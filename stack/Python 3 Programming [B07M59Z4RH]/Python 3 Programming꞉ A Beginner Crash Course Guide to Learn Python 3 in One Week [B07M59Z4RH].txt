This is Audible.
Python 3 Programming. A Beginner Crash Course Guide to Learn Python 3 in One Week.
Written by Timothy C. Needham.
Narrated by Zach Ulleman.
Table of Contents.
Introduction.
Chapter 1. An Introduction to Python.
Running Python.
Installing on Windows.
Installing on Other Systems.
Choosing the Right Version.
Learning While Having Fun.
Choosing to Code.
Using a Text Editor.
Using an Integrated Development Environment.
Getting Started.
Creating Your Own Files.
Chapter 2. How to Design a Software.
Design Your Software.
Asking the Right Questions.
How to Use Python to Solve Problems.
Identifying the Problem.
What Must the Software Do?
Who Will Use the Software.
What Systems Will Be Used.
Define the Program.
Understanding the Audience.
Watching Users.
Compiling User Stories.
Identifying the Solution.
Understanding the Problem.
Understanding what the Software Needs to Do.
Considering Limitations.
Defining the Results.
Refining the Program.
Refining the Program.
Breaking the Solution Down.
Organizing Tasks into Steps.
Using Subgroups and Indentation.
Coding the Design.
Turning the Design into Executable Code.
Refining the Design.
Testing the Design.
Breaking Down the Jargon.
Chapter 3.
Data Types and Variables.
Choosing the Right Identifier.
Python Keywords.
Understanding the Naming Convention.
Creating and Assigning Values to Variables.
Recognizing Different Types of Variables.
Working with Dynamic Typing.
The None Variable.
Using Quotes.
Nesting Quotes.
How to Use Whitespace Characters.
How to Create a Text Application.
Working with Numbers.
Computers Only Count to One.
Using Boolean.
Using Whole Numbers.
Performing Basic Mathematical Operations.
Working with Floats and Fractions.
Converting Data Types.
Breaking Down Jargon.
Chapter 4.
Conditional Statements.
How to Compare Variables.
Manipulating Boolean Variables.
Combine Conditional Expressions.
The Assignment Operator.
How to Control the Process.
How to Deal with Logical Errors.
Using the Conditional Code.
Loops.
While Statement.
Nesting Loops.
Nesting Loops.
Breaking Down Jargon.
Chapter 5.
Data Structures.
Items and Sequences.
Tuples.
Creating a Tuple.
Changing Values in a Tuple.
List.
Creating a List.
Modifying a List.
Stacks and Cues.
Dictionaries.
Dictionaries.
Breaking Down Jargon.
Chapter 6.
Working with Strings.
Splitting Strings.
Concatenation and Joining Strings.
Editing Strings.
How to Match Patterns.
Creating a Regular Expression Object.
Chapter 7.
How to Use Files.
How to Open Files.
Modes and Buffers.
Reading and Writing.
Closing Files.
Chapter 8.
Working with Functions.
Defining a Function.
Defining Parameters.
Documenting Your Function.
Working with Scope.
Understanding Scope.
Manipulating Dictionaries and Lists.
Abstraction.
Chapter 9.
Solutions.
Concatenate Two Strings.
Sum of Two Numbers.
Even and Odd Numbers.
Fibonacci Series.
Palindrome.
Access Elements in a List.
Slice a List.
Delete Elements in a List.
Access Elements in a Tuple.
Change a Tuple.
Create a String.
Conclusion.
Other Books by Timothy C. Needham.
Did you enjoy this book?
Sources.
Introduction.
Introduction.
Have you always wanted to learn how to program in Python?
If the answer to that question is yes, you've begun one of the greatest adventures of this century.
It's easy to program since there's no specialized equipment that you need to purchase to run the programs.
All you need is the right version of the software, a good computer, and operating system.
You can learn to program from the comfort of your own home.
Python is one of the best languages with which one can learn how to program.
There are multiple reasons why, but the simplest explanation is that Python is easy to read and write.
It does not take too much time to write a working code since the language has a simple syntax, which makes it easy to write the code.
This book acts like a guide for a beginner.
This book provides information on how one should code when using Python and what attributes of Python can be used to make the program simple.
You can never trust someone who says they know everything about programming.
New versions of Python are built regularly to improve the user experience.
This book provides information on different aspects of the language and will help you learn more about different structures and functions in Python.
You have to keep in mind that the more you learn about programming, the better you get at it.
You'll learn different ways to adapt your programming style to overcome some problems.
There are a few exercises that have been given in this book to help you improve on writing code.
I urge you to try to write the code before you look at the solutions that have been provided in the last chapter.
I hope you enjoy the journey you're about to begin.
Power up that computer and prepare yourself for a few solid hours of programming.
Also, the only thing I ask is that if you could please leave a review after listening to this book on the Audible site.
Chapter 1. An Introduction to Python
Before we continue, please refer to your audiobook companion PDF that comes free with your purchase of this audiobook
to see and learn all the codes explained with charts and images.
Running Python
Python is a software that can be installed and run on multiple operating systems including Mac OSX or OS2, Linux, Unix, and Windows.
If you're running Python on GNU, Linux, or Mac OSX, you may already have the software installed in the system.
It's recommended to use this type of system since it already has Python set up as an integral part.
The programs in this book work on every operating system.
Installing on Windows
If you're using Windows, you'll need to install Python and configure certain settings correctly
before you start working on the examples given in this book.
To do that, you must refer to specific instructions provided for your operating system on the following Python webpages.
HTTP colon forward slash forward slash wiki.python.org forward slash moin forward slash beginnersguide forward slash download
HTTP colon forward slash forward slash www.python.org forward slash doc forward slash FAQ forward slash windows
alternative versions for AMD and Itanium machines are available at
This file, which has a .msi extension, must be saved at a location that you can find easily.
You can then double-click on this file to start the Python installation wizard, which
will take you through the installation.
It's best to choose the default settings if you're unsure of the answers.
Installing on other systems You may choose to install Python on other
systems if you want to take advantage of the latest versions of Python.
The instructions for Unix-like and Linux systems can be found at the following links.
If you're using OSX, your instructions are here.
www.python.org
and http colon forward slash forward slash docs.python.org forward slash dev forward slash 3.0 forward slash using forward slash mac dot html.
Choosing the right version Different installers include different numbers after the word Python that refer to the version number.
If you look at the archives on multiple websites, the version numbers will range from 2.5.2 to 3.0, where the former is an old but usable version of Python while the latter is the latest version.
The Python team released version 2.6 at the same time that it released version 3.0, since there are some people who still may want to stick to the version 2 of Python since they want to continue to write code the old way, but still want to benefit from the general fixes and some of the new features introduced in version 3.0.
The Python language is continuously evolving.
Version 3.0 has become the norm and has evolved into version 3.1.1.
The newer versions of 3.0 are refinements of version 3.0.
Therefore, the newer versions will continue to be referred to as 3.0 in this book.
Version 3.0 includes several changes to the programming language that are incompatible with version 2.0.
You do not have to worry about programming using different versions of Python since there is only a subtle difference in the language or syntax.
There may be some differences running Python on other operating systems, which will be pointed out in the book wherever necessary.
Otherwise, the codes in this book will work in the same way across different operating systems.
This is one of the many good points of Python.
For the most part, this book will concentrate on the fun part, learning how to write programs using Python.
If you wish to learn more about Python, you should read the documentation prepared by the developers, which is free and well written.
It's available at http colon forward slash forward slash www.python.org forward slash doc forward slash.
Learning while having fun.
On most occasions, people don't want to have fun when they work on technical disciplines since fun is underestimated.
Every human being only learns a subject well when he or she is having fun with it.
Developing software using Python is often an engrossing and enjoyable experience, partly because you can test out your changes as soon as you've made them without having to perform any intermediary steps.
Unlike many other languages, Python takes care of most background tasks, making it easier for you to focus on the code and the design of your code.
This makes it easier for the user to stay in the creative flow and continue to develop and refine the program.
Python is easy to read and is one of the many languages that use a syntax that is closer to English.
Therefore, you spend less time trying to understand what you've written, which means that you have more time on hand to understand how the code can be improved and how you can expand the code to encompass different aspects.
Another good thing about Python is that it can be used to complete any task, regardless of how big or small the task may be.
You can develop simple, text-driven or numerical-based programs as well as major graphical applications.
There are some limitations to the language, but before you identify them, you'll have already become adept at programming that will help you know how to work around that limitation.
Choosing to code
Using a text editor
People often choose to create or write Python scripts using plain text editors that have basic programming features.
Programs like Kate, NetIt, GetIt, BeBedIt, and Notepad, preferably Notepad 2 forward slash plus plus, are the best ones to use for this task.
Multiple editors are available that offer specific enhancements for programmers, such as syntax highlighting, which is useful for showing coding errors immediately as you type.
Old-school programmers may choose to use Emacs or Vi.
The language does not require specific software that needs to be used to create the code.
That choice is up to you.
Do not attempt to use word processing software such as Word or OpenOffice for this task.
It will mess up badly.
Using an integrated development environment
An integrated development environment, or IDE, is a graphical interface with lots of useful features designed to make programming with Python even easier.
You still have to type the code in the same way, but you can do all of your coding using a single application, and these programming environments can provide some useful shortcuts and reminders.
There are now several Python-specific IDEs.
Popular applications include Idle, which is bundled with Python itself, Eric, you may notice a theme here, nudge-nudge, wink-wink, say no more, Gini, Dr. Python, and SPE.
More general programming environments like Bluefish and a whole host of others also support Python.
This book doesn't cover the use of IDEs or any of the alternative distributions of Python because each of these approaches would require a chapter unto themselves at the very least.
However, the examples contained in this book will work if you choose to explore those options.
This book will take the simplest approach, using tools that come as standard with most operating systems, that is, a text editor and a Python interactive shell.
Getting Started
When you sit down to write a new program, you must remember that it starts with a problem.
Before you write code for anything, you have to develop an idea of what it is that you would like to create and the problem that you're looking to solve.
This will help you develop a fair idea on how you would like to solve the problem.
Over the course of the next chapter, we'll look at the software development cycle which will help you through the process of designing the software.
This is a step that most people will need to learn separately since most programming guides usually switch to the intricacies of the language
and focus on how to develop code which can make it difficult for a beginner to understand how to understand the code and what needs to be done to fix that code.
Understanding the principles of software design can dramatically speed up the process of creating new software and help ensure that important details are not missed out.
In subsequent chapters, you'll learn to build the designs and ideas in Python and learn to construct the basic units of the codes using words, data and numbers.
You'll also learn how to manipulate these inputs to refine the code.
It's important to learn how to compare different sets of data to make informed decisions.
Over the course of the book, you'll learn to refine the designs you've created and break them down into portions that can be coded easily.
These steps will help to expand your understanding of the language and help you turn your ideas into complete computer programs.
Creating your own files
Python is described as a self-documenting language. It does not mean that the user manual is written for you by Python.
However, you can add documentation strings which are defined as blocks of text to your script or code.
These documentation strings will show up when you open your code that can then be turned into web pages that provide useful references to those looking for similar code.
An example of documentation strings has been provided in the subsequent chapters and it is important to learn to include documentation strings in your code at an early stage.
If you're enjoying this audio book, I would love it if you went to Audible and left a short review.
Chapter 2. How to Design a Software
Before we continue, please refer to your audiobook companion PDF that comes free with your purchase of this audiobook to see and learn all the codes explained with charts and images.
If you were like most programmers, you would have jumped to the third chapter to learn more about how to build a program and may have bumped into an issue.
However, this chapter will help you turn your problem into a working program.
Design your software
There are multiple reasons why one may want to write his or her own code to develop an application that does exactly what you want it to do.
You may already have an idea of something you wish to achieve which led you to pick up this book in the first place.
You may need to develop a solution for work, you may have an amazing idea in mind that you want to develop, or you may want to perform some analyses using Python.
You may already have the program you need, if only it would do this one extra thing, or maybe you just enjoy the idea that writing your own software is possible.
The first step you should take is to ask questions. You must never refrain from asking the right questions.
There are times when you may wonder why you should make the effort to ask people questions since there are some people who believe that they should dive right into writing code without wasting any time.
It is important to break the idea down into smaller fragments to develop a well-structured idea.
This will help you develop a strong code.
You have to remember that what you are trying to do is make your life easier.
Asking the right questions
It is important to ask yourself why you are developing every module, function, project and line of code.
You must ask yourself this right before you begin the process.
There is a possibility that someone out there has already written the code you want to develop or at least has written something very similar to it.
You can use this code and convert it to suit your needs.
You have to also ask yourself if there is a simpler way to work on the problem.
Every programmer must learn to be lazy since that helps him or her identify a simpler way to work the code.
That way you won't have to work on the program from scratch and you won't need to learn everything from scratch.
Most programmers tend to learn as they go along but the art of programming does not have too much to do with memorizing code.
Instead you must identify the logical procedure and simplify the concept you have in mind.
The first task is extremely simple in the sense that you must only ask the right questions to break your idea down.
However, you will encounter more complex problems as you progress and will also learn to develop ideas of your own.
How to use Python to solve problems
Programmers use a language called pseudocode to design software and Python is one of the only fee languages that are synonymous with pseudocode.
The difference here is that you can run the code written in Python to obtain a result.
This language is easy to read, does not require compiling and is fun to learn.
Your scripts can be run immediately once you have saved them since you do not need to call upon a compiler or any other function to run the script.
Unlike other languages, Python can be used to solve a wide range of problems easily since there are many pre-constructed functions or modules that deal with the menial computer tasks.
Experts have said that Python is similar to playing with building blocks since the elements of the language are easy to grasp and they can be combined in any way possible to create a graceful and complex structure.
A great feature of Python is that it is a self-documenting language.
You have to write the documentation yourself, but blocks of text called documentation strings or doc strings can be included within the structure of the program.
This feature is used by most programmers to keep the design ideas in one file that helps them to think about the program and work on the code as they go along.
You can also take a look at your old code and understand what it was you were trying to achieve when you had written that code.
These doc strings will help you and other programmers understand how your program functions and what the need for such a program is.
Identifying the problem
Before you start coding anything, you need to have an idea or a problem that you wish to solve.
It's quite useful to start with a familiar repetitive task that you suspect could be performed more efficiently using a simple script.
Your first problem is to find out how to communicate with your computer using Python and how to get your computer to communicate back.
Using this as an example, I will briefly explain the stages of the software development cycle that most programs will go through in the course of their development.
You don't have to slavishly follow all the suggestions in this chapter, but you may find that they provide a useful structure for developing more complex applications and to get you back on track if you find yourself getting lost.
It's also useful to be able to design your program before having to think about the details of coding it in a formal computer language.
The first stage of writing any new program is to grow a design out of the initial problem, a sequence of actions that will calculate the correct result and create the required output.
Once an idea has passed the why bother test, it's necessary to create a simple framework on which to hang the various bits of code that you come up with.
Without such a framework, it's virtually impossible and difficult to construct a simple script.
We often tend to complicate the code and are left with a messy code in the end.
The great news is that no specialized knowledge is required at this stage.
The process can be started off by answering a few simple questions.
What do you want the software to do?
Who will be using it?
And what system will users be running it on?
What must the software do?
You have to first write the problem you want to tackle down and why you want to solve that problem.
This step will help you to understand what it is that you want the software or code to do.
You can use a simple text editor for this step.
Start with some simple tasks that you know a computer can do, like adding a few numbers or updating strings or catalogs.
It's difficult to identify the problem in the beginning.
It's important to understand the problem better so you can identify the solution.
Save the file as a plain text with the .txt extension and give it the title of your program to be.
In the next chapter, you'll learn to write a code to get your computer to print a statement on your output window.
Who will use the software?
You must then specify your target audience, regardless of whether you're doing it for yourself.
Write your target audience down and make a list of every person who will use this program.
Family, relatives, friends, workmates, clients or anonymous users, registered users.
How do you want the audience to interact with the application you've built?
Use a text interface, click a single button, answer a complex form.
Do you need this audience to be adept at programming?
Should the application be self-explanatory?
Will they need to learn the ropes?
What systems will be used?
You have to know if the program you build will work on different operating systems.
If you want it to run only on one operating system, you must let the users know.
The program you build may also be accessed by clients through different types of systems through internet applications
and can use different hardware or software in the device.
You have to also let the users know if they must download or install software for the computer to decode your script or program.
These questions are important to answer at the initial stages of development since they have a huge impact on the process in the future.
Keep your answers simple at this stage, but make sure you answer most of them since you'll be prepared for any challenges or obstacles.
If you can't answer some of the questions yet, that's fine too.
This chapter will help you break your answers down into simpler steps.
But before you move to that step, you must ask the right questions.
Define the program
It can be useful to create a list of the things you want the software to do and what it is you want to achieve by building the software.
You may need to analyze the procedures you'd be using and also understand the tasks that you'd be taking up deeply.
It's useful to examine a task that you have already performed before.
This can be a task that you have not automated in the past.
The following sections will help you generate the list of tasks you must complete to finish your design.
Understanding the Audience
Understand how your target audience performs the tasks that you've listed down.
Sit with them and learn about the sections of the task they want to automate and understand the factors that they would like to control.
You have to also make a list of factors that the audience finds confusing and understand how you can help them overcome those difficulties.
There are some people who use a short questionnaire, even if it's them answering the questions since the answers will help you gain an idea on the problem at hand.
You can ask for some detailed answers in the questionnaire to understand what your target audience wants the application to look like and how they want it to behave.
You must also understand what file formats they expect to use to read information from and save it out to, particularly covering any unique or special considerations that you can imagine.
File formats could include HTML, XML, and plain text for text documents, or your users might have images saved as PNGs or JPEGs, audio files WAV that they may want to convert to MP3s.
A file extension, the letters after the last dot in the file name, usually provides a clue as to what format the file is in, though there are other ways of finding out this information.
Through this exercise, you'll understand how the task is often performed and the information you need to collect before you start the process.
You do not need to develop an example or a prototype of the code at this stage since it's invaluable.
It's better to have a code written down.
You can tweak this code as you go along.
Watching users
As a developer, you can take the liberty to watch the audience carry out the task and make notes while the tasks are being performed.
You do not need a lot of detail at this stage since you only need to gather information that will help you develop your code or software.
The alternative approach would be to put yourself in your audience's position and walk through the task.
Another technique is to collect up all the pieces of paper that go into or come out of the process and use them to create a storyboard.
It is true that this step is more relevant in the future, but it's better to get into the habit of working on this step now.
Compiling User Stories
A user story consists of one or two lines in everyday language that specifies something that the user wants from the software.
The idea is that stories should be brief enough to fit on an index card, on a sticky note, or into one cell of a spreadsheet.
A user story should indicate the role of a user, what that user wants the software to do, and what benefit might be gained from it.
User stories are prioritized by the user to indicate which features are most important and are then used to work out an estimate of the time it will take to develop those features by the developer.
The developer may then create use cases out of these stories and tests to determine whether these requirements have been fulfilled.
Use cases are longer, more detailed descriptions of features that are required by specific users in specific situations.
You just need enough information to work out the basic functionality that will be required from the program that you're about to write.
Try to keep it concise.
Identifying the Solution
Armed with all of this information, let's return to the text file to complete the first stage of the software design.
The design stage can often be the most time-consuming part of the programming process.
It consists of several stages in which the output from one stage becomes the input of the next.
Often the output from one or more stages is fed back through the same process several times.
This process that happens inside the program is termed as recursion.
Every software design cycle has a similar recursive nature.
So, let us go back to our initial problem now.
Understanding the problem
This time around, you're going to fill in a little more detail and turn your text file into a very simple user requirements document.
In a professional situation, this would become the agreement between the programmer and the client who is paying for the software to be written.
For now, you're just going to use it as a means to keep a record for the original purpose of this software.
Make sure that the problem is stated clearly and that you have identified the issue you wish to resolve correctly.
Often, there can be hidden subtleties in the problem that look straightforward when written in your natural language,
but require additional clarification when you come to turn them into a programming language or code.
If the problem is not defined well enough to make a decision at that point,
you'll need to return to this stage and clear up the details before you can make any further progress.
Understanding what the software needs to do
The things you want the software to do are known as functional requirements in the trade.
Simple examples include printing a message, adding up some numbers, or sending an email form.
You might have additional details to add.
For example, maybe the user must be able to input some text, numbers larger than 200 cannot be entered,
or the update must be performed over the internet.
Functional requirements specify how a system should behave.
For your first exercise, hello world, you'll be asking the software to print out a simple message,
so your first functional requirement is that the computer should print out a message.
Considering limitations
You may also want to include other needs or limitations of the software which are called non-functional requirements.
The remaining constraints are defined by the non-functional qualities and requirements of the software,
like cost-effectiveness, accessibility, and compatibility with other operating systems, performance, and usability.
You do not have to worry about these aspects if you're developing a code for yourself.
Defining the results
You need to give some thought as to how the software will be tested.
Early on, it'll be enough to simply run the program and see if it works,
but as your scripts grow in complexity, you'll find it useful to formalize the methods used for testing.
It may be worth finding or creating some data to use as an example for testing purposes,
and you may find it useful to create a table of values that you expect to find at various points in the process.
In Chapter 11, I'll be showing you how to create built-in test suites,
which can make a large part of the process automatic.
It's generally considered good practice to write your tests before you do any coding,
but it often happens that the tests and code actually get written at the same time.
For now, a note of the expected output will do fine.
Refining a program
Any piece of software that is going to be used more than once will require some degree of maintenance.
Issues that are worth thinking about early on are how the software might need to change in the future
and how to keep track of issues.
You might also consider how the application is going to be kept in working condition
while you're integrating new possibilities and responding to new challenges.
In many cases, the application will be maintained by the person who wrote it,
but it is good practice to organize your project and write your code in a way that makes it easy for someone else to understand what you've done
and contribute fixes and new features.
One day, you might want to pass on the responsibility of keeping it up to date to someone else.
To facilitate maintenance, the software should include some means of contact,
such as the author's email address so that users can get in touch if there are any problems.
For now, just note your email address.
Later on, I'll show you how you can integrate this information into your code
so you don't have to retype this information every time you want to use it.
A principle of the programming that you must keep in mind is, don't repeat yourself.
This principle states that every piece of information must have an unambiguous, simple, and authoritative representation in the system.
No piece of information should ever have to be typed in twice.
If you find yourself doing this, it's a sure sign that some part of your script needs redesigning.
Let us take a look at the hello underscore world TXT program.
Problem
Get the computer to output a message.
Target users
Me
Target system
GNU
Linux
Interface
Command Line
Functional requirements
Print out a message
User must be able to input some text.
Testing
Simple run test
Expecting a message to appear
Maintainer
Maintainer
Maintainer
Website.com
Breaking the solution down
Next, you start the process of turning your wish list into a program.
In this stage, you'll design a logical flow of actions which will hopefully produce the desired outcome.
First, you need to turn the text file into something the Python interpreter can understand by saving it as a Python or .py file.
Use the save as function in your text editor to save the file with the same name, but this time with a .py extension.
This example will become hello underscore world .py.
Now, the interpreter needs to know what this text is. Otherwise, it'll attempt to interpret the first thing it finds as a command. There are a variety of ways of marking out blocks of text as comments or text strings so that the interpreter doesn't attempt to execute them.
Comments
Comments
The hash symbol, or hashtag, is used to mark comments. Comments are completely ignored by the Python interpreter. All text between the hash sign and the end of the line is ignored.
Comments
This formatting is a convenience so you, the programmer, can write little notes to yourself to remind yourself what this part of the code is supposed to do or to flag parts of the code that need attention.
These comments will only ever be seen by people who are actually reading the code. If you're writing software as part of a team, comments are a great way of communicating your thoughts and intentions to the other programmers.
Good code can often contain more comments than actual lines of code. Don't be tempted to remove them once you've coded the design. In a month's time, you're likely to have completely forgotten what this script was intended to do, and you'll be thankful for these little reminders.
Text Strings
Text strings are delimited by quotation marks. Delimited means the text is enclosed between a matching pair of the specified characters.
Python uses a variety of forms of quotation marks, typically single and double quotation marks.
There is a subtle difference between the two forms, which I'll cover in detail in this section on Text Strings in Chapter 3.
The main reason for different forms is to allow nesting of quotes.
Nesting means putting one inside the other, like this.
Open double quotation. What on earth does open single quotation nested delimiters close single quotation mean question mark close double quotation? She asked.
Like comments, quotation marks only work if the text is all on one line.
Fortunately, there are a variety of ways to get the interpreter to ignore line breaks.
In this example, I shall use the technique of triple quoting, which is explained in later chapters.
Organizing tasks into steps
Now, you are prepared to start designing your program.
The program design is initially sketched out in pseudocode, which is the design language that can be used as an intermediary step to turn the user requirements document into a piece of Python code.
There is nothing special about the form of this language.
Your own natural way of expressing ideas is exactly what is needed in this situation.
Pseudocode is simply a series of logical statements in your own words that describe the actions that the program needs to take in order to produce the desired result.
If you're working as part of a team, your company may have a standard way of writing pseudocode, but you don't need to worry about such considerations when you're learning.
Over time, you're likely to find that your pseudocode naturally adopts a Python-like syntax.
Initially, the important thing is that you can express your ideas clearly without having to worry about the rules of the language yet.
Using subgroups and indentation
Python is very strict about indentation.
Python regards any space or tab at the start of a line as an indentation.
Every indentation means something.
Without going into too much detail at this stage, pay careful attention to how indentation is used in the examples.
The most important thing to remember is not to mix tabs with spaces as the interpreter thinks these are two different things, even if they look the same to you.
In your text editor's preferences window, set it to insert four spaces instead of using tabs, and you'll avoid so much future grief by doing this.
It is always best to keep your designs clear and readable.
Use blank lines to separate the different sections of your pseudocode and use indentation to show how statements are grouped together.
As long as each line is a comment preceded by a hash symbol, you're free to format it how you like.
Coding the design
Now you're ready to start turning your design into proper Python code.
Great!
The data your software will be manipulating will take various forms.
These values are assigned to things called variables, which you can think of as a box or a bucket that contains a single piece of information, often a word or number.
Some people find it useful to think of them as slates that can be written on with chalk.
The important thing is that the information in the container can be changed by putting a new value into it.
This automatically wipes out the old value and replaces it with a new one.
The fact that these values can be changed gives rise to the term variable.
There are two stages to creating a variable.
The first is to create the container and stick an identifying label on it.
This is called initialization.
The second is to put a value into it.
This is called assignment.
In Python, both these things happen in the same statement.
Assignment, and therefore initialization, is performed using the equal sign like this.
Variable equals value
One of the specific features of Python is that once a value has been assigned to a variable, the interpreter will then decide what sort of value it is, i.e. a number, some text, or some other relevant piece of information.
Each variable is referred to by a name, known as an identifier, which is rather like a name tag that identifies the variable to the rest of the program.
It's a good idea to choose names that give you an idea of what sort of values they represent.
Python will regard any word that has not been commented out, delimited, or escaped in some other way as either a command or an identifier.
For this reason, you need to be careful to avoid choosing words that are already being used as part of the Python language to identify your new variables.
Details of which words you cannot use will be covered in the next chapter.
Turning the design into executable code
Now, you have to come up with a strategy for solving the problems you have agreed to tackle.
First, you want to print out a message, and you want the user to be able to input some text.
OK, so you're expecting your message and user's text to be strings of text.
It would be a very good idea to add this information to the testing section of your doc strings at the start of the file.
Text strings are represented by enclosing the text in quotes.
Now, you just need to know the function that prints things out to the screen, which is called print open parentheses close parentheses in Python.
So, your first problem translates fairly easily into executable code as you can see in listing 2-5.
You can print any text you like.
Hello World is the default.
Let us take a look at the first version of the hello-world.py program.
Problem
Get the computer to output a message.
Target Users
Me
Target System
GNU-Linux
Interface
Command Line
Functional Requirements
Print out a message
User must be able to input some text
Testing
Simple run test
Expecting a message to appear
Expecting colon message equals equals input text
Maintainer
Maintainer at website.com
Double quotes, double quotes, double quotes
Hash symbol
1
Print out a friendly message
Print
Open
Parentheses
Open
Hello World
Exclamation point
Close quote
Close parentheses
Hash symbol
2
Input
Some text
Hash symbol
3
Print out the text we just entered
This script can be run by typing
Dollar sign
Python
Hello
Underscore
World
The only line in this script that is actually executed by the interpreter is print hello world
Everything else is either ignored as a comment or assumed to be a doc string in the case of the block of text at the beginning
If you change the text between the quotes in the call to the print function, the Python interpreter will print out whatever you tell it to
Well done! You just wrote your first Python program. It's about as basic as can be, but you can now bask in the satisfaction of having gotten Python to do something
Refining the design
Constantly editing the script to get it to say something different quickly becomes rather tedious
Wouldn't it be great if the program were interactive? In that case, you would need to find a way to get some user input
The quick and dirty method of doing this is to use the built-in input function
This function takes one argument, a text string that is printed to the screen to prompt the user for input
The function then returns the user's input
All requests for input need a message to tell the user that input is required
This is known as a prompt
I assign this input to a variable called sum underscore text
Then I can use the print function to print out the user's input
Notice that this time sum underscore text isn't in quotes because I want the value contained in the variable called sum underscore text rather than the literal text string
Open quotation marks
Variable names aren't allowed to contain spaces, so you'll notice that I've replaced the space with an underscore
It's worth remembering that variable names can't contain dashes either because Python will assume that the dash is a minus sign
Details of how to name your variables will be covered fully in Chapter 3
Testing the design
Now it's time to save the file again and test it by running the script with the Python interpreter as before
If you get any error messages at this stage, you probably made a mistake typing the script
Common errors include missing quotation marks or spaces in the wrong places
In this case, you'll need to go back to the coding stage and correct these errors before you test the code again
The testing stage involves making sure that the design does what it's supposed to do and that it matches the specification that you started with
Compare the actual output from running the program to the output you said you were expecting in your original specification
Are they the same? If not, why not? What could be done better?
Apart from the initial design stage, you'll probably spend most of your time cycling around this testing stage
Don't be tempted to view error messages as annoyances or irritations
Pay great attention to what they tell you as they can be one of the most useful aids on the path to learning Python
On some occasions, you'll want to deliberately produce error messages to prove that something is working
Try it now
Find out what you have to mess up to get an error message
Take note of what sort of message you get and fix your script so that it runs cleanly again
Breaking down the jargon
Some terms that were introduced in the chapter are
Argument
This is a value you pass to a function or to a procedure so it has some data to work with
Assignment
This is the operation of setting a variable to a value
Delimiter
This punctuation mark is typically used to separate a text string or other piece of data from surrounding characters
Escape
This is a method of indicating that the next character in a text string should be processed in a different way
Function
A function is a block of code that performs a calculation, accepts zero or more arguments, and returns a value to the calling procedure when it's complete
Indentation
This refers to the use of spaces and tabs at the start of a line of code or text, except you want to use spaces rather than tabs, remember?
Identifier
This is a user defined name. Both function names and variable names are identifiers. Identifiers must not conflict with keywords
Initialization
This process sets the initial value of a variable. Initialization is done only once for each variable when that variable is created
Module
A module is a Python program that can be imported by another program. Modules are often used to define additional functions and classes
Nesting
Put one piece of code inside another similar construct
Non-functional requirements
These are needs or limitations of the software that are not specifically about what the software will do
Program implementation
This is the actual realization of the program as opposed to the design
Prompt
This string of text or punctuation marks indicates that the user needs to input some information or commands
Pseudocode
This program design language is intended to be read by humans, not performed by a computer
Return
This refers to the process of transferring execution from a function back to the place from which that function was called in the main program
The return statement can also pass a value back to the main program for use in further calculation
Statement
This instruction to do something in a programming language manipulates a piece of data, performs a calculation, or produces some output
String
String
This refers to a line of text or other characters intended to be displayed or processed as a single item
Top level design
This is the first stage of a design and it provides a summary or general description of the actions that the software is intended to perform
User story
A user story consists of one or two lines in the everyday language of the user that specifies something desired from the software
Validation
This process tests whether a value is what the programmer expects it to be
Variables
Use variables as a means of referring to a specific item of data that you wish to keep track of in a program
It points to a memory location which can contain numbers, text, or more complicated types of data
If you're enjoying the audiobook, I would love it if you went to Audible and left a short review
Chapter 3 Data Types and Variables
Before we continue, please refer to your audiobook companion PDF that comes free with your purchase of this audiobook to see and learn all the codes explained with charts and images
In the last chapter we learned that an identifier is part of a variable, which is a unit of data
These variables and identifiers are held in the computer's memory and their value can be changed by making a modification to a value that is already present in the variable
This chapter will introduce you to the different types of variables that you can use when writing a program in Python
You'll also learn how these variables can be used to convert your designs into working codes using Python
This is when you begin real programming
Over the course of this chapter we will work on two programs
One where we'll learn to format and manipulate text strings
And another to perform a simple mathematical calculation
The programs mentioned above can be written easily using different variables
When you use variables, you can specify a function
A method of calculation that must be used to obtain a solution without the knowledge of the type of value that the variable must refer to in advance
Every piece of information that must be put into a system needs to be converted into a variable before it can be used in a function
The output of the program is received only when the contents of these variables are put through all the functions written in the program
Choosing the right identifier
Every section of your code is identified using an identifier
The compiler or editor in Python will consider any word that is delimited by quotation marks, has not been commented out, or has escaped in a way by which it cannot be considered or marked as an identifier
Since an identifier is only a name label, it could refer to just about anything
Therefore it makes sense to have names that can be understood by the language
You have to ensure that you do not use a name that has already been used in the current code to identify a new variable
If you choose a name that is the same as the older name, the original variable becomes inaccessible
This can be a bad idea if the name chosen is an essential part of your program
Luckily, when you write a code in Python, it does not let you name a variable with a name used already
The next section of this chapter lists out the important words, also called keywords in Python, which will help you avoid the problem
Python Keywords
The following words, also called keywords, are the base of the Python language
You cannot use these words to name an identifier or a variable in your program since these words are considered the core words of the language
These words cannot be misspelled and must be written in the same way for the interpreter to understand what you want the system to do
Some of the words listed below have a different meaning, which will be covered in later chapters
False
None
Assert
True
As
Break
Continue
Def
Import
In
Is
And
Class
Del
For
From
Global
Global
Raise
Return
Else
Elif
Not
Or
Pass
Accept
Try
While
With
Finally
If
Lambda
Non-local
And
Yield
Understanding
Understanding the naming convention
Let us talk about the words that you can use and those you cannot use
Every variable name must always begin with an underscore or a letter
Some variables can contain numbers but they cannot start with one
If the interpreter comes across a set of variables that begin with a number instead of quotation marks or a letter, it will only consider that variable as a number.
You should never use anything other than an underscore, number, or letter to identify a variable in your code.
You must also remember that Python is a case-sensitive language, therefore false written with a lowercase and false written with uppercase are two different entities.
The same can be said for v variable all lowercase, v variable starting with an uppercase, and v variable with two uppercase v's.
As a beginner, you must make a note of all the variables you use in your code. This will also help you find something easier in your code.
Creating and assigning values to variables
Every variable is created in two stages. The first is to initialize the variable and the second is to assign a value to that variable.
In the first step, you must create a variable and name it appropriately to stick a label on it, and in the second step you must put a value in the variable.
These steps are performed using a single command in Python using the equal to sign.
When you must assign a value, you should write the following code.
Variable equals value
Every section of the code that performs some function like an assignment is called a statement.
The part of the code that can be evaluated to obtain a value is called an expression.
Let us take a look at the following example.
Length equals 14
Breadth equals 10
Height equals 10
Area underscore triangle equals length asterisk breadth asterisk height
Any variable can be assigned a value or an expression like the assignment made to area underscore triangle in the example above.
Every statement must be written in a separate line.
If you write the statements down the way you would write down a shopping list, you're going the right way.
Every recipe begins in the same way, with a list of ingredients and the proportions along with the equipment that you would need to use to complete your dish.
The same happens when you write a Python code.
You first define the variables you want to use and then create functions and methods to use on those variables.
Recognizing different types of variables
The interpreter in Python recognizes different types of variables, sequences or lists, numbers, words or string literals, booleans and mappings.
These variables are often used in Python programs.
A variable none has a type of its own called none type.
Before we look at how words and numbers can be used in Python, we must first look at the dynamic typing features in Python.
Working with dynamic typing
When you assign a value to a variable, the interpreter will choose to decide the type of value the variable is, which is called dynamic typing.
This type of typing does not have anything to do with how fast you can type on the keyboard.
Unlike other languages, Python does not require that the user declare the types of variables being used in the program.
This can be considered both a blessing and a curse.
The advantage is that you do not have to worry about the variable type when you write the code, and you only need to worry about the way the variable behaves.
Dynamic typing in Python makes it easier for the interpreter to handle the user input that is unpredictable.
The interpreter for Python accepts different forms of user input to which it assigns a dynamic type, which means that a single statement can be used to deal with numbers, words or other data types,
and the user does not have to always know what data type the variable must be.
Not needing to declare variables before you use them makes it tempting to introduce variables at random places in your scripts.
You must remember that Python won't complain unless you try to use a variable before you've actually assigned it a value,
but it's really easy to lose track of what variables you're using and where you set up their values in the script.
There are two really sensible practices that will help keep you sane when you start to create large numbers of different variables.
One is to set up a bunch of default values at the start of each section where you'll be needing them,
keeping all the variables that you're going to use together in one part of the text like an ingredients list.
The other is to keep track of the expected types of values of your variables,
keeping a data table in your design document for each program that you're writing.
Python needs to keep track of the type of a variable for two main reasons.
Chiefly, the machine needs to set aside enough memory to store the data,
and different types of data take up different amounts of space, some more predictably than others.
The second reason is that keeping track of types helps to avoid and troubleshoot errors.
Once Python has decided what type a variable is,
it will flag up a type error if you try to perform an inappropriate operation on that data.
Although this might at first seem to be an unnecessary irritation,
you'll come to discover that this can be an incredibly useful feature of this language,
as the following command line example shows.
greater than greater than greater than greater than,
greater than greater than,
greater than, greater than,
greater than, greater than,
SLOND Fermor
close parentheses, colon, file, double quotation mark, double quotation mark, comma, line one,
comma, in, less than, module, greater than, type error, unsupported operand type, open
parentheses, s, close parentheses, for, plus, colon, single quotation, int, single quotation,
and, single quotation, s, t, r, single quotation, greater than, greater than, greater than, c, hyphen,
trace, traceback, open parentheses, most recent call last, close parentheses, colon, file, double
quotation, double quotation, comma, line one, comma, in, less than, module, greater than, type error,
colon, unsupported operand type, open parentheses, s, close parentheses, for, hyphen, colon, single
quotation, s, t, r, single quotation, and, single quotation, b, o, o, l, single quotation. The program
above tries to perform operation on data types that are incompatible. You're not allowed to add a number
to a word or take a yes, no answer away from it. It's necessary to convert the data to a compatible
type before trying to process it. You can add words together or take numbers away from each other,
just like you can in real life, but you can't do arithmetic on a line of text. The tracebacks are
Python's way of alerting you to a potential error in your logic, in this case, a type error. This tells
me that I need to rewrite the code to make it clear what type of information I want to put in and get out
of the equation. The purpose of data types is to allow us to represent information that exists in the
real world, that is, the world that exists outside your computer, as opposed to the virtual world
inside. We can have the existential conversation about what is real and what is not some other time.
The previous example uses variables of type int, whole numbers, and type str, text. It will quickly
become apparent that these basic data types can only represent the simple units of information.
You may need to use quite a complicated set of words, numbers, and relationships to describe
even the simplest real-world entity in virtual world terms.
Python provides a variety of ways of combining these simple data types to create more complex
data types, which I'll come to later in this book. First, you need to know about the fundamental
building blocks that are used to define your data and the basic set of actions you can use to
manipulate the different types of values.
The None variable
A predefined variable called None is a special value in Python. This variable has a type of
its own and is useful when you need to create a variable but not define or specify a value
to that variable. When you assign variables such as double quotation, double quotation, and zero,
the interpreter will define the variable as the str or int variable.
Information equals None. A variable can be assigned the value None using the statement above.
The next few examples will use real-world information that will be modeled into a virtual form using some
fantasy characters. This example uses some statistics to represent some attributes of the characters to
provide data for the combat system. You can use this example to automate your database and your accounts.
So, let us take a look at some of the characters in this example.
In the program hello-world.py, you saw how you could get a basic output using the print function.
This function can be used to print out the value of the variable and a literal string of characters.
Often, each print statement must start off on a new line, but several values can be printed on a
single line by using a comma to separate them.
print can then be used to concatenate all the variables into a single line only separated by spaces.
Different segments of information can be combined into a single line using multiple methods.
Some of these methods are more efficient when compared to others.
Adjacent strings that are not separated will be concatenated automatically,
but this is not a function that works for most variables.
Greater than, greater than, greater than, print, open parenthesis, double quotation mark,
male, double quotation mark, double quotation mark, elf, double quotation mark, close parenthesis.
However, when you enter the following code, greater than, greater than,
greater than, print, open parenthesis, double quotation mark, male, double quotation mark,
race, close parenthesis, you'll receive the following error.
This approach cannot be used since you cannot write a string function as a variable and a
string together since this is just a single line string.
This approach cannot be used since you cannot write a string function as a variable and a string
together since this is just a way of writing a single line string.
Using Quotes
Using Quotes
In Python, a character is used to describe a single number, punctuation mark, or a single letter.
A string of characters used to display some text are called strings or string literals.
If you need to tell the interpreter that you want a block of text to be displayed as text,
you must enclose those characters in quotation marks.
If a text is enclosed in quotes, it is considered the type str or string.
Nesting Quotes
There are times when you may want to include literal quotation marks in your code.
Python allows you to include a set of quotation marks inside another set of quotation marks,
if you use a different type of quotation mark.
Greater than, greater than, greater than, text, equals, double quotation marks,
you are learning, single quotation marks, how to, single quotation mark,
use nested quotes in Python, double quotation mark.
In the example above, the interpreter will assume that it has reached the end of the
string when it reaches the end of the text at the second set of double quotes in the string above.
Therefore, the substring how to is considered a part of the main string, including the quotes.
In this way, you can have at least one level of nested quotes.
The easiest way to learn how to work with nested quotes is by experimenting with different types of strings.
Greater than, greater than, greater than, boilerplate, equals, double quotation mark, double quotation mark, double quotation mark,
dot mark, dot mark, dot mark, dot mark, dot mark, dot pairs of coordinates ofc Alorsllo Tedmak
close parentheses, equals, equals, equals, hash symbol, equals, equals, equals, open parentheses,
asterisk, close parentheses, equals, equals, equals, hash symbol, equals, equals,
equals, open parentheses, double quotation mark, close parentheses, equals, equals, equals, hash
symbol. Period, period, period, egregious response generator. Period, period, period,
version single quotation mark 0.1 single quotation mark period period period double quotation mark
filibuster double quotation mark technologies inc period period period period hash symbol
equals equals equals open parentheses double quotation mark close parentheses
equals equals equals hash mark equals equals equals open parentheses asterisk close parentheses
equals equals equals hash mark equals equals equals open parentheses double quotation mark
close parentheses equals equals equals hash mark period period period double quotation mark
double quotation mark double quotation mark greater than greater than print
open parenthesis boilerplate, close parenthesis.
hash mark equals equals equals
open parenthesis double quotation mark, close parenthesis
equals equals equals hash mark
equals equals equals
open parenthesis asterisk, close parenthesis
equals equals equals hash mark
equals equals equals
open parenthesis double quotation mark, close parenthesis
equals equals equals hash mark.
egregious response generator version single quotation mark zero point one single quotation mark double quotation mark filibuster double quotation mark technologies inc
hashtag equals equals equals open parenthesis double quotation mark close parentheses equals equals equals hash mark equals equals equals double quotation mark close parentheses equals equals equals hash mark
This is a useful trick to use if you want to format a whole block of text or a whole page.
How to use white space characters
White space characters can often be specified if the sequence of characters begins with a backslash.
Single quotation mark backslash n single quotation mark produces a line feed character that is different from the single quotation mark backslash r single quotation mark character.
In the output window the former would shift the output to a new line while the latter would shift the output to a new paragraph.
You must understand the difference between how different operating systems translate the text.
The usage and meaning of some of the sequences are lost on most occasions.
You may want to use the backslash n to shift to a new line.
Another sequence that is useful is backslash t which can be used for the indentation of text by producing a tab character.
Most of the other white space characters are used only in specialized situations.
Backslash n means new line.
Backslash r means carriage return.
Backslash t means tab.
Backslash v means vertical tab.
Backslash e means escape character.
Backslash f means form feed.
Backslash b means backspace.
Backslash a means bell.
You can use the example below to format the output of your screen.
Greater than, greater than, greater than, greater than, print, open parenthesis, double quotation, characters, backslash n, backslash n, description, backslash n, choose, your character, backslash n, backslash.
Period, period, period, period, period.
Backslash t dobby, backslash n, backslash tealph, backslash n, backslash t mail, backslash n, d o n, backslash apostrophe t, forget to escape, backslash, apostrophe, backslash, backslash, backslash, apostrophe, period, double quotation mark.
Close parentheses.
Characters.
Description.
Choose your character.
Dobby.
Elf.
Male.
Don't forget to escape.
Single quotation mark backslash single quotation mark period.
You must remember that strings are immutable, which means that they cannot be changed.
It is possible to use simple functions to create new strings with different values.
How to create a text application.
All of the information mentioned in this chapter can be used to write the code for your role-playing game.
Strings are often simple to use since you must only ensure that you enclose the strings in matching quotes.
The script to design the character description is simple.
Hash symbol.
Prompt the user for some user-defined information.
Hash symbol.
Output the character description.
You may want to include the following information for the character.
Name, gender, race, and description of the character.
For this information, you can create the following variables.
Name, gender, race, and description.
These values can be printed using the following code.
Double quotation mark.
Double quotation mark.
Double quotation mark.
Chargon.py.
Problem, colon, generate a description for a fantasy role-playing character.
Target users, colon, me and my friends.
Target system, colon, GNU forward slash Linux.
Interface, colon, command hyphen line.
Functional requirements, colon, print out the character sheet.
User must be able to input the character's name, description, gender, and race.
Testing, colon, simple run test.
Maintainer, colon, maintainer at website.com.
Double quotation mark.
Double quotation mark.
Double quotation mark.
Underscore.
Version, underscore, equals 0.1.
Name, equals, double quotation mark.
Double quotation mark.
Desc, equals, double quotation mark, double quotation mark.
Gender, equals, double quotation mark, double quotation mark.
Race, equals, double quotation mark, double quotation mark.
Hash symbol, prompt user for user hyphen defined information.
Name, equals input.
Open parentheses, single quotation, what is your name, question mark, single quotation mark, close parentheses.
D.E.S.C. equals, input, open parentheses, single quotation mark, describe yourself, colon, single quotation mark, close parentheses.
Gender, equals, input, open parentheses, single quotation mark, what gender are you, question mark, open parentheses, male, forward slash, female, forward slash, unsure, close parentheses, colon, single quotation mark, close parentheses.
Race equals input, open parenthesis, single quotation mark, what fantasy race are you, question mark, hyphen, open parenthesis, pixie, forward slash, Vulcan, forward slash, Gelfling, forward slash, Troll, forward slash, Elf, forward slash, Goblin, close parenthesis, colon, single quotation mark, close parenthesis.
Hash symbol, output the character sheet.
Character underscore line equals double quotation marks less than tilde tilde equals equals pipe hash symbol pipe exclamation mark exclamation mark plus plus asterisk asterisk backslash at forward slash asterisk asterisk plus plus tilde tilde equals equals pipe hash symbol pipe plus plus tilde tilde.
Greater than double quotation mark.
Print, open parenthesis, double quotation mark, backslash, N, double quotation mark, comma, character underscore line, close parenthesis.
Print, open parenthesis, double quotation mark, backslash, T, double quotation mark, comma, name, close parenthesis.
Print, open parenthesis, double quotation mark, backslash, T, double quotation mark, comma, race, comma, gender, close parenthesis.
Print, open parenthesis, double quotation mark, backslash, T, double quotation mark, comma, D-E-S-C, close parenthesis.
Print, open parenthesis, fancy underscore line, comma, double quotation mark, backslash, N, double quotation mark, close parenthesis.
The program above is a smarter version of the hello underscore world program written above.
However, in this program there is a new line added, underscore version underscore equals 0.1 at the start of the program.
This is a predefined variable that has a special meaning in Python's documentation.
This is the number we will continue to use to record the above example.
As we go along, we'll continue to increment this number when we make any changes or refine the program.
Now, we'll need to obtain some numerical information about the characters that will interact in the game.
Working with numbers
It is straightforward to assign any number to variables.
Muscle equals 8.
Brains equals 13.
As mentioned earlier, the interpreter assumes that a set of characters is a number if it starts with a numerical instead of a quotation mark or letter.
Therefore, you cannot start any variable with a number.
However, you must learn a few things before you begin to work on mathematics on your computer.
Computers only count to 1.
All the information in the computer can only be stored in 0s and 1s.
Every computer stores and processes any volume of data using tiny switches that can either be on, 1, or off, 0.
Using Boolean
As mentioned earlier, a computer can only register two values.
True, value equals 1, and false, value equals 0.
These values are known as Boolean operators and can be manipulated using operators like OR, NOT, and AND.
These operators are explained in further detail in the following chapter.
Boolean values can be assigned as follows.
Mirage equals false.
Intelligence equals true.
Using whole numbers
Whole numbers, also called integers, do not have decimal points and can be 0, positive, and negative.
These numbers are used to refer to different things, like the recipe example mentioned above.
Performing basic mathematical operations
Now that you know how to store data in a variable, let us take a look at how to manipulate that data.
Basic mathematical operations can be performed using operators like PLUS, MINUS, and Asterisk.
These operators create an expression that must be evaluated before you can obtain a value.
The following statements can be used to perform these operations.
Greater than, greater than, greater than, muscle equals 2 plus 3.
Greater than, greater than, greater than, brains equals 7 plus 4.
Greater than, greater than, greater than, speed equals 5 asterisk 6.
Greater than, greater than, greater than, greater than, weirdness equals muscle, asterisk, brains, plus speed.
Greater than, greater than, greater than, greater than, weirdness.
All these operations work using the Baud mass mathematical algorithm.
Working with floats and fractions
Most fractions are often expressed using the float type, where decimal points can be used.
These numbers, like integers, can be both positive and negative.
You do not need to assign a variable to the data type float.
Python automatically converts a variable into a float type if it is assigned a decimal number.
Muscle equals 2.8
Brains equals 4.6
Speed equals 6.8
Even if the number before and after the decimal point is zero, it is still considered a fraction.
This data type can be manipulated using the same mathematical operations mentioned above.
Converting data types
There are different built-in functions that are used in Python to convert a value from one data type to another.
The data types often used are
Int open parenthesis x close parenthesis used to convert any number into an integer.
Float open parenthesis x close parenthesis used to convert a number to a float data type.
Str open parenthesis object close parenthesis convert any type into a string that can be used to print.
20
Greater than
Greater than
Greater than
Greater than
Greater than
Integrate
Integrate
Integrate
Greater than
Greater than
Greater than
Integrate
Integrate
Integrate
Disk
Integrate
Go
No
I
I
I
Don't
W
W
W
W
W
W
W
W
W
W
W
W
W
W
W
W
23. Breaking down jargon. This section provides the definition of some new terms that were used
in this chapter. Binary. In arithmetic, binary relates to the digits 1 and 0. This term responds
to the current in a wire. Boolean. A Boolean variable can only take two values, true and
false, which correspond to 1 and 0, respectively. This type of variable is the most appropriate
type that can be used to let the user know if a condition holds true or not. Characters. A
character is anything from a digit, letter, space, and a punctuation mark. This data type is anything
that can be typed using a key on a keyboard, regardless of whether or not an output is printed
on the screen. Concatenate. When you create a string using different segments of strings or copy two text
strings together. This chapter has helped you understand how to assign different types of
variables and how you can manipulate strings and numbers. Let us take a look at the following
exercises and see how well you do. The solutions are provided at the end of the book.
Number one. Write a program to concatenate two strings. Number two. Write a program to calculate
the sum of two numbers. Chapter four. Conditional statements. Before we continue, please refer to
your audiobook companion PDF that comes free with your purchase of this audiobook to see and learn all
the codes explained with charts and images. In the last few chapters, you've learned how to use Python
to manipulate strings and to make simple calculations. More importantly, you've learned how to design
your software. Now it's time to learn how to refine your code. Therefore, pull out your old scripts and
find an effective way to obtain your output. How to compare variables. To generate more accurate
answers, you must know how to compare the values and specify what the interpreter must do based on the
obtained result. Python allows you to use conditional statements to allow you to make these decisions.
A conditional statement can transform the code or script from just being a list of instructions to a
code that can be used by the user to make their own decisions. It would be useful to tell the
interpreter to perform a different action as per the decisions made by the user. You can write a pseudocode like
If a certain condition is true, colon, then the following actions must be performed, semicolon.
If another condition is true, colon, then these actions must be performed, period.
Each pair in the example above is a conditional statement, but before we learn about these statements,
let's take a look at how to specify these conditions. Different values can be compared using the following
operators. Less than symbol is less than. Greater than symbol is greater than. Less than symbol and
equal symbol means less than equal to. Greater than symbol and equal symbol means greater than equal to.
Equal symbol, equal symbol means equal to. Exclamation mark and equal symbol means not equal to.
These operators affect data types in different ways and give the user answers in the form of the
Boolean operators. The data bits on either side of the operator are called operands and these are the
variables that are compared. The comparative operator and the operands together form a conditional
expression. It is important to check the conditional statements or expressions you're using since you
may obtain an error if you compare incomparable data types. The results obtained by comparing these
numbers are self-explanatory. Greater than greater than greater than minus 6, 9, greater than 39,
greater than 37. True. Greater than greater than greater than 7.65, not equal to 6.0.
True. Greater than greater than greater than minus 5 less than equal to minus 2. True.
Greater than greater than greater than 7, less than minus 7. False. Greater than greater than
greater than 23.5 greater than 37.75. False. Greater than greater than greater than minus
5 greater than equal to 5. False. Greater than greater than greater than 3.2 not equal
to 3.2. False. Variables can also be used in conditional expressions. Greater than greater
than greater than variable equals 3.0. Greater than greater than greater than variable equal
to 3. True. Manipulating Boolean Variables. Before you move on to the different conditional
structures used in Python, you must learn how to manipulate the Boolean variables true
and false. You can use these values to understand the characteristics of any variable. These
operators are often used with the terms and, or, and not. The statements below represent
some bits of information. Greater than greater than greater than A equals true. Greater than
greater than greater than B equals false. Greater than greater than greater than C equals
true. Greater than greater than greater than D equals true. Greater than greater than
greater than e equals false. Let's take a look at how and, or, and not can be used.
Greater than, greater than, greater than a or b. This operator returns the value true,
since for the or operator, either one of the values needs to be true.
Greater than, greater than, greater than c and e. This operator returns the value false,
since for the and operator, both values must be the same.
Greater than, greater than, greater than, not d. This operator returns the value false,
since the not operator provides the opposite of the value.
Combine Conditional Expressions. Conditional expressions can be combined to produce complex
conditions that use the logical operators and and or. Let's take a look at the following conditions.
Open parentheses a, less than 6, close parentheses, and open parentheses b, greater than 7, close
parentheses. This statement will only return true if the value of a is less than 6 and the value of b
is greater than 7. The Assignment Operator. Since you're familiar with the Assignment Operator
Equals, which you use to put a value into a variable, let us take a look at how you can use this operator
to assign values to variables. This Assignment Operator can be used to unpack sequences.
terms are a variable. This says a response that will bring the value of b, low power
into a link. 1
Great then, greater than, greater than, char1, single quotation, c, single quotation.
Great then, greater than, greater than, char2, single quotation, a, single quotation.
Great then, greater than, greater than, char3, single quotation, t, single quotation.
The assignment operator can also be used to assign different variables with the same value.
A equals B equals C equals 1
The assignment operator can also be used along with mathematical operators.
Counter plus equals 1
The statement above is interpreted as counter equals counter plus 1.
Other operators can also be used to either increment or decrement the value of the variable.
How to control the process
You have the liberty to decide what happens next in the program you've written using the control flow statement.
The results of the comparison statements can be used to create conditional statements
that allow the interpreter to provide the output that is based on whether the predefined conditions hold true.
Conditional statements can be constructed using the words if, elif, and else.
Unlike other languages, Python does not use the keyword then.
The syntax is very specific, therefore you must pay close attention to the layout and punctuation.
If condition, colon
Hashmark, perform some actions
Print, double quotation, condition is true, double quotation
Elif, condition, not equal to true
Hashmark, perform some other actions
Print, double quotation, condition is not true, double quotation
Else, hashmark, perform default or fall hyphen through actions
Print, double quotation, anomaly, colon
Condition is neither true nor false, double quotation
In the syntax above, the first line begins with the word if, which must be followed by a conditional statement
that gives a true or false output followed by the colon
This colon means yes
The statements that follow must always start on a new line
The number of spaces doesn't strictly matter so long as all the instructions after the colon are indented by the same amount
Though it's good to practice to use the same number of spaces to indicate control flow throughout your code
The statements following after the colon are known as a suite
You can include further conditional sections using the elif keyword, an abbreviation of else if, which is not a Python keyword
Statements following elif will be evaluated only if the previous test fails, i.e. the conditional expression is false
You can also include a final else statement, which will catch any value that did not satisfy any of the conditions
It doesn't take any conditional expression at all
This can be used to specify a default set of actions to perform
In the previous example, things would have to go very wrong for us to ever see the final anomaly warning as the preceding if and elif statements would have caught either of the two possible results
It is possible to nest if statements to allow for more possibilities
And you can leave out the elif or else statements if you don't want anything to happen unless the condition is satisfied
In other words, sometimes you want to do something if a condition is satisfied, but do nothing if it's not satisfied
After the final statement, the indentation must go back to its original level
This will indicate to the interpreter that the conditional block has come to an end
Python marks out blocks of code using indentation alone
It doesn't use punctuation marks like the curly braces you may see in other languages
This unique feature of Python means you have to be extra careful about indentation
If you do get it wrong, you'll find out soon enough as the interpreter will complain loudly
Later than, greater than, greater than, greater than, if C, colon
Period, period, period, print, open parenthesis C, close parenthesis
Period, period, period, C, plus, equals, 1
Period, period, period, . indent equals, double quotation, bad, double quotation
File, double quotation mark, less than, s-t-d-i-n, greater than, double quotation mark, comma, line 4
A conditional statement always gives the user the ability to check or validate the data that was used as the input.
Validation is often performed when the data is first fed into the computer and also when the information is written out of a database record or file.
How to deal with logical errors
As your applications become more complex, you'll need more formal methods of testing your designs.
One of the ways of doing this is to construct a trace table.
You must trace the values of all the variables in the conditional expressions over the course of the execution of the program.
A trace should be performed with as many different sets of data as is necessary to make sure that all the possible alternatives get tested.
Most errors in programming don't occur if the values lie within some expected range, but they often occur for unusual values, also called critical values.
Critical values are values that lie outside the tolerances of the program, such as a number that the application is not equipped to deal with.
Critical values should be worked out early on in the design process so that the program can be properly tested against them.
In the calculation of the area of a triangle, the value that most needs taking into account is that of the breadth, which has been set at 14 centimeters.
Allowing 8 centimeters means that the maximum breadth of the triangle can only be 8 centimeters.
Using the conditional code
Now, you can apply your knowledge of conditional statements to allow for different ways of measuring up the material.
If the breadth of the triangle were too much, it would become a different type of triangle.
Therefore, you need to identify the right code, which reflects the right conditions.
The first step would be to translate your trace values into a pseudocode.
The following example is about measuring the length of a curtain.
If
if extra material less than
width plus equals 1.
If extra material greater than
width plus equals 2.
Loops
While Statement
Result equals 1.
While Result less than 1,000 colon.
Result asterisk equals 2.
Print Result
To control the number of times the loop is processed,
it's necessary to specify a conditional expression.
As long as this conditional expression is true at the beginning of an iteration,
the loop continues.
In the preceding example, our conditional expression is Result less than 1,000.
So as long as the value of Result is less than 1,000,
the loop will continue processing.
Once Result reaches 1,024,210, the program will stop processing the loop body.
The variables used in the conditional expression are often expendable entities,
which are only required for as long as the loop is active.
Rather than keep thinking up different names, this kind of integer counter is usually named
i or j by convention.
Two things are important to remember in this sort of construction.
Any variable used in the conditional expression must be initialized before the execution of the loop.
Also, there must be some way of updating this variable within the loop.
Otherwise, the loop will just go around and around forever, which is called an infinite loop.
It is possible to use different sorts of variables in the conditional expression.
Let's consider the problem of calculating the average of several numbers input by the user.
The main problem here is that I don't know how many numbers will be input.
The solution is to use what is called a sentinel value to control the loop.
Rather than using the counter in this instance,
the script checks the value of the user input number.
While it is positive, i.e. greater than equal to zero,
the loop processes as normal,
but as soon as the negative number is entered, the loop is broken,
and the script goes on to calculate the average.
Let's take a look at the following example.
Counter equals zero.
Total equals zero.
Number equals zero.
While number greater than equal to zero, colon.
Number equals int, open parenthesis, input, open parenthesis, double quotation mark,
enter a positive number, backslash, nor a negative to exit, colon, double quotation mark,
close parenthesis, close parenthesis.
Total plus equals number, counter, plus equals one.
Average equals total forward slash counter.
Print, open parenthesis, average, close parenthesis.
There are several methods of getting out of loops cleanly,
the chief ones being the use of the break and continue keywords.
If you want to get out of a loop without executing any more statements in the loop body,
use break.
If you just want to get out of this particular iteration of the loop,
continue immediately takes you to the next iteration of the loop.
At times, you'll want the interpreter to recognize a condition but do nothing.
In this case, the pass keyword can be useful.
It creates a null statement, which simply tells the interpreter to move on to the next instruction.
Nesting loops.
You're allowed to nest loops and other conditional statements in Python,
probably infinitely, but it is best to keep the number of levels of nesting to a minimum.
For one thing, it's very easy to get confused about which option the program is taking at any particular point.
Also, having lots of indented blocks within other indented blocks makes your code difficult to read,
can slow down the program's execution, and is generally considered bad style.
If you've come up with a design that involves two or three layers of looping,
you should probably start thinking about redesigning it to avoid the excessive depth of nesting.
Four.
The other control flow statement I want to introduce is the for statement,
which is constructed in a similar manner to the if and while statements.
Its construction is for element in sequence, followed by an indented suite of instructions.
During the first iteration of the loop, the variable element contains the first element in the sequence
and is available to the indented suite.
During the second iteration, it contains a second element in the sequence, and so on.
To understand how this statement works, you need to know about sequences.
The simplest sequence in Python is a string,
which is a sequence of individual characters including spaces and punctuation.
Other forms of sequence are tuples and lists.
Tuples and lists are sequences of data items,
the chief difference between them being that lists are editable in place whereas tuples are not.
It's possible to use either in a for statement.
They're constructed as follows.
Hashmark tuple.
Sequence 1 equals open parenthesis 1, 2, 3, close parenthesis.
Sequence 2 equals open bracket 1, 2, 3, close bracket.
Breaking down jargon.
This section explains some of the terms used in this chapter.
Assignment operator.
The single equal sign is the assignment operator.
It can be combined with other operators to perform more complex assignment operations.
Built-in.
A built-in element is an innate part of the programming language
as opposed to something that has to be imported from a module.
Built-in elements are part of Python's standard library.
Comparison operators.
These operators compare two values.
Conditional statement.
This section of code is performed if a certain condition evaluates as true.
A conditional statement is a form of control flow statement.
Critical values.
These values exist at the edges of the permissible ranges set for an application.
In particular, these are values that would cause changes or unexpected results
from the normal running of the program.
Loop body.
The body is the suite of instructions to be repeated in a loop.
Null statement.
The pass keyword creates a null statement,
which tells the interpreter to move on to the next statement.
Validation.
This refers to the process of checking that your data is what you expect.
Now that you've understood how to work with conditional statements and loops,
try the following programs.
The solutions to these programs have been provided at the end of the book.
Number one, write a program to print the Fibonacci series.
Number two, write a program to print a palindrome.
Number three, write a program to check if a number is even or odd.
Chapter five, data structures.
Before we continue, please refer to your audiobook companion PDF that comes free with your purchase
of this audiobook to see and learn all the codes explained with charts and images.
So far, you've learned to work with individual pieces of data to produce some simple results.
Real-world data is usually in lumps or groups, and it would be useful to work with such groups
without having to make lots of repetitive statements in our code.
Fortunately, Python provides a variety of data types that can make handling groups of data much simpler.
The data types that are most used in Python are strings, tuples, lists, and dictionaries,
which are called data structures.
Lists and tuples are a group or ordered data items,
while strings are pieces of characters or text that are put together.
Strings are just pieces of text.
Tuples and lists are ordered groups of individual data items.
Dictionaries are groups of pairs that only consist of key variables and values.
Strings, tuples, and lists are also called sequences,
which are a type of data model.
The methods used for accessing the data in a sequence are same,
which you will see later in this chapter.
There's another way of looking at these data types,
according to whether they can be modified or not, which is called mutability.
An existing string and tuple cannot be modified,
but new strings and tuples can be created using them,
which means that both strings and tuples are immutable.
Lists are mutable, which means that we can add or remove items from a list.
Items and sequences
We can fetch an individual item from a sequence using an index,
which is the position of the element.
The index is specified as an integer, a whole number,
in square brackets immediately following the variable name.
So, S, open bracket, I, close bracket, will retrieve the item at position I of sequence S.
This allows you to access a single character in a string.
Greater than, greater than, greater than, vegetable, equals, single quotation mark, pumpkin, single quotation mark.
Greater than, greater than, greater than, vegetable, open bracket, zero, close bracket.
Single quotation mark, P, single quotation mark.
Or an item in a list.
Greater than, greater than, greater than, vegetable, equals,
open bracket, single quotation mark, pumpkins, single quotation mark, comma,
single quotation mark, potatoes, single quotation mark, comma,
single quotation mark, onions, single quotation mark, comma,
single quotation mark, eggplant, single quotation mark, close brackets.
Greater than, greater than, greater than, vegetable, open bracket, one, close bracket.
single quotation mark pumpkins single quotation mark
the first thing you'll notice is that indexing is zero based
that means you start counting at zero an index of open bracket two
close bracket accesses the third item on the list the first item would be
referenced with open bracket zero close bracket so you can use integer zero
through the number of elements in the sequence minus one
zero to n minus one as indices when you use a negative index the
interpreter counts from the end of the list greater than greater than
greater than vegetable open bracket minus one close bracket single quotation
mark eggplant single quotation mark you can grab sections of a sequence using
slices slicing is used to fetch multiple items from a sequence slices are the
same as indices in the sense that the notation used for both is the same
however slices are written by two or more integers separated by colons the first
value is the inclusive starting point and the second number is the exclusive
end point of the slice so s open bracket zero colon two close bracket means that
the slice will start from index zero and stop just before index two i.e. fetch items
at position zero and one the third value is optional and specifies an additional
step value which may be negative so instead of picking out a sequential list you can
retrieve every other or every nth item and you can also retrieve them backward if you
need to so s open bracket i colon j colon step close bracket or retrieve a slice of s
starting from i and up to but not including j and taking the specified step if you leave
out the starting point the slice will start at the beginning of the original sequence and
if you leave out an endpoint the slice will run to the end of the original sequence indexing
and slicing do not modify the original sequence they make a new sequence from the original however
the actual individual data items are the same so if you modify an individual item in a sequence
you'll see the item change in a slice from the sequence as well
tuples a tuple is an immutable ordered group of items or elements think of tuples as useful
little sealed packets of information a tuple is specified as a comma separated list of values
which may be enclosed in parentheses on certain occasions the parentheses are required so when
in doubt use parentheses these values need not all be of the same type a value can also be another
tuple creating a tuple tuples can be created with no items in them using the round brackets
greater than greater than greater than empty underscore tuple equals open parenthesis close
parentheses if you do not want more than one item in the tuple you should enter the first item followed
by a comma greater than greater than greater than one underscore item equals open parenthesis single
quotation mark blue single quotation mark comma close parentheses changing values in a tuple you cannot change the values in a tuple
you cannot change the values in a tuple these tuples are sealed packets of information that are often used in situations where a set of values need to be passed on from one location to another if you wish to change the sequence of a data you should use a list
list list a list is an ordered comma separated list of items enclosed in square brackets items need not all be of the same type an item can also be another list list can be sliced concatenated and indexed the same way as any other type of sequence it is possible to change individual items in a list as opposed to immutable strings and tuples where a tuple is rather like a fixed menu lists are more flexible it is possible to change individual items in a list as opposed to immutable strings and tuples
where a tuple is rather like a fixed menu lists are more flexible it is possible to assign data to slices which can change the size of the list or clear it completely
creating a list it is easy to create a list greater than greater than greater than shopping underscore list equals open bracket single quotation mark detergent single quotation mark comma single quotation mark deodorant single quotation mark comma
called quotation mark single quotation mark comma single quotation mark shampoo single quotation mark comma single quotation mark
single quotation mark body wash single quotation mark close bracket
modifying the list
a new value can be added to a list using the assignment operator
greater than greater than greater than shopping underscore list
open bracket one close bracket equals single quotation mark candles single quotation mark
Greater than. Greater than. Greater than. Shopping underscore list. Open bracket. Single quotation
mark detergent. Single quotation mark comma. Single quotation mark candles. Single quotation
mark comma. Single quotation mark deodorant. Single quotation mark comma. Single quotation
mark shampoo. Single quotation mark comma. Single quotation mark body wash. Single quotation
mark. Close bracket. Stacks and Queues. Because lists are an ordered type of data,
it is possible to use them to store and retrieve data items in a particular order.
The two main models of doing this are described in traditional programming speak as stacks and queues.
A stack is a last-in, first-out, LIFO structure used rather like a discard pile in a card game.
You put cards on top of the pile and take them back off the top.
You can push items onto the stack with list.append and pop them back off with pop.
Note that there is no additional index argument, so it will be the last item of the list that has popped.
Greater than, greater than, greater than, shopping underscore list dot append, open parenthesis, single quotation mark, brush, single quotation mark, close parenthesis.
Greater than, greater than, greater than, shopping underscore list dot pop, open parenthesis, close parenthesis.
Single quotation mark, candles, single quotation mark.
Greater than, greater than, greater than, shopping underscore lists.
Open bracket, single quotation mark detergent, single quotation mark comma, single quotation mark deodorant, single quotation mark comma, single quotation mark shampoo, single quotation mark comma, single quotation mark body wash, single quotation mark, close bracket.
The other approach involves creating a first in, first out FIFO structure called a queue.
This works more like a pipe where you push items in at one end and the first thing you put in the pipe pops out on the other end.
Again, we can push items into the pipe using append and retrieve them using pop, this time with an index of zero to indicate that the data items should be popped from the start of the list.
Greater than, greater than, greater than, shopping underscore list dot append, open parenthesis, single quotation mark, brush, single quotation mark, close parenthesis.
Greater than, greater than, greater than, shopping underscore list dot pop, open parenthesis, zero, close parenthesis.
Dictionaries.
Dictionaries are like address books.
If you know the name of the person, you can get all of that person's details.
The name is technically referred to as a key and any corresponding detail is referred to as the value.
The key must be of an immutable type, that is a string, number, or tuple.
The value can be more or less anything you like.
The dictionary itself is a mutable data type, which means you can add, remove, and modify key-value pairs.
The keys are said to be mapped to objects, hence dictionaries are referred to as mappings to remind us that their behavior is somewhat different to sequences.
Dictionaries are used anywhere we want to store attributes and values that describe some concept or entity.
For example, we can use a dictionary to count instances of particular objects or states.
Because each key has to have a unique identifier, there cannot be duplicate values for the same key.
Therefore, we can use the key to store the items of input data, leaving the value part to store the results of our calculations.
Breaking down jargon
Let us break down some of the new words you've come across in this chapter.
Arbitrary
In this instance, anything defined by the programmer is arbitrary.
Complex data types
These are structured or compound types constructed from a sequence of other types of data.
Constant
A constant value does not change during the execution of the program.
Constrain
Ensure that the results of a calculation fall between a specified range.
Hash
A hash is a number calculated from a dictionary key to help with storage.
This number is designed to be smaller than the key to aid efficiency.
Immutable
An immutable value that cannot be edited in place.
Index
An index is a token of an immutable type in square brackets immediately following the variable name used to point to a specific item in a sequence.
Iterable
Iterable
This refers to a code object that can be iterated.
Iterate
When you loop through items in a sequence one item at a time, you iterate it.
Iterator
This construct is designed to allow looping.
Mapping
This refers to a sequence that maps hashable values to arbitrary objects.
Matrix
A matrix is a multidimensional sequence.
Method
A method is a function specifically attached to an object or class of objects.
Mutable
A mutable value can be changed.
Operation
This action is performed on two variables, operands, usually of a mathematical or logical nature.
Q
A Q is a first-in, first-out, FIFO structure.
You push things in at one end and pop values out of the other.
Resultant
This value is returned as the result of a process.
Separator
This text string is used to distinguish between items of data.
Sequence
A sequence is the simplest sort of complex data type in Python.
Lists, strings, and tuples are the types of sequences.
Sequence packing
Sequence packing is the action of assigning a sequence of comma-separated values to a variable.
Slice
This refers to a smaller segment of a sequence.
Here are a few exercises that will help you master data structures.
Number one, write a program to access the elements on a list.
Number two, write a program to slice a list in Python.
Number three, write a program to delete elements in a list.
Number four, write a program to access elements in a tuple.
Number five, write a program to change a tuple.
If you're enjoying the audiobook, I would love it if you went to Audible and left a short review.
Chapter six, working with strings.
Before we continue, please refer to your audiobook companion PDF that comes free with your purchase of this audiobook to see and learn all the codes explained with charts and images.
Most commands in Python 3 will work in exactly the same way as in Python 2.
There are, however, some important changes.
Probably the most fundamental change is the rationalization of the string data type.
In previous versions of Python, strings were coded as a sequence of single bytes using the Limited American Standard Code for Information Interchange, or ASCII, character set to represent text.
This 7-bit encoding allows for up to 128 characters, including uppercase and lowercase letters, numbers, punctuation, and 33 invisible control characters.
While ASCII is okay for representing languages that use Latin script, such as English and most European languages,
it's completely useless when it comes to representing the 2,000 basic ideograms of the Chinese language.
To deal with these sorts of problems, the Unicode standard was created to cover all written languages,
so Python 3 has brought itself up to date by switching to Unicode as its default text encoding.
The STR type is what used to be Unicode type, and a new type, byte, has been introduced to represent raw text strings and binary data.
Previous versions of Python went through all sorts of contortions in order to deal with text encoding.
Fortunately, all you really need to know is that the STR type in Python 3 supports international characters by default,
so you don't have to do anything special if you want to write a string.
To go along with the string type changes, the print statement in Python 2.x has been replaced with the print function,
which is a built-in function in version 3.0.
This function replaces most of the earlier syntax with keyword arguments.
To balance this, the old raw underscore input is replaced by input,
and you have to use eval open parenthesis input open parenthesis close parenthesis close parenthesis
to get the old functionality of input.
Splitting strings
As strings are immutable, you'll often want to split them up into lists in order to manipulate their contents.
Quick reminder, a delimiter is a character or string of characters that are used to separate words or units of data.
The list will be split up to max split times, so you'll end up with a list that's max split plus one items long.
If no separator is specified, the string will be split up by white space characters as if they're words.
Greater than, greater than, greater than, sentence equals, single quotation mark, this is a long sentence, single quotation mark.
Greater than, greater than, greater than, greater than, sentence dot, rstrip, open parenthesis, single quotation mark,
sentence, single quotation mark, close parenthesis, dot, split, open parenthesis, close parenthesis.
Open bracket, single quotation mark, this, single quotation mark, comma, single quotation mark, is, single quotation mark, comma,
single quotation mark, a, single quotation mark, comma, single quotation mark, long, single quotation mark, close bracket.
Python has an alternative string-splitting method, string.partition, open parentheses,
SEP, close parentheses, which returns a tuple, head, sep, tail.
The method identifies the separator within the string, and then returns the section before
the separator and the part of the string that is separated from the string.
If the separator is not found, the method will return the original string and two empty
strings.
Concatenation and Joining Strings
Using the plus operator to join strings together is very inefficient.
Combined with lots of calls to the print function or statement in Python 2, using the plus operator
can potentially slow your program's execution to a crawl.
Python isn't that slow.
Often, it works out better to manipulate a list of words and then use string.join, open
parentheses, sequence, close parentheses, to return a string that is a concatenation of
the strings in a sequence.
This method is the opposite of string.split.
The data you want to manipulate is in the sequence of the argument, and the string that you want
to call the method on is just the string of characters you want to use to separate the
items.
This could be a space or an empty string.
So, multiply a list of the string, and I continue to use for you.
The index card dictionary is also the same and the string that is a ext
than greater than greater than s3 dot join open parentheses open bracket s1 comma s2
close bracket close parentheses single quotation mark example text single quotation mark you
must remember that the function string dot join always expects a sequence of strings as the
argument greater than greater than greater than s3 equals double quotation mark hyphen double
quotation mark greater than greater than greater than s3 dot join open parentheses single quotation
mark castle single quotation mark close parentheses single quotation mark c hyphen a hyphen s hyphen t hyphen
l hyphen e single quotation mark you also may have the need to convert different data types into
strings by using a sublist editing strings strings as you've probably gathered by now can't be edited
in place but they do have some useful methods that will return a new edited version of the string
you often need to clean up the beginning and end of the string to remove extraneous white space or
punctuation especially if you're trying to compare some user input with a stored value this is done with
the string dot strip open parentheses open bracket c h a r s close bracket close parentheses method
this returns a copy of the string with c h a r s removed from the beginning and the end if the sequence is
found if no arguments are given string dot strip will remove white space characters by default
greater than greater than greater than sentence equals single quotation mark this is a long sentence
single quotation mark greater than greater than greater than sentence dot strip open parentheses
single quotation mark a single quotation mark close parentheses single quotation mark this is long
sentence single quotation mark how to match patterns sometimes the basic string methods just aren't enough
for example you may need to retrieve values that appear within a regular pattern in a piece of text
but you don't know what those values are going to be or just have a rough idea of what they should
not be this is where regular expressions come in a regular expression regex for short is a pattern
that can match a piece of text in its simplest form a regular expression could just be a plain string of
ordinary characters that matches itself regular expression syntax uses additional special characters to
recognize a range of possibilities that can be matched these expressions can be used in search and replace
operations and to split up text in different ways than string dot split regular expressions are complex powerful and
difficult to read most of the time you can manage without them but they are particularly useful when dealing with
complex structured pieces of text it's best to take regular expressions slowly learning a bit at a time trying to learn the whole
regular expression syntax syntax all in one go could be quite overwhelming regular expression matching
operations are provided by the re module as re is not built in by default it's necessary to import the module first before it is
possible to use it greater than greater than greater than import re in the module supports both 8-bit and
unicode strings so it should be possible to recognize any characters that you can type in from the keyboard or read from a file
next you need to construct a regular expression string to represent the pattern you want to catch
let's use the rather colorful string from earlier in the chapter again
creating a regular expression object
you can compile a regular expression pattern into a regular expression object using read dot compile open
parentheses pattern open bracket comma flags close bracket close parentheses
this returns a pattern object on which you can call all the previous methods but you no longer need to
provide the pattern as an argument you might want to do this if you need to use this pattern to perform lots of
matches all at once compiling the pattern into an object speeds up the pattern comparison process because the
pattern does not have to then be compiled each time it's used you might also need to use this approach where a
function specifically requires a regular expression object to be passed to it rather than just a pattern string
exercises
number one write a program to create a string
if you're enjoying the audiobook i would love it if you went to audible and left a short review
chapter seven how to use files
before we continue please refer to your audiobook companion pdf that comes free with your purchase of this audiobook to see and learn
all the codes explained with charts and images
so far data has either been written into the program itself or received via the input function and printed
out using the print function once the program has finished its execution the data is lost in order for an application
to have any practical value it's necessary to be able to store that information and retrieve it the next time the program is run the vast majority of computer information is stored in files on a hard drive or similar storage medium or can be transmitted via some file like object
file like objects share some similar properties with files and can often be treated in the same methods
streams are an important kind of file like object
how to open files
file objects can be created with the built in open open parenthesis file name open bracket comma mode open bracket comma buffering closed bracket closed bracket closed bracket closed parenthesis function
built in the same file
built in functions and methods also return file
let us open a plain text file in the same directory where we started the interpreter
greater than greater than greater than
greater than open open parenthesis single quotation mark python dot txt single quotation mark close parenthesis
less than i o dot text i o wrapper object at 0 x b 7 b a 9 9 0 c greater than the example above uses the
file object as another python object which says it's an i o dot text i o wrapper
in plain language that's a file object
if the file doesn't exist you'll get an i o error
i o stands for input output in other words reading and writing to files
the file object now holds the contents of story dot txt but in order to do anything with it you need to learn some file methods
i hope you're getting used to the concept that everything in python is some type of object and that any type of object
will usually have several methods that you can use to access its values or edit it
before you can make use of the different file methods it's important to understand the different ways that python can open a file to create a file object
modes and buffers
opening the file by just passing the file name to open creates a read-only file object
if you want to be able to write to that file as well it's necessary to set the optional mode argument
this argument can be a single character r read w write or a append any of which may be allowed by b binary or plus read and write
if you don't provide a mode argument python will assume your file as a text file and mode r
will be assumed
greater than greater than greater than
open open parentheses single quotation mark python dot txt single quotation mark comma single quotation mark rb single quotation mark close parentheses
less than i o dot buffered reader object at zero x b seven b a nine nine zero c greater than
the b mode returns a different kind of object to the default file object
one that contains the same information in byte format
you might want to use this if you wanted to handle image or audio data
write mode w lets you change the contents of the file completely
append mode a only lets you add information to the end
this last option is useful for creating log files
the buffering argument used with w or a can either be zero or one
if it's zero your data is written straight to your hard drive
if it's one python creates a temporary file to store the text in before it gets written out
the data is not written to disk unless you explicitly call file dot flush or file dot close
you probably won't need this option immediately
reading and writing
the most basic method you can use to access the file's contents is file dot read
open parentheses open bracket size close bracket close parentheses
this reads up to size bytes from the file
less if the read hits the end of the file before it gets to the size bytes
the complete file is read as one string if there is no size argument provided or if it's negative
unless the file is opened as a binary object the bytes are returned as string objects
in such cases you'll only have raw bytes as output
if you're reading a plain text file containing ordinary characters you might not notice a great deal of difference
greater than greater than greater than text equals open open parentheses single quotation mark
python dot txt single quotation mark close parentheses
greater than greater than greater than text dot read open parentheses close parentheses
single quotation mark are you keen to learn the python language
open brackets period period period pages more text here period period period close bracket
and single quotation mark if you're dealing with a large body of text like the following example you may wish to deal with it in smaller pieces
file dot read line open parentheses open bracket size close bracket close parentheses reads a single line from the file
up to the next new line character backslash n an incomplete line may be returned in an iteration
the size argument is defined as the number of bytes that the interpreter must read the bytes also
include the trailing new line if the interpreter reaches the end of the file an empty string is returned
greater than greater than greater than text equals open open parentheses single quotation mark python dot txt single quotation mark close parentheses
greater than greater than greater than greater than greater than greater than text dot read line open
parentheses close parentheses
double quotation marks are you keen to learn more about the python language period
thank you for purchasing the book period
i hope you gather all the information you were looking for period double quotation mark
files are their own iterators so you can also iterate through lines in a file using a for loop
the same result as the file dot read line method is returned at each iteration and the loop
only ends when the method returns a null or empty string try the following code out greater than
greater than greater than greater than for line in text colon period period period print open parenthesis line
close parenthesis closing files it's a good idea to use file dot close to close a file after you're finished with it
python will probably notice you're not using the file anymore and free up the memory space
eventually but explicitly closing it is cleaner often the data in a file dot write operation is
stored in a buffer until the file is closed you can make sure the data gets written out to the file
without closing it by using file dot flush a file once closed cannot be further read or written
you are allowed to call close more than once
chapter eight working with functions the first design considerations in making a new function are what
kind of input it needs and what information the function will return of close importance are the type
and structure of the data that will be fed in and retrieved data supplied to a function are called
parameters and the final information that is returned is known as results or output our initial
specification for the function design should also include a general description of the function's
specific purpose defining a function a function is always defined using the def statement the word
def is followed by the function name an optional list of parameters and the line ends with a colon which
indicates that the subsequent lines should be indented as a suite or block of instructions let's start with a
function that takes no parameters greater than greater than greater than def generate
underscore rpc open parenthesis close parenthesis colon period period period double quotation mark
double quotation mark double quotation mark double quotation mark roll hyphen playing character generator
double quotation mark double quotation mark double quotation mark
double quotation mark disposable quotation mark period period profound
180 Dios 550alar
This block of instructions proceeds in exactly the same way as a complete script, so in essence
we give a name to each piece of functionality and they're called functions.
If you want to provide some notes on what the function does, you can do so in docstring,
which must be the first thing in the function.
The docstring is then followed by a series of statements that are the core functionality.
The function can also return some data using a return statement.
The function's last line specifies which variables get returned to the main program.
If there's nothing to return, you don't have to use a return statement and Python will
assume none as the default return value.
Up to this point, the block of code in our function has not yet been run, it has simply
been assigned to the function definition.
To get the code to run, you need to call the function from the main body of the program.
This is called a function call.
Since we've given names to function, we can call those functions any number of times.
We haven't specified any parameters in this example, hence the empty parentheses after the function name.
Defining Parameters
Most functions work on some data that they have been given by the main program.
In order for the function to receive data, it needs to set up some empty containers to hold the data.
These become variables unique to the function and are known as formal parameters, and it's
best if they don't have the same names as the main program.
These formal parameters have to be specified in the parentheses after the function name
on the first line of the function definition.
This function might be called from the main program in the following way.
This function might be called from the main program in the following way.
The values and parentheses in the function call are known as arguments.
They correspond to the formal parameters in the function definition.
In this case, the first argument, 33, is bound to the parameter sides, and the second argument,
3, is bound to the parameter dice.
This effectively creates two variables, sides and dice, to be used inside the function.
If you just send the function values like this, there must be the same number of arguments
as parameters, and they have to be in the right order, so these are known as positional arguments.
You could substitute the actual values in the function call with variables if you prefer.
Just remember that the function is going to refer to that value by the name of the parameter
that receives it, and the original variable will remain unaffected.
Only the value gets passed on.
Documenting your function
Once a function is fully coded and passes the tests you've set for it, it's a good time to
edit its docstring to fit with the expectation of Python's documentation tools.
Docstrings are expected to follow convention.
The first line of a docstring should be a short description of the function that makes sense
by itself and fits on only one line, usually a maximum of 79 characters including any indentation.
The next line should be left blank.
After that, the body of the docstring should contain a description of the function's parameters,
a longer description of the function, notes about the algorithm used, and an example of
how to use the function that includes details of optional arguments, keyword arguments, and its return values.
You might also want to include information about possible side effects, exceptions, and restrictions
on when the function can be called.
These matters will be covered later in this book.
In short, all the information that another programmer would need to be able to use the function.
It's very important to update your docstrings and comments every time the code changes.
Working with scope
One way of conceptualizing functions is to think of them as black boxes that take in source data,
process it, and pass it back.
The code in the main program that sends the source data and receives the result is known as the calling
procedure. It doesn't need to know what's inside the black box, so long as the source data and the results
are clearly identified. Understanding scope
When you write a function, you should not have to worry about using names that will clash with names
used in other parts of the program. This is why we have the concept of scopes.
When any program is run, the interpreter keeps track of all the names that are created and used in
the program. These names are tracked in a table referred to as a symbol table and can be viewed as a
dictionary using the built-in vars function. The variables created in the main program's symbol
table are known as global variables because any part of the program can access these variables.
These can be viewed with the built-in globals function. You'll notice that the result of running vars
with no arguments inside the main program is the same as running globals. So far, the script examples
in this book have only used global data. Any variable that is created in a function is stored in a symbol
table unique to that function. This data is known as local data and can be accessed within that function
using the locals function. The main body of the program, global scope, cannot access the variables
set inside the function, local scope. The function, however, is still able to access names in the main body,
that is, globals. Hence, you have two ways to get at a function to process some data. The correct way is to
take that data as a parameter for the function. The function will process it and then return the result,
which will be collected by the main program. The other way is to let the function directly
access and process the global data, but this second way is discouraged because the function
works with only particular variable names and cannot be reused anywhere else.
Manipulating dictionaries and lists. Parameters to a function are passed by value. However,
in the case of objects, unlike simple types such as integers and strings,
if you modify the parts of an object including items in a list or dictionary,
the changes are reflected outside the function as well. This means that a function can be used
to modify a mutable data type such as a dictionary or list. Technically, such a modification procedure
is not a pure function, as it neither needs a return value or indeed any input parameters.
In order to avoid strange side effects, a good general policy is to send and return
immutable values from functions and keep any modification procedures for your mutable type
separate. If you send a list or dictionary to a function, all you're doing is sending it to a
pointer to the same global instance of that object, just as you had written local underscore list equals
global underscore list. Abstraction
This round of testing may bring new issues to light. In order to help you keep track of what's
going on with your code, do the minimum necessary to get the new code to pass its tests. If the new code
fails, you should roll back the changes to the point where the code passes again. Also, if using the
function doesn't work, don't sweat it. Reverse the changes and move on. There's no rule that says you
have to abstract everything into a function. The process of placing code into functions,
abstraction, and turning code that deals with specifics into a general purpose code,
generalization, can also be applied to your testing procedures, and this is a good thing to do.
All these test procedures will eventually get moved outside the program into a separate module,
so abstraction and generalization are also good preparation. The rule to remember is to write your
tests first and then make sure your existing code still passes before attempting to refactor it.
Although this might seem like a laborious approach, in fact, it speeds up the development of new code
and provides a mechanism for flagging up which part of the code needs fixing next,
rather than having to keep the details in your head. This has to be a good thing.
If you're enjoying the audiobook, I would love it if you went to Audible and left a short review.
Chapter 9. Solutions
Before we continue, please refer to your audiobook companion PDF that comes free with your purchase
of this audiobook to see and learn all the codes explained with charts and images.
Concatenate two strings
Hashmark
Python program
Hyphen
Concatenate string
Print
Open parenthesis
Double quotation mark
Enter
Single quotation mark
X
Single quotation mark
For exit
Period
Double quotation mark
Close parentheses
Semicolon
String 1
Equals
Input
Open parenthesis
Double quotation mark
Please enter the first string
Colon
Double quotation mark
Close parentheses
Semicolon
If string 1
Equal to
Single quotation mark
My name is Dobby
Single quotation mark
Colon
Exit
Open parenthesis
Close parentheses
Semicolon
Else
Colon
String 2
Equals
Input
Open parenthesis
Double quotation mark
Please enter the second string
Colon
Double quotation mark
Close parentheses
Semicolon
String 3
Equals
String 1
Plus
String 2
Semicolon
Print
Open parenthesis
Double quotation mark
Backslash
End string
After concatenation
Equals
Double quotation mark
Comma
String 3
Close parentheses
Semicolon
Print
Print openweb
Print open parenthesis
Double quotation mark
Double quotation mark
String 1
plus
Semicolon
Print, open parenthesis, double quotation mark, string 2, equals, double quotation mark, comma, string 2, close parenthesis, semicolon.
Print, open parenthesis, double quotation mark, string 3, equals, double quotation mark, comma, string 3, close parenthesis, semicolon.
Sum of Two Numbers
Hashmark, program to add two numbers.
Number One, equals, input, open parenthesis, double quotation mark, please enter the first number, colon, double quotation mark, close parenthesis.
Number Two, equals, input, open parenthesis, double quotation mark, please enter the second number, colon, double quotation mark, close parenthesis.
Hashmark, using the arithmetic operator to add two numbers.
Sum equals, float, open parenthesis, number one, close parenthesis, plus, float, open parenthesis, number two, close parenthesis.
Print, open parenthesis, single quotation mark, the sum of, open brace, zero, close brace, and, open brace, one, close brace, is, open brace, two, close brace, single quotation mark, period,
format open parenthesis number one comma number two comma sum close parenthesis close parenthesis
even and odd numbers hash mark program to check whether a number is even or odd
hash mark when a number is divided by two when the remainder is zero the number is even
hash mark if the remainder is one the number is odd num equals int open parenthesis input
open parenthesis double quotation mark enter a number colon double quotation mark close
parentheses close parentheses if open parenthesis num percent two close parentheses equal to zero
colon print open parenthesis double quotation mark open brace zero close brace is even double
quotation mark period format open parentheses num close parentheses close parentheses else
print open parentheses double quotation mark open brace zero close brace is odd double
quotation mark dot format open parentheses num close parentheses close parentheses
fibonacci series hash mark program to display the fibonacci sequence up to nth term when n is
provided by the user hash mark change this value for a different result n terms equals 10 hash mark
uncomment to take input from the user hash mark n terms equals int open parentheses input open
parentheses double quotation mark how many terms question mark double quotation mark close
parentheses close parentheses hash mark first two terms n1 equals 0 n2 equals 1 count equals
0 hash mark check if the number of terms is valid if n terms less than equal to 0 colon print open
parentheses double quotation mark please enter a positive integer double quotation mark close
parentheses Elif end terms equal to 1 colon print open parentheses double quotation mark fibonacci sequence
up to double quotation mark comma nterms comma double quotation mark colon double quotation mark
close parentheses print open parentheses n1 close parentheses else print openukost double quotation mark
Fibonacci sequence up to double quotation mark comma n terms comma double quotation mark colon double quotation mark close parentheses while count less than n terms colon print open parenthesis n1 comma n equals single quotation mark comma single quotation mark close parenthesis nth equals n1 plus n2.
Hashmark update values n1 equals n2 n2 equals nth count plus equals one palindrome hashmark program to check if a string is a palindrome or not hashmark change this value for a different output my underscore str equals single quotation mark I need to save Harry Potter single quotation mark hashmark make it
suitable for caseless comparison my underscore str equals my underscore str dot case fold open parenthesis close parenthesis hashmark reverse the string rev underscore str equals reversed open parenthesis my underscore str close parenthesis hashmark check if the string is equal to its reverse
access to
access elements in a list
MyUnderscoreList equals open bracket single quotation mark P single quotation mark comma
single quotation mark R single quotation mark comma single quotation mark O single quotation
mark comma single quotation mark B single quotation mark comma single quotation mark
E single quotation mark close bracket.
Hash mark output colon P.
Print open parenthesis my underscore list open bracket zero close bracket close parenthesis
Hash mark output colon o
Print open parenthesis my underscore list open bracket two close bracket close parenthesis
Hash mark output colon e
Print open parenthesis my underscore list open bracket four close bracket close parenthesis
hash mark error exclamation point only integer can be used for indexing
hash mark my underscore list open bracket 4.0 close bracket
hash mark nested list n underscore list equals open bracket double quotation mark happy double quotation mark comma
open bracket 2 comma 0 comma 1 comma 5 close bracket close bracket
hash mark nested indexing
hash mark output colon a print open parenthesis n underscore list open bracket 0 close bracket open bracket 1 close bracket close parenthesis
hash mark output colon 5 print open parenthesis n underscore list open bracket 1 close bracket open bracket 3 close bracket close parenthesis
Slice a list.
I single quotation mark comma single quotation mark Z single quotation mark close bracket.
Hash mark elements third to fifth.
Print open parenthesis my underscore list open bracket 2 colon 5 close bracket close parenthesis.
Hash mark elements beginning to fourth.
Print open parenthesis my underscore list open bracket colon hyphen 5 close bracket close parenthesis.
Hash mark elements sixth to end.
Print open parenthesis my underscore list open bracket 5 colon close bracket close parenthesis.
Hash mark elements beginning to end.
Print open parenthesis my underscore list open bracket colon close bracket close parenthesis.
Delete elements in a list.
Greater than greater than greater than my underscore list.
Equals open bracket single quotation mark p single quotation mark comma single quotation
mark r single quotation mark comma single quotation mark o single quotation mark comma single
quotation mark b single quotation mark comma single quotation mark l single quotation mark
comma single quotation mark e single quotation mark comma single quotation mark m single quotation
mark, close bracket. Greater than, greater than, greater than, my underscore list, open bracket,
2 colon, 3, close bracket, equals, open bracket, close bracket. Greater than, greater than, greater
than, my underscore list, open bracket, single quotation mark, P, single quotation mark, comma,
single quotation mark, R, single quotation mark, comma, single quotation mark, B, single quotation
mark comma single quotation mark l single quotation mark comma single quotation
mark e single quotation mark comma single quotation mark m single quotation mark
close bracket greater than greater than greater than my underscore list open
bracket 2 colon 5 close bracket equals open bracket close bracket greater than
greater than greater than my underscore list open bracket single quotation mark
p, single quotation mark comma, single quotation mark r, single quotation mark comma, single
quotation mark m, single quotation mark close bracket. Access elements in a tuple. My underscore
tuple equals open parentheses, single quotation mark p, single quotation mark comma, single
quotation mark e, single quotation mark comma, single quotation mark r, single quotation
mark, comma, single quotation mark, m, single quotation mark, comma, single quotation mark,
i, single quotation mark, comma, single quotation mark, t, single quotation mark, close parentheses.
Hash mark, output, colon, single quotation mark, p, single quotation mark. Print, open parentheses,
my underscore, tuple, open bracket, 0, close bracket, close parentheses. Hash mark, output,
colon single quotation mark t single quotation mark print open parentheses my underscore tuple
open bracket five close bracket close parentheses hash mark index must be in range hash mark if you
uncomment line 14 comma hash mark you will get an error period hash mark index error colon list
index out of range hash mark print open parentheses my underscore tuple open bracket six
close bracket close parentheses hash mark index must be an integer hash mark if you uncomment line
21 hash mark you will get an error period hash mark type error colon list indicates must be
integers not float hash mark my underscore tuple open bracket two point zero close bracket
hash mark nested tuple n underscore tuple equals open parentheses double quotation mark mouse
double quotation mark comma open bracket eight comma four comma six close bracket comma open
parentheses one comma two comma three close parentheses close parentheses hash mark nested index
dash mark Wang also seek a regular diagram
ulative index
April 30, May 25, 2020, 2016, 2017, 2017, 2013, 2018, 2019, 2019, 2019, 2019, 2018, 2019, Premium, 2019, 2021, 2019, 2019, 2019, 2017, 2019, 2019, 2019, 2021, 2020, 2019, 2019, 2019, 2019, 2019, 2021, 2019, 2019, 2019, 2019, 2020, 2020, 2019, 2019, 2018, 2019, 2019, 2019, 2017, 2019, 2019, 2019, 2019, 2019, 2019, 2019, 2019, 2019, 2019, our new 2019,icos, 2019, 2019, 2019, 2017, 2018, 2019, 2019, 2019, 2020, 2019, 2019, 2017, 2019, 2019, 2019, 2019, 2017, 2019, 2019, 2019, 2019, 2019, 2019, 2018, 2019, 2019, 2019, 2019, 2018, 2019, 2018, 2020, 2020, 2019, 2018, 2019, 2019, 2021.
N underscore tuple, open bracket zero, close bracket, open bracket three, close bracket,
close parentheses.
Hashmark nested index
Hashmark output colon 4
Print open parenthesis n underscore tuple open bracket 1 close bracket open bracket 1 close bracket close parenthesis
Change a tuple
My underscore tuple equals open parenthesis 4 comma 2 comma 3 comma open bracket 6 comma 5 close bracket close parenthesis
Hashmark we cannot change an element
Hashmark if you uncomment line 8
Hashmark you will get an error colon
Hashmark type error colon single quotation mark tuple single quotation mark object does not support item assignment
Hashmark my underscore tuple open bracket 1 close bracket equals 9
Hashmark but item of mutable element can be changed
Hashmark output colon open parenthesis 4 comma 2 comma 3 comma open bracket 9 comma 5 close bracket close parenthesis
My underscore tuple open bracket 3 close bracket open bracket 0 close bracket equals 9
Print open parenthesis my underscore tuple close parenthesis
Hashmark tuples can be reassigned
Hashmark output open parenthesis
Hashmark output open parenthesis single quotation P single quotation comma single quotation R single quotation O single quotation KOMA single quotation KOMA single quotation KOMA single quotation KOMA single quotation KOMA single quotation KOMA single quotation KOMA A single KOMA single comparison KOMA single KOMA single KOMA single KOMA single KOMA single KOMA single KOMA single KOMA single KOMA single KOMA sign what are you?
close parenthesis. My underscore tuple equals open parenthesis single quotation mark P single
quotation mark comma single quotation mark R single quotation mark comma single quotation
mark O single quotation mark comma single quotation mark G single quotation mark comma
single quotation mark R single quotation mark comma single quotation mark A single quotation
mark comma single quotation mark M single quotation mark comma single quotation mark
I, single quotation mark, comma, single quotation mark, Z, designation mark, close parentheses.
Print, open parentheses, my underscore tuple, close parentheses.
Create a string.
Hash mark all of the following are equivalent.
My underscore string equals, single quotation mark, hello, single quotation mark.
Print, open parentheses, my underscore string, close parentheses.
My underscore string equals double quotation mark hello double quotation mark.
Print open parentheses my underscore string close parentheses.
My underscore string equals triple quotation mark hello triple quotation mark.
Print open parentheses my underscore string close parentheses.
Hashtag mark triple quote string can extend multiple lines.
my underscore string equals double quotation mark double quotation mark double quotation mark
hello welcome to the world of python double quotation mark double quotation mark double
quotation mark print open parentheses my underscore string close parentheses
conclusion thank you for purchasing the book this book acts as a guide for those who are
working with python for the first time over the course of the book you'll gain information on
what python is and how to code in python before you begin to program there are some questions you
must ask yourself to understand the right code you must write this is called the software development
stage and is one of the most important steps to complete when writing a code python is a simple
language and is written as a pseudo code as a programmer you'll find that it's easy for you to
code in python you'll gather information on different aspects of python including data types
structures functions how to work with files how to work with strings including others there are some
exercises given at the end of the chapters which can be used to practice the solutions to these
exercises are provided in the last chapter of the book the exercises provided in the book are simple
but they'll help you learn how to write simple code in python once you understand the language better
you can go on to developing larger and more complex programs try to work on the exercises before you
look at the solutions in the last chapter you must remember that it is practice that will help you
become the best programmer in any language it's okay to make mistakes when you write code but it's
important that you learn from those mistakes keep a notepad close to you and make note of all the
variables and functions you've declared in your code to ensure that you don't overwrite them with new code
i hope you gather all the information you're looking for good luck on your new adventure
now head over to audible and tell me what you think timothy c needham other books by timothy c needham
python for beginners a crash course guide to learn python in one week excel 2016 a comprehensive
beginner's guide to microsoft excel 2016 learn java a crash course guide to learn java in one week
all rights reserved no part of this publication may be reproduced or transmitted in any form
whatsoever electronic or mechanical including photocopying recording or any informational storage
retrieval system without express written dated and signed permission from the author
sneak preview of python for beginners i would like to share with you a free sneak peek to another one of
my audiobooks that i think you'll really enjoy the audiobook is called python for beginners a crash course
guide to learn python in one week and it's about how you can easily learn python language in less than a
week enjoy chapter one python a comprehensive background before we continue please refer to
your audiobook companion pdf that comes free with your purchase of this audiobook to see and learn all
the codes explained with charts and images before we discuss python programming especially what python
is let me briefly say something about programming being a good programmer does not simply entail
just knowing a vast array of programming languages or how to code fast programs instead it's about
comprehending a problem abstractly and being able to change it into code looking for new ways to tackle
for instance a scientific problem and knowing the kind of tools to use being able to fix a program when
it's not working writing a program that is quick enough not the quickest possible writing a program that other
people can understand in a short period of time take note of the last point reproducible research and
open science is becoming the norm in some research fields this means that other people will probably
have to read your code understand exactly what you're doing and be able to recreate the code so that they can run it
themselves by the end of this book therefore we will not only be interested in the correctness of your solution
we shall also look at whether we can understand how the program you create solves the problem
this is to mean that you should always write your codes assuming that someone else will read it
let's go back to understanding python the programming language of the future
what is python in its simplest terms python is a general purpose multi-paradigm and interpreted programming
language that gives programmers the ability to use various styles of programming to create complex
or simple programs get results faster and write code in a way that resembles human language explanation
below python is the programming language often used to create algorithms for sorting and analyzing chunks
of data that businesses and organizations from all over the world collect the explanation above brings
about some very interesting points about python number one it's a high level language python is a high
level language this means the code you type to build a program is more like a human language than
the typical code created to control machines this for one makes things a lot simpler for you the programmer
and means that someone else is better placed to understand the code if he or she wants to use it him or
herself the human-like high-level code then goes through a software called an interpreter that
converts it into machine code a language that machines can understand number two it's open source the software
that lets us make programs in python is open source this means it's available in the public domain and
anyone can freely use it the greatest advantage of this software is the fact that you can modify it and
create your own version to perform particular tasks this is actually the main reason why many people have
openly embraced the open source concept and the use of python is no exception let's discuss this briefly
associations that use python many organizations currently use python to complete major tasks you'll not
always hear about their uses since organizations are somewhat reserved about sharing their systems
information or trade secrets nonetheless python is still there making a great difference in the way
organizations function and many common systems and applications have settled for python for their
development some of them include youtube google search bit torrent nasa eve online i robot machines yahoo
facebook maya and many others look for the following commercial uses of python
correll over the years people have used products such as paint shop pro to grab screenshots modify
pictures draw fresh images and perform many other graphic oriented tasks what's amazing about this
popular product is that it heavily relies on python scripting this means to automate tasks in paint shop pro
you'll need a degree of python knowledge d-link it can be quite problematic to upgrade firmware over
a network connection and this company d-link encountered a situation where every upgrade tended to tie up a
machine something they described as a weak utilization of resources additionally a number of upgrades needed
extra work since there were problems with the targeted device the use of python to build a multi-threaded
application that allows for the movement of updates to the devices enables one machine to service several
devices and a new methodology supported by python decreases all the reboots to one after the installation
of that fresh firmware is done moreover this company opted for python over other languages such as java because
python offers an easy to use serial communication code forecastwatch.com have you ever wondered if someone
somewhere reviews your weatherman's performance well if you have look no further this company does that
this company compares the thousands of weather forecasts produced every day against real climatological
data in order to determine their accuracy the produce report advances weather forecasts in this particular
case the software used in the comparisons is a pure python program since it contains standard libraries that
are important in the collection parsing and storage of data from online sources additionally the enhanced
multi-threaded nature and capability of python gives it the ability to gather the forecasts from about
5 000 sources per day the code is also a lot smaller than what other languages like php or java would need
many other companies softwares and programs use python and to sum this up i'll say that scientists
business people teachers governments and even religious organizations just to mention the least use python
programming in one form or another you too should also get started with learning python if you don't
want to be left behind we'll start from the beginning i.e downloading the program chapter 4 interacting with python
before we continue please refer to your audiobook companion pdf that comes free with your purchase of this
audiobook to see and learn all the codes explained with charts and images in this section you'll learn
how to use and interact with python in the number of available ways let us begin by talking about
python's interpreter while using the console of your operating system a console is also referred to as a
command prompt or a terminal it's a textual method of interacting with your operating system just as the
desktop together with the mouse is the graphical method used to interact with your pc
how to open a console on mac osx the standard console of osx is a program known as terminal
to open it navigate to applications then go to utilities and double click the terminal program
you can also easily search for it in the search tool at the top right of the screen
the command line terminal is a tool you'll use to interact with your computer a window having a
command line prompt message that looks like the code below will open my computer colon tilde my username dollar
sign how to open a console in linux the different distributions of linux such as mint fedora ubuntu may
have dissimilar console programs typically known as terminals the particular terminal you open and
how you do so can depend on your distribution let us take one example on ubuntu you'll probably
want to open gnome terminal it presents a prompt similar to this my username at my computer colon tilde dollar
sign how to open a console on windows windows console is also referred to as the command prompt
or cmd you can easily get to it by using the key combination windows plus r windows in this case
refers to the windows log button that opens the run dialog just type cmd and press enter or just click
ok you can also use the start menu to search for it it should appear like this c colon backslash users
backslash my username greater than the windows command prompt is not as potent as its counterparts
on osx and linux are therefore you should consider directly starting the python interpreter or use the
idle program that comes with python all of these are accessible from the start menu
starting and interacting with python the python program you've installed will act as something we
usually refer to as an interpreter the interpreter picks up text commands and runs them as you write
them which is quite handy for trying stuff out at your console just type python then press enter and
you should enter the interpreter as soon as python opens you'll see some contextual information resembling the
following python 3.5.0 open parenthesis default sep 20 2015 comma 11 colon 28 colon 25 close parenthesis
open bracket gcc 5.2.0 close bracket on linux type help copyright credits or license for more information
greater than greater than greater than greater than greater than on the last line we have the
prompt greater than greater than greater than which indicates that you're currently in an interactive
python interpreter session known as python shell you should note that the python shell is different
from the normal command prompt at this point you can try entering some code for python to run
try the following print open parenthesis double quotation mark hello world double quotation mark
close parentheses hello world greater than greater than open parenthesis
1 plus 4 close parenthesis close Both macaroni CHot FL  uh...
to 10. Help is a very useful command since it enters a help functionality that lets you explore
all the things Python enables you to do right from the interpreter. To close the help window,
press Q and go back to the Python prompt. You can also press Ctrl-Z to leave the interactive
shell and return to the console or the system shell. On OSX or Linux, press Ctrl-D or on the
Windows button, enter. Let us now try a simple exercise. Earlier, I demonstrated entering a
command to work out some math. You can now try out some math commands. Do you know any Python
operations? Tell it to give you the squared result of the sum of 239 and 588. There are several ways
you can get the answer. Greater than, greater than, greater than, 239 plus 588, 827. Greater than,
greater than, greater than, 827, asterisk, 827, 683,929. Greater than, greater than, greater than,
open parenthesis, 239 plus 588, closed parenthesis, asterisk, asterisk, asterisk, asterisk, 2, 683,929.
Greater than, greater than, greater than, open parenthesis, 239 plus 588, closed parenthesis,
asterisk, asterisk, asterisk, 2, 683,929. Running the Python files. When you have a large Python code
to run, you'll want to save it into a file. For example, you can modify it into little parts,
fix a bug, and rerun the code without having to type the rest repeatedly. You can save your code to a
file and pass the name of the file to the Python program instead of typing the commands one by one.
This executes the file's code instead of launching the interactive interpreter.
Let us try that. Just create a file in the current directory labeled hello.py with your most
preferred code editor and then enter the print command above. Next, save the file. On OSX or Linux,
run touch hello.py so that you can create an empty file to edit. It's very easy to run this file with
Python. $python hello.py. Ensure that you're positioned at your system command prompt, which
will either have a $ or greater than at the end, not at Python's, which contains greater than, greater
than, greater than instead. If you're using Windows, you can double-click the file to run it.
When you press enter now, the file will execute and you'll see the output. This time, however,
when Python has completed the execution of all commands from the file, it exits back to the system
command prompt as opposed to returning to the interactive shell. At this point, we can now get
started with the turtle project. Even so, you have to note the following. Note, if you're getting weird
errors about no such file or directory or can't open file instead of getting hello world, it means your
command line is most probably not running from the directory in which you saved your file.
You can go ahead and change your current command line's working directory with the cd command.
cd stands for change directory. On Windows, you might prefer something like
greater than cd desktop backslash python underscore exercises. If you're using OSX or Linux,
you might prefer seeing something like dollar sign cd desktop forward slash python underscore exercises.
This changes to python underscore exercises directory under the desktop folder or somewhere
like that. If unsure of the location directory you saved the file in, simply drag the directory
to the command line window. Again, if you're not sure in which directory your shell is currently
running, use pwd. It stands for print working directory. Note, when you begin playing around
with turtle, avoid naming your file turtle.py. You can try using more apt names like rectangle.py
or square.py. Otherwise, each time you refer to turtle, Python will immediately pick up your file
in place of the standard Python turtle module. Before we learn a few more things about Python
and start handling the intermediate projects, you ought to be able to handle a few basic projects
by now, including turtle. Let's cover that one first. If you're enjoying the audiobook,
I would love it if you went to Audible and left a short review.
Chapter 6. Variables
Before we continue, please refer to your audiobook companion pdf that comes free with your purchase
of this audiobook to see and learn all the codes explained with charts and images.
I'm sure that you've noted that experimenting with angles requires changing three different
numbers or places in the code each time. Can you imagine trying all the sizes of squares
or with rectangles? Would that not be tedious? Luckily, we have easier ways to do that than
changing many numbers each time. Using variables, we can achieve that sleekly. You'll be able to
tell Python that whenever you refer to a variable, you actually mean something else. When you relate
it to symbolic math, where you can write let x be 5, this concept may be a bit more familiar.
In this case, then x asterisk 2 is obviously 10. In Python syntax, this statement is explained
as x equals 5. After the statement, if you happen to print x, it outputs the value minus 5. We can
also use that for turtle as well. Turtle dot forward, open parenthesis, x, close parenthesis.
Variables store all sorts of stuff, not just numbers. Another thing you may want to store
regularly is a string. A string just refers to a piece of text. These strings usually have a starting
as well as an ending double quote. We'll delve into that, the other data types you can store,
and what you can use these for later in the book. Did you know that you can even refer to the turtle
by name using a variable? Here's an explanation of this in play. John equals turtle. Now, each time you
type John, Python thinks you mean turtle. However, you can keep using turtle as well. John dot forward,
open parenthesis, five, zero, close parenthesis. John dot left, open parenthesis, nine, zero, close
parenthesis. Turtle dot forward, open parenthesis, five, zero, close parenthesis. The angle variable.
This is an exercise. If you create a variable known as a tilt, you could assign it a number of degrees.
How could you use that to make your experiment with the tilted squares program much faster?
This is the solution. Tilt equals 20. Turtle dot left, open parenthesis, tilt, close parenthesis.
Turtle dot forward, open parenthesis, five, zero, close parenthesis. Turtle dot left, open parenthesis,
nine, zero, close parenthesis. Turtle dot forward, open parenthesis, five, zero, close parenthesis.
Turtle.left, open parenthesis, nine, zero, close parenthesis.
Turtle.forward, open parenthesis, five, zero, close parenthesis.
Turtle.left, open parenthesis, nine, zero, close parenthesis.
Turtle.forward, open parenthesis, five, zero, close parenthesis.
Turtle.left, open parenthesis, nine, zero, close parenthesis.
Turtle.left, open parenthesis, tilde, close parenthesis.
And so on.
Note, you could also apply this principle to the size of the squares.
Santa Claus's house.
Now, draw a house.
Note, you can calculate the diagonal line's length using the Pythagorean theorem.
This is actually a good value to store in as a variable.
To determine the square root of a given number in Python,
you ought to first import the specific math module, then proceed to use this function.
Math.sqrt, open parenthesis, close parenthesis.
We exponentiate a number with the asterisk, asterisk operator.
Thus, squaring means asterisk, asterisk, two.
Import math.
C equals math.sqrt, open parenthesis, a, asterisk, asterisk, two, plus b, asterisk, asterisk, two, close parenthesis.
Next, we'll be discussing loops.
If you're enjoying the audiobook, I would love it if you went to Audible and left a short review.
This has been Python 3 Programming, a beginner crash course guide to learn Python 3 in one week.
Written by Timothy C. Needham
Narrated by Zach Alleman
Copyright 2018 by Timothy C. Needham
Production Copyright by Timothy C. Needham
Thank you.
Audible hopes you have enjoyed this program.
