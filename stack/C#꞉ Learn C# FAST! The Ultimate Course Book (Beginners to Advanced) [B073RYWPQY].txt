This is Audible.
C-Sharp. Learn C-Sharp Fast. The Ultimate Coursebook.
Beginners to Advanced.
Written by Gary Mitnick.
Narrated by Sean Tivenin.
Preface.
This e-book is aimed at anyone wanting to learn the C-Sharp programming language,
but is not completely new to programming.
The first section of this e-book introduces you to the basics of C-Sharp.
Should you not have a software installed to develop C-Sharp applications,
you can get Visual Studio installed and have a simple console application up and running in no time.
A basic introduction to keyboards, namespace types, and arithmetic operators is covered,
which is built on in the next section.
The second part of this e-book takes these simple operations and places them into methods
and explains how to make decisions in your program,
set up a path of execution, and deal with errors.
It covers how values are stored in computer memory and why it is important for your program.
Classes, objects, and encapsulation show you how to model entities in your code,
while enumerations and arrays means of storing and manipulating your data.
In the third section of this e-book,
you will learn how to extend the types you have created in the second part of this book.
You will learn about creating events that other sections of the program can listen to
and take action on via delegates.
Learn about LINK, a powerful tool for any developer working with data.
Use Lambda Expression to create local functions and create delegates.
The key to learning C-Sharp is to start coding as soon as possible.
Don't wait until you're an expert in theory.
Start writing software immediately.
I hope you will find this e-book to be a great resource in establishing your C-Sharp expertise,
and you will continue to reference it.
I have placed some references at the very back of this e-book
that I hope you will find very useful.
Part 1. Introduction.
What is C-Sharp?
C-Sharp is a multi-paradign or multi-styled object-oriented programming OOP,
language encompassing strong typing, argument must match type,
declarative, describe what you wish to do and not how you want to do it,
imperative, how to do, functional, functional approach,
generic, algorithms are developed in terms of types to be detailed later,
and also component-oriented programming, i.e. an internet service, a software package,
a website resource, or perhaps a component which encapsulates some related features or information.
The aim is to allow programmers to use the most suitable programming style
and associated language constructs for a specific job,
seeing that not one example solves all problems.
Microsoft C-Sharp is now a well-established programming language
that builds on features found in predecessor C-style languages,
like C, C++, and Java,
making it acquainted to many knowledgeable programmers.
It inherits lots of the best highlights of C++,
yet is designed to be a cleaner and more logical language.
C-Sharp is part of a larger, more complex open-source execution platform
called the Common Language Infrastructure, CLI.
It is this specification that facilitates us to use a high-level language like C-Sharp on various machines,
macOS X, Linux, Solaris, iOS, Android,
without rewriting the code.
Common Language Infrastructure, CLI.
Instead of directly generating instructions which a processor can understand,
the C-Sharp compiler issues instructions in an intermediate language,
the CIL, Common Intermediate Language.
An additional compilation step occurs, usually at execution time,
converting the CIL to machine code that the processor can understand.
What can I do with C-Sharp?
With C-Sharp, you can develop web applications with ASP.NET,
build mobile applications with Windows Phone Desktop,
or develop applications with Windows Presentation Foundation, WPF.
Some other applications consist of code which runs in the cloud via iOS,
Windows Azure, Android, and Windows Phone support the Xamarin platform.
What is the .NET Framework?
.NET is a platform which incorporates languages, a runtime, and framework libraries,
enabling developers to create numerous types of applications.
C-Sharp is one of the main .NET languages.
However, there is Visual Basic, F-Sharp, C++, and more.
The formal name of the runtime is the CLR, or Common Language Runtime.
The programming languages that aim at the CLR compile into an intermediate language, IL.
The CLR itself can be described as virtual machine that runs IL and supplies many offerings,
such as memory management, security, exception management, garbage collection, and much more.
The FCL, or Framework Class Library, is a set of reusable code that offers both technology-specific platforms
and general all-purpose services.
The general services include crucial types such as networking, cryptography, collections, and more.
In addition to general classes, the FCL contains technology-specific platforms like WPF,
Web Services, ASP.NET, amongst others.
The FCL's worth comes from having common components available for reuse,
conserving time and money without needing to write that code by yourself.
There's an enormous ecosystem of open-source and commercial software that depend on and supports .NET.
You must visit GitHub, CodePlex, or any extra open-source code repository site
and see the many projects written in C-Sharp.
Commercial offerings include services and tools to assist you building code,
managing systems, and offer applications.
Beginning C-Sharp programming with Visual Studio Community Edition.
The previous section described numerous great things you can do with C-Sharp.
However, most of them are so detailed that they need their own book.
This e-book is totally focused on the C-Sharp programming language
and the code will be executed as a console application.
It's the simplest application to get up and running,
and once you comprehend the code, you can easily use it on another C-Sharp application type.
You can write your code with any editor,
but this e-book uses Visual Studio 2015 Community Edition, which is free.
Should you not have Visual Studio installed on your machine,
please visit the following address,
https colon backslash backslash www.visualstudio.com backslash downloads backslash
and select free download of Microsoft Visual Studio Community Edition.
Once Visual Studio is downloaded, follow the installation through and start VS up.
In VS, select File, New, Project.
Then select Installed, Templates, Visual C-Sharp in the tree on the left,
and finally select the Console Application Project type.
In the Name field, rename it to Hello World.
Set the location to your preference and click OK.
This will create a new solution for you.
When Visual Studio finishes loading, your solution will appear.
Add the following line console dot right line Hello World as illustrated.
Once complete, press CTRL and F5,
or go to the menu select Debug and Start without debugging.
If you just press F5, VS will run the program while waiting for a response.
This will compile your program and print the following on the console.
The program dot cs file outlines a class named Program, which has a main method.
In C Sharp, all executable code must be defined within a method,
and all methods must belong to a class or a struct.
The main method designates the program's entry point.
This method should be defined in the manner specified here in the program class,
as a static method.
If it's not designated as such,
the .NET framework might not recognize it as the starting point for your application when you run it.
Note, C Sharp is a case-sensitive language.
You must spell main with an uppercase M.
A class has members, and this example shows a method member named main.
A method can be equated to a function or a procedure in other programming languages.
There are two sets of curly braces,
one for the program class and another for the main method,
which are referred to as a block,
indicating the beginning and end of the scope.
The static modifier indicates that there is only ever one instance of a program class
that has that main method.
It is the static instance.
Main must be static,
but other methods can omit static,
which makes them instance numbers.
This means that you can have numerous copies of a class or instance with their own method.
Seeing that a program only needs a single main method,
static makes sense.
A program that manages clients might have a customer class,
and you would need several instances to represent each customer.
Later, you will see examples of instantiating classes later in this ebook.
The code begins with a using clause for the system namespace.
Typically, the FCL, Framework Class Library,
is gathered into namespaces to keep code organized
and prevent clashes involving identically named types.
This using clause enables us to utilize the code in the system namespace.
We are doing so with the console class.
Without that namespace,
the compiler doesn't know what console means or how to find it.
However, now C-sharp knows that we're using the system.console class.
Namespaces.
The actual example up to now have been an extremely application.
However, little programs may grow into much larger programs.
And as a program develops, two problems arise.
Firstly, it is more difficult to comprehend and maintain large programs
than it is to comprehend and maintain small programs.
Secondly, extra code usually means extra classes,
with more methods, requiring you to keep tabs on more names.
One of the most convenient and simplest ways to organize code
is with the C-sharp namespace feature.
The following is a hierarchical portrayal of where namespaces fit into a program's overall structure.
Namespace, type, type members.
Out of this hierarchy, the namespace is optional.
However, if you leave it out, the class will be a member of the global namespace,
so there is a possibility of a clash with other class names.
It's a rather good procedure to place each of your classes in namespaces.
You are able to bring the namespace into scope using the using directive at the top of the program.
Coding expressions and statements.
In the first part of this e-book, you saw how to write, compile, and execute a simple C-sharp program.
The example program had a single statement in the main method.
Now you will learn how to write more statements and add logic to your program.
Whitespace.
C-sharp is a free-format language, which means that whitespace, space, tab, and newline characters
is not significant except as a separator.
So you are free to lay your statements in any style you choose.
Keywords.
To allow the compiler to translate the program code,
certain terms within C-sharp have unique status as well as meaning.
These are known as keywords,
and they deliver the concrete syntax that the compiler utilizes
to interpret the expressions that the programmer writes.
In the first Hello World program,
class, static, and void are all instances of keywords.
The compiler utilizes the keywords to identify the organization and structure of the code.
Since the compiler interprets these words with higher significance,
C-sharp necessitates that developers place keywords only in certain locations.
When your program breaks these rules, the compiler will promulgate errors.
C-sharp keywords, abstract, as, base, bool, break, byte, class, catch, checked, char, case, const,
continue, decimal, default, delegate, do, double, else, enum, event, explicit, extern, false, finally, fixed, float, for, for each,
go to, if, implicit, in, int, interface, internal, is, long, lock, namespace, new, null, object, operator, out, override, params, private, protected, public, read-only, ref, return,
s-byte, sealed, size of, short, stack, all, OC, string, static, struct, switch, this, throw, try, true.
In addition, C-sharp also uses the subsequent identifiers.
However, these identifiers are not reserved in C-sharp,
so you can use these names as identifiers for your own variables, methods, and classes,
but nevertheless, the best action to take is to stay away from doing so whenever feasible.
Set, set, value, var, where, where generic, yield, variables.
What is a variable?
It is simply a storage area or container with a name which our programs can change its contents.
Every variable in C-sharp has a particular type,
which governs size and layout of the variable's memory,
the variety of values that can be stored within that memory,
and the list of operations that is applied to the actual variable.
You must give your variables a well-understood name
and make sure you don't use the keywords, previous section.
There is a standard naming convention in C-sharp,
meaning you cannot start variables with an underscore.
It's really advisable to follow best practice of placing a lowercase letter
with each subsequent word of the variable having an initial uppercase letter.
This is camel case.
Variables hold values, and C-sharp has many dissimilar types of values that it can store and process.
For example, floating points numbers, integers, and strings of characters.
Whenever you declare a variable, you must specify the type of data it will hold.
Types.
A type sets out the blueprint for a value.
As discussed, C-sharp is a strongly typed language,
which means that the compiler won't implicitly convert between incompatible types.
For instance, you can't assign a string to an integer or an integer to a string,
certainly not implicitly.
The subsequent code example will not compile.
Int total equal 359.
String message equal 7.
The following tables illustrate the built-in types.
You should add a suffix to a number when the meaning would be ambiguous.
With the subsequent example, the m suffix ensures that the 6.25 is handled as a decimal number.
Decimal price equals 6.25m.
You can assign Unicode values direct to any char.
The following demonstrates how to delegate a space to a variable named add a space.
Char add a space equals slash U0032.
Also, you can get the Unicode value of a character by performing a cast operation.
Int space Unicode equals parentheses, int parentheses, space.
Arithmetic operators.
C-sharp supports regular arithmetic operations like the plus sign for addition,
the minus sign for subtraction,
the asterisk for multiplication,
and the forward slash for division.
The symbols plus, minus, asterisk and slash are called operators
since they operate on value to create new values.
In the following example,
the variable price gain ends up holding the product of 12.50 and 3.
Long price gain.
Price gain equals 12.50 asterisk 3.
C-sharp has many other operators that allow you to perform
all of the logical operations you would expect
of any general-purpose programming language.
The subsequent table illustrates some of the available operators.
Prefix operators change the value of the variable before assignment.
And postfix operators modify a variable after assignment,
as illustrated in the following example.
Int value 1 equals 6.
Int value 2 equals plus plus val 1.
Int value 3 equals 3.
Int value 4 equals value 3 minus minus.
Both value 1 and value 2 are 7.
The value 3 variable is 2,
but value 4 is 3.
This is so because the postfix operator evaluates after assignment.
Directing precedence.
Priority is given to some operators over others.
Consider the following expression,
which uses the plus and asterisk operators.
2 plus 3 asterisk 5.
This expression is potentially vague.
But in C-sharp,
the multiplicative operators asterisk, slash, and percentage
have precedence over the additive operators plus and minus.
In this example,
the 3 asterisk 5 multiplication is executed first,
followed by the plus 2 addition.
The answer to 2 plus 3 asterisk 5 is therefore 17.
You can use parentheses to override precedence and force operands to bind to operators in a way of your choosing.
For example, perform the addition of 2 and 3 and multiply the result by 5.
Associativity to evaluate expression.
Sometimes an expression contains different operators that have the same precedence,
like slash and asterisk.
Associativity is the direction, left or right, in which the operands of an operator are assessed.
Look at the following expression that uses the asterisk and slash operators.
4 slash 2 asterisk 7.
In this instance, the associativity of the operators governs how the expression is assessed.
The two multiplicative operators, asterisk and slash, are left associative,
denoting that the operands are assessed left to right.
In this case, 4 slash 2 will be assessed before multiplying by 7, giving the result 14.
Associativity and the assignment operator.
As noted, the equal sign is an operator.
Each operator returns a value based on the operands,
and the same goes for the equal assignment operator.
It acquires left-hand side and right-hand side operands.
It simply takes the right side, evaluates it, and stores it on the left side.
The left operand has the value of the assigned operator.
In the subsequent example, the value returned by the assignment operator equals 15.
int myinteger myinteger equals 15 slash slash the value of assignment expression is 15.
Equally, you can assign several variables to the same value.
myinteger 5 equals myinteger 4 equals myinteger 3 equals myinteger 2 equals myinteger equals 15.
Incrementing and decrementing variables.
In C Sharp, you can use the plus operator to increment a variable, as demonstrated here.
initialPrice equals initialPrice plus 1.
However, this is so common in C Sharp that it has its own operator.
initialPrice plus plus.
Equally, the subsequent code subtracts 1 from the variable initialPrice.
initialPrice minus minus.
You can place the plus plus or minus on either side of the variable,
but take note that all operators are utilized to evaluate an expression that has a value.
So, the value returned by initialPrice plus plus is the value of count before the increment takes place.
Whereas, the value returned by plus plus initialPrice is the value of count after the increment takes place.
Here is an example.
int initialPrice.
initialPrice equals 35.
console.brite-line.
experient-price is now 36.
35 is outputted to console.
initialPrice equals 35.
console.brite-line.
initialPrice plus plus parentheses.
slash slash initialPrice is now 35.
35 is outputted to console.
Declaring implicitly typed local variables.
So far in this ebook, you have seen that you declare a variable by specifying a data type
and an identifier, like the following.
Int my int.
It is also good practice to assign a value before you attempt to use it, like the following.
Int my int equals 100.
You must remember that the value you assign must be of the same type as the variable.
The compiler can work out which is the best type of expression if you use the var expression
as demonstrated in the subsequent example.
var my first variable equals 1000.
var my second variable equals bonjour.
In the subsequent examples, my first variable is an integer, and my second variable is a string.
It is most important, however, for you to appreciate that this is a handiness for declaring only variables.
And after a variable has been declared, you can assign only values of that type to it.
You can't, for example, assign a double, float, or string values to my first variable at a later point in your code.
You should take note that you can only utilize the var keyword once you have supplied an expression to initialize a variable.
This subsequent declaration is illegal, and the program will not compile.
var one more variable slash slash compiler can't determine the type error.
Summary.
In this section, you saw how to create a simple C-sharp program, how to use variables.
You learned about the common data types available for variables in C-sharp.
You also learned about the precedence and associativity of operators, and how expressions are assessed.
Part 2.
Understanding the C-sharp Way.
Methods and Properties.
The previous chapters showed how to write code in the main method.
That's the program's entry point, but it's normally a lightweight method without too much code.
In this chapter, you will begin to relocate your code out of the entry point of the program to better manage your code.
You will start how to outline methods with parameters and return values.
You will also utilize properties, which in turn lets you encapsulate the object's state.
One method is grouping together a series of statements to accomplish a particular action or compute a certain final result.
It is a named series of statements.
In other languages like C, C++, or Visual Basic, you can see a method is similar to a function or subroutine.
It has a name and a body.
The method name should be a meaningful identifier that indicates the overall purpose of the method.
For example, calculate take-home pay.
The lines of code to be executed are included in the body of the method.
Those lines are executed when the method is called.
The method can be given some data for processing and can return information, which is typically the result of the processing.
In C-sharp, methods are a fundamental and powerful mechanism.
Declaring methods.
The syntax for declaring a C-sharp method is as follows.
Return type method name parentheses parameter list parentheses squiggle bracket slash slash method body statements go here squiggle bracket.
The return type is the name of a type and specifies what kind of information the method returns as an outcome of the method's processing.
This can be any type.
A list is given in the previous chapter, such as an int or string.
If it fails to return anything, then you must utilize the keyword void in place of the return type.
The method name is the name used to call the method.
You should follow the same camel case convention as used when declaring variables earlier.
For example, calculate take-home pay.
The parameter list is not mandatory, but it describes the names and types of the information that you can pass into the method for it to process.
You write the parameters between opening and closing parentheses.
Like you are declaring a variable with the name of the type succeeded by the name of the parameter, for example,
int first parameter, int second parameter.
If the method takes more than one parameter, you must separate each value with a comma.
The statements in the method body are the lines of code that are executed when the method is invoked.
They are surrounded by opening and closing brackets.
If you wish to return data from a method, you must include a return statement at the end of processing in the main body of the method.
The return statement can contain two parts.
The word return succeeded by an expression that indicates the return value and a semicolon.
The type of the expression must be the same as the type specified by the method declaration.
Therefore, if a method returns an integer, the return statement has to return an int, or else your program simply will not compile.
The subsequent illustration is an example of a method named addToNumbers, which takes two integer values as parameters,
adds the values together, and returns an int value.
If you don't want your method to return anything from your method, you can use return followed by a semicolon like the following.
It will immediately exit the method.
Bracket, return, bracket.
Calling methods.
You can call a method from another part of the program to perform its task.
In order to call the method, you must use its exact name and match its signature as specified by its parameters.
So, if a method has two integer parameters, you must pass two integer values.
Using the above addToNumbers example, the following is fine.
AddToNumbers, parentheses, 23, 6, parentheses.
You can replace the numeric values of 23 and 6 with the names of two int values, and then call the method like so.
int num1 equals 23.
int num2 equals 6.
AddToNumbers, parentheses, num1, num2, parentheses.
Applying scope.
The scope of a variable is the region of the program in that that variable is actually usable.
A variable is said to be in scope in a particular location when it can be accessed at that location in a program.
You are able to specify variables with diverse scope.
Scope is applicable to methods in addition to variables.
The actual scope of an identifier, be it variable or method, is associated to the location of the declaration that introduces the identifier in the program.
Local scope.
The actual opening and closing brackets that make the body of a method define scope of a method.
Every variable which you declare inside the body of a method is scoped to that method.
They vanish when the method ends, and can be accessed solely by code running in that method.
They are known as local variables for the reason that they are local to the method in which they are declared.
They are not in scope in any additional method.
It is not possible to share information between methods because of the scope of local variables.
Consider the following example.
The specific code will not compile due to the fact another method is attempting to utilize the variable myvar, which isn't in the same scope.
Myvar, the variable, is available solely to the code in first method, between the two braces.
Class scope.
The opening and closing brackets which form the main body of a class determine the scope of the class.
Whatever variable you declare in the body of a class, excluding any variables in a method, are scoped to that class.
The proper C-sharp term for a variable defined by a class is field.
As previously stated, you can utilize fields as opposed to local variables to share information between methods.
The variable firstfield is defined outside the methods first method and another method in the class.
Therefore, firstfield has class scope and is accessible for use by every method in that class.
There is one other point to notice about this example.
Inside a method, you must declare a variable before you can avail of it.
However, fields are a bit different.
A method can utilize a field before the statement that actually defines the field.
The compiler works out the details.
Method overloading.
Essentially, overloading a method is when you have numerous methods with identical names, but take different parameters.
Different parameters could be varying the parameter count, n slash, or varying data types.
Method overloading is a form of polymorphism.
Polymorphism occurs when the same logical operation takes on my, poly, forms, morphs, because the data varies.
Overloading is most useful when you need to carry out the exact same operation on different data types, or different groups of information.
Keep in mind that even though it is possible to overload the parameters of a method, you can't overload the return type of a method.
I.e., you can't have two methods with identical names, and the only difference is their return type.
The following illustration is an example of overloading a method.
Here you can see a class called Introductory Maths.
It has three methods with the same name, but take a different number of parameters.
Optional parameters and named arguments.
Starting with C Sharp 4.0, the language designers added support for optional parameters.
By allowing the association of a parameter with a constant value as part of the method declaration,
it is possible to call a method without passing an argument for every parameter of the method.
A key feature of C Sharp and other languages designed for the .NET framework is the capability to interoperate with applications and components written by using other technologies.
One of the principal technologies that underpins many Microsoft Windows applications and services running outside of the .NET framework is the COM, or component, object, model.
It does not support overloaded methods, rather it utilizes methods that can take optional parameters.
In this method, the first parameter is mandatory because it does not stipulate a default value, but the second and third parameters aren't required.
You must specify all compulsory parameters before any non-compulsory ones.
You can call up a method in which takes non-compulsory parameters in the same way that you can call any other method, i.e., specify method name and any required arguments.
The distinction of methods that take optional parameters is that you can leave out the corresponding arguments.
The method uses the standard value when it runs.
In the subsequent example, the first call to the optional method method provides values for all three parameters.
The second call stipulates only two arguments, and these values are applied to the first and second parameters.
The third parameter receives the default value of bonjour when the method runs.
A second method call feature made available in C Sharp 4.0 is the use of named arguments.
With named arguments, it is possible for the caller to explicitly identify the name of the parameter to be assigned a value,
rather than relying on parameter and argument order to correlate them.
To pass an argument as a named parameter, you specify the name of the parameter,
followed by a colon, and the value to use.
The subsequent examples perform the same function as those in the previous section,
except that the parameters are specified by name.
Optional method, parentheses, first, colon, 99, second, colon, 123, dot, 45, third, colon, LeMondieu, parentheses.
Optional method, parentheses, first, colon, 333, second, colon, 54, dot, 456.
Handling uncertainties with optional parameters and named arguments.
Using optional parameters and named arguments can result in some possible ambiguities in your code.
You must understand how the compiler resolves these ambiguities,
otherwise you might find your applications behaving in unexpected ways.
Suppose that you define the opt method as an overloaded method, as shown in the illustration.
This is perfectly legal C Sharp code that follows the rules for overloaded methods.
The C Sharp compiler can tell the difference between the methods as they take different parameter lists.
However, as demonstrated in the following example,
a problem can arise if you attempted to call the optional method method
and omit some of the arguments corresponding to one or more of the optional parameters.
Optional method, parentheses, 1, 2.5, LeMondieu, parentheses.
Again, this is perfectly legal code,
but which version of the optional method method does it run?
The answer is that it runs the version that most closely matches the method call,
so it invokes the method that takes three parameters and not the version that takes four.
Optional method, parentheses, 1, 4th, colon, 101.
In the above code, the call to optional method omits arguments for the second and third parameters,
but it specifies the fourth parameter by name.
Only one version of optional method matches this call, so this is not a problem.
Optional method, parentheses, 1, 2.5, parentheses.
This time, neither version of the optional method method exactly matches the list of arguments provided.
Both versions of the optional method method have optional parameters for the second, third, and fourth arguments.
So, does this statement call the version of optional method that takes three parameters
and use the default value for the third parameter?
Or does it call the version of optional method that takes four parameters
and uses the default value for the third and fourth parameters?
The answer is that it does neither.
This is an unresolvable ambiguity, and the compiler does not let you compile the application.
The same situation arises with the same result if you try to call the optional method method
as shown in any of the subsequent statements.
Optional method, parentheses, 1, 3rd, colon, LeMondieu, parentheses.
Opt method, parentheses, 1, parentheses.
Opt method, parentheses, 2nd, colon, 2.5, 1, colon, 1, parentheses.
Decision statements and flow control.
To solve real-world problems, you need the capability of your code to selectively perform different actions.
You can perform this task with flow control statements,
which provide the means for conditional logic within a program
or looping over a section of code numerous times.
Even a simple program cannot be written in C-sharp without using flow control statements.
This first section discusses how to change the order of statement execution based on conditional checks.
Then you will learn how to execute statement groups repeatedly by constructing loop.
If statement.
The if statement is one of the most common statements in C-sharp.
If assesses a Boolean expression, an expression that returns true or false, see below,
called the condition.
If the condition is true, the next statement is executed.
And if a statement can contain an optional else clause that contains an alternate statement
to be executed if the condition is false, the general form is as follows.
If condition.
Consequence.
Statement.
Else.
Alternative.
Statement.
In the example that follows, answer 1 appears in both z greater than 10 and z greater than 20.
Evaluate to be true.
If z greater than 10 is true, but z greater than 20 is false, answer 2 appears.
Cascading if statements.
It is possible to nest if statements inside other if statements.
By doing so, you can chain together a sequence of Boolean expressions,
which are tested one after another until one of them are true.
In the subsequent example, if the value of today's day is 0,
the first test evaluates to true, and day of week is assigned the string Sunday.
If the value of today's day is not 0, the first test fails, and control passes to the else clause,
which runs the second if statement and compares the value of today's day with 1.
The second if statement executes only if the first test comes back false.
Likewise, the third if statement executes only if the first and second test returns false.
Code blocks.
By utilizing curly brackets, we can synthesize statements into one statement termed a block statement,
or code statement.
It allows the grouping of many statements into a single statement, which is the consequence.
In the subsequent example, two statements that reset the sec variable to 0 and increment the min variable
are grouped inside a block, and the entire block executes if the value of sec is equal to 59.
Boolean variables.
C-sharp offers a data type called bool.
It holds either true or false.
The subsequent statements declare a bool variable called are you ready and assign true to it.
True is then outputted to the console.
Boole are you ready.
Are you ready equals true.
Console.rightline parentheses are you ready parentheses slash slash outputs true on the console.
Boolean operators.
C-sharp has several very useful Boolean operators, an operator that returns true or false.
The simplest is the not operator.
It is represented by the exclamation point.
If the statement are you ready is true, then exclamation point are you ready is false.
i.e., the opposite of that value.
The two most commonly used Boolean operators are equality, equal sign, equal sign, and inequality,
exclamation point, equal sign.
These are binary operators with which you can ascertain if one value is the same as another value of the same type,
returning a Boolean answer.
The equality operator, equal, equal, equal, with the assignment operator, equal, are not the same.
The expression A, equal, equal, B compares A with B and has the value true if the values are the same.
The expression A equals B assigns the value of B to A and returns the value of B as its result.
The relational operators are closely related to equal, equal, and exclamation point equal.
You use these operators to find out whether a value is less than or greater than another value of the same type.
The subsequent table shows how to use these operators.
Conditional logical operators.
C-sharp also provides two other binary Boolean operators.
The logical and operator, which is represented by the ampersand ampersand sign,
and the logical or operator, which is represented by the dash dash symbol.
Together, they are known as the conditional logical operators.
Their function is to unite two Boolean expressions, or values, into a single Boolean result.
These operators are similar to the equality and relational operators in that the value of the expression in which they appear is either true or false.
But they differ in that the values on which they operate must also appear either true or false.
The outcome of the ampersand ampersand operator is true if and only if both of the Boolean expressions it's evaluating are true.
In the subsequent statement, the value true is assigned to valid percentage on the criteria that the value of percentage is greater or equal to zero,
and the value of percentage is less than or equal to 100.
The result of the dash dash operator is true if any of the two Boolean expressions it evaluates is true.
You can utilize the dash dash operator to work out if any one in a series of Boolean expressions is true.
In the subsequent statement, the value true is assigned to invalid percentage on the criteria that the value of percentage is less than zero,
or the value of percentage is greater than 100.
bool invalid percentage.
Invalid percentage equals parentheses percentage less than zero parentheses dash dash parentheses percentage greater than 100 parentheses.
Short circuiting.
The ampersand ampersand and dash dash operators both exhibit a feature called short circuiting.
There are occasions that it is not necessary to evaluate both operands when ascertaining the result of a conditional logical expression.
For example, if the left operand of the ampersand ampersand operator evaluates to false,
the result of the entire expression must be false, regardless of the value of the right operand.
Similarly, if the value of the left operand of the dash dash operator evaluates to true,
the result of the entire expression must be true,
irrespective of the value of the right operand.
In these instances, the ampersand ampersand and dash dash operators bypass the evaluation of the right operand.
Here are some examples.
In this expression, if the value of percentage is less than zero,
the boolean expression on the left side of ampersand ampersand evaluates to false.
This value means that the result of the entire expression must be false,
and the boolean expression to the right of the ampersand ampersand operator is not assessed.
Parentheses percentage less than zero, parentheses dash dash, parentheses percentage greater than 100, parentheses.
In this expression, if the value of percentage is less than zero,
the boolean expression on the left side of dash dash evaluates to true.
This value means that the result of the entire expression must be true,
and the boolean expression to the right of the dash dash operator is not assessed.
If you cautiously design expressions that use the conditional logical operators,
you can enhance the performance of your code by sidestepping needless work.
In order to do this, just put the boolean expressions that can be easily worked out
on the left side of a conditional logical operator,
and put the more complex expressions on the right side.
In numerous cases, you will discover that the program doesn't need to work out the more complex expressions.
Null coalescing operator?
It is a short way of saying, if this value is null, then use this other value.
It has the following form.
Expression 1?
Question mark?
Question mark?
Expression 2.
The null coalescing operator also uses a form of short-circuiting.
If expression 1 is not null, its value is the result of the operation,
and the other expression isn't assessed.
If expression 1 does equate to null,
then whatever value is in expression 2 is the result of the operator.
The null coalescing operator is a binary operator.
Null conditional operator?
Whenever you invoke a method on a value that is null,
the runtime will throw a system.null reference exception error.
This is an exception that almost always indicates an error in the programming logic
because the developer didn't perform sufficient null checking
before invoking a number on a null object.
In recognition of the frequency of this pattern,
that is, checking for null before invoking a member,
C-sharp 6.0 introduces the question mark operator,
known as the null conditional operator.
Here are some examples.
int?length equals consumer?
consumer? plein空к
dot length dash dash returns null if consumer is null.
consumer first equals consumer?
bracket zero bracket slash slash returns null if consumer is null.
int? count equals consumer?
bracket zero bracket question mark dot orders question mark dot count
parentheses parentheses slash slash null if consumer first consumer
or orders is null.
Control flow statements, continued.
Now that we've described Boolean expressions in more detail,
we can cover in more details flow control statements,
which C-sharp supports.
While and do slash while loops.
To date, you have seen how to create programs
that perform a task only once.
However, computers can effortlessly perform
similar operations multiple times.
In order to carry this out,
you must create an instruction loop.
Since it is the simplest conditional loop.
The general form of the while statement is as follows.
While parentheses Boolean expression parentheses statement.
The Boolean expression,
which must be enclosed in parentheses, is assessed.
If true, the statement is executed
and the Boolean expression is assessed once again.
If still true, the statement is repeated
and then the Boolean expression is assessed once more.
This procedure lasts until the Boolean expression evaluates to false
and while the statement exits.
The following is a while statement that writes the values 10 through to 1 on console.
Note that as soon as the variable 1 reaches the value 1,
the while statement finishes.
The following is outputted to the console.
10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
The do slash while loop is very akin to the while loop.
However, a do slash while loop is favored when the number of repetitions is from 1 to n.
And n is unknown when iterating commences.
This pattern often occurs when asking input from a user.
For loop.
This loop iterates over a block of code until a stated condition is reached.
It is very like the while loop.
The distinction is that the for loop has built-in syntax for initializing,
incrementing, and testing the value of a counter,
known as the loop variable.
Since here is an exact location in the loop syntax for an increment operation,
the increment and decrement operators are commonly used as part of a for loop.
In the next example, we can see the value of 1 is outputted to the console
and increased by 1 during each iteration of the loop.
You will see 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 on the console.
For each loop.
The for each loop iterates through a collection of items,
setting a loop variable to represent each item in turn.
Operations may be carried out on an item in the body of the loop.
One fine feature of for each loop is that every item is iterated over precisely once.
So it's impossible to miscount and iterate past the end of the collection,
as can happen with other loops.
The format of for each is
for each, parentheses, type variable in collection, parentheses, statement.
The main points of the for each statement
Type is used to declare the data type of the variable for every item in the collection.
This may be var.
If so, the compiler deduces the type of the item from the type of the collection.
Variable is a read-only variable
into which the for each loop will automatically allocate the subsequent item in the collection.
Its scope is restricted to the body of the loop.
Collection is an expression, such as an array,
representing any number of items.
A statement is the loop body that executes for each iteration of the loop.
An example of the for each loop in the illustration below.
You will see dog, fish, snake on the console.
Switch statement.
A switch is easier to comprehend than a complex if statement,
when you have a value that must be compared against numerous constant values.
It has the subsequent syntax.
Switch, parentheses, expression, parentheses, squiggle bracket,
case, constant, statements, default statements, squiggle bracket.
Points to note about the expression are
The value that is being compared to different constants goes where expression is.
The type of this expression governs the type of the switch.
Allowable governing data types are
bool, sbyte, byte, short, u short, int, u int, long, u long, char, and enum type,
discussed in types.
The corresponding nullable types of each of those value types and string.
Any constant expression that works with the governing type considered a constant.
The switch section is a collection of more than one case labels,
or default labels, succeeded by a collection of one or more statement.
Statements are one or more statements to be executed
when the expression equals one of the constant values stated in a label in the switch section.
The end point of the group of statements can't be reachable.
Typically, the concluding statement is a jump, break, return, or go to statement.
You can redraft the cascading if statement to the following switch statement below.
Switch statement rules.
The switch statement is very valuable, but you can't always utilize it.
Any switch statement you write must adhere to the following rules.
You can use switch only on certain data types, such as int, char, or string.
With any other types, including float and double, you must use an if statement.
The case labels must be constant expressions, such as 42 if the switch data type is an int,
4 if the switch data type is a char, or 42 if the switch data type is a string.
If you must calculate your case label values at runtime, you need to use an if statement.
The case labels have to be unique expressions, i.e. two case labels can't have the same value.
It is possible to run the same statements for more than one value by providing a list of case labels and no intervening statements.
The code for the last label on the list is executed for all cases in that list.
Although you will get a compiler error if a label has more than one associated statements,
execution can't fall through to the subsequent statement.
The subsequent code fragment illustrates these points.
Break statement.
To escape out of a loop or a switch statement, C-sharp uses a break statement.
Every time the break statement is met, control instantly leaves the loop or switch.
For example, a conditional statement comprises of a counter that is supposed to count from 1 to 100.
However, the break statement terminates the loop after 4 counts.
The output is 1, 2, 3, 4.
Exceptions and Error Handling
To date, we have seen the main C-sharp statements that you need to know to perform common tasks
like declaring variables, using operators to create values, writing methods, writing if and switch statements to run code selectively,
and writing while, for, and do statements to run code repeatedly.
However, these statements don't cover the chance or likelihood that things can go wrong.
C-sharp has a feature called Structured Exception Handling that lets you work with situations
where your methods aren't able to fulfill their intended purpose.
The syntax for managing exception handling is the try.
Try is a C-sharp keyword.
Catch.
Catch is another C-sharp keyword.
And a finally.
Finally is also a C-sharp keyword.
Statement.
All the code to be monitored for exceptions goes in the try block.
And the code that handles a potential exception goes in a catch block.
The finally statement ensures that code always runs, even after an exception has occurred.
In C-sharp, any time you try to use a member of a null object, you'll receive a null reference exception error.
The solution to fix the problem is to assign a value to the variable.
Since the code that threw the exception is inside the try block,
the code stops execution of any of the code in the try block and starts looking for an exception handler.
The catch block parameter indicates that it can catch a null reference exception
if the code inside of the try block throws that exception type.
The body of the catch block is where you perform any exception handling.
Catching multiple exceptions.
The .NET framework defines numerous types of exceptions.
If you write a program, you probably don't want to write catch handlers
for every possible exception that your code can throw.
So, how do you ensure that your programs catch and handle all possible exceptions?
The answer is the way the different exceptions are related to one another.
Exceptions are ordered into inheritance hierarchies.
Format exception and overflow exception both belong to a tree called system exception.
System exception belongs to a bigger tree simply called exception,
and base call for all exceptions.
The code following throws an exception in the try block with the different exceptions caught.
The method is named handle this uncaught exception.
As there isn't a specific catch block to handle a null reference exception,
the exception will be handled by the catch block for the exception type.
You list exceptions by their inheritance hierarchy,
with top-level exceptions lower in the list of catch blocks.
A thrown exception will move down this list of handlers,
looking for a matching exception type,
and only execute in the catch block of the first handler that matches.
Argument null exceptions originates from argument exception,
and argument exception originates from exception.
If no catch block can handle an exception,
the code goes up the stack looking for a potential catch block in calling code
that can handle the exception type.
Your program will terminate should there be no code in the call stack.
Once the program initiates executing code in the try block,
the finally block is guaranteed to execute.
If an exception happens and isn't caught,
the finally block will execute before the program starts looking at the calling code
for a matching catch handler.
You can write a try-finally block without catch blocks
to guarantee that certain code will execute once the try block begins.
This is useful for opening a resource,
like a file or database connection,
and then guaranteeing you will be able to close it
regardless if an exception occurs or not.
Throwing exceptions.
Should you encounter a reason why your method can't perform its intended purpose,
throw an exception.
The following exception types listed are used extensively throughout the CLR and .NET framework.
You can throw them yourself or use them as a base for deriving custom exception types.
System.argument exception.
Thrown when a function is called with a bogus argument.
This generally indicates a program bug.
System.argument null exception.
Subclass of argument exception that's thrown when a function argument is unexpectedly null.
System.argument out of range exception.
Subclass of argument exception that's thrown when a usually numeric argument is too big or too small.
E.g., this is thrown when passing a negative number into a function which solely takes positive ones.
System.invalid operation exception.
Thrown when the state of an object is unsuitable for a method execute.
Irrespective of any particular argument values.
E.g., when you read an unopened file or get the subsequent element from an enumerator where the underlying list has been modified halfway through the iteration.
System.not supported exception.
Thrown to indicate that a particular method or function isn't supported.
System.not implemented exception.
Thrown to indicate that a function has not yet been employed.
System.object disposed exception.
There are many exception-derived types in the .NET FCL which you can utilize.
In this example illustrated below, the .NET Framework's argument out of range exception class is one.
Classes and Objects.
A class is a construct that enables you to create custom types by putting together variables of other types, methods, and events.
An object is an instance of that type, and is created once the program starts.
Many objects can be instances of the same class.
A class is like a template.
It starts the data and behavior of a type.
Should a class not be declared as static, the client code can utilize it by generating objects or instances which are assigned to a variable.
That variable remains in memory until every reference to it goes out of scope.
Once that occurs, the CLR denotes it as ready for garbage collection.
Should the class be declared as static, then only one copy will exist in memory, and client code can't access it with an instance variable only through the class itself.
Classes provide a convenient mechanism for modeling the entities manipulated by applications.
An entity can signify a specific item, like a client, or something more abstract, like as an order.
Part of the design process of any system focuses on determining the entities that are important to the processes that the system implements,
and then performing an analysis to see what information these entities must hold, and what operations they should perform.
You store the information that a class holds as fields, and use methods to implement the operations that a class can perform.
Encapsulation.
This is the procedure of placing more than one items together in a physical or logical package and limiting access to it.
The idea behind this OOP pillar is that a program that uses a class shouldn't have to worry how that class actually works internally.
The program simply creates an instance of it and uses it.
As long as those methods do what they say they will do, as the program has access to them, the program doesn't care how they are implemented.
When you call the console.writeline method, you don't want to be concerned with all the complex details of how the console class gets data written on the screen.
A class might need to maintain all sorts of internal state information to perform its various methods.
This additional state information and activity is hidden from the program that is using the class.
So, encapsulation is something referred to as information hiding.
Encapsulation actually has two purposes.
To combine methods and data within a class.
In other words, to support classification.
To control the accessibility of the methods and data.
In other words, to control the use of the class.
Classes are declared by using the class keyword, as shown in the subsequent example.
The access level comes before the class keyword.
Since public is used in this case, there is complete access to create objects from this class.
To declare a class, you use the keyword class and then name of the class.
Class consumer as above.
The remainder of the definition, i.e. the class body, is in brackets and holds the fields, properties, methods, and events.
They are jointly known as class members.
Controlling accessibility.
You can modify the definition of a field or method with the public and private keywords to control whether it is accessible from the outside.
A method or field is private if it is accessible only from inside the class.
To declare that a method or field is private, you write the keyword private before its declaration.
As intimated previously, this is actually the default.
But it is good practice to state explicitly that fields and methods are private to avoid any confusion.
A method or field is public if it is available from both inside and outside the class.
To declare that a method or field is public, you write the keyword public before its declaration.
Creating an object.
Even though they are frequently utilized interchangeably, a class and object are not the same.
A class specifies plan for an object, but is not the actual object itself.
An object is occasionally identified as an instance of a class and is a concrete entity based on a class.
Objects can be created by using the new keyword followed by the name of the class that the object will be based on.
The following, create a new object from consumer class created in the previous example.
ConsumerObject1 equals new consumer parentheses.
When an instance of a class is created, a reference to the object is returned to the developer.
In the previous code list, object1 is a reference to an object that is based on consumer.
This reference refers to the new object, but doesn't contain the object data itself.
Constructors.
Every class that is created needs a constructor.
A constructor has the identical name as the class.
It can take parameters, but is unable to return a value, not even void.
It's mandatory to have a constructor, and if you don't write one, the compiler generates a default constructor on your behalf.
To write your own constructor, just add a public method that doesn't return a value, and give it the same name as the class.
E.g., the following shows the circle class with a default constructor that initializes the getCircleRadius field to zero.
In this example, the constructor is marked as public.
If the keyword is left out, the constructor will be private, like any other methods and fields.
If the constructor is private, it cannot be used outside the class, which prevents you from being able to create circle objects from methods that are not part of the circle class.
Private constructors do have limited uses.
Having added a public constructor, you can now use the circle class and exercise its area method.
Notice that you use a dot notation to invoke the area method on a circle object.
Circle C, circle equals new circle parentheses, double area of circle equals C dot getArea parentheses, slash slash creates a circle object, slash slash initialize it.
Static classes.
A static class is basically the same as a non-static class, but there is one difference.
A static class cannot be instantiated, i.e., you can't generate a variable of the class type via the new keyword.
To access the members of a static class, you utilize the class name itself.
The subsequent static class, called utility class, has a public method called method A.
You can invoke this method like so.
utility class dot method A parentheses.
The goal of a static class is solely to act as a holder of utility methods and fields.
A static class cannot contain any instance data or methods.
And it does not make sense to try to create an object from a static class by using the new operator.
Value types and reference types.
Types in C-sharp can be split into either value types or reference types.
The differences between the types in each category stem from differences in copying strategies,
which in turn result in each type being stored differently in memory.
Value types.
Value types encompass most built-in types.
In specific terms, all numeric types, char type, and bool type.
As well as custom struct and enum type.
These types all have a fixed size.
Variables of value types directly contain their own values.
Reference types.
Reference types comprise all classes, array, delegate, and interface types
that are handled differently by the compiler.
For example, take the circle class type, previous code listing.
Once you declare a circle variable, the compiler allocates a small portion of memory
which can possibly hold the address of, or a reference to, additional block of memory holding a circle.
Only once an actual circle object is created, via the new keyword, then the memory is allocated.
Copying value and reference types.
When you take a copy of a value type, there are two memory locations.
For example, should you create an integer variable called i and give it the value 42,
then an additional integer variable named copy and assign i to copy.
Copy will hold the identical value as i, 42.
Although copy and i hold the exact same value,
they are actually two different blocks of memory holding the value 42.
One block for i, and another block for copy.
If you adjust the value of i, the value of copy doesn't change.
This is in marked difference to declaring a variable as a class type,
where you are essentially copying the same address.
E.g., if you declare c as a circle, c can refer to a circle object.
The actual value held by c is the address of a circle object in memory.
Should you declare a further variable called refc, a circle, and assign c to refc,
refc will have a copy of the identical address as c.
To summarize, both refc and c now denote the one circle object.
Note that the behavior of method parameters hinge on whether they are value types or reference types.
Null values.
The null value identified with the null keyword indicates that the variable does not refer to any valid object,
i.e., it stipulates that a variable is set to nothing.
You can assign reference types, pointer types, and nullable types the value null.
Code that sets a variable to null explicitly assigns the reference to refer to no valid value.
It is possible to check whether a reference refers to nothing.
The subsequent code demonstrates assigning null to a string variable.
Assigning the value null to a reference type is not the same as not assigning it at all.
In other words, a variable that has been assigned null has still been set,
whereas a variable with no assignment has not been set,
and therefore will often result in your program not compiling if used prior to assignment.
Assigning a string value the value null is particularly dissimilar from assigning an empty string.
Use of null indicates that the variable has no value,
whereas quotation marks indicates that there is an empty value, an empty string.
This difference is quite valuable in programming.
You could take a phone number of null to mean that the value number is unknown,
while a phone num value of quotation marks could stipulate no phone exists.
Nullable types.
Value types can't typically be assigned null, since by definition they can't hold references,
which includes references to nothing.
However, C-sharp defines a modifier that you can use to declare that a variable is a nullable value type.
A nullable value type acts in a similar way to the original value type,
but you can assign the null value to it.
You use the question mark to specify that a value type is nullable, like so.
Int question mark i equals null slash slash valid code.
You can ascertain whether a nullable variable contains null by testing it in the same way as a reference type.
If parentheses i equals equals null parentheses.
The system.object class.
One of the most important reference types in the .NET framework
is the object class in the system namespace.
To completely appreciate the significance of the system.object class,
you need to understand inheritance, described later in this ebook.
For the time being, simply accept that all classes are specialized types of system.object,
and that you can use system.object to create a variable that can refer to any reference type.
System.object is such an important class that C-sharp provides the object keyword
as an alias for system.object.
In the subsequent example, the variables C and O both reference the same circle object.
The fact that the type of C is circle and the type of O is object,
the alias for system.object,
in effect offers two different views on the same item in memory.
Circle C, C equals new circle parentheses 42 parentheses,
object zero, zero equals C.
Boxing.
As discussed, variables of type object can refer to any item of any reference type.
However, variables of type object can also refer to a value type.
To illustrate, both the two following statements initialize the variable I,
of type int, a value type, to 42.
And then initialize the variable O, of type object, a reference type, to I.
Int I equals 42.
Object O equals I.
In the second, there is a bit more happening.
Remember that I is a value type, and that it lives on the stack.
Should the reference inside O refer directly to I,
then the reference would refer to the stack.
Nevertheless, all references must refer to objects on the heap.
Creating references to items on the stack could seriously compromise the robustness of the runtime
and create a potential security flaw, so it is not allowed.
Therefore, the runtime allocates a piece of memory from the heap,
copies the value of integer I to this piece of memory,
and then refers the object O to this copy.
Boxing is a term for automatically copying an item from the stack to the heap.
Unboxing.
Because a variable of type object can refer to a boxed copy of a value,
it's only reasonable to allow you to get at that boxed value through the variable.
You may be thinking that can access the boxed int value that a variable O refers to via a simple assignment status like
int i equals O.
This, however, will result in a compile error.
You can't use the int i equals zero code.
The variable O could be referencing absolutely almost anything, not just an integer.
Take, for example, the subsequent code if such a statement were allowable.
Circle C equals new circle parentheses,
int i equals 42,
object O,
O equals C,
dash dash O refers to a circle,
I equals O,
dash dash what is stored in i.
To get the value of the boxed copy,
you must utilize what is known as a cast.
This operation checks if it's safe to convert an item of one type to another
before it actually makes the copy.
You prefix the object variable with the name of the type in parentheses as follows.
int i equals 42,
object O equals I,
slash slash boxing OK,
int equals parentheses,
int parentheses O,
slash slash this compiles OK.
The effect of this cast is subtle.
The compiler sees that you've specified the type int in the cast.
It generates code to check what O actually refers to at runtime.
It could be really anything.
Even though your cast says O refers to an int,
it doesn't mean that it actually does.
If O does actually refer to a boxed int and everything correlates,
the cast will succeed,
and the compiler will extract the value from the boxed int and copy it to i,
i.e. the boxed value will be stored in i.
This is called unboxing.
However,
if O does not refer to a boxed int,
there has been a type mismatch and the cast will fail.
Invalid cast exception is invoked.
The following illustrates an unboxing cast that fails.
Note that boxing and unboxing are expensive operations
because of the quantity of checking that is required
and the need to allocate additional heat memory.
Boxing is useful,
but overuse will really negatively impact the performance of your program.
Casting data safely.
By utilizing a cast,
you can, in your opinion,
specify that the data referenced by an object has a specific type,
and it is safe to reference the object by using that type.
It is important to note that it is of your opinion.
The C Sharp compiler will not check that this is the case,
but the runtime will.
If the type of object in memory doesn't match the cast,
the runtime will throw an invalid cast exception.
You should expect this exception and deal with it appropriately,
should it occur.
In saying that,
catching an exception and attempting to recover
in the event the type of an object is rather an unwieldy approach,
C Sharp offers two really useful operators
that can help you perform casting in a much more elegant manner.
Is and As operators.
The Is operator.
You can utilize the Is operator
to authenticate that the type of an object
is what you assume it to be,
like illustrated below.
The Is operator accepts two operands,
the left, a reference to an object,
the right, a type.
Should the type of the object referred to on the heap
have the specified type,
it evaluates to true,
or else it evaluates to false.
The prior code tries to cast the reference
to the object variable O
only if it knows that the cast will be successful.
The As operator.
The As operator achieves a similar role to Is,
but in a slightly condensed method.
You utilize the As operator like below.
The As operator is similar to the Is operator
and that it takes an object and a type as its operands.
The runtime attempts to cast the object to the specified type.
If the cast is a success,
the result is returned
and is assigned to the wrapped integer variable.
Should the cast fail,
then the As operator appraises to the null value
and instead assigns that to temp.
Enumerations.
An enum is a value type
that the developer can declare.
The key characteristic of an enum
is that it declares at compile time
a set of possible constant values
that can be referred to by name.
The subsequent is an example of an enum.
enum, season, squiggle bracket,
spring, summer, autumn, winter, squiggle bracket.
Once you have declared an enum,
you can use it in the exact same way as any other type.
That is, if the name of your enum is season,
then you can create variables,
fields,
and parameters of type season,
as illustrated here.
In order to read an enumeration,
you must assign a value to it.
You can assign a value that is defined
by the enumeration only to an enumeration variable,
as is illustrated here.
As you can with all value types,
you can create a nullable version
of an enumeration variable
by using the question mark modifier.
You can then assign the null value,
as well as the values defined
by the enumeration to the variable
season question mark colorful equals null.
Structures.
Classes specify reference types
that are solely created on the heap.
However, on some occasions,
the class may have so little data
that the overhead of managing the heap
turns out to be disproportionate.
In such cases,
it is best to define the type as a structure,
which is a value type.
Since structs are stored on the stack
as long as the structure is reasonably small,
the memory management overhead
is often reduced.
A structure is similar to a class
in that it can have its own fields,
methods,
and constructors.
Declaring a structure
is similar to that of a class.
You utilize the keyword struct,
then use the name of the type,
then followed by the body of the structure,
between opening and closing brackets.
Here, for example,
is a structure named time
that contains three public int fields
named hours, minutes, and seconds.
As per classes,
it is not recommended
to make the fields of a structure
public in most cases,
as there is no way
to control the values held in public fields.
Anyone could, for example,
set the value of minutes or seconds
to a value greater than 60.
A better idea is to make the fields private
and provide your structure
with constructors and methods
to initialize and manipulate these fields,
as shown in this example.
When you copy a value type variable,
you get two copies of the value.
With reference types, however,
once you copy a variable of reference type,
you get two references to the said object.
In summary,
use structures for small data values
for which it's just as
or nearly as efficient
to copy the value
as it would be to copy an address.
Utilize classes for larger,
more complex data
where copying is too inefficient.
Difference between structures
and classes.
Syntactically,
a structure and a class
are somewhat alike,
although there are
a few significant differences.
Firstly,
it's impossible to declare
a default constructor,
i.e. a constructor with zero parameters,
for a structure.
In the next example,
the code would compile
if time were a class,
but since time is a structure,
it doesn't.
Secondly,
in a class,
you can initialize instance fields
at their point of declaration.
In a structure,
you cannot.
In this next example,
the code would compile
if time were a class,
but because time is a structure,
it triggers a compile time error.
The main differences
between a structure and a class
are summarized in the box below.
Arrays.
You can define an array
as an unordered sequence of items,
as opposed to fields
in a structure or class
which may have different types.
All the items in an array
have the identical type.
In addition,
items in an array
live in a contiguous block of memory
and are accessed by using an index
as opposed to fields
in a structure or class,
which are accessed by name.
Declaring array variables.
In order to declare an array variable,
you stipulate the name
of the element type,
then use a pair of square brackets
and finally by the variable name.
The square brackets denote
that the variable is to be in an array.
So, to declare an array
of integer variables named pins
in order to hold a set of personal ID numbers,
you write the following.
Int brackets pins slash slash
personal ID numbers.
You are not just limited
to primitive types as array elements.
You may also create arrays of structures,
enumerations, and classes.
For example,
you can construct an array
of date structures like so.
Date, brackets, dates.
Creating an array instance.
In order to create an array instance,
you use the new keyword,
element type and size of the array
you're forming enclosed in brackets.
Generating an array
will also initialize its elements
with the default values.
O, numeric, null, reference,
or false, boolean.
To create and initialize a new array
with four integers
for the pins variable declared previous,
you write the following.
Pins equals new int brackets
including four.
Since the memory for the array instance
is allocated dynamically,
array size doesn't need to be a constant.
It can be worked out at runtime.
You write the following.
Int size equals int dot parse
parentheses console dot read line
enclosed parentheses parentheses
slash slash get the size of array
from console int enclosed brackets
pins equals new int
size in enclosed brackets
slash slash create new array of pins
based on user input.
Likewise, you can create
an array size of zero.
This might sound strange,
however, it's quite valuable
when the array size is resolved dynamically
and might even be zero.
The zero size is an array
containing zero elements
and is not a null array.
Populating and using an array.
Whenever you create an array instance,
every element of the array
is initialized to a default value
depending on their type.
Numeric values, for example,
all default to zero.
Objects are initialized to null
and strings are set to null.
You can adjust this behavior
and initialize the elements of an array
to precise values if you wish.
You achieve this by producing
a comma-separated list of values
between a pair of brackets.
So, in order to initialize
an array of four pins
of integer value,
whose values are 9, 3, 7, and 2,
you code the following.
int enclosed brackets pins
equals new int 4
in enclosed brackets
squiggle bracket 8561 squiggle bracket.
The values in between the brackets
don't have to be constants.
They can be values worked out at runtime,
as shown in the following lines of code.
random random example array
equals new random enclosed parentheses
int brackets pins equals new
int 4 in enclosed brackets
squiggle bracket random example array
dot next parentheses percentage 10
random example array dot next
parentheses percentage 10
random example array dot next
parentheses percentage 10
random example array dot next
parentheses percentage 10
squiggle bracket
Slash slash populates array with four random numbers.
The number of values between the brackets must match precisely the size of the array instance being created.
Int brackets pins equals new int enclosed three brackets squiggle bracket 8561 squiggle bracket.
Slash slash results in a compile time error plus one.
Int brackets pins equals new int four and enclosed brackets squiggle bracket 856 squiggle bracket.
Slash slash results in a compile time error minus one.
Int enclosed brackets pins equals new int four and enclosed brackets squiggle bracket 8561 squiggle bracket slash slash this is correct.
Creating an implicitly typed array.
Once you declare an array, the element type must match the type of elements in the array.
For example, if you declare pins to be an array of int as above,
you cannot store a double, string, struct, or anything that is not an int in this array.
If you stipulate a list of initializers when declaring an array,
you can let the C-sharp compiler interface the actual type of the elements in the array for you.
Like this.
Varnames equals new enclosed brackets squiggle bracket Louis, Rosanna, Joelle, Janet squiggle bracket.
In the above example, the C-sharp compiler determines that the names variable is an array of strings.
Note.
One.
You leave out the square brackets from the type.
The names variable are declared simply as var, not var square brackets.
Two.
You must stipulate the new operator in square brackets before the initializer list.
If you utilize this syntax, you must ensure that each of the initializers have the same type.
This following causes the compile time error var bad equals new bracket squiggle bracket
Louis, Rosanna, 97, 101, squiggle bracket, slash, slash, error no best type found for implicitly typed array.
Accessing an individual array element.
To access an individual array element, you must provide an index signifying which element you need.
Array indexes are zero-based.
So, the initial element of an array lives at index zero, not index one.
An index value of one gets the second element.
You can read, for example, the contents of element two of the pins array into an int variable by using the following code.
Int myPin.
MyPin equals pins two in enclosed brackets.
Likewise, you can change the contents of an array by assigning a value to an indexed element.
MyPin equals 9627.
Pins two in enclosed brackets equals myPin.
All array element access is bounds checked.
And should you stipulate an index that is less than zero or greater than or equal to the length of the array,
the compiler will throw an index out of range exception exception.
As illustrated below.
Iterating through an array.
All arrays are really instances of system.array class in the .NET framework.
And this class specifies numerous valuable properties and methods.
You can, for example, query the length property to learn how many elements there are in an array
and iterate through all the elements of an array via A for statement.
The subsequent code outputs the array element values of the pins array to the console illustrated below.
Often, new developers fail to recall that arrays start at element zero and that the last element is numbered length minus one.
C-sharp provides the for each statement with which you can iterate through the elements of an array without worrying about these issues.
Here, for example, is the proceeding for statement rewritten as a comparable for each statement illustrated below.
An iteration variable, i.e. pin, is declared in the for each statement, and it obtains each value of every item in the array.
The type of this variable has to match the type of the elements in the array.
The for each statement is the favored way to iterate through an array.
It expresses the purpose of the code directly, and all the for loop is dropped.
However, sometimes you will have to revert to a for statement, because a for each statement always iterates through the entire array.
If you wish to iterate through a partial part of an array, e.g. the first half, or bypass some elements, like every second element, it's much easier to utilize a for statement.
A for each statement always iterates from array index zero through array index length minus one.
Should you wish to iterate backward or in another sequence, it's easier to use a for statement.
If the body of the loop needs to know the array index of the element rather than just the value of the element, you'll have to use a for statement.
If you need to adjust the elements of the array, you will have to utilize a for statement, as the iteration variable of the for each statement is a read-only copy of each element of the array, using multidimensional arrays.
The arrays to date have contained a single dimension, and you can think of them as simple lists of values.
You can produce arrays with more than one dimension.
To create a two-dimensional array, you specify an array that needs two integer indexes.
The subsequent code produces a two-dim array with 20 ints named items.
You can think of an array like a table, where the first dimension stipulates a number of rows, and the second stipulates a number of columns.
int, comma, in enclosed brackets, items, equals new int, four and five, in enclosed brackets.
To get an element in the array, you must provide two index values to specify the cell holding the element.
The subsequent code shows some examples using the items array illustrated below.
You can create endless dimensions on an array.
The following example generates and utilizes an array called cube, that contains three dimensions.
If you wish to retrieve an element in the array, you must stipulate three indexes.
Since arrays take a lot of memory, an array with more than three dimensions could potentially cause problems.
Just to note, a cube array contains 125 elements.
Five times five times five.
A four-dimensional array, each dimension having a size of five, comprises of 625 elements.
It's quite easy to run out of memory, so you should always be prepared to catch and handle out-of-memory exception exceptions.
Parameter arrays.
As discussed earlier in this ebook, overloading is the technical term for declaring two or more methods with the same name in the same scope.
However, overloading doesn't easily handle a situation in which the type of parameters doesn't vary, but the number of parameters does.
By utilizing the params keyword, you can stipulate a method parameter that takes a variable number of arguments.
For example, you can send a comma-separated list of arguments of type, defined in the parameter declaration,
an array of arguments of the specific type, no arguments, thus length of the params list is zero.
No extra parameters are allowed after the params keyword, and only one parameter is allowed in a mutual declaration.
An example of a parameter array is illustrated below.
The following is outputted to the console.
The total sum equals 2538.
Inheritance.
Inheritance permits you to generate new classes which reuse, extend, and modify the behavior from other classes.
Together, with encapsulation and polymorphism, they form the pillars or characteristics of object-oriented programming, OOP.
When you utilize inheritance, you declare that a class inherits from another class, like illustrated below.
The base classes' methods become part of the derived classes.
In C-sharp, a class is allowed to derive from one base class maximum.
A class isn't allowed to derive from two or more classes.
Except, however, a derived class is stated as sealed.
You can create additional derived classes that inherit from derived class using the same syntax.
Base class constructors.
Along with the methods which it inherits, a derived class automatically contains all the fields from the base class.
These fields usually require initialization when an object is created.
You typically perform this sort of initialization in a constructor.
You can specify the base keyword to call a base class constructor when you define a constructor for an inheriting class, as illustrated in this example.
Virtual methods.
When a method in a base class is declared virtual, a derived class can override the method with its own implementation.
Occasionally, virtual is used to hide a method.
A method that is envisioned to be overridden is called a virtual method.
Overriding a method is a mechanism for offering different implementations of the same method.
The methods are all related because they are intended to perform the same task, but in a class-specific manner.
Hiding a method is a way of substituting one method with another.
The methods are typically unrelated and may perform completely different tasks.
Overriding a method is a useful programming concept.
Hiding a method is often an error.
You mark a method as a virtual method by using the virtual keyword.
For example, the toString method in the System.Object class is defined like this, illustrated below.
Override methods.
If a base class states that a method is virtual, a derived class can use the override keyword to declare another implementation of that method, as illustrated below.
It is possible for the implementation of the method in the derived class to call the original implementation of the method in the base class.
This is achieved by utilizing the base keyword, as illustrated below.
When you declare polymorphic methods by using the virtual and override keywords, you must ensure the following.
A virtual method can't be private since it is intended to be made accessible to other classes via inheritance.
Likewise, override methods can't be private since a class can't change the protection level of a method that it inherits.
However, override methods can have a special form of privacy known as protected access, as you will find out in the next section.
The signatures of the virtual and override methods must be identical.
They must have identical name, number, and types of parameters.
In addition, both methods must return the same type.
You can only override a virtual method.
Should the base class method not be virtual and you attempt to override it, it will ensue in a compile error.
This is logical.
It should be up to the developer of the base class to decide whether its methods can be overridden.
If the derived class does not declare the method by using the override keyword, it does not override the base class method.
It hides the method.
I.e., it becomes an implementation of a completely different method that happens to have the identical name.
Like before, you will get a compile time hiding warning, which you can silence by utilizing the new keyword.
An override method is implicitly virtual, and it's possible for it to be overridden in a subsequent derived class.
You can't, however, explicitly declare an override method as virtual by utilizing the virtual keyword.
Protected access.
The public and private access keywords either ensure access for everyone or only to the class itself.
In most cases, these two options are enough.
However, as all experienced object-oriented programmers know, isolated classes cannot solve complex problems.
Inheritance is a very effective way of connecting classes, and evidently there is a special and close relationship between a derived class and its base class.
Frequently, it is useful for a base class to allow derived classes to access some of its members while hiding these same members from the classes that are not part of the inheritance.
It is possible with the protected keyword.
It works like this.
If a class A is derived from another class B, it can access the protected class members of class B.
Put another way, inside the derived class A, a protected member of class B is effectively public.
If a class A is not derived from another class B, it cannot access any protected members of class B.
So, inside class A, a protected member of class B is regarded as private.
Extension methods.
Extension methods facilitate you to augment methods to existing types without having to create a new derived type, recompiling or otherwise modify the original type.
You can consider them as a special type of static method, although they are called as though they were instance methods on the extended type.
The output of the console is the C-sharp programming language.
Interfaces.
Inheriting from a class is a powerful mechanism, but the real power of inheritance comes from inheriting from an interface.
An interface does not contain any code or data, it just specifies the methods and properties that a class that inherits from the interface must provide.
Utilizing an interface makes it possible to completely separate the names and signatures of the methods of a class from the method's implementation.
In numerous ways, abstract classes are very similar to interfaces, excepting the fact that they contain code and data.
However, you can specify that certain methods of an abstract class are virtual, so that a class that inherits from the abstract class must provide its own implementation of the methods.
Frequently, you use abstract classes with interfaces, and together, they provide key techniques with which you can build extensible programming frameworks.
Defining an interface.
Defining an interface is syntactically similar to defining a class, except that you use the interface keyword instead of the class keyword.
Implementing an interface.
To implement an interface, you declare a class or structure that inherits from the interface, and that implements all the methods specified by the interface.
When you implement an interface, you must ensure that each method matches its corresponding interface method exactly, according to the following rules.
The method names and return types match exactly.
Any parameters, including ref and out keyword modifiers, match exactly.
Every method which implements an interface has to be publicly accessible.
Although, if you are using an explicit interface implementation, the method shouldn't have an access qualifier.
If there is any difference between the interface definition and its declared implementation, the class will not compile.
It is possible for a class to inherit from another class and implement an interface simultaneously.
To do this, C-sharp uses a positional notation, i.e., initially it's the base class followed by a comma and finally the interface.
The following example defines alligator as a class that is a reptile, but that additionally implements the i water-based interface illustrated below.
Referencing a class through its interface.
In the same way that you can reference an object by using a variable defined as a class that is higher up the hierarchy,
you can reference an object by using a variable defined as an interface that its class implements.
In the previous example, you can reference an alligator object by using an i water-based variable, as follows.
Alligator my alligator equals new alligator in close parentheses.
i water-based i my alligator equals my alligator.
Slash slash this is legal.
This is valid because all alligators are water-bound reptiles, although the converse is not true.
You cannot assign an i water-based object to an alligator variable without casting it first to verify that it does actually reference an alligator object,
and not some other class that also happens to implement the i water-based interface.
The technique of referencing an object through an interface is useful,
because you can use it to define methods that can take different types as parameters,
as long as the types implement a specified interface.
For example, the find water speed method shown here can take any argument that implements the i water-based interface illustrated below.
You can verify that an object is an instance of a class which implements a specific interface by using the is operator.
You use the is operator to determine whether an object has a specified type,
and it works with interfaces as well as classes and structs.
For example, the following block of code checks that the variable my alligator actually implements the i water-based interface before attempting to assign it to an i water-based variable, illustrated below.
Note that when referencing an object through an interface, you can invoke only methods that are made available through the interface.
Multiple interfaces.
A class can have at most one base class, but it is allowed to implement unlimited interfaces.
Should a class implement an interface, then it must implement each interface method.
You specify each of the interfaces via a comma-separated list, like illustrated below.
Explicitly implementing an interface.
The examples so far have shown classes that implicitly implement an interface.
Revisiting the i water-based interface and the alligator class, shown next,
although the alligator class implements from the i water-based interface,
there is nothing in the implementation of the number of legs method in the alligator class that says it is part of the i water-based interface.
This might not be an issue in a simple situation, but suppose the alligator class implemented multiple interfaces.
There is nothing to stop multiple interfaces from specifying a method with the identical name, although they might have different meanings.
Say, for example, you wanted to implement a swamp tour based on alligators.
A long swamp tour might be broken down into several parts, or legs.
If you wanted to keep track of how many legs of the tour each alligator was available to see,
you might do the following illustrated below.
Now, if you implement this interface in the alligator class, you have an interesting problem.
This is legal code.
But does the alligator have four legs?
Or is it available in four legs of the swamp tour?
The answer, as far as C-sharp is concerned, is both of these.
By definition, C-sharp does not distinguish which interface the method is implementing.
So the same method actually implements both interfaces.
To solve this problem, and disambiguate which method is part of which interface implementation,
you can implement interfaces explicitly.
To do this, you specify which interface a method belongs to when you implement it, as illustrated below.
Now you can see that the alligator has four legs, and has been on three legs, of the swamp tour.
Apart from prefixing the name of the method with the interface name, there is one other subtle difference in this syntax.
The methods are not marked as public.
You cannot specify the protection for methods that are part of an explicit interface implementation.
This leads to another interesting phenomenon.
If you create an alligator variable in code, you cannot actually invoke either of the number of legs methods,
because they are not visible.
As far as the alligator class is concerned, they are both private.
In fact, this makes sense.
If the methods were visible through the alligator class, which method would the following code actually invoke?
The one for the I water-based interface?
Or the one for the I swamp tour interface?
Alligator, alligator equals new alligator in closed parentheses.
Int legs equals alligator dot number of legs in closed parentheses.
How do you access these methods?
The answer is that you reference the alligator object through the appropriate interface, like this.
Alligator, alligator equals new alligator in closed parentheses.
I swamp tour swamp tour alligator equals alligator.
Int legs in swamp tour equals swamp tour alligator dot number of legs in closed parentheses.
I water-based water-based alligator equals alligator.
Int legs on alligator equals water-based alligator dot number of legs in closed parentheses.
It is recommended to explicitly implementing interfaces when possible.
Interface restrictions.
It's important to remember that interface never contains any implementation.
To ensure that this rule is never broken, you must adhere to the subsequent points.
You can't define any fields in an interface, not even static fields, since a field is an enactment detail of a class or structure.
You can't define any constructors in an interface.
A constructor is also considered to be an enactment detail of a class or structure.
You're not allowed to define a destructor in an interface.
Destructors are described in garbage collection.
You can't stipulate an access modifier for any method.
Every method in an interface is implicitly public.
You can't nest any types in an interface.
You can't inherit from a struct or a class with an interface.
Although an interface can inherit from another interface.
Since structures and classes contain implementation, an interface can't inherit from either, i.e. inheriting implementation.
Abstract classes.
You can implement the eye-water-based and eye-huntable interfaces discussed before in many different classes, depending on how many different types of reptiles you want to model in your C-sharp application.
In situations such as this, it's quite common for parts of the derived classes to share common implementations.
For example, the duplication in the following two classes is obvious, illustrated below.
Duplication in code is a warning sign.
If possible, you should refactor the code to evade this duplication and reduce any associated maintenance costs.
One way to achieve this refactoring is to put the common implementation into a new class created specifically for this purpose.
In effect, you can insert a new class into the class hierarchy, as shown by the ensuing code example illustrated below.
This is a good solution.
But there is one thing that is still not quite right.
You can actually create instances of the meat-eating reptile class.
And the reptile class, for that matter.
This doesn't really make sense.
The meat-eating reptile class exists to provide a common default implementation.
Its sole purpose is to be a class from which to inherit.
The meat-eating reptile class is an abstraction of common functionality, rather than an entity in its own right.
To declare that creating instances of a class is not allowed, you can declare that the class is abstract by using the abstract keyword,
such as in the next example illustrated below.
Trying to instantiate a meat-eating reptile object will result in a compile error.
Meat-eating reptile
My meat-eating reptile
Equals new meat-eating reptile
In close parentheses
Slash slash
Compile error
Abstract methods
Inside an abstract class, you can have abstract methods which are comparable in principle to a virtual method.
However, it doesn't contain a method body.
If it's a derived class, then it must override this method.
The following example defines the digest crayfish method in the meat-eating reptile class as an abstract method.
Meat-eating reptiles might use the same code for chewing crayfish, but they must provide their own implementation of the digest crayfish method.
An abstract method is useful if it does not make sense to provide a default implementation in the abstract class, but you want to ensure that an inheriting class provides its own implementation of that method.
Sealed classes
Using inheritance is not always easy, and you have to think everything out before you start coding.
If you create an interface or an abstract class, you know you are writing something that will be inherited from in the future.
However, it's hard to predict the future structure.
You will need a solid understanding of the problem that you are modeling.
Unless you deliberately design a class with the purpose of using it as a base class, it's most unlikely that it will function well as a base class.
With C-sharp, you can use the sealed keyword to prevent a class from being used as a base class if you decide that it should not be.
The example illustrated below.
If any class attempts to use Alligator as a base class, a compile-time error will be generated.
A sealed class can't declare any virtual methods, and an abstract class can't be sealed.
Sealed methods
You can utilize the sealed keyword to specify that an individual method in an unsealed class is sealed.
For example, if a derived class can't override this method, you can only seal an override method, and you declare the method as sealed override.
A quick way to compare interface, virtual override, and sealed keywords is as follows.
The interface introduces the name of a method.
A virtual method is the initial implementation of a method.
An override method is an additional implementation of a method.
A sealed method is the final implementation of a method.
Garbage collection
Each time you create a new object, the Common Language Runtime, CLR, allots memory for the object from the managed heap.
As long as address space is available in the managed heap, the runtime continues to allocate space for new objects.
Still, memory is not endless.
Ultimately, the garbage collector, or GC, must perform a collection to free some memory.
The GC regulates the best time to perform a collection, based upon the allocations being made.
In order to make a collection, the GC checks for objects in the managed heap that are no longer being utilized,
and makes the necessary operations to reclaim their memory.
Object Lifetime
When value types go out of scope, they are destroyed, and their memory taken back.
However, with reference types, you start off creating an object by using the new operator.
The subsequent example creates a new instance of the Square class.
Square mySquare equals newSquare in close parentheses slash slash square is a reference type.
From your point of view, the new operation is a solitary operation.
But underneath, object creation is really a two-phase process.
1.
The new operation allocates a chunk of raw memory from the heap.
You have no control over this phase of an object's creation.
2.
The new operation converts the lump of raw memory to an object.
It has to initialize the object.
You can regulate this stage by using a constructor.
After you have created an object, you can access its members by utilizing the dot operator.
For example, the Square class includes a method named draw that you can call mySquare.draw in close parentheses.
When the mySquare variable goes out of scope, the square object is no longer being actively referenced,
and the object can be destroyed, and the memory that it is using can be reclaimed.
This might not happen immediately.
Like object creation, object destruction is a two-phase process.
The two phases of destruction exactly mirror the two phases of creation.
1.
The common language runtime, CLR, must perform some tidying up.
You may control this by writing a destructor.
2.
The CLR must return the memory previously belonging to the object back to the heap.
The memory that the object lived in must be deallocated.
You have no control.
Garbage collection is this process of destroying an object and returning the memory to the heap.
3.
Writing destructors.
You can utilize a destructor to complete any tidying up needed when an object is garbage collected.
The CLR will automatically clear up any managed resources that an object uses.
And in many of these cases, writing a destructor is unnecessary.
However, if a managed resource is large, such as a multidimensional array,
it might make sense to make this resource available for immediate disposal by setting any references that the object has to this resource to null.
Additionally, if an object references an unmanaged resource, either directly or indirectly, a destructor can prove useful.
A destructor is a special method, a little like a constructor, except that the CLR calls it after the reference to an object has disappeared.
A destructor begins with the tilde letter, then name of class.
For example, here's a simple class which opens a file for reading in its constructor, and closes the file in its destructor.
Note that this is simply an example, and I do not recommend that you always follow this pattern for opening and closing the files as illustrated below.
There are some very important restrictions that apply to destructors.
Destructors apply only to reference types, i.e. you can't declare a destructor in a value type, like a strut, for example.
You cannot specify an access modifier, such as public, for a destructor.
You never call the destructor in your own code.
Part of the CLR, called the GC, does this for you.
A destructor cannot take any parameters.
Again, this is because you never call the destructor yourself.
Internally, the C-sharp compiler automatically translates a destructor into an override of the object.finalize method.
The compiler converts this destructor, as illustrated below.
The compiler generates a finalize method which holds the destructor body in a try block.
It calls the method in the base.
This ensures that a destructor always calls its base class destructor, even if an exception occurs during your destructor code.
It's important to note that solely the compiler can render this translation.
You can't write your own method to override finalize, and you can't call finalize yourself.
Why use the garbage collector?
You can never destroy an object yourself by using C-sharp code.
There just isn't any syntax to do it.
The CLR will do it for you at a time of its own making.
Also, remember you can also make several reference variables refer to the same object.
In the subsequent code example, the variables myfp and reference to myfp point to the same process file object.
Process file myfp equals new process file in closed parentheses.
Process file reference to myfp equals myfp.
How many references can you create to an object?
As many as you want.
This has an impact on the lifetime of an object.
The CLR must be cognizant of all these references.
If the variable myfp disappears, by going out of scope, other variables, such as reference to myfp, might still exist, and the resources used by the process file object cannot be reclaimed.
The file shouldn't be closed.
So, the lifetime of an object cannot be tied to a particular reference variable.
An object can be destroyed, and its memory made available for reuse only when all the references to it have disappeared.
You can see that managing object lifetimes is complex, which is why the designers of C-sharp decided to prevent your code from taking on this responsibility.
If you needed to destroy objects, sooner or later one of the ensuing circumstances would come up.
You'd forget to destroy the object.
This would mean that the object's destructor, if it had one, would not be run,
tidying up would not occur, and memory would not be returned back to the heap.
You'd try to destroy an active object and risk the possibility of one or more variables holding a reference to a destroyed object, known as a dangling reference.
A dangling reference refers either to unused memory or possibly to a wholly different object that now happens to occupy the same piece of memory.
Either way, the outcome of using a dangling reference would be undefined at best, or security risk at worst.
All bets would be off.
You'd try to purge the same object more than once.
This may or may not cause a serious error.
These problems are unacceptable in a language like C-sharp, which places robustness and security high on its list of design goals.
So the best option is for the GC to destroy objects on your behalf.
It ensures that each object will be destroyed, and its destructor will be run.
Once a program ends, all outstanding objects will be destroyed.
Each object will be destroyed exactly once.
Each object will be destroyed solely once it's unreachable, i.e. when there are no program references to the object.
These guarantees are extremely useful and free you from tedious housekeeping chores that are easy to get wrong.
They afford you the luxury to concentrating on the logic of the program itself and being more productive.
Garbage collection can be quite a resource consumer, so the CLR collects garbage only when it needs to.
For example, low memory or the size of the heap has exceeded the system defined threshold.
And then it collects as much as it can.
Carrying out a few large sweeps of memory is more efficient than lots of small ones.
One feature of the GC is that you don't know, and should not rely upon, the order in which objects will be destroyed.
The last, and probably most important point to note, destructors don't run until objects are garbage collected.
Should you decide to write a destructor, you are going to know that it will be executed, although not when.
Consequently, you should on no occasion write code which depends on destructors running in a particular sequence,
or at a specific point in your application.
How the garbage collector works.
It runs on its own individual thread, and can execute only at certain times.
Typically, when your application reaches the end of a method.
While it runs, other threads running in your application will temporarily halt.
This is because the GC might need to move objects around and update object references.
And it cannot do this while objects are in use.
The garbage collector, GC, is a complicated piece of software that is self-tuning,
and implements a number of optimizations to try to balance the need to keep memory available against the requirement to maintain the performance of the application.
The details of the internal algorithms and structures that the GC uses are beyond the scope of this ebook,
but at the high level, the steps that the GC takes are as follows.
One.
It builds a map of all reachable objects.
It ensures this by continually following reference fields inside objects.
The GC builds this map very carefully, and makes sure that circular references do not cause endless recursion.
Any object not in this map is considered to be unreachable.
Number two.
It examines if any of the unreachable objects has a destructor that needs to be run, a process called finalization.
Any unreachable object that needs finalization is placed in a special queue termed the f-reachable queue, pronounced f-reachable.
Number three.
It deallocates the outstanding unreachable objects, i.e. those that don't require finalization, by moving the reachable objects down the heap,
thus defragmenting the heap and freeing memory at its top.
Once the GC moves a reachable object, it updates all references to that object.
Number four.
From here, other threads can resume.
Number five.
It finalizes the unreachable objects that require finalization.
Now in the f-reachable queue, by running the finalize methods on its own thread.
Recommendations.
If you write classes that contain destructors, it will add complexity to your code, and to the GC process, and make your program run more slowly.
If your code doesn't have any destructors, the GC doesn't need to place unreachable objects in the f-reachable queue and finalize them.
Clearly, not doing something is faster than doing it.
Therefore, try to avoid using destructors except when you really need them.
Only use them to reclaim unmanaged resources.
For example, consider using a statement instead, as it will be described later in this chapter.
You must be very careful when you write a destructor.
Specifically, be aware that, if your destructor calls further objects, those objects might have already had their destructor called by the GC.
As noted, the order of finalization is not guaranteed, so make sure that destructors do not depend on one another or overlap one another.
For example, don't have two destructors that attempt to release the identical resource.
Resource management.
On some occasions, it's best to release a resource in a destructor.
Some resources are just too valuable to wait for an unknown length of time until the GC actually releases them.
Limited resources such as memory, database connections, or file handles need to be released.
And they need to be released as soon as practical.
Situations such as these, your only option is to release the resource yourself.
In order to do this, you create a disposal method, e.g., a method that unambiguously disposes of a resource.
Should a class have a disposal method, then it is viable for you to call it, and decide when the resource is released.
Disposal methods.
Take a class such as TextReader, which implements a disposal method.
It provides a mechanism to read characters from a sequential stream of output.
The TextReader class contains a virtual method named Close, which closes the stream.
Both the StreamReader class and the StringReader class override the Close method and originate from TextReader.
The subsequent is an example which reads lines of text from a file using the StreamReader class,
and then displays it on the screen, as illustrated below.
The ReadLine method reads the subsequent line of text from the stream into a string.
The ReadLine method returns null if there is nothing left in the stream.
It's important to call Close when you have finished with Reader to release the file handle and associated resources.
However, this example is not exception-safe.
If the call to ReadLine throws an exception, it will be bypassed, and the call to Close won't occur.
If this happens often enough, you will run out of file handles and be unable to open any more files.
Safe Disposal.
In order to guarantee that a disposal method, e.g. a Close, is always called, irrespective of whether there is an exception,
you can call the Disposal method within a finally block.
The following is the previous example coded by using this technique, as illustrated below.
You can use a finally block, but it has some limitations that make it a less-than-perfect solution.
It quickly becomes unwieldy if you have to dispose of more than one resource.
You end up with nested try and finally blocks.
In some cases, you might need to modify the code to make it fit this idiom.
It fails to create an abstraction of the solution.
This means that the solution is hard to understand, and you must repeat the code everywhere you need this functionality.
The reference to the resource stays in scope after the finally block,
so you could accidentally try to use the resource after it had been released.
The using statement is designed to resolve all these problems.
Using and iDisposable interface.
The using statement offers a clean mechanism for regulating the lifetimes of resources.
You can create an object, and this object will be destroyed when the using statement block finishes.
The subsequent example is a good way to ensure that your code always calls close on a text reader, as illustrated below.
The iDisposable interface must be implemented by the variable which you state in the using statement.
The iDisposable interface lives in the system namespace, and contains just one method, named dispose.
The purpose of a dispose method is to free any resources used by an object.
It just so happens that the stream reader class implements the iDisposable interface,
and its dispose method calls close to close the stream.
You can employ a using statement as a clean, exception-safe, and robust way to ensure that a resource is always released.
This approach solves all of the problems that existed in the manual try-slash-finally solution.
The solution now.
Scales well if case you need to dispose of numerous resources.
Doesn't change the logic of the program code.
Abstracts away the problem and avoids repetition.
Is robust.
You can't accidentally reference the variable declared within the using statement.
In this case, line reader.
After using the statement has ended because it's not in scope anymore.
Calling the dispose method from a destructor.
When writing your own classes, should you write a destructor or implement the iDisposable interface
so that instances of your class can be managed by a using statement.
A call to a destructor will happen, but you just don't know when.
On the contrary, you know exactly when a call to the dispose method happens,
but you just can't be sure that it will actually happen,
since it relies on the developer using your classes remembering to write a using statement.
Nevertheless, it is possible to guarantee that the dispose method always runs by calling it from the destructor.
This is like a useful backup.
You may not remember to call the dispose method.
However, you can be certain that it is called even if it's only when the program terminates.
Here's an example of how you might implement the iDisposal interface, as illustrated below.
Features of the iDispose class.
If iDisposable interface is implemented by this class,
your application code can call the public dispose method at any time.
The public dispose method calls the protected and overloaded version of the dispose method that takes a boolean parameter,
passing the value true as the argument.
This method actually performs the resource disposal.
The destructor calls the protected and overloaded version of the dispose method that takes a boolean parameter,
passing the value false as the argument.
The destructor is called only by the garbage collector, when your object is being finalized.
You can call the protected dispose method safely multiple times.
The variable disposed indicates whether the method has already been run,
and is a safety feature to prevent the method from attempting to dispose the resources numerous times,
if it is called simultaneously.
Your application might call dispose,
but before the method completes, your object might be garbage collected,
and the dispose method run again by the CLR from destructor.
The resources are released only the first time the method runs.
The protected dispose method supports disposal of managed resources, e.g. largeArray,
and unmanaged resources, e.g. fileHandle.
If the disposing parameter is true,
this method must have been called from the public dispose method.
In this case, the managed resources and unmanaged ones are let go.
If the disposing parameter is false,
this method must have been called from the destructor,
and the GC is finalizing the object.
In this case, it is not necessary, or exception safe,
to release the managed resources,
because they will be, or have been by now,
handled by the garbage collector,
so only the unmanaged resources are released.
The public dispose method calls the static GC.suppressFinalize method.
This method stops the GC from calling the destructor on this object,
which has formerly been finalized.
All the regular methods of the class, such as certain function,
check to see whether the object has already been discarded.
If it has, they throw an exception.
Part 3. Extending C-sharp Types.
Properties.
A property is a cross between a field and a method.
It looks like a field, but acts like a method.
You access a property by using exactly the same syntax that you use to access a field,
although the compiler automatically translates that into accessor method calls,
also known as property getters and property setters.
The following illustration outlines how to declare properties.
A property can contain two blocks of code, starting with the get and set keywords.
The get block contains statements that execute when the property is read,
and the set block contains statements that run upon writing to the property.
The property type stipulates the type of data read, get accessor, and written, set accessors.
The subsequent code demonstrates the screen position structure rewritten by using properties.
When looking at this code, note the following.
Lowercase, underscore a and underscore b are private fields.
Uppercase public a and public b are public properties.
All set accessors are sent the data to be written via a hidden, built-in parameter named value.
A private field directly implements each property, but this is only one way to implement a property.
All that is required is that a get accessor returns a value of the specified type.
Such a value can simply be calculated dynamically,
as opposed to being simply retrieved from stored data,
in which case there would be no need for a physical field.
Using properties.
Once you utilize a property in an expression, you can use it in a read setting,
i.e. you are retrieving its value,
and in a write setting, i.e. you are adjusting its value.
The code that follows demonstrates how to read values from the public a and public b properties
of the screen positional structure, as illustrated below.
You used identical syntax to access properties in fields.
When you utilize a property in a read context,
the compiler automatically translates your field-like code into a call to the get accessor of that property.
Likewise, if you use a property in a write context, the compiler automatically translates your field-like code into a call to the set accessor of that property.
The values being assigned are passed into the set accessors by using the value variable, as described in the preceding section.
The runtime performs this task straight away.
You can also utilize a property in a read-slash-write setting.
In such a circumstance, both the get accessor and set accessor are utilized.
For example, the compiler automatically translates statements such as the following into calls to the get and set accessors.
Originals.publicA plus equals 10.
Read-only properties.
It is possible to declare a property which encompasses only a get accessor.
In such a case, you may utilize the property solely in a read context.
For example, here's the publicA property of the screen positional structure declared as a read-only property, as illustrated below.
The publicA property does not contain a set accessor.
Therefore, any attempt to use publicA in a write context will fail, as demonstrated in the subsequent example.
Originals.publicA equals 170 slash slash compile dash time error.
Write-only properties.
Likewise, it is possible to declare a property that contains only a set accessor.
In this case, you can utilize the property only in a write context.
For example, here's the x property of the screen positional structure declared as a write-only property, as illustrated below.
The publicA property does not contain a get accessor.
Any attempt to use publicA in a read context will fail, as illustrated here.
Property Accessibility.
It is feasible to stipulate the property's accessibility, public, private, or protected, when you declare it.
However, it is possible within the property declaration to override the property accessibility for the get and set.
Take the version of the screen positional structure, for example, shown below.
It defines the set accessors of the publicA and publicB properties as private.
The get accessors are public, since the properties are public, as illustrated below.
You must observe some rules when defining accessors with different accessibility from one another.
You can change the accessibility of only one of the accessors when you define it.
This is so since it is not logical to define a property as public, and then change the accessibility of both properties to private later.
The modifier can't stipulate lesser restrictive accessibilities than that of the property.
Take the property as declared private, for example.
You can't specify the read accessor as public.
Instead, you would make the property public and make the write accessor private.
Property restrictions.
Properties look, act, and feel like fields when you read or write data using them.
However, they are not true fields, and certain restrictions apply to them.
You can assign a value through a property of a structure or class only after the struct and class has been created.
The following code example is illegal because the location variable has not been initialized, by using new.
ScreenPositionalLocation, location.publicA equals 20, slash slash compile dash time error, location not assigned.
You can't use a property as a ref or an out argument to a method,
although you can use a writable field as a ref or an out argument.
This makes sense because the property doesn't really point to a memory location.
Rather, it points to an accessor method, such as in the following example.
My method, parentheses, ref location.publicA, parentheses, slash slash compile time error.
The most a property can contain is one get accessor and one set accessor.
It can't contain other methods, fields, or properties.
The get and set accessors cannot take any parameters.
The data being assigned is passed to the set accessor automatically by using the value variable.
You can't declare const properties, such as is demonstrated here.
const int publicA, squiggle bracket, get, squiggle bracket, dot, dot, dot, squiggle bracket, set, squiggle bracket, dot, dot, dot, squiggle bracket, slash, slash, compile dash time error.
Indexers.
You can think of an indexer as a smart array in much the same way that you can think of a property as a smart field.
Whereas a property encapsulates a single value in a class, an indexer encapsulates a set of values.
The syntax for an indicator is identical to that of an array.
They are invaluable if you want to provide access to items that contain multiple values by using a natural and familiar syntax.
Points to note on indexers are
Indexers allow objects to be indexed in a comparable way to arrays.
You return a value with the get accessor and assign a value with the set accessor.
You utilize this keyword to state the indexers.
Utilize the value keyword to define the value being assigned by the set indexer.
You don't have to use integer values to index indexers.
It's your obligation to state the precise lookup mechanism.
You can overload indexers.
You can use more than one formal parameter, e.g. accessing a two-dimensional array.
An example which doesn't use indexers.
Usually, you use an int to store an integer value.
Internally, an int stores its value as a sequence of 32 bits, where each bit can be either 0 or 1.
Most of the time, you don't care about this internal binary representation.
You just use an int type as a container that holds an integer value.
However, sometimes programmers use the int type for other purposes.
Some programs use an int as a set of binary flags and manipulate the individual bits within an int.
C-sharp provides a set of operators that you can use to access and manipulate the individual bits in an int.
These include the NOT operator, an unary operator which performs a bitwise complement.
For example, if you take the 8-bit value 11001100, 204 decimal, and apply the NOT operator to it,
you obtain the result 00110011, 51 decimal.
All the 1s in the original value become 0s, and all the 0s become 1s.
The left shift operator.
This is a binary operator that performs a left shift.
The expression 204 left shift 2 gives the result 48.
In binary, decimal 204 equals 11001100, and left shifting it by two places makes it 0011000, or 48 decimal.
The far left bits are discarded, and 0s are introduced from the right.
This is a corresponding right shift operator.
The OR operator.
This is a binary operator that performs a bitwise OR operation,
returning a value containing a 1 in each position in which either of the operands has a 1.
Take the expression 204 or 24, for example.
It has the value 220.
204 is 11001100.
24 is 0011000.
And 220 is 110011100.
The AND operator.
This operator performs a bitwise AND operation.
AND is similar to the bitwise OR operator,
except that it returns a value containing a 1 in each position where both of the operands have a 1.
So, 204 and 24 is 8.
204 is 11001100.
24 is 0011000.
And 8 is 000011000.
The ZOR operator.
This operator completes a bitwise exclusive OR operation.
That is, returning 1 in every bit where there is a 1 in one operand or the other.
But not both.
Two 1s yield a 0, which is the exclusive part of the operator.
Therefore, 204 ZOR 24 is 212.
11001100 ZOR 0011000 is 11010100.
You can utilize these operators together to determine the values of the specific bits in an int.
As an example, the following expression uses the left shift and bitwise AND operators
to determine whether the 6-bit from the right of the byte variable named bits is set to 0 or to 1.
So, let's use bits AND parentheses 1 left shift 5 parentheses parentheses parentheses exclamation point equals 0.
Suppose that the bits variable contains the decimal value 42.
In binary, this is 0010101010.
The decimal value 1 is 00000001 in binary.
In the expression 1 left shift 5 has the value 00100000.
The 6th bit is 1.
In binary, the expression bits and parentheses 1 right shift 5 is 00101010 and 00100000.
And the value of this expression is binary 00100000, which is non-zero.
If the variable bits contain the value 65 or 00000001 in binary, the value of the expression is 00000001 and 00100000,
which yields the binary result 0000000 or 0.
This is a fairly complicated example, but it's trivial in comparison to the following expression,
which uses the compound assignment operator AND equals to set the bit at position 6 to 0.
Bits AND equals NOT parentheses 1 left shift 5 parentheses.
Similarly, if you want to set the bit at position 6 to 1, you can use a bitwise OR operator.
The following complicated expression is based on the compound assignment operator OR equals.
Bits OR equals parentheses 1 left shift 5 parentheses.
The trouble with these examples is that although they work, they are not at all easy to comprehend.
They're complicated, and the solution is a very low-level one.
It fails to create an abstraction of the problem that it solves,
and it is consequently very difficult to maintain code which carries out these kinds of operations.
The same example using indexers.
Let's pull back from the preceding low-level solutions for a moment for a reminder of what the problem is.
You'd like to use an int, not as an int, but as an array of bits.
Therefore, the best way to solve this problem is to use an int as if it were an array of bits.
In other words, what you'd like to be able to write down to access the bit 6 places from the right in the bits variable is an expression such as the following.
Remember that arrays start with the index 0.
Bits 5 in enclosed brackets.
And, to set the bit 4 places from the right to true, we'd like to be able to write this.
Bits 3 in enclosed brackets equals true.
Unfortunately, you can't use the square bracket notation on an int.
It works only on an array or on a type that behaves like an array.
The answer to the problem is to make a new type that is essentially like an array of bool variables but is implemented by using an int.
You can achieve this feat by defining an indexer.
Let's call this new type integer bits.
Integer bits will contain an int value, initialized in its constructor.
But the idea is that you'll use integer bits as an array of bool variables.
To define the indexer, you use a notation that is a cross between a property and an array.
You introduce the indexer with the this keyword, specify the type of the value returned by the indexer,
and also specify the type of the value to use as the index into the indexer amongst .
The indexer for the integer bits struct uses an integer as its index type and returns a boolean value.
Note the following.
Although similar, an indexer isn't a method.
It has no parentheses containing a parameter.
However, there are square brackets that stipulate an index.
You utilize this bit index to specify which elements are being accessed.
Each indexer utilizes the this keyword.
A struct or class may state at most one indexer.
However, it is possible to overload it and have numerous implementations.
Plus, it is always nameless.
Indexers encompass get and set accessors comparable to properties.
The get and set accessors here have the intricate bitwise expressions, discussed previously.
The index started in the indexer assertion is furnished with the index value stated once the indexer was called.
The get and set accessor methods can read this argument to decide which element should be accessed.
Understanding indexer accessors.
Whenever you read an indexer, the compiler immediately translates your array-like code into a call to the get accessor of that indexer.
For example, bool peak equals bits six in enclosed brackets.
This line of code is converted to a call to the get accessor for bits, and the index argument is set to six.
Likewise, if you write to an indexer, the compiler automatically translates your array-like code into a call to the set accessor of that indexer.
Setting the index argument to the value enclosed in the square brackets, such as demonstrated here.
Bits, three in enclosed brackets, equals true.
This statement is converted to a call to the set accessor for bits where index is three.
Like ordinary properties, the data which you are writing to the indexer, in this case true,
is made available inside the set accessor by using the value keyword.
This type of value is identical to the type of indexer itself, bool in this example.
It's also possible to use an indexer in a combined read-slash-write context.
In such a circumstance, the get and set accessors are both used.
The following, for example, uses the ZOR operator to invert the value of the bit at index six in the bits variable.
Bits, six in enclosed brackets, ZOR equals true.
This code is automatically translated into the following.
Bits, six in enclosed brackets, equals bits, six in enclosed brackets, ZOR true.
This code works for the reason that the indexer declares both a get and a set accessor.
Comparing indexers and arrays.
When you use an indexer, the syntax is purposely array-like,
although there are numerous significant differences between indexers and arrays.
Indexers can utilize non-numeric subscripts, like string as shown in the subsequent examples,
while arrays can only use integer subscripts.
Public int this string name in enclosed bracket, squiggle bracket, dot dot dot, squiggle bracket, slash slash.
This is okay.
You can overload indexers, like methods, however arrays can't.
Public name this phone number number in enclosed bracket, squiggle bracket, dot dot dot, squiggle bracket.
You cannot use indexers as ref or out parameters, while array elements can be.
Integer bits, bits, slash slash, bits contains an indexer.
Method, parentheses, ref bits, one in enclosed brackets, parentheses, slash slash, compile dash time error.
Indexers in interfaces.
You can declare indexers in an interface.
To achieve this, stipulate the get keyword, the set keyword, or both.
But substitute the body of the get or set accessor with a semicolon.
Every class or structure which implements the interface needs to implement the indexer accessors declared to the interface,
as illustrated below.
Should you implement the interface indexer in a class, you can state the indexer implementations as virtual.
This permits further derived classes to override the get and set accessors, like illustrated below.
Generics.
Once your applications start to develop and become more sophisticated,
you are going to require a better way to reuse and modify existing software.
C-sharp includes a feature called generics to facilitate code reuse, especially the reuse of algorithms.
Just as methods are powerful because they can take arguments,
so types and methods that take type arguments have significantly more functionality.
C-sharp without generics.
So far in this ebook, you have seen that you can use the object type to store a value of any type,
and you can define parameters by using the object type when you have to pass values of any type into a method.
You can also return values of any time with a method, and this practice is very flexible, but it has a drawback.
The responsibility on the developer to remember what kind of data is being used.
If the developer makes a mistake, this can result in runtime errors.
In order to understand generics, it's best to look in detail at the problem that they are designed to solve.
For example, presuppose that you needed to model a first-in, first-out structure such as a queue.
You could create a class such as the following illustration.
This class uses an array to provide a circular buffer for holding the data.
The size of this array is specified by the constructor.
An application uses the enqueue method to add an item to the queue,
and the dequeue method to pull an item off the queue.
Where to insert, retrieve an item from the array is kept track of with the private head and tails fields.
The numElements field indicates how umpteen items are in the array.
The enqueue and dequeue methods use these fields to determine where to store or retrieve an item from
and perform some rudimentary error checking.
An application can generate a queue object and call these methods, as illustrated in the code example that follows.
Notice that the items are dequeued in the same order in which they are enqueued, shown in the illustration below.
Now, the queue class works well for queues of ints.
But what if you want to create queues of strings, or floats, or even queues of more complex types such as circle,
as covered in classes and objects, or alligator, or whale?
The problem is that the way in which the queue class is implemented restricts it to items of type int.
And if you try to enqueue an alligator, you will get a compile time error.
q q equals new q parentheses.
alligator my alligator equals new alligator parentheses.
q dot enqueue my alligator and enclosed parentheses.
slash slash compile time error can't convert from alligator to integer.
One way around this restriction is to specify that the array in the queue class contains items of type object.
Update the constructors, and modify the enqueue and dequeue methods to take an object parameter and return an object,
such as in the following illustration.
Don't forget that you can utilize the object type to refer to a value or variable of any type.
Every reference type inherits from the system.object class in the .NET framework automatically.
C-sharp colon object aka system.object.
Now, because the enqueue and dequeue methods manipulate objects, you can operate on queues of circles, alligators, whales,
or any of the other classes that you have seen in earlier exercises in this ebook.
Although, it is vital to note that you must cast the value return by the dequeue method to the appropriate type,
since the compiler won't perform the conversion from the object type automatically.
Q, Q, equals new Q, parenthesis.
Alligator my alligator equals new alligator, parenthesis.
Q, dot, in Q my alligator, in enclosed, parenthesis, slash slash now legal dash alligator is an
object.
Q, Q, equals new Q, parenthesis.
Alligator my alligator equals new alligator, parenthesis.
Q, dot, in Q my alligator, in enclosed, parenthesis, slash this is ok alligator is now an object.
dequeued alligator equals alligator in parentheses q dot dequeue parentheses slash slash must cast
object back to an alligator. If you don't cast the return value, you will get the compiler error
cannot implicitly convert type object to alligator. This requirement to perform an explicit cast
degenerates much of the flexibility afforded by the object type. Furthermore, it is very easy to
write code such as this. qq equals new queue parentheses alligator my alligator equals new
alligator parentheses q dot enqueue my alligator in enclosed parentheses. circle my circle equals
circle in enclosed parentheses q dot dequeue parentheses slash slash runtime error. Although
this code will compile, it is not valid and throws a system dot invalid cast exception exception at
runtime. The error is caused by trying to store a reference to an alligator in a circle variable
when it is dequeued, and the two types are not compatible. The compiler will not throw an
error because it doesn't have information to perform this check at compile time. The real
type of the object being dequeued becomes apparent only when the code runs. Another disadvantage of
using the object approach to create generalized classes and methods is that it can consume
additional memory and processor time should the runtime require to convert an object type to value
type and back to object type again. Consider the following piece of code that manipulates
a queue of int values. qq equals new queue parentheses. int my integer equals 99. q dot enqueue
my integer in enclosed parentheses slash slash box the integer to an object. my integer equals
int in enclosed parentheses q dot dequeue parentheses slash slash unbox the object to an integer.
The queue data type assumes the items it holds to be objects reference type. In queuing a value
type, like as an int, necessitates it to be boxed in order to convert it to a reference type.
Likewise, dequeuing into an int means the item has to be unboxed to be converted back to a value type.
Although boxing and unboxing happen transparently, they add performance overhead because they involve
dynamic memory allocations. Although the overhead is small for each item, it all starts to add up when a
program queues large numbers of value types. C-sharp with generics. C-sharp provides generics to remove the
need for casting, improve type safety, reduce the amount of boxing required, and make it easier to create
generalized classes and methods. Generic classes and methods accept type parameters, which specify the
types of objects on which they operate. In C-sharp, you indicate that a class is a generic class by providing a
type parameter in angle brackets, like illustrated below. The T in the above example is like a
container for a real type at compile time. When you write code to instantiate a generic queue, you provide
the type that should be substituted for T. Circle, alligator, int, and so on. When you define the fields
and methods in the class, you use the same placeholder to indicate the type of these items, like illustrated
below. The type parameter T can be any legal C-sharp identifier, although the lone character T is
commonly used. It is replaced with the type you specify when you create a queue object. The subsequent
examples create a queue of ints and a queue of alligators. Q less than int greater than. Int queue
example equals new queue less than int greater than parentheses. Q less than alligator greater than
alligator queue equals new queue less than alligator greater than parentheses. Additionally, the compiler
now has enough information to perform strict type checking when you build the application. You no longer
need to cast data when you call the dequeue method, and the compiler can trap any type mismatch errors
early. Int queue example dot enqueue 99 in enclosed parentheses. Int my int equals int queue
example dot dequeue parentheses slash slash no casting necessary. Alligator my alligator equals
int queue example dot dequeue parentheses slash slash compiler error slash cannot implicitly convert type
int to alligator. You should be aware that this substitution of T for a specified type is not simply a
textual replacement mechanism. Rather, the compiler completes a complete semantic substitution in
order for you to specify any valid type for T. Here are some examples illustrated below. The first example
produces a queue of integers while the second example creates a queue of person values. The compiler also
generates the versions of the enqueue and dequeue methods for each queue. The methods for the int queue
example queue look like the following public void enqueue int item in parentheses public int dequeue
parentheses. The methods for person queue queue are public void enqueue person item in enclosed parentheses
public person dequeue parentheses. Contrast these definitions with those of the object-based version
of the queue class shown in the preceding section. In the methods derived from the generic class, the item
parameter to inqueue is passed as a value type. No boxing need. Similarly, the value returned by dequeue
is also a value type that does not need to be unboxed. A similar set of methods is generated for the other
two queues. The type parameter doesn't have to be a simple class or value type. For example, you can create a
queue of queues of integers, if you should ever find it necessary, like the illustration below. A generic class can
have multiple type parameters. For illustration, the generic dictionary class defined in the system.collections.generic
namespace in the .NET Framework class library assumes two type parameters. One type for keys, one for values.
Collections. You have to create and manage groups of related objects for numerous applications.
You can group objects in two ways. One, generating arrays of objects. Two, generating collections of objects.
Collections offer a more supple way to work with groups of objects. As opposed to arrays, the group
of objects can grow and shrink dynamically when the needs of the application change. For some collections,
you may assign a key to any object which you put into the collection so that you can quickly recover
the object by using the key. The subsequent table is a list of the most generally used collections.
List t. List of objects, accessible by index, like an array, but with additional methods to search list
and sort the contents of list. Queue t. First in, first out data structure with methods to add an entity
to one end of the queue, remove an entity from the other end, and inspect an entity short of removing it.
List t. First in, last out data structure with methods to push an entity onto the top of the stack.
Pop an entity from the top of the stack, and inspect the entity at the top of the stack short of removing it.
Linked list t. Double-ended ordered list, adjusted to sustain insertion and removal at either end.
Possible to act like a queue or a stack, but in addition supports random access, like a list.
Hash set t. Unordered set of values which is adjusted for quick recovery of data.
It provides set-oriented methods for establishing whether the entities it holds are a subset of those
in another. Hash set t object as well as computing the intersection and union of hash set t objects.
Dictionary t-key t-value. Collections of values which can be identified and retrieved by using keys
rather than indexes. Sorted list t-key t-value. Sorted key slash value pairs list.
Keys are required to implement i comparable t. The list t collection class. The generic list t class
is the simplest of the collection classes. You can utilize it much like an array. You can reference
a present element in a list t collection by using ordinary array notation, with square brackets and
the index of the element. However, you can't utilize array notation to increase new elements.
However, in general, the list t class provides more flexibility than arrays, and is designed to
overcome the following restrictions exhibited by arrays. To read just an array, you must create a new
array. Copy the elements. To remove an element from an array, you must move all the trailing elements
up by one place. To insert an element into an array, you must move elements down by one place to make
a free slot. However, you lose the last element of the array. The list t collection class provides the
following features. You don't need to specify the capacity of a list t collection when you create it.
To remove a specific element from a list t collection, use the remove method. You can utilize the add
method to add an element at the end of the list t collection. You can utilize the insert method in order to
insert an item into the central part of a list t collection. To easily sort the data in a list t
object, call the sort method. The following is an example which illustrates how to create, manipulate,
and iterate through the contents of a list int collection, illustrated below. Here is the output of
this code, iterating a for statement 10987654, the linked list t collection class. Each item in the list holds
the value for the item together with a reference to the next item in the list, the next property,
and the previous item, the previous property. The item at the commencement of the list has the
preceding property set to null, and the item at the conclusion of the list has the next property set to
null. Unlike the list t class, linked list t does not support array notation for inserting or examining
elements. Instead, you can use the add first method to insert an element at the start of the list,
moving the first item up and setting its previous property to refer to the new item, or the add list
method to insert an element at the end of the list, setting the next property of the previously last
item to refer to the new item. You can also use the add before and add after methods to insert an
element before or after a specified item in the list. You have to retrieve the item first. You can find
the first item in a linked list t collection by cueing the first property, whereas the last property
returns a reference to the final item in the list. To iterate through a linked list, you can start at
one end and step through the next or previous references until you find an item with a null value
for this property. Alternatively, you can use a FOREACH statement, which iterates forward through a
linked list t object and stops automatically at the end. You delete an item from a linked list t collection
by using the remove, remove first, and remove last methods. The subsequent code shows a working
linked list t collection. Notice how the code that iterates through the list by using A for statement
steps through the next or previous references, only stopping once it receives a null, as illustrated below.
The following is outputted to the console. Iterating using a FOREACH statement,
246810. Iterating using a FOREACH statement, 246810. Iterating list in reverse order,
108642. The QT collection class. The QT class implements a first-in, first-out mechanism.
The enqueue operation adds an item to the back of the queue, while the dequeue operation takes the item
off the queue at the front. Here follows an example showing a queue int collection and its usual operations,
illustrated below. Here is the output from this code. Populating the queue. 9 has joined the queue.
3 has joined the queue. 7 has joined the queue. 2 has joined the queue. The queue contains the following
items. 9372. Draining the queue. 9 has left the queue. 3 has left the queue. 7 has left the queue.
The stack T collection class. It is class modeled on an LIFO mechanism. An element joins the stack at the top,
the push operation, and leaves the stack at the top, the pop operation. Here's an example. Notice the
order in which the items are listed via FOREACH loop, as illustrated below. Here is the output from this
program. Pushing items onto the stack. 9 has been pushed on the stack. 3 has been pushed on the stack.
7 has been pushed on the stack. 2 has been pushed on the stack. The stack now contains 2739. Popping items
from the stack. 2 has been popped off. 7 has been popped off. 3 has been popped off. 9 has been popped off.
The dictionary. tkey t-value collection class. The array and list t-types provide a way to map an
integer index to an element. You specify an integer index within square brackets. For example, 4 in square
brackets. And you get back the element at index 4, which is actually the fifth element. However,
sometimes you might want to implement a mapping in which the type from which you map is not an int,
but rather some other type. Such as string, double, or time. The dictionary tkey t-value class implements
this functionality by internally maintaining two arrays. One for the keys from which you're mapping,
and one for the values to which you're mapping. When you insert a key-slash-value pair into a dictionary,
tkey t-value collection, it automatically tracks which key belongs to which value. It makes it
possible for you to retrieve the value which is linked with a specified key quickly and effortlessly.
The design of the dictionary tkey t-value class has some important consequences. A dictionary tkey
t-value collection cannot contain duplicate keys. If you call the add method to add a key that is
already present in the keys array, you get an exception. You can, however, use the square brackets
notation to add a key-slash-value pair, as shown in the following example, without danger of an
exception. Even if the key has already been added, any present value with the identical key will be
overwritten with the new value. You can test if a dictionary tkey t-value collection already
contains a particular key by using the contains key method. Internally, a dictionary tkey t-value
collection is a sparse data structure that operates most efficiently when it has plenty of
memory with which to work. A dictionary tkey t-value collection can get really big when you add more
items. When you use a for each statement to iterate through a dictionary tkey t-value collection,
you get back a key-value pair tkey t-value item. This is a structure that contains a copy of the key and
value elements of an item in the dictionary tkey t-value collection. And you can access each element
through the key property and the value properties. These elements are read-only. You cannot use them to modify
the data in the dictionary tkey t-value collection. An example that associates the ages of members of
my family with their names and then prints the information, as illustrated below. Here is the
output from this program. The dictionary contains name Lewis, age 47, name Rosanna, age 46, name Joelle, age 20,
name Janet, age 18. The sorted list tkey t-value collection class. The sorted list tkey t-value class
is very similar to the dictionary tkey t-value class in that you can use it to associate keys with value.
The main difference is that the keys array is always sorted. It is called a sorted list after all. It takes
longer to insert data into a sorted list tkey t-value object than a sorted dictionary tkey t-value object
in most cases. But data retrieval is often quicker, or at least as quick, and sorted list tkey t-value
class uses less memory. When you insert a key slash value pair into a sorted list tkey t-value collection,
the key is inserted into the keys array at the correct index to keep the keys array sorted. The value is then
inserted into the values array at the same index. The sorted list tkey t-value class automatically
ensures that keys and values maintain synchronization, even when you add and remove elements. This means
that you can insert key slash value pairs into a sorted list tkey t-value in any sequence. They are
always sorted based on the value of the keys. Comparable to the dictionary tkey t-value class,
a sorted list tkey t-value collection can't hold duplicate keys. When you use a for each statement
to iterate through a sorted list tkey t-value, you receive back a key value pair tkey t-value item.
However, the key value pair tkey t-value items will be returned sorted by the key property. Here is the
same example that associates the ages of members of my family with their names and then prints the
information. But this service has been adjusted to use a sorted list tkey t-value object rather than a
dictionary tkey t-value collection, as illustrated below. The output from this program is sorted
alphabetically by the names of my family members. The sorted list contains name Rosanna, age 46,
name Janet, age 18, name Joel, age 20, name Louis, age 46. The hash set t collection class. The hash set t
class is optimized for performing set operations such as determining set membership and generating the
union and intersect of sets. You use the add method to add items to a hash set t. Similarly, you use the
remove method to delete items. However, the real power of the hash set t class is provided by the
intersect with, union with, and accept with methods. These methods modify a hash set t collection to
generate a new set that either intersects with, has union with, or does not contain the items in a
specified hash set t collection. These operations are destructive inasmuch as they overwrite the
contents of the original hash set t object with the new set of data. You can also determine whether
the data in one hash set t collection is a superset or subset of another by using the i subset of,
is superset of, is proper subset of, and is proper superset of methods. These methods return a boolean
value and are non-destructive. Internally, a hash set t collection is held as a hash table,
enabling fast lookup of items. However, a large hash set t collection can require a significant
amount of memory to operate quickly. The subsequent example shows how to populate a hash set t collection,
and illustrates the use of the intersect with method to find data that overlaps two sets,
as illustrated below. This code generates the following output.
Employees, Fred, Bert, Harry, Louis, Joel. Clients, Louis, Sid, Harry, Rosanna, Janet.
Clients who are also employees, Louis, Harry. Using collection initializers.
The examples in the preceding subsections have shown you how to add individual elements to a
collection by using the method most appropriate to that collection. Add for a list t collection,
nq for a q t collection, push for a stack t collection, and so on. You can also initialize
some collection types when you declare them, using a syntax similar to that supported by arrays.
For example, the following statement creates and initializes the sample numbers list int object
shown earlier, demonstrating an alternate technique to repeatedly calling the add method.
List int sample numbers equals new list int parentheses squiggle bracket 10987765104321 squiggle bracket.
Internally, the C-sharp compiler actually converts this initialization into a number of calls to the
add method. Subsequently, you can use this syntax only for collections that actually support the add
method. However, the stack t and q t classes don't. For more complex collections,
which take key-slash-value pairs like dictionary t key t value class, you can stipulate each key-slash-value
pair as an anonymous type in the initializer list, like so.
Dictionary string int ages equals new dictionary string int parentheses squiggle bracket squiggle
bracket lewis 44 squiggle bracket squiggle bracket rosanna 45 squiggle bracket squiggle bracket joelle 17
squiggle bracket squiggle bracket janet 15 squiggle bracket squiggle bracket. Note, in a pair, first item is key,
second item is value. The find methods, predicates, and lambda expressions. Using the dictionary-oriented
collections dictionary t key t value, sorted dictionary t key t value, and sorted list t key t value,
you can quickly find a value by specifying the key to search for, and you can use array notation to access
the value, as you have seen in earlier examples. Other collections that support non-keyed random access,
such as the list t and linked list t classes, do not support array notation, but instead provide the
find method to locate an item. For these classes, the argument to the find method is a predicate
that specifies the search criteria to use. The form of a predicate is a method that examines each item
in the collection, and returns a boolean value indicating whether the item matches. In the case of the find method,
as soon as the first match is found, the corresponding item is returned. Note that the list t and linked list t classes
also support other methods such as find last, which returns the last matching object, and the list t class
additionally provides the find all method, which returns a list t collection of all matching objects. The most convenient
way to stipulate the predicate is via a lambda expression. Delegates. A delegate permits you to
capture a reference to a method and pass it around like any other object. In addition, it is possible
to call the captured method as you would for any other method. Typically, when you write a statement
that invokes a method, you specify the name of the method, and possibly specify the object or structure
to which the method belongs. It is clear from your code exactly which method you are running, and when you
are running it. Look at the following simple example that calls the CPU calculate method of a CPU
processor object just as an example of a central processing unit processor. CPU processor p equals
new CPU processor parentheses. p dot CPU calculate parentheses. The next example creates a delegate named
CPU calculate delegate that references the CPU calculate method of the CPU processor object. Some elements of the
statement are omitted that declares the delegate because it is important to understand the concept
rather than worry about the syntax. CPU processor p equals new CPU processor parentheses. Delegate dot dot dot
CPU calculate delegate dot dot dot CPU calculate delegate equals p dot CPU calculate. It is important to
understand that the statement that assigns the method reference to the delegate does not run the method at this
point. There are no parentheses after the method name, and you do not specify any parameters. If the
method takes them, this is just an assignment statement. Having stored a reference to the CPU calculate
method of the CPU processor object in the delegate, the application can subsequently invoke the method
to the delegate like this. CPU calculate delegate parentheses. This looks like an ordinary method call.
If you did not know otherwise, it looks like you might actually be running a method named CPU calculate delegate.
So it retrieves the method that the delegate references and runs that instead. Later on, you can change the
method to which a delegate refers. So a statement that calls a delegate might actually run a different
method each time it executes. Additionally, a delegate can reference more than one method at a time.
Think of it as a collection of method references. And when you invoke a delegate, all the methods to which it
refers will run. Declaring a delegate. You must utilize the word delegate, followed by the return type, then the
identifier, i.e. the delegate name, succeeded by parameters in brackets, to declare a delegate. An example.
public delegate int cpu calculate parentheses int x int y parentheses. Any method, either static or an
instance method, from any accessible class or struct which matches the delegate type may be allocated to
the delegate. You can then programmatically alter method calls, and in addition plug new code into standing
classes. Once you declare a delegate type, a delegate object needs to be created with the new keyword,
and be associated with a particular method. When creating a delegate, the argument passed to the
new expression is written similar to a method call, but without the arguments to the method, as listed
here. Public delegate void print string exp parentheses string zy parentheses dot dot dot. Print string exp print
sg1 equals new print string exp parentheses right to visual parentheses. Print string exp print sg2
equals new print string exp parentheses right to platter parentheses. The subsequent code exhibits
declaration, instantiation, and use of a delegate which can be utilized to reference methods that take an
integer parameter and returns an integer value, as illustrated below. The following is outputted to the
console. Value of number var 35. Value of number var 175. Lambda expressions. A lambda expression is an
anonymous method utilized to produce delegates and sometimes expression trees. It permits you to write
local functions which may be passed as arguments or sent back as the value of function calls. To create a
lambda expression, you stipulate input parameters, if any, on the left side of the lambda operator,
equals greater than, and you put the expression or statement block on the opposite side. Taking,
for example, the lambda expression x equals greater than x star x. It stipulates a parameter that's named x
and returns the value of x squared. To allot this expression to a delegate type, you utilize the following
code illustrated below. The following produces an expression tree type, illustrated below. Lambda
expression forms. Lambda expressions can take series of slightly dissimilar forms. Lambda expressions were
originally part of a mathematical notation called the lambda calculus, which provides a notation for
describing functions. A function is like a method. Although the C-sharp language has extended the syntax and
semantics of the lambda calculus in its implementation of lambda expressions, several of the original rules
are still held. Here are some examples illustrating the different forms of lambda expressions available
in C-sharp, illustrated below. To summarize, here are some features of lambda expressions of which you
should be aware. If a lambda expression takes parameters, you specify them in the parentheses to the
left of the equals greater than operator. You can omit the types of parameters, and the C-sharp compiler
will infer their types from the context of the lambda expression. You can send parameters by reference,
by using the ref keyword, if you want the lambda expressions to be able to change its values other than
locally, but this is not recommended. Lambda expressions can return values, but the return type must match
that of the delegate to which they are being added. The body of a lambda expression can be anything from a
simple expression or a series of C-sharp statements. Method calls and variable definitions. Once a method
ends, variables which were defined in a lambda expression go out of scope. It's possible for a
lambda expression to access and modify all variables outside the lambda expression which are in scope when
the lambda expression is defined. Be very careful with this feature. Events. You have now seen how to
declare a delegate type, call a delegate, and create delegate instances. However, this is only half the
story. Although by using delegates you can invoke any number of methods indirectly, you still have to
invoke the delegate explicitly. In many cases, it would be useful to have the delegate run automatically when
something significant happens. The .NET framework provides events, which you can use to define and trap
significant actions and arrange for a delegate to be called to handle the situation. Numerous .NET
classes expose events. For example, most of the controls which you can place on a form in a Windows
store app or WPF application and the Windows class itself use events so you can run code when the user
interacts. You can also create your own events. Declaring an event. You declare an event in a class
intended to act as an event source. An event source is usually a class that monitors its environment and
raises an event when something significant happens. In the automated factory, an event source could be a
class that monitors the temperature of each machine. The temperature monitoring class would raise a
machine overheating event if it detects that a machine has exceeded its thermal radiation boundary,
i.e. too hot. An event keeps a number of methods to call once it's raised. Sometimes these methods are
denoted as subscribers. These methods should be ready to handle the machine overheating event and take
the essential corrective action like close down the machines. You declare an event similarly to how
you declare a field. Although, since events are envisioned to be used with delegates, the type of
an event needs to be a delegate. Although you need to prefix the declaration with the event keyword,
the following syntax specifies. Event, DelegateTypeName, EventName. Take, for example,
HaltMachineryDelegateDelegate. It has just been repositioned to a new class called MonitorTemperature,
which offers an interface to the numerous electronic probes monitoring the temperature of equipment.
You can state the MachineTooHot event, which will invoke the HaltMachineDelegate, as illustrated below.
The code logic in the MonitorTemperature class raises the MachineTooHot event as well.
Also, you add methods to an event, a process known as subscribing to an event,
rather than adding them to the delegate on which the event is based. You will look at this aspect
of events next. Subscribing to an event. Like delegates, events come ready-made with a
A plus equals operator. You subscribe to an event via an A plus equals operative. In this example of an
automated factory, the software controlling every machine can arrange for the shutdown methods to be
called when the MachineTooHot event is raised, as illustrated below. Notice that the syntax is
the same as for adding a method to a delegate. You can even subscribe by using a Lambda expression.
When the tempMonitorMachineTooHot event runs, it will call all the subscribing methods and shut down the
machines. Unsubscribing from an event. Knowing that you use the plus equals operator to attach a delegate to an event,
you can probably guess that you use the minus equals operator to detach a delegate from an event.
Calling the minus equals operator removes the method from the event's internal delegate collection.
This action is often referred to as unsubscribing from the event. Raising an event. You can raise an event,
just like a delegate, by calling it like a method. Once you raise an event, every attached delegate is
called in sequence. Here, for example, is the MonitorTemperature class with a private notify method
that raises the MachineTooHot event, as illustrated below. This is a frequent expression. You need the
null check since an event field is implicitly null, and only becomes non-null when a method subscribes to
it by using the plus equals operator. Should you raise a null event, or try to, you'll receive a null
reference exception exception. You will need to provide the appropriate arguments when you raise
the event, should the delegate defining the event expect parameters. Link. All of your applications
written have a very high chance that they need to connect to an external database at some point.
It could be tables in a database, files in a desk, or XML documents online. In order to get data,
you are going to need to query the database, and then load the results back into objects.
This can be relatively straightforward, but does not take into account any changes in the structure
of the database. If there is a change in a relational database, then you will have a gap between the
database and your application. The .NET framework offers a straightforward way to deal with the data
called Language Integrated Query, or LINK. LINK is a number of technologies built on query integration
into C Sharp. There is LINK, to SQL, entities, objects, XML, and also to Google, Twitter, eBay. LINK prevents
your application becoming very tightly coupled with the structure of the data that it's processing.
It can be seen as a link between world of general-purpose programming and the data world.
It allows query and set operations on numerous data sources. Once you understand the LINK syntax against
an array, you can consider that you will know most of the concepts of LINK to database.
Fundamentals. LINK requires the data to be stored in a data structure that implements the IEnumerable
or IEnumerableT interface. It doesn't matter how you store your data — array, list, any collection type
like a queue or stack, etc. — as long as it's enumerable, i.e. you can iterate over the structure.
The basics of LINK are sequences and elements. A sequence is simply any object which implements
IEnumerable interface. An element is each item in the sequence. For example, strings
enclose brackets names equals squiggle bracket lewis paul david squiggle bracket. Names is a sequence,
and lewis paul david are elements. This is a local sequence because it is a local object in memory.
A query operator is a method that transforms a sequence. It usually takes an input sequence
and outputs a transformed output sequence. There are around 40 standard query operators.
Simple query. The following is the simplest LINK query which takes one input sequence and one
operator. In this example, we apply the WHERE operator to a simple array and extract those elements
that are four characters or more, illustrated below. standard query operators are implemented
as extension methods. So we call the WHERE directly on names as if it was an instant method.
For this to compile, you need to include using system.link. Projecting data.
With select or select many, every element can be transformed in any mode with a lambda expression.
For example, using the example above, we can transform each element into uppercase with the following code
change. I enumerable less than string greater than names filtered equals names dot select parentheses
n equals greater than n dot two upper and close parentheses parentheses. The examples following are
based on the following arrays, as illustrated below. Grouping, ordering, and aggregating data. LINK offers the
same functionality as SQL in terms of specifying data to be returned in a specific order. You can have
data returned in a particular order. For example, you can group the rows returned in accordance to one
or more key fields. Also, you can calculate summary values based on the rows in each group.
To return data in a specific group, you can use the ORDER BY method. Comparable to the WHERE and SELECT
methods, ORDER BY expects a method as its argument. This method identifies which expressions you are going to
sort the data on. For instance, you can display the name of each business in the addresses array in
ascending order, as illustrated below. The following is outputted to the console. Copper Distillers,
Squaw Valley Hotel, Tray Research, Wide World Importers, Wing Tip Toys. Should you wish to enumerate the
data in descending order, you can instead utilize the ORDER BY DESCENDING method. However, if you wish to
ORDER BY more than one key value, you utilize the ORDER BY or ORDER BY DESCENDING method
after ORDER BY or ORDER BY DESCENDING. The output generated by the example code looks like this.
Country, Germany. One companies. Squaw Valley Hotel. Country, Canada. Two companies. Copper Distillers.
Tray Research. Country, France. Two companies. Wing Tip Toys. Wide World Importers.
Joining Data. Join and Group Join operators are designed to be efficient with local queries and
support inner and left outer joins. Just like SQL, Link gives you the ability to join multiple sets of
data together over on or more common key fields. In order for the code to execute, both the client's
first name and last name must be available in the client's array, but the country for each business
that clients work for is stored in the addresses array. The common key between the client's array
and the address array is the business name. The parameters to the join method are as follows.
The innumerable collection with which to join. A method that identifies the common key fields
from the data identified by the select method. A method that identifies the common key fields on
which to join the selected data. A method that specifies the columns you require in the
innumerable results set returned by the join method. This completes the C Sharp Programming
eBook. I hope this programming guide has been useful for you. I wish you all the best in your further
studies. References. MSDN C Sharp Programming Guide. Guide on key C Sharp language features.
https colon backslash backslash msdn.microsoft.com backslash en-us backslash library backslash
67ef8sbd.aspx Visual Studio Developer Essentials. Some great resources.
https colon backslash backslash backslash
www.visualstudio.com backslash dev-essentials slash stack overflow when your program doesn't work.
http colon backslash backslash stack overflow.com backslash 101 link samples examples you can use in
your programs. https colon backslash backslash code dot msdn dot microsoft dot com backslash 101 dash link
dash samples dash 3fb9811b.
This has been C Sharp. Learn C Sharp fast. The ultimate course book. Beginners to advanced. Written by Gary Mitnick.
Narrated by Sean Tivenin. Copyright 2017 by Gary Mitnick. Production copyright 2017 by Gary Mitnick.
Audible hopes you have enjoyed this program.
