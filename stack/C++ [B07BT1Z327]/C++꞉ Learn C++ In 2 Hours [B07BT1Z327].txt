This is Audible.
C++. Learn C++ in 2 hours.
Written by Cooper Alvin.
Narrated by Matthew Pettigrew.
Introduction.
Bjarn Strostrup developed C++ at Bell Labs in the year 1979.
C++ is a middle-level programming language
that supports varied platforms like Mac OS X,
Unix, and Windows, in addition to a few others.
This book is an introductory tutorial on C++
and is designed for beginners with little to no background of the programming language.
This book follows a practical and simple approach to C++.
We have included executable examples,
along with screenshots of the execution,
to help you run the examples for yourself and execute them.
This will give you a hands-on experience of C++ programming language,
as well as its environment,
which shall prepare you well for any advanced learning in the same.
Although this book does not require you to have any prior knowledge of C++,
knowledge of basic programming languages and computer programs is highly recommended.
You can simply follow the book as a step-by-step guide,
moving from one example to the next as you read the theory related to it.
Nothing teaches any programming language fundamentals better than writing and executing programs in the same.
We hope you will like the book.
With you, Bugless Programming.
Copyright 2017. All rights reserved.
This document is geared towards providing exact and reliable information in regards to the topic and issues covered.
The publication is sold with the idea that the publisher is not required to render accounting,
officially permitted, or otherwise qualified services.
If advice is necessary, legal or professional,
a practiced individual in the profession should be ordered.
From a Declaration of Principles, which was accepted and approved equally by a committee of the American Bar Association
and a committee of publishers and associations.
In no way is it legal to reproduce, duplicate, or transmit any part of this document,
neither electronic means or in printed format.
Recording of this publication is strictly prohibited,
and any storage of this document is not allowed unless with written permission from the publisher.
All rights reserved.
The information provided herein is stated to be truthful and consistent,
in that any liability, in terms of inattention or otherwise,
by any usage or abuse of any policies, processes, or directions contained within,
is the solitary and utter responsibility of the recipient reader.
Under no circumstances will any legal responsibility or blame be held against the publisher
for any reparation, damage, or monetary loss due to the information herein,
either directly or indirectly.
Respective authors own all copyrights not held by the publisher.
The information herein is offered for informational purposes solely and is universal as so.
The presentation of the information is without contract and any type of guarantee assurance.
The trademarks that are used are without any consent,
and the publication of the trademark is without permission or backing by the trademark owner.
All trademarks and brands within this book are for clarifying purposes only,
and are owned by the owners themselves, not affiliated with this document.
Chapter 1. Overview
C++ is a programming language that can be used for object-oriented, procedural,
as well as generic programming.
Its ability to support all these programming forms can be attributed to the fact that C++
has features corresponding to both low-level and high-level programming languages.
This programming language is an enhanced version of C,
which was developed by Bjorn Strostrup in the year 1979 at Bell Labs.
However, it was initially named C with Classes, which was changed in 1983 to C++.
It is a middle-level language that is free-form, statically typed, and case-sensitive.
The type-checking for this programming language is performed at the time of compilation and not at the time of execution.
Moreover, it is compiled and not interpreted.
As previously mentioned, C++ is an enhanced version of C, and any C program is a C++ program also.
The program can be compiled and executed in the C++ environment, just like it's done in a C programming environment.
Lastly, all the object-oriented features like inheritance, polymorphism, data hiding, and encapsulation are supported.
The C++ package includes three main components, which include the core language elements like data types, literals, and variables,
the standard library, and standard template library, or STL.
The C++ standard library includes functions that are used for manipulating objects like files and strings.
Besides this, C++ also includes a library of rich methods for manipulating data structures,
in addition to other such elements of the programming language.
The ANSI standard
Before we move forward, it is important to explain what the ANSI standard means with respect to programming languages.
The ANSI standard is an attempt to standardize the programming language to ensure portability of the code.
It is another way to ensure that the code you write compiles and executes without errors or warnings on another system,
if it does the same on one system.
Almost all of the C++ compilers that are commercially available support ANSI standard C++,
and therefore, its use is highly recommended.
Why C++?
C++ is a programming language that can be used to program in many different methodologies.
With that said, the change in programming style does not affect the efficiency or time effectiveness of the program.
Moreover, it is used for designing new systems as well as maintaining old systems.
It is all of these reasons that C++ is a popular programming language.
Another important aspect of its popularity is the multifaceted use of the programming language.
C++ can be used for writing programs that manipulate the hardware, like device drivers,
as well as creating user interfaces for user-system interaction.
Besides this, C++ is one programming language that is taught as part of any computer science course
because of the sheer utility and widespread use of this programming language.
Environment Setup
In order to run C++ programs, you will need to set up C++ programming environment on your system.
However, you may also choose the online option to avoid the hassle of installing software and compilers.
Due to the heavy dependence of the online solution on the availability of good internet connection,
it is always good to have a setup that can work for you even if internet is not working.
In order to create a local environment setup for C++, you need two software solutions.
Firstly, you require a text editor, which can be used for writing C++ programs.
If you are using Windows, Notepad will do the job for you.
However, if you are working on Linux or Mac, you will have to explore options like VI Editor and TextEdit.
All the C++ files need to be stored using the .cpp extension.
Next, these programs will then be compiled and executed using the C++ compiler.
The most popular compiler used for this purpose is the GNU C slash C++ compiler.
It is simple to install these compilers on your system.
All you need to do is follow the tutorial or instructions for installation and you should be good to go.
Chapter 2
Syntax
Assuming that you have your system ready with the text editor and compiler, if you are using the local setup,
we move on to the basics of C++ programming language.
The first thing that you need to learn about any programming language is the syntax.
This chapter shall help you learn the syntax and get started with C++ programming.
A C++ program
You cannot hope to learn any programming language unless you look at the code and are comfortable with the look and feel of it.
You have to code it to know it.
The simplest program in C++ that we will introduce here is the program that prints Hello World.
This simple code has been given below.
This is my first C++ program.
The output of the code shall look like this.
Going into the detail of what this code does and how it works,
the first line of the program includes a library file called Iostream.
This file is required to perform any input or output operation in the program.
Generally, you must declare all the header files that your program requires at the beginning of the program.
The next line tells the system to use the namespace std.
Mentioning this is important in view of the fact that most of the functions and methods that are used from the libraries are available under this namespace.
You may have a namespace of your own with the functionalities you require implemented as a part of it.
Execution always begins from the main method.
Therefore, all your programs must have a main method that returns an integer value.
Notice the return statement at the end of the program.
Your program must return an integer or you will receive a warning for it.
The main statement that prints the required text on the screen is the count statement.
It has a string combination that is placed within double inverted commas.
Anything that is placed within these double inverted commas as part of the count statement are printed on the screen.
Notice the placement of the two comments in the program.
One of the comments is placed inside forward slash star and star forward slash character combination,
while the other comment follows the forward slash forward slash character combination.
The former is a multi-line comment.
The comment starts after the forward slash star character combination and ends wherever star forward slash is encountered.
On the other hand, the latter is a single line comment.
The comment in this case starts after the forward slash forward slash character combination
and terminates as and when the new line character is encountered.
Another important thing to notice in the program is the use of a semicolon at the end of every statement.
A C++ statement must terminate with a semicolon.
Your C++ program can have any number of white spaces and blank lines.
The compiler simply ignores them.
Besides this, you can see that the C++ statements inside the main functions are enclosed inside curly brackets.
This is referred to as a block.
As a rule, all logically related statements are kept inside one block.
In order to compile and execute this C++ program, open the text editor and write this program in it.
You need to save the file with the extension .cpp.
For instance, you can name this file as sample.cpp.
Compile and execute this file to see the desired results.
Identifiers
An important element of a C++ program that has not been used in the sample program is identifier.
Identifier is a name given to a function, variable, or class and can be described as a combination of characters, numbers, and underscore.
As a rule, an identifier can begin with an underscore or character.
Never use an identifier that starts with a number.
You may use capital and small case alphabets.
C++ is case sensitive.
Therefore, lowercase i-d-e-n and uppercase i-d-e-n are two different identifiers for the system.
Besides this, the use of any other special characters or punctuation within an identifier is prohibited.
Keywords
While naming identifiers, it is important to note that the name must not be the same as a keyword.
Keywords are reserved words that C++ uses for its function implementation.
A list of keywords is given below for your reference.
Classes and Objects
A C++ program can be described as a collection of objects.
All through the execution of the program, these objects basically interact with each other by calling each other's methods or accessing variables.
Before moving forward, let us discuss what these terms mean.
The heart and soul of a C++ program is a class which is a template that declares variables and methods.
The variables are like any other variables, which are just identifiers that can be assigned a value.
On the other hand, a method describes the behavior of the class.
Objects are created by instantiating these classes.
Therefore, objects are real-time entities that are created using the template called class.
In order to help you understand this concept, let us take the example of a class called table, which has the variables named length, breadth, height, wood, color, and type.
Besides this, it has a method that can be used to initialize a table.
Evidently, this is a template or a form that needs to be filled for any new table.
So when you create a table, you instantiate an object of the class table and initialize the variables described above using the method that the class includes for it.
Chapter 3. Data Types
As you will graduate into writing more complicated programs, you will realize that you need variables for storing information.
For instance, if you wish to add two numbers, then you need two variables that can store those two values, and then another variable for storing the resultant.
Each variable has a type.
The type determines the number of memory locations in the physical space that need to be reserved for that variable.
For instance, variables can store characters, integers, floats, boolean, and strings.
The identifier used for referring to this variable is called the variable name.
C++ supports built-in as well as user-defined data types.
Each of these classes have been discussed in this chapter.
Built-in Data Types
The basic data types supported in C++ are as follows.
Boolean
The Boolean data type holds only two values, namely true and false.
The keyword bool is used to declare variables of this type.
Character
This data type can hold any character, including special characters.
The keyword used to declare a variable of this type is char.
The memory allotted for char is one byte.
Integer
This data type can hold any integer.
The keyword used to declare a variable of this type is int.
The memory allotted is four bytes.
Floating point
This data type can hold any number, along with its fractional part, in the form of decimal point numbers.
The keyword used to declare a variable of this type is float.
The memory allotted is four bytes.
Double floating point
This data type can hold any number, along with its fractional part, in the form of decimal point numbers.
Its capacity to store digits that appear from the decimal point is double that of float.
The keyword used to declare a variable of this type is double.
The memory allotted for double is eight bytes.
Valueless
Some variables do not have a data type, and are usually typecasted as per the needs of the program.
Such variables are declared as void or typeless.
Wide character
The memory space allotted to this data type is more than allotted char.
Characters that require a larger memory space can be declared as wide characters, using the keyword wchar underscore t.
The memory allotted for wide char is two or four bytes.
The memory allotted to each of these data types can also be manipulated by using one of the following type modifiers.
Unsigned, signed, long, short.
For instance, using short with int decreases its memory allocation to two bytes.
Besides this, these type modifiers are used to change the range of values that the data type will support.
For example, unsigned data type will only have positive values, while a signed data type will have positive as well as negative values.
The size of a data type on a computer is also hardware dependent, therefore it is good to check the same.
You can execute the following program on your computer to see how the sizes vary on your system.
Pound, include, less than, iostream, greater than, using namespace std, semicolon, int, main, open parenthesis, close parenthesis, open curly bracket, cout, less than, less than, quote,
size of, less than, less than, less than, size of, open parenthesis, wchar, underscore, t, close parenthesis, less than, less than, end l, semicolon, cout, less than, less than, quote,
cout, less than, less than, less than, less than, size of, open parenthesis, int, close parenthesis, less than, less than, end l, semicolon, cout, less than, less than, quote,
cout, less than, less than, less than, less than, size of, open parenthesis, long int, close parenthesis, less than, less than, end l, semicolon, cout, less than, less than,
end l, semicolon, end l, semicolon, s'sice, in all, end l, semicolon, cout, less than, less than, end l, semicolon,gyout, same,
size of, open parenthesis, long int, close parenthesis, end l, semicolon, s'sice, in all, num, d in l, semicolon, kout, size of, open parenthesis, short int, close parenthesis,
end l
c out
less than, less than
size of double
colon
size of opened parenthahy
double
close parenthethy
end l
c out
less than, less than
say of float
colon
size of float
than, size of, open parenthesis, float, close parenthesis, less than, less than, end l,
semicolon, return zero, semicolon, close curly bracket.
The program uses end l, which is just a newline character, so the program asks the system
to print a newline after every line is printed.
This shall make the output more readable.
The execution of the code on your system shall yield a result similar to the one shown below.
Typedef declarations This is a method by which the C++ ecosystem
allows the programmer to rename existing data types according to their convenience and the
needs of their program.
The syntax for using typedef is as follows.
typedef data underscore type new underscore name semicolon Here, the data underscore type
is the data type that needs to be renamed and the new underscore name is the name that you
wish to give this data type.
Sample implementation for typedef is as follows.
typedef int measurement semicolon Now, wherever measurement will be used as a data
type, the variable will internally be declared as an integer.
Variables can be declared of the type measurement using the following syntax.
measurement length semicolon Measurement width semicolon
Enumerated data types C++ also allows the programmer to declare
a data type of his or her own.
Enumerated data types can be given a name and a set of values that they can hold.
Therefore, every enumerator is a constant and the data type of this constant is the enumeration.
In order to create an enum, the following syntax must be used enum name underscore of underscore
enum open curly bracket values close curly bracket var underscore name semicolon Here, enum is
the keyword name underscore of underscore enum is the name that you wish to provide for the
enumerator you are creating values is the list of values that the enum can hold and var underscore
name is the name of the variable that is declared for the enum.
Simple implementation for enum is given below for your reference.
enum color
white comma black comma blue comma red comma green close curly bracket
C underscore name semicolon C underscore name equal sign white semicolon
The C++ statements given above create an enum called color that can hold 5 values namely
white, black, blue, red, and green.
A variable C underscore name is declared as the enum color and then it is assigned the value white.
Internally, the list of values defined inside the curly brackets is assigned the values 0,
1, 2, and so on.
Therefore, white will internally have the value 0 and green will have the value 4.
You can change the value by mentioning the same in the enum declaration.
For example, the code shown below assigns the value 5 to blue.
enum color
white comma black comma blue equal sign 5 comma red comma green close curly bracket C underscore name semicolon
It is important to understand that the values of the enumerators will now be white equals 0, black equals 1, blue equals 5, red equals 6, green equals 7.
The values are assigned in such a manner because the value of the succeeding enumerator is always 1 greater than that of the preceding enumerator.
Chapter 4 Variables
Like we mentioned previously, a variable is an entity that stores variables and has a data type.
As a rule, all variable used in a program must be declared.
When we declare a variable, we basically tell the compiler that the variable must have the specified amount of memory allotted to it,
as it is expected to store values of the specified type.
The syntax for defining a variable is as follows.
data underscore type
var underscore name
semicolon
Here, data underscore type is the data type and var underscore name is the name of the variable.
It is crucial to note here that data underscore type must be a valid data type or else you can expect an error message for the same.
sample declaration is given below
int x semicolon
You can also declare multiple variables in the same line, as it is shown below.
int x comma y comma z semicolon
Here, x, y and z are three variable, which are declared as integers.
Now that you know how to declare variables, let us see how we can assign values to these variables.
For example, if we wish to assign the value 0 to x, 1 to y, and 2 to z, then I can place these statements in my code.
x equals sign 0 semicolon
y equals sign 1 semicolon
z equals sign 2 semicolon
Declaration and initialization can be clubbed together in the following manner.
int x equals sign 0 comma
y equals sign 1 comma
z equals sign 2 semicolon
If you don't initialize the variables, default or garbage values are stored into them.
If the variables are declared as static, then they are initialized with the value null or 0.
On the other hand, all other variables contain garbage values.
Be sure to realize this fact, as it may lead to many logical errors in the code.
The variable declaration statement is checked for at the time of compilation.
However, actual variable definition is required only at the time of linking.
This is particularly the case for global variables that are declared in one file and used in many other files.
Such variables are declared using the extern keyword.
Pound include
less than
iostream
greater than
using namespace std
semicolon
forward slash
forward slash
declaration of the variables
x, y, z, and a
and a
extern int x comma
y
semicolon
extern int z
semicolon
extern float
a
semicolon
int main
open parenthesis
close parenthesis
open curly bracket
forward slash
forward slash
definition
int x comma
y
semicolon
int z
semicolon
float a
semicolon
forward slash
forward slash
forward slash
initialization
x
equal sign
5
semicolon
y
equal sign
10
semicolon
z
equal sign
x
plus y
semicolon
c
out
less than
less than
z
less than
less than
less than
end
l
semicolon
return
0
semicolon
c
out
less than
less than
a
less than
less than
end
l
semicolon
return 0
semicolon
close curly bracket
the following
result is
obtained
r-values
and l-values
expressions
are divided into
two categories
namely l-value
and r-value
if an expression
refers to a memory
location then it
is referred to as
l-value
this expression may
appear on the left
or right hand side
of the c++ statement
on the other hand
data values
are called r-values
and they can only
appear on the right
hand side of the
c++ statement
basically data values
cannot be assigned a
value
as they are values
in themselves
therefore putting them
on the left hand side
of the c++ statement
violates their basic
nature
a valid c++ statement
is shown below
uppercase x
equal sign
10
semicolon
here
10 is a data value
and x is a name
referring to a memory
location
therefore
x is the l-value
and 10 is the r-value
the following statement
is also valid
uppercase x
plus
10
semicolon
x being an l-value
can appear on left
as well as right hand
side of the statement
however
the following statement
is invalid
10
equal sign
uppercase x
semicolon
it is important to
mention here that
constants and literals
are r-values
and they cannot appear
on the left hand side
of a c++ statement
scope of variables
scope of variables
every variable has a scope or region in which it remains valid
broadly there are two types of scopes namely local and global variables
besides this there is also a third type of scope which is formal parameters
local variables are declared inside a block and they are accessible only within that block
the following code uses three local variables namely x y and z and performs multiplication of x and y the result of which is stored in z
pound include less than iostream greater than using namespace std semicolon int main open parenthesis close parenthesis open curly bracket forward slash forward slash declaration of local variables
int x
int x comma y semicolon int x comma y semicolon int z semicolon forward slash forward slash
initialization of local variables x equals sign 5 semicolon y equals sign 7 semicolon z equals sign x star y semicolon c out less than less than z semicolon return 0 semicolon
close curly bracket
close curly bracket
the output of the code can be seen in the image given below
on the other hand global variables are not block dependent and are accessible to all the blocks and functions
lastly
formal parameters are parameters that are imported into a function
they are treated as local variables to the function and are accessible inside the function only
pound include less than iostream greater than using namespace std semicolon
forward slash forward slash declaration of global variable
int g underscore var semicolon
int main open parenthesis close parenthesis open curly bracket forward slash forward slash declaration of local variables
int l underscore var 1 comma l underscore var 2 semicolon
forward slash forward slash initialization of local variables
l underscore var 1 equal sign 5 semicolon l underscore var 2 equal sign 7 semicolon
forward slash star the resultant of addition of two local variables saved into a global variable
star forward slash
g underscore var
equal sign l underscore var 1 plus l underscore var 2 semicolon
c out less than less than g underscore var semicolon
return 0 semicolon
close curly bracket
the output of the code is as follows
this may bring into question a scenario when a local variable has the same name as a global variable and is accessed inside its scope
in this case the local variable gets preference
sample code to illustrate how this works has been provided below
phone
17
declaration of local variable of the same name int g underscore var equal sign 10
semicolon c out less than less than g underscore var semicolon return zero
semicolon close curly bracket the result of the execution of this code is
given below it is crucial to mention here that local variables contain garbage
values if they are only declared and not initialized on the other hand global
variables are initialized by the value zero if number or null if character with
that said it is considered good programming practice to initialize
variables whenever you declare them type qualifiers another concept in C++ that
holds importance here is that of type qualifiers there are three type
qualifiers in C++ namely const restrict and volatile the use of const will be
discussed later in this book the restrict qualifier restricts access to the value
by only allowing the pointer declared as restricted to be used for the access
volatile keyword is used to indicate that the variable concerned can be altered in
different ways by the program storage classes a storage class is a method by
which the lifetime and scope of the variable can be modified the storage
class of a variable is specified as the first word in the declaration of the
variable the storage classes available in C++ are auto mutable extern register and
static each of these classes has been discussed in detail below auto class this is
the default storage class for all local variables moreover the storage class can
only be used inside functions for variables local to the function sample
declaration for the same is as follows auto int a equal sign zero semicolon register
class variables declared as belonging to the register class are stored in the
register instead of RAM this poses several limitations on the variables firstly the
variable cannot be longer than a word besides this applying the unarian
operator on the variable is not allowed as it does not have a memory location sample
declaration for such a variable is given below register int x semicolon it just
means that you want the variable to be stored in the register and the same will be
done if a register is available this storage class is typically used for
variables that are required to be accessed quickly and many times in the program as is
the case of counters static class the scope of a static variable is not block dependent
and the variable remains alive throughout the lifetime of the program therefore if you make
a local variable static only one copy of the variable is saved for any number of
function cells made to the function inside which this variable exists another usage of
this modifier lies in the case of global variables a global variable declared as static is available
only inside the file that it exists besides this if a class member is declared a static only one
copy of this member is stored across any number of objects that may have been created for the
same extern class the extern storage class creates a reference to the global variable for which it is
used and the variable can now be accessed from any number of files however once defined this
variable cannot be defined again this storage file is typically used for global variables that need to be used
beyond the scope of one file mutable class this class is specifically used with
class objects and allows the modification of the mutable member by any const member
function of the class chapter five constants or literals constants or literals are identifiers that
are assigned fixed values the program is not allowed to alter these values under any circumstance in the event that a program
attempts to alter the value of a constant or literal an error message is flashed with that said they
are exactly like regular variables and have a data type they are also declared and initialized like
regular variables integer literals a literal that is decimal octal or hexadecimal is referred to as an
integer literal the preceding numbers or digits indicate the base of the literal for instance 0 precedes octal numbers while hexadecimal
literals have 0x before them if a literal doesn't have any prefix then it is decimal literals may also have suffixes like l or u which indicate if a literal is a long or unsigned respectively
floating-point literals floating-point literals are literals that possess a fractional or exponential part in addition to the integer part therefore they may be represented in decimal form where the integer part is followed by a decimal point and fractional component
or in the exponential form
buoyant literals a buoyant literal is only allowed to have two values therefore there are only two types of buoyant literals namely true and false however do not assume true to be equal to one and false to be same as zero
character literals
character literals
it is a practice to enclose character literals within single inverted commas
a character literal can store characters special characters and universal characters
a list of special character sequences has been given below for your reference
the functionality of escape sequences can be understood by running the following code
pound include less than iostream greater than using namespace std semicolon int main open parenthesis close parenthesis open curly bracket
see out
see out
less than less than
quote
hello
backslash t
backslash t
backslash t
backslash t
world
backslash n
backslash n
backslash n
exclamation point
quote
semicolon
return zero
semicolon
close parenthesis
when you execute the code you will see that hello and world are separated by three tabs and the exclamation sign appears after three new lines
string literals
when you have to declare string literals or character sequences you must do so with double inverted commas
the string can be a sequence of characters and special characters
moreover it can also be multiple lines that are separated using the new line special character or a character with many white spaces
declaring and defining constants or literals
constants can be defined using two methods which have been described below
the first method makes use of the keyword const which must be the first word in the declaration statement of a constant to declare it as such
the syntax for declaring constant variable is as follows
const data underscore type variable underscore name equal sign value semicolon
here
data underscore type is the data type and variable underscore name is the identifier for the variable that is to be used
sample code to illustrate how this can be done is given below
const
include
iostream
using namespace std
semicolon
int main
open parenthesis
close parenthesis
open curly bracket
const int side
equal sign
15
semicolon
const
char
new line
equal sign
apostrophe
backslash
n
apostrophe
int
sq
underscore
area
semicolon
sq
underscore
area
equal sign
side
star
side
semicolon
less than
less than
less than
less than
less than
less than
less than
less than
new line
semicolon
return 0
semicolon
close curly bracket
the output for the code is as shown
the second method makes use of preprocessor directives
the syntax to define a preprocessor directive is as follows
pound
define
name
val
here
name is the identifier and val is the value you expect it to contain
sample implementation of this concept is given below
pound
include
less than
iostream
greater than
using namespace std
semicolon
pound
define
side
15
pound
define
new line
semicolon
return
to the code
sq
slash
n
apostrophe
int
main
open
parentheses
open
curly bracket
int
sq
underscore
area
semicolon
sq
underscore
area
semicolon
sq
underscore
area
semicolon
sq
underscore
colon
return
zero
semicolon
close curly bracket
the output for this program is shown in the image given below
please note that it is considered a good programming practice to write the name of literals or constants in capital letters
chapter six
operators
in order to perform logical and mathematical manipulation on variables and values an entity called operators is used
c plus
c plus plus
c plus plus supports many types of operators including arithmetic, logical, and bitwise operators. Each class of operators is discussed in detail below.
arithmetic operators
arithmetic operators
arithmetic operators
All mathematical operations are performed using operators that fall under the category of arithmetic operators. List of supported operators have been given below.
Addition. This operator performs addition between two numbers. If A and B are two variables holding 5 and 6 respectively, then C equals sign A plus B will yield C equals 11.
Multiplication. This operator performs multiplication between two numbers. If A and B are two variables holding 5 and 6 respectively, then C equals sign A star B will yield C equals 30.
Subtraction. This operator performs subtraction between two numbers. If A and B are two variables holding 5 and 6 respectively, then C equals sign A minus B will yield C equals minus 1.
Division. This operator performs division between two numbers. If A and B are two variables holding 10 and 5 respectively, then C equals sign A forward slash B will yield C equals 2.
Modulus. This operator returns the remainder left after dividing the two numbers. If A and B are two variables holding 10 and 5 respectively, then C equals sign A percent symbol B will yield C equals 0.
Increment. This operator adds 1 to the value of the variable. If A is a variable holding the value 1, then A plus plus will yield the value 2.
Decrement. This operator reduces 1 from the value of the variable. If A is a variable holding the value 1, then A minus minus will yield the value 0.
Relational operators. All operations involving comparison are performed using relational operators. A list of the operators supported by this programming language is given below.
Not equal to. Exclamation point equal sign.
This operator is applied on two operands. It checks equality between two operands. If they are equal, it returns false. Else it returns true.
Equal to. Equal sign. Equal sign.
This operator is applied on two operands. It checks equality between two operands. If they are equal, it returns true. Else it returns false.
greater than the greater than symbol
this operator is applied on two operands
it checks equality between two operands
if the first operand is greater than the second operand
it returns true
else it returns false
less than less than symbol
this operator is applied on two operands
it checks equality between two operands
if the first operand is less than the second operand
it returns true
else it returns false
Greater than or equal to
Greater than sign, equal sign
This operator is applied to two operands.
It checks equality between two operands.
If the first operand is greater than or equal to the second operand, it returns true.
Else it returns false.
Less than or equal to
Less than symbol, equal sign
This operator is applied on two operands.
It checks equality between two operands.
If the first operand is less than or equal to the second operand, it returns true.
Else it returns false.
Bitwise operators
The only difference between normal operators and bitwise operators is that these operators perform operations bit by bit.
Moreover, these operators can be applied on byte, int, short, long, and char.
The list of bitwise operators supported in Java include
Bitwise and
Ampersand
This operator works on two operands, and the output for each set of input bits is 1, if both the inputs are 1.
Else the output is 0.
Bitwise or
Vertical line
This operator works on two operands, and the output for each set of input bits is 1, if 1 or both of the inputs is 1.
Else the output is 0.
Bitwise xor
Carat
This operator works on two operands, and the output for each set of input bits is 1, only if 1 of the inputs is 1.
Else the output is 0.
Bitwise complement
This operator works on a single operand, and negates the values from 0 to 1, and from 1 to 0.
This operator works on two operands. The bits of the left operands are shifted left. The number of places is equal to the number specified as value for the second operand.
This operator works on two operands. This operator works on two operands. The bits of the left operands are shifted right, by the number specified as value for the second operand.
In order to understand how bitwise operations take place, let us take an example.
Assume two variables, A and B, having the values 60 and 13, respectively.
The binary equivalent of A and B are as follows.
A equals 00111100
B equals 00001101
Using the AND truth table, according to which the output is 1, only if both the inputs are 1.
Correspondingly, the output of A&B equals 00001100
Similarly, other bitwise operations can also be performed.
Logical operators
All the logical operators in Java are performed using logical operators. The list of operators supported by this programming language is given below.
Logical AND
This operator works on two operands. If both the operands are non-zero, the expression returns true. Else, it returns false.
Logical OR
This operator works on two operands. If one or both the operands are non-zero, the expression returns true. Else, it returns false.
Logical NOT
This operator works on one operand. If the operand is zero, this expression returns true. Else, it returns false.
Assignment operators
The list of assignment operators supported by Java include
Simple Assignment Operator
Equals sign
This operator assigns the value computed by the right-hand side to the variable on the left-hand side.
If A, B, and C are three variables, and the expression is C equals sign A plus B, then the value of addition of A and B is assigned to C.
Subtract and Assignment Operator
Subtract and Assignment Operator
Minus equal sign
This operator assigns the value computed by the subtraction of right-hand side from left-hand side to the variable on the left-hand side.
If A and C are two variables, and the expression is C minus equal sign A, then the value of C minus A is assigned to C.
Divide and Assignment Operator
This operator assigns the value computed by the modulus of left-hand side with the right-hand side to the variable on the left-hand side.
If A and C are two variables, and the expression is C minus A, then the value of C divided by A is assigned to C.
Modulus and Assignment Operator
Percent Symbol
This operator assigns the value computed by the modulus of left-hand side with the right-hand side to the variable on the left-hand side.
If A and C are two variables, and the expression is C, percent symbol equal sign A, then the value of C modulus A is assigned to C.
Left Shift and Assignment Operator
Less than less than equal sign
If A and C are two variables, and the expression is C less than less than equal sign A, then the value of C left-shift A is assigned to C.
Right Shift and Assignment Operator
Greater than greater than equal sign
If A and C are two variables, and the expression is C greater than greater than equal sign A, then the value of C right-shift A is assigned to C.
Bitwise and Assignment Operator
operator. Vertical line equals sign. If A and C are two variable, and the expression
is C vertical line equals sign A, then the value of C vertical line A is assigned to
C. In addition to the above mentioned, there are a few more operators that do not fall
under any specified category. These operators are sizeof. The sizeof operator is used to
determine the size of the variable that is passed as argument to it. The syntax for using
the sizeof operator is x equal sign sizeof open parenthesis A close parenthesis semicolon
forward slash forward slash now variable x will contain the size of the variable.
Conditional operator question mark colon. The conditional operator is the replacement of
a simple if else statement. The syntax of the conditional operator is condition question
mark A colon Y semicolon. When this C++ statement is given, it checks the condition for truthfulness.
If the condition is true, expression corresponding to A is executed. Else the expression corresponding
to B is executed. Comma operator. Comma. A sequence of operations are performed when the comma operator
is used. The value returned by the expression separated by commas is the value of the last expression
in the list. Dot dot and arrow minus greater than. These operators are used to access class members
associated with objects, structures, and unions. Cast. Cast operator converts the data type of
the variable or value that is sent to it as a parameter. For instance, the value returned
by the expression. For instance, the value returned by the expression int open parenthesis 3.5 close
parenthesis is 3. The expression typecasts the floating point number 3.5 into an integer. Operator precedence.
If an expression uses multiple operators, then operator precedence rules are used to determine
the order of execution of operations. The precedence of operators in terms of whether they will be
evaluated from right to left or left to right is defined for groups of operators in the following
manner. Right to left. Unary. Conditional. Assignment. Left to right. Postfix. Multiplicative. Additive. Shift. Relational.
Quality. Bitwise and. Bitwise xor. Bitwise or. Logical and. Logical or. For example, if we have
to evaluate the expression a equal sign 3 plus 5 star 5, then multiplication is performed before
addition. Therefore, a equals 28 instead of 40.
Chapter 7. Loop Constructs. The fundamental structure that is available in almost all
programming languages is loops. It forms the core of programming and has been discussed in
detail in this chapter. In your programming endeavors, you will experience several situations where you
will be required to execute a set of statements a specified number of times. While most old programming
languages have a go-to label that allows you to redirect control for repetitive execution,
it is not considered a good programming practice to use the same.
In order to prevent the usage of go-to statement for such purposes, loops were introduced.
C++ supports four types of loops, which are as follows.
For loop. The for loop allows the programmer to specify a variable and condition. The variable can
be initialized and updated as part of the for statement. Moreover, the for statement also checks
the condition and the for block is executed only if the condition is true. The syntax for implementing
the for loop is as follows. For, open parenthesis, data underscore type, var underscore name,
equal sign, init underscore value, semicolon, condition, semicolon, var underscore name,
update expression, close parenthesis, open curly bracket, close curly bracket.
Here, data underscore type is the data type of the variable called var underscore name,
which is updated using the expression given in the last section of the for statement.
The condition to be checked for executing the for block is mentioned in the middle section of the for
statement. Sample implementation of the for loop is as follows.
Pound, include, less than, io stream, greater than, using namespace std, semicolon, int main, open parenthesis,
close parenthesis, open curly bracket, int i, semicolon, c out, less than, less than, quote,
inside loop for i, equal sign, quote, less than, less than, i, less than,
less than, less than, apostrophe, backslash, n, apostrophe, semicolon, close curly bracket,
return zero, semicolon, close curly bracket. The result of the execution of this program is as follows.
While loop. While is a comparatively simpler construct that only checks the truthfulness of a
condition for executing the while block. If the specified condition is found true, the block executes,
else it breaks. The syntax for implementing the while loop is as follows.
While, open parenthesis, condition, close parenthesis, open curly bracket, close curly bracket.
Here, the condition to be checked for executing the while block is mentioned in the while statement.
The sample implementation of the while loop is as follows.
Pound, include, less than, iostream, greater than, using namespace, std, semicolon,
int main, open parenthesis, close parenthesis, open curly bracket, int i, equal sign, one, semicolon,
cout, less than, less than, outside loop, backslash, n, semicolon, while, open parenthesis, i, less than,
equal sign, five, close parenthesis, open curly bracket, cout, less than, less than, quote, inside loop for i,
equal sign, quote, less than, less than, i, less than, less than, apostrophe, backslash, n, apostrophe,
semicolon, i, plus, plus, semicolon, close curly bracket, return zero, semicolon, close curly bracket.
The result of the execution of this program is as follows.
Do while loop
Do while loop is a variant of the while loop, which executes at least once, irrespective of
whether the specified condition is true or false. The condition is checked at the end of the first
execution of the block, when the while statement is encountered. The syntax for implementing the
do while loop is as follows. Do open curly bracket, close curly bracket, while, open parenthesis,
condition, close parenthesis, semicolon. Here, the condition to be checked for executing the while
block is mentioned in the while statement. Sample implementation of the do while loop is as follows.
Pound, include, less than, iostream, greater than, using namespace std, semicolon.
Int main, open parenthesis, close parenthesis, open curly bracket. Int i, equal sign, one, semicolon.
See out, less than, less than, quote, outside loop, backslash, in, quote, semicolon. Do, open parenthesis,
see out, less than, less than, quote, inside loop for i, equal sign, quote, less than, less than,
i, less than, less than, apostrophe, backslash, in, apostrophe, semicolon.
I plus plus, semicolon, close curly bracket. While, open parenthesis, i, less than, equal sign, five,
close parenthesis, semicolon, return zero, semicolon, close curly bracket. The result of the execution of
this program is as follows. Nested loop. One or more loops of any type, be it four, while
or do while, can be used inside each other to form a nested loop. There's no limitation on the number
of loops that are allowed. Loop control statements. Loop control statements redirect the flow of
execution from the normal sequence. Moreover, any objects created within the scope that was being
executed are also destroyed. C++ supports three loop control statements, namely, go to, break, and
continue, which have been described below. Break. The break statement is used to redirect control
from the loop block to the statement that appears after the loop block. In this way, the loop ceases
to execute once the statement is encountered. The syntax for its implementation is break, semicolon.
Continue. The continue statement is used to redirect control from the loop block to the first statement
of the loop, which is the for, do, and while statements for the three loop constructs. This statement halts
the execution of the present iteration and initiates the execution of the next iteration.
The syntax for its implementation is continue, semicolon.
Go to. Although the use of the go to statement is strictly prohibited as it exposes the code to external
attacks, there may be times when its use may be inevitable. For such scenarios, this statement has been
included here. The go to statement redirects the execution to the statement that corresponds to
the label specified as part of the go to statement. The syntax for its implementation is go to label
underscore name, semicolon. The infinite loop. Like we said in all the loop constructs, they execute as
long as the condition remains true. So if we create a scenario where the condition never becomes false,
then the loop will execute infinitely. Infinite loops can be created by omitting the condition in the loop
constructs. A sample implementation for this concept is as follows.
Pound, include, less than, iostream, greater than, using namespace std, semicolon,
int main, open parenthesis, close parenthesis, open curly bracket, for, open parenthesis, semicolon,
semicolon, close parenthesis, open curly bracket, cout, less than, less than, quote, this is an infinite
loop, backslash n, quote, close curly bracket, return zero, semicolon, close curly bracket.
This program will continue printing the message until you kill the process using ctrl plus c keys.
Chapter 8. Decision Making
Another important construct, as far as core programming elements are concerned,
is decision making construct. In a decision making construct, the programmer can specify the
condition that needs to be tested and the set of statements that must be executed if the condition
is true. Moreover, the programmer can subsequently also specify the set of statements that must be
executed if the condition is false. C++ supports five types of decision making constructs, each of which
has been described below. If statement
The if statement is the simplest decision making construct that tests the condition which appears
in the if statement. If the condition is found true, the block of statements that follow the if
statement is executed. Sample implementation for the if statement is given below.
Pound, include, less than, iostream, greater than, using namespace std, semicolon,
int main, open parenthesis, close parenthesis, open curly bracket, int i, equal sign, one, semicolon,
open curly bracket, cout, less than, less than, quote, inside if block, backslash n, quote, semicolon,
close curly bracket, return zero, semicolon, close curly bracket. The output for this code is shown in the
image given below. If else statement
The if else is an enhancement of the simple if decision making construct that tests the condition
which appears in the if statement. If the condition is found true, the block of statements that follow
the statement is executed. On the other hand, if the condition is found false, the block of statements
that follow the else statement are executed. Sample implementation for the if else statement is
given below. Pound, include, less than, iostream, greater than, using namespace std, semicolon,
int main, open parenthesis, close parenthesis, open curly bracket, int i, equal sign, one, semicolon,
if, open parenthesis, i, equal sign, equal sign, zero, close parenthesis, open curly bracket,
cout, less than, less than, quote, inside if block, backslash n, quote, semicolon, close curly bracket,
else, open curly bracket, cout, less than, less than, quote, inside else block, backslash n, quote, semicolon,
close curly bracket, return zero, semicolon, close curly bracket. The output for this code is shown in the
image given below. Nested if statements. You can have multiple if statements inside another to test
multiple conditions. There is no limit on the amount of nesting that can be performed for if.
However, the higher the number of ifs inside one another gets, the time complexity of the program
increases. Sample code for implementing the nestled if is as follows. Pound, include, less than,
a. Iostream, greater than, using namespace std, semicolon, int main, open parenthesis, close parenthesis,
open curly bracket, int i, equal sign, one, semicolon, int j, equal sign, one, semicolon, if, open parenthesis,
i, equal sign, equal sign, one, close parenthesis, open curly bracket, cout, less than, less than,
quote, inside if block two, backslash n, semicolon, if, open parenthesis, j, equal sign, equal sign, one,
close parenthesis, open curly bracket, cout, less than, less than, quote, inside if block two,
backslash n, quote, semicolon, close curly bracket, close curly bracket, return zero, semicolon, close curly bracket.
The output generation upon the execution of this code can be seen in the image given below.
Switch statement. In order to mitigate the complexity challenges associated with nested if statements,
C++ also provides switch statements, which can test a variable for multiple values and execute
corresponding statements for the same. This construct internally creates a table which is used for the
execution. As a result, execution is faster and more efficient than the nestled if.
The syntax for implementing switch statements is as follows.
Switch. Open parenthesis. Variable. Close parenthesis. Open curly bracket.
Value 1, colon, statements. Value 2, colon, statements. Value 3, colon, statements.
Default, colon, statements. Close curly bracket.
A sample implementation of the switch statement is given below.
Pound, include, less than, iostream, greater than, using namespace std, semicolon.
Int main, open parenthesis, close parenthesis, open curly bracket. Int i, equal sign, 3, semicolon.
Switch. Open parenthesis, i, close parenthesis, open curly bracket.
Case 1, colon, cout, less than, less than, quote, value entered is 1, quote, semicolon, break, semicolon.
Case 2, colon, cout, less than, less than, quote, value entered is 2, quote, semicolon, break, semicolon.
Case 3, colon, cout, less than, less than, quote, value entered is 3, quote, semicolon, break, semicolon.
Default, colon, cout, less than, less than, quote, value entered cannot be identified by the switch block, quote, semicolon, break, semicolon, close curly bracket, return 0, semicolon, close curly bracket.
The output generated on the execution of the code is as follows.
Nested switch statements.
In addition to these, C++ also supports the conditional operator, question mark, colon, which has already been discussed in the chapter on operators.
Chapter 9. Functions.
Some programs may include complex tasks, and as a result, they may become really long.
Moreover, these tasks may have to be performed repetitively.
For instance, tasks like addition, factorial determination, and many other similar mathematical functions are used commonly in computation.
It is better to write a code and call it than to write the same code again and again.
It is mere wastage of programming effort and increases the number of lines of code.
Besides this, it is a good programming practice to divide a big task into small, manageable tasks.
Modularization of code makes it readable, easy to understand, and maintainable in the long run.
It is for these reasons that the concept of functions has been introduced in programming languages.
Just like the main function that we have implemented in almost every example that we have written,
other functions with task-specific implementation can also be written.
A function can be best described as a block of code that performs a specific task
and needs to be declared and defined as part of the C++ code.
The function declaration includes the return type, function name, and parameters.
On the other hand, the actual body of code that contains the implementation of the task to be performed
is referred to as function definition.
Implementing Functions
Functions may be referred to by many names.
They are also known by names like procedure, subroutine, and method.
Many functions have been implemented and are available as part of the C++ standard library.
You will encounter and use many of these functions in the chapters that follow.
The syntax for implementing a function is as follows.
Here, ret-type is the return type of the function.
F-name is the name of the function, and list-of-parameters entails the parameters that the function is expected to take.
The list of parameters that are passed to a function must be same in number, order, and type
as that mentioned in the function implementation.
Moreover, there may be functions that do not have any parameters,
and no parameters need to be passed to them for invocation.
The function statement is commonly also called the function header,
while the implementation of the function is called function body.
In order to help you understand this better,
let us look at the sample implementation of a function that determines the maximum value
out of the two values provided to it, and returns the maximum value as a result.
int maximum underscore value, open parenthesis,
int number underscore one, comma, int number underscore two, close parenthesis,
open curly bracket, int max underscore val, semicolon,
if open parenthesis, number underscore one, greater than, number underscore two, close parenthesis,
int max underscore val, equal sign, number underscore one, semicolon,
else max underscore val, equal sign, number underscore two, semicolon,
return max underscore val, semicolon, close curly bracket.
Declaring and defining a function
The function statement, or the function header, is the declaration,
and tells the compiler the way in which the function needs to be called.
A function may just be declared at the beginning of the program and can be defined later.
In order to declare the function maximum underscore value,
the following statement needs to be given at the beginning of the program.
int maximum underscore value, open parenthesis,
int number underscore one, comma, int number underscore two, close parenthesis, semicolon.
Alternatively, you may also just use the following statement for function declaration.
int maximum underscore value, open parenthesis, int, comma, int, close parenthesis, semicolon.
It tells the compiler that a function named maximum underscore value exists,
and it can take integer parameters.
It is a good practice to declare your functions at the beginning of the program.
However, it is particularly used in cases where you have the function definition in one file,
and the function is being used in another file.
calling a function
In order to call a function, we need to invoke the function by mentioning its name
and giving a list of parameters that the function will process.
Whenever a function call is made, or the system sees that a function name along with the parameters
has been mentioned, it simply transfers control to the called function.
All the statements given in the body of the function are sequentially executed
to perform the required task.
As and when a return statement is encountered, the control is transferred back to the calling
function, and normal course of execution is followed.
In case a function does not return anything, or is a void function,
then the closing brace of the function transfers control back to the calling function.
The following code calls the function that we implemented previously in this chapter.
Pound include
Pound include
Less than
Iostream
Greater than
Using namespace std
Semicolon
Forward slash forward slash
Function declaration
Int
Maximum
Underscore value
Open parenthesis
Int
Number
Underscore 1
Comma
Int
Number
Underscore 2
Close parenthesis
Semicolon
Int
Main
Open parenthesis
Close parenthesis
Open curly bracket
int x equal sign 25 semicolon int y equal sign 76 semicolon int ret underscore val semicolon
forward slash forward slash function called ret underscore val equal sign maximum underscore
value open parenthesis x comma y close parenthesis semicolon c out less than less than quote maximum
value equal sign quote less than less than ret underscore value less than less than end
l semicolon return zero semicolon close curly bracket forward slash forward slash function
definition int maximum underscore value open parenthesis int number underscore one comma
int number underscore two close parenthesis open curly bracket int max underscore val semicolon
if open parenthesis number underscore one greater than number underscore two close
parenthesis max underscore val equal sign number underscore one semicolon else max underscore
val equal sign number underscore two semicolon return max underscore val semicolon close curly
bracket the output of the code is shown in the image given below
a function can be called in three ways namely call by value reference and pointer all these
methods have been described below call by value when a variable is passed as parameter to the
function the system makes a copy of the value of the parameter and sends the same to the function
for processing the value of the parameter is not updated and hence the return value is the only
way you can check if any processing has occurred call by pointer in call by pointer the address of the parameter
is passed into the parameter of the function therefore any changes made to the value that this address holds
by the function concerned reflect in the variable's value in this manner multiple values can be returned
from the function indirectly one using the return statement and others by accessing the variables that have been manipulated
the default mode of operation and c++ is called by value that is the variable's original value is not
The default mode of operation in C++ is called by value, that is, the variable's original value is not manipulated by the called function.
Setting default values for parameters
C++ allows programmers to set default values for parameters of a function.
This is a particularly useful functionality in cases where function calls are made without the exact number of arguments.
If the corresponding parameter value is left blank by the calling function, the default value is used for processing.
Default values can be set for all parameters of the function using the assignment operator.
The sample implementation given below illustrates how default values can be set for function parameters.
Pound include less than iostream greater than using namespace std semicolon int add underscore vowel open parenthesis int x comma int y equal sign 5 close parenthesis open curly bracket int add underscore result semicolon add underscore result equal sign x plus y semicolon return open parenthesis
int main open parenthesis open parenthesis open curly bracket int x equal sign 10 semicolon int y equal sign 20 semicolon int ret underscore vowel semicolon ret underscore vowel equal sign add underscore vowel open parenthesis
c out less than equal sign CL tienen equal sign 10 semicolonitz hug Bronze
see out less than less than quote result when both values given colon quote less than less than
ret underscore val less than less than end l semicolon ret underscore val equal sign add
underscore val open parenthesis x close parenthesis semicolon see out less than less than quote result
when only x value given colon quote less than less than ret underscore val less than less than end l
semicolon return zero semicolon close curly bracket the output generated for this code is shown in the
image given below chapter 10 numbers the most fundamental entity that you will ever work with
or manipulate is numbers primitive data types like int float double long and short have been
provided for your use you can manipulate the range of numbers that a number data type can house by using
long short signed and unsigned keywords the sample implementation shown below defines the different
types of numbers that are available in c plus plus pound include less than io stream greater than
using namespace std semicolon int main open parenthesis close parenthesis open curly bracket
forward slash forward slash defining numbers int i semicolon double d semicolon short s semicolon float f
semicolon long l semicolon forward slash forward slash assigning values to numbers
numbers i equals equals one thousand semicolon i equal sign one thousand semicolon d equals
thirty thousand nine hundred forty nine point three seven four semicolon s equals
equals ten semicolon f equals two hundred and thirty point four seven semicolon l equals
 sumi colon l equals one million semicolon cout less than less than quote int colon quote less than less than
I less than less than
c.
out less than less than
double colon
d less than less than
end l
c.
out less than less than
short colon
less than less than
less than less than
end l
semicolon
c.
less than, less than, quote, float, colon, quote, less than, less than, f, less than,
less than, end l, semicolon, cout, less than, less than, quote, long, colon, quote, less
than, less than, l, less than, less than, end l, semicolon, return 0, semicolon, close
curly bracket.
The output for this code is shown in the image given below.
Performing Mathematical Functions Although you can write code for any mathematical function
that you wish to perform in your program, there are a set of functions that are provided as
part of the C++ library.
You can directly use them to get your work done without the hassle of coding them from scratch.
In order to use these functions, you will need to include the header file, less than, cmath,
greater than, in your program.
Some of the inbuilt functions include, double costs, open parenthesis, double, close parenthesis,
parenthesis.
This function returns the cosine of the angle provided as argument.
Double sine, open parenthesis, double, close parenthesis.
This function returns the sine of the angle provided as argument.
Double tan, open parenthesis, double, close parenthesis.
This function returns the tan of the angle provided as argument.
Double log, open parenthesis, double, close parenthesis.
This function returns the natural log of the number provided as argument.
Double pal, open parenthesis, double, comma, double, close parenthesis.
This function returns the value computed by putting first argument raised to the power corresponding
to the second argument.
Double hypot, open parenthesis, double, comma, double, close parenthesis.
This function returns the hypotenuse of a right triangle for which the two side lengths are
given in the arguments.
Double sqrt, open parenthesis, double, close parenthesis.
This function returns the square root of the number provided as argument.
Int abs, open parenthesis, int, close parenthesis.
This function returns the absolute value of the integer provided as argument.
Double fabs, open parenthesis, double, close parenthesis.
This function returns the absolute value of the decimal number provided as argument.
Double floor, open parenthesis, double, close parenthesis.
This function returns the integer lower than or equal to the number provided as argument.
The sample implementation given below demonstrates how these mathematical operations can be performed.
Pound include less than iostream greater than pound include less than cmath greater than using namespace std semicolon int main open parenthesis close parenthesis open curly bracket forward slash forward slash defining numbers int i equal sign int i equal sign minus 1000 semicolon double d equal sign 200
point 374 semicolon short s equal sign 10 semicolon float f equal sign 230 point 47 semicolon long l equal sign 100 000 semicolon forward slash forward slash performing mathematical operations c out less than less than quote pow open parenthesis d comma 2 close parenthesis

d comma 2 close parenthesis close parenthesis less than less than end il semicolon c out less than less than quote abs open parenthesis i close parenthesis colon quote less than less than abs open parenthesis nar
I
C out
LESS THAN LESS THAN
QUOTE
SINE
D
CLOSE PARENTHESY
COLON
QUOTE
LESS THAN LESS THAN
SINE
D
CLOSE PARENTHESY
LESS THAN LESS THAN
END L
SEMICOLON
C out
LESS THAN LESS THAN
QUOTE
LESS THAN LESS THAN
D
C out
LESS THAN LESS THAN
QUOTE
LESS THAN LESS THAN
CLOSE PARENTHESY
QOTE
LESS THAN LESS THAN
FLOR
.
The output of this code is shown in the image given below.
Random Numbers There may be scenarios where you might need
random number generation.
C++ provides two functions for this purpose, namely rand and srand.
The first function only returns a pseudo-random number, however, the problem can be fixed by
using srand.
The following implementation demonstrates how random numbers can be generated.
include less than iostream greater than
include less than ctime greater than
include less than cstdlib greater than
using namespace std
int main
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
at
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
int
y, equal sign, rand, open parenthesis, close parenthesis, semicolon, cout, less than less than, quote, generated random number, equal sign, quote, less than less than, y, less than less than, end l, semicolon, close curly bracket, return zero, semicolon, close curly bracket.
The output for this code has been shown in the image given below.
Chapter 11. Arrays
The concept of arrays comes from the standard concept of arrays and data structures, which described it as a collection of same-type elements.
C++ provides support for this data structure.
Arrays can be used to store data values or variables of the same type.
For instance, if you need five integer variables, then instead of declaring five different variables with names like num1, num2, num3, num4, and num5, you can simply declare an array with the name num5 and access variables as num open bracket 0, close bracket, num open bracket 1, close bracket, num open bracket 2, close bracket, num open bracket 3, close bracket, and num open bracket 4, close bracket.
The name of the array is num, while 0, 1, 2, 3, and 4 are indexes.
An element of the array is accessed by putting the index inside the square bracket that follow the name of the array.
The lowest address contains the first element, while the highest address contains the last element.
Declaring Arrays
In order to declare an array, you must specify the name of the array and the number of elements that this array is required to contain.
The syntax for declaring an array is as follows.
Data underscore type, array underscore name.
Open bracket, array underscore size, close bracket, semicolon.
Here, data underscore type is the data type, array underscore name is the name of the array that you wish to give,
and array size is the number of elements that the array is expected to have.
Since this array is just one row of elements, if you can imagine it to be such, this is a single dimension array.
Please note that the value of array underscore size must be greater than 0,
and the data underscore type must be a valid data type supported by C++.
In order to declare a double array with 10 elements of the name bow, you need the following declaration statement.
Double bow, open bracket, 10, close bracket, semicolon.
Initializing Arrays
Array values can be initialized at the time of declaration or later in the program, as per your convenience and needs.
If you wish to initialize the array at the time of declaration, then you will need to use a statement similar to the one given below.
Double bow, open bracket, 5, close bracket, equal sign, open curly bracket, 35.9, comma, 33.7, comma, 24.6, comma, 11.9, comma, 7.3, close curly bracket, semicolon.
It's important to realize here that the number of values that you give as part of the curly braces must never extend past the value specified in the square bracket.
You may alternatively use the following C++ for performing the same operation.
Double bow, open bracket, close bracket, equal sign, open curly bracket, 35.9, comma, 33.7, comma, 24.6, comma, 11.9, comma, 7.3, close curly bracket, semicolon.
This statement automatically assigns the size of 5 to the array.
When you initialize the array without specifying the size of the array, the system automatically assigns a size that is large enough to accommodate the mentioned elements.
The individual elements of the array can be accessed by specifying the index of the elements.
The first element gets the index 0, and the index for other elements after that is simply incremented by 1.
For example, the elements of the array declared above are as follows.
Bow 0 equals 35.9, bow 1 equals 33.7, bow 2 equals 24.6, bow 3 equals 11.9, bow 4 equals 7.3.
Individual assignments and reassignments can also be made by using statements like
Val, open bracket, 0, close bracket, equal sign, 0.0, semicolon.
Accessing elements of array.
Evidently, if you need to access the elements of the array, you just need to write the name of the array, followed by the index within square brackets.
A sample to show you how values of array elements can be assigned to other variables is given below.
Double my cell, equal sign, ball, open bracket, 0, close bracket, semicolon.
The statement given above will simply assign the value 0.0 to the variable my cell.
The following sample code summarizes all the concepts related to arrays and how they can be implemented in C++.
Int main, open parenthesis, close parenthesis, open curly bracket, forward slash, forward slash,
assigning values to array elements, for open parenthesis, int x, equal sign, 0, semicolon, x, less than 5, semicolon, x, plus plus, close parenthesis, open curly bracket, num, open bracket, x, close bracket, equal sign, x, plus 100, semicolon.
Close curly bracket, cout, less than, less than, quote, element, quote, less than, less than, set w, open parenthesis, 13, close parenthesis, less than, less than, quote, value, quote, less than, less than, end l, semicolon.
Keeper think in Rq.
bere HUGE
load
seems to have a little bit of error, per turn.
Civilizing
use
bit
nee
3
oland
4
ided
2
00
.
The output of the code can be seen in the image given below.
Although this discussion only includes the basics of arrays in C++, you can move on to
advanced topics like multidimensional arrays, pointer to arrays, and using arrays with functions.
Chapter 12 Strings
Apart from numbers and sets of numbers, the other category of elements that you can expect
to work a lot with is characters.
While we have already discussed characters and data types, this chapter elaborates on
strings.
C++ supports two forms of strings.
One of these forms represents strings in the form of character sequences.
On the other hand, C++ also has a class type for strings, which is a part of the standard
C++.
The former is known as C-style string, while the latter is a C++ addition.
We shall discuss both these forms in this chapter.
C-style strings
The C-style strings, as the name suggests, was a concept given in C, and C++ has inherited
the same, considering the fact that C++ is an enhanced version of C.
Typically, this type of a string is a character array that ends with the null character as
an indication of string termination.
Such a string is also referred to as null terminated string.
The C-style strings are usually declared and initialized in the following manner.
char
char
say hello
open bracket
6
close bracket
equal sign
open curly bracket
apostrophe
h
apostrophe
comma
apostrophe
l
apostrophe
comma
apostrophe
o
apostrophe
comma
apostrophe
backslash
o
apostrophe
close curly bracket
Therefore, if you wish to store a five-letter word in a C-style string, you will need a
character array of size 6, with the extra element required to store the null character.
You can alternatively also use the following statement for declaring and initializing the
array.
In order to demonstrate how these strings operate, let us look at the following example.
The output for this code is shown in the image given below.
There are a number of functions that you can use for manipulating C-style strings.
These functions include strcpy, open parenthesis, s1, comma, s2, close parenthesis.
This function copies the string given in s2 to the string character array pointed by s1.
strcat, open parenthesis, s1, comma, s2, close parenthesis.
This function concatenates the string given in s2 to the string pointed by s1.
strlin, open parenthesis, s, close parenthesis.
This function returns the length of the string.
strcmp, open parenthesis, s1, comma, s2, close parenthesis.
This function compares the string given in s2 to the string pointed by s1.
The value returned by the function is 0 if the two strings are equal.
strchr, open parenthesis, s, comma, ch, close parenthesis.
This function finds the character ch in the string s and returns a pointer to the first occurrence
of the same.
strstr, open parenthesis, s1, comma, s2, close parenthesis.
This function finds the string s2 in the string s1 and returns a pointer of the first occurrence
of the same.
string class.
C++ provides a string class that can be used to create strings by instantiating the class
and manipulating them as objects.
The following code demonstrates how string class can be used for string declaration, definition,
and manipulation.
% include less than, iostream greater than, % include less than, string greater than, using
namespace std semicolon, int main, open parenthesis, close parenthesis, open curly bracket.
string str underscore 1, equal sign, quote, my, quote, semicolon, string str underscore 2, equal
sign, quote, space, quote, semicolon, string str underscore 3, semicolon, int str lin, semicolon,
clst slash, forward slash, forward slash, copy str underscore 1 into str underscore 3, str
underscore 3, str underscore 3, equal sign, str underscore 1, semicolon, c out, less than,
// concatenate str-1 and str-2 str-3 equals str-1 plus str-2 semicolon c out less than less than quote str-1 plus str-2 colon quote less than less than str-3 less than less than end l semicolon
// determine the length of str-3 str-lin equal sign str-3 dot size open parenthesis close parenthesis semicolon c out less than less than quote str-3 dot size open parenthesis close parenthesis colon quote less than less than str-lin less than less than end l semicolon
return 0 semicolon close curly bracket the output generated for this code can be seen in the image given below
conclusion
C++ is a programming language that finds application in almost every domain and field
from drivers to user applications you name it and it can be created using C++
this is what makes C++ such an important programming language to learn and master
now that we have reached the end of this book you must be thorough with basic C++ concepts and programming
you are advised to take this knowledge forward and practice as many examples as you can
this will help you create a solid foundation for advanced C++ programming
we expect you to take the learning forward by graduating from these basics to advanced concepts in C++ programming
we hope this book has been helpful and beneficial to you we look forward to receiving any feedback on the book
this has been C++ learn C++ in two hours written by Cooper Alvin copyright 2018 by Felipe Guirao
production copyright 2018 by Felipe Guirao
audible hopes you have enjoyed this program
you
