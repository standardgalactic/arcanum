(K)
for some suitable K.
Theorem A.8. (Rieszâ€“Fischer) For every Hilbert space E, there is some nonempty set K
such that E is isomorphic to the Hilbert space ` 2
(K). More specifically, for any Hilbert basis
(uk)kâˆˆK of E, the maps f : `
2
(K) â†’ E and g : E â†’ ` 2
(K) defined such that
f ((Î»k)kâˆˆK) = X
kâˆˆK
Î»kuk and g(u) = ï¿¾ h u, uki /k ukk
2

kâˆˆK
= (ck)kâˆˆK,
are bijective linear isometries such that g â—¦ f = id and f â—¦ g = id.
Proof. By Proposition A.4 (1), the map f is well defined, and it is clearly linear. By Propoï¿¾sition A.2 (3), the map g is well defined, and it is also clearly linear. By Proposition A.2
(2b), we have
f(g(u)) = u =
X
kâˆˆK
ckuk,
2128 APPENDIX A. TOTAL ORTHOGONAL FAMILIES IN HILBERT SPACES
and by Proposition A.4 (1), we have
g(f ((Î»k)kâˆˆK)) = (Î»k)kâˆˆK,
and thus g â—¦ f = id and f â—¦ g = id. By Proposition A.4 (2), the linear map g is an isometry.
Therefore, f is a linear bijection and an isometry between ` 2
(K) and E, with inverse g.
Remark: The surjectivity of the map g : E â†’ ` 2
(K) is known as the Rieszâ€“Fischer theorem.
Having done all this hard work, we sketch how these results apply to Fourier series. Again
we refer the readers to Rudin [140] or Lang [111, 112] for a comprehensive exposition.
Let C(T) denote the set of all periodic continuous functions f : [âˆ’Ï€, Ï€] â†’ C with period
2Ï€. There is a Hilbert space L2
(T) containing C(T) and such that C(T) is dense in L2
(T),
whose inner product is given by
h
f, gi =
Z
Ï€
âˆ’Ï€
f(x)g(x)dx.
The Hilbert space L2
(T) is the space of Lebesgue square-integrable periodic functions (of
period 2Ï€).
It turns out that the family (e
ikx)kâˆˆZ is a total orthogonal family in L2
(T), because it is
already dense in C(T) (for instance, see Rudin [140]). Then the Rieszâ€“Fischer theorem says
that for every family (ck)kâˆˆZ of complex numbers such that
X
kâˆˆZ
|ck|
2 < âˆž,
there is a unique function f âˆˆ L
2
(T) such that f is equal to its Fourier series
f(x) = X
kâˆˆZ
cke
ikx
,
where the Fourier coefficients ck of f are given by the formula
ck =
1
2Ï€
Z
Ï€
âˆ’Ï€
f(t)e
âˆ’iktdt.
The Parseval theorem says that
+âˆžX
k=âˆ’âˆž
ckdk =
2
1
Ï€
Z
Ï€
âˆ’Ï€
f(t)g(t)dt
for all f, g âˆˆ L
2
(T), where ck and dk are the Fourier coefficients of f and g.
A.3. SUMMARY 2129
Thus, there is an isomorphism between the two Hilbert spaces L2
(T) and ` 2
(Z), which is
the deep reason why the Fourier coefficients â€œwork.â€ Theorem A.8 implies that the Fourier
series P kâˆˆZ
cke
ikx of a function f âˆˆ L
2
(T) converges to f in the L
2
-sense, i.e., in the meanï¿¾square sense. This does not necessarily imply that the Fourier series converges to f pointwise!
This is a subtle issue, and for more on this subject, the reader is referred to Lang [111, 112]
or Schwartz [152, 153].
We can also consider the set C([âˆ’1, 1]) of continuous functions f : [âˆ’1, 1] â†’ C. There is a
Hilbert space L2
([âˆ’1, 1]) containing C([âˆ’1, 1]) and such that C([âˆ’1, 1]) is dense in L2
([âˆ’1, 1]),
whose inner product is given by
h
f, gi =
Z
1
âˆ’1
f(x)g(x)dx.
The Hilbert space L2
([âˆ’1, 1]) is the space of Lebesgue square-integrable functions over [âˆ’1, 1].
The Legendre polynomials Pn(x) defined in Example 5 of Section 12.2 (Chapter 12). form a
Hilbert basis of L2
([âˆ’1, 1]). Recall that if we let fn be the function
fn(x) = (x
2 âˆ’ 1)n
,
Pn(x) is defined as follows:
P0(x) = 1, and Pn(x) = 1
2
nn!
f
(n)
n
(x),
where fn
(n)
is the nth derivative of fn. The reason for the leading coefficient is to get
Pn(1) = 1. It can be shown with much efforts that
Pn(x) = X
0â‰¤kâ‰¤n/2
(âˆ’1)k
2
n(n âˆ’
(2(
k
n
)!
âˆ’
k!(
k
n
))!
âˆ’ 2k)! x
nâˆ’2k
.
A.3 Summary
The main concepts and results of this chapter are listed below:
â€¢ Hilbert space
â€¢ Orthogonal family, total orthogonal family.
â€¢ Hilbert basis.
â€¢ Fourier coefficients.
â€¢ Hamel bases, Schauder bases.
â€¢ Fourier series.
2130 APPENDIX A. TOTAL ORTHOGONAL FAMILIES IN HILBERT SPACES
â€¢ Cauchy family, summable family.
â€¢ Bessel inequality.
â€¢ The Hilbert space ` 2
(K).
â€¢ Parseval identity.
â€¢ Zornâ€™s lemma.
â€¢ Rieszâ€“Fischer theorem.
â€¢ Legendre polynomials.
A.4 Problems
Problem A.1. Prove that the subspace consisting of sequences (zk)kâˆˆK such that zk = 0
except perhaps for finitely many k is a dense suspace of ` 2
(K).
Problem A.2. If V is any nonempty subset of E, prove that V
âŠ¥ is closed (even if V is not)
and that V
âŠ¥âŠ¥ is the closure of V (see the remarks following Proposition A.5).
Appendix B
Matlab Programs
B.1 Hard Margin (SVMh2)
The following Matlab programs implement the method described in Section 52.7.
The first program is the heart of the method; it implements ADMM for quadratic proï¿¾gramming.
function [x,u,nr,ns,k] = qsolve1(P, q, A, b, rho, tolr, tols, iternum)
% Solve a quadratic programming problem
% min (1/2) x^T P x + x^T q + r
% subject to Ax = b, x >= 0 using ADMM
% P n x n, q, r, in R^n, A m x n, b in R^m
% A of rank m
m = size(A,1); fprintf(â€™m = %d â€™,m)
n = size(P,1); fprintf(â€™ n = %d \nâ€™,n)
u = ones(n,1); u(1,1) = 0; % to initialize u
z = ones(n,1); % to initialize z
% iternum = maximum number of iterations;
% iternum = 80000 works well
k = 0; nr= 1; ns = 1;
% typically tolr = 10^(-10); tols = 10^(-10);
% Convergence is controlled by the norm nr of the primal residual r
% and the norm ns of the dual residual s
while (k <= iternum) && (ns > tols || nr > tolr)
z0 = z;
k = k+1;
% Makes KKT matrix
KK = [P + rho* eye(n) Aâ€™; A zeros(m,m)];
2131
2132 APPENDIX B. MATLAB PROGRAMS
% Makes right hand side of KKT equation
bb = [-q + rho*(z - u); b];
% Solves KKT equation
xx = KK\bb;
% update x, z, u (ADMM update steps)
x = xx(1:n);
z = poslin(x + u);
u = u + x - z;
% to test stopping criterion
r = x - z; % primal residual
nr = sqrt(râ€™*r); % norm of primal residual
s = rho*(z - z0); % dual residual
ns = sqrt(sâ€™*s); % norm of dual residual
end
end
The second program SBVMhard2 implements hard margin SVM (version 2).
function [lamb,mu,w] = SVMhard2(rho,u,v)
%
% Runs hard margin SVM version 2
%
% p green vectors u_1, ..., u_p in n x p array u
% q red vectors v_1, ..., v_q in n x q array v
%
% First builds the matrices for the dual program
%
p = size(u,2); q = size(v,2); n = size(u,1);
[A,c,X,Pa,qa] = buildhardSVM2(u,v);
%
% Runs quadratic solver
%
tolr = 10^(-10); tols = 10^(-10); iternum = 80000;
[lam,U,nr,ns,kk] = qsolve1(Pa, qa, A, c, rho, tolr, tols, iternum);
fprintf(â€™nr = %d â€™,nr)
fprintf(â€™ ns = %d \nâ€™,ns)
fprintf(â€™kk = %d \nâ€™,kk)
if kk > iternum
fprintf(â€™** qsolve did not converge. Problem not solvable ** \nâ€™)
end
w = -X*lam;
nw = sqrt(wâ€™*w); % norm of w
fprintf(â€™nw = %.15f \nâ€™,nw)
B.1. HARD MARGIN (SVMH2) 2133
delta = 1/nw;
fprintf(â€™delta = %.15f \nâ€™,delta)
if delta < 10^(-9)
fprintf(â€™** Warning, delta too small, program does not converge ** \nâ€™)
end
%
lamb = lam(1:p,1);
mu = lam(p+1:p+q,1);
b = 0;
tols = 10^(-10);
% tols < lambda_i; finds the nonzero lambda_i
[lambnz,numsvl1] = countmlu2(lamb,tols);
% tols < mu_i; finds the nonzero mu_j
[munz,numsvm1] = countmlv2(mu,tols);
fprintf(â€™numsvl1 = %d â€™,numsvl1)
fprintf(â€™ numsvm1 = %d \nâ€™,numsvm1)
if numsvl1 > 0 && numsvm1 > 0
sx1 = zeros(n,1); num1 = 0;
sx2 = zeros(n,1); num2 = 0;
for i = 1:p
if lambnz(i) > 0
sx1 = sx1 + u(:,i);
num1 = num1 + 1;
end
end
for j = 1:q
if munz(j) > 0
sx2 = sx2 + v(:,j);
num2 = num2 + 1;
end
end
b = (wâ€™*(sx1/num1 + sx2/num2))/2;
fprintf(â€™b = %.15f \nâ€™,b)
else
fprintf(â€™** Not enough support vectors ** \nâ€™)
end
if n == 2
[ll,mm] = showdata(u,v);
if numsvl1 > 0 && numsvm1 > 0
showSVMs2(w,b,1,ll,mm,nw)
2134 APPENDIX B. MATLAB PROGRAMS
end
end
end
The function buildhardSVM2 builds the constraint matrix and the matrices defining the
quadratic functional.
function [A,c,X,Xa,q] = buildhardSVM2(u,v)
% builds the matrix of constraints A for
% hard SVM h2, and the right hand side c
% Aso builds X and Xa = Xâ€™*X, and the vector q = -1_{p+q}
% for the linear part of the quadratic function
% The right-hand side is c = 0 (Ax = 0).
p = size(u,2); q = size(v,2);
A = [ones(1,p) -ones(1,q)];
c = 0;
X = [-u v];
Xa = Xâ€™*X;
q = -ones(p+q,1);
end
The function countmlu2 returns a vector consisting of those Î»i such that Î»i > 0, and the
number of such Î»i
.
function [lambnz, mlu] = countmlu2(lambda,tols)
% Counts the number of points u_i (in u)
% such that lambda_i > 0 and returns a vector
% of these lambda_i
% tols = 10^(-11);
p = size(lambda,1); lambnz = zeros(p,1);
mlu = 0;
for i = 1:p
if lambda(i) > tols
mlu = mlu + 1;
lambnz(i) = lambda(i);
end
end
end
The function countmlv2 returns a vector consisting of those Âµj such that Âµj > 0, and
the number of such Âµj
. It is similar to countmlu2. Here a judicious choice of tols is crucial
and one has to experiment with various values.
B.2. SOFT MARGIN SVM (SVMS2
0 ) 2135
The function showdata displays the data points (the ui and the vj ) and the function
showSVMs2 displays the separating line and the two margin lines.
function showSVMs2(w,b,eta,ll,mm,nw)
%
% Function to display the result of running SVM
% on p blue points u_1, ..., u_p in u
% and q red points v_1, ..., v_q in v
l = makeline(w,b,ll,mm,nw); % makes separating line
lm1 = makeline(w,b+eta,ll,mm,nw); % makes blue margin line
lm2 = makeline(w,b-eta,ll,mm,nw); % makes red margin line
plot(l(1,:),l(2,:),â€™-mâ€™,â€™LineWidthâ€™,1.2) % plots separating line
plot(lm1(1,:),lm1(2,:),â€™-bâ€™,â€™LineWidthâ€™,1.2) % plots blue margin line
plot(lm2(1,:),lm2(2,:),â€™-râ€™,â€™LineWidthâ€™,1.2) % plots red margin line
hold off
end
Actually, implementing the above function is not entirely trivial. It is necessary to write a
function makeline to plot the line segment which is part of the line of equation w1x+w2y = b
inside a box containing the data points. We leave the details an exercises.
B.2 Soft Margin SVM (SVMs2
0
)
The following Matlab programs implement the method described in Section 54.8.
The function doSVMs2pbv3 calls the function solve1 given in Section 52.7.
function [lamb,mu,alpha,beta,lambnz,munz,numsvl1,numsvm1,badnu,w,nw,b,eta]
= doSVMs2pbv3(nu,rho,u,v,K)
%
% Best version
% Uses the duality gap to compute eta
% In principle, needs a single support vector of type 1
%
% Soft margin nu-SVM version s2â€™
% with the constraint
% \sum_{i = 1}^p + \sum_{j = 1}^q mu_j = K_m
% (without the variable gamma)
%
% p green vectors u_1, ..., u_p in n x p array u
% q red vectors v_1, ..., v_q in n x q array v
2136 APPENDIX B. MATLAB PROGRAMS
%
% First builds the matrices for the dual program
% K is a scale factor
%
p = size(u,2); q = size(v,2); n = size(u,1);
[A,c,X,Pa,qa] = buildSVMs2pb(nu,u,v,K);
%
% Runs quadratic solver
%
tolr = 10^(-10); tols = 10^(-10); iternum = 80000;
[x,U,nr,ns,kk] = qsolve1(Pa, qa, A, c, rho, tolr, tols, iternum);
fprintf(â€™nr = %d â€™,nr)
fprintf(â€™ ns = %d \nâ€™,ns)
fprintf(â€™kk = %d \nâ€™,kk)
noconv = 0;
if kk > iternum
noconv = 1;
fprintf(â€™** qsolve did not converge. Problem not solvable ** \nâ€™)
end
lam = x(1:(p+q),1);
alpha = x((p+q+1):2*p+q,1);
beta = x(2*p+q+1:2*(p+q),1);
w = -X*lam;
nw = sqrt(wâ€™*w); % norm of w
fprintf(â€™nw = %d \nâ€™,nw)
%
lamb = x(1:p,1);
mu = x(p+1:p+q,1);
tols = 10^(-10); tolh = 10^(-9);
% tols < lambda_i < K - tolh
[lambnz,numsvl1] = findpsv2(lamb,K,tols,tolh);
% tols < mu_i < K - tolh
[munz,numsvm1] = findpsv2(mu,K,tols,tolh);
fprintf(â€™numsvl1 = %d â€™,numsvl1)
fprintf(â€™ numsvm1 = %d \nâ€™,numsvm1)
% lambda_i >= K - tolh
[lamK,pf] = countumf2(lamb,K,tolh); % number of blue margin failures
% mu_j >= K - tolh
[muK,qf] = countvmf2(mu,K,tolh); % number of red margin failures
fprintf(â€™pf = %d â€™,pf)
fprintf(â€™ qf = %d \nâ€™,qf)
[~,pm] = countmlu2(lamb,tols); % number of points such that lambda_i > tols
B.2. SOFT MARGIN SVM (SVMS2
0 ) 2137
[~,qm] = countmlv2(mu,tols); % number of points such that mu_i > 0
fprintf(â€™pm = %d â€™,pm)
fprintf(â€™ qm = %d \nâ€™,qm)
fprintf(â€™p - pm = %d â€™,p - pm)
fprintf(â€™ q - qm = %d \nâ€™,q - qm)
lnu = max(2*pf/(p+q),2*qf/(p+q)); unu = min(2*pm/(p+q),2*qm/(p+q));
fprintf(â€™lnu = %d â€™,lnu)
fprintf(â€™ unu = %d \nâ€™,unu)
if nu < lnu
fprintf(â€™** Warning; nu is too small ** \nâ€™)
else
if nu > unu
fprintf(â€™** Warning; nu is too big ** \nâ€™)
end
end
sx1 = zeros(n,1); num1 = 0;
sKu = zeros(n,1); Knum1 = 0;
for i = 1:p
if lambnz(i) > 0
sx1 = sx1 + u(:,i);
num1 = num1 + 1;
end
if lamK(i) > 0
sKu = sKu + u(:,i);
Knum1 = Knum1 + 1;
end
end
% Knum1
sx2 = zeros(n,1); num2 = 0;
sKv = zeros(n,1); Knum2 = 0;
for j = 1:q
if munz(j) > 0
sx2 = sx2 + v(:,j);
num2 = num2 + 1;
end
if muK(j) > 0
sKv = sKv + v(:,j);
Knum2 = Knum2 + 1;
end
end
% Knum2
2138 APPENDIX B. MATLAB PROGRAMS
b = 0; eta = 0;
epsilon = 0; xi = 0;
P2 = Xâ€™*X;
badnu = 0;
if numsvl1 > 0
if numsvm1 > 0
b = (wâ€™*(sx1/num1 + sx2/num2))/2;
fprintf(â€™b = %.15f \nâ€™,b)
eta = (wâ€™*(sx1/num1 - sx2/num2))/2;
fprintf(â€™eta = %.15f \nâ€™,eta)
else
errterm = wâ€™*(sKv - sKu) + (pf - qf)*wâ€™*(sx1/num1);
Pterm = (1/K)*(lamâ€™*P2*lam);
denomqf = (p+q)*nu -2*qf;
fprintf(â€™denomqf = %.15f \nâ€™,denomqf)
if denomqf > 0
eta = (errterm + Pterm)/denomqf;
fprintf(â€™eta = %.15f \nâ€™,eta)
b = -eta + wâ€™*sx1/num1;
else
badnu = 1;
fprintf(â€™** Warning: numsvl1 > 0, numsvm1 = 0 and nu = 2*qf/(p+q) ** \nâ€™)
end
end
else
if numsvm1 > 0
errterm = wâ€™*(sKv - sKu) + (pf - qf)*wâ€™*(sx2/num2);
Pterm = (1/K)*(lamâ€™*P2*lam);
denompf = (p+q)*nu -2*pf;
fprintf(â€™denompf = %.15f \nâ€™,denompf)
if denompf > 0
eta = (errterm + Pterm)/denompf;
fprintf(â€™eta = %.15f \nâ€™,eta)
b = eta + wâ€™*sx2/num2;
else
badnu = 1;
fprintf(â€™** Warning: numsvm1 > 0, numsvl1 = 0 and nu = 2*pf/(p+q) ** \nâ€™)
end
else
fprintf(â€™** Not enough support vectors ** \nâ€™)
end
B.2. SOFT MARGIN SVM (SVMS2
0 ) 2139
end
Km = (p+q)*nu*K;
fprintf(â€™K = %.15f â€™,K)
fprintf(â€™ (p+q)*nu*Ks/2 = %.15f \nâ€™,Km/2)
fprintf(â€™sum(lambda) = %.15f â€™,sum(lamb))
fprintf(â€™ sum(mu) = %.15f \nâ€™,sum(mu))
if (numsvl1 > 0 || numsvm1 > 0) && badnu == 0
if eta < 10^(-9)
fprintf(â€™** Warning, eta too small or negative ** \nâ€™)
eta = 0;
end
delta = eta/nw;
fprintf(â€™delta = %.15f \nâ€™,delta)
tolxi = 10^(-10);
% tols < lambda_i < K - tolh or K - tolh <= lambda_i and epsilon_i < tolxi
[lamsv,psf,epsilon] = findsvl2(lamb,w,b,u,eta,K,tols,tolh,tolxi);
% tols < mu_i < K - tolh or K - tolh <= mu_i and xi_i < tolxi
[musv,qsf,xi] = findsvm2(mu,w,b,v,eta,K,tols,tolh,tolxi);
fprintf(â€™psf = %d â€™,psf)
fprintf(â€™ qsf = %d \nâ€™,qsf)
fprintf(â€™pf - psf = %d â€™,pf - psf)
fprintf(â€™ qf - qsf = %d \nâ€™,qf - qsf)
% computes eta from the duality gap
errterm = wâ€™*(sKv - sKu) + (pf - qf)*b;
Pterm = (1/K)*(lamâ€™*P2*lam);
denom = (p+q)*nu - pf -qf;
fprintf(â€™denom = %.15f \nâ€™,denom)
if denom > 0
eta1 = (errterm + Pterm)/denom;
fprintf(â€™eta1 = %.15f \nâ€™,eta1)
end
end
end
The constraint matrix and the matrices defining the quadratic program are constructed
by the function buildSVMs2pb.
function [A,c,X,Pa,q] = buildSVMs2pb(nu,u,v,K)
% builds the matrix of constraints A for
% soft margin nu-SVM s2â€™
2140 APPENDIX B. MATLAB PROGRAMS
% with the constraint
% \sum_{i = 1}^p + \sum_{j = 1}^q mu_j = K_m
% (without the variable gamma) and the right-hand side c
% u: vector of p blue points (each an n-dim vector)
% v: vector of q red points (each an n-dim vector)
% builds the matrix X = [-u_1 ... -u_p v1 .... v_q]
% and the matrix Pa as 2(p+q) matrix obtained
% by augmenting Xâ€™*X with zeros
% K is a scale factor (K = Ks)
p = size(u,2); q = size(v,2);
% Ks = 1/(p+q);
Ks = K; Km = (p+q)*K*nu;
A = [ones(1,p) -ones(1,q) zeros(1,p+q);
ones(1,p) ones(1,q) zeros(1,p+q) ;
eye(p) zeros(p,q) eye(p) zeros(p,q);
zeros(q,p) eye(q) zeros(q,p) eye(q) ];
c = [0; Km; Ks*ones(p+q,1)];
X = [-u v];
XX = Xâ€™*X;
Pa = [XX zeros(p+q,p+q); zeros(p+q, 2*(p+q))];
q = zeros(2*(p+q),1);
end
The function findpsv2 makes a vector of Î»i (and Âµj ) corresponding to support vectors
of type 1.
function [lampsv,num] = findpsv2(lambda,K,tols,tolh)
%
% This function find the vector of
% lambda_iâ€™s such that 0 < lambda_i < K
% and the number of such lambda_i.
%
% tols = 10^(-11); % the smaller this is, the larger the number of
% points on the margin
% tolh = 10^(-9); %
m = size(lambda,1); lampsv = zeros(m,1);
num = 0;
for i = 1:m
if lambda(i) > tols && lambda(i) < K - tolh
lampsv(i) = lambda(i);
num = num + 1;
end
B.2. SOFT MARGIN SVM (SVMS2
0 ) 2141
end
end
The function countumf2 finds those Î»i such that Î»i = K.
function [lamK,mf] = countumf2(lambda,K,tolh)
% Counts the number of margin failures, that is,
% points u_i (in u) such that lambda_i = K
p = size(lambda,1);
mf = 0; lamK = zeros(p,1);
for i = 1:p
if lambda(i) >= K - tolh
mf = mf + 1;
lamK(i) = lambda(i);
end
end
end
Similarly, the function countvmf2 finds those Âµj such that Âµj = K.
The function countmlu2 finds those Î»i such that Î»i > 0.
function [lambnz, mlu] = countmlu2(lambda,tols)
% Counts the number of points u_i (in u)
% such that lambda_i > 0 and returns a vector
% of these lambda_i
% tols = 10^(-11);
p = size(lambda,1); lambnz = zeros(p,1);
mlu = 0;
for i = 1:p
if lambda(i) > tols
mlu = mlu + 1;
lambnz(i) = lambda(i);
end
end
end
Similarly, the function countmlv2 finds those Âµj such that Âµj > 0. The function findsvl2
finds the Î»i corresponding to blue support vectors of type 1 and 2 and the error vector  .
The number of blue errors is psf (the ui
for which  i > 0). Similarly the function findsvm2
finds the Âµj corresponding to red support vectors of type 1 and 2 and the error vector Î¾.
The number of red errors is qsf (the vj
for which Î¾j > 0).
2142 APPENDIX B. MATLAB PROGRAMS
The main function runSVMs2pbv3 calls doSVMs2pbv3 and displays the separating line (or
plane) and the two margin lines (or planes).
function [lamb,mu,alpha,beta,lambnz,munz,w] = runSVMs2pbv3(nu,rho,u,v,K)
%
% Best version
% Uses the duality gap to compute eta
% In principle, needs a single support vector of type 1
%
% Runs soft margin nu-SVM version s2â€™
% with the constraint
% \sum_{i = 1}^p + \sum_{j = 1}^q mu_j = K_m
% (without the variable gamma)
%
% p green vectors u_1, ..., u_p in n x p array u
% q red vectors v_1, ..., v_q in n x q array v
%
% First builds the matrices for the dual program
% K is a scale factor
%
p = size(u,2); q = size(v,2); n = size(u,1);
[lamb,mu,alpha,beta,lambnz,munz,numsvl1,numsvm1,badnu,w,nw,b,eta]
= doSVMs2pbv3(nu,rho,u,v,K);
if n == 2
[ll,mm] = showdata(u,v);
if (numsvl1 > 0 || numsvm1 > 0) && badnu == 0
showSVMs2(w,b,eta,ll,mm,nw)
end
else
if n == 3
showpointsSVM(u,v)
if (numsvl1 > 0 || numsvm1 > 0) && badnu == 0
offset = 10;
C1 = [1 0 1]; % magenta
plotplaneSVM(u,v,w,b,offset,C1)
C2 = [0 0 1]; % blue
plotplaneSVM(u,v,w,b+eta,offset,C2)
C3 = [1,0,0]; % red
plotplaneSVM(u,v,w,b-eta,offset,C3)
end
axis equal
B.3. SOFT MARGIN SVM (SVMS3) 2143
view([-1 -1 1]);
xlabel(â€™Xâ€™,â€™fontsizeâ€™,14);ylabel(â€™Yâ€™,â€™fontsizeâ€™,14);
zlabel(â€™Zâ€™,â€™fontsizeâ€™,14);
hold off
end
end
end
B.3 Soft Margin SVM (SVMs3)
The following Matlab programs implement the method described in Section 54.12. The main
function doSVMs3b is given below.
function [lamb,mu,alpha,beta,lambnz,munz,lamK,muK,w,b,eta,nw,fail]
= doSVMs3b (nu,rho,u,v,K)
%
% Soft margin nu-SVM version s3
%
% Computes eta using the duality gap
% Needs a single support vector of type 1
%
% p green vectors u_1, ..., u_p in n x p array u
% q red vectors v_1, ..., v_q in n x q array v
%
% First builds the matrices for the dual program
% K is a scale factor
%
p = size(u,2); q = size(v,2); n = size(u,1);
[A,c,X,P2,Pa,qa] = buildSVMs3b (nu,u,v,K);
%
% Runs quadratic solver
%
tolr = 10^(-10); tols = 10^(-10); iternum = 80000;
[x,U,nr,ns,kk] = qsolve1(Pa, qa, A, c, rho, tolr, tols, iternum);
fprintf(â€™nr = %d â€™,nr)
fprintf(â€™ ns = %d â€™,ns)
fprintf(â€™ kk = %d \nâ€™,kk)
noconv = 0;
if kk > iternum
noconv = 1;
fprintf(â€™** qsolve did not converge. Problem not solvable ** \nâ€™)
end
2144 APPENDIX B. MATLAB PROGRAMS
lam = x(1:(p+q),1);
alpha = x((p+q+1):2*p+q,1);
beta = x(2*p+q+1:2*(p+q),1);
w = -X*lam;
nw = sqrt(wâ€™*w); % norm of w
fprintf(â€™nw = %d \nâ€™,nw)
lamb = x(1:p,1);
mu = x(p+1:p+q,1);
b = -(sum(lamb) - sum(mu));
fprintf(â€™b = %.15f \nâ€™,b)
%
tols = 10^(-10); tolh = 10^(-9);
% tols < lambda_i < K - tolh
[lambnz,numsvl1] = findpsv2(lamb,K,tols,tolh);
% tols < mu_i < K - tolh
[munz,numsvm1] = findpsv2(mu,K,tols,tolh);
fprintf(â€™numsvl1 = %d â€™,numsvl1)
fprintf(â€™ numsvm1 = %d \nâ€™,numsvm1)
% lambda_i >= K - tolh
[lamK,pf] = countumf2(lamb,K,tolh); % number of blue margin failures
% mu_j >= K - tolh
[muK,qf] = countvmf2(mu,K,tolh); % number of red margin failures
fprintf(â€™pf = %d â€™,pf)
fprintf(â€™ qf = %d \nâ€™,qf)
[~,pm] = countmlu2(lamb,tols); % number of points such that lambda_i > tols
[~,qm] = countmlv2(mu,tols); % number of points such that mu_i > 0
fprintf(â€™pm = %d â€™,pm)
fprintf(â€™ qm = %d \nâ€™,qm)
fprintf(â€™p - pm = %d â€™,p - pm)
fprintf(â€™ q - qm = %d \nâ€™,q - qm)
lnu = (pf + qf)/(p+q); unu = (pm + qm)/(p+q);
fprintf(â€™lnu = %d â€™,lnu)
fprintf(â€™ unu = %d \nâ€™,unu)
if nu < lnu
fprintf(â€™** Warning; nu is too small ** \nâ€™)
else
if nu > unu
fprintf(â€™** Warning; nu is too big ** \nâ€™)
end
end
B.3. SOFT MARGIN SVM (SVMS3) 2145
sx1 = zeros(n,1); num1 = 0;
sKu = zeros(n,1); Knum1 = 0;
for i = 1:p
if lambnz(i) > 0
sx1 = sx1 + u(:,i);
num1 = num1 + 1;
end
if lamK(i) > 0
sKu = sKu + u(:,i);
Knum1 = Knum1 + 1;
end
end
% Knum1
sx2 = zeros(n,1); num2 = 0;
sKv = zeros(n,1); Knum2 = 0;
for j = 1:q
if munz(j) > 0
sx2 = sx2 + v(:,j);
num2 = num2 + 1;
end
if muK(j) > 0
sKv = sKv + v(:,j);
Knum2 = Knum2 + 1;
end
end
% Knum2
% computes eta from the duality gap
errterm = wâ€™*(sKv - sKu) + (pf - qf)*b;
Pterm = (1/K)*(lamâ€™*P2*lam);
denom = (p+q)*nu - pf -qf;
fprintf(â€™denom = %.15f \nâ€™,denom)
epsilon = 0; xi = 0;
if denom > 0
eta = (errterm + Pterm)/denom;
fprintf(â€™eta = %.15f \nâ€™,eta)
if eta < 10^(-10)
fprintf(â€™** Warning; eta is too small or negative ** \nâ€™)
end
tolxi = 10^(-10);
% tols < lambda_i < K - tolh or K - tolh <= lambda_i and epsilon_i < tolxi
[lamsv,psf,epsilon] = findsvl2(lamb,w,b,u,eta,K,tols,tolh,tolxi);
2146 APPENDIX B. MATLAB PROGRAMS
% tols < mu_i < K - tolh or K - tolh <= mu_i and xi_i < tolxi
[musv,qsf,xi] = findsvm2(mu,w,b,v,eta,K,tols,tolh,tolxi);
fprintf(â€™psf = %d â€™,psf)
fprintf(â€™ qsf = %d \nâ€™,qsf)
fprintf(â€™pf - psf = %d â€™,pf - psf)
fprintf(â€™ qf - qsf = %d \nâ€™,qf - qsf)
else
eta = 0;
denom = 0;
fprintf(â€™** Warning, nu = (pf + qf)/(p+q) ** \nâ€™)
end
Km = (p+q)*nu*K;
fprintf(â€™K = %.15f â€™,K)
fprintf(â€™ (p+q)*nu*Ks = %.15f \nâ€™,Km)
fprintf(â€™sum(lambda) + sum(mu)= %.15f \nâ€™,sum(lamb) + sum(mu))
eta1 = 0;
if numsvl1 > 0 || numsvm1 > 0
if numsvl1 > numsvm1
eta1 = wâ€™*sx1/num1 - b;
else
eta1 = b - wâ€™*sx2/num2;
end
fprintf(â€™eta1 = %.15f \nâ€™,eta1)
else
fprintf(â€™** Warning: not enough support vectors ** \nâ€™)
end
if denom == 0
if numsvl1 > 0 || numsvm1 > 0
eta = eta1;
fail = 0;
else
fail = 1;
fprintf(â€™** Warning, denom = 0 and not enough support vectors ** \nâ€™)
end
else
fail = 0;
end
end
The main function doSVMs3b is executed by the following function:
B.3. SOFT MARGIN SVM (SVMS3) 2147
function [lamb,mu,alpha,beta,lambnz,munz,w] = runSVMs3b(nu,rho,u,v,K)
%
% Runs soft margin nu-SVM version s3
%
% Computes eta using the duality gap
% Needs a single support vector of type 1
%
% p green vectors u_1, ..., u_p in n x p array u
% q red vectors v_1, ..., v_q in n x q array v
%
% First builds the matrices for the dual program
% K is a scale factor
%
p = size(u,2); q = size(v,2); n = size(u,1);
[lamb,mu,alpha,beta,lambnz,munz,lamK,muK,w,b,eta,nw,fail]
= doSVMs3b(nu,rho,u,v,K);
if n == 2
[ll,mm] = showdata(u,v);
if fail == 0
showSVMs2(w,b,eta,ll,mm,nw)
end
else
if n == 3
showpointsSVM(u,v)
if fail == 0
offset = 10;
C1 = [1 0 1]; % magenta
plotplaneSVM(u,v,w,b,offset,C1)
C2 = [0 0 1]; % blue
plotplaneSVM(u,v,w,b+eta,offset,C2)
C3 = [1,0,0]; % red
plotplaneSVM(u,v,w,b-eta,offset,C3)
end
axis equal
% axis([ll(1) mm(1) ll(2) mm(2)]);
view([-1 -1 1]);
xlabel(â€™Xâ€™,â€™fontsizeâ€™,14);ylabel(â€™Yâ€™,â€™fontsizeâ€™,14);zlabel(â€™Zâ€™,
â€™fontsizeâ€™,14);
hold off
end
2148 APPENDIX B. MATLAB PROGRAMS
end
end
The function buildSVMs3b builds the constraint matrix and the matrices defining the
quadratic program.
function [A,c,X,P2,Pa,q] = buildSVMs3b(nu,u,v,K)
% builds the matrix of constraints A for
% soft margin nu-SVM s3 and the right-hand side c
% u: vector of p blue points (each an n-dim vector)
% v: vector of q red points (each an n-dim vector)
% builds the matrix X = [-u_1 ... -u_p v1 .... v_q]
% and the matrix Xa as 2(p+q) matrix obtained
% by augmenting Xâ€™*X with zeros
% K is a scale factor (K = Ks)
p = size(u,2); q = size(v,2);
% Ks = 1/(p+q);
Ks = K; Km = (p+q)*K*nu;
A = [ones(1,p) ones(1,q) zeros(1,p+q) ;
eye(p) zeros(p,q) eye(p) zeros(p,q);
zeros(q,p) eye(q) zeros(q,p) eye(q) ];
c = [Km; Ks*ones(p+q,1)];
X = [-u v];
XX1 = Xâ€™*X;
XX2 = [ones(p,1)*ones(p,1)â€™ -ones(p,1)*ones(q,1)â€™;
-ones(q,1)*ones(p,1)â€™ ones(q,1)*ones(q,1)â€™];
P2 = XX1 + XX2;
Pa = [P2 zeros(p+q,p+q); zeros(p+q, 2*(p+q))];
q = zeros(2*(p+q),1);
end
B.4 Î½-SV Regression
g The main function donuregb is given below.
function
[lamb,mu,alpha,beta,lambnz,munz,lamK,muK,numsvl1,numsvm1,w,epsilon,b]
= donuregb (rho,nu,X,y,C)
%
% Soft margin nu-regression
% with the constraint
% \sum_{i = 1}^m + \sum_{j = 1}^m mu_j = C nu
B.4. Î½-SV REGRESSION 2149
% (Without the variable gamma)
%
% Input: an m x n matrix of data points represented as
% as the rows of X, and y a vector in R^n
%
% First builds the matrices for the dual program
% C is a scale factor
%
m = size(X,1); n = size(X,2);
[A,c,P,Pa,qa] = buildnuregb(nu,X,y,C);
%
% Runs quadratic solver
%
tolr = 10^(-10); tols = 10^(-10); iternum = 80000;
[x,U,nr,ns,kk] = qsolve1(Pa, qa, A, c, rho, tolr, tols, iternum);
% fprintf(â€™nr = %d â€™,nr)
% fprintf(â€™ ns = %d \nâ€™,ns)
fprintf(â€™nr = %dâ€™,nr)
fprintf(â€™ ns = %dâ€™,ns)
fprintf(â€™ kk = %d \nâ€™,kk)
noconv = 0;
if kk > iternum
noconv = 1;
fprintf(â€™** qsolve did not converge. Problem not solvable ** \nâ€™)
end
lamb = x(1:m,1);
mu = x(m+1:2*m,1);
alpha = x((2*m+1):3*m,1);
beta = x(3*m+1:4*m,1);
w = Xâ€™*(mu - lamb);
%
b = 0; epsilon = 0;
tols = 10^(-10); tolh = 10^(-9);
% tols < lambda_i < C/m - tolh
[lambnz,numsvl1] = findpsv2(lamb,C/m,tols,tolh);
% tols < mu_i < C/m - tolh
[munz,numsvm1] = findpsv2(mu,C/m,tols,tolh);
fprintf(â€™numsvl1 = %dâ€™,numsvl1)
fprintf(â€™ numsvm1 = %d \nâ€™,numsvm1)
% lambda_i >= C/m - tolh
[lamK,pf] = countumf2(lamb,C/m,tolh); % number of blue margin failures
% mu_j >= C/m - tolh
2150 APPENDIX B. MATLAB PROGRAMS
[muK,qf] = countvmf2(mu,C/m,tolh); % number of red margin failures
fprintf(â€™pf = %dâ€™,pf)
fprintf(â€™ qf = %d \nâ€™,qf)
[~,pm] = countmlu2(lamb,tols); % number of points such that lambda_i > tols
[~,qm] = countmlv2(mu,tols); % number of points such that mu_i > 0
fprintf(â€™pm = %dâ€™,pm)
fprintf(â€™ qm = %d \nâ€™,qm)
% lambda_i <= tols
[lmz,nz] = countLzero(lamb,mu,tols);
pm2 = numsvl1 + pf; qm2 = numsvm1 + qf;
fprintf(â€™pm2 = %dâ€™,pm2)
fprintf(â€™ qm2 = %d \nâ€™,qm2)
lnu = max(2*pf/m,2*qf/m); unu = min(2*pm/m,2*qm/m);
fprintf(â€™lnu = %dâ€™,lnu)
fprintf(â€™ unu = %d \nâ€™,unu)
fprintf(â€™nz = %d \nâ€™,nz)
if nu < lnu
fprintf(â€™** Warning; nu is too small ** \nâ€™)
else
if nu > unu
fprintf(â€™** Warning; nu is too big ** \nâ€™)
end
end
fprintf(â€™C/m = %.15f â€™,C/m)
fprintf(â€™ (C nu)/2 = %.15f \nâ€™,(C*nu)/2)
fprintf(â€™sum(lambda) = %.15f â€™,sum(lamb))
fprintf(â€™ sum(mu) = %.15f \nâ€™,sum(mu))
lamsv = 0; musv = 0; xi = 0; xip = 0;
if numsvl1 > 0 && numsvm1 > 0
sx1 = zeros(n,1); sy1 = 0; num1 = 0;
sx2 = zeros(n,1); sy2 = 0; num2 = 0;
for i = 1:m
if lambnz(i) > 0
sx1 = sx1 + X(i,:)â€™; sy1 = sy1 + y(i);
num1 = num1 + 1;
end
if munz(i) > 0
sx2 = sx2 + X(i,:)â€™; sy2 = sy2 + y(i);
num2 = num2 + 1;
end
end
B.4. Î½-SV REGRESSION 2151
% num1
% num2
b = (sy1/num1 + sy2/num2 - wâ€™*(sx1/num1 + sx2/num2))/2;
fprintf(â€™b = %.15f \nâ€™,b)
epsilon = (wâ€™*(sx1/num1 - sx2/num2) + sy2/num2 - sy1/num1)/2;
fprintf(â€™epsilon = %.15f \nâ€™,epsilon)
if epsilon < 10^(-10)
fprintf(â€™** Warning; epsilon is too small or negative ** \nâ€™)
end
nw = sqrt(wâ€™*w); % norm of w
fprintf(â€™nw = %.15f \nâ€™,nw)
%
tolxi = 10^(-10);
% tols < lambda_i < C/m - tolh or C/m - tolh <= lambda_i and xi_i < tolxi
[lamsv,psf,xi] = findnuregsvl2(lamb,w,b,X,y,epsilon,C/m,tols,tolh,tolxi);
% tols < mu_i < C/m - tolh or C/m - tolh <= mu_i and xi_iâ€™ < tolxi
[musv,qsf,xip] = findnuregsvm2(mu,w,b,X,y,epsilon,C/m,tols,tolh,tolxi);
fprintf(â€™psf = %d â€™,psf)
fprintf(â€™ qsf = %d \nâ€™,qsf)
