0 ‚àà ‚àÇf(xe) + A
> Œª. e (‚àó3)
From (‚àó2) and (‚àó3), we obtain
0 ‚àà ‚àÇf(xe) + ‚àÇg(ze) + A
> Œªe + B
> Œª. e (‚àó4)
52.4. CONVERGENCE OF ADMM ~ 1885
But (‚àó1) and (‚àó4) are exactly the KKT equations, and by Theorem 51.41, we conclude that
x, e z, e Œªe are optimal solutions.
Step 9 . Prove (A1). This is the most tedious step of the proof. We begin by adding up
(A2) and (A3), and then perform quite a bit or rewriting and manipulation. The complete
derivation can be found in Boyd et al. [28].
Remarks:
(1) In view of Theorem 51.42, we could replace Assumption (3) by the slightly stronger
assumptions that the optimum value of our program is finite and that the constraints
are qualified. Since the constraints are affine, this means that there is some feasible
solution in relint(dom(f)) ‚à© relint(dom(g)). These assumptions are more practical
than Assumption (3).
(2) Actually, Assumption (3) implies Assumption (2). Indeed, we know from Theorem
51.41 that the existence of a saddle point implies that our program has a finite optimal
solution. However, if either A> A or B> B is not invertible, then Program (P) may not
have a finite optimal solution, as shown by the following counterexample.
Example 52.5. Let
f(x, y) = x, g(z) = 0, y ‚àí z = 0.
Then
LœÅ(x, y, z, Œª) = x + Œª(y ‚àí z) + (œÅ/2)(y ‚àí z)
2
,
but minimizing over (x, y) with z held constant yields ‚àí‚àû, which implies that the
above program has no finite optimal solution. See Figure 52.4.
The problem is that
A =
Ôøæ 0 1 , B =
Ôøæ ‚àí1
 ,
but
A
> A =

0 0
0 1
is not invertible.
(3) Proving (A1), (A2), (A3), and the convergence of (r
k
) to 0 and of (p
k
) to p
‚àó does not
require Assumption (2). The proof, using the ingeneous Inequality (A1) (and (B))
is the proof given in Boyd et al. [28]. We were also able to prove that (Œª
k
), (Axk
)
and (Bzk
) converge without Assumption (2), but to prove that (x
k
), (y
k
), and (Œª
k
)
converge to optimal solutions, we had to use Assumption (2).
1886 CHAPTER 52. DUAL ASCENT METHODS; ADMM
f(x,y) = x intersected with y=z,
z fixed.
graph of f(x,y) = x
Figure 52.4: A graphical representation of the Example 52.5. This is an illustration of the
x minimization step when z is held fixed. Since the intersection of the two planes is an
unbounded line, we ‚Äúsee‚Äù that minimizing over x yields ‚àí‚àû.
(4) Bertsekas discusses ADMM in [17], Sections 2.2 and 5.4. His formulation of ADMM is
slightly different, namely
minimize f(x) + g(z)
subject to Ax = z.
Bertsekas states a convergence result for this version of ADMM under the hypotheses
that either dom(f) is compact or that A> A is invertible, and that a saddle point exists;
see Proposition 5.4.1. The proof is given in Bertsekas [20], Section 3.4, Proposition
4.2. It appears that the proof makes use of gradients, so it is not clear that it applies
in the more general case where f and g are not differentiable.
(5) Versions of ADMM are discussed in Gabay [69] (Sections 4 and 5). They are more genÔøæeral than the version discussed here. Some convergence proofs are given, but because
Gabay‚Äôs framework is more general, it is not clear that they apply to our setting. Also,
these proofs rely on earlier result by Lions and Mercier, which makes the comparison
difficult.
52.4. CONVERGENCE OF ADMM ~ 1887
(5) Assumption (2) does not imply that the system Ax + Bz = c has any solution. For
example, if
A =

1
1

, B =

‚àí
‚àí
1
1

, c =

1
0

,
the system
x ‚àí z = 1
x ‚àí z = 0
has no solution. However, since Assumption (3) implies that the program has an
optimal solution, it implies that c belongs to the column space of the p √ó (n + m)
matrix Ôøæ A B .
Here is an example where ADMM diverges for a problem whose optimum value is ‚àí‚àû.
Example 52.6. Consider the problem given by
f(x) = x, g(z) = 0, x ‚àí z = 0.
Since f(x) + g(z) = x, and x = z, the variable x is unconstrained and the above function
goes to ‚àí‚àû when x goes to ‚àí‚àû. The augmented Lagrangian is
LœÅ(x, z, Œª) = x + Œª(x ‚àí z) + œÅ
2
(x ‚àí z)
2
=
œÅ
2
x
2 ‚àí œÅxz +
œÅ
2
z
2 + x + Œªx ‚àí Œªz.
The matrix

1
2 ‚àí
1
2
‚àí
1
2
1
2

is singular and LœÅ(x, z, Œª) goes to ‚àí‚àû in when (x, z) = t(1, 1) and t goes to ‚àí‚àû. The
ADMM steps are:
x
k+1 = z
k ‚àí
1
œÅ
Œª
k ‚àí
1
œÅ
z
k+1 = x
k+1 +
1
œÅ
Œª
k
Œª
k+1 = Œª
k + œÅ(x
k+1 ‚àí z
k+1),
and these equations hold for all k ‚â• 0. From the last two equations we deduce that
Œª
k+1 = Œª
k + œÅ(x
k+1 ‚àí z
k+1) = Œª
k + œÅ(‚àí
1
œÅ
Œª
k
) = 0, for all k ‚â• 0,
so
z
k+2 = x
k+2 +
1
œÅ
Œª
k+1 = x
k+2
, for all k ‚â• 0.
1888 CHAPTER 52. DUAL ASCENT METHODS; ADMM
Consequently we find that
x
k+3 = z
k+2 +
1
œÅ
Œª
k+2 ‚àí
1
œÅ
= x
k+2 ‚àí
1
œÅ
.
By induction, we obtain
x
k+3 = x
2 ‚àí
k + 1
œÅ
, for all k ‚â• 0,
which shows that x
k+3 goes to ‚àí‚àû when k goes to infinity, and since x
k+2 = z
k+2, similarly
z
k+3 goes to ‚àí‚àû when k goes to infinity.
52.5 Stopping Criteria
Going back to Inequality (A2),
p
k+1 ‚àí p
‚àó ‚â§ ‚àí(Œª
k+1)
> r
k+1 ‚àí œÅ(B(z
k+1 ‚àí z
k
))> (‚àír
k+1 + B(z
k+1 ‚àí z
‚àó
)), (A2)
using the fact that Ax‚àó + Bz‚àó ‚àí c = 0 and r
k+1 = Axk+1 + Bzk+1 ‚àí c, we have
‚àír
k+1 + B(z
k+1 ‚àí z
‚àó
) = ‚àíAxk+1 ‚àí Bzk+1 + c + B(z
k+1 ‚àí z
‚àó
)
= ‚àíAxk+1 + c ‚àí Bz‚àó
= ‚àíAxk+1 + Ax‚àó = ‚àíA(x
k+1 ‚àí x
‚àó
),
so (A2) can be rewritten as
p
k+1 ‚àí p
‚àó ‚â§ ‚àí(Œª
k+1)
> r
k+1 + œÅ(B(z
k+1 ‚àí z
k
))> A(x
k+1 ‚àí x
‚àó
),
or equivalently as
p
k+1 ‚àí p
‚àó ‚â§ ‚àí(Œª
k+1)
> r
k+1 + (x
k+1 ‚àí x
‚àó
)
> œÅA> B(z
k+1 ‚àí z
k
). (s1)
We define the dual residual as
s
k+1 = œÅA> B(z
k+1 ‚àí z
k
),
the quantity r
k+1 = Axk+1 + Bzk+1 ‚àí c being the primal residual. Then (s1) can be written
as
p
k+1 ‚àí p
‚àó ‚â§ ‚àí(Œª
k+1)
> r
k+1 + (x
k+1 ‚àí x
‚àó
)
> s
k+1
. (s)
Inequality (s) shows that when the residuals r
k and s
k are small, then p
k
is close to p
‚àó


from below. Since
x
k ‚àí x
‚àó
 ‚â§ d, then using Cauchy‚ÄìSchwarz we obtain
x
‚àó
is unknown, we can‚Äôt use this inequality, but if we have a guess that
p
k+1 ‚àí p
‚àó ‚â§
  Œª
k+1
 
 r
k+1
 + d
  s
k+1

.
52.6. SOME APPLICATIONS OF ADMM 1889
The above suggests that a reasonable termination criterion is that
  r
k

 and
  s
k


should be
small, namely that


r
k

 ‚â§ 
pri and
  s
k

 ‚â§ 
dual
,
for some chosen feasibility tolerances  pri and  dual. Further discussion for choosing these
parameters can be found in Boyd et al. [28] (Section 3.3.1).
Various extensions and variations of ADMM are discussed in Boyd et al. [28] (Section
3.4). In order to accelerate convergence of the method, one may choose a different œÅ at each
step (say œÅ
k
), although proving the convergence of such a method may be difficult. If we
assume that œÅ
k becomes constant after a number of iterations, then the proof that we gave
still applies. A simple scheme is this:
œÅ
k+1 =
Ô£±
Ô£¥Ô£≤
Ô£¥Ô£≥
œÑ
incrœÅ
k
if
  r
k

 > ¬µ
  s
k


œÅ
k/œÑ decr if
  s
k

 > ¬µ
  r
k


œÅ
k otherwise,
where œÑ
incr > 1, œÑ decr > 1, and ¬µ > 1 are some chosen parameters. Again, we refer the
interested reader to Boyd et al. [28] (Section 3.4).
52.6 Some Applications of ADMM
Structure in f, g, A, and B can often be exploited to yield more efficient methods for perÔøæforming the x-update and the z-update. We focus on the x-update, but the discussion applies
just as well to the z-update. Since z and Œª are held constant during minimization over x, it
is more convenient to use the scaled form of ADMM. Recall that
x
k+1 = arg min
x

f(x) + (œÅ/2)
  Ax + Bzk ‚àí c + u
k


2
2

(here we use u instead of ¬µ), so we can express the x-update step as
x
+ = arg min
x
Ôøæ
f(x) + (œÅ/2) k Ax ‚àí vk
2
2

,
with v = ‚àíBzk + c ‚àí u
k
.
Example 52.7. A first simplification arises when A = I, in which case the x-update is
x
+ = arg min
x
Ôøæ
f(x) + (œÅ/2) k x ‚àí vk
2
2
 = proxf,œÅ(v).
The map v 7‚Üí proxf,œÅ(v) is known as the proximity operator of f with penalty œÅ. The above
minimization is generally referred to as proximal minimization.
1890 CHAPTER 52. DUAL ASCENT METHODS; ADMM
Example 52.8. When the function f is simple enough, the proximity operator can be
computed analytically. This is the case in particular when f = IC, the indicator function of
a nonempty closed convex set C. In this case, it is easy to see that
x
+ = arg min
x
Ôøæ
IC(x) + (œÅ/2) k x ‚àí vk
2
2
 = Œ†C(v),
the orthogonal projection of v onto C. In the special case where C = R
n
+ (the first orthant),
then
x
+ = (v)+,
the vector obtained by setting the negative components of v to zero.
Example 52.9. A second case where simplifications arise is the case where f is a convex
quadratic functional of the form
f(x) = 1
2
x
> P x + q
> x + r,
where P is an n √ó n symmetric positive semidefinite matrix, q ‚àà R
n and r ‚àà R. In this case
the gradient of the map
x 7‚Üí f(x) + (œÅ/2) k Ax ‚àí vk
2
2 =
1
2
x
> P x + q
> x + r +
œÅ
2
x
> (A
> A)x ‚àí œÅx> A
> v +
œÅ
2
v
> v
is given by
(P + œÅA> A)x + q ‚àí œÅA> v,
and since A has rank n, the matrix A> A is symmetric positive definite, so we get
x
+ = (P + œÅA> A))‚àí1
(œÅA> v ‚àí q).
Methods from numerical linear algebra can be used so compute x
+ fairly efficiently; see Boyd
et al. [28] (Section 4).
Example 52.10. A third case where simplifications arise is the variation of the previous
case where f is a convex quadratic functional of the form
f(x) = 1
2
x
> P x + q
> x + r,
except that f is constrained by equality constraints Cx = b, as in Section 50.4, which means
that dom(f) = {x ‚àà R
n
| Cx = b}, and A = I. The x-minimization step consists in
minimizing the function
J(x) = 1
2
x
> P x + q
> x + r +
œÅ
2
x
> x ‚àí œÅx> v +
œÅ
2
v
> v
subject to the constraint
Cx = b,
52.6. SOME APPLICATIONS OF ADMM 1891
so by the results of Section 50.4, x
+ is a component of the solution of the KKT-system

P + œÅI C>
C 0
 
x
+
y

=

‚àíq +
b
œÅv
.
The matrix P + œÅI is symmetric positive definite, so the KKT-matrix is invertible.
We can now describe how ADMM is used to solve two common problems of convex
optimization.
(1) Minimization of a proper closed convex function f over a closed convex set C in R
n
.
This is the following problem
minimize f(x)
subject to x ‚àà C,
which can be rewritten in ADMM form as
minimize f(x) + IC(z)
subject to x ‚àí z = 0.
Using the scaled dual variable u = Œª/œÅ, the augmented Lagrangian is
LœÅ(x, z, u) = f(x) + IC(z) + œÅ
2
k
x ‚àí z + uk
2
2 ‚àí
œÅ
2
k
uk
2
.
In view of Example 52.8, the scaled form of ADMM for this problem is
x
k+1 = arg min
x

f(x) + (œÅ/2)
  x ‚àí z
k + u
k


2
2

z
k+1 = Œ†C(x
k+1 + u
k
)
u
k+1 = u
k + x
k+1 ‚àí z
k+1
.
The x-update involves evaluating a proximal operator. Note that the function f need
not be differentiable. Of course, these minimizations depend on having efficient comÔøæputational procedures for the proximal operator and the projection operator.
(2) Quadratic Programming, Version 1 . Here the problem is
minimize
1
2
x
> P x + q
> x + r
subject to Ax = b, x ‚â• 0,
where P is an n √ó n symmetric positive semidefinite matrix, q ‚àà R
n
, r ‚àà R, and A is
an m √ó n matrix of rank m.
1892 CHAPTER 52. DUAL ASCENT METHODS; ADMM
The above program is converted in ADMM form as follows:
minimize f(x) + g(z)
subject to x ‚àí z = 0,
with
f(x) = 1
2
x
> P x + q
> x + r, dom(f) = {x ‚àà R
n
| Ax = b},
and
g = IRn
+
,
the indicator function of the positive orthant R
n
+. In view of Example 52.8 and Example
52.10, the scaled form of ADMM consists of the following steps:
x
k+1 = arg min
x

f(x) + (œÅ/2)
  x ‚àí z
k + u
k


2
2

z
k+1 = (x
k+1 + u
k
)+
u
k+1 = u
k + x
k+1 ‚àí z
k+1
.
The x-update involves solving the KKT equations

P + œÅI A>
A 0
 
x
k+1
y

=

‚àíq + œÅ(
b
z
k ‚àí u
k
)

.
This is an important example because it provides one of the best methods for solving
quadratic problems, in particular, the SVM problems discussed in Chapter 54.
(3) Quadratic Programming, Version 2 . This problem is similar to the previous one, except
that the variable x ‚àà R
n
is not restricted to be nonnegative. The problem is
minimize
1
2
x
> P x + q
> x + r
subject to Ax = b,
where P is an n √ó n symmetric positive semidefinite matrix, q ‚àà R
n
, r ‚àà R, and A is
an m √ó n matrix of rank m.
The above program is converted in ADMM form as follows:
minimize f(x) + g(z)
subject to x ‚àí z = 0,
with
f(x) = 1
2
x
> P x + q
> x + r, dom(f) = {x ‚àà R
n
| Ax = b},
52.6. SOME APPLICATIONS OF ADMM 1893
and
g = 1,
the constant function which is the indicator function of the convex set C = R
n
. In
view of Example 52.8 and (1), since Œ†Rn (x
k+1 + u
k
) = x
k+1 + u
k
, the scaled form of
ADMM consists of the following steps:
x
k+1 = arg min
x

f(x) + (œÅ/2)
  x ‚àí z
k + u
k


2
2

z
k+1 = x
k+1 + u
k
u
k+1 = u
k + x
k+1 ‚àí z
k+1 = 0,
for all k ‚â• 0, so
u
k = 0
z
k+1 = x
k+1
for all k ‚â• 1. Consequently we have
x
k+1 = arg min
x

f(x) + (œÅ/2)
  x ‚àí z
k + u
k


2
2

z
k+1 = x
k+1 + u
k
u
1 = 0,
for k = 0, 1, and for k ‚â• 2 we have u
k = 0 and z
k = x
k
, with
x
k+1 = arg min
x

f(x) + (œÅ/2)
  x ‚àí x
k


2
2

.
As before, the x-update involves solving the KKT equations

P + œÅI A>
A 0
 
x
k+1
y

=

‚àíq + œÅ(
b
z
k ‚àí u
k
)

,
with u
k = 0 if k ‚â• 1 and z
k = x
k
if k ‚â• 2.
We programmed the above method in Matlab as the function qsolve1, see Appendix B,
Section B.1. Here are two examples.
Example 52.11. Consider the quadratic program for which
P1 =
Ô£´
Ô£≠
4 1 0
1 4 1
0 1 4
Ô£∂
Ô£∏ q1 = ‚àí
Ô£´
Ô£≠
4
4
4
Ô£∂
Ô£∏
A1 =

1 1
1 ‚àí1
‚àí
‚àí
1
1

b1 =

0
0

.
1894 CHAPTER 52. DUAL ASCENT METHODS; ADMM
We see immediately that the constraints
x + y ‚àí z = 0
x ‚àí y ‚àí z = 0
imply that z = x and y = 0. Then it is easy using calculus to find that the unique
minimum is given by (x, y, z) = (1, 0, 1). Running qsolve1 on P1, q1, A1, b1 with œÅ = 10,
tolr = tols = 10‚àí12 and iternum = 10000, we find that after 83 iterations the primal and
the dual residuals are less than 10‚àí12, and we get
(x, y, z) = (1.000000000000149, 0.000000000000000, 1.000000000000148).
Example 52.12. Consider the quadratic program for which
P2 =
Ô£´
Ô£¨Ô£¨Ô£≠
4 1 0 0
1 4 1 0
0 1 4 1
0 0 1 4
Ô£∂
Ô£∑Ô£∑Ô£∏
q2 = ‚àí
Ô£´
Ô£¨Ô£¨Ô£≠
4
4
4
4
Ô£∂
Ô£∑Ô£∑Ô£∏
A2 =

1 1
1 ‚àí1
‚àí
‚àí
1 0
1 0 b2 =

0
0

.
Again, we see immediately that the constraints imply that z = x and y = 0. Then it is easy
using calculus to find that the unique minimum is given by (x, y, z) = (28/31, 0, 28/31, 24/31).
Running qsolve1 on P2, q2, A2, b2 with œÅ = 10, tolr = tols = 10‚àí12 and iternum = 10000,
we find that after 95 iterations the primal and the dual residuals are less than 10‚àí12, and we
get
(x, y, z, t) = (0.903225806451495, 0.000000000000000, 0.903225806451495,
0.774193548387264),
which agrees with the answer found earlier up to 11 decimals.
As an illustration of the wide range of applications of ADMM we show in the next section
how to solve the hard margin SVM (SVMh2) discussed in Section 50.6.
52.7 Solving Hard Margin (SVMh2) Using ADMM
Recall that we would like to solve the following optimization problem (see Section 50.6):
Hard margin SVM (SVMh2):
minimize
1
2
k
wk
2
subject to
w
> ui ‚àí b ‚â• 1 i = 1, . . . , p
‚àí w
> vj + b ‚â• 1 j = 1, . . . , q.
52.7. SOLVING HARD MARGIN (SVMH2) USING ADMM 1895
The margin is Œ¥ = 1/ k wk . The separating hyperplane Hw,b is the hyperplane of equation
w
> x ‚àí b = 0, and the margin hyperplanes are the hyperplanes Hw,b+1 (the blue hyperplane)
of equation w
> x ‚àí b ‚àí 1 = 0 and Hw,b‚àí1 (the red hyperplane) of equation w
> x ‚àí b + 1 = 0.
The dual program derived in Section 50.10 is the following program:
Dual of the Hard margin SVM (SVMh2):
minimize
1
2
Ôøæ
Œª
> ¬µ
>
 X
> X

¬µ
Œª

‚àí
Ôøæ Œª
> ¬µ
>
 1p+q
subject to
p
X
i=1
Œªi ‚àí
q
X
j=1
¬µj = 0
Œª ‚â• 0, ¬µ ‚â• 0,
where X is the n √ó (p + q) matrix given by
X =
Ôøæ ‚àíu1 ¬∑ ¬∑ ¬∑ ‚àíup v1 ¬∑ ¬∑ ¬∑ vq
 .
Then w is determined as follows:
w = ‚àíX

¬µ
Œª

=
p
X
i=1
Œªiui ‚àí
q
X
j=1
¬µjvj
.
To solve the dual using ADMM we need to determine the matrices P, q A and c as in
Section 52.6(2). We renamed b as c to avoid a clash since b is already used. We have
P = X
> X, q = ‚àí1p+q,
and since the only constraint is
p
X
i=1
Œªi ‚àí
q
X
j=1
¬µj = 0,
the matrix A is the 1 √ó (p + q) row vector
A =
Ôøæ 1
>p ‚àí1
>q

,
and the right-hand side c is the scalar
c = 0.
Obviously the matrix A has rank 1. We obtain b using any i0 such that Œªi0 > 0 and any j0
such that ¬µj0 > 0. Since the corresponding constraints are active, we have
w
> ui0 ‚àí b = 1, ‚àíw
> vj0 + b = 1,
1896 CHAPTER 52. DUAL ASCENT METHODS; ADMM
so we obtain
b = w
> (ui0 + vj0
)/2.
For improved numerical stability, we can average over the sets of indices defined as IŒª>0 =
{i ‚àà {1, . . . , p} | Œªi > 0} and I¬µ>0 = {j ‚àà {1, . . . , q} | ¬µj > 0}. We obtain
b = w
>
Ô£´
Ô£≠

X
i‚ààIŒª>0
ui
 /|IŒª>0| +

X
j‚ààI¬µ>0
vj
 /|I¬µ>0|
Ô£∂
Ô£∏ /2.
The Matlab programs implementing the above method are given in Appendix B, Section
B.1. This should convince the reader that there is very little gap between theory and practice,
although it is quite consuming to tune the tolerance parameters needed to deal with floatingÔøæpoint arithmetric.
Figure 52.5 shows the result of running the Matlab program implementing the above
method using ADMM on two sets of points of 50 points each generated at random using the
following Matlab code.
u14 = 10.1*randn(2,50)+18;
v14 = -10.1*randn(2,50)-18;
The function SVMhard2 is called with œÅ = 10 as follows
