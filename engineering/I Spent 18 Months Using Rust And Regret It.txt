I spent 18 months rebuilding my algorithmic trading platform in Rust.
I'm filled with regret.
I would love it if this article was like,
I'm filled with regret for not doing it sooner.
Like, how funny would that be?
All right, Austin Starks, take us on a wild ride.
I was a young, hopeful Rust fanatic.
On paper, Rust seemed...
Okay, this is not seeming very pro-Rust.
This is not pro-Rust at all.
On paper, Rust seemed like the programming language designed by the gods.
Not only is it the fastest programming language out there,
it's also one of the safest.
Well, technically, it's really hard for Rust to actually be the fastest language out there.
It's very easy for it to be not fast.
In fact, it's quite optimized to be not fast due to the safety.
But hey, C++ is not faster.
C is not faster.
None of the languages are faster.
Anything that's at the tippy top, just remember, right?
The top of the performance pyramid is going to be filled with managed memory language.
So you got Rust, you got C, you got Zig, you got C++.
I'm sure there's other ones.
Nym might fall in there.
But the reality is, is the reason why Rust often goes from the fastest to the next level
is because you use things like RCs, ARCs, and Mutacies to effectively get around Rust, right?
Or more so, clone.
Yeah, I guess Odin would be in here as well.
So this is like a very typical...
This is like the typical problem here, right?
Wait, wait, people don't use ARCs in C++?
I mean, you use ARCs if you use shared pointers in C++.
And if you look at the bottom of the pyramid, you find a snake and a big yellow square.
Golang falls into these two categories, right?
Go is fast, right?
Once you have runtime managed memory, which is RCs and ARCs, it's no longer fast, right?
You fall down into garbage collected, right?
I put a heavy emphasis on garbage collected because there's not garbage collector.
But you are no longer managing your own memory.
You are letting something else manage your memory.
Java doesn't exist.
It's just a fantasy.
It is.
Where did Java hurt you?
I'm not alone in thinking Rust was this perfect language.
If you read about Rust programming language online, you'll likely encounter overwhelmingly positive opinions.
Every guide on Medium, every post on Reddit, every answer on Stack Overflow, everything is glowing.
I can't wait to catch a bullet by this.
I feel like I'm about to catch a bullet by Rust.
Given this, I decided to migrate away from TypeScript, rewrite my entire open source algorithmic trading system in Rust.
I gave Rust a neutral rating before.
I take that back.
Dang.
Dang.
Okay.
I really hope that we get some really good ones, right?
I hope we get something really good here.
By the way, if you're doing algorithmic trading, I would assume you'd want to be able to react really, really fast.
So I could see you using a very – I could see why Rust would be a natural decision.
Typically, you don't want to do algorithmic trading in slower, garbage-collected language because a couple hundred milliseconds could cost you the trade, right?
Just real talk.
It makes sense why you'd want to use something that's better than TypeScript.
I wrote my – let's see.
I wrote about my experience with Rust four months ago.
In my last article, I concluded that while I really like the speed in some aspects of the language design, such as enums and strong typing, I didn't really love the language.
What you're discovering is that you don't in love and post safety.
That's what you're discovering.
My article is met with harsh criticism on Reddit, including one highly upvoted comment that accused me of chat GPT-ing to write my article.
Dang.
This is a lot of upvotes for something that literally isn't true.
I don't use chat GPT to write any of my blogs.
I just simply don't.
I hate how it sounds.
This is just how I write.
Nowadays, I don't even use chat GPT to correct my writing.
This is genuinely my writing style.
Dude, I'm right there with you.
I actually tried to use chat GPT to help me with some stuff, and it just became very frustrating.
It became very, very frustrating.
What if he is a robot?
Ooh.
Ooh.
Anyways.
After posting, I had thought that I didn't give Rust a fair shot.
Maybe I was just naive or came in with misplaced expectations.
Now, after working with the language for a little while longer, I can confidently make one conclusion.
The language absolutely fucking sucks.
I think the language is great.
So maybe I'm not that intense, but dude, this is funny.
But I've always said I think Rust feels better than it is.
Because when you're solving a black box problem, it's, like, really, really easy.
It's really, really great.
He can still turn it around.
He can still turn it around.
There's some things that make Rust really good at.
Like, I love it for basic command line operations along with, like, marrying that with some, like, file reads, transforms and stuff.
It just is really good for that.
What I despise about Rust.
I want, let's see.
If you want to find an article about what's right with Rust, look literally anywhere on the internet.
You'll be hard-pressed to find anything less than neutral about the language.
This article will be a focused rant about what I despise about this crabby language.
All right.
Let's see if we can figure this out.
Horrendous, verbose, unintuitive syntax and semantics.
Yes, when you get into this level, this is what I always say.
The moment you start getting into this world, this is where things start getting, like, good Rust becomes shitty really quick.
Like, really, like, once you, like, when you hit into, like, dude, a pinbox dying future is crazy.
Like, this is crazy.
It's Haskell dressed up as C-like language to trick normies.
Haskell has this exact same problem.
Yeah, that's due to async.
I know, I've always said async is where things just get all effed up.
And the moment you get into async land and you try to do something that's really clever, do it every single time.
What is this?
Okay, so send.
Send means it can cross.
It can go across.
It can go across async boundaries, correct?
And then plus tick underscore means the unnamed lifetime, if I'm not mistaken.
This is where I start breaking down, too, is once we start getting into this world,
this means it can cross async boundaries, and it has a lifetime that you don't need to, that we're not mentioning, right?
So that means the function that you're passing in, F, is a mutable function that takes in a client session
that returns a future at some point in the world that can be crossed over the boundaries
and has an output of R, where R is send and static.
Async is very hard.
It's very, very hard.
Yeah, like, I generally get what I'm looking at here.
I generally get what I'm looking at.
It's just that once you get into this world, it is.
It's just super hard.
Like, generally speaking, it gets very, very hard.
All right, so all of this looks pretty good.
All of this looks pretty good.
None of this looks like, see, the rest of this looks pretty good, right?
I would say that everything else in here just looks pretty straightforward, right?
Anybody who ever said that Russ doesn't have atrocious semantics is lying to your face.
See, the thing is, I think one thing that's really nice, though, that you're kind of missing
is the fact that you can go operation, session, await.
If it's okay, we do this.
If it's not okay, we do that.
Like, I think this is actually really nice, right?
I think that this is a really nice thing.
And then you have a for loop.
You have all of this.
It actually reads really nice.
Like, this part, this is what I'm talking about when Russ looks really good,
is this right here.
This is really nice, Russ.
And there's a lot going on here that is actually shockingly crazy, right?
You have to start a session, which awaits something.
You have to start a transaction, which awaits something.
You then have to do this operation, then match on the errors.
And if you get the error, then you return out the result.
Else, you're going to go max retry has exceeded.
This is really, this is nice code.
It's this part right up here that just gets so effed up.
This part gets so effed up.
There are certain things where, if you don't have access to an extremely powerful large language model,
then writing the function becomes literally impossible.
I don't want to spend 90 minutes figuring out why where clause in my run transaction.
Let's see, figuring out the where clause in my run transaction.
Yeah, the where clauses become exceedingly frustrating.
I'm on your team.
And if you define your generics in the wrong place, run clauses can be super frustrating.
Like, they can become super, super frustrating.
That's why, like, a language like OCaml, though having an exceptionally similar type system,
gets away with a lot is because it's garbage collected.
It can just simply drop some of these difficulties, and that's that.
Yeah, the large language model is an interesting, is a very interesting call out saying,
unless if I have access to this, I, to me, it says you just need to understand more about Rust
internally for you to be able to do this.
And so this is that language curve.
You know, I jokingly made that video where I said Rust learning curve is like this.
Once you hit async, it's non-differentiable.
It's because this, like, skill issues here, the problem is that the borrow checker when
you're learning is like a steep, it's like an upright curve, and then you get it, and
that's it.
Once you get the borrow checker, it's easy.
But then when you add in lifetimes, it's like another just upright curve.
And then when you add in async, it's like just such, it, like, goes, it goes off the table.
And it becomes so hard, because it's just really difficult when you marry all the concepts
of lifetimes, of traits, and of async.
When you put these all three together, now you get this whole problem that's really, really
difficult, and it is most certainly a skill issue.
It's most certainly a skill issue, but it's a very excessive and difficult skill issue.
So the Rust curve is the Debian logo?
Exactly.
Right?
My God, the curve is non-functional.
Yeah, I know.
In the end, I had to abandon the idea of a helper function entirely.
Yeah, so again, this is just, that's because you're writing it the not Rust way.
Don't write a helper function.
Can we all agree?
This is one of those things that I always made a problem of, is that in JavaScript, you abstract
out these similar functionalities across async operations.
In Rust, you don't want to do that, because you will find that you hate your life.
You do.
You find that you hate your life, and it sucks a whole bunch, because you do this, and you
just, you have to, like, be okay with code duplication at some level.
Or you have to be a genuine master of Rust.
Or just give it to ArcMutex.
ArcMutex makes it very easy.
Oh, I read that one.
Okay.
You say he's also making it complicated by using a Mongo transactions.
I'm not sure if that's true.
A lot of people want to use, by the way, this code girl, I can see your experience is showing
right here.
Wrong duplication is better than wrong abstraction?
Absolutely.
Hands down, 100% correct.
Because you can always fix an abstraction.
You can always, or you can always fix code duplication with abstraction.
Very hard to fix it, fix abstraction.
By the way, I forgot what else.
Oh, no.
My cam died.
My cam died.
It actually wasn't my camera.
It's my, it's my, what do you call it?
My HDMI converter.
Hold on.
Almost there.
Almost there.
Whoopsies.
Hold on.
Hold on.
There we go.
I blame Karen.
I thought it was my Linux.
Nope.
There we go.
You're moving again.
There we go.
There we go.
All right.
In the end, I had to abandon the idea of a helper function entirely because I quit literally,
let's see, because I quite literally couldn't get the code to compile.
Yeah.
I mean, dude, I've made this mistake a lot with Rust.
And I feel like you make the same mistake with Zig as well.
I think the problem, I truly think the problem here is what I would like to refer to as JavaScript
brain.
JavaScript brain, or really dynamic language brain.
Dynamic language brain says abstract on all forms of code duplication.
And so you kind of adopt this without realizing it.
You adopt it really quickly.
And also, a big problem about dynamic programming, along with structural programming such as Go,
is that you adopt structural patterns.
And you think a certain way.
You think in interfaces.
And again, Rust does not necessarily make traits easy.
And Zig, they don't even have traits.
They don't even have traits.
They don't even have them at all.
And so it makes things really hard.
What's the meme with the four people talking about something, and then there's the last
guy that's like, you guys have interfaces?
What's that meme called?
Dry is overrated, and people overuse the concept?
Absolutely.
They use it constantly, and it is very, very dangerous.
It's true.
I've been coding in C89 lately, and I find my JS brain really leads me into the wrong,
into some bad places.
Yeah.
What is it called?
We are the Millers.
Oh.
Yeah.
This one.
This one.
This one.
Something along the lines of, like, JavaScript, TypeScript interfaces are great, right?
Golang.
Something along, like, the lines of Golang structural.
I am sure there's Python.
There's some sort of...
I'd have to think about this more.
But this is happening.
I got to think about...
I got to think about this still.
I know there's a joke in there, so we'll just make the quick and easy joke, which I'll
just grab the first one, right?
I know.
Sometimes, bro cooked for nothing.
I know.
There's something there.
There's something there that's really good, and I don't know what it is.
Zig.
Draft shit post.
It's a draft shit.
There's definitely something there that's really good.
It just is going to take too long to think about, and so we say, move on.
Okay.
This is not what it looks like.
What people claim as Rust's biggest strength, a strict compiler to eliminate errors, is one
of Rust's biggest flaws.
Just give me the garbage collector and let me do what I want to do.
Real talk.
This is real.
This is absolutely real.
Rust's biggest strength is also its biggest weakness, which is also very reflective of
all other ones.
JavaScript's biggest strength is the fact that you can just add a property to anything.
JavaScript's biggest weakness is you can just add a property to anything, right?
Like, every language has the exact same problem, right?
In contrast, if I were writing this exact same function in Go, it would look like something
like this.
Well, Go is actually really great, though.
I mean, Go gives you the abstraction ability of TypeScript with the 99% speed of Rust.
It's very impressive.
Run transaction.
Do all this one.
Yeah, yeah.
Start a client session.
There we go.
Defer session end.
Yep.
Do all this thing.
Grab all that good stuff.
Do this one.
Yep.
This is all looking good.
Grab all this stuff.
Oh, yeah.
Oh, yeah.
Oh, yeah.
Oh, yeah.
Oh, yeah.
Do the returns.
Do the attempts max.
Yeah.
Go is just so simple, right?
Go is just so dang simple, right?
It's just so simple.
That's what makes it so fun.
So easy to read and understand.
It really is easy to read and understand.
And all the people, I see a bunch of people saying, if error equals nil, blah, blah, blah.
If we were to do this in TypeScript, one, two, three, four, five of those would be hidden
errors in which you would not know you need to catch or not.
So you would just get randomly borked, whereas at least in Go, I know when I'm about to get
borked and I can handle it, okay?
So come on.
Don't even try that with me.
Don't.
Come on.
Come on.
While the core of the function remains relatively the same, you don't have to do backflips to
figure out how to make the dang code work.
It just works.
Agreed.
Horrendous error handling.
Ooh, that's interesting.
I would kind of argue, my only problem, I will say this about Rust, one of its big problems
is that due to the question mark operator, you defer a ton of error handling really easily.
The convenience of not handling an error is so easy that I often find I think less about
errors and I often find myself oopsie-dazing.
It's skill issue.
Skill issue.
Fair.
Please.
Please.
It's a skill issue.
But nonetheless, I find it so convenient that I forget to like really think about how I
should handle this.
Rust does have some very nice things with errors.
As long as you avoid unsafe unwraps.
Well, yeah.
You can be a damn sure that the code will run and keep running.
No pointers, exceptions, and unhandled errors just don't happen anymore.
Yay, right?
Wrong.
Because when your data is wrong or something unexpected happens, you'll be fighting to
figure out what the hell happened.
Maybe I'm just an idiot and can't figure out how to enable stack traces, but when an
error happens in my application, I have no idea why.
Well, I mean, backtrace equals one, right?
Rust underscore backtrace equals one.
Am I incorrect on that one?
I don't think so.
Right?
Right?
Definitely some skill issues on that one.
For prod, why not?
I mean, if you're going to have exceptions, why not have a trace?
Assuming that you handled 99% of your exceptions or your errors, and this one you couldn't
handle, why not?
Like, I totally get when you have one and you handle it, you don't need a stack trace,
right?
By the way, this also would be largely, this also is very nice to consider with asserts,
right?
Running a bunch of simulations and asserts and ensuring that you can't have these kind
of things.
You can really figure out a lot of your application before you actually have it running with actual
money doing trading.
You know what I mean?
I still use XX errors and %W for stack traces and go.
See, I haven't used XX errors.
I just still use errors and pretty much do wrap stacks still, right?
In contrast, I actually like goes handling, right?
I like the fact that you don't have stack traces.
Instead, you just build your own stack, and I build my own stack, and so I get all the
relevant bits in where the error happened, and I actually find it to be really nice.
Like, generally speaking, I find it to be very nice.
In contrast, with a language like Python, you get these beautiful art-like stack traces
that tell you exactly what happened down to the line number.
Even in Go, you have errors wrap, yep, which enable you to look at the entire error stack
in your application, which is only the places you're really concerned about, which
is also nice.
Perhaps I'm a goddamn idiot, because when I encounter an error and rust, I'm like, I'm
in la-la land trying to figure out what happened to the, or what happened, wait, trying to
figure out what the hell happened.
Well, I could not read that.
Again, I'm going to say it again.
The question mark operator, due to the extreme convenience of it all, I think leads more people
down this.
There's this concept.
There's a very important concept in programming that you need to internalize, which is called
the pit of success.
You want to make it so that doing the right thing is so easy that people just fall into
the right move.
And that's one of the problems with Rust's extremely convenient error handling, is that
a lot of people just question mark out the errors really quickly.
And so you end up handling an error like 10 functions higher with absolutely no indication
into where this error happened.
And I see this a lot.
I see this quite a bit.
I'm not saying that if error is better, if error equals nil is better, but at least you
have to think about it a little bit more holistically in Go, even though it's more boilerplate.
You have to think about it.
You have to wrap it.
You have to add context.
It's also why I like Anyhow.
I can add context at every level.
And by adding context at every level, I get Go-like error handling, but with the convenience
of Rust, right?
A dine error is just crazy.
Don't do dine error.
A dine error is nuts.
Anyhow, this error, friends.
Yeah.
I need this ePrint LN littered throughout my application.
In fact, no, I'm not an idiot.
This is a flawed language design.
I think this is just, again, I think he's just, when you use Rust, you don't fall into
the pit of success.
And by not being in the pit of success, I think it's very easy to blame the tool as opposed
to the knowledge of it.
And remember, I'm not, I'm not, at this point, I am not a Rust lover.
I am not a Rust lover.
I think it has a lot of things going for it, but I actually think that Zig is significantly
better.
I think it gives you the right amount of safety with giving you the right amount of control
over your program.
I think it's the best of both worlds.
And I would say that this, this right here is definitely much more of a skill issue that's
very obvious.
Like, you goofed up.
You goofed up.
Hey, dude, it took me like a year to really get a good grasp on errors and Rust.
Like, to really understand a nice way to handle Rust.
It took a long, whoopsie daisies, it took a long time.
And so I definitely don't blame that at all.
Krabby community.
Hot take.
The Rust community isn't as nice and cool as they pretend to be.
Absolutely.
Rust community is probably, I would say, the least friendly.
Zig might be the least friendly community, but then Rust is right afterwards.
I think JavaScript and TypeScript generally have a pretty friendly community.
All right?
Like, I can shit.
Well, okay.
PHP has the nicest community.
We can all agree to that.
Anyone that disagrees that PHP is not the nicest community, I would like to mention Adam Elmore
and Aaron Francis.
Okay?
You cannot beat Adam Elmore and Aaron Francis as the nicest people in the universe.
Yeah, PHP is a very nice.
They're super, super nice.
Very, very nice community.
And I would, like, the reason why I'm going to Laravel is that I, or LaraCon, is that I
am obsessed with how well and how good their community is.
And I want to learn from it.
I want to bring it in.
I want to bring it to the mainstream software world where we can stop, like, where we can
actually be a lot better.
Like, even notice this.
I'm not, like, I'm not dunking on this guy.
I'm not being mean to him.
I'm saying, hey, this is a really natural conclusion I think a lot of people run into.
I'm fully on his team.
I'm trying to, like, I'm trying to bring the goodness of that PHP community outside because
I think it's really healthy and I'd love to see more of it.
And I agree fully.
I think the Rust community, specifically in the more leadership roles, are some of the
meanest people I've ever interacted with in my entire lifetime.
Like, absolutely the meanest people.
It is shocking.
It is shocking how much of their superior.
Now, there's some good ones.
I can think of, gosh, it's Shepard something Shepard.
Gosh, why?
Dude, I can see his name.
Dude, his name is, like, Derp Shepard or Derp something.
Derp Shadow.
Gosh, why can't I remember his name?
Really, a Shep master.
Dude, Derp?
Yeah, Derp.
Really nice guy.
Shepard's Oasis.
Shepard's Oasis.
There you go.
I actually think he's a really nice guy and he's an exceptionally talented person.
Like, outrageously talented and still, like, communicates in a really nice way.
Like, I actually think that just genuinely a huge amount of respect for the guy.
Right?
Absolutely.
Huge amount of respect.
All right.
Because MongoDB is shitty.
MongoDB is not a real database.
It's a key value dock stored and no squeal storage system that literally,
designed for marketing metrics.
It didn't even provide support for asset or transactions until more recently.
And for the longest time, it just blindly corrupted your data due to its poor Q2 right design.
There are better databases.
Don't make Rust look bad for using MongoDB.
I mean, this is actually just terrible advice.
I mean, really, the thing that EO is struggling with is having helper functions,
which is typically, I find to be very difficult,
for doing a retry over some async operation.
Right?
You could generalize this to retry over async operation.
And Mongo not going to make it, for sure.
Mongo not going to make it.
But this response is wild.
Right?
But again, I'd also like to say that random response on the internet is not reflective of the community.
So just remember this, that I don't think, you know what I mean?
Someone just said something, and it's very, very true.
I think, generally speaking, when I think of the Rust community, I think of, I just come back to this picture often.
And I can't undo it, because once it's in the brain, it's just stuck there.
It's just stuck there forever.
I'd really love to see a turnaround in the community and be a little bit more approachable.
For example, I asked the question on the Rust subreddit,
how to improve error handling with MongoDB Rustcrate.
My answer ranged from switch to Postgres.
Why am I using MongoDB at all?
MongoDB is bad in Go and Python 2.
An actually helpful suggestion to improve error messages.
Okay, that's good.
That's good.
I always find this strange.
When somebody asks a question, how do I handle this situation better?
I've always found it such a strange answer to be like, use Postgres.
Like, I will say that to Dax or to TJ, but I would never say that to an internet random person.
You know what I mean?
That just feels weird.
There is no other programming community that's as cult-like as Rust.
They ignore all the giant glaring flaws with the language,
like it's crazy learning curve, verbosity, horrible error messages,
crazy syntax, and questionable language design choices.
They'd rather say it's a skill issue with the developer.
That's insane to me.
I do think you're definitely having some level of skill issues.
I think one of the hardest parts about writing in different languages
is adopting the mindset of that specific language, and it's very, very hard.
And so I'd revisit this maybe a bit more.
Like, I'm on board with you that I don't think Rust fits all situations,
but I think that horrible design choices,
I actually think a lot of the design choices are really good.
I think there's a lot of really cool things.
Like, dude, Imple, Imple, what's it called?
Imple from and try from is, like, one of my favorite things of all time.
He's doing it solo with no mentor.
Yeah, that's very, very hard.
Imple from and Imple try from is probably my favorite design feature of all time.
It's so good.
It's, like, shockingly good.
But I wish more languages had that.
I just like shadowing in Rust a lot.
Funny, you know, it's funny you should say that because I was on your team.
I thought shadowing in Rust was, like, such a bad idea,
and now I love shadowing in Rust.
And the reason being, I have an example somewhere here.
I can just search the word maybe.
There we go.
I always am like, hey, get an index of something.
If it equals null, I want to just return this back out.
But if it doesn't equal null, I want to, like, unwrap that null.
Because I generally hate indenting.
I try not to indent.
So I'm not going to have the inverse of this, which is capture grouping,
and then getting out of it.
And so I wish I could.
I really wish I could just do this, right?
Like, I actually wish I could shadow.
I think shadowing is really, really nice.
I actually really do like shadowing now that I understand it.
Before, I didn't like it even when I used it.
And I did understand it.
That's kind of a dick phrase to say.
I did understand it, but I just didn't.
Now that I've used it enough times, I actually really, really like this.
Right?
What is shadowing?
Just what I just did right there.
This right here is a maybe U size.
This right here is a U size.
So a shadow is to change its type.
I'm going to change its type from option U size to U size.
You can use or else.
Yeah, yeah.
I mean, those are things that, you know, this is me.
This is like some of my first zig I ever wrote.
I know there's better ways.
I know there is like an or else something, something, something.
I haven't quite got there yet.
Right?
I'm still learning all the things.
You know, I like to write a language in a way that's familiar with me how to handle it.
And then as I get better, I like to try to get better at it.
You know, I like to kind of like, as you can see right here, I'm kind of getting good at the catching.
Right?
I'm getting there.
I'm getting there.
Just please let me get there.
I'm getting there slowly.
Though I do agree with you.
I do agree with you that I guess I could do something along the lines of, oh, whoopsies.
I just realized that I was yanking the whole wrong thing.
Whoa, whoa, whoa, whoa, whoa, whoa, whoa.
That was crazy.
So you're saying I can go or else return null.
All right.
That's really, really nice.
Thank you.
I know I was yanking wrong.
Very, very beautiful.
Like these things, like this, again, Zig has some really nice operations here.
This is very, very nice.
But again, what's the use case of shadowing?
When you wish to change a variable type but keep the same name.
Right?
Very, very nice.
All right, final words.
With all this being said, Rust has some pros.
It's fast and, well, that's mainly it.
No, no, no, no, no, no.
Multi-threaded programming, I find to be, generally speaking, multi-threaded programming in Rust is pretty enjoyable.
Just multi-threading itself, of course, I cheat with ArcMutex and or clone.
Forgive me.
But if you clone and or ArcMutex, async is really not that bad.
There's plenty of reasons to actually really like it.
Errors is values.
I think generally is a good way to go.
But if you're trying to get maximum performance and async, I find it very difficult.
I do like the idea of having the reminder of like, hey, you can't have this.
Like, here's a good example.
If you use channels with Go, there's like these four rules of channels that just make it super, super hard to work with.
And I hate it.
Whereas when you work with channels with Rust, because it has an optional type, it actually makes it really, really easy to use a channel.
You can't get stuck in a whole set of things.
And this just genuinely makes async programming significantly nicer.
Just like at an entire level.
I can't remember the, let's see, the four bad things about Golang channels, right?
There's like the four things you got to know.
I know there's one, whatever.
I don't even want to, I don't even want to look for it.
We're not even going to look for it.
But there's like these four rules of things that are very, very annoying.
And Rust just doesn't have it due to the options.
That means you can, like, here's one thing.
If you return a nil through a channel, you close the channel, if I'm not mistaken.
Whereas with Rust, because you have options, you can have effectively some null, right?
You can say, hey, this is empty.
There's like, there's a bunch of stuff.
Close channel is only.
You're mistaken, I'm afraid.
I'm mistaken on that one.
Okay, my bad, my bad.
I don't use channels a lot.
I thought there was like no nils.
Reading from a nil channel.
Panic, yes.
Reading from a nil panic.
Nils and Golang and channels.
I thought there was a whole thing.
Okay, yeah.
I know there's like a whole bunch to it.
Like I said, I'm not great at Go.
I use almost, all my Go has no channels except for a couple.
And I find channels to be really great.
But I know that Rust had a really nice, it has really nice ways to know what to do.
Here, okay, let's look at this.
The Axiom channel.
Send to, let's see.
A send to a nil channel blocks forever.
Like, that sucks.
Can we all agree that this is bad?
That's one really nice part about Rust is that it just returns an error and says, hey, use of closed channel.
It's very, very nice.
Receive from a nil channel blocks forever.
Can't you get around this by doing a receive with two arguments?
Can't you?
You can get around that by doing a, like a receive with X and done, right?
Can't you get around that now with that?
So isn't that, isn't that Axiom kind of generally dead?
Yeah, not or so.
Okay, yeah, yeah, yeah, yeah, yeah.
It's the val okay pattern.
Yeah, that's, I didn't, I didn't want to write all this stuff.
You know what I mean?
Let's see.
Send to a closed channel panics.
Also, again, that's pretty reasonable.
I'd rather have it return an error, though.
The weird part is that Go makes such usage of errors.
I'm surprised that they didn't just send an error back, right?
I feel like the usage, a channel two would be really nice if they had errors and stuff.
And then what's that?
Receive from a closed channel returns the zero value immediately.
This is, of course, because they don't have options, right?
So again, if you had an option, you can tell that a channel is closed because it returns a none, right?
That means there was nothing there, as opposed to something that's empty, which is very, very different, right?
So an option would be really, really nice.
And so I would prefer that over this.
I knew there was some, there's some quirkiness, right?
And so I find that this one is like a very, I find this one to be very difficult.
Yeah, you can always use val okay.
You can always use val okay.
And that, that should be used.
You should use val okay.
Okay, it's just, I would rather have an option type that makes sense.
And so what I find that is when I read from a channel, so I do this thing, I forget where I do it,
but I do, I do a thing where I check for, I check for results.
And how I check for results is that what I do is, what is it?
Is that I do a, like a function call, like a function get, I'm way too zoomed in.
And I'll do like a select, and then I'll do like a pull from X.
And then I'll also do like a default return, return, return something, right?
And so that way I have like a default return and this, and that way I do, it's like a non-blocking quick value select.
And I know this is like a, this is some level of a pattern.
Anyways, I don't know.
I thought, you know, this article, this article is skill issues, but I think, I think the thing that you have to,
you have to pull from this is that just because there's skill issues doesn't mean there's not real issues as well.
I think the pit of success with Rust is a bit shallow.
I think it's very easy to do the wrong thing.
And that's why I think it's pretty universally agreed that with Rust, people find that they build something,
they refactor it, they build it new.
They refactor it, they build it again.
They refactor it, right?
And they find themselves in this constant refactoring thing because they're not,
it's very hard to write it right the first time or even write it good enough the first time.
And so I find that it's just that Rust doesn't have the same ability to just fall into the correct way.
At least that's my general perception of it.
I think if I wrote it all the time, I could fall into the right way very easily.
I think that if I just had enough reps, I think Rust would be very easy at all points, including in the async world.
But I think because I don't have enough reps, I don't do it 40, 50, 60 hours a week.
I don't fall into that.
There you go, the pit of skill issues.
It's a pit of skill issues more than anything else.
Rust is fun, but it's less practical.
Sure.
I guess it's also safe too.
If we compare it to C++, it's obviously the better language.
I do feel like that's also, again, I think that this just, when I hear this phrase,
what I hear is that you're either comparing it to C++ 11 and below,
or B, you've never really done C++ and you heard it's stupid.
And so therefore you kind of like dunk on it.
You know, if you use unique pointers or shared pointers and everything, you generally,
it's pretty easy to do the right thing and go.
I mean, in C++.
It's more verbose than I like.
Can we all agree it's more verbose than we like?
But generally speaking, long as you do, long as you stick to certain things, it's pretty easy.
And then, of course, there's also like all the crazy operation overloads
and the weird, crazy copy constructors, the L values, R values.
There's some hard parts that I think take a long time to learn.
To master C++ is like mastering Rust.
I'd rather have my application take a few dozen milliseconds longer to run
if it means my development time is cut in half,
which is an interesting tradeoff to make for an algorithmic trading,
because algorithmic trading, I would assume, a few dozen milliseconds can be impactful.
On the bright side, if we choose to write my application in Go,
I'd also probably have some regret.
What if it could be faster?
I'd think to myself, there's yet another article about how Rust is the best thing since sliced bread.
Oh, geez, I made a mistake.
At least the, I mean, article FOMO, influencer FOMO is real.
Like real talk, influencer FOMO is super real.
By the way, I did build an arbitrage across different trades for cryptos,
and we used Bellman's Ford's maximum flow problem to detect multi-leg arbitrage,
and it was pretty sweet.
I made some money, but the biggest problem is I just didn't have $10 million to put in,
or I literally could have made an incredible amount of money back in the day
when there were such inefficiencies in the market.
At the very least, now that I know Rust, I feel like I can learn anything.
Maybe I'll pick up OCaml for the hell of it.
It can't be much worse than Rust, can it?
OCaml's great, but I think you're going to run into things that you dislike about OCaml equally,
but probably less.
I spent this whole weekend fixing its just milliseconds performance.
Dude, people do that.
You can learn anything.
Just put in the time.
You can learn anything.
You really can.
Thank you for reading.
If you're interested in algorithmic trading and AI, subscribe to Aurora's Insights.
Want to see how fast Rust really is?
Create accounts on Nexus Trade today.
Interesting.
Let's see what the comments are.
Are there any comments?
I was wondering if there's comments.
Let's check out some comments.
I completely lost it in the low IQ article.
Damn.
Damn.
Dude, it's so much nicer to say the word skill issues.
Dude, I do like this.
Well, Cornell, I went to CMU.
I am a gem fellow, and I'm a software engineer making six figures.
What about me is low IQ?
Winky face.
You know, you don't need to adjust yourself.
A little word from the experienced.
You know what?
Instead of that, I'll just show you.
Go to YouTube.
Go to the Primogen.
I have a short that I thought was very, very good, which I tried to make it as obvious as possible.
I have a short that I thought was really, really good.
Right here.
We're not going to listen to it.
Nope.
Nope.
And the comments are just, man, discover asserts.
Didn't we call this defensive program?
That sounds like strong typing with extra steps, right?
Like, they completely miss what asserts are about, and they say a bunch of stuff.
So instead, in 20 years, just imagine what else this guy hasn't figured out.
So instead, you just don't respond.
Sound like you sound like a loser.
You just don't respond because, honestly, it's easier, and I'm okay with that.
And I try just never to respond because I'm just like, man, you know, it just makes you feel shitty.
And then they're like, try to, dude, it's just like, I ain't about it.
That's still, let's see, that's still not Rust.
That's just MongoDB create you're complaining about, brother.
It's pretty funny.
You're supposed to write your own errors and overload the source methods for the stack trace.
Anyhow, does a good job.
Dot context.
You can't blame Rust for you choosing the wrong language for your use case.
If you didn't care about compile time safety and needed faster iteration,
you should have known to use language like Go or Python instead.
The problem is, is that you can say these things, but often, personally,
I don't know those things until I do them and I get burnt by them, right?
Because you can generalize this advice to a whole bunch of you should haves, right?
You ought to have known.
And I find that I don't know until I have goofed up several times.
You know what I mean?
And I think that that is really, really, really, really obvious.
Only when you're on the other side.
Prime wants to agree and disagree at the same time.
Exactly.
No, I do.
I do want to agree because it is correct.
But it's so hard to tell somebody that.
You know, you don't know until you know.
Like, you know, I've known about asserts for so long.
I've seen them in code for so long.
I never used them.
Then all of a sudden, I used them and I really understood them.
Now I can't stop using them, right?
Like, you could not have explained it to me until someone named Joran,
the Tiger Beetle database guy, gave such an impressive presentation.
I said, I must be missing something.
I will figure this out.
And now that I have, now I effing love it.
Despite the fact that I've known about them for like a decade.
Oh, you too?
After Tiger Beetle?
Yeah.
It's just one of those things that's like, it's super hard to explain something until you've experienced it.
Programming the negative space article.
Yeah.
It's good.
It's very hard.
You know, you should explore and you should use technologies incorrectly because you will never know why to use them correctly.
Performance matters, standards, standard, let's see, for high frequency trading.
Yeah.
Standard algo bots that do crypto, not so much.
Okay.
Okay.
You should see the FPG and algos that are nanosecond sensitive.
Yeah.
You're talking about like Jane Street, OCaml on stuff.
Dude, it's crazy.
Been in this space for almost a decade and there are some wild stuff out there.
Rusco, et cetera, are not even considered where big money is.
Yeah.
Isn't it like just, you're burning FPGAs?
I know that when it comes to Forex exchange, it's, or Forex, it's all about, it's all about FPGAs and nanoseconds.
Sleep the beast.
Thank you very much for the five gifted subs.
Appreciate that.
Anyways, children learn by exploring.
Yeah.
And I think that's, we shouldn't discredit exploring.
We really should be very careful about that.
Don't, don't, I think it is good insights in the sense that the pit of success is extremely hard to fall into with Rust.
And I think that if you're going to do Rust, you got to learn the language really, really well to be effective.
And that is a huge danger to most people is learning the language extremely well before jumping in.
So before you rewrite your stuff, maybe spend six months really learning the language, read through the book, understand about allocations, read through the async book, understand that practice pin, pin project, all that crap.
And then once you get it all done, then maybe, you know, it can be better.
Anyways, the name is the primogen.
I don't know why I slapped my ball.
I honestly have no idea why the ball slapping just happened.
