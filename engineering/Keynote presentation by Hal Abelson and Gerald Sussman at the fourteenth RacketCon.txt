All right. I think we're ready to begin. Now, it is my distinct honor to introduce
for you here today, Hal Abelson and Gerald Sussman joining us remotely from Boston. And, yes.
Now, they are, of course, the creators of structured interpretation of computer programs,
also known as SICP, SICP, or simply the wizard book. And I needn't tell you about the enormous
impact this work has had on the computer science curriculum, both in the U.S. and elsewhere
in the world, and individually on generations of developers, including most of us in this
room. So I'm not going to tell you about their work on SICP. I just want to take a moment
to tell you about some of the other great work that they are doing, starting with Hal. So
Hal Abelson has been working for decades on making things more open, beginning with the
OpenCourseWare initiative at MIT, which was, as far as I know, one of the first or if not
the first such initiative, making education more accessible to people all around the world.
He's also worked on making the power of computation more accessible, starting with the logo project
back in the 60s and 70s, and all the way down to the MIT App Inventor project, which he's going
to be telling us about today, I believe. And he's also worked on the Creative Commons initiative,
which forms a legal basis of making educational materials and things, policing creative works
of all kinds in the public domain. So this is all incredibly valuable stuff, and I'm so
glad that you're working on this, Hal. And Jerry, in addition to his work on SICP, has also
worked on numerous other things. He is, of course, one of the creators, along with Guy Steele, of
the Scheme Programming Language, of which, of course, Racket is a member in that family.
And he has also worked on reforming the physics curriculum and attempted to introduce the scheme
programming language into the physics curriculum, specifically into the teaching of classical
mechanics and formalizing some of the procedural aspects of classical mechanics. I don't know
how much success you've had with this, Jerry, but we'd all be certainly very interested to
hear how well Scheme is doing in the physics curriculum. In addition to that, he's also
worked on fields too numerous to list from synthetic biology to working on amateur and professional
telescopes. So he really is a polymath and, you know, modern day renaissance man. And I think
we are very privileged and honored to have here, Hal and Jerry. So please take it away.
Okay. Well, I just want to say thank you. Hal and I are honored to appear before you. And
we also greatly want to congratulate you for doing wonderful work in developing software
that's clean and understandable and can help people. And I think that every software engineer
in the world ought to be looking at things like Racket to understand how to do a good job. That's
something I really think. Anyway, I will start out. Let me get my screen shared for you.
Here it is.
There we go. Okay. I presume you can see that on my screen. So of course, we are really interested,
Hal and I have both been interested for our entire lives in teaching people thinking. We got that idea,
basically, from our teachers, Seymour Papert and Marvin Minsky. Seymour actually wrote a book called
Teaching Children Thinking. Okay. And I think the most important thing that they taught us is that
programming is a means of expression in the same way that writing your natural language, English,
or playing music, or, you know, in fact, doing things like mathematics, all of those are means of
expression. And that programming is a new means of expression. And it's very, very powerful. And it's
something we should, we should learn about, and make sure everybody in the world knows about.
Okay. Now, so I'm going to proceed by giving a bit of the philosophy of this stuff. Okay.
Wait, I started out, for me, I suppose, I was teaching electrical circuits in 1974. Okay. I was teaching,
I was at my first faculty teaching, I suppose, I was 1973, when I taught E and M. But I was teaching
circuits, and I was observing, I'm a circuit guy, I'm an old ham radio operator. And I observed that
the way in which we taught this stuff was not the way the experts actually deal with circuits.
When we teach it, we put equations, node equations, and things like that. But the fact is, the experts
hardly ever write any equations at all. How come? Well, the answer is that the things that we teach are
the things you can write in English text and small numbers of mathematical equations that can fit on a
blackboard. So I decided it was important to write down these things as procedures, write down the
things that an actual expert does, and then write it as code that a student can read. And then the idea
was if a student can read that code, the student can learn the techniques of an expert. And that's
started. And of course, I did this with originally with Richard Stallman, who was an undergraduate,
graduated at Harvard at the time. And I hired him to work on things like this with me.
Next, in the 1970s, I continued this, I developed a class with Richard Adler, unfortunately deceased,
he got killed in an automobile accident. Okay, but there were students who learned about electrical
circuits and programming, we taught them with this is a 24 unit subject, it was taught by Richard
Dattler and me two years, one in 78 and one in 79. And we basically, that's twice the size of an MIT
class, we taught them how to do electrical circuits and programming by incrementally writing a symbolic
electrical circuit analysis system in Lisp. Okay, so Jerry, let me just stop you for a moment,
there is in there's an artifact on the screen blocking the titles of the slides. Ah, sorry,
I'll fix that. I will fix that. That's easy. Okay. It's a bug in the in the zoom world.
Perfect. Okay, great. Yeah, looks great. I thought it wasn't there for you. But it might be for me.
Anyway, so the next thing to realize, having spent a lot of time thinking about that, I talked a lot with
my friend Joel Moses, and we decided that that programming is really the abstract version of
engineering design. It's the fact that most of the time, you have no idea what you're trying to make
is a partially defined goal. But in fact, when somebody tries to give you specs, that doesn't
make sense. What generally is you figure out what specs you can possibly implement. Okay, it's not like
but it's not like physical systems where you have problems, like by tolerances, like the parameters have
particular values plus minus 5%. Okay, on the other hand, what we are limited by is the fact that we make
more complex things this way, we make things that are so humongous, so huge in number of parts,
that the main problem is control of complexity. And so that's a vision that I got into at that time.
Now, approximately that time, just after that, Hal and I got together and started teaching this class.
And I think the text on this slide is probably the most important piece of text that Hal and I ever wrote.
Okay, and I'm going to read it to you slowly. Computer science is not a science and significance
has little to do with computers. The computer revolution is a revolution in the way we think
and the way we express what we think. The essence of this change is the emergence of what might best
be called procedural epistemology, the study of the structure of knowledge from an imperative point of
view, as opposed to the more declarative point of view taken by classical mathematical subjects.
Mathematics provides a framework for dealing precisely with notions of what is. Computation provides a
framework for dealing precisely with notions of how to. So this is the idea is that for the first time
in history, we can write recipes, for example, that are hundreds of pages of long and make sense,
as opposed to recipes that would not take one page. And therefore, we can explain to students things
that couldn't be explained without this kind of structure. So then there was a revelation at that
time, and I want to say it actually started earlier. When I was a freshman, I was taught LISP
probably by Bill Gosper. We used to go to Chinese restaurants late at night. I was a member of the
Minsky's Hackers Group, which was a bunch of undergraduates and others who just loved playing
with computers and basically did what Minsky needed done. And the most important thing there is that over
one dinner, I believe Gosper explained to me the eval apply interpreter. Now here's, of course,
a very concrete syntax version of it. And you all know that concrete syntax is not the way you want
to do things. But in fact, it is the tightest little picture that gives you absolutely mechanical. But
what's going on is eval takes an expression environment and calls apply with the procedure
and its arguments because it pulls those out of the expression, okay? Apply takes the procedure
and the arguments and makes a new environment and then calls the vowel on the body with that environment.
That's an important loop, right? The amazing thing is that there's a very similar thing, which I learned
when I was a freshman about if this was my second term when I was taking E and M, which was that there's
Maxwell's equations. And notice the important thing here is the two curl equations. B is the magnetic field.
It says the magnetic field is coming from the rate of change of the electric field. And the electric
field is coming from, that's E, is coming from the rate of change of the magnetic field.
This is very similar to that other idea, okay? Oh, by the way, at the bottom is a conservation of charge,
which was discovered by Benjamin Franklin, and Maxwell credits him with that. But in any case,
Maxwell had this wonderful combination. He did, he made this manipulation, I suppose, on the same day
he wrote down the equations for the first time, although they were not written in this beautiful
vector notation. And he ends up with the wave equation, which is a traveling wave, okay? All of a sudden,
let there be light. That was light. And that's beautiful. And to me, the revelation was that
these are the same idea. That's the, oh, it's, it's, it's dual variables that occur everywhere in, in,
in physics and in every other kind of engineering I know of, right? It's that there's, there are things
like force and the, and, and, and distance or momentum and, and, and velocity, I said it wrong.
Yes, force and distance is energy. Okay. I'm not going to expound on that right now, but that's,
that's the idea. Okay. So the important reason for studying programming in general is that there's,
there's, among other things, amazing intellectual impact that we have on students by teaching them
and things like that. We, they get to confront all sorts of things, like what does Chicago mean?
I once had an argument with a philosopher that was almost came to a fistfight over the meaning of the
word Chicago. What does identical mean? We all only, a computer programmer understands that two
things are identical, only if modifying one changes the other. Okay. What is about the, why are
quotations special? The problem of substitution occurs. Okay. That, you know, if you, if you, um,
if you have John knows that the morning star is, is Venus, and we all know that the morning star is
the evening star, it doesn't mean John knows the evening star is Venus. And there were all sorts of
other things like that. You know, there were questions about why, why, if something is Raven is
Black. Seeing a Black Raven is evidence for that, but seeing a white, a white coffee cup is not.
So, but the next challenge is how do we teach students to think, uh, this way? And we have to
worry about, again, can the code be written and read by a student as literature of the subject to be
taught? That's the thing that I'm thinking about. And there are lots of things like that.
Say, Hal and I also taught together a class in signals and systems with Bill Siebert about things
like that. Okay. We can't do that right now. Okay. Uh, basically we have to get, get somebody from
walking into the room. Um, and we also worry about things like, one thing I think is very important
is people have made this terrible idea of thinking that you should be ashamed of yourself if you have a
bug. That's not reasonable. Bugs are part of the method of getting, of get, of making good,
good designs. That's the incremental path to making a good design is to make something that almost works
and then fix it. Okay. So I'm not going to elaborate on that because we don't have enough time today,
but I want to say that, of course there, there are bugs that don't make sense. Uh, would you like, uh,
Python is, is an example of full of, full of, uh, gotchas like this. They look at the, what,
what does this squiggly bracket mean? Is it a set or is it a, is it a dictionary? Um,
we're much worse. Uh, what about things like, uh, like the difference between a, uh, a list and a,
and a tuple, you know, in order to make it a tuple, it has to have a comma. Okay. I mean,
yeah, this is the kind of thing that when I learned this stuff, because I had to learn some Python,
I lost a half an hour just trying to figure out why my tuple didn't do the right thing. Okay. Um,
anyway, the other important thing is, is to think that if you can think about using programming as
a way of expressing stuff, then take complex, deep stuff. This is advanced classical mechanics,
where one is, you're talking about Hamiltonians and Lagrangians and that sort of stuff. And the,
the laws of motion at the level of, of no, there's a theorem for why, for example, uh, the,
you know, conservation laws are the same as, as, uh, as symmetries of the universe. Okay. Well,
these are, you start teaching that, but the important thing to realize is expressing the
methods in a computer language forces them to be unambiguous and computationally effective.
The task of formulating a method as a computer executable program and debugging that program is a
powerful exercise in the learning process. That's the goal there. And we have also been developing
with my friend Jack Wisdom, that was previously was offered Jack Wisdom. Uh, we, we want to
understand general relativity. That's very, not very easy. Okay. The math is usually impressionistically
written. It's hard to tell what was actually said. That's a, the, the math is, the math is written
to be ambiguous in the way, just like, cause math is a natural language. Okay. Well, but if you
transform into computer programs, then Einstein's field equation makes a perfectly clear, is a
perfectly clear idea. Okay. And we, of course you have to fill in all the details and you do. Okay.
So why is programming important? It provides, uh, uh, pleasures. They're intellectual pleasures.
That's why it's important to teach kids this. Okay. It's a, it also causes philosophical contemplation.
There are all sorts of internal questions you have to understand. There's debugging is fun. Okay.
And it's important as a way of making an incremental progress to getting an answer.
There's the pleasure of discovery of good ideas. For example, I did not go to explain that, but for
example, um, that high-order functions and expensable generic procedures makes automatic
differentiation essentially trivial. Okay. And the great thing about, about math is,
well, our impressionistic math, cosine square, uh, of theta is cosine theta times cosine theta,
but cosine minus one theta is not one over cosine theta. That should make a little kid in, uh, in high
school really upset, saying there's something wrong. It's not really wrong. It's a natural language.
You have to get around that. And it's nice to be able to say that precisely. And programming makes
us that, that. So I'm almost done. Got one more thing to show you. Here's, or here's one more thing that
the most important sense in the RNRS, in my opinion, is right at the top. Programming languages should be
designed not by poly feature upon feature, but by removing the weaknesses and restrictions that make
additional features appear necessary. And Marvin Minsky said to me once, anyone can learn Lisp in
one day, except that if they already know fortune, it will take three days. Okay. So, and of course,
if you want to have some fun, there's a book by Chris Hansen and I, we elaborate on better ways to make
things very flexible. And finally, I have a plug for the most, one of the most important things of
all that, that we have to make, in order to make things democratized, as, as Hal would say, to make
it so everybody can access things. And so that everything that we can all learn from everybody
else's stuff, we want to write free library software. That's like GPL. And the books I write,
and Talism too, I suppose, is creative commons by share alike. Okay. You have to say, yeah,
Sussman wrote this, but that's a different thing from you can pass the ground, modify it,
do what you like. I can see that Amaro principle. And I think you, you should really support the
Free Software Foundation. And that's all I have to say. Let me give this back to Hal.
Give it back. Okay. Let me unshare. That's my problem. There's a share. Unshare. How long did I take?
Okay. Hi, everybody. And thank, thank you for coming. I'm going to be talking about something
that complements what Jerry said, which at the root are kind of the same thing, but takes a very
different perspective. Let me share and start this. We didn't develop a food transfer protocol. I would
otherwise make tea for everybody. And it's captured in this distinction between not so much thinking,
although I'll talk about thinking, but we're now in a world where this has real implications for action.
I'll talk a little bit about the project I've been doing, which is called MIT App Inventor. But let me
start kind of where Jerry started. I showed up at MIT in 1969, which is way after Jerry. But I was lucky
enough that almost the first person I ran into when I showed up at MIT was Seymour Papert, who was,
of course, a math professor then. And soon after that, Papert wrote this amazing, amazing, amazing memo,
logo memo, logo memo number one, quote, teaching children thinking, Jerry, number two, number two,
which Jerry already mentioned. And what it said
was that this was about, as Seymour said, presenting a grander vision of educational technology.
But the point is that the technology is something that children themselves learn to manipulate it.
children themselves, right? Not researchers like us, not people in industry, but children themselves.
And what did they get out of that? A greater and more articulate mastery of the world,
right? A sense of the power of applied knowledge. He didn't talk about really understanding a lot of
things. This is really about how children were thinking about themselves as intellectual agents.
Papert, Papert came to MIT from working at the lab of Jean Piaget, who was great, great, great, great,
great, great educational psychologist. And Papert formulated an idea about the construction of
knowledge called computation, called constructionist, constructionism. Constructionism means is a theory
that says I create my own knowledge by building artifacts that I can share with people. And the
thing that we should realize is that by empowering people to be using these great programming languages,
like Lisp and Racket and Scheme and all of that, we are empowering people to construct their own
knowledge by this theory called constructionism. Jerry already saw our book. Our book,
as Jerry hinted, came directly out of what Seymour was saying. It's about how we are thinking,
but even more, how children can think about things and what children can do.
Papert was pretty amazingly, together with Marvin Minsky, co-director of the MIT AI lab. And he was also
the head of the MIT logo project, which started in 1968. That's right. And our motto there was that
computers are for kids. But think a little bit, 1968, 1970 was a really, really long time ago.
And the idea that you would take these really powerful machines like our PDP-10 and what you
would do is open them up to kids was almost heretical. I mean, people would come into our lab
and say something like, show me the robots. And there just was not the sense that these enormous devices
that we take for granted right now would be things that you'd put in the hands of kids.
That was the genesis of Logo. I wrote a book about Logo for the Apple, Logo for a bunch of things,
about taking effectively something very, very much like Scheme, Scheme with a syntax level,
and saying, how do you empower kids to be using that?
And the buzzword is, Jerry didn't quite say it, is computational thinking. Papert actually was not,
Papert was kind of the first person to popularize this idea of computational thinking.
Again, the key word there is thinking. Papert actually didn't call it computational thinking.
He called it procedural thinking, which will give you a hint of what's really important
in the stuff we're all doing. And we can list what we think is important there. There's ideas like
procedures and iteration and recursion and all of this stuff.
And a lot of what's going on in the world now, because the world now is kind of caught up with
what we were thinking in 1968, which sort of says, gee, this idea of programming and expressing things
in programming languages are actually a valuable thing to do in education. And I'm going to say again,
that was not there in 1970. It's hard, it's so long ago that it's hard to remember that.
But these days, I want to say we're in a new transition. Something really has happened over
the last two years. And I want you to appreciate that. That it's not only a question of thinking.
The infrastructure that we have right now, that kids can do, can actually make a real difference.
Not only, not only a difference in their mind and how they think about themselves,
but a difference in the world. So what's going on now is we can empower kids to really address
authentic challenges and build things that impact their life, their family, their friends,
their community, even their city and country. And I'm talking about, I'm talking about middle school kids.
Just imagine the infrastructure we built right now is so powerful that even kids have this ability.
That's something that hasn't happened until a couple of years ago. And people still don't appreciate it.
That you can, anyone in particular kids can create original apps that have societal impact,
even if they have no technical training beyond elementary school. Even young kids, they can do
this all over the world. And even in the poorest communities. Let me show you a couple of examples
of what that's like. Darvi is one of the largest slums in Asia. It's outside of Mumbai. It has about a
million people in it. The average income is about $50 a month. Right? So Darvi is, again, a major slum.
Darvi is also, is also home to the sort of the Darvi tech girls. And what they do is they create
applications and software to improve the lives of the other people in Darvi. Right? Kids. These are kids,
13 to 16. Right? Darvi girls can change. And the thing I want you to realize is kids these days can
do that. So an example of one of the things they did is they built an app that's called Pani, which
means water in their language, that schedules their family's time in the community water distribution plant.
And of course, that's really meaningful to them, because that avoids fights,
and in which arguments people might have to go there all day to wait. And of course,
for those, you know, if you're a 13 year old girl, that's meaningful for you, because who's your
family going to send to hang out at the water distribution plant and be in the fires? So this
is an immediately relevant thing that they can do. And what it shows that's computational action,
because children even in the poorest communities can make things that improve the lives for people
around them. Let me show you another example. You probably, the Eastern European country of Moldova
has been in the news because of the threats from Russia. But outside of threats from Russia, Moldova
also has a problem with hepatitis B. And there's an app that was done by, I think, three high school girls
in Moldova that says, go find a good source of water, take a picture of it with your mobile phone,
fill out some comments, there are things you can fill out like the pump handle here is broken,
or the quality of the water. And then what they can do is they can take that database,
they can take that information and add it to Google Maps. And what does that do? That means that anyone in
Moldova, anyone in the world now has a resource where they can help find good sources of water.
Right? That's not a thing that was in everybody's head even five years ago. Right? That kids can make
something that has national impact. Right? So even children can create valuable resources that have
nationwide scope, or even worldwide scope. And that should be in our, in our consciousness. When we
think about why we're doing what we're doing, we're empowering everybody, even children to do this
thing. Here's another example from from the US in Kentucky, a very, very simple lab, any of you could
make this. It's the thing that schedules that listed I take my medication. But the important part is that
was done by a fourth grade girl who was thinking about her grandfather, who has Alzheimer's. And she
said, here's something that would really improve the life of my grandfather. And I view this thing that
I'm doing as a tribute to my grandfather. Right? So this is not that it's a great app, it's how that girl
feels about her own sense of empowerment, and ability to do things in this world of computation.
So again, even children can draw on their personal experiences to make life better for others, and to
think about their own sense of power. Here's another one that comes from Hong Kong. There's a thing called
Dementia Care Companion. There's, there's a lot of concern in Hong Kong about the elderly. And this is
the kind of app that you expect somebody to have, to help them. It has locator functions and alarms and
tips. And what's really cool about it that I never would have thought of in this thing, I don't know how
many of you would have thought of it, it has instructions, and the instructions are spoken in
the, in the voices of the person's family member. I just thought that was wild, it never would have
occurred to me. And I said, well, wow, that that's the kind that would occur to a fifth grade kid,
but not to me. And it's an example of how by empowering kids to do things, they have a different
perspective on life. And often they make things that are better than we the professionals would
be thinking about. So again, that's computational action. And it's about improving the quality of life
for family members, but also improving how you think of your own ability to be effective in this
world that we're all creating. Final, final one, here's a final one. This is an app that was actually
done by MIT students, that it reads these urine sample strips, and then basically uses some AI to
read what's on the strip, and do an interpretation of the diagnosis. And there it is being tested in a
village in Nicaragua. So this can happen all over the world. And again, even students can make breakthrough
medical applications that have worldwide implications. This all works, I should mention this, this stuff
happens on our MIT server app inventor server, which actually runs out of the lab in this building, we
have a million users a month, 70,000 a day, and you can see a, you see a breakdown there about a quarter in
the US, Taiwan and Mexico and Spain, and Spain are big, big, big users, but it really is all over the
world, almost 200 countries. And that's what we're building. And that's the ability that we have to
empower people. And not only think about the great ideas that come from being able to do programming
and building computation, but the great ways that you can think about yourself doing this. Here's,
here's, here's, here's some very recent scopes that we have, there are 10 million people who've used this
system from almost 195, almost 200 countries, of which 47%, almost half are in the developing world. This is not a
thing about rich countries only, this is a worldwide phenomenon. And it's the kind of thing that we are
making possible. So again, let me go back to Seymour. Teaching children thinking by Seymour, who at the same time he was
starting the MIT AI lab and thinking about all this stuff, was creating the logo project.
And what it was about is not only ideas, which are critical, which are incredible, Jerry spoke about
that, but it's about how kids and everyone can think about empowering themselves through this technology
building. Thanks. Okay, why don't you want to share?
Let me unshare here. Okay. Well, that was awesome. Thank you so much, Hal and Jerry. So of course,
we have time for questions. We have quite a long discussion section. Please feel free to come to me.
Just come up to me if you have anything you'd like to discuss with Hal and Jerry. I guess I'll just start by
asking you this. Is Scheme still your language of choice? And is your favorite dialect of Scheme racket?
That's for me? For either of you, both of you. Well, well, first of all, if we have an echo,
what's going on here? Somebody's... Mine's turned off. Mine's muted too. Hold on a second. Both of mine are muted.
Something is making it... Well, we'll solve the technical problem first. Okay. This is not
written in this game. Yeah. Mine's muted. I think mine is muted also. In fact, my entire... So somebody
else has got a problem here. Somebody has a... Okay. It seems like if I'm too close to the speakers,
it might be picking it up. Okay. Okay. Anyway, for me, I will say that I use Scheme more than anything
else. The reasons I use MIT GNU Scheme is not because it was done by my group, although it helps,
but the main reason is because I know so much about its insides that I can fix it and change it very
rapidly. Okay. To do what I like. Okay. That's one thing. But the other nice thing about it is it's
very good at compiling numerical procedures into very serious numerical code for an x86. Okay. If I
were starting again, would be... I'm going to say something nasty. If I were starting again, we are
doing... making the stuff for SICM, I would probably be using Julia. Okay. Which is basically a scheme with...
with syntax, which I hate syntax. I'd much rather use LISP syntax. But I'd be using Julia because it's
even better at numerical crunching on very, very large scales. And many of the things I do require
large numerical crunches. I like to build, you know, I like to build things that do celestial mechanics and
things like that. Racket's a wonderful thing, but it has one problem for me. It doesn't play well with my
most famous favorite interface in the world, which is Emacs. By contrast, I know it does have an
email, there's an Emacs interface, but when I've tried it, it hasn't played well with Emacs. And I
live in Emacs. I hardly touch the computer doing anything else except with Emacs. Emacs is very
popular in this community. And you should try the latest racket mode, which is authored by Greg
Hendershot. And it's really good. It's really good. I want to do that. I haven't had the time.
Please send me email explaining... You can count on it. You can count on it.
Everyone's going to send you an email about this. Okay, fine. Okay. Because I love... Basically,
the real thing I love is Emacs. Okay. While we're waiting on more questions, I'd also like to
mention one thing, which is when I was a kid, I moved to a new town, which was Bombay,
Mumbai. At the time it was called Bombay. And, you know, I was a kid, I was 10, and I didn't have any
friends there. And I was in this big new town. And every day, I used to walk a few blocks to get to
my school bus, which would pick me up and take me to my school, which was like 15 miles away. It was
this huge, enormous, you know, big experience with little kids. And the thing is, every day in the
morning, I would walk these four blocks from my house to the bus stop. And I would be surrounded by
people who didn't have arms, who didn't have legs. And they would just have their hands out and say,
you know, and then I was this little kid faced with the daily choice of what to do with the 10
rupees lunch money that I had in my pocket. You know, should I give it to them, one of these people,
or should I eat my breakfast, you know? So it was a very interesting, formative experience for me.
And I mention it because I didn't know it at the time, but it wasn't something that was everywhere
in Mumbai at the time. I happened to be living on the fringes of Dharavi,
which is the community that you mentioned. So it's incredible that this is a community that,
you know, the world is forgotten, the man doesn't care about them. And you're empowering the kids and
the community members there to take matters into their own hands and, and, and fix these problems.
So that's, that's wonderful. Just wanted to say that.
Thanks for a great talk. I'm Sam Tobin-Hochstadt.
One thing that's really distinctive about SICP is the way that it's been used for self study and
self education by so many people around the world. And, but also it's been a popular textbook used in
lots of places. I used it as an undergraduate. So can you talk a little bit about how you think about
writing a book that's both useful for people trying to learn something on their own with maybe nothing
more than a book that they checked out from the library and also writing a book that, uh,
talented educators such as yourself can teach from.
I'm not sure it's, I mean, we, we started that book based on notes on a course that we taught at MIT.
And the thing that we forced ourselves to do in this course is to really focus on the ideas.
So that's not true in every course that you teach, but here we were trying to talk about fundamental
ideas to some really bright people who were MIT beginning students and freshmen, but we tried,
but we didn't try to clutter it up with a lot of details. So the book tries to be very clear about
what are the basic ideas. And I think, and, and also we had some really great ideas to do on. We came out
of the, the culture of the MIT AI lab where I, I guess the key idea we talk about was abstraction
and you didn't see that in a lot of other courses. Even now, if you look at, uh, if you look at most
of programming book about most languages, they're going to start by telling you what the primitive data
types of the language are, right? Pick up any book and you'll see that in the beginning. And what we,
we start by saying, what are the, uh, abstractions and the means of combination in that,
which is somewhat a higher level. And I think clearer. And I like, we certainly were very
conscious of taking that perspective when we wrote the book. And I like to think that's one
of the reasons why people are able to learn from it and people like it.
I think there's another thing going on here, which is very interesting, which has to do with,
I believe that the way we teach mathematics in general, of which I think of programming
as a kind of mathematical thing also, but we, meaning it's symbolic reasoning and things like that.
Uh, the, we teach mathematics incorrectly. We teach it as a set of skills.
Okay. Manipulate this expression, manipulate that expression, poke this thing, solve a quadratic
equation, junk like that. We don't teach it as a language. We don't teach it. Look, when I read
a sentence of English, I do not look at the characters out of which it's made. I hardly see
the characters. I rarely see even the words. What I'm seeing is a meaning. And I, I know after having
been, I'm 77 years old and I've done a lot of, of math. And I can tell you, I look at a differential
equation, it's a sentence. Okay. And it's a sentence that tells me how something moves.
And I think about the motion, not about the characters in that sentence. Okay. And I think
that's a bug. It's a bug that the, that the, that we teach, they teach math and programming and stuff
like that, that way. The wonderful thing about SICP is we don't teach people the scheme. We start
speaking it the same way you start a little child learns to speak and listen to his parents and
friends talking together. David stopped talking. Okay. David was, David came in and made a mistake.
Okay. Go ahead. All right. Any other questions? Yeah. I think we have one here.
I'm William Bowman from university of British Columbia. So I really appreciate the, the philosophy
under underlying SICP that computer science was really a means of expressing yourself. And that's
how I think about programming languages in general, but particularly because a lot of this work came out
of AI and we're now facing a new, new form of AI. Um, one of the things I struggle with when talking to
new students is they, they think this means of expressing yourself is dead. Now we can express
ourselves in natural language and all programming will be solved in natural language, which I obviously
disagree with, but I'm, um, I'm, I'm curious about your, your take on this or how you kind of address this
in the new generation of students who don't see expressing yourselves in code in the same way.
Yeah. Yeah. I'm really, I'm really glad you asked because I've been thinking about that a lot.
And I think we all need to think about that a lot because our, our, our, our, our first reaction is
going to be to resist it and say, this is, this is some fantasy of the marketing people and startup people.
But the idea you'll find some, actually some very smart people who say, gosh, the appropriate
programming language right now is natural language. And we don't want to dismiss that out of hand.
And if it doesn't work right now, you know, look, look at how, how AI is evolving and how
you can interact with things and correct them. So we're, we're playing with that again, thinking
about, uh, can primary school students express themselves in that, but I'm glad you, I'm glad
you answered it. I think it's a very, very serious question. We're thinking about this at MIT, you know,
should universities be teaching programming at all, or is there some more deep fun, deeper fundamental
thing that is not really about the syntax of a programming language, but more deeply, the ideas
that we think about in a programming language, whether or not they're expressed in the form of
a programming language or natural language. So I don't have an answer to that. But certainly,
I'm glad you asked because we all should be thinking about that very, very seriously.
And I'm worried about it too, but I'm worried about it from the point of view of, we've had the same
kind of thing with mathematics, right? Mathematics, of course, uh, it persists. And the reason why it
persists is because you can't say in natural language, some of the things you can say in mathematical
expressions. And that it's very hard to imagine saying, saying, Maxwell's equations and its
consequences without being able to do that kind of writing and reading. So there's, there are values
to different ways of expressing oneself. As again, Minsky would say, if you don't understand something
five different ways, you don't understand it. So the fact that, the fact that one kind of expression
is currently becoming more dominant again, in the computational world, doesn't worry me,
because all of the ways of expression will be necessary.
Hi, I'm Greg from the, a student at the University of Washington. So you've mentioned, uh,
difference between programming and mathematics several times. My question is, how do you feel about
proof assistance, such as the lean programming language or proof assistant?
I can say one thing. It's great. It's wonderful that there are such things. Okay. I want to be very
careful, uh, about that. But being able to, proofs are good. Okay. And everybody does them in the even
in their heads when they're writing programs. There are cases where it's essential that something be true
and correct. For example, a garbage collector. But that's a small program. Okay. It's a one-page
thing. If that isn't right, you can't debug the system because, you know, you've thrown away the
information. You get, you clear your memory or something. But the other, but the honest answer is
that in order to use a proof assistant or anything like that, you need to have a specification.
And some, some of engineering, yes, you can specify something. You get a, you get a, you start with a
specification and you develop an application or a mechanism. I'm thinking about electrical circuits
or whatever. It doesn't matter. You know, the signal processing systems, things like that. Other times,
in the game, the same subjects, electrical circuits, you, you figure out what you want to, what you can
build. And as a consequence of that, you figure out what specs you can achieve. In other words, you're doing,
you're doing exploratory engineering. Okay. And in that case, I don't think it works very well to do
it to try to group proofs because you have no idea what you're trying to achieve until you've achieved it.
Okay. A beautiful example of this is, it's easy to specify that a chess program plays legitimate legal
chess. It's very hard to say what it means to play good chess. Okay. Does that help you?
Is that a reasonable answer to help?
There you go.
Any other questions?
Um, let's see. I guess, uh, you mentioned how you'd like to see scheme as,
you'd be a ladder. Oh, yeah. Let me get away from the speakers.
Yeah. Yeah. You mentioned, Clark,
I'd like to hear you a little louder. Okay.
Yeah. You mentioned that, uh, you'd like to see scheme as a way to describe, uh,
formal mathematical language more precisely. Um, do you see room for other DS DSLs domain specific
language? Excuse me. That might be, um, more appropriate for certain fields, um,
in mathematics in general, or yeah, how do you see that working out?
Well, what do you, I'm trying to think of an example of what you're talking about.
Yeah. I guess, I guess what I'm saying is because you mentioned in other places how mathematical
formalism itself is kind of a, is a language. And, um, in many cases, it isn't precise enough or explicit
enough, whereas scheme is, um, so could there be cases where we could have similarly explicit
languages for certain subfields that are also, you know, not necessarily scheme could be something.
Sure. Well, there are important things that we don't have. Okay. Uh, that are essentially,
look, when I'm thinking about some mathematical system,
okay. I'm often thinking in terms of pictures. Okay. If I'm looking at something about a topology
problem. Okay. Then I'm drawing little open sets, you know, things like that. And, um,
I'm also also drawing commutative diagrams. Okay. And I'm doing that in my head, maybe on the chalkboard.
I like chalk. I don't like whiteboards. Okay. So I, you know, like I'm drawing these pictures and I'm
reusing my visual system to help do the reasoning. We don't have very good interfaces for describing
that kind of stuff in appropriate for, for doing computational work. So for example, okay. I'm
imagining it was supposing someone says, oh, ah, somebody's telling you the time is running over.
Yeah. Okay. Okay. But, you know, supposing someone says, uh, there is a continuous,
continuous function between two, you know, two topological spaces. I'm immediately seeing a
picture of two blobs. And there's, I see for every open set in the, in the target, there is a,
an open set in the source. Okay. It's a picture. You see, and how do I capture that? The mind's eye.
Okay. And that's not just good for math. It's for everything. We don't have that kind of, uh,
flavorful, uh, flavorful language for describing things that are essentially spatial and that
depend upon our visual systems to do a lot of the, a lot of the hard work.
At the same time, there's a lot of work going on in generative AI that's creating those kinds of
diagrams. Yes. From, from, from pictures and things. So don't, don't knock that, that could,
no, I didn't knock it. That could easily exist in, in a couple of years. I hope so. Yes.
Makes sense. We have some questions on the live stream. Well, first a comment. Without a doubt,
the SICP book has had a lasting impact on how we think about programming. So, of course, um, looking
back, what are your reflections on the book's influence and what, if anything, would you change or add to it
today? Well, even, I mean, even after we did it, we didn't do anything very much. We didn't do, never
did anything with types because we sort of, uh, we, we sort of don't, don't like that sort of thing. We
didn't do really anything with classes. You know, our, our chapter three in SICP was one of the first
thing that started thinking about object oriented programming. So we talked about that, but we
didn't talk about, about classes and the way you organize things like that. So I would think if we,
even shortly after the book was published, we said, boy, we didn't talk about that very much.
So I'd certainly be talking about that as an organization, as a way of organizing ideas. So
that's the most obvious first one. But, you know, since then there are lots and lots of things that we
could talk about, we've said that book says nothing about user interaction, right? If you learn SICP,
you just don't think about user intact interactions at all. And those are becoming even more important
than they were. So there's a lot of stuff that, that if we were doing this again, we would put in.
Well, I would want to say that I'd be careful not to put too much into one bucket. What I hate is books
that are a thousand pages and cover everything, right? But it seems to me very important that what
we did was a good kernel, okay? If somebody wants another book, I think, or if we wanted to write
another book on this stuff, we would want to write a book about what Hal just said. But I wouldn't want
to say that that's equivalent in the sense for the, for a kernel thing. I think what we have there is
good as that is good as it could be. That's why we never did any further modification to it. So yes,
there are things that we didn't talk about. But again, chicken, kitchen sink books drive me nuts.
That's very fair. That was a comment from Gabby Corona. We have another comment from Hunan. So cool to
see the goats. SICP is a book I return to for inspiration and enlightenment. Grateful to Brian
Harvey, whom I believe is the professor at UC Berkeley, for opening this world to us students.
That's right. That's right.
And there's, there are two questions that are closely related. One from Gabby Corona and one from
Armin Kay. What is the future of MIT scheme? In my view, it's the only scheme done right.
And the related question, what is your hope for the future of scheme languages?
Shots fired.
I don't think scheme language matters much at all. Okay. I think that what matters is the ideas
that are expressed. I put what I thought was the most important thing is what I said in the
one pointed at the R4RS or RNRS statement, that the most important thing is to not to remove features.
Okay. And keep, and keep the language very simple. So that, so that the only, the only features that
are actually there are the ones that are needed. Okay. It's a, you know, making something very complicated
is a bad idea. Now, MIT scheme has the problem that the maintenance of it is not by, is by a tiny
committee. Okay. Basically a few people who say headed by Chris Hansen. Okay. That's, that's, and that's not
good. So it can't last forever. Okay. Then again, I can't last forever. I'm 77 years old. Okay. And I don't really
care very much about, about, about that programming language except, or system, except for the fact
that I use it a lot. Okay. It works well. It works extremely well. And it has, it has some amazing
features that most don't have. But the, but the real story is that the language, what matters is what
we, what is the ideas. Okay. And I hope that the, the ideas survive. And I think the ideas are mostly
the ones that come from the original list. Way back from the time of John McCarthy and his students. Okay.
It's not me. Okay. Yeah. I just want to underline what Jerry said about the key thing being the ideas,
not really the syntax and the language in which they are expressed. And going back to what we were
saying before, it might be that the appropriate way to be expressing those ideas is going to be
natural language. I don't know, but there's certainly a lot of people working on that.
Yeah. I think natural languages too, is not dense enough to write very complex things like
programming languages. That's the problem. Yeah. Yeah. The nice thing is like when people
try to make graphical interfaces to programming languages. Okay. They, there's not enough space.
The reason why computer say, uh, designs of large electrical systems are generally mostly,
most expressed in, in text, not in, you know, in textual descriptions, like, like, uh, uh, design
languages. I forget the names of some of them, but right now, but they, they, you don't, you draw the
schematic diagrams only for little parts because you can't make a schematic diagram big enough.
Okay. Physically that a person can look at. And the reason why text is so dense. Okay. With textual,
a hyper, sorry, formal textual language is a powerful thing. And that can't go away.
I have a question here.
Jason Heman, Seton Hall. Um, I wanted to ask a followup that, uh, design philosophy that you
described that I think so many of us respect, uh, doesn't seem like the foundational design to Python.
And yet, MIT has gone that direction for a course that I know you both love very much.
Why is that the right thing to have done?
It's complicated. Okay. I, I think the answer is not that, not that, uh, Python is in some sense
a better language. I think it's a much worse language, uh, than the scheme. Because partly,
partly because it's, it, it's complexity and in particular its inconsistencies in its syntax
make it harder for students to learn. Which means the amount of time wasted on learning the syntactic
structure that could be going into teaching ideas is, I, I, I've taught it. So I, I've seen that. Okay.
That that's a real, a real drag. On the other hand, there is one special thing that, that matters.
Okay. Which is that it's got access, it'd be an automatic access to everything in the C library,
basically, because of the huge number of, of, uh, interfaces that were built to be people all over
the world. Okay. That was partly because of, I suppose that was partly because of the fact that it got
adopted by Google early. Now, uh, engineering has a tension in it that's always been there
since the beginning of time. It's the tension between the applications that are desired and the,
the, the, uh, what you, what basically industry wants the engineers to be. What they want them to know
when they graduate, when they go in for an internship, for example. Okay. Or versus the,
what we call engineering science, which is the foundational material. That tension is a,
is a pendulum that goes back and forth over time. Uh, when I was beginning, uh, when I was
at the beginning undergraduate, although I was in the math department, the electrical engineering
material was mostly about rotating machines. And, you know, about how to make magnetic field, uh,
make, make, make, optimize, you know, coils to make magnetic fields right and things like that.
Okay. That's what industry wanted. Okay. Then there was a revolution started by,
I suppose, people like Gordon Brown and, uh, other, uh, some other powerful people,
Ernie Gilliman and things like that, which was called engineering science.
And then there were great textbooks written on that by, by people like, like Amar Bose and, uh,
uh, uh, Ken Stevens on electrical circuits. And that was dominated for a while. And then it goes back,
you know, you know, all of a sudden CMOS became so important that that became part of the, of the,
of the, of the introductory curriculum, even though it actually is very distracting,
because bipolars are easier to work with from an intellectual point of view.
Okay. And you know, what's happens is that there's this fight between those two things right now,
every student wants to, it wants to have, have, uh, have preparation so that when they, that next
summer, they're going to get a, uh, $10,000 a month job from Google or something like that,
or Facebook or whatever. Okay. That's a pressure. That pressure is, is dominant right now.
On the other hand, when Hal and I were beginning with SICP, the other, the engineering science part
was dominant, partly because people like, like Amar Bose and later Bill Siebert and people like that.
So it's a historical thing. It's always been like that. And I expect it will always be.
Is that right, Hal? Well, I mean, I expect, I mean, I think what's going on
is there's this tension between wanting to be clear and minimalistic. That's kind of the,
the philosophy that, that is in scheme really about what are the fundamental ideas and do that
versus the world is now getting enormous in terms of what people want to do.
So one of the things that scheme does not have, at least in the way we did it, scheme does not have
the include statement, which is critical, critical to the way people are doing Python right now.
Right. So when you, when you're first learning, the question is, do you want to have the fundamental
things so you can construct what's going on? Or do you want to sort of say there's this enormous world
with millions and millions of capabilities, and I can simply put, put them into my system. And that's
the tension that's going on. And that's a really important kind of pedagogical set tension for
those of us who are teaching things. That's also true. Right. Right. So I don't know where that ends
up, but it's a real tension that's there. Since we're celebrating 40 years of magic, I also want to
bring it back to the book for a moment. I think it's Patrick Weston at MIT who's fond of saying that in
order to understand something, you need to understand it at the level of its presentation
and also one level below. So with that in mind, when you were writing the book, how did you,
how did you do that? And are there any fun anecdotes that you'd like to share about your time writing
the book? Well, well, I mean, the critical thing for us is we wrote this out of teaching.
That's right. That book was, what, the third revision of notes that we had put out for the
course? Right. So anything that went into that book started out by having to be something that could
be explained to students. And that really, really dictates the style of the thing. It made it partly
minimalistic and partly us choosing to really say you have to explain stuff. And Patrick, you know,
Patrick is absolutely, absolutely right about that. And indeed, that's, again, historically
appropriate. Other books that I've, I learned from, for example, the Bose and Stevens electrical
circuits book, okay, which is, it's called introductory network theory or something, is an example of a book
that was written by Bose because he was teaching the introductory circuits class. And he was writing down
his ideas and how you teach that stuff. I certainly, the stuff I've done with the Jack Wisdom is exactly
the same thing. We taught the class for many years before we wrote a book on advanced classical mechanics,
analytical mechanics. So it's the idea that this is what we tell students. Now we have to be very
precise and write it down very, very carefully, so that so we're capturing that those ideas.
Right. Any other questions? I think we have someone, a caller who'd like to join remote caller
or callers seven. Well, I guess we'll wait for them. But in the meantime,
oh,
yeah.
We have a meeting, hold on.
Surprise.
Surprise.
Surprise.
We're in the middle of it. Okay. We're having people coming in with a party.
You guys can come in and, but say hi to everybody because we're in the middle of giving a lecture.
We're having a party.
Hello.
Hi, everybody.
What's this party about?
It's for you.
It's for you guys.
It's for you guys.
Surprise.
Well, we've been picking them out all day. Okay.
Sorry, everybody, but come in. Okay. Yes.
Oh my gosh.
Anyway, all you guys, we were, we, we certainly had no idea this was going to happen. Yeah. Okay.
We have gifts.
Well, that is a wonderful community you have there because they organized this in a few days.
Thank you. Thank you.
And I believe.
Okay. We'll find out what it is.
Yeah. It should open it.
Yes.
You should open the liver.
Okay.
To figure out how to open these are not damaging those.
They're unfortunately very well-lapped.
Okay.
We'll have to figure this out there.
Oh, I see the method.
Here's the method.
I found it.
I found the, I found the key.
Okay.
Sorry, sorry, everybody.
We, uh, yes, we, we, we were, we were talking to the people.
By the way, I hope everybody there is enjoying this discussion.
Yeah, no, of course.
Of course.
These are all the conspiracy.
So we're very much enjoying this.
Somebody could actually, the person who's on the, who's holding the cell phone.
Is it possible to go behind?
Oh, it's a goodie.
Yes.
I'll, I'll open yours.
Open mine.
Do you need help?
40 years of magic.
By Racket Conn.
Oh, man.
Oh, the thing from Racket Conn.
Yes, from Racket.
Thank you, everybody.
Whatever it is.
Okay.
It's a music box.
A music box.
Okay.
House is kind of tight.
Oh, no.
I had no idea this was going to happen at all.
What's the way it plays?
Oh, no, you need to put the.
Oh, it's got a roll in it.
I see.
I understand.
Okay.
Thank you.
No, no, Jared.
It's this one.
That one, I think, is if you want to make your own music.
Of course.
How do you, well, I used to punch cards and I used to punch, actually, paper tape.
Way back in the beginning.
That's what we were counting on.
Wait.
Oh, let's see it this way.
And then find the thing.
Got it, got it, got it, got it.
Thank you.
Oh, that's cool.
Oh, wow.
Thank you.
Thank you, thank you, thank you.
You got to put the tape in.
Oh, there's a, there's tape, Hal.
There she is.
There it is.
You got to put it in.
Thank you.
I got it, what?
Wonderful.
Oh, I got to put it in there.
Put it in there from the end to the end here.
It's an old, it's like a punch card.
Well, that's, that's an amazing, an amazing outcome that we didn't expect.
There you go.
Yeah.
Yeah, I think Hal, you got started in computers with a summer job with paper, punch paper tape, right?
And a whole little blank tape you can make your own, if you want to make your own music.
Yes.
I should tell you, by the way, that this brings back memories of punching tapes for the PDP-6
before we had anything with punch paper tape, okay, way back in 1964.
When they, with the PDP-6 had no software on it, and they had to have a loader, the loader would read a paper tape.
Can you show the tape to the camera so that the audience here can see what you're talking about?
Oh, how wonderful.
That's the bottom of the tape.
The tape.
The tape.
The tape.
Yes.
Oh, here's the piece of paper tape with holes in it.
Maybe finally you should.
Yeah, I can.
Yeah.
Here.
Close it.
Oh.
Oh.
Yeah.
See?
Yeah.
Okay, paper tape with holes in it.
All right.
Okay?
And I certainly, yeah, I certainly have punched paper tape.
Now you have one.
Thank you.
Okay.
Very nice.
You have your very own music box interpreters, so, you know, go file.
Okay, well, now we have to run a program to run a little machine that runs the paper tape punch.
Sorry for the bloopers in between.
That's all right.
No, no, no, no, no, no, that's fine, that's fine.
It's a little technical.
Okay, that's all right.
Yeah.
Okay, so is there anything else anybody wants to ask or talk about?
No, I think that's it.
You all can feel free to continue with the revelry and, you know, watch on the live stream if you
want.
We'll still be streaming on con.racketlying.org.
And thank you so much, Hal and Jerry, for joining us.
Congratulations again, 40 years of magic.
Okay.
Thank you.
Thank you, thank you.
Thank you, and it was fun.
You all.
Okay.
Welcome to Broadway.
We'll be right back.
