You have to get to a point where the agent is actually an accepted team member that can contribute code.
Prior2Day can help you to diagnose your problem.
I think we are going to get to a stage where instead of me filing an issue, I just use Copilot and NSV agent to make the change.
I think we're heading into an era where people truly just provide apps for themselves that are just for them and their friends or their family.
So let's dive in and we'll talk about this.
Thomas, I'm super excited that you're here and chatting with us.
I feel like GitHub has been on a roll, has had a ton of incredible product releases over the last six months around AI.
Can you just give us the lay of the land?
I think people are super familiar with GitHub Copilot.
It's been around for a long time.
It's super widely used.
What are the highlights as far as new product releases you all have been doing specifically in the AI space?
Oh, gosh, that's so much to talk about.
Well, first of all, thank you so much for having me.
I'm so excited to be here with you all.
And, yeah, you know, it's been a journey for us since we started with Copilot.
It's now almost five years ago, June 2020.
Now, you know, when we're recording, this is February 2025.
Back then we had JCPG3.
You know, we played with a model.
We worked with OpenAI to fine-tune a model that then was called Codex.
And really it was just auto-completion, right?
Like we brought AI into where developers are writing their code, you know, predicting the next line, multiple lines of code test cases.
And really quickly it became very obvious that this is incredibly helpful for developers because they stay in the flow, right?
Like instead of you going, you know, from your editor to the browser, and Nolan mentioned, you know, before we started recording how many tabs he has open, right?
Like we all do, you get distracted by all the things that are happening in your browser.
So by the time you're back to your editor and you're copying and pasting something, you know, off of a blog or a Reddit post or GitHub, obviously, you lost that, you know, train of thought that you had or chain of thought as we call it now in the models.
And then came SAP GDP, right?
And that changed everything for the industry.
And obviously we brought chat into the editor, giving it all the context of all the files you have opened, the debugger, the terminal.
And then if you just look into the last, you know, six months or so, it's become obvious that first of all, we're moving from one model to a set of models.
And, you know, we have now in Copilot, OpenAI, GPT 4.0 and 0.1, 0.3 mini now, and then 0.1 without mini, and Cloud 3.5 sonnets.
And since last week, we also have Gemini 2.0 and Flash available.
And just, you know, as on GitHub, right, we wouldn't run GitHub with just one open source library where you get React.
And if you don't like React, well, tough luck, you have to go somewhere else.
And we believe that developers want choice and they want all these models available and pick the right one.
And they probably have their favorite model.
And then once you, you know, started using it, you kind of like figure out how it works and you can kind of predict what it can solve and what it cannot solve.
So that has fundamentally changed, I think, over the last six months.
And, you know, just, you know, a couple of weeks ago with DeepSeq, the whole game has changed again, right?
And the second is that, you know, we're moving from kind of like AI-infused to AI-native workflows and agents.
And, you know, these agents are still, you know, in the early stages.
And just last week, we announced Agent Mode and VS Code.
And so you can now not only ask questions and chat answers, you know, how to solve that problem and actually can generate files and modify files.
And it can give you, you know, a comment line commando and then can say, okay, I want to run this.
And if not, then not, right?
Like, so if it moves all your files, you can say, well, maybe not.
Let me try again.
So it's still in control, but it shows you kind of like that journey that we're on.
I like to think about this as like driver assistance systems in your car, right?
Like as long as full self-driving only really works when you're in a Waymo in San Francisco, you need still controls like a steering wheel and need to pay attention.
And the car tells you to pay attention, right?
And same is true for these agents.
Like while there is certainly that vision on the horizon where the agent can solve things on its own, in the meantime, we need these more agentic workflows where you as a developer
stay in charge.
Yeah.
And how do you think about, you know, there's obviously tons of, tons of super, super interesting products being built in this space.
GitHub is making some of those products.
Like, how do you think about like what the opportunity is for, for GitHub to build some of this stuff versus like, you know, problems you want to stay away from and like let the rest of the ecosystem solve.
And like, even from the browser perspective, like obviously co-pilot is like a core part of VS Code, but like VS Code is a, you know, a Microsoft product, if you will, or an open source product, if you will.
Like it's not a GitHub product.
Like, how do you think about that tension as you're figuring out like what level of detail to go and build some of these experiences in?
VS Code is, you know, in a way, our sister team within, within Microsoft, you know, we're sitting in, in a new organization that just got formed about a month ago called Core AI.
And so we have VS Code, GitHub, the regular Visual Studio.net, and then the AI side with the Azure AI service, AI Foundry, those things, we're all sitting in the same organization.
So that kind of like describes, I think the pieces that we want to cover, which is the AI stack from the, you know, infrastructure platform layer, if you will, responsible AI inferences, evaluations to the, you know, IDE platform layer.
You know, extensions that you can build for VS Code or for GitHub, all the way up to the GitHub layer, if you will, the DevOps layer where your software development lifecycle exists.
And then on top of, obviously, we're building a lot of tools that you can use to build your own applications on top of that stack.
So, you know, as of today, we are leveraging others to build these models, whether it's OpenAI, Cloud, or Google, or DeepSeq, you know, we have a whole model catalog.
Obviously, Microsoft has some smaller models, like 5.4 as well.
But then on top of that, that's the stack that we are thinking we will cover.
And some of that we do under the GitHub brand, some of that we do under the VS Code brand, and some of that we will do under the Azure or, you know, more generic Microsoft brands.
One of the questions that actually, like, Nolan and I spend a lot of time, and I don't know if, like, yeah, me and Nolan have both worked at NumFocus for a really long time.
I've been on the board.
Nolan drives our sustainability efforts at NumFocus and provides the financial legal infrastructure for open source projects like NumPy, SciPy, et cetera, et cetera.
And we were actually last night, Nolan and I were having this conversation about open source sustainability and sort of where the world of AI goes to help and potentially, like, help augment the work that maintainers have to do.
And I'm curious, like, I think GitHub has been in this position providing the sort of infrastructure, frontier infrastructure in many ways, like you have done a bunch of grant programs and other things to help make open source more sustainable.
And I'm curious, like, how the sustainability angle plays in with some of this AI tooling, specifically for the maintainers of a lot of these projects.
I think one of the biggest problems that maintainers face today is just as soon as your open source project becomes successful, which ultimately is the goal when you start working on open source, right?
Like you have this idea of building something, then you make it open source, and you have that dream of, you know, getting some tractions, you know, gaining stars, having others talk about your project.
And ultimately it's a way for, you know, software developers to gain reputation or status, right?
And the stars and the followers that you have on GitHub for many developers is as important as the number of followers that you have on Axe or, you know, Blue Sky or Mastodon or whatnot.
And then, you know, your project becomes successful, and now you're flooded with issues and ideas and questions.
And even if you're more successful, people, you know, forking your project and sending you back pull requests, and all of a sudden what you thought is amazing becomes, you know, a burden on your life, especially when it doesn't bring you a revenue stream.
And when you never intended to make that a business because you love your job or you want to actually work on some other startup idea, right?
That's what we often see in open source is that those that, you know, are powering the internet, there's this, you know, meme, this graphic where it's kind of like a stack of blocks.
And right now there's this little piece in open source maintainer in, I don't know, Nevada or something, right?
Like that, if that breaks apart, like a Jenga tower, the whole thing falls apart.
And so if you think about AI and agents, how will that help is that hopefully they can pick up some of these issues and help them maintainer do their work without, you know, going through, you know, each of these issues and figure out how to implement that.
Is that actually valuable for me, it could be, you know, on the issue side, by citing the issue, it could be just by automatically implementing that and creating a pull request and say, here, you know, updated to the latest version of some open source library you're using.
It could be in reviewing the code, you know, that came from a fork through pull request and providing feedback to the person that forked your repo, right?
So that way you have that feedback loop before the maintainer has to wake up and do that all manually, all the way to, you know, fixing security vulnerabilities and kind of like reducing the boilerplate that an open source maintainer, you know, has to naturally go through as the software survives for, you know, years, if not decades to come, right?
Like that software is stale really fast.
There isn't really much software that can just remain unchanged forever.
And so you have to constantly keep maintaining the thing.
And so leveraging AI for a lot of that, so it can gain back some time to do creative work, I think is the biggest impact that can AI can have on open source.
When we talk about this future of agents and of, you know, having, you know, a Jarvis in our ear or whatnot, we also have to be real that like a lot of problems are just very simple and we still haven't solved them.
Like how often are you on a call and you're muted and somebody else will tell you, hey, Thomas, you're muted.
You know, how often is your internet connection unstable?
How often do we work in code bases that are so outdated that, you know, the dream of AI modernizing all that is just still years away?
Yeah, I think that's such a great point.
I think the other thing that this makes me think about is just like how much the sort of social contract of the internet relies on the idea that there's like another human at the end of some action that's happening.
Like that is just like the fundamental reality of the internet with the exception of like crawlers, which there's sort of a well-established like internet substrate for like crawling infrastructure.
And I think this is going to happen now with agents where like, you know, I can imagine a world where there's, you know, however many hundreds of millions of developers on GitHub, but there's actually like billions and billions of agents roaming around the internet.
And like, they're kind of like poking and prodding at a bunch of these different things.
And I'm curious, like from a infrastructure standpoint, from like a social contract standpoint, also from like a security standpoint, like how, how do we navigate that world, especially when like so much of the like critical infrastructure for, for the world is now like living on GitHub with, with open source software.
You know, I think the way, you know, I'd like to look at this is that in, in many, you know, regards, we already have that world, right?
Like we're running millions of, you know, CICD processes, automatic build processes, automatic testing processes, whenever we push code into a repository on, on a recurring basis.
And, you know, in many ways, that's just nothing else than an agent, a simplistic agent, you know, has, doesn't have a lot of intelligence, but, you know, it reacts in an environment.
You push code, it takes that code, it does something in a virtual machine, which is exactly what an agent does as well.
It compiles this, it tries to figure out growth steps step by step.
And these steps are hard coded, while for the agent, they are somewhat variable.
They're coming out of the model instead of out of a script, right?
And then at the end, you get a log file and the result, and then you have to kind of like figure out if the result is not what you expected, what happened in the log file and you scroll through that, which is exactly what, you know, how these agents work when you, whether using chat GPT or copilot or, or agent mode is like, as long as it works and your output is exactly what you expected, that's cool, right?
Like, as soon as it doesn't work anymore, now we have to scroll through endless lines of log files, which look no different today than they looked 20 years ago when you did make on a make file or configure and it didn't work.
And so I think, you know, in many ways, that's why AI is so successful for software development already, because we have been preparing, you know, us for that world by, you know, establishing processes like DevOps, Azure development, you know, unit testing, quality gates, you know, not pushing into the main branch without a human review and a pull request, CI, CD, all these kinds of things, right?
And on the other side, I think, you know, we, we got to think about that future of agents where the agent needs to be predictable, right?
Like I need to know before I spin off an agent, whether the agent can actually solve the problem I have, like you can today, you know, go into, go into copilot and say, Hey, book me the code for GitHub or Facebook or whatever office.
And it obviously won't do anything meaningful, it probably gives you something and then you can iterate from that, but you don't, you quickly, you know, put yourself in a corner that you can't back out of and then you're like, ah, screw it, I start fresh, right?
So it needs to be predictable.
And so you need to know before I get started, because when I, once I'm starting and the agent is running, I'm wasting compute, right?
Like the longer this thing runs, the more money or time I have spent.
And then it needs to be steerable, right?
Like I need to be able to specify what I want, combined with predictability in a way that I know what the output will be.
And you often hear folks saying, you know, the agents will replace the junior developer.
And in my head, I'm like, well, but how long can I send a junior developer off to do a task until I want to check in with that junior developer and say what I've been doing, right?
Like it's this feedback loop that is even more crucial for a junior developer than it is for a senior developer, right?
So I need to be able to steer the agent.
I need to verify the output of that, right?
So predictable, steerable, verifiable.
And then it needs to be, I need to be able to tolerate it.
Like it needs to be like in such a way that when I send it off and do some work and it comes back and files a pull request, you know, which is something we showed recently where you take an issue with an agent all the way to the pull request.
And the pull request looks like, you know, a human would have filed it, except the copilot filed it, right?
That output needs to be tolerable.
Like if I look at this and like don't find it useful and then have to basically give it so much input that in the time that the agent actually did the work, I could have done it myself.
I will not use that again, right?
And so these four things need to be all true until we act the point where an agent can actually take over software development tasks.
And so right now that's very small tasks.
And the more complex they get, the more, you know, the more you're wasting your time.
Yeah, something this makes me think of, and maybe this is a horrible idea, but I feel like the AI agents having the sort of a publicly visible GitHub contribution graph is actually like this kind of interesting eval that I think like developers are really, like when I see an open source pull request, like almost one of the first things I do is like, who is this person?
Like, should I even spend the time to like invest into, you know, merging this pull request, reviewing it, et cetera, et cetera.
And I feel like that'd be an interesting mechanism to like assess the quality of, you know, the given stance of where AI is today.
I'm curious if you all have pushed on that, like contribution graph sort of publicly visible eval in order to ascertain, like what is the actual capability of an agent today?
You know, if I think about this, you know, when you do it as a human, right?
And you file, I file a pull request against your project and you don't like my code, you give me feedback.
And then as a human, I'm able to adjust to your feedback or I go away and say, well, Logan doesn't, doesn't like my style and I don't want to adjust, you know, to his style.
And so we part ways and that often happens in open source as well, right?
Certain communities have certain ways of collaborating and folks that don't like that style and go off and do their own projects.
And often we then see also forks in the road for, for some projects agents, you know, today don't have that feedback loop, right?
Like you can give them feedback to kind of like steer them into the direction you want them, but like ultimately the agent doesn't have social behavior.
They're, they're not, they're not a team player, you know, the, the gamification, you know, of the, the team construct where if, if you're the new developer in the team, the existing team members, you know, set the standard for you.
And in your first week or so on, on a project, you kind of like learn and you're careful, you know, of how you're learning within the team, um, because they're raising the bar for you until you made it and that, that your pull request gets merged.
Right.
So I think that's where, you know, when we think about these agents, that's where we have to get to the point where the agent is actually an accepted team member, uh, that, that can contribute code.
Um, and today that, that happens right at the auto-completion level, right?
Like it's very, very simple feedback loop, uh, while you see something and you press the tab key and, and accept the code, and then you can, you know, use the cursor or the mouse to, to edit, edit that code, which is a, you know, learned behavior for software developers.
As we've been doing that, um, you know, for as soon as, as soon as the internet came, actually before the internet even came, you typed listings, uh, from magazines and books, right?
And then you modified those listing and, and made them work within your application.
And it was frustrating back then because you couldn't go and, and ask somebody else, uh, whether a human or an agent of, of, of, of solving a problem.
And that's where the agent, uh, uh, today can, can help you.
The copilot today can help you to, uh, diagnose your problem.
And we didn't have that capability over the internet.
But I think it's this, uh, learning of, um, where these agents work today and, and, and involving them from, from that place.
Um, is, is, is crucial instead of jumping ahead into a future, uh, where you believe, uh, all the tasks, all the issues that you file can just be implemented by magically, uh, by software and, and, um, by a software or three agent, you know?
Um, I think that's where the, the, the engineering challenge is today for us at GitHub.
Yeah.
It's a conversation that back to the conversation Nolan and I were having about sort of open source sustainability.
One of the things we were talking about was how much, uh, the sort of input of a lot of these, like code creation artifacts matters, like even more in the world of AI.
I think like you sort of, there's a lot of human intuition that goes into like, oh, I see a GitHub issue.
It's like kind of opaque, opaque, the maintainer, like put a bunch of random contacts that like maybe doesn't make a lot of sense unless you've worked on the project before or something like that.
And then you sort of taken agent, which today I think like, you know, all AI systems, like start from zero, like they have absolutely no context of this thing.
Like they only have the context, which is given to them.
And like, if the only context they have is this really opaque, um, you know, GitHub issue that like requires the nuance of, of some repo, it's really hard for them to do an effective job.
And I'm curious how you like, um, how much of this is actually like an AI code generation problem versus like helping people to do all the, like, you know, sort of traditionally described as like soft skill things that software engineering folks have to do, which is like document things.
Well, write out a plan, you know, have the interpersonal human connection between other people.
How much of that is, um, actually a product problem that still needs to be solved to make this like code generation use case work really well.
A lot of it, right?
Like in, in many ways, you know, the copilot has the same challenges as the human, um, most projects are large and figuring out which files actually implement the current behavior and have to be changed for the new behavior of an issue, uh, is, is hard for human.
And it's hard for, you know, an agentic developer in the same way, let alone that, that obviously the model has, um, you know, limited, um, uh, context window and then figuring out which parts to stuff into the prompt and, uh,
which parts to leave out that still an unsolved challenge and, uh, uh, you know, the, the larger, the model repo, uh, uh, that, that you're working on the, the harder that gets.
And so, um, you know, since last year, we, we, we have a product in development called Copilot workspace that literally puts you as the developers at the center of that agentic workflow.
And, and so the first step when you file an issue is that it actually writes you a spec of the current behavior by analyzing the code that is in the repo.
And since the bullets, you know, describing previous state and new state, um, uh, based on your description, and then you can edit that.
And so it's literally like a bulleted list in, I don't know, notion or, or your note sheet, right?
And you can just edit that, that, that, that, that bulleted list and say, well, that's actually not the behavior I wanted when I described the issue.
It also has a brainstorming mode where, you know, can give you more ideas of what else you could do.
Uh, and so when you think about just that step of that workflow, but helps you to write better issues.
Uh, but it also then gives you a path to, okay.
So plan out these changes in, uh, across all the files and it shows you which files to modify.
And you can say, well, you know, add the readme file, update that, or, uh, consider the files in the test folder, um, uh, things like that.
Right.
And then you can ask it to implement all the changes and, and run the thing and, and works well for web applications, right?
Because they, uh, this is the flow that is in the browser, um, with the cloud environments.
So if you're working on a web-based application, you can just run the thing and, and look at the preview, and then you can file your pull request.
So instead of you filing an unspecific issue, you know, by starting with an issue and using Copilot workspace, you can actually file a full-scale pull request that is based on the code base by AI.
Yeah, the AI, you know, the copilot looking at the code base and your specification, helping you to that, to that workflow.
But, you know, you as a human needs to, need to steer it along the way.
Like there's, you know, if you, if you go through that workflow, you'll, you'll quickly have to learn a new way of software development, uh, where you have to read all this, you know, all these description that the AI, that the large language model, you know, the agent, you know, analyzed.
And then, you know, realize, okay, here, something is missing here and I have to add something there.
And so your, your engineering skills, you know, your systems thinking, uh, the decision making, what open source library to use, um, you know, what database to use.
All these skills, all that knowledge is still required.
And so, you know, somebody with no, uh, computer science background or no coding background, you know, no, not a programmer before.
Can't actually go through that workflow, um, on a, on a decent, decent sized repository.
Thomas, kind of off that, that same thread, um, in your Ted talk, you mentioned that AI could enable a billion new developers by lowering entry barriers.
So how is GitHub addressing the challenge of onboarding and educating this influx of new developers, especially those from non-traditional backgrounds?
Let me give you a couple of examples.
And the one, you know, my favorite example, and I mentioned it, um, a bunch of times on stage already.
I've, you know, kids, uh, um, uh, my two sons and they're coding, they're learning coding in Python.
And, uh, before co-pilot, you know, they would come, you know, to my desk in the middle of a podcast and say, here's, you know, my, my coding challenge and, uh, uh, find, find the bug in, in my code.
So I can keep going and building my game because they're much more interested on the outcome of what they're building than the increased intricacies of, of software development.
Right.
And so then, um, at some point I'm, I thought on me, well, I could just get them co-pilot.
And so I installed them this code and, and, and co-pilot and, and then they quickly learned, you know, that they can prompt a co-pilot in English and, and say, Hey, what's, what's wrong here with my code?
Or they can say, you know, show me what that code looks like in, in Java and, and, and learn new programming languages, right?
Like kids, uh, especially in this, you know, school age, you know, whatever sick, uh, first to fifth grade or so they're very eager to explore the world.
And as parents, you often, uh, you know, see that because they keep asking you questions and you're running out of patience or you're running out of energy.
And you're like, okay, I explained enough to go and, uh, do something else.
Right.
And co-pilot doesn't have that problem.
Right.
Like it has infinite patience.
Like you can ask it, you can drive it into, you know, insanity by just asking and asking and asking.
And at some point you may get garbage, but like, it will never stop answering.
And I think that's just in itself, um, truly democratizing, right?
Because now my kids have the benefit of, I know how to code.
You know, I taught myself 30 years ago.
Uh, I have a technical background and obviously I'm in this topic day in, day out, but many kids around the world do not have that benefit.
And they're living in households where their parents don't know how to code.
And they probably have never seen, uh, uh, Python or Ruby or whatnot.
And so giving them a co-pilot that, uh, helps them to explore the world, um, of coding and, and explaining that to them.
And they can just say, Hey, put me as pong game or a snake game, or, uh, I want to, you know, build a little, um, app to track my allowance.
Things like that is incredibly empowering.
Now, the next thing on this is it doesn't only work in English.
It works in effectively any major language, right?
And so, and then think about it, you know, a six year old, uh, in Germany or in Hyderabad or in Indonesia or whatnot, right?
They don't, they don't learn English for us.
They learn the local language first.
And, and then coding is predominantly in English, right?
This podcast is in English.
And we're yet at the, we're yet at the, to get to the point where you can just run AI over this and all our voices sound exactly like us.
And then we have different accents or different language, right?
And so that is also democratizing, right?
Like you can learn coding before learning English and, and you can actually, uh, you know, ask all these questions, uh, without going to the internet and trying to understand what the person has set there.
And you can follow up, right?
The true power I think of these AI chat systems is that they take a second question and a third question.
It's like, if you didn't get the first answer, you can just say, I don't get it.
Explained it or you can say this sounds wrong to me.
And then it apologizes to you, right?
Like it's this moment where he does like, Oh, this is cool.
I can probe and, and see what the, what the true answer is.
So I think that, you know, is, will help a whole new generation of, of, um, kids and ultimately anyone, right?
At any age that wants to get out of read only mode on, on their smartphones, right?
Like maybe install, uh, all, all these apps.
And then we use them in the way that, um, the developer intended instead of it being, uh, custom to us.
And then, um, there was a blog post the other week called personal software, right?
And, uh, it derives, um, I think the Robinson or something we can, we can look it up later and add to the show notes, but.
You know, it, it talks about the personal computer and how the personal computer isn't actually personal, right?
Like I'm just downloading all that software that is exactly the same as the software you have.
And the only personalization we have is like the, the order of the icons in your dog or on your home screen and the background image and whatnot.
Right. But with, with, you know, AI and, and, and tools like GitHub Spark or, um, bold.new, lovable, uh, vzero.dev, uh, and so on.
You actually can create your own little software and you don't need to think about, uh, buying a subscription and, and all the other services and the tracking and all the things that come with these apps.
Um, you know, I mentioned allowance tracking or weather tracking or building like a little app when you go on the family vacation where you want to collect all your memories, right?
Like I think we're heading into an era where people truly just provide apps for themselves that, that are just for them and their friends or their families.
And, and, and if you, once you have achieved that stage, right, then why wouldn't anyone that's using a smartphone also create software for themselves?
Already kind of discussed, but we were on a run yesterday and we're kind of talking about Copile and just the evolution of these tools.
Um, and, you know, I kind of probed the question, you know, as these tools get better and the ability for agentic systems to solve issues, go into GitHub repository, solve those problems.
You know, my question was, you know, for the open source community that a lot of these tools rely on, which is, you know, basically saying, Hey, you know, we have these issues.
Let's have the community go solve it.
As these agentic systems come and do that, you know, what is the new system for open source?
You know, what does that do for the community of developers who are sitting there looking to contribute to this code?
If there's already agentic system, that's going to do it for them.
Does that then, you know, kind of go extinct?
You know, what is that shift with the open source community itself?
Um, here's your feedback and thoughts on that.
Right.
Like if, if you think about, um, open source today, um, most of us are open source consumers and we're pulling in a library, um, or not one, a thousand libraries in most of our projects.
Um, you can't really do software without open source anymore.
Um, and then you have a challenge, uh, with one of those libraries.
Maybe the behavior is not exactly as you expected, um, or, or you need something else that the maintainer didn't have time for.
And then often, you know, you fork it and figure it out yourself.
And that in itself is already challenging, right?
Because now we have to navigate somebody else's code base and that's a hard problem.
Like in, in many ways, that's an unsolved problem, whether, you know, you, you dive into an open source project or you join in a new company.
Uh, you know, it has a different stack, right?
Like it maybe have a different version of the programming language or the environment that you're using.
So now it's like, oh, do I screw up with my local environment, uh, uh, to, to make that open source project run, right?
Like in Ruby, it's like, how much are you messing with RBN and things like that?
Or you're just letting it go and, and, and, and hack around it or just, you know, vendor the code into your own code base.
So you, uh, you're no longer using the open source library.
You're just using a local fork of that, right?
Um, but you know, AI, you can navigate the code, the code base much easier, right?
Like I already mentioned, you know, can have it, you know, describe the behavior to you.
You can have it, um, you know, identify the files you, you want to modify, um, with agent mode.
You can, you know, describe the change you want and see what it does, right?
And that alone, you know, is kind of like a learning by doing a behavior that developers will get into, like, right?
By describing the thing that you want to achieve in natural language and then having the agent kind of like identify, okay, I might need to modify these three files.
And I can still, you know, F5 or run the thing and see, okay, now it's close, you know, 15 error messages.
Then you go back to the agent and say, Hey, what do I do with all these error messages now?
Right.
And so that I think will get easier as a consumer to become actually contributed to the open source project because it's easier to onboard.
Um, that you find a pull request and, you know, Copilot will review that pull request and, and point out all the, all the things that you have introduced, you know, bugs, issues, or violations of coding standards against that project.
So before, you know, the top maintainer of that project has seen your sloppy work, uh, you may be fast enough to, to fix all the things, right?
Like next, next human, uh, behavior thing here, right?
Like it's like, how much anxiety do I have before I commit back to an open source project?
Because I'm worried, you know, somebody like, you know, uh, Linus Torvalds or, or, or, or, or, or, you know, with a high rank and status in the community, uh, is looking at my code and thinking, what the hell is that?
And, and like, go back and learn coding first, like, and, you know, and, and it's all well intentioned, right?
Like the problem lies as much as the, uh, with the person that has the fear in the head of, uh, contributing back because most open source projects are actually super friendly.
But, uh, you don't know that until you have got gone and caused the chasm and actually, you know, uh, uh, uh, taken that step and learned, okay.
And, you know, Logan, Logan and Nolan actually super nice and they just accept my contributions and whatnot, right?
So I think that's where life will get much easier.
And then, as you know, I think we are going to get to a stage where instead of me filing an issue, I just use co-pilot and an NSV agent to make the change and then send you back the pull requests.
And you just use your SV agent to review my work.
And then the biggest decision you have to make is do I want that feature in my library or not?
Um, and, um, and that still is with you, right?
And that's where the software developer still is needed, um, to, to design a product, um, because the AI, uh, uh, can't do that on their own.
Yeah.
One, one of the, you mentioned this example of your, your kids, uh, learning to program in Python.
And it reminded me of, I think this, this year, and obviously Python has been popular for a really long time, but I think this year you announced at GitHub universe that like, I don't know if it's tracking the percentage of total code or like new lines of code or what the specific metric is.
But like Python is now the world's most popular programming language.
Uh, it's, it's beating out JavaScript and others.
Um, the, we, Nolan and I were having this conversation with Charlie Marsh, who created UV and rough and some, some Python tooling infrastructure.
And, and the question which we asked him, which I'm really curious to get your reaction to is like in this world where AI is so dramatically accelerating, um, you know, sort of the onboarding of new developers, but also like the existing developers to be more productive.
Like is Python the final programming language?
Like, are we like, does it basically stop this like new creation of languages and, and I'll plant this separate seed, which is you and I were originally connected, um, through the work that I was doing in the open source Julia programming language.
And it was like pushing on, you know, I was harassing the GitHub team to make sure we had Julia support for all this other stuff and making.
And like, that was my, like my experience growing up was doing all this work for the Julia ecosystem on GitHub predominantly.
Um, so I, I have a specific, you know, feeling about like what, what's happening in the world of, of, you know, code generation, et cetera, et cetera.
But I'm curious, like where your head is at in that space and, um, how you, how you think about that.
I think the ultimate programming language will be human language, um, whether that's English or German, Hindi, um, or whatnot.
And, um, because that's the, you know, layer that we all learn, you know, uh, from birth and, and, and that we express our ideas, right?
Like you're not brainstorming in program language, uh, with, with Nolan, right?
Like on a whiteboard you're, you're scratching and, and it's very kind of like chaotic because human language naturally is that way.
Right.
Like you can put a couple of words on a whiteboard and they have a totally different meaning to you.
Uh, then they may have to me that comes into the meeting room later and looks like at this and saying, what the, what is this?
Right.
Um, and so I think the top layer is going to be human language and, you know, any larger company that has product managers, your product managers are describing all those features in, in, in English already.
Um, and so we're already at that point, you know, um, features are described in English, you know, support tickets are described in, in, in, in, in, in human language.
Um, uh, uh, your, your pitch decks or, or that is, you know, human language, right.
Um, programming language is the highest abstraction layer.
Um, uh, on top of the CPU or GPU, that's still deterministic, right.
That's the difference between those two, right.
Like human language inherently is non-deterministic.
Like we can say the same sentence and depending on the context and, and our, our background and, and where we're from, it might mean different things.
And programming language, when you put, you know, the five keywords in a row that, that usually mean the same thing.
Um, uh, and, and so we are going to have those two layers, right.
The non-deterministic layer and the deterministic layer and developers will jump back and forth between those.
Um, and I think that, you know, whether it's Python, uh, or Rust or Go and Ruby, there will be always another programming language.
I think anyone predicting the opposite is going to be naturally wrong.
Cause it's in the, you know, in the same way that there's, there used to be always another Twitter client.
Uh, now there's no more Twitter clients, but now it's another, uh, Mastodon client or, uh, threats or, or blue sky client, right.
Like there's always another app that we're trying out, um, uh, because everybody in the tech industry is, is talking about that app.
And so.
But I think it's crucial to understand that those two layers have to exist, right?
Like a machine learning model at the end of the day needs to translate into, into, into programming language.
Um, it can do that, you know, at the lowest layer and, and just run instructions.
Uh, and we go, we're seeing that already, right?
Like when you speak with your phone, um, and instructed to do things for you, or when you're dictating it.
You're not actually having it translate what you say into code first, and then execute that code.
It just does it because it's built into the application.
Uh, but with code interpreter, right?
Like that's the, the opposite example when you use code interpreter or, or just math in, in chat GPT.
Uh, it writes a Python script first, and then it executes that Python script, uh, to, to get to the result or, or plot a chart.
Um, uh, anything where the model in itself is worse than just writing code and then the code does it for it.
And all of a sudden you have digital deterministic outcomes.
So I think those two layers will exist and there isn't a, you know, Python will forever be the, the top language.
And look, you know, these ratings, um, we, we publish them every year at GitHub universe.
So what you quoted was universe 2024.
Uh, when for the first time Python was the number one language after, I don't know, 10 years or so, JavaScript was number two.
And, and obviously the JavaScript ecosystem is, uh, divided between JavaScript and TypeScript.
And, and, um, you know, then half of the ecosystem argues, well, if you take JavaScript and TypeScript together, there's still bigger than Python.
And sure that's true, but that wasn't the case last year when JavaScript was number one and Python was number two, right?
So we didn't keep, we didn't change the system.
It's the same system.
And it just shows the trend of the importance of, of that language.
Um, I think on your other question, I think the GitHub in itself and the developer lifecycle will really evolve, um, um, as it had always evolved, right?
Like if you go back 30 years when I started coding on a Commodore 64, you know, I had a big yellow book, uh, the big Commodore 64 book or something in German, and I had nowhere to go, right?
Like if I was stuck at, at 6 PM on a, on a Saturday and couldn't figure out how to build that side scroller that I've always wanted to build.
There, there was nothing I could do.
I could just keep looking in the book.
If there was like a page missing that, that gave me that insight or just hack around, um, uh, and, and see, but let's trial and error.
Whether I can make it work.
And, and then came the internet and, you know, and that changed everything, right?
Because you could just, in the early days would dial into like a mailbox and, and chat with some other nerds that were kind of like in your same, in your same ecosystem, uh, somewhat, because there wasn't really like.
A single place where all the developers went and then came source fortune and GitHub and an open source.
And all of a sudden you had that world available to you, right?
Look, you know what you can do today on a Saturday afternoon is incredible.
You know, just the productivity, right?
Like when we, when we think, when we ask the question, you haven't asked it, but like, you know, when we ask the question, is AI replacing developers?
Yeah.
We always have done that, right?
Like we always have done stuff to make ourselves more productive.
If you would, you know, build whatever you're building right now, without the power of open source, you would have, you would need 10 times as many developers to get the same stuff done.
And so it wouldn't be competitive in the market.
And so as such open source, the usage of open source and companies has replaced a part of the workforce that would still be there.
If you haven't, we haven't done open source and the same is true for every technology advancement, you know, for faster computers from, you know, from the internet, open source, the cloud and all, you know, DevOps and all these kinds of things.
At the same time, you know, the amount of work that we have day in, day out has also increased like exponentially, and we are writing more software every single day, right?
Like find a team in any, you know, small or big company that's not writing more code every day than they're deleting, unless, you know, somebody defect us at all.
And then you have that one big git commit where it's like plus a million lines of code and minus 2 million lines of code.
We have all seen that too, but like the reality is we're sitting on an ever growing pile of code, you know, and often it feels like, you know, pile of shit, you know, let's be clear.
That's sometimes the feelings we have, especially when we join a company that has been around, you know, as long as Microsoft or Google have been around where you're always working in an existing legacy code base.
You know, my, my joke always is the happiest day of a developer is when they start a new project, you know, file a new project.
And then from there, it's all downhill, right?
Like, because you start with a blank sheet and you try out all these new Python libraries.
And then three weeks later, you go to your manager and it's like, hey, you know, we have all this tech debt and all this, we made all the wrong choices on these libraries.
And this isn't as good as we thought it is.
We should start from scratch, right?
And so after three weeks, you might still be able to do that.
After three months, you're like, hell no, now we have to refactor it and make it work and remove all the band-aids that we use to ship fast.
And so I think AI is helping us a little bit further on that, on the journey to deal with the complexity of our applications and stay sane and ultimately stay in the flow and be creative.
Thomas, you've also emphasized the need for competition in the AI industry.
So how does GitHub plan to foster a competitive yet collaborative environment among different AI models, platforms, all within kind of GitHub itself?
We already mentioned multi-model choice, right?
Like we added multiple models to co-pilot and we will add more, you know, over the months to come.
We have a whole catalog of models in GitHub models.
We can, you know, go to the playground and play with Mistral and Cohia and FIFO and whatnot.
You know, if you think about DeepSeq, the DeepSeq model is a GitHub repo and then links from the GitHub readme into a hugging phase.
And there you can, you know, look at the data and run inference and whatnot, right?
So in many ways, you know, GitHub, not only through the home of open source, it's also now the home of AI, where a lot of these AI projects collaborate.
And we are part of an ecosystem.
I've always looked at GitHub as, you know, we're one planet in a huge universe of software development tools.
There is no one, you know, software development suite that just doesn't exist.
Like just look at your computer.
You know, you have an operating system and a container solution and an editor or whatever VS code.
And now there's, you know, lots of forks of VS code.
And that's the nature of open source, right?
Like if you don't like the editor, you can fork it and build your own one and see if you can differentiate.
And it's this choice, you know, we mentioned already lots of open source libraries for that.
It's the Python ecosystem or the react ecosystem.
And I think, you know, we are still a big great shop at GitHub.
You know, we've been always working with Ruby and Rails.
We're part of the Rails Foundation.
We're part of the OpenSSF Foundation and the Linux Foundation and all these kinds of things.
So I think, you know, we are part of that ecosystem as one planet.
And as we want to interact with other planets in our universe, and we want to integrate with them through APIs and webhooks and those kinds of things.
We partner with them, you know, who join blog posts and join conference sessions or sitting just on the board of these foundations together.
And, you know, we're giving back to the community, whether it's by just giving everybody free repos and free co-pilot and free issues and free, you know, actions and whatnot.
And by obviously also contributing back to open source ourselves, whether it's in Rails or in Git and other projects.
And I think, you know, the best thing about working at GitHub, whether it's me or any other hubber, is that it's really easy to get into a conversation with other developers at GitHub, right?
Like our brand is more like a star than a planet.
And everybody knows GitHub and that has, you know, good days and bad days, right?
Like we get lots of good feedback and then there's also a lot of lots of, you know, productive, you know, productive complaining, I'd say.
People saying, you know, why are you doing all this investment into AI instead of investing into that one feature that I always wanted for three years.
And I'm scratching my head, I'm thinking, well, you know, there's 10,000 features that we wanted to build since 2014.
And we, as every other software developer, have an endless backlog of things that we want to build.
We have an endless backlog of, you know, fundamentals, scale, uptime, you know, accessibility, security, where we want to get better.
And we believe that co-pilot and agents will help us to bring the effort down so we can, you know, get to the ultimate dream for every developer,
which is like, I have this one idea on a morning and with just, you know, a few magical, you know, pomps and commandos that can implement all that and show it to you in the evening.
Like, how did you, how did you do that? Right? Like, that's kind of like the dream that we have all in our heads, I think, as software developers.
Yeah, this makes me think of this like 10,000 feature backlog that you all have, you know, at the same time you have that and you want to build all those things into GitHub and AI.
And AI is hopefully going to accelerate the process of that.
Um, at the same time, we talked before about this, like personal software and this, like, you know, user of one creation of like text to app, et cetera, with, um, with all the products that are doing that.
How do you think this like balances out? Like, do you think like, you know, if, if you had to guess today, if you look like five years ahead, does like GitHub end up with.
10,000 more features or like, does GitHub end up with like, actually like a sprawling product array?
That is like some of those like actually distinctly live outside of the current GitHub flow because like they're relevant.
Yeah. Or like this, or more generally, like the software become like a hundred X more complicated, or do we end up with like a hundred X, like more different software to choose from in the next five years?
I think it's both. I think, you know, in some ways it becomes more complicated, um, uh, because the depth is increasing so much.
You know, we're already seeing that, you know, um, I have the AI engineering book here, you know, from, uh, you know, looking at this and, uh, reading through some of the pages and understanding, you know, how full stack engineering has fundamentally changed with the AI models.
Not for everybody yet, um, but we're heading into that direction right now to also understand, you know, prompt engineering and evals and, uh, irresponsible AI and, and filters and, and then, you know, model upgrades and moving from one model version to another.
And that's not as easy as moving from one open source library version to another.
Um, although that's often, you know, harder as, as we'd like it to be as well.
Um, and so I think that the world is going to be more complex, but at the same time, uh, through the help of.
Uh, through the help of, you know, co-pilot check interfaces, being able to just talk, you know, and I think they're heading, uh, to a place where I just, you know, have a drivers, uh, like Ironman in my ear where I can just, you know, uh, reflect on some of my thoughts.
And it gives me like, oh, you know, uh, uh, yesterday we were on that podcast and you said this and that, and maybe that's a good talk track for this customer meeting as well to just, you know, use a non-coding example.
And, um, and so I think, you know, the, um, agents and, and the co-pilots that we're building plus the natural language interface will allow us to navigate that, that complexity, uh, easier.
Right.
Like the classic example, I think of agents that we all have in our head is the travel agent where I can just say, Hey, book me, you know, my spring break trip with my family, you know, same wife, same kids.
So I don't, you don't have to go to an airline webpage and enter from two dates and birth dates and names and all that.
And then you go to the rental car company and to the hotel webpage or that again, for the exact same spring break trip, you take every single year, right?
Like, or it's the same family, but different destination, but it knows that, okay, you like the beach and you're like, kind of like warm weather in April and whatnot.
So I think, you know, that's a very simplistic example.
Uh, but it, it, you know, imagine the amount of time you have, you know, for four person, 10, uh, family, uh, every year you book your, you know, two, three vacations, uh, that, that you're taking, uh, take.
Now you have your AI assistant that does it all for you.
And, and it's really just a visual choice of, okay, this, this, or this option, or maybe it's a pricing choice, um, um, or, or whatever criteria you, you, you have to, to pick your vacation.
I think that's, you know, if you take this example and multiply that across all the decisions we have to make in life and, and.
Realize that human language interfaces are much, much more easy to interact with than, than, than click and mouse and, you know, user interfaces, um, or, or touchscreens.
Um, uh, uh, I think, you know, we're looking into a life that we have, we navigate all the complexity, um, that's much more ease and happiness.
Thomas, we'd like to leave, uh, leave our guests with two questions as we wrap things up.
Uh, first one is what does your personal tech stack look like?
What tools are you currently using day in and day out?
GitHub.
Uh, so we have this, you know, I'm saying at GitHub that, uh, we build GitHub on GitHub using GitHub.
So that's, it's, it's not a joke.
You know, I use, I open GitHub in the morning.
I look for my notifications, uh, my leadership team posts, you know, their, uh, you know, status updates.
In, in the GitHub discussion.
Uh, we have obviously lots of issues, um, where decisions are made on, on, on business planning, pricing, or, or features.
Um, we have users of Slack.
Uh, and so that's probably my number two tool, um, after GitHub, uh, looking into Slack.
And, uh, my favorite channel is, uh, the demos channel where folks post post their demos and, and just looking through the recent demos and what they're working on.
And it's like a widespread of this is shipping tomorrow, you know, all the way back to this is designer prototyping something.
That's not shipping for awhile.
Um, VS code, um, when, when I get time, uh, uh, and, and, and, and, um, uh, do some coding myself.
Um, what else?
Um, I have chat CPT, um, you know, I, I use that as well.
Um, uh, especially, you know, the, um, new reasoning models and, and kind of like describing what I want to solve and just give me a starting point.
You know, to write a strategy document, um, um, or, you know, just a quick email to somebody, um, where I don't know how to get started and, and have it in a succinct way.
You know, I, I'm English as a second, have English as a second language.
And so sometimes it's just easy.
And even that, you know, goes back to the question I asked earlier, which is, um, uh, you know, how is this changing the world and how do we get, uh, you know, 2 billion, uh, developers.
I think, you know, we are actually going to get to a world that's much more literate and, and, uh, and this has an easier time to, uh,
to, to write a professional text and engage in, in professional conversation.
Awesome.
And then last question is now we're what 40 some days into 2025.
We like to ask our guests, what's one thing you hope happens in 2025?
And one thing you hope does not happen come 2025.
I think what, you know, what I don't want to happen, you know, as a CEO of GitHub is, uh, another log4j, uh, security incident.
Um, and in some ways, you know, those will happen again.
Um, but every time we have these, um, on a Friday afternoon or not, um, uh, it creates a big wave, um, for a lot of developers around the world to, to rally and, and, and fix all, you know, all their servers and all their, all their stacks.
Um, and so the more we get to a point where we have skilled the open source ecosystem, the better we all, you know, can sleep at night.
Um, and so I think that's, you know, one thing that, um, we're really pushing hard at GitHub together with a lot of partners in the ecosystem.
And where I hope, you know, uh, the farther out the next big one of those is, um, the, the better it is for all of us.
I think, you know, what I want to happen.
In 2025 is that we make progress on, you know, what we talked about for the last one hour, which is like getting to the spot where these three agents, you know, these agentic systems, these co-pilots get, uh, better at, you know, interpreting, you know, my intent.
And, uh, helping me to write good software because, um, you know, that, that allows me to build more cool stuff.
Um, um, and both, you know, at GitHub through, you know, my thousand plus engineers, um, in the company, but also me personally, when, when I have time, you know, over the weekend to cope with my kids or on my own hobby projects.
Right.
That's look, I'm, you know, a developer since the early nineties, um, a professional developer since, you know, the early two thousands.
And, uh, like the dream is still there that, you know, you have all these ideas in your head and the thing that we don't have is enough time, uh, to implement them all.
And so that's, I think, you know, when we get, if you get a little bit closer to that in, in 2025, where we can just, you know, describe with a few prompts of what we want to build.
And then the AI helps us building that and brings back the joy in coding, uh, and removing a little bit of the boilerplate or the things you don't want to do.
Um, we've made a step forward as industry.
I love that.
Thomas, this was awesome.
This was a wonderful conversation.
Thank you for, for taking the time to talk to us about, about the present, the future, um, and everything in between.
Thank you.
