It's been 20 years, almost to the hour, since Git was self-hosted enough to write its initial
commit. Did you expect to be sitting here 20 years later, still using it and talking about it?
Um, still using it, yes. Maybe not talking about it. I mean, that was,
has been one of the big surprises by just how much it was, basically how much it took over the
whole CM world. Just because I saw it as a solution to my problems and I obviously thought it was
superior even literally 20 years ago to the day. I thought that first version, which was pretty raw,
to be honest. Right. Even that version was superior to CBS. Sure. But, but at the same time,
I'd seen CBS just hold on to the market. I mean, SDN came around, but it's just CBS in,
SDN and other guys, right? Yeah.
Uh, for many, many decades. So I was like, okay, this market is very sticky. Yeah. I can't use CBS
because I hate it with a passion. So I'll do, I'll do my own thing. Yeah. I couldn't use Bitkeeper,
obviously, anymore. So I was like, okay, I'll do something that works for me and I won't care
about anybody else. Yeah. And, uh, immediately that showed in the first few, few months and years,
people were complaining that it was kind of hard to use, not intuitive enough. Right. Then something
happened, like there was a switch that was thrown. Yeah. Well, you mentioned Bitkeeper. Maybe we can
talk about that a little bit. Sure. Um, pretty famously, you wrote the initial version of GIP and
around 10 or so dates as a replacement for the kernel. Yes and no. It was actually fewer than
well, it was about 10 days until I could use it for the kernel. Yes. Um, but to be fair,
the whole process started like December or November, the year before. So 20, uh, 2004, what happened was,
uh, Bitkeeper had always worked fairly well for me. It wasn't perfect, but it was light years ahead of
anything else. I've tried, tried, uh, but Bitkeeper in the kernel community was always very not entirely
welcomed by the community because it was commercial. It was free for open source use because Larry McVoy,
who I knew really liked open source. Right. I mean, he, at the same time, he was, was making a business
around it and he wanted to, to, to sell Bitkeeper to big companies, but not being open source and
being used for one of the biggest open source projects around was kind of a sticking point for
a lot. Sure. And it was for me too. I mean, to some degree, I really wanted to use open source,
but at the same time, I'm very pragmatic and there was nothing open source that was
and remotely good enough. So I was kind of hoping that something would come up that would be better.
But what did come up was that, uh, Tridge in Australia basically reversed engineered Bitkeeper,
which wasn't that hard because Bitkeeper internally was basically a good wrapper around
SCCS, which goes back to like the sixties. I mean, this is not an SCCS is almost worse than CVS.
But that was explicitly against the license rules of Bitkeeper. Like Bitkeeper was like,
you can use this for open source, but you can't reverse engineering and you can try to kind of, uh, clone Bitkeeper.
And that made for huge issues. I mean, we, and this was something private. So I was talking to Larry
and I was emailing with Tridge and we were trying to come up with a solution, but, but Tridge and Larry
were really on completely opposite ends of the spectrum. And then there was no solution coming up.
So for, by the time I started writing Git, I had actually been thinking about the issue for
four months and thinking about what, what worked for me and thinking about how do I do something that
does even better than Bitkeeper does, but doesn't do it the way Bitkeeper does it.
Right.
So I did not want to be in the situation where Larry would say, Hey, you did the one thing you were not
supposed to do. Right.
So yes, the writing part was maybe 10 days until I started using Git for the kernel, but there was a
lot of like mental going over what the ideas should be.
Well, I want to talk about maybe both of those things. We can start with that kind of 10 day
period. So as I understand it, uh, you had sort of taken that period as a time away from the kernel
and mostly focused on Git and isolation. What was that transition like for you to, to just be working on
Git and not thinking about the kernel? Since it was only two weeks, it ended up being that way.
It wasn't actually a huge deal. I'd, I'd done things like that just for like in the last 35 years,
I've been on vacation a couple of times, right? Not very many times, but I have been like away from
the kernel for two weeks at a time before. Uh, and it was kind of interesting because it was
one of my reactions was how much easier it is to do programming and users. Right. You'd need to be,
there's so much less you need to care about. There's yeah, you don't need to worry about memory
allocations. You don't need to worry about a lot of things and debugging is so much easier when you
have all this infrastructure that, that you're writing when you're doing absolutely right. So it was
actually somewhat, I mean, I wouldn't say relaxing, but it was, it was fun to do something user spacey
where I had a fairly clear goal of what I wanted. I mean, clear goal in the sense I, I knew the
direction. I didn't know the details. Well, that's the other thing actually I want to talk about is
one of the things I, I find so interesting about Git, especially 20 years on is it's so the development
model that it encourages to me seems so simple that it's almost obvious at this point. But I
don't say that as a reductive term. I think there must've been quite a lot of thought into distilling
down from the sort of universal source control ideas down into something that became Git. Tell me,
you know, what were the sort of non-obvious choices you made at the time to get what we have?
The fact that you say it's obvious now, I think it wasn't obvious at the time. I think one of the
reasons people found Git to be very hard to use was that most people who started out using Git
were coming from a background of something CVS-like. And the Git mindset, I came at it from a file
system person's standpoint where I had this disdain and almost hate for it of most source control
management projects. So I was not at all interested in kind of maintaining the status quo. Like the
biggest issue for me was, well, there were two huge issues. One was performance because when I,
back then I still applied a lot of patches, which I mean Git has made almost go away because now I just
merge other people's code. But, but for me, one of the goals was that I could apply a patch series in
basically half a minute, even when it was like 50, a hundred patches. You shouldn't need a coffee to.
Right. Exactly. And that was important to me because it's actually a quality of life thing.
It's one of those things where, where if, if things are just instant,
you, some mistake happens, you see the result immediately and you just go on and you fix it.
And, and some of the other projects I had been looking at took like half a minute per patch,
which was not acceptable to me. And that, that was because the kernel is a fairly large project.
Sure. And a lot of these
SCMs are just not, were not designed to be scalable. Yeah.
So that was one of the issues, but one of the issues really was,
I knew I needed it to be distributed, but I needed to be really, really stable.
Okay.
And, and people kind of think that using a,
the SHA-1 hashes was a huge mistake. But to me, SHA-1 hashes were never about the security.
It was about finding corruption, of course. Because we'd actually had some of that
during the BitKeeper thing. So BitKeeper used CRCs and MD5s, right. But didn't use it for everything.
Right.
So one of the early designs for me was absolutely everything was protected by a really good hash.
Sure.
And that kind of drove the whole project, like having two or three really fundamental design ideas,
which is why at a low level, it is actually fairly simple.
Right.
And then the complexities are in the details and the user interfaces and in all the things it has
to be able to do because everybody wants it to do crazy things.
Yeah.
But, but having a low level design that has a few core concepts made it easier to write and
much easier to think about. And also to some degree, explain to people what the ideas are. And I kind
of compare it to Unix. Unix has like a core philosophy of everything is a process. Everything is a file.
You pipe things between things. And then the reality is it's not actually simple. I mean,
there's the simple concepts that underlie the philosophy, but then all the details are very
complicated.
And I think that's what made me appreciate Unix in the first place.
Yeah.
And I think Git has some of the same kind of, there's a fundamental core simplicity to the design.
And then there is a complexity of implementation.
There's a through line from Unix into the way that Git was designed.
Yes.
Yeah.
Okay.
You mentioned SHA-1. One of the things that I think about in this sort of week or two where you were
developing the first version of Git is you made a lot of decisions that have sort of stuck with us.
Yeah.
Were there any, including or not, SHA-1 that you regretted or wish you had done differently?
Well, I mean, SHA-1 I regret in the sense that I think it caused a lot of pointless churn
with the hull trying to support SHA-256 as well as SHA-1. And I understand why it happened,
but I do think it was mostly pointless. I don't think there was a huge,
real need for it, but people were worried, so it was shown. So I think there's a lot of wasted effort
there. There's a number of other small issues. I think I made a mistake in how the index file
entries are sorted. I think there's these stupid details that made things harder than they should be.
Yeah. But at the same time, many of those things could be fixed, but they're small enough,
it doesn't really matter. Right.
All the complexities are elsewhere. Yeah, yeah, yeah.
So it sounds like you have few regrets. I think that's good. I'm curious also in that sort of two-week
period, were there any moments where you weren't sure what you were trying to achieve was going to work
or come together or be usable? Or did you already have a pretty clear thought?
Sure. I had a clear idea of the initial stages, but I wasn't sure how it would work in the long run.
So honestly, after the first week, I had something that was good for applying patches, but not so much
for everything else. I had the basics for doing merges and the data structures were in place for
that. But it actually took, I think it took an additional week before I did my first merge.
And there were a number of things where I wasn't, I didn't, I had kind of the big picture end result in
mind, but I wasn't sure if I'm going to get there. Yeah. The first steps, I mean, the first week or two,
to be in the, you can go and look at the code and people have, and it is not complicated code. No,
it's, I think the first version was 10,000 lines or something. You can more or less read it in a
single setting. Yeah. And, and it's, it's very straightforward and doesn't do a lot of error
checking and stuff like that. It's really a, let's get this working because I have another
project that I consider to be more important that I want to need to get back to. It really was,
I will hit, I mean, and, and it happened where I would hit issues that required me to do some changes.
Yeah. The, the first version you can tell it's not, I think we ended up doing a
backwards incompatible object store transfer at one point. At least FSCK complains about some of the old
objects we had because we, I, I changed the data format. I didn't know that's where that came from.
Yeah, no. So there were things that were the first, the first version just was not doing everything it
needed to do. Yeah. And, uh, I forget if I actually did a conversion or not. I may not have ever needed
to convert. Yeah. And, and we just have a few warnings for like a few objects in the kernel where,
where FSCK will say, Hey, this is an old, no longer supported format, sort of thing. But on the other,
on the whole, it really worked. I mean, surprisingly well. Yeah. The big issue was always people's
acceptance of it. Right. And that took, that took a long time. Yeah. Well, we talked a little bit
about how sort of merging was put in place, but not functional until, you know, maybe week two or week
three. Yeah. What were the other sort of features that you left out of the initial version that you
later realized were, were actually quite essential to the project? Well, it wasn't so much later realized
it was stuff that I didn't care about, but I knew that if this is going to go, then where somebody else will.
I mean, it's the first, the first week when I was using it for the kernel, I was literally using
the raw, what is now called plumbing commands by hand. There was no, no so-called porcelain. There was
nothing above that to make it usable. So to, to make a commit, you'd go do these very arcane things.
That's your index commit tree. Yeah. Commit tree, right. And that just returns a like a shot that you
by hand, just write into the head, like a file. And that was it. Did hash object exist in the first
version? Um, I think that was one of the first binaries that I had where I could yet just check
that I could hash everything by hand and it would return the hash to standard out. Then you could do
whatever you wanted to it. Um, but it was like the early porcelain was me scripting shell scripts around
these very hard to use things. And, and honestly, it wasn't easy to use even with myself shell scripts.
Yeah. But to be fair, the first like initial target audience for this were pretty hardcore
kernel people who had been using bitkeepers. So they at least knew a lot of the concepts I was aiming for.
Mm-hmm . And, uh, people picked it up. I mean, I think I had, it didn't take
that long because before some other kernel developers started actually using it. And I was actually
surprised by how quickly some source control people started coming in. Yeah. And, uh, I started getting
patches from the outside within days of building the first good version public.
So we've talked a lot about the sort of first couple of weeks with Git. Yeah. I want to move
forward a bit. You made the decision to hand off maintainership to June pretty early on in the project.
Yeah. I wonder if you could tell me a little bit about what it's been like to sort of watch
him run the project and really watch the community interact with it, uh, at a little bit of a distance
after all these years. I mean, to be honest, I mean, I maintained Git for like three or four months.
I think I handed it off in August or something like that. And when I handed it off, I truly just
handed it off. I was like, I'm, I was, I'm still around. I was still reading the Git mailing list,
which I don't do anymore. Yes. Uh, Junior wanted to make sure that, that if he asked me anything,
I'd be okay. Uh, but at the same time I was like, this is not what I want to do. I still feel silly.
My oldest daughter went off to college and two months later, she sends this text to me and say,
says that I'm more well known at the computer science lab for Git than for Linux because they
actually use Git for everything there. And I was like, Git was never a big thing for me. It was a,
I need to get this done to, to do the kernel. Sure. And, uh, and it's kind of ridiculous
that yes, I used four months of my life maintaining it.
But now at the 20 years later, yes, you should definitely talk to Junior, not to me because he's
been doing a great job and I'm very happy it worked out so well. But to be honest, I'll take credit for
work. Having worked with people on the internet for long enough that I was like, during the four
months I was maintaining Git, I was pretty good at picking up who has got the good taste to be a good
maintainer. That's what it's about is taste for you. For me, it's, it's hard to describe, but it's,
yes, you have to, you can see, you can see it in patches. You can see in how they react to other
people's code, how they, how they think kind of things. And he was not the first person in the project,
but he was one of the early ones that was around from pretty much week one after it, I had made it
public. So he was one of the early persons, but it wasn't like, you're the first one, tag, you're it.
It was more like, okay, I have now seen this person work for, for three months and I don't want to
maintain this project. I will ask him if he wants to be that maintainer. I think he was a bit nervous
at first, but, but it really has been working out. Yeah. He's certainly run the project very admirably.
Yeah. I mean, so taste is to me very important, but practically speaking, the fact that you stick
around the projects for 20 years, that's the, that's the even more important part, right? And he
asks. Yeah. I mean, he's knowledgeable about almost every area of the tree to a surprising degree. Yeah.
Okay. So we've, we've talked a lot about early Git. I want to talk a little bit about sort of the,
the middle period of Git maybe. One of the things that I find so interesting about the tool,
given how ubiquitous it's become, it's clearly been effective at aiding the kernel's development.
Yeah. But it's also been really effective for university students writing little class projects
on their laptops. What do you think was unique about Git that made it effective at sort of both
extremes of the software engineering spectrum?
Yeah. The distributed nature really ends up making so many things so easy. Yeah.
And that was one big part that set Git apart from all, pretty much all SCMs before. Yeah.
Was, I mean, there had been distributed SCMs, but there had, as far as I know, never been something
where it was like the number one design goals. Right. I mean, along with the other number one
design goals. You can work with Git purely locally. And then later, if you want to make it available
in any other place, it's so easy. Yeah. And that's very different from, say, CBS, where you have to,
in order to work with it, you have to set up this kind of centralized repository. And if you ever want
to move it anywhere else, it's just very, very painful. Right. And you can't, like, share it with
somebody else without losing track of it. There's always going to be one special repository when
you're using a traditional SCM. And the fact that Git didn't do that, and very much by design didn't do
that. I mean, that's what made services like GitHub trivial. I mean, I'm, I'm, I'm trivializing GitHub
because I realized there's a lot of work in making all the infrastructure around Git. But at the same
time, the basic Git hosting side is basically nothing. Because that would, the whole design of Git is
designed around making it easy to copy and, and every repository is the same and equal.
And I think that ended up being what made it so easy to then use as an individual developer.
When you make a new repository for Git repository, it's not a big deal. It's like you do get in it
and you're done and you don't need to set up any infrastructure and you don't need to do any of
the stuff that you traditionally needed to do with an SCM. And then if that project ever grows to be
something where you decide, oh, maybe I want other people to work with it. That works too. And again,
you don't have to do anything about it. You just, you just push it to GitHub and you're, again,
you're done. Yeah. That was something I very much wanted. And I didn't realize how many other
people wanted it to. Yeah. I thought people were happy with CBS and SBA. Right. Well, I didn't really
think that, but I, I thought they were, they were sufficient for most people. Let's put it that way.
Yeah. We've talked a little bit about just now, sort of how Git has applicability on both ends of
the sort of software engineering extremes. I've lived my whole life with version control as part
of software development. And one of the things I'm curious about is how you see Git's role in shaping
how software development gets done today. That's too big of a question for me. I don't know.
It wasn't why I wrote Git. I wrote it for my own issues.
I, I think GitHub and the, the other hosting services have, have made it clear how easy it is now to make
all these random small projects in ways that it didn't used to be. Yes. And that has resulted in
a lot of dead projects too. Sure. Like you find these one-off things where somebody did something
and left it behind and it's sure still there. But does that really change how software development
is done in the big picture? I don't know. I mean, it changes the details. It makes collaboration
easier to some degree, makes it easier to do these throwaway projects. And if they don't work,
they don't work. And if they do work, now you can work together with other people.
But, but I'm not sure it changed anything fundamentally in software development.
Moving ahead a little bit, you know, modern software development has never been changing
faster than it is today. Are you going to say the AI word?
I'm not going to say the AI word, unless you want to.
No, no, no. What are some of the areas of the tool that you think have evolved or maybe still need
to evolve to continue to support the certain new and demanding workflows that people are using it for?
I'd love to see more bug tracking stuff. I mean, everybody is doing that. I mean, there are,
whether you call it, bug tracking or issues or whatever you want to call it.
But they're all, I'd love to see that be more unified because right now it's very fragmented
where every single hosting site does their own version of it. And I understand why they do it.
A, there is no kind of standard good base. And B, it's also a way to do the value add and keep people
in that ecosystem, even when Git itself means that it's really easy to move the code.
But I do wish there was a more unified thing where bug tracking and issues in general would be,
it would be something that would be more shared among the hosting sites.
Sure.
Right.
You mentioned earlier that, um, you were maybe not pretty quick, but it's at least been a while
since you sort of regularly follow the melee ones. Yeah. Um, in fact, it's been a little bit of time
since you even committed to the project. I think by my count it's, uh, August of 2022 was the last time
we had a commit.
Yeah. I have a few experimental patches in my tree that just, I keep around. So these days I do a
pool of the Git sources and I have, I think four or five patches that I use myself. And I think I
posted a couple of them to the Git main list, but they're not very important. They're like details that,
that tend to be very specific to my workflow. But honestly, I mean, the, this is true of, of the
Linux kernel too, that I've been doing Linux for 35 years and it did everything I needed in the first
year. Right.
And the thing that keeps me going on the kernel side is a hardware keeps evolving and, and
a kernel needs to evolve with that. Of course.
But B it's all the like needs of other people. Right. Never in my life would I need all of the
features that the kernel does. Yeah. Um, but I'm interested in kernels and I'm still doing that
35 years later. When it came to Git, it was like, Git did what I needed within the first year. In fact,
mostly within the first few months. Yeah.
And, uh, and when it did what I needed, I lost interest because I, I didn't, when it comes to
kernels, I'm really interested in how they work and this is what I do. But when it comes to SCMs,
it's like, yeah, I'm not at all interested. Have there been any features that you followed in the
past, you know, handful of years from the project that you found interesting?
I liked how the merge strategies got slightly smarter. Yeah.
Uh, I liked how some of the scripts were finally arriving in C just to make them faster. Yeah.
Because I, I saw that even though I don't apply like a hundred patch series anymore. Um,
I do end up doing things like rebasing for test trees and stuff like that and, and having some of the
performance improvements, but, but then, I mean, those are fairly small implementation details in
the end. They're not the kind of big changes that, I mean, I think the biggest change that I was still
tracking a few years ago was, was all the, uh, multiple hashes thing, which really looks very painful
to me. Okay. Have there been any tools in the sort of ecosystem that you've used on site? I mean,
I'm a, a huge tick user myself. I don't know if you, I've never, no, I, even early on when we had
like, when Git was really hard to use and they were like these add on UIs, the only
like wrapper around Git I ever used was Git K. Yeah. And, and that was obviously integrated into
Git fairly quickly. Right. Uh, but I, I still use like entirely the
command language. I don't use any of the editor integration stuff. I don't do any of that because
my editor is too stupid to integrate with anything. It's much less Git. So I occasionally do statistics
on, on my Git history usage just because I, I'm like, what commands do I use? Yeah. Yeah. And it turns
up. I use live Git commands and, and Git merge and Git blame and Git log are, are three of them pretty much.
So I'm, I'm a very casual user, user of Git in that sense. I have to ask about what the other two are.
I mean, obviously Git commit and Git pull. I did this top five thing at some point. I mean, it may have
changed, but, but there's like, there's not a lot of, I, I do have a few scripts and then to like use
Git rev list and go really low to statistics for the project. But then they, in terms of your
interaction with the project. Yeah. Yeah. What do you feel like have been some of the features
in the project either from early on or, or in the time since that, um, maybe haven't gotten
the appreciation they deserve? Oh, I mean, Git has gotten so much more appreciation than it deserves.
But I, yeah, that's the reverse of what I would ask me. Uh, like a big thing for me was when people
actually started appreciating what Git could do instead of complaining about how
different it was. Yeah. And that, I mean, that, that was several years after the initial Git,
I think it was, how was it? It was the strange web developers who started using Git in a big way.
It's like Ruby on Rails, I think. I mean, which I had no, I still don't know what Ruby even is.
Right. But, but, uh, Ruby on Rails people started using Git sometime in 2008, something like this. Right.
And, uh, it made, it was strange because it brought in a completely new kind of Git user at least
that I hadn't seen before. Sure. Right. And, and it must have existed, like in the background,
it just made it very obvious that suddenly you had all these young people who had never used SCM
in their life before. Right. And Git was the first thing they ever used. And it was what the project
they were using was using. So it was kind of the default thing. Yeah. And, uh, and it, I think it
changed the dynamics when you, you didn't have these old timers who had used a very different SCM
their whole life. And suddenly you had young people who had never seen anything else
and, uh, and appreciated. And instead of saying, it is so hard. I started seeing these people who were
complaining about how do I do this one when this old project is in CBS. Right. So that was, that was
funny. But yeah, no, the, the fact that people are appreciating Git, uh, I mean, way more than I
ever thought. Yeah. Especially considering the first few years when I got a lot of hate for it.
Really? Oh, the complaints kept coming. Tell me about it. Oh, I mean, I, it's more like,
I can't point to DT test. You'd have to Google it. But the number of people who sent me, why does it
do this? Uh, and, uh, and the flame wars over my choice of, uh, of names. Um,
for example, I didn't have like Git status, which actually is one of the commands I use fairly
regular. It's in top five. It's probably not in the top five, but it's still like something fairly
common. I didn't, I don't think I'd ever used it with CBS because it was so slow and people had all
these expectations. So I just remember the first few years, the, the complaints about why the names
of the sub commands are different for no good reasons. And the main reason was I just didn't
like CBS very much. So I, I did things differently on purpose sometimes. And, and, and the shift
literally like between 2007 and 2010, those years when people went from complaining about how hard
Git was to use to, to really appreciating some of the power of Git was to me interesting.
Sure.
We've talked about the sort of very early days and the inception of the project. We've talked a
little bit about how Git is used in the wild today. Um, I want to spend maybe just a moment
thinking about the future of the project. I guess maybe to start, I wonder in your mind,
what are the sort of biggest challenges that Git either is facing or will face? Um,
I don't even know. I mean, it has just been so much more successful than I ever, I mean,
the statistics are insane. It went from use for the kernel and a couple of other projects to being
fairly popular to now being like 98% of the SCM. I mean, that's sure. That's a number I saw in some
report from last year. So I mean, it's, it's, uh, I don't know how true that is, but it's like
big. Yeah. And, uh, and in that sense,
I wouldn't worry about challenges because I think SCMs, there is a very strong network effect where,
and that's probably why once it took off, it took off in a big way is, is there's just
when every other project is using Git by default, all the new projects will use Git too. Yeah. Because
the pain of having two different SCMs for two different projects should work on, it's just not
worth it. So I would, I would not see that as a challenge for Git as much as I would see it
as a challenge for anybody else who thinks they have something better. And, and honestly, because
Git does everything that I need, the challenges would likely come from new use and uses. Yeah. I
mean, we saw some of that. We saw some of that with people who used Git in ways that explicitly were
things I consider to be the wrong approach. Yeah. Like Microsoft, the mono repo for everything,
which showed scalability issues. Right. I'm not saying Microsoft was wrong to do that. I'm saying
this is literally what Git was not designed to do. Right. Uh, I assume most of those problems have
been solved because I'm not seeing any complaints, but at the same time, I'm not following the mailing list
as much as I used to. I don't even know if the large file issue are, is because they're to be solved.
Yeah. If you want to put a DVD image in Git, that was like, why would you ever want to do that? But
I mean, that's the challenge is when Git is everywhere, you find all these people who do
strange things. That you would never imagine. Yeah. That I didn't imagine and that I consider
to be actively wrong. But hey, I mean, that's a personal opinion. Clearly other people have
have very different personal opinions. So, uh, so that's always a challenge. I mean, that's,
that's something I see in the kernel too, where I go, why the hell are you doing that?
That shouldn't work, but you're clearly doing it. To that extent, I mean, we talked about how,
whether it's 98% or what the statistic is, Git is obviously a huge dominant component in software
development. Uh, at the same time, there are new, you know, version control upstarts that seem to pop
up. Uh, P jewel comes to mind, jujitsu, Piper and things like that. I'm curious if you ever tried any
of them. No, I don't. I mean, literally since I came from this, from being completely uninterested in
source control, why would I look at alternatives now that I have something that works for me? Uh, yeah, I,
I, I did. I mean, I really came into Git not liking source control and now I don't hate it anymore.
And I think that databases are, are my particular, like, that's the most boring thing in life thing,
but SCM still haven't, haven't been something I'm really interested in.
You've given me a little bit of an end to my last question for you. So
on schedule, Linux came about 34 years ago. Uh, yeah. Git 20. Oh, bad question. And so we're
maybe five or so years overdue for the next big thing. No, no. I, I see the other way around all
the projects that I've had to make, I had to make because I couldn't find anything better that somebody
else did, but I much prefer other people solving my problems for me. Right. Uh, so me having to
come up with a project, it's actually a failure of the world. Right. And the world just hasn't failed
in the last 20 years for me. Right. Uh, I, I, yeah, I started doing Linux because I needed an operating
system and there was nothing that's my needs. And I started doing good for the same reason.
I started subsurface, which is my DiBlog. Well, not no longer my DiBlog software,
but that was so specialized that it never took off in a big way. And, and that solved one particular
problem. But, uh, my computer use is actually so limited that, that I think I've solved all the problems.
Part of, part of it is probably, I'd been doing it so long that my, like, I can only do things in
certain ways. I'm still using the same editor that I used when I was in college because my fingers have
learned one thing and there's no going back. And I know the editor is crap and I maintain it because
it's a dead project that nobody else uses. So I have a source tree and I compile my own version every
time I install a new machine. Uh, and I would suggest nobody ever use that editor, but I can't,
I've tried, I tried multiple times finding an editor that is more modern and does fancy things like
colorize my source code and do things like that. And every time I try it, I'm like, yeah,
I, these, these hands are too old for this. Right. So, so I really hope there is no project that comes
along that makes me go, I have to do this. Yeah. Well, on that note, on that note, thank you for
20 years of gift. Well, Hey, it's, I did it for my own very selfish reasons. And really, I mean,
this is the point to say again, that yes, out of the 20 years, I spent four months on it. So it
really, all the credit goes to do now. And hey, all the other people who involved in gift that have
by now done so much more than I ever did. In any event, thank you.
Thank you.
