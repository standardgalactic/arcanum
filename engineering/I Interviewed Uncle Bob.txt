okay so today we are joined right here by uncle bob the robert martin himself how you doing i'm
well thank you why don't you give like a kind of an introduction to who you are so anyone that
doesn't know they can get to know you oh heavens um yes i'm uncle bob or i'm bob martin some people
call me uncle bob i've been a programmer for um 50 some odd years uh written all kinds of code and
assembly language in c and fortran and cobalt and c plus plus and java and nowadays i work in closure
that's the language i enjoy uh you may know me also as the author of uh clean code and a whole
bunch of other books um over the years so that's who i am you also signed the original agile manifesto
2003 february 31 february 2001 yes that's true we were all there together yep okay so i just have
to ask how did you get to closure because i did read that article where you talked about closure
and all that and i think that's how we had our first introduction is me reading that article which
i just find closure to be such a bizarre language jump from uh from i guess the more like uh will
we call it enterprise java style programming yeah so um yeah it took a lot of therapy to get the
closure um somebody gave me a book recommendation 20 years ago and the book was uh the structure and
interpretation of computer programs uh an old book right out of the 80s and i i got the book i think i
got it on ebay um and it was a secondhand book i stuck it on myself i didn't read it for a while
and then one day i started just thumbing through it and the book just captivated me it was like one
of those moments when like oh my god what the hell am i reading here and what's the name of the book again
can you say the name one more time the structure and interpretation of computer programs
which you can get for free nowadays it's sic.org i think okay i don't think i've ever read that oh yeah
well you can google it you can get it for free you can also see all the old lectures by abelson and
sussman they're all online and then you know 1980s guys drawing parentheses on the blackboard
it's very very fun fun stuff to do but the book um just catalyzed me it energized me i thought well
this is interesting and of course the language was lisp or it was scheme right i'd list the derivative and i
thought okay i had for 30 years thought i'm never gonna learn lisp i don't want to learn lisp it sounds
like a dumb language no i'm currently on that team and i'm crossing my 20-year mark so i'm close
okay so i read that book and it changed my mind and i thought okay i i gotta get a lisp and i just
happened to bump into closure i i had known rich hickey off and on for for uh long years because he used to
debate on the c plus plus uh news groups back when there were news groups uh and i saw his work on
closure and i thought i'm gonna get this language i'm gonna diddle around with it and this was probably
2010. uh and i just fell in love with the language it was just wonderful uh and i've been using it ever
since wow okay yeah well what is like just because i i'm i'm i'm fairly kind of stuck in my c looking
language ways i generally don't i just we were having a talk earlier that i think one of the
reasons why functional style languages are largely unsuccessful is because their syntax is stupid is
what i was saying when i say stupid i mean that the average person who's had 10 years of programming
that looks at functional syntax they're they're just like incapable of just even reading it to begin
with it's just so divergent from what is like kind of a zeitgeist of programming and so how was that
how was that transition because that is that that's clearly where you you fell in love with it was there
like a hard period was there a time where you're just like why am i doing this to myself so the the
syntax of lisp and their foreclosure is so absurdly simple that there is no syntax uh barrier to cross
and there's there's almost no syntax to the language so the most startling thing when you get into it the
most startling thing is you're asking yourself where where are all the handles how do i control this
language where's the class keyword where's the type keywords where are all these keywords and the answer
to that is there aren't any and all you really have are a couple of very very simple gestures
uh which by the way makes the language remarkably expressive the less syntax the more semantics
as it turns out so good or bad both okay it's both good and bad it's a it's a double-edged sword
uh although i i err on the semantic side i like the expressivity uh if you've ever done any fourth
i have not done one of these languages that has almost no syntax uh small talk another language
that has almost no syntax there are a few languages like that and they become very expressive because
you're not constrained by this big syntax iron curtain that drags around you all the time yeah
but no you have to kill yourself so so that does that mean because i've heard this stated before
and and i i don't quite understand it because i don't have the experience with lisp to actually like
really concretely understand this besides for you know a square uh on a blackboard that uh every kind
of lisp program is almost its own unique language onto itself is that does that kind of follow up with
because you can kind of define everything yourself because there is no real um there is no real syntax
as you say and so people kind of really create their own structures in every kind of unique way
and so when you go from one to another you have this like you kind of have to adopt the person's
mentality who wrote it this is generally true of every language right when you're when you're a
programmer what you're really doing is you're inventing another language to express your problem in in
in lisp the the syntax is so sparse that all you're doing is inventing another language to
express your problem in without the constraint of the language syntax the uh the language also has
a number of features that make it very easy features is not the right word um affordances is a
better word that make it very easy to uh add facilities to what appears to be the language
i'm being obtuse on purpose but there's no other way to say that okay okay i i think i i think i
understand what you're trying to say if if i were to re-say that it sounds like you're trying to say that
the language allows you to make things that look like it's a part of the language
that's not something you've created thus yeah this whole idea of you kind of invent your own
every lisp program is its own language onto itself is partially in some sense true yes that's certainly
true i i again i'll say also that every every programming language does that but it's most
pronounced in a language like lisp okay so how do you how do you reconcile because i you know you may
have heard of clean code how do you reconcile some of the approaches that are suggested in there with
a language like closure because it sounds like closure is much more wild west and has very few constraints
um so you have to be more disciplined in closure there's you know because you can go off the deep
end really fast uh but the the clean code book is all about discipline so the the ideas in the clean code book
and move very well over into closure there's not there's no real friction there okay i like to keep
my functions nice and small i like to keep my names expressive i like to keep my modules relatively small
all of that is very easy to do in yeah does it have a concept of interfaces yes it does uh that you can
have polymorphic interfaces there's like three different ways to do that uh since closure rides on top of the
java stack you can actually create java interfaces that a java program can call uh although you're
doing it all in closure and you can also call java interfaces from closure so the the interoperability
between the closure language and the java stack is almost perfect not quite almost yeah okay that makes
sense i mean a lot of the jvm languages you can kind of call between uh we did a lot of groovy you may
be familiar with that yeah that idea we'll call it an idea um we i did a lot of groovy at one point
and it's uh i mean you can call java functions really easy you know a lot of concurrent hash maps and
all that but it was an experience nonetheless kind of working between jvm languages can sometimes be
fantastic and sometimes be a huge pain so all right so you're you're you've been off in the closure land
and all that and you know there's a lot a lot of newerish languages go um and rust i think are
probably the two most big kind of splashy new languages if you will call it new and splashy
uh that a lot of people have been kind of very excited about how does clean code intersect those two
languages i don't know a lot about rust i've only kind of looked at it cursorally um go i'm a little
more familiar with i've done a little bit of work in go uh i'm go is essentially c with a couple of
widgets uh yeah attached onto it and and uh very easy to do clean codish like things in in any language
that's derived from c and any of the c style languages clean code is real easy to to work with
um in fact i'm not sure there's any language that you could not apply clean code to except maybe cobal
well cobalt is very very unique unto itself i've i've only done probably like 10 hours of cobalt it's
uh it's very very tricky people are also saying is this true is pearl sorry pearl also is pearl also
clean coatable uh hmm probably not that's okay i actually have i have a i have a friend that may
or may not be in this chat whose mother programs pearl full-time wow i know that's i didn't even know
that was a position i didn't even know that was possible uh permanent pearl programmer a permanent
pro pearl programmer the the triple p all right so let's get kind of into some more of the fun stuff
so the general goal here today is that i'm not trying to make this into some sort of debate i think
debates largely tend to i mean the purpose of a debate in my head is that you try to make the
crowd think like you and not necessarily come to any sort of agreement or understanding of one
another's argument as much it is to try to defeat the other person if that makes sense um and so i
want this to kind of be more of like how do you think about things and then i'm going to try to
represent as best i can maybe twitter's general thought process slash twitch's general thought
process which by the way could be very room temperature iq uh for for you to kind of talk
back and forth with does does that sound good sure it's fine all right so i i i think for me the most
important question to ask is that in the last about i'd say in the 15-ish years because when i went to
college and when i started going to college clean code the gang of four this kind of this kind of
uh we also had java as our primary language of uh of learning programming with was a very like
important part when i would go into interviews it was always like all right tell me the you know tell
me the design patterns that you know can you explain this and you know in these terms right solid was
brought up a lot all that kind of stuff but then as time has gone on it feels like that's no longer
talked about uh i i really don't ever hear the term design pattern ever discussed among anybody
uh what kind of what kind of has caused this shift and do you think it's a it's a direct shifting
away from something like a clean code or is it just a nomenclature change among people
what has caused the shift is what has caused that shift in the last 50 years the same it's the same
effect and and the effect is that the demand for programmers is so large that the number of
programmers in the world doubles every five years or so and there's no way to keep up with a um a
a way of thought when you've got a doubling of the number of people pouring in right so you might have
some thought leaders from 30 years ago who had some really good ideas those ideas have been swept aside
by the wave of people just pouring in and it's very very difficult to maintain any kind of um consistent
mode of thought when you're in that kind of demographic deluge
yeah that makes perfect sense one of the things i try to do is yell loud enough so that people
remember some of these things and bring them back into the present so that they can look at them and
go oh there are these things called design patterns gee i didn't know anything about that well maybe you
know how to read something about that by the way you know the design patterns book is probably the most
important book written in the last 30 years and it's been swept away by this wave of incoming people
uh do you do you think that a lot of modern software can have the same benefit with these
design patterns uh because i i'll tell you like personally i i pretty much am a strategy pattern guy
right i think the strategy pattern really is the basis of all patterns right i mean it's pretty much
that is life is strategy that's pretty much just use an interface um do you think that much beyond
that knowledge and the builder pattern that there is a lot of usefulness still to continue to like
dive into these patterns oh there's a ton of usefulness to it because the purpose of a design
pattern is to have a name on a structure so i can say to you well i think we ought to use the visitor
pattern here and if you know what that pattern is which you're right it's just a bunch of strategies
but if you know what that pattern is then that structure snaps into your mind and you and i can have
an intelligent discussion about it and we can have a uh a discussion of the of the pros and cons
or if you're sitting there reading code and you see oh this is the xyz decorator and you happen to
know the decorator pattern then the structure snaps into your brain and you don't have to work it out by
reading the code perfectly right that's the whole point of design patterns you see a way to take one
notch up on the level of abstraction so that you can look at things in the code and identify them
without having to go line by line by line by line yes okay no i mean that's a very good answer you
know because you know we often have a lot of data structures or algorithms if i say hey this is a
general tree you already know what a general tree is right you don't have i don't have to explain to it
that you have zero or more children right like that's just not a thought process we have to have so
therefore you could make the argument that if we know what a builder pattern is and i say hey let's
use the builder pattern you and i are both probably thinking something that's very very close to the
same thing it may be slightly different but for the most part at least close to the same thing okay so
i think that's actually a pretty reasonable argument for design patterns um but one thing can i say it
this way that a lot of times what i see is that when people kind of are really into this because
remember netflix was a job a large java shop was there for a long time and so there's a lot of
patterns uh i i often find people reaching first for a pattern and an abstraction before the problem
is ever solved what do you think about that because i know you're you're very into the design first and
then program kind of approach you said that in casey's um gosh you said that in casey's here let me bring
up your exact quote sorry i did do it like a little i did i did try to at least read one thing right
um you said you said it was the latter zealots who thought it was better to leap into code without
any forethought and that was kind of like there was some context to that of course but the the
general idea is that some people or your suggested ways to like kind of design all things and you kind
of create the abstractions and think about the structure of your code before you start coding
is that correct yeah am i am i correct on that one um yes with caveats but yes okay
a lot of like modern or at least what i would call modern thinking at least like the go way of thinking
is that you kind of almost do somewhat of the opposite that you don't reach for abstraction
first you actually try to get the thing itself first out and you allow the abstractions to more
naturally percolate or manifest themselves how how can you kind of resolve those two school of
thoughts no i don't think there's a resolution there so so the way i work is that i will i will
do the most concrete thing for first i will think about the problem you know and and you know the amount
of thinking i do is an hour maybe okay and you know maybe i'll scratch a little design on a whiteboard
or something or a piece of paper i'll think about it and then i will then i will enter it if the
problem is large enough and i will do that and then i go right for the most concrete thing i can
and then i i have the problem force me to become abstract as i'm adding more and more code it starts
to get harder and harder to add that code without adding an abstraction of some kind and so i let the
code force that abstraction upon me and i continue that process and typically you wind up with an awful
lot of abstractions once you follow that process do you ever knowing like so let's say that you have
like i don't i it's hard to always come up with these examples kind of off the top of your head but
you have something that you could easily see into a series of if statements or switch statements like
right you have a message type that you're going to be handed it's a string and the first one is just
message and then the next one you know there will be more but there might not be many how do you
determine when to abstract versus when to go you know what if there's three hard-coded strings i'm
fine with that like when do you make this decision um for me it's a kind of feel thing as i'm working
in the code i look at it and i i get this itchy feeling in in some part of my face or gut and i think
oh man that's going to kill me later on uh and at some point that's overwhelming and then i make the
abstraction but a switch statement with two cases three cases i'm probably not going to get upset
about okay is there do you have a number that you put on it or is it really just only feel like
kenneth can five be too many like is there ever too many well i i think yes you can say a thousand
is too many but um agreed yeah there's no there's no hard number because it all depends on the context
right if i'm if i'm putting together a program uh for a demonstration that i'm doing and i'm going
to throw it away i'm just not going to worry about it very much on the other hand if it's if it's for
a client and the client has a long lifetime and they're expecting to make you know a lot of changes
to it then i'm going to be a lot more careful okay have you ever have you ever had a situation let's
kind of keep on going with this whole message thing right you're coming up with some sort of custom
protocol that's going to have a various set of commands have you ever reached for abstraction
first and then regretted it in my younger days it's it's a hard lesson to learn right you because
abstractions are beautiful and they are tyson and you want to do them and it looks so grand and after a
while you learn well extractions come at a cost and you will pay that cost as soon as you use the
abstraction uh and it will not pay you back unless there is some reason to have that abstraction there
so in my younger days i did a lot of that but uh having become old and jaded i try to stay as
concrete as i can until i'm forced out of the concrete world you know it's it's funny it's funny you
should say that because i i often you know i we have enough people hanging around here i don't
know what we're at right now let's just grab a quick number of 3400 people currently watching
and i often i often see kind of it's very hard to tell somebody a lot of these rules that i've kind
of come up with like why do i approach software in this kind of specific method and a lot of it just
comes from the fact that exactly what you said which is well one time i tried to make a game and i had
seven layers of inheritance you want to guess how much i hated that experience yeah i really did
hate that experience because not all burgers are cheeseburgers and eventually you're just like i
just need a whole new burger archetype you know like it just it just you just lose it and you kind
of have to go through this experience a bunch of times before you kind of have like a a general feel of
software and based on the things you're saying you're actually not really far either from the go
philosophy like it is good to sit down and kind of think about what um you know kind of what you
want to build here i generally i generally don't feel like i have to think hard in the sense that
whenever i give a problem i just know the structure i want it to be and that is usually good for what
i know what the inputs should be which obviously all good all good plans die at first contact right
like they never they never go past that and so it's like oh i was totally wrong about like eight
of my assumptions i guess i have to redo all these things um have you ever been into the uml days like
was there a point in your career where you were like big in the uml and oh yeah absolutely i have
changed your mind on a greedy boots okay because i'm curious about this because i was so heavy into
it that's where like all my seven layers and all these things came from was that i was umling and
dotting and composite you know i was really into it oh yeah yeah yeah yeah yeah now me too and i still
use uml from time to time i'll draw some diagrams on a board i know how to do it uh but that was a uh that
that was a time when we thought that we could capture software in a very abstract way and the
goal was for high level analysts to draw these diagrams and we wouldn't even need programmers
we could generate the code from those diagrams that was completely ridiculous failure i i may or may
not have generated some code from uml at one point in my lifetime there were many tools there were many
tools that could do it and there's still you can do it in intellij today you can draw a uml diagram and
it'll generate code but who cares you don't want to generate code from a diagram that that has been
tried so many times and it has failed every time it's like it's almost always the wrong solution unless you
have an extremely constrained environment yeah that actually makes a lot of sense i feel like if you
are purely working in a black box you effectively can engineer that solution out because it like
everything is known there's there there is no questions right like i had i had something i had
to build a long time ago for a little bit of a satellite that had 256 bits it's like you know what i could
test every possible pattern or there's 256 possibilities it was eight bits it's like i could test every
single possibility and we can actually design this to the 100 there is no you know like there is no
possibilities that we won't be prepared for but that's kind of where i lost my uml mojo is after
that because i realized that as i kept going i kept designing these things and then again first
contact with the enemy and my diagram was completely wrong and i spent so much time on the diagram oh yeah
yeah that's that's always a problem and back in those days we used to think that this is before agile
before the agile movement we used to think that you should spend weeks and weeks on those diagrams
get the diagrams first and then the code will just pour out well that never worked yeah i spent six
months on one and it did it made it uh it made it three hours into programming before i realized that
i made a program so slow for a supercomputer it couldn't run on a supercomputer and i was just like
it was bad six months to be destroyed in three days or three hours um okay well speaking of agile
that's that's pretty a pretty kind of a hot topic here um how do you feel because you obviously signed
the original you're one of the signatories or whatever they call whatever word they use there
of the original agile manifesto how do you feel like the last what is it 23 years have gone since
the since the agile manifesto has come out i wrote an entire book describing my feelings about that
topic it's called clean agile um i'm the old fuddy-duddy who's yelling at the young kids to get off
his lawn right the the uh the agile the agile message has gotten so badly twisted and and torqued and
perverted uh that i i wrote that book to try and reboot the whole thing saying well no that's not what
we were saying you know what we were saying is something else agile was a small idea for helping small
teams do small things it was not the overarching pattern of software development that was to
dominate the world it was just a way to get six or seven guys to be able to work well together
okay so what what made it fall apart then
i can tell you that exactly um how long do you have
i have to help my wife move in uh 26 minutes okay well this won't take that long um one of us
decided that we wanted a scrum advocate uh ken schwaber decided that he wanted to teach a course
called the certified scrum master course and he came to me and he said hey bob can i borrow one of
your offices so that one of your classrooms so that i can teach this and i said yeah go ahead ken that's
fine and he taught the very first certified scrum master course and the and the idea just took off
everybody wanted to be a certified scrum master not one programmer wanted to be a certified scrum master
all the project managers wanted it they wanted that little check box on their resume and the project
managers flooded into the field they flooded into agile they took over the message they took over the
conferences they took over everything and they literally pushed the programmers out
and the agile became a project management idea and the programmers looked around like you know they
were left on the desert island and looked around like well how the hell did we wind up on this island
and why are they sailing away in our ship that's what happened to agile so so what is the because i i often
make this joke which is agile is a lot like communism you know people just keep not trying it correctly
um what is what is the correct way to agile oh gee um it's a real simple idea right uh do things in
really short sequences measure how much you get done at every sequence use that measurement to project an
end date and tell everybody that's kind of it we can go into you know lower level details if you want but
that's pretty much it do things in real short short segments like one week long right measure how much
you get done project that out with an end date and then tell everybody hey that's the end date that we
look like we're seeing and generally that date is so terrifying that people are like oh maybe
we've got to do something about this early enough to actually get something done okay um so so there's
there's so proper agile has no dictates on how the team accomplishes or even the timelines or the weeks
days that are used to measure these short cycles shall we call them sprints yeah in scrum they're called
sprints there are individual um implementations of agile so there's extreme programming there's scrum
there's fdd there's dsdm there's a whole bunch of these processes that are more just sounded like
drugs more than anything else are we sure we're on the same topic pretty sure one of those is the dream
drug i've heard about it yeah well i think a lot of them are dream drugs but but um uh they are more
defined agile is not agile is just this framework that says hey you know do it up do it in short
cycles for christy and and that's kind of it uh now i i happen to be an extreme programming
aficionado i like the disciplines of extreme programming so you can you and i could have
discussions on things like pair programming and test-driven development and refactoring and simple
design and things like that where we could get into a lot more detail but that's just an extension
on top of agile okay i i mean i like this topic a lot we don't have a ton of time so i don't want to
i don't want to linger here too long but i mean to me that this mo mace oh my goodness this mostly
makes sense in the sense that as far as i can tell i think netflix is one of the best uh executors of
agile in the sense that no two teams operated the same every team was independent to choose their process
how much process how much process they wanted what is their cycles how are they making promises how
are they interfacing with other teams like everyone was their own kind of tower onto themselves and it
largely worked for quite some time obviously as things kept growing things you know there's always
friction no matter which way you choose we always said we choose people over process which i think is
the right kind of way to go about things i think that is very agile uh in in sense but okay it's kind of
good to understand kind of how the breakdown effectively happened and it makes sense that
um if agile is not applied on the individual basis it will it becomes well just becomes a series of
meetings and all that how do you convince like a company that they're doing agile wrong and that
you should leave it up to individual teams and individual teams should make their choices because
that inevitably suggests chaos right like there is a level of chaos to that that you cannot control if two
teams decide two different release cadences yep yeah where agile breaks down is when people try to put an
overarching envelope around the outside and then demand certain behaviors across the board just was
never designed for that so so how do you convince someone that they shouldn't do that right because
that's that's largely how agile is kind of practiced today is that it's like everybody it's you know
stand-ups for five days a week for everybody you know we do this we do this we do this like how do
how do you say no no no no let those three people make their own determination let those five over
there make their own determination and then they will figure out how to talk to each other like how
do you convince management of said of that because that sounds like the wild west sounds like chaos
so i do that by writing books and yelling at people and things like that but but how would how would
someone do that if they were trying to introduce agile into an organization and introduce agile into
an organization with scrum shall we say oh okay yeah how do you bring scrum into an organization so
sorry say it again the inverse that it already has scrum the kind of the ridiculous you're like now
let's introduce agile let's how do we introduce the actual concept into this place how do we undo the
scrum poison um i don't know how you do that i don't know how you how you convince people to
behave in a different way my whole career for the last 30 years has been in trying to convince people
to behave in a different way and i've had some moderate amount of success just by yelling loud and
publishing a lot but when i get into an individual company it's very very difficult what will happen
to me is that i will wind up leaving that company with one or two people who kind of got
the light bulb on their head and then they leave they leave the company they go somewhere else
that might not be the best um selling for your contracting at all be like by the way if you bring
me and you'll lose some employees well i don't do that anymore i don't do any of that stuff anymore
yeah all right all right i want to get to the the things that i think are more probably exciting for
me so i have a i have a really dumb rule of thumb when it comes to programming and it's a personal
rule right which is that whenever i see columns exceed 80 i generally think what am i doing here now i
don't have a problem with columns exceeding 80 it's just kind of like a general heart mentality that
when i've done that i kind of look back and go man i probably have a bunch of like maybe i have a
nested function in here maybe i have two for loops that are nested i've just i've done something here
that's probably slightly unusual to get out this far unless if i'm of course programming java or c plus
plus then it's you know then you have to extend that line to a new new position um you have one which
is you don't like functions beyond four to six lines you know like that's your kind of smell how did you
arrive to that because i i i have i have a few questions on this so how did you get there so
first of all on the language side i don't set that at 80 i set it at 120. i did a statistical analysis
on that and found that that if you go beyond 120 you're outside of the vast majority of programs that
were written yeah yeah again mine is completely irrational so i'm not saying that you have to have
rationality described this is just my feeling right punch card width so that's rational
80 columns and we've been living with that for uh 50 60 70 years now yeah um
function width function height right the number of lines in a function i don't really have a limit
there um i have said a number of times that i like four or five or six i think that's a good
size for a function if i ever get a function that's 10 lines long it's not like i'm gonna throw it out
it's like oh it's 10 lines long wonder why and then i continue on um i like them to be small and the
reason i like them to be small is that if a function does more than one thing and i can pull the two things
apart and give them individual names i find that to be more readable that's that's the bottom line
that's the only reason with the inverse okay could you say this kind of an inverse which is the more
functions you have to go through to understand what is happening also the more contextual overhead
you have to have because i can imagine if i had to have 20 lines on screen that kind of describes a
few step process i can kind of keep that in my head because i don't even have to like use an lsp i
don't have to use anything to jump to these definitions they're just like right there in my
head but if you're always splitting these functions up it can also be difficult to be like okay what does
this function do okay well this function is broken into two more functions what are those two functions
do okay now understand those two let's undo that one let's undo that one let's go to the next one okay
now we got to go you know you kind of effectively build a tree in your head of what is happening
how how do you prevent that type of explosion with that type of rule so i don't prevent that type of
explosion if if if that happens to me there's a single keystroke which will just pop those
functions back in right the inline refactoring so in intellij i can just go you know control all then
control all then control all then and it puts that whole function back together and i can read it
so if i find myself in that situation then it's easy for me to undo it i also then realized that i had
partitioned it incorrectly because if i find myself in that situation it's because
i did not put those functions apart correctly i did not give them the right names
so that's a test for me right i can undo it and then redo it in a different way that maybe
flows a little better the fear that you will drown underneath the sea of little tiny functions
is not a very good fear what you want to do is state what each function does give it a nice name
so that when you see a function and you read it you understand what it's doing without having to
read the next function down if you can get that goal if you can get it so that you can read a function
and not have to understand the next three functions down you've gained a big leg up on the problem of
understanding what a system does yeah i feel like that's true if mutation is low in the sense that
if you have a complex enough problem right like if you write let's just say any new modern ui framework
and you're in in the driver's seat and you have to sit down there and you have to do the actual
writing of the framework right that would be uh understanding what a function does simply by its name
could become excessively difficult if you've ever read through any of the source codes anything
like that even though you can kind of understand it you kind of have to read the code to first
really understand what these names mean and so that's always been kind of one of my my problems
because what what what i personally find happen is that i have a lot of these smaller functions and you
have a lot of this and then you go to code review and code review is really where i think a lot of
these weaknesses kind of show up because i can't look at the code without clicking around hopping to
different files hopping to different locations trying to gain it in my head because it's like the code was
written to be lsp navigatable but not reviewable if that makes sense yeah i understand i understand
the fear and i understand the experience you know i've experienced that as well you get badly
partitioned code and you're leaping all over the place and you don't know where anything is and you
can't keep anything in your head because you're constantly going here and you're constantly going
there but that is a smell that's a symptom that's not that doesn't follow from the the process of
breaking things down into well structured bits and giving them nice names you can break things down
into little bits and giving them nice names without forcing that jumping around and that's part of
the part of the uh part of the discipline of clean code you don't want to create those those uh nests
of leaping around okay if you've looked in the book you've seen that i like to order the functions
in the order that they were called so inside of a class i will say well here's the main function and
then below that are the ones that that guy called and below those those are the ones that that guy called
so that you can read down in a single single scan and stop at the point where you say oh i think i
understand everything i don't need to read the rest i don't get that last part that sounds very difficult
but i but i yes yes that's why i'm just like man i don't know if i could i don't know if i could do
that uh yeah i generally have a a different a slightly different ordering but i'll grant that to you i put
the most complicated usually at the bottom the least complicated at the top uh the least complicated
or easy to kind of zip through whereas the most complicated tends to be very meaty and slow rolling
um okay okay i just wanted to get that out because i always have a hard time kind of reconciling how
how those work and how they work in principle what it really sounds like to me is that what you're
trying to say is that you need the program for 20 years bite your shoot yourself in the foot a lot
of times and then a lot of these things make more sense because i mean i'm not trying to put
words in your mouth but that's generally the advice i tend to give which is that you have to shoot
yourself in the foot a hundred times before you realize how you've shot yourself in the foot
and then you don't shoot yourself in the foot as often the way i like to say it is that i i like to be
polite to the next person coming right so any kind of code that forces someone to puzzle it out or leap
around is rude it's rude code and i don't like my code to be rude i want it to be polite
do you think that there i mean isn't some level of code you have to jump around you have to puzzle
it out because i'm not sure if names can always convey the context because often the difficulty
isn't in some sense the names though naming is very hard it's in the state change and the state change
can really only be discovered by not just what the function's name is but by understanding
why the state changes and how that affects the next said calls isn't there always going to be
some level of like sorry i mean that's why for that's why we both agree on the low comment thing
i think comments are largely useless uh accidental and essential complexity there's an essential
complexity you cannot get rid of then there's a bunch of accidental complexity the programmers add to
it that they didn't have to and you know my goal is to eliminate it to reduce the accidental
complexity to as close to zero as you can get it okay i like to ride a nice a nice 100 accidental
complexity line it just feels good job security um all right all right how about how about tdd so
i've i i've been i've gone back and forth on td you're a very tdd fellow right it is a discipline that
i um value okay um let me tell you my tdd success story when i was a when i was a young fella a long
long time ago uh we had this app uh at a company called web filings now known as workiva in which we
had the original flash app in which people who are doing 10ks and 10qs public quarterly reports
would do all their editing along with the spreadsheet where you could link values and all that update your
spreadsheet boom it flows through all your documents all your documents are now up to date with your
spreadsheets pretty nice and so you could do a comment on a spot and then someone could review
it change all of that and we also had an ipad so i was in charge of the ipad the ipad you could zoom
and do all that that was some fun matrix equations for zooming and doing all that because there was no
zooming this was just a web app and a canvas and so we just you know we invented our own math there
and so we did all that it was a lot of fun um but if you touch the screen i need to be able to
start a comment by you touching and dragging so that's kind of like a fun unique problem to kind
of have and the thing is is that that has to line up with the original doc so it's like okay well i
know a lot of this information i know where every character starts because we did our own hand rolled
kerning because kerning had to be identical to the flash app as it is in the ipad app which is an
impossible problem by the way so you have to just invent your own kerning and write every single letter
and so that's what we did we hand rolled all of our own kerning and so i knew where every letter
started i knew where every everything about every page and so therefore i could write my own like
test before i ever even started because i'm like we need a search algorithm that when i press this it
behaves this way this goes in this comes out i know everything about the problem it was a perfect
what i'd consider a perfect tdd problem but i've never had that again okay
so my my big problem that i see with tdd or at least how i feel about it is that
i only know so much and most of the time i don't get the information that i need it's like hey let's do
something we've never done before i don't even know what the enemy looks like yet why would i want to write
a test first so yeah the way i do tdd is about one line at a time you know i will write a test and
it's a very small test it's maybe one line or two lines and it will fail and then i will write a line
of production code to make it pass this is so far below the idea of gosh i don't know what this code's
going to do because i clearly do know what it's going to do that i can very easily write a test for
that code in essence what i am doing is i am practicing double entry bookkeeping for every line
of code i write i write a complementary line of code that checks that i wrote the right line of code
just the way accountants do with entering numbers into spreadsheets right okay i'm gonna enter a
transaction over here i better enter the the complementary one over here and make sure the
balance sheet is still zero that's that's what test driven development is it's double entry bookkeeping
it is a way for me on a minute by minute basis to be sure that i have not done something
so globally stupid that it'll cost me three hours of debugging time
well i guess the follow the follow-up is is why not right so this is generally how i do it and i
think you said you watched the stream for a little bit earlier so you saw me where i developed
the tower defense the chat aggregator and then after i kind of let i like this structure i kind
of like what i have here then i go and i go okay let's i'm going to now test this to make sure
it's correct like right i never i am not a fan of of of trying to run code to see if it's correct
in the sense that like i'm going to now fire up the whole program to make sure i've written this
few lines correctly because that is just like such a nightmare testing cycle that i always do reach
for unit tests pretty quickly as a as a means to drive correctness and implementation not as a means
to develop the thing right so it's kind of like where the fundamental distraction comes from is that
if i were to start off with a test it kind of almost feels like i've kind of kind of already
pigeonholed myself into what i want to do when it's like well maybe i don't want to do it this
way maybe i don't even know how i want to interface with it yet and so do you ever find yourself
writing some test code writing some code realizing okay i can't even do it that way then going back
to your test code then reformulating your test code and then going back and reformulating this and kind
of doing this back and forth on it sure that happens all the time so why not just start with your
base implementation first there's another another reason that i'm very curious by the way i'm not
trying to like fight you on this i'm super curious on this no no no fine honest questions i know we
talked about honest questions all right so um uh there's another reason that i want that that test
or those suite of tests i want to come up with a suite of tests that when it passes
i feel comfortable to deploy i don't want to have to go through a long burn-ins period you know where
you you get the system running for a month and everybody kind of stares at it and wonders if
it's going to crash you know i don't want to go through that i don't want to go through a long
manual qa process with a bunch of guys in india banging away on it i don't want to go through that
i want to i want to cut that off as much as i can so i'll have a suite of tests that i can run
and if that suite of test is covering almost every line of code in the system i have a high degree of
confidence that i can take that code and move it closer to deployment i have worked on systems where
that passing suite of tests was deployment we would just deploy it right then and and if you're
going to do that you better have a real high degree of confidence in those tests so because
of that i use this discipline to keep keep the number of tests high and and every line of code is
somehow covered more or less now there's a whole bunch of exceptions to that there's a whole bunch of
places where that just doesn't work a whole bunch i shouldn't say a whole bunch there's a number of
places where that doesn't work but where it does work it's a discipline that i like to follow it it
makes me feel very safe so i i kind of have like a different i guess view on testing which is that i can
only test the things i know about meaning that i i actually have zero confidence every time all the
tests pass green i have zero confidence that there's not bugs in it right like i just i'm just
like there's probably bugs like i just simply don't know what i don't know and so even though all things
are green i am highly confident i've screwed something up and so that's kind of always been
my general approach which is that's i mean this is probably where or the reason why i write my base
implementation first and then come back with the test because i i already know what i know and i'm not
gonna i'm not gonna catch anything unless if i've just programmed wrong and the things that i already
know would break they break so how so so so why does it this i mean so you say this 100 line you know
this 100 effectively you're you're broaching the subject of 100 code coverage and i largely think
100 code coverage is a lie i don't think there should be even a number on it um why why do you try to
test every line try try to test it first of all i agree with you i don't want a number on it uh any kind
of number you put on that is is a lie uh but i think that you're also you're always shooting
asymptotically towards 100 percent uh and i do that because i want that test suite that i can trust i
have lived in that world where the test suite was so good that i could trust it and deploy and what that
also allows is for me to fearlessly refactor if i need to change the design of the system and i've got
a suite of tests that i really trust i can rip that system to shreds i can tear it apart you know in
a period of two or three hours just making sure that the tests all can all continue to pass change
the design rip things out move things around change this change that tests all still pass and i'm
running those tests all the time to make sure they still pass and i can i can uh have absolute
control over the code that way now and i use the word absolute it's never absolutely but i i have a high
degree of control over the code if i have a suite of tests that i can trust so i have lived in the
world the other world i have lived in the world where the suite of tests can't be trusted right
and there's no point in running them it's like okay the test passed so what i know there's bugs in
there that's what i want to avoid that's what i want to avoid i don't want to live in that world
now i'm working on a project right now where half the system is has a suite of tests that i can trust
and half the system doesn't and i i have a nice division between those two parts it happens to be
the gooey right that i can't test properly and then the rest of the processing code that i can
and i have one way of dealing with the code that's under test and i have another way of dealing with the
code that's not okay and so there's there's a lot of things that i want to talk about within all of
all of that there's just so many of them right um all right so i guess the first thing is that we
you did talk a lot about refactoring refactoring confidently um i guess that really dictates the
type of test you're writing then right that must mean you don't test individual functions you test
only contracts and is the assumption that when you refactor the contract doesn't change
yes so that this is something you learn over a long period of time when you're doing test-driven
development you have to write your tests in such a way that they don't couple to the implementation
and that first of all that takes a very long time and then once you do learn it it takes a long time
to learn and then once you do learn it you realize that you're only applying the exact same principles
that you apply to all the code you've ever written before right because anytime you can touch a
system in one place and it breaks in many you've got a design problem that's that's the definition
of a design problem touch it here breaks in 10 other places over there well that's also true of tests
if i touch it here and it breaks 10 10 or 20 tests i've got a design problem
well so you have a requirements change how many tests should break if the requirements change
and the answer is one if you can get there it's not always easy to get there but if you can get
there it should be one how many modules should you have to modify when there's a requirements change
one if you can get there that's kind of the goal of design you want to focus change on individual
modules so that when a change occurs one module is effective if you can pull that off and it's not
easy to pull that off but that's only assuming that every module has one dependency right you could
have many things depend on one thing yes yeah yes and if a module has many incoming dependencies
that's a problem and if a module has many outgoing dependencies that's a problem and you can't
eliminate them all but you can control that you can minimize that and get some kind of some kind of
um discipline around the number of dependencies between modules that's i wrote another book about
that called clean architecture but don't you by but but that if you do that you also introduce
natural abstraction that doesn't technically need to be there because now you're just abstracting to
specific interfaces you're just putting a man in the middle
i am putting a barrier but across an axis of change so yes it the the interfaces that you would
put in there the instructions that you would put in there are not strictly necessary for the behavior
of the system but they vastly increase the ability to modify the system they keep it easy to make a change
here without affecting something here all right all right i i tend not to i i'm very pro or i'm
very pro anti-abstraction i'm not sure i probably should just say anti-abstraction i try to very
minimally abstract my code when possible all right so then we began with we began this by saying you know
i don't put abstractions in unless the need is there but the need is there if i've got a change here
and it's affecting a bunch of stuff over there then i'll put an abstraction i don't know i think
sometimes requirement changes are big enough to just warrant that right like if someone changes your
fundamental data type a lot of things require that data type it's just by by its very nature must change
the only way you can do that is if you can predict the future and i have proven to myself i am a shitty
future predictor and that's true yeah because then i just have to make the same number of changes
it's just propagated through 10 places that eventually get to the tips now you just have
one changes eight times as opposed to one change that is eight oopsie daisies
you're always going to get bit by that we always get bit by that that doesn't mean that you can't
mitigate it and by the way also when you get bit by that you have the opportunity then to make sure
you don't get bit by it again because the most likely thing to change is the thing that's been
changing already so if you can if you can catch it early because somebody made a change and you can
put in a protection for that change then when they change that thing again and they will you'll have
a connection built in maybe i'll give you a maybe on that one i'm gonna give you a maybe i'll give you
50 50. okay i'll take that so hold on we got to go back to a little bit of testing uh when it comes to
it comes to when it comes to testing and you try you know your goal as you say is asymptotically
reaching 100 why why why does it matter that you cover every line of code because i want a test suite
that i can trust and but not all code is is all code worth testing all yes all code is worth testing
because any any error any any code that is in error can cause catastrophic results so yes all code is worth
testing but not all code is worth testing directly i don't mind indirect tests you know for example i
don't write tests for my getters and centers that's stupid right but i do write tests for the functions
that call the getters and centers all right so i have a general rule of thumb which is that if i can't
get the implementation right first try i test it okay and so that leaves some level of code always
untested because i have a implementation right the first time because some things are really easy
some in an array say that again some things are really easy some things are really easy some an array
like in javascript you have to summon array right would you just write it for summing an array i
wouldn't i wouldn't write one either right and so i have kind of like a set of i have a general rule
of thumb which is that if i'm doing something that is trivial in a function i just don't test it so yeah
kent beck used to say only test the things that could possibly break yeah that's what i mean that's
one reason why i do like uh uh errors as values languages is because they kind of force you to think
about the places in which things break uncomfortably so but nonetheless they do that's why i've always
been a very sus of the jvm is because it's kind of just like you don't have to handle it if you don't
want to and it's just like well maybe we do want to handle it or at least think about it should be
inconvenient when there's an error okay you don't think so um i'm not a big fan of multiple return
types um like go does that i don't like the comma separated returns i think that complicates things
so i i prefer to throw exceptions in languages that allow exceptions to be thrown
yeah but but then you have you have a whole control flow problem then because now you have to use you
necessarily skip a whole bunch of lines and you may even skip out of your function right like state
becomes very unknown if you don't have every line that has an error considers the error
so i mean that's also true when you return when you return error codes if you return an error code
from the middle of a function you may not know the state of how that function left things
by the necessity you do because you actually chose okay i got an error i will now have to return from
this error like you've made that choice at that point yes you have and if i throw an exception i've
i've chosen to throw the exception at that point but you don't know where and what point yeah i know but
that but that's the problem is that if you caught it three functions up you now have many many layers
well that's some you know come on so you know you've worked in places with at least three functions up
it's like if you want to go to is everywhere it doesn't necessarily mean it's a good idea um but
you know i like the exception model myself because i don't like to throw long distances you know i throw
up to the next function so it's very much like an error code except that it's caught in a different
way so you do like errors as values is what you're saying you just like two ways to return values because
that's what it sounds like if you do if you do a try catch every single time by the necessity you have
multiple return values you just have multiple return channels okay i'm happy with that okay okay and
hey that's fine hey look at that common ground all right who would have guessed who would have guessed
all right well i guess i don't think we'll probably ever see eye to eye on uh on unit testing fully or
test driven development though i mean i like i said i've used it once where i really understood the
problem and it was it was absolutely absolutely fantastic for sure um but what do you prefer when it
comes to testing are you do you drive more towards integration level like where do you choose your
level is higher better or is lower better or is there any rule that you can say so the the i'll just
go back to kent beck's statement i'll i will test anything that could possibly break uh i like to pose my
tests as uh abstract tests the wrong word uh general tests against a family of functions rather than a test
against every individual function i like indirect testing i want to make sure every line is covered
but the tests themselves are written at a slightly higher level but not so high that they're called
integration tests they're still unit tests they're just testing a slightly larger unit than a single
function okay do you think there's value in integration testing yes absolutely how much effort
should be put in it depends on the complexity and the size of the system unit tests are myopic
you know when you're writing unit tests you're thinking of one thing when you're doing integration
testing you're thinking about a number of things you've got a bunch of balls you're juggling in the
air so they can be very useful but they should not be testing business rules integration tests should
be testing integration they should be testing the choreography and the the flow of data through the units
as opposed to individual business rules it's a waste when you do individual business rules in integration
tests okay i i guess i'm slightly confused by that um isn't the output of any integration test a series
of business rules aren't you testing like a summation of business rules um so my my goal in an integration
test is not to make sure that all the business rules work i may have to test a business rule in
order to test the data flows but if the data flows work in an integration test i'm not going to go
through every one of the business rules that use those same data flows okay okay i've got unit tests
okay so you you just do more like does the system continue to operate i asked for a piece of data it
did return this type out we're good enough is that kind of what you're trying to say yeah
a little more detailed than that i want to know that the the processes got started properly the data
flow channels got opened properly that the right kind of data went across them so i might be putting
in um special little widgets to test those kinds of things i might stick in some extra fixture code that
will look at the flows of data across those points integration tests are very technical you know
yeah so that's the kind of thing a system architect does they're trying to plumb out the way the whole
system functions how do you feel about golden i see that a lot in integration tests like a bunch of
golden files being used like i start up our system it goes off and it talks to the db it does all these
things and then i expect this exact like shape of output how do you feel about that kind of the golden i guess they call
golden testing yeah it's a move of desperation uh you don't have enough insight into the system so
the only thing you can look at is the output and you don't know what's going on inside
uh and so okay well geez it seemed to print the report fine i guess the system's okay well
if it's a complicated system that's not a very um comforting approach why not
because you're only testing a very small subset of the behaviors that you're trying to test if you've
got two or three golden standards out there and you you'd run the tests and all the golden standards work
you have not hit the conditions that the golden standards didn't cover and you don't even know what
those conditions are yeah so even you get a false sense of security now if that's all you got okay
that's all you got but uh i would not start a system uh and and with the goal of testing it with golden
standards golden standards are um the least effective way of of keeping a system under control in my opinion
other than just not i mean can't you make that exact same argument for every smaller set of tests
because in some sense a unit test is a really a snapshot test just in the snapshot just happens to be really tiny
well yes the snapshot's tiny the number of moving parts is innumerable uh and then you made the point
earlier you know if you've only got eight bits you only got 256 possibilities and you can completely flesh
that out now i can't completely flesh out the behavior of the system but i can look at an individual
function or an individual small family of functions and be relatively certain that the behavior of those
functions is well covered am i 100 certain no am i relatively certain to a high degree yes
golden standard doesn't give you that because the golden standard is way too far out at the at the user
interface there's too much stuff going on in there from from my point of view and and in a complicated
system okay well unfortunately i do have to uh go as someone said in chat my wife is going to be angry
at me i may be 15 minutes late um i do appreciate having you on here and talk about these things the
goal again today was just to have it so that you can kind of explain your positions and i hopefully did a
good enough job kind of representing what i i would say your average twitter arguments were because i've read
a lot of the tweets and they all were just like four lines and you're just like well actually and so
i wanted to make sure that that was close enough thank you i had a good time appreciate you yeah no
this was a lot of fun i i did like some of your takes i do like the uh you know abstract when necessary
start more concrete i i do think those are good things and and most of all i i think that um the hardest
part about software isn't that there's a bunch of design patterns you have to memorize there isn't
some sort of like nomenclature that you and i have about you know we have our own set of special words
in software development and which is very weird to use around your non-software development friends
which i'm sure you've experienced you know you just don't throw the word integration testing around
with them what's this guy talking about um but at the end of the day i feel like experience is always
going to be the best teacher and it kind of like for me the only way i understand my principles is
simply because i've just made bad decisions and i'm just trying to make less bad decisions
as time has gone on and so maybe one day i will be sitting in your shoes telling all the kids to
start doing tdd and i'll be like dang it how did this happen how did i get here oh my god i'm uncle
bob now i know now uncle prime happen to next gen next gen i'm like saved by the bell next generation
this is gonna be terrible um all right so you get the last word any any things you want to tell to
the people watching things you want them to consider books you want to shill you you you name it you
get to do oh heavens um the most important thing i think is is keep on learning and read like crazy
read things you don't agree with get a broad a broad understanding remember the story i told about the
structure and interpretation of computer programs that was a book i expected not to agree with that
and it changed my life so just keep that up in mind right a broad mind read a bunch of junk constantly
learn uh and in 20 or 30 years you know things could be good hopefully all right that's good that's
that's fantastic anything else do you have any uh books or anything that you want to throw out there any
courses whatever you have no no i don't do courses and stuff like that anymore i pretty much stick to
my writing and and uh my programming of of stuff that i do um there's a book that i uh is in production
at the moment uh which is um a history of ancient programmers you know starting with people like grace
hopper and and uh um john bachas and edisker dykstra and that's a book that i'm i i had a lot of fun
writing i don't know how many people will read it i hope people will but i had a ton of fun writing that
book uh do you do when you're writing a book do i do tdd when i'm writing a book no i do not
there's no automated tests i can run you know you reread it a lot but that's not quite the same
all right well it sounds like you have manual testing somewhere in this pipeline we should fix
this no uh but okay did you hear there's this it was in ancient rome you might not i mean i i don't
when you said the word ancient then you mentioned people from the 50s it sounds like you might not
have i i believe the first programmer ever i i tried to look this up several times and i could never find
it i watched it on special once he did a play in a box where there was a spindle that had wires
attached to it and as it spun it would drop and then it'd rotate the other direction then it would
drop and rotate the other direction effectively doing binary programming to about 2 000 years ago
and would make entire things move around based on this like on off sequence and so technically
considered like the first actual programmer
which is cool yeah i only heard about a third of that because the network decided to cut out about
them oh that's too bad don't worry we'll we'll leave it for another time maybe i'll find the uh
maybe i'll find i'll find the reference and toss it to you
okay all right well you have no words hurts will all right you have a good one uncle bob this is great
thank you thank you for coming on thank you appreciate it had a good good time all right take care
