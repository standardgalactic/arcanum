error messages are the user interface of your entire programming language because they're like
oh won't it be cool if you could do like an if statement like this and it's like
yeah but that doesn't solve the big engineering problems that just feels cool when you're first
learning the language right um i will say it is not a self-deprecating acronym like just an idea
is such a dumb thing to name your language because uh because you're like saying oh my
thing i'm not really trying to do anything useful or important i just had an idea one day man just
no that's not i will i will unequivocally state that that is not what it is hello everyone welcome
to the game engineering podcast today i am joined by jonathan blow the game designer and programmer
who made braid and the witness and is now working on a new programming language as well as two new
games i am truly honored to have had this conversation jonathan had huge influence on me
both regarding the passion for video games but also the attitude to pursue excellence and become better
at my craft every day the conversation starts very technically jonathan dives deep into the design
of a macro system in his new programming language called jai after discussing the language he showcases
the upcoming unnamed socobank game we then move towards more general questions about the role of
a game designer how his company tecla operates and the state of game development in 2025 and without
further ado let's meet jonathan blow regarding the status update of joy the last time i think the last
status update from compiler uh beta it was in september and you said that there are three things on the
roadmap uh strongly typed macrosystem cross-compiling support and dll's compiled at a different point
in time there's this problem with like runtime context and how to coordinate synchronize that and
you outline these like three things and then you said that maybe after tackling those three jai will be out
for public access yes how does that look like now well um what i've been doing since then is i've been
trying to approach the macro system problem uh directly and it's an interesting thing okay let me let me go
back and i'll talk about the macro system a little bit and how it what the idea was and how it works now
and all this stuff right so the idea was um similar to many ideas in this programming language okay let's
even one more step back okay so you have a language like c that was made in 1970 and was very effective
right and it was very effective because it was simple it was low level um it could target a lot of
different computers at the time um and that just meant to do all those things at once meant certain
classes of decisions had to be made and so there are all sorts of problems in c that if c were designed
today would not be problems so for example you know back in 1970 you had all these machines with
different bite sizes right you had computers with six bit bites and you had eight bit bites and you had
12 bit bites i think um and just extrapolate that to everything right so there was this extreme degree of
unknownness right and so you couldn't um you know that's why integer types on c are just sort of
of unknown size officially even though you kind of know that they're four bytes or eight bytes depending
on what you're doing and all these things right so here's the thing is that now um literally 50 years
after c was successful right we're in a very different computing environment and if you want
to make a language that's able to target low level programs like that um you don't have to degree to
to deal with the same degree of unknownness everywhere and all of this and secondly um like back when c was
made it was like this sort of like hey let's just hack together a programming language and like play with it
it's kind of like how javascript started actually right it was just like look we're just we're just
putting this thing in the web browser to do some if statements and whatever it's not a real programming
language right and that's fine to get started but sometimes you end up paying a lot more for that than
you wish you did and in in you know the last 30 years or something we've kept paying for some of
these early decisions and see and so part of part of the goal is to go back and look at the other
major language paradigm like the functional programming languages and say what did they what did they do
well what did they get right you know and i am not a functional programming language um i'm not one of
these people who like thinks they're uh the answer to everything and you know there's all these like
religious zealot people um on the internet but i mean look you know i do think they got some things
correct for example if you're building a c program or a c plus plus program or even like a rust program
or whatever now right the build process inherently involves the operating system in a very specific way
right so like a c program is a bunch of c dot c files or a c plus plus program is a bunch of dot cpp files
actually they kept changing the extension for a long time right it was like dot c plus plus and
then it was dot cxx in case x in case plus was hard to type and then and it was dot c sometimes and the
compiler was supposed to figure or it was dot capital c also and then that didn't work on windows because
of case insensitivity like just the file extension has gone through so much history in c plus plus um
but the point is uh it's just a bunch of these files right and they just live on the disk and
then what defines what your program is well it's some program in another language like a make file or
something and actually now so if you're a modern linux person it's not just there's like a cmake file
or like a ninja config file or whatever that is that generates all these other things right and and so you
need like four other programming languages just to decide what your program means that just seems
really bad and wrong and as soon as you start trying to target a lot of platforms like we do in the
games industry it's very obvious how that's wrong because you you just have your perk like i did all this
work to specify a program is the act of being very specific about what the computer should do from
moment to moment and then you bring this all over to another operating system and you still can't run it
without like doing all that like oh now i'm in visual studio so like i have to import all these things
into this weird ide or i have to learn this ms build syntax and make the equivalent of a make file over
there but it's not a make file it's a different thing right oh now i'm going to mac right and and all
this stuff and um or i'm going to some you know sometimes so for example when i was working on um
it was actually before playstation 3 came out um you know i was working with some people on a project
for like a bring up board for the cell processor when the cell processor barely existed or something
like sometimes you go into these really weird environments right and it's like okay what what do
we have to work with here and even if you have something like make i mean a lot of operating systems are like
unix offshoots or something it it often will have incompatibilities or or some of the things the
make file is trying to run to do the things to run your program or don't don't work exactly the same
over here or whatever you just run into all these endless problems just to compile your thing and it's
like okay that is a mistake because your program is like i said it's one way to look at it there's
the operational way of looking at it which is it is an extremely specific set of instructions about
what to do um so why can't you just do it why can't my computer just do it why do i have to do all this
stuff and then the functional programmer way of looking at it is like look my program is a mathematical
object the output of this thing is well defined why should a mathematical object change meaning or
be hard to interpret as you move it around right and so that was one of the lessons that i took early
on in defining this programming language is like look it's not going to require any kind of external
build apparatus at all and i realize i'm getting kind of off topic but i'm gonna i'm gonna kind of bring
it back on topic um but you know um so the the reason this happened is incidental right if you
look at the early functional languages like lisp the way they worked was it was an interpreter so
you had to kind of load all the files to do anything because otherwise at any moment you could call a
function that is in a file you didn't load so the interpreters just load all the files and then run them
and it's like okay why did we get away from that well c probably had to run on computers with
very small amounts of resources right and so maybe so so it made sense to compile things into a bunch
of small dotto files and then link them right um but the the problem of course is just you know you're
you're externalizing some of your semantics okay so that's just that's a that long explanation was
just a simple example of one of the inspirations that's not even about being a functional programming
language but it's something the functional programming language community got right
like by accident so any of these languages like like standard ml of new jersey was the same way
it would like load all the files and i think it compiled them i don't remember it was like 30 years
ago they used this but like it had this same uh aesthetic that like your program is well defined
it doesn't need the operating system to give it meaning it's well defined on its own right
so that's one thing they got right um now one of the things uh that lisp uh is famous for
or infamous for is its macro system right so now we're getting back on topic um where you know you
could take code that looked kind of like lisp code but really as long as you have a lot of parentheses
like anything looks like lisp code because that's all it is um and you could run it through a macro that
could like rewrite and exchange things around and do all these things and it was a very powerful
mechanism right and so i was looking at that and i because i wanted some kind of a macro system
because in c macros are very useful even in c plus plus they're very useful but also people kind of
hate them right like if you're going to port some code or try to understand it and you see a file full
of like all these big macros you're just like oh my god right because um for those not familiar with c
uh which is i don't know what how many what percentage of your audience is fluent in c uh
i would assume that there is a high percentage but oh hi okay i wouldn't assume that oh you wouldn't
assume high okay the point being okay so the c macro system is actually very powerful for how it works
which is just it does a textual rewrite on your source file before you compile it right and so
it's essentially a string replace um it's not a super powerful string replace it doesn't have like
regex or anything but it has you know you can do something where you it looks like calling a function
and instead of that function call you're sort of giving it a replacement string and the reason that's
very powerful is because you can completely violate normal syntactical rules and all this stuff in
terms of like um you know you can insert things that are only half of an expression or half of an
identifier and concatenate that to something else right it's not related to the parse tree or even
the token stream it comes before the token stream that's very powerful but this is also what makes it
completely undebuggable right because the rest of the programming language doesn't understand the macros at
all okay so when i went into this language i was like okay i want to do macros but i want them to be
more understandable and more debuggable and then also hygienic right which
non non-functional programmers don't necessarily know what that means
or i guess i guess some other imperative languages have hygienic macros now but what
so in c again because a macro is a string replacement um then that string replacement
changes meaning depending on where in your program you use it because uh you know any variable that
it tries to use could get shadowed like if your functions like if it's trying to read a global and
then your function defines that name and you use the macro inside the function now the macro won't work
correctly but it'll be very hard to understand why it's broken um because it's just a mess and so
that's why when people write these macros if they're intended to be used over a wide area you start
naming the variable names with like some really long prefix and a lot of underscores and a lot of
capital letters and whatever and that's not actually a guarantee that you'll never have this problem
um but it makes it extremely unlikely that anyone else is ever going to use that same name and break
your macro right um at the same time though um it's also kind of powerful in this very sloppy way
because you could design a macro where you say i'm going to use this in a function and that function
should have a global variable named x it's not even going to be a parameter to the macro we're just going
to use that and again if somebody forgets to define x that could be a confusing error message but but
you at least have that expressive power and you can design your macro that way right so in contrast
we're being like functional languages and we have hygienic macros which is that they have their own
namespace they're like a function if they declare variables or whatever it doesn't pollute the calling
site right um but then we have some mechanisms by which you can read the local variables of the
calling site and all this and sometimes these are a little bit more annoying to use like in the case of
multiply nested macros and stuff we're still working out those details of how to make it nice um
but but so far oh and the other thing about our macros is uh they're actually exactly like
functions in every other way so you they have type checking like functions unlike c macros right and
um they actually could be overloaded with functions and you know when you do function call resolution
it could be either a macro or a function it's like extremely clean and uniform in that way um
can i ask and then one of the things one of the things you can do yeah uh internal to a macro
instead of the macro being a string rewrite um it can change the code around but it does it by
reinserting new code which it can generate and that could either be in the form of a string so you
could create a new string and put it at the old site of the macro but unlike c and this is an advantage
and a disadvantage that has to be a syntactical unit because it gets parsed separately right um so you
can't do some of these weird tricks well you would do them in a different way like and see if you
want to create a new identifier that's like partly what someone passed in and then partly a tag you
just you could create that identifier but it's not like they would pass that in explicitly as a parameter
probably um as a um we're getting off there's a way that you can mark it where you say like i don't
mean this to be an identifier yet and then it can get passed in so you you can do it it just requires
slightly more syntax um but then the other way so so to try to bring this whole discussion this 20
minute long answer to an end the other um the other way you can insert code inside the macro is
uh as a syntax tree and there's a way to get the syntax tree of the arguments that were passed in
and you can inspect it and you can move the nodes around if you want or you could generate new ones
and attach them to the old ones and the thing is um so this is the equivalent of like what lisp used to do
but uh it's you know this is a um static programming language that's imperative and so it has a lot
more type checking at compile time than something like list and so what that means is you have the
equivalent of a tagged union of all the node types right and nodes pointed other nodes and those pointers
could have subtypes right so like a declaration has a slot of the name and that has to be an identifier
it's not like a general node and whatever right so there's there's type checking on all these things
and so that just means when you're trying to do these rewrites it's uh it's not as simple as it
was in lisp right because in lisp you just say oh take slot three and put it over here and whatever
and now it's like you're assigning specific pointers with specific names to all these nodes
and i just i knew that going in and i wanted to do the experiment of like what does this look like
because i'd never seen anyone do it and it works but it's like uh it's a little tedious
and so there's some combination that we want to do of user level functions just to make this easier
but then also further compiler support we had a new idea come in a couple weeks ago from one of our beta
users that sounds pretty good to me um about just a way a way to compose code from pieces in syntax
without without going all the way to the node representation and editing those data structures
and coming back which you can still do but and you may want to do in specific cases but the question
is like can we make it more facile and so that's just that's part of the picture like i i just wanted
to give you a real answer about all this um and and why like the explanation of why it would take a
long time to figure out the reason it takes a long time to figure out is because we're trying to do the
best thing and i don't exactly know what the best thing is for any of these like if i knew what the
best thing is i could sit down and program it and it doesn't honestly take that long usually right
but it's these last few issues are the issues where like i kind of don't know and some exploration is
required okay on that note in jai you have compile time execution so yeah isn't this sort of adjacent or
like an alternative way of doing the same thing with macros yes so there is a question this is a
constant question of like you know when you start implementing some functionality is this really the
best way to do it should you be doing it a different way right um
um and there are okay there's sort of two in the abstract there's two extremes that you could land
on and the extreme is never the right answer right but one extreme which is what you will learn if you
go to a pretty good computer school and they teach you about programming languages right that extreme is
the actual base implementation of the language should be the minimal thing that achieves the
functionality that you want and then just higher level features should be buildable at user level
by composing these language kernel features you would say right together to build things and the
problem with that is that could be very slow and very hard to understand if you go to debug it and
like ergonomics matter right uh you know if you're going to sit down and program something
when i'm first learning a language it might feel awesome and fun and cool that it's like very minimal
and provides all these weird ways for me to combine the minimal axes of functionality to generate
what i want but on day 1000 in a row that i've been programming in this language
i'm not going to enjoy that anymore if what i really want is to get the job done and not have to
do a bunch of stupid things right so that's one reason why that extreme is not good like ergonomics
matter and it really matters that what you want to do frequently is easy and fun and readable and
understandable by other people who are not you or understandable by you three months later when you
go away and you haven't looked at the code and you come back right uh the other extreme which happens
with like a lot of the time when people enthusiastically design programming languages and like don't have
an education in this stuff or or haven't i mean not to like i don't i don't respect computer science
education that much i mean it was good that i went back then but now it's you know it's literally 30
years later than i was in college and like all this information is on the internet and you can get
it on your own if you're diligent you just you have to be good about really wanting the high quality
information because there's also a lot of trash out there um but uh the other extreme is to be some
language like pearl or whatever where you take that ergonomic to the limit and you're just like
look anytime i think of a cool syntax that lets me say something in two characters less than i would have
been able to say it otherwise i'm just going to put that in the language right and the problem then
is your language becomes incredibly complicated and full of all these constructs that everybody has to
learn and you know if you have language tools they all have to implement and understand all these things
and like your syntax errors get way worse and less understandable which is very important um
i'll get back to that in a second right but but like the more syntactical constructs you have
then anytime you make a minor one character mistake the less the more likely the compiler is to be
wrong about what it thought you were saying and so it could give you a different error message for a
different situation and you're like wait this is what's it talking about and it takes you longer to
debug right so the thing to understand is that error messages are the user interface of your entire
programming language they're the main interface that programmers deal with and so if they're not good
like the amount of work that everybody has to do goes up by a large factor it's very expensive for your
error messages to be bad and that's why you shouldn't use these compiler generation tools that they teach
you to use in computer school because um they lead to worse error messages among other outcomes um but
uh okay wait what was the original question the question was what weren't macros are to do does
macro system work the same way yeah yeah okay so here's the thing when we come to this topic um
um there's a little bit of redundancy between several things so we have regular functions
right so i just said macros look like functions right we have regular functions we have inline
functions which are mandatory inline and that would actually be classically in c one reason that you
would use macros because you didn't like function calls in the old days were pretty expensive and
sometimes you wanted to make sure you avoided them and so you would just use a c macro to make sure
that you didn't have a function call there and that's still i would say the use of of that is much
reduced in the modern day but it's still a thing like sometimes you really just want to make sure so
we have inline functions for that but you also could use macros for that so that's that's some overlap and
redundancy um and then there's compile time execution and the answer is yes there is redundancy there
however um i think it falls into the case where the ergonomics matter enough to maintain the redundancy
and i'll try to explain why right um one thing that i got correct early on okay so a lot of things in
the design of this language reflect frustrations that i had trying to learn all these things use all
these systems as a as a programmer for a long time and one of the frustrations that i had is when you
start trying to use a programming language and it's too soft so like tickle or pearl were like this or php
or you know javascript without type checking like typescript or something on top um they're too soft
and it leads to like all these like i typed an undeclared identifier and it took me a half an hour to
figure that out because it just i tried to use it and it was the empty string and like now i have to
have a debugging session to figure out what was going on whereas in a statically typed language it takes
a tenth of a second to know that that identifier is undeclared right and this is a very very valuable
thing right so softness versus hardness is important and so one of the things that i felt
when i was doing this compile time execution the initial implementation is i had all this experience
with these interpreted systems you know the first computer class at berkeley where i went to school
was using scheme and scheme was not uh compile time statically typed uh and it had all these other
problems like it didn't it didn't have very many actual data structures and whatever so you do everything
is lists and then you would have these debugging sessions where you pass a list to your function
and the function expects it to be a certain shape and it's not and you're like what's going on i don't
those were and it's a tremendous waste because it like all these students who come to the school and
they're like i'm gonna be in computers and i'm gonna do awesome stuff and you give them this first class
and they just have all these horrible debugging slogs and they don't actually get to do anything creative
it was horrible this is by the way the sick p book that everyone says they like structure and
interpretation of computer programs that's what this class was and i would not teach things that
way at all at all um i think they've rewritten that book now to use python or something
i don't know if that's any better in reality but um anyway so uh the the decision i made early on
was there's actually uh okay so when you first implement compile time execution what are you going
to do you're going to add some statement into the language that says run this at compile time right
what is that what does that do well maybe it's going to call some functions right where are those
functions well they're just like in my program right and so the thing the red light alarm light
that went off early on was oh there's going to be kind of a mess once programs get complicated that if
you're running things at compile time like you're going to have some code that you really want to just
be compile time code and not in your target program and if you just have this statement that like run
things at compile time then how do you how do you know and then when you get to like cross compiling
and stuff like you may have different implementations right so like open a file if you're on you know
windows and you're compiling for um you know arm then open a file is going to call a completely
different low-level api on the host machine than the target machine and so you just you have to have a
way to keep this straight right and and that was clear early on um and so the way that i did that
is by having the default there's a way to make your meta program right in a way that's very clear and
completely separate from your target program it can't see the target program at all um right there
are advantages to that i can work in the meta program and not worry at all that i'm breaking anything
about the target program there's no namespace uh overlap so again one of the big problems that
happens in in c plus plus um and it's especially weird because they added these namespaces but the
namespaces i mean those were in like c plus plus 11 or something but the namespaces are implemented
exactly the wrong way so you could still have a conflict between namespace names because the name of
the namespace is defined by the person who wrote the header file not the person using the header file
and so that's a complete disaster um but uh the the problem in c and c plus plus that you have
as well as many of these other static languages is um again um you know if you include things and they
all contribute things into your global namespace you can have a name conflict right i was very upset one
day i had my own this was many years ago but i had my own code base with all this code for doing 3d stuff
and i had my quaternion code and it used a struct called capital q quaternion that had to be included
everywhere because you do all this math and use it everywhere right and then i went to port this
to a nintendo gamecube and i told this company i'll port it in a week man which i did i ordered it in a
week but the first day and a half really sucked because i went in there and the nintendo sdk used capital
q quaternion for everything and you can't you can't change their header files right so you have
to rename it in your whole code base and so i also i had a great deal of frustration with that i had to
name it my quaternion or something right in all the files um so i had that kind of frustration a lot and
so we have extreme partitioning between namespaces in this language and that causes a little bit of
friction but it solves a lot of these problems so the the problems that i'm focused on solving are
the problems that you have as your language or as your program gets big and complicated
and and that's another thing like a lot of people when they design languages they're like oh won't
it be cool if you could do like an if statement like this and it's like yeah but that doesn't solve
the big engineering problems that just feels cool when you're first learning the language right and
that is one of the frustrations that i had that makes me made me want to do all this work to make
a language in the first place is i looked around and very few people were actually focused on these
large large scale high complexity problems all right okay so the way that works here is probably your
most complicated compile time execution takes place in a separate program essentially right and so there's
no cross-contamination there's no namespace pollution they can have different implementations
of everything but they can also share code very easily if you want so if you're importing some
you know uh what's a good example like a string library or something you can just import that on both sides
and use it and it's fine right okay but for ergonomic reasons you also can run things just in your actual
main program right you can just have a command that says run this thing and compute these 10 integers
that i'm just going to insert as a string or something right because that's a very small thing
that's maybe easy and if you're not that worried about it polluting your program it's much more
convenient to put it at the site where you want to do it as opposed to in this separate program so
then the the the role of macros to finally answer the question the role of macros in all this is
there a convenient way to uh to invoke that kind of compile time execution in a way that the user
doesn't have to worry about very much because they're just calling a macro they give it some parameters
the macro can say like okay what do i want to do let me run this thing at compile time take these results
put them together in this way and insert that back into the program and um uh so yes it is in a sense
redundant because you already have compile time execution in this other place but if i were to
remove that facility i think a it would be a lot less convenient to do compile time execution in a lot
of cases but b um the power of the macros would go down incredibly um they would almost be like not
worth having anymore if you couldn't do compile time execution because we would have to you know we
would have to add some entirely different macro language for like manipulating things declaratively and
it would have to be incredibly complicated because like i said there's all these nodes and all these
different types and all this stuff right um so i don't know maybe there's a way that you could make
it not have that much syntax but behind the scenes it would have to be doing all this type checking and
stuff and so so yes in a computer science sense it is redundant functionality but boots on the ground
in terms of what am i trying to program um i think it is the right thing to have it invocable in both
places okay okay does it do you want let's tune this do you want shorter answers or do you want
in-depth that's fine that's fine in-depth answers it depends how much we need to get through
in-depth answers are great but this means that you're up to five hour discussion
and we'll see what happens uh okay does it mean then
that if you get the macros done so that you're happy with the system you think it's functional
and you get the other issues on the roadmap jai becomes open sourced and gets a committee
standard and everything everything that is below it in the c++ world what happens next well
there is some vague roadmap that does not have dates attached but it's in phases and okay so
phase one is where we are right now or you could call it phase zero even which is just it's a closed
beta we have a bunch of people in the beta using the language um but yeah it's not it's not accessible
to the public but we don't restrict um what anyone does with their code so you know if you search for
code that people have written or are sharing like that's out there it's just look at the compiler and
and the um the core uh modules that we ship are just closed for now um phase let's just say that's
phase one so that we don't get confused so phase two will be um probably an open beta of the binary
compiler right where we're not giving out source yet but everybody can use the language and that's
actually the biggest step because once we do that um it becomes a lot more costly to make changes to
the programming language that break people's code and all that right and so that's one reason why
we're going for so long in this closed beta and why for these features that you mentioned like why i
feel it's important to finish them before we do that but so so that's the next step after these features
get reasonably subtle now we do we do have ways there's a few ways even in the closed beta how we
accommodate changes so if we're going to change let's say we're going to deprecate some syntax or
something and change it right what we do is we release a version of the compiler or even a function
let's take a function in the standard library we don't call it that but it's the equivalent if there's
some function we want to get rid of or change to something that works totally differently first we
deprecate it and there's an official way to do that just on the function we can tag it with a message
and it generates a warning when you compile and then we just leave it that way through
several compiler versions like every time you compile you get a warning this is going to stop
working eventually and then it at some point later we actually take it out and so people have a window
right and and so that kind of technique can help even when you're in open beta but
you know like the more open you are the more there's going to be people who tried it and wrote some
code and then they got busy for 10 months and then came back and that version of the compiler
it no longer works and they're forced to update their code away um so that's one reason why we're
waiting a long time now that all that said the the meta programming that we have does make it in
principle possible to rewrite your program um automatically to track features as well but like
like we haven't done a version of that that like maintains comments in white space and stuff and
so that's not that fun um and and that's also like in principle like we don't um
we haven't like actually done that on a very large project like the game that we're working on
we haven't round tripped it through that mechanism so there's probably all sorts of things that don't get
rewritten correctly but that's that's another plan that we have eventually is like you could just
run a thing that just automatically converts your features um okay so then phase three would be
probably okay now during phase two when we're giving out the binary there's always some people
who are going to be like look i want to use this language but uh i can't unless i have source to the
compiler because like look what happens if you get hit by a bus or something like you just die um our
project then doesn't have that clear of future um it does to some degree because again so the same
meta programming power that i just mentioned um can let you do other stuff like you can automatically
transcribe the language to a different programming language in a way that's more robust so you can
always imagine doing that just from the text files but that's actually in some cases pretty hard because
it's more than just parsing the syntax like you have to know what's a type like especially if you're
converting to c or something right and what all these things and um but from a meta program you can
actually do it tremendously more robustly because you actually know the meaning of everything like if
i use a variable called x i can tell you exactly where x is defined because we can see from the
meta program the the linkage between the two and so there's no ambiguity about names spacing or anything
like that right um okay but uh so for those parties during that time we would probably give like a
closed copy of the source right because we you know we want people to feel secure so and the point of
that would just be like look if a bomb goes off where i live you can still compile the compiler and
you're fine um okay so then phase three would probably be we're publishing the source and maybe we're
taking bug reports but it's not some kind of like community project at that time right and the reason i
would do that is again i i think so i think when you have the chef model where
the chef is trying to make a very good dish um that works very well uh up to a point up to a certain
point of scale right and to be honest it gets you up to a level of quality that i've literally never
seen from any community-based open source project right and this is this is going to get all the flames
in the comments but it's also going to get the clicks for you right like the the theory behind
open source is hey you have so many people working on the code it just can't help but be incredible
all the bugs will get fixed and it'll do all these things and if you actually look so linux is but one
open source community right but let's just take that linux user space it's just incredibly full of bugs
and it's very slow and it doesn't in general implement any new functionality really ever
um it's just copying old functionality right like even stuff like so in the beginning linux had stuff
that might seem kind of new if you weren't that experienced so like the fact that you could like
alt arrow key around or whatever it is to get multiple desktops and you'd be like windows can't
do that and it's like yeah but twm on you know on unix did that in like 1990 or whatever right a couple
years before the linux kernel even began so like all these ideas came from somewhere and we just haven't
seen the ability for creativity to happen with that kind of development and maybe that's not a surprise
right because if you have a large number of people it's easy for those people to contribute
incrementally but creativity involves whatever whether it's one person or some number of people
it involves those people steering the project very deliberately in a into a very specific place and
that becomes harder if you're talking about a bunch of people contributing incrementally it also becomes
harder even if you're ostensibly in charge of the project if you're trying to take all these inputs
from this big community who's contributing if those are going in the wrong direction but you're spending
all your time fielding these inputs then it's like you're trying to push your way through a river that's
flowing in the wrong direction and trying to get somewhere and so um i would like to protect against
that for some amount of time but this is all this is forecasting like who knows who knows how it will
go when we actually get there but i would like to do some amount of time of that and then at some point
we would certainly probably uh license it in such a way that people could just fork it and do whatever
they want with it at some point but again i think that's a big part so going back to linux for example
i think that's a big part of what has killed uh linux in a certain way i mean obviously linux is not
dead but it just it doesn't it doesn't have momentum and it doesn't really make progress and that's not
unique to linux either like windows doesn't make progress either and mac os doesn't make progress anymore
either but i think on the on the proprietary operating system side the reason is different
um if you look at something like the linux ecosystem um again there's a tremendous number
of contributors right but everything is so forked and there's so many different heterogeneous
environments and like everybody's introducing new stupid things all the time that do the same thing as
the old stupid thing but different so you have to rewrite all the stuff and then when you do it does the
same thing as the old thing right and there's so much of that that like all this effort is extremely
diffused and it can't push the thing forward at all and then again like i said it's hard to have
imagination in that context and often it's like okay you know we've we've all probably just seen
some really cool videos of a rocket ship getting caught on a tower and it's like the biggest heaviest
rocket to fly i actually don't know if it's a little bit i think that version is a little bit lighter than
saturn 5 was but like the full spec version won't be um but the point being like that's not something
you get by incremental contribution right that's something you get by uh someone is driving to a
specific point right and in principle that should be what proprietary systems are able to do and they
used to be able to do that but the problem is they're not able to do it either anymore right yeah
um unless you start something new in like a small startup company like microsoft is not going to give
you the new awesome operating system right yeah like all this ai stuff you could in principle design
a new awesome operating system or it would still be terrible while we work on llms getting better but
like what that would look like would probably actually be tremendously different from a typical desktop
operating system but um nobody's gonna do that they're gonna do the microsoft thing where it's windows
but we also spy on you by screenshotting things and randomly close your windows sometimes when you didn't want
to or something like that's how it's gonna work um so so i'm not i don't want to turn this into like
closed source is better than open source or whatever um even though it used to be uh i would say
i would say it's still a tie uh they're both not making progress so so that's what we're trying to
isolate against with this kind of roadmap um but yeah at some point we would fork it and let people
run it um i don't know that i would be using the public fork at that time um we might well just
let our private one diverge or or maybe we just consider the project done like i have so many
things to work on like at some point i just need to hand this off to somebody as well and like do
something else and become a more more of a minor contributor because like i've got all these games to
design and stuff right so you had but that's that's the road map is eventually yes eventually
it would be completely open source on github and you can do your patch requests and whatever but
it'll probably take a while to get there honestly you had the idea to make it uh paid and remain like
closed so yeah what happened to that um well this was just a trying to figure out a way to fund more
work on the compiler and i just don't estimate that anything we would do would have a net positive
impact or i haven't figured that out right so right now the open beta is free that's great um anytime you
charge for things you get less people using it than yeah than the than the free people right and so um
um so you cut down on the size of your beta which is maybe um maybe fine but maybe you get fewer bug
reports and so you don't get to fix the problems as fast and then how much money do you get and it's like
well you know we have we have around 800 people in the beta right now i think it's 790 something
yeah something like that um not all those people are probably active because i'm not tracking you
know i don't put spyware in i don't track i would be kicked out i would be kicked out if you did that
yeah yeah um but but you know not even to kick people out but just to estimate um like if i wanted
to estimate for purposes of doing this computation how many people are active right uh like let's say
say i somehow managed to get a thousand dollars from every member of the beta which is a lot of
money and wouldn't happen right that's 700 000 that sounds like a lot of money um but
and it actually would that would make a big difference if we got that much because that
would pay a decent engineers it would pay like one decent engineer for like two and a half years
probably or two engineers for less time or whatever right and that would make a material difference but
that's not how it would go right if i said hey the beta is a thousand dollars there's some people in
the beta for whom you know like every person makes a different amount of money and a thousand dollars
means a different amount to those people and so the people who are uh who have less disposable money
would bail out and all these things right and so i don't have the ability to predict how well it would
go um so i just i i just also haven't done it because it would just be it would just be super risky
and weird to to do that um i think there are other routes you could do so you know historically
sometimes projects get funded by commercial vendor support or something right while we're in a closed
beta and nobody can use the language it's hard to envision that happening right but once it becomes
more open you could sort of picture that in some way although sometimes that comes with strings it's
like hey we got some money from electronic arts but they really want us to put this one feature in
or whatever and it's like well i don't know if i would have done that so that's a danger um but i
don't know but that's the reason why i haven't done it is because i'm just not sure that it would be
a good idea okay yeah i rewatched the video you the presentation you've done uh while starting this
project uh of making a new language and yeah yeah you said like c plus plus ship is done sailing
even though like it's kind of 10 years i tend to be very early on yeah things but i think a lot more
people would agree with that statement now yeah um a lot of people are very upset about c plus plus now
whereas back then so this just to put this in context i believe this was in 2014 yes this one that
you're talking about that's actually not so that initial video i think i made two videos like before
i had an implementation um but then i think the third one like late 2014 like november or something
is is an actual demo of the first version of language and that's the one that i would recommend
people look at if they want to see the early because these first ones you were talking about are just
more like here's a bunch of ideas i have and then i think a lot of those were replaced by better ideas
later in yeah development yeah but they are very inspirational i i found them yeah i found them
really like you know here's here's this idea like here's the state of things now and here's where we
could get to but yeah like the syntactic syntactically yeah i felt very good when i recorded those videos
because prior to that like at that time i was still working on our previous game the witness which had
been a long project of its own and i was programming in c plus plus every day and i would come in and
like i just compiling the game took several minutes which maybe doesn't sound that long to some people
but like you know i had gone from braid which i had worked very carefully to keep braid fast to compile
but like in a lap on a laptop in 2008 this game that made you know several million dollars um took
seven seconds to compile on on a thinkpad t42 right that's what i remember i was timing it
and it was seven and a half seconds um and then c plus plus has gotten so bad that on a modern computer
if i open up the old braid code base it probably takes longer even though we're many years later
and computers are in theory much faster it's just the compilers are a lot slower so there's that
but then then you know the witness was a bigger more complicated game with more people working on it
and they're not as careful about you know minimizing compile time which if you if you're not careful
about that in c plus plus it can get away from you really fast because of this problem of you include
all the header files many times so c plus plus is very pathological and c c has the same problem but
c plus plus doubled down by putting more when you do templates and stuff it naturally wants you to
put them in header files so header files get bigger and bigger but the problem is it's incredibly stupid
in in the modern day because you have let's say hundreds or thousands of files and each file includes
a bunch of header files which include a bunch of header files which include a bunch of header files
all those headers get recompiled for every single file for every single c file and then all that debug
information gets written into the dot o file for that c file so now you have all these dot o files
on disk a small fraction of which is the actual code you want to compile but mostly is debug information
for the headers and then the linker comes along and it has to put all these dot o files together
and you have 7123 copies of the same information and it has to deduplicate all that down into one
and that takes a lot of time so you spend all this time generating all the redundant information
and you spend all this time condensing it back down and that's one of the reasons that c plus
plus programs take so long to compile um and so i was really suffering from that on the witness at the
time i was like dude i'm supposed to be designing this game but i'm also doing all this programming and
like it's just miserable and it's it's miserable not just because of the c plus plus part but also um
um you know you end up with all these build processes so like we would bake light maps for
the world which is like a way of predetermining where light lands in subtle ways so that the scene
looks nicer and that's being done by some computer right offline or in either in a corner of the room
or like in a server farm in texas or somewhere and
and so that's generating all this data and it takes a bunch of time to like update
all that because it's a large amount of bitmap data and um
you know so you come in first thing in the morning and that's like really tedious and so then
your programmers other programmers on the team spend some time writing a little desktop tool to
like update your stuff in the middle of the night while you're not there but then you run the game
and it has to like compress the textures because they're not compressed the right format in as they
pull them down and that takes time or like you turn that off for several days because you were working on
some really gnarly bug and you didn't want things to update and change while you're working on the bug
and then you forget to turn it back on and then it's not updating or like it updates but the light
maps don't draw correctly whatever there's all these problems that happen like development when
when you start having a lot of binary data there's a lot of friction and cumbersomeness that comes along
with that also and you have to be very careful to manage that and so toward the end of that project we
were sort of suffering on both of those axes so i it was not uncommon that i would come in in the morning
and like i couldn't really work for like the first 20 minutes or something and like when you when you're
being bothered by something and you want to come in and do something it just sucks to just be like
sitting there like oh what am i what am i doing right now right so um but but a big part of that i felt
was the c plus plus and so when i made that speech it was really exciting because prior to that i felt
like most programmers feel like every programmer who's experienced i think feel some version of this
right like if you're a javascript programmer you've got your own problems with like npm and like how big
the code is getting and what whatever those things are right like because we've built all these systems
where we don't have the proper respect for how bad complexity is and how far it runs away with things
and how much it deteriorates our ability to program right and so i was just feeling that and i i thought
what any programmer thinks which is like well this is just what it is i can try to do some stuff to try to
mitigate the problem but i can't i can't do anything right i'm helpless to solve the core problem and
then one way i just woke one day i woke up and said no i'm not i actually i used to i used to make
programming languages for fun in college i could do that again and do a serious programming language this
time and you know actually in that first talk you're talking about the first video um i actually bring
up i think as an option like look it's a lot easier to do this than even a single video game so you can
have a coalition among different people in the games industry and then i decided not to do that again
because of all these inherent issues in collaboration it's like everybody has a different idea and you have
to have all these processes and discussions and you just move slower and so i just decided to just do it
and so i had a demo for that third video yeah um which actually worked very well but yeah it was
motivational for me i guess is the point because i woke up and i i was like wait i don't have to be
depressed if i actually do this myself i i think because you're citing as uh alternative languages you're
citing there like d go and rust and since then there's zig odin c3 hair which are all like new
languages that are sort of like modern c alternatives yeah with with manual memory management i feel like
you're not alone in this like this interest with c plus plus what no and in fact i think i think that
video so i know for a fact that at least one of those let's not get into language wars and like
comparing against me but you know i know i know at least one of those and maybe multiple were directly
inspired by the stuff i was doing at the time because other people said like oh yeah we we could
make a language right and then they did their version of of what they think it should be right yeah and i
think um you know i think i i would rather have my language than than their language for all of those
um but that's that's what you would expect any of these uh creators of these languages to say and so
we kind of just have to see how all these things mature and play out but i do think it's much more
healthy like this is what computers used to be like right was you had all these people doing all these
initiatives and then at some point like at some point in the 90s in the mid to late 90s when the
web took off that all turned into like innovating on web stuff and then at some point it all focused
into javascript frameworks like that was the only random creativity that happened was everybody was
making javascript frameworks all the time and the problem was
because because it was a growing field and like all these web programmers were coming in and were
relatively new at programming they didn't really know the history of all the programming languages
and stuff that came before so they didn't know that they were like mostly
doing things that had all these problems that we knew about like yeah okay you're making this
event-driven framework that's actually not going to be that good even if you do a good job at making
things event-driven because event-driven isn't actually that good for the following reasons and
just people had to relearn all those lessons because um you know if you don't if you don't know even
recent history then they can come back and and bite you um but and then at some point even the javascript
frameworks got hard to make and then we i think we had some years of like literally no creativity
and now we're back in this more positive space i mean most of this stuff is trash to be fair like but
but now we're in this space where you have a lot of people doing random ai stuff and they're mostly
script kitties just calling into you know chat gpt's api or whatever but still there's some creativity
there and then you have people doing new programming languages right and again most
of these programming languages are just largely leaning on llvm we also do we use llvm for
optimization but um we actually can't build an entire binary without it um and i you know all these things
that i was complaining about about code being too big and complicated and cumbersome and taking too long
to compile and being too big in binary form and all this that applies just triple to llvm like we don't
even when we make a debug build of our compiler um we don't even link debug llvm because it's so hard
because like the just the just the dot o files and um libraries i think are gigabytes of data like
i'm pretty sure i'm not exaggerating it was just like it was such a headache for source control to
like pull that stuff down even if you're not compiling it that we were just like no we're not going to do
that so we do a release llvm we we update it rarely you're gonna you're gonna talk to chris latner about
it at some point yeah probably um but i don't i mean i don't think he can do anything about that at this
point because it requires a and and he'll probably disagree with me he would probably say no man that's
when you have a lot of people implementing a lot of functionality that's what happens or something i
don't know okay well i'll we'll see stay tuned to see how that conversation goes you but i don't
think i don't think it's productive to just have a conversation with him where i just say llvm sucks
that's not i tried that via direct email to some people on the lvm team once and they just didn't
reply and i never heard from them again so yeah and in this first talk you outlined like five things
that would be like principles for this language jay and yeah it was friction reduction joy of programming
performance simplicity and design for good programmers can you comment on what do you think
you achieved after 10 years with jai on these pillars i think most of those we've nailed um i would say
the language is getting a bit complicated in terms of all the features um it's probably more complicated
than i would have pictured in the beginning so i would say simplicity is the only gray area but
that's always something we're looking like i think step one so so rather than
like if you want to build things in the real world right
if you try to optimize on every axis at once sometimes that makes the problem way too hard
and you just fail right and so in terms of these five things it's like okay what what is the most
important well if we don't get back some of the joy of programming relative to c plus plus or whatever
then what's the point if i'm going to be just as miserable using this as plus plus then i lost right
so that's incredibly important um you know some like low friction is related to that and all this
um simplicity of the language things that are simpler are easier to learn and easier to use and
easier to write and all that but simplicity also causes problems right so like the scheme language that i
mentioned earlier is a extremely simplified lisp right but the simplification causes problems although
a lot of the problems are also problems that lisp had to begin with so whatever right um
anyway the point is just uh things are more complicated than i would have envisioned in the
beginning um they're way way less complicated than c plus plus though like c plus plus is um i mean i'm
not sure that i know anybody who knows the whole language now like that's how complicated c plus is
they're probably i'm not saying that nobody does right but probably a lot of the people who know the
language are not getting a lot of real work done in the real world um because there's just so much stuff
in it now they just kept going and going i stopped around c plus plus 11 or 13 or something um i just
don't even look at new features from after that time um yeah but but so that's um that's something
that i would love to improve on and so the goal is just to build out the language to the level of
expressive power that it needs to be or that i would like which it's almost there um but again
like the macros are not as powerful as i would like them to be they are they're as powerful in terms
of what they can do in the end but it's just like sometimes it's hard to do it it's too hard to do the
powerful thing we would like to make it easier um and then uh you know with regard to
the stuff like dll's that you mentioned in the beginning that's it's like okay there's this
friction point that was caused by a very early decision in the programming language which is
having the context and well after using that i think that's a tremendously valuable part of the
language and i don't want to get rid of that so instead we have to solve this other problem that was
introduced in order to have this level of power everywhere otherwise you only have that level of
power like up to the dll boundary and then if you call a dll you have to say like you know no context
on all the functions or something and then that means that some of this power that we've been
introducing like the ability to customize allocators and whatever cannot cross dll boundaries and that
adds complexity and you have to deal with this problem as a programmer and that sucks right and so
um those are complexities that we would like to address to the best of our ability and like i've said
uh we haven't worked out the right answer yet and so it just takes time um but i think i would say
that we've nailed at least for me um most of those things and just the simplicity is
the simplicity is a little bit gray um but again i mean relative to c plus plus we're so much simpler
like if you i don't even know if you were to write out the full c plus plus spec i don't even know how
many pages that is now um i guarantee ours is much much shorter and we do more that's the thing is
we have more expressive power than c plus plus by a large margin because at this point they're trying
to like backfill so one of the proposals is like you know how to do better runtime type information
right and the proposals for this are extremely painful and still kind of suck compared to what
we have which is relatively more straightforward and simple and easy to use and all these things
and so i think on a relative scale we've been successful there it's just on an absolute scale
i would have liked the language to have simpler semantics than it has currently yeah for sure okay
i have a last question regarding joy and then we can move on yeah he can you can not answer this
question if you don't want to but i've seen i've seen a comment on youtube i think uh that the name
of the language was a speculation the name of the language was coming from an acronym like just an idea
and this is why it was called jai um here's what i'll say i'm deliberately leaving it um ambiguous
and the reason is i don't like so this is all a pushback against one of the failures that i saw
in the open source world right and what would happen is you would go on hacker news or and you would
read these titles of people introducing their project or you even go this even goes back to computer
science research papers somebody would say like you know blammo in capital letters colon an algorithm
to do pathfinding faster or whatever and they always put the name first like their awesome cool
name that they thought of and then they tell you second like what it does so it's like this really
bad stupid form of marketing that always irritated me because you look on hacker news and all these
projects come up and you're like i know this thing sucks and doesn't even really do what it was supposed
to do and is super slow and crashes half the time on input but they came up with a really cool name
that they're excited about like there's this the culture was a little bit broken right the culture
was hey everybody can contribute that's the great thing about software and as long as you contribute
and you're excited to be programming then we're happy to have you and it's like well also though
you should be doing good engineering and you shouldn't put broken like if you put broken things
into the world but you advertise them as if they were not broken and you tell everybody use my thing it
solves your problem you're actually adding pollution so now somebody who comes along and wants to solve
that problem has to do a web search like is there a library to do the following thing and there's 17
hits and like some of these are like a bunch of crap that somebody just put out once and like never
never even really did it the job to begin with it's just they were motivated one day and then they
posted it and then they got demotivated right and it never and you have to sift through all these
things and like try to figure it out and and all these have cool names right and so the point was
let me just not have a cool name and not advertise based on that's also why the name of the company
is in a weird awkward thing that's nobody knows what it means and it's not
i very i haven't had specific questions regarding the marketing anyway we'll get there um but that's
why and so um i will say it is not a self-deprecating acronym like just an idea is such a dumb thing to
name your language because uh because you're like saying oh my thing i'm not really trying to do anything
useful or important i just had an idea one day man just no that's not i will i will unequivocally
state that that is not what it is okay but we're also we're just being deliberately like non-markety
about the name okay but you have to at the same time you have to like type something to run the
command right yes i could have called it compiler but then that would have run into namespace conflicts
with other things so okay but it's also more type uh it do you still say that this is unnamed language
and it can change the official name would be different yeah maybe maybe okay i don't know
that's not too serious either it's just the most important thing to me is that the semantics of the
language are strong like the syntax even is like i don't care that much about the syntax right we changed
some of it recently but it's mostly the same um with the you know with the christmas christmas beta
edition where where you created like three different ways to do the casts just so people can experience
different ways okay yeah that was that was a fun little thing to do it only took a few hours on one
day to do that and i was just like all right let's just try it and then we'll delete most of those ways
later and it'll be fine okay let's close the jai section and start the game section but maybe we
can take the break a couple of minutes uh okay yeah i'll refresh my two what is the status of the game
also unnamed uh or sometimes called sokoban or sometimes yes game three for like the older people
no no game three is a different game so this is this is another question like you had in your twitter
bio that you're working on two games but all of the sokoban stuff is one game where's the other one
okay well okay so for a little bit the other game was the anniversary edition of braid that was if you
look at my twitter bio last year that was the other game but since then that has shipped and
we now have um another game it's actually it's kind of on pause right now um it's unclear
whether we will finish it or not it depends on business business randomness that is happening
right now okay um but it is a virtual reality uh music oriented game and that's using the same engine
as the sokoban game we just sort of ported it we copied it over and um you know deleted all the gameplay
code and then you just have the engine there still uh which by the way is a similar thing um i guess
we haven't mentioned this but part of the whole plan related to open sourcing the compiler is around
that time or maybe before uh for the closed beta people we'll be releasing our full game engine um which
is nice because it's actually a commercial quality thing like right now if you download the beta there's
examples of games and all that right so we give people code that where it's very easy to just like
open a window and start or you know there's like the invaders example which was in one of those early
videos which plays music and reads the controls and you could play a game and it's all there and you
could start with that and edit it and change it into whatever you want but those are not full-scale
commercial quality you know modern graphics api things and so um this other engine that we're going
to release eventually uh is all that um and yeah so so we essentially did a trial run at stripping the
game and the engine apart and uh did that to bootstrap this game um it runs on the meta quest 3 right so
that involves cross compiling to a different cpu and different operating system um android on arm
uh and it all works great and um you know we do we you know you can uh it's it's not a very uh complete
or polished game but you can put on the headset and use the controllers and play a game that does all the
things it does controller tracking and plays audio and all these things but is it it does is it planned
to be as like a commercial game with actual things or it's like a simulation thing no it was the plan
was that it would be a commercial game um and uh i just don't know i would like to do it eventually even
if this business randomness does not resolve but um that may just change the schedule by a lot because
you know if we can have funding for it that just means we can hire an additional programmer or two
who can work on that right and if we don't have between this other game and the compiler and all that
um i have a lot to do and i have more programming to do than i would like to do i also need to design so
right now on the on the sokoban game slash game four slash all this stuff um i am uh working on
the ending right now and that's in sort of very intensive design process and so that's time that i
can't spend programming either when i'm designing that or sometimes i'm doing gameplay programming in
support of the design because it's much easier to implement your own design than to try to talk to
somebody who will do do the things that you say like if you're a if you want to be a game designer
uh it's very much more powerful to know how to program even if you're not like a good programmer
right even if you just do scripting or whatever it's way better than if you're like a helpless designer
who can't make things happen uh but anyway so that that's the situation there is like
would i like to do that game eventually yes i so what happened was the way this started was um
more than a year ago uh i just tried out the quest 3 because i was like i'll i just want to keep up with
what's happening in virtual reality and i was just really impressed by how good it is um like it doesn't
require uh you know like previously i had used like the valve index kind of thing or whatever
htc vive what whatever um and that has all these base stations that you have to set up and i just
wouldn't end up maintaining that because it's annoying um but this it's very easy to put on and
the tracking is approximately as good it's not quite as good i think as the the those base stations provided
on the valve stuff but it's almost as good and it's untethered which is the big difference i mean i bought
a wireless radio for the vive but like i never hooked it up and it probably wasn't that good
um but it's just a really great experience and my big disappointment in that sector is i just think
all the games are uh not very creative like vr game developers have not figured out how to do the
design to make their games so interesting that people want to do that because there's plenty of good
games you can play without putting on a helmet right so if you're gonna put on the helmet there
needs to be a reason and a lot of the time people think that reason is oh it's so immersive because
of vr and like i don't think that's a real reason um but i i think there are game mechanical things
by which a game can differentiate itself and you could have an experience that's very different from what you
could have just on your desktop and i think game designers have not been very good about
figuring out what that is and i don't exactly know what those things are but this game was my way of
like wanting to go in there and explore and figure it out but the thing is like i said i have limited
programming bandwidth so it relies on you know having other people do the programming and right now
that part is in limbo okay okay so can you tell me about the scope of game four slash sokoban
yeah because i've heard and saw sort of statistics about like the scope of this game which seemed
incredibly huge it is very huge um it is probably
the biggest like if we're going to say like handcrafted high quality puzzle game right if
that's a category this is easily the biggest one of those ever made by some integer factor
right that i don't know what that factor is there are some other so the game has um we don't know we're
actually going through and editing and cutting out levels right now because there's too many and
you want to keep the best ones right it's a level based game where you wander around an overworld and
then you go into specific levels actually do you want to do a screen share this is an overworld that
you wander around and you go into all the levels right so you like go up a screen and then you go
right now we're loading shaders so it's janky but you go into these individual levels right which are just
little puzzle solving experiences and then the complexity of the overworld is something like
that except it's actually bigger than that and then every one of the little like yellow stars that
you see is an entire level that you can go into and then uh
as i um oh you know i should turn off the music huh that's probably bad for uh it wasn't streamed
uh okay uh anyway so these are some levels that we've been working on lately just to show off the
visual style of the game which is really nice by the way and so you know it's like classically a
sokoban game is about pushing stuff around you know and um solving the puzzle which in this case is i got
to get my character to the exit which is here right and so these are just some you know obviously i don't
want to go explaining all the mechanics but this is sort of our current favorite level in terms of how
it looks yeah i just like a lot of things are successful here like just the lighting off the red
tiles and the border around it and the cool background and all that um but you know we have a
bunch of a bunch of levels that look good let me let me find another one some of them are like less done
than others um oh that one's been updated recently that looks pretty cool and um in your sokoban game
you can control also like couple characters right and you get different yeah kind of abilities yeah so
there are um there's probably 10 characters in the game total okay this is this is another one that i
think looks really neat so this is a different character this is the wizard and he can uh he can
teleport well actually so if i go over here um he can like teleport swap with this block right that's
his his power he doesn't have to cross all the squares in between so yeah okay so that'll give you an
idea so this is one level right yes and there's about uh there's on the order of 800 levels
there might be fewer than that really in the end or more i don't know but um there's on the order of
800 levels and then there's that overworld that takes you to all of them and a lot of the levels
fit on one screen but some of them don't because part of the idea of the game is we're playing around
with different mechanics and some of the mechanics involve um large complicated levels that have many
puzzles in them and so if you count the number of actual puzzles it's well over a thousand um you
know i don't even know it's probably like 1200 or it depends on what you call a puzzle and all these
things right um it's big it's big um i estimate so far i think it's a reasonable estimation that if
someone wants to 100 a game 100 the game um if they're an average person it's probably
over 500 hours of play time that's my guess okay uh someone who's really good at puzzles could
probably do it faster than that but for example we had a play tester play an earlier version of the game
he didn't even 100 it right because a lot of it was still rough this was more than a year ago um
he played and recorded play testing videos for us and i think i think he played about 130 hours um
you know before we were like okay you're at the super rough part of the game and oh this isn't just
a puzzle enthusiast this is somebody who makes puzzle games who has thought about puzzles a lot right
and so for him it would have been probably around 300 hours at least to 100 the game okay right
if if like we don't know though because literally nobody has ever well we're not done yet but so
nobody has ever played through all the things not having seen them before i mean obviously i could play
through but i know the answers to a lot of things so it's a lot faster yeah anyway though it's really big
i wish i checked uh the stats for with the witness to compare do you know them um how how much time
would you need for so i think again it depends if you're completionist and you're really interested in
all the details and you're not a hyper fast puzzle solver i think it's 80 to 100 hours um people who are
really fast and good at puzzles i believe i've heard of people doing the game in like 30 to 40
right when they're like puzzle enthusiasts right wild yeah so um and you know probably there's some
people who did it even much faster than that right because there's nothing in the game that
artificially i mean there's speed runners who can do the game incredibly fast once they know the answer
all the puzzles and stuff and they skip around lots of things but the point being so if that's accurate
if you say it's 80 to 100 this game is like five times as big or something in terms of how much there
is to play at least it's really big well how did the development look like because of the language
like you were both developing the language and the game at the same time so like yeah stop stop the game
to change the language or like did you need to update not really i mean here's the thing the so that
first uh demo of the programming language i gave was in late 2014 i think and at that time um it was a
full programming language that you could use like obviously like i demoed a little video game in it right
um but you know there was some stuff that was kind of hacked together and not really good like at that
time okay so interestingly when i gave that original talk i knew that it was going to be manual memory
management i think i was pretty clear about that in the talk it wasn't going to be garbage collected
but i wasn't sure about other things like i wasn't sure that it was going to be a systems programming
language um that would let you fully access operating system apis or whether it was going to try to be
high level in some way and so that initial demo that i showed when it opens a window and stuff um
um it was actually calling into a c library that i had pre-written that did all the windows api stuff
and i was like maybe that's going to be how it is and you just interface with these higher level things
or maybe it's just literally a low-level programming language and we made it eventually a low-level
programming language but so some of that happened in 2015 right after this demo and all that but i was
still working on the witness right until literally january of well really march of 2016 because you
always have to do support when a game comes out and fix things and whatever so um
but at that time so i started this game around the middle of 2016 which was a really long time ago now
but part of the reason for that is i've been doing this plus the programming language plus the braid
anniversary edition all three of those things um and plus running the company like you know making
business deals and figuring out who to hire and all these things right uh so that all takes time um so
but but at that time in the middle of 2016 the programming language was already
in an early version of its modern form um it just i would say it was not as industrial strength as it
is now right it didn't have all the features that it has now for sure but also some of the features
you know they had little bugs or little things that i knew they wouldn't handle
and but because i was the only person writing code in this language it didn't matter i just i knew what
the and if i had a problem either i would just work around it really quickly or i would just skip it or
whatever um but then also i did spend a lot of my time from 2016 to 2020 working on the compiler
but also a lot setting up the game so you know we did a whole new game engine from scratch we ported
over some of the witness engine but a lot of it was new really more than i a lot more i didn't want
to do a real engine going into this project and we did a real engine for some reason
but when you ported you needed to switch it from c plus plus to giant right for the witness yeah and
we didn't do that with very much code um but like the a lot of the editor we poured it over like the
gameplay is nothing alike right between the games but a lot of the editor and then we wrote a new
renderer for a more modern api because the witness was targeting like a direct x 10 or 11 class api
which is still in this older style where it's more of an abstraction barrier and then a more modern api
like direct x 12 or vulcan um you do a lot of things you're like allocating buffers on the gpu manually
and that's a big difference right um it lets you do a lot more things but it's a big difference so um
um we essentially did that from scratch and all this stuff like i poured it over my animation system
that i had written for the witness like for character and object animations but i i made it
better and i added a thing so in the witness you couldn't really um like we only had one character and
it was your shadow so like we didn't work very hard on animation blending or having a lot of
different animations for a character and then there was machines where we would sort of if you take an
elevator up and then you reverse it that's actually all playing animations because we you know you have
little wheels in the elevator and stuff and we would just like refine seek through and find the right
time to reverse it and all that but it becomes different when you have a game that's character
focused and it's like oh is he running and idle and whatever and you want to blend through all these
things and so i made a little data driven declaration language for an animator to use to control what
happens and all that stuff right so there was a lot to do um but yeah like the programming language was
already far enough along that it was mostly fine but i also kept upgrading it over that time and then i think
i think our first beta was in the beginning of 2020 is that right it was let me go to our changelog
uh yeah so i believe it was like january 1st 2020 was the very early beta and that was just you know
15 people or something the beta was very small and then we just have been gradually growing it
how uh when did other people join you on the socoban game uh from the beginning because we already had
a company okay from shipping the witness and it was like i don't remember how many full-time versus
part-time we had but it was about 12 people or 14 people and we had an office in san francisco and
we were just doing our things okay okay so what about the release when will when will it come out um
we have not announced anything yet however um
i would say uh i want it to be not a lot more than a year from now
so which sounds like maybe a long time if you're like waiting for a new game to play but that's
very quick compared to how long development has been now if we do that it'll still mean it was almost
10 years from the time the project was started which is just incredibly long and we can't do that
anymore because that will be dead so uh but now that we've got a new engine and a new programming
language and all this stuff um most of that doesn't need to change for future games right and so we can
just build on this foundation that we've got to do new stuff after and so the game three which you've
seen mentioned the idea behind this game by the way this huge huge 500 hour game it was supposed to
originally just be a small game that we did really fast um and then we would go on it would be to prep
the engine so we could use the engine for game three but then the engine got a lot bigger and the
game got a lot bigger and it and it's just always harder to do things than you thought that it was
going to be that's the reality of game development and so all those things conspired to mean that it's
not done yet but man it's some this game is really something it's really big and then hopefully when we
release the engine people will really appreciate it too like we're not going to release it in a product
kind of way so it's not going to be like a competitor to godot or something um because it's oriented in
a different way so like godot is trying to be like unity right where you can make a game through the ui
and you don't really necessarily have to know how to program maybe you write a little bit of the
scripting language or something right um this engine is not like that at all it's a very programmer
centric engine which is good if you're a programmer who wants to be in control of how things work
because you don't have this big legacy of stuff that is hard to modify um but it also means that
um it's just you don't build a game in quite the same way so it's got it's got an editor in the game
like you run the game and you have an editor that lets you edit entity fields and all that but it's inside
the game it's not outside the game like it is in unity and godot right and um but what that means
is you're in control of it and you can do whatever you want with it and we'll see we'll see how that's
received at the time so actually if you're going to count all the things that i've been doing right
it's really like at least four things because it's the engine the game uh the braid anniversary
other game and the programming language and then i mean if you really want to get picky probably
the programming language and then the user space libraries that are in the modules folder are probably
kind of two things sort of so i don't know i don't know how many things that is i'm just trying to feel
good about it how much does it take uh to compile how much time it's take to compile now from scratch
the game the game yeah um it's longer than i would like uh it's about 1.7 seconds on my laptop if we're
um if we're building using our own back end if we use llvm uh in a non-optimized build right just to
debug build it probably takes another two seconds or three seconds more than that
my goal for the final compiler speed is that we want to be able to do a million lines per second on
a desktop machine and um we're probably a little less than 10x slower than that right now 10x sounds
like a lot but we haven't really tried to optimize it very much like once in a while i go in and try
to make it faster but like i said i have a lot of things to work on and so most of the work has just
been making the features go and so between just making it faster in a regular scalar way i think we
could get at least 2x or 3x just from that and then you could think about parallelizing it more
there is some parallelization in the compiler but the hard part which is the type checking
is not parallel right now at all so it's a huge bottleneck in the middle okay okay
i have a couple of questions regarding tecla your company sure
yeah first of all maybe how your company operates like how many people is it now remote uh because
you're now remote we were local um before covid and then a combination of san francisco made it
illegal to be in your office for eight months um but also i became fed up with california and san
francisco generally and so did many other people and so a lot of people just moved away during that
time there was also some other stuff that happened so you know okay so one of the things that we got
kind of blindsided by between let's take a longer time frame like between the time when i started the
witness which was around 2009 and today right one of the things that's happened is because we've had this
big technology boom including all the internet companies and all this stuff um the price of
programming has gone way way way up right so back in 2009 um i would hire people for a salary of around
a hundred and fifty thousand dollars and that felt pretty high to me and like now that's very low like
if you like by california salaries if you're expecting to pay someone a hundred and fifty
thousand dollars i mean there's also been some inflation but if you're expecting to pay someone
a hundred and fifty thousand dollars that's like a junior person or someone not that skilled or something
right and the problem is we don't have a giant fountain of free money the way that like google or
facebook or these companies have and so they can afford to pay incredible amounts of money to people
so this was another thing that we had was just during covid so we started out being remote because
we had to but then we were remote because it was like well everybody's moving out of california
let's just be remote for a while and see how that is and not reopen our office and
that worked in some ways but there's a lot of negatives to it and if i could do it a different
way if i could go back to an office and have everybody there i would much prefer that even
though i don't like working in an office myself um everything works better when you do that but so
we've been remote since 2020 and it also was a natural time there were some people who just moved on
to other jobs at that time because it was a time when people were making a lot of big life changes and
then also some of these people had been working at my company for like 10 years right and even if
it's something's a really good job like 10 years is a long time and you're just like i kind of want to
go do something else oh gee i heard that some people at meta are making six hundred thousand dollars a
year and like i just got married and are having a kid and my priorities change like all these things
the mixtures of all these things happened and so really um between 2020 and now
we're a small team to begin with the team size has gone up and down like it's probably been averaged
around 12. we're a little bit lower than that now because we had some layoffs this year or in 2024 which
was a notorious year for layoffs in the game industry um but i think we only have
two people in the company including me who were there in 2020 at this point like that's how much
turnover there's it was just a very disruptive time but that's been great like that didn't all happen at
once it happened in many phases um but you know we have a really good team now for for finishing up
this game and it feels good we've just had a couple meetings you know once once it ticked over into 2025
and it's like okay this is the year when we mostly finish the game we want to be basically kind of done
with it at the end of the year like you just click into a different mode and things get more serious right
yeah so how does the language slash game engine slash game split looks like inside the company
like if you hire somebody like do you hire for language or for a game or does it does it get
changed no i mean i would like to hire for the language eventually this was one of the things that
i was hoping when the braid anniversary edition shipped the plan was that that would make enough money
surplus above what we need to run that i could just hire one or two people to work on the language
full-time and it didn't make that much money it made money it's profitable but it's not profitable enough
to be able to hire people to put on something that's uh what would you call it like a it's just not
a profit generating product right we're not selling the compiler um so
uh right now we do have um so i work on the compiler sometimes and then there's rafael who's
a dude who's known to the people in the beta who who works on it part-time um and then
that's kind of it so it's very little manpower for
like a c a c plus plus competitor language right like if how many people at microsoft work on that c
plus plus compiler right or whatever i'm sure it's a lot or how many people work on the go compiler
right to pick a more modern language it's probably a lot still even though that language has kind of
stabilized i bet there's a big team on it right and so it's kind of crazy to be doing this with
like two people working on it part-time but that's what we're doing um i would like to put um as soon
as it becomes feasible i would like to put more people on the compiler and that might be something
that happens sometime in the middle of 2025 because business fluctuates all the time and if something
happens that's really good we might be able to do that um but like so 2024 people not in the games
industry may not know this i alluded to layoffs earlier um 2024 is pretty much seen by by most
experienced people as the worst year for the video game industry in the entire history of the video game
industry that anyone has been alive for like including there was a very notorious i forget what year
like in the 80s sometimes there was like an atari console cartridge crash when you could go into
the store and buy those cartridges for 25 cents like this was even worse than that um just in terms of
how many companies went out of business and how many had layoffs and how many are still going to have
layoffs because it hasn't totally ended but i think in 2025 the economy is starting to pick back up
and we'll see we will see but um you know not to get too much into business but the the way this will
reflect on the compiler is if things get good again we could afford to spend more on it um
and you know with regard to the game the sokoban game that's what most people in the company
are working on right now um because that's the thing that's expected to make some money and then
there's this vr project which also i said there are business uncertainties attached to that but
that would also be something that we expect to make money off and that we have significant people on
but yeah the compiler is um we do a lot with a little on the compiler yeah is how i would describe it
yeah how do you hire people
you know i don't think we've been careful enough about hiring people is one thing
um and maybe it's just because it's very hard you know some of these big companies
put people through a big interview process that lasts a week in many many meetings and then they
still hire people who aren't good so i don't know that that really fixes anything
um we've had a mixture i mean we've had some very good successes hiring people um like who are just
very good and you just couldn't imagine having anyone better in that position and we have
a couple such people at the company right now and and that's great um and then you know uh
hopefully you land like that's more than you can really ask for when you get that
but mostly what you hope for is just people who are going to do a good job and you know care about
working on the game and do a good job on the game and are you know productive and do great and um
that's mostly what we have now uh after the because you know like i said we had a little bit of a
layoff and when you have a layoff you you try to insulate you try to make the decision it's always
it's very hard i hope nobody listening to this ever has to do this um but you try to make the
decisions that are going to make the company come out the best after the layoff right but
you would have preferred to not have to do it in the first place um but uh
yeah i mean we've also so that's great that we have good people um but
we've also had to fire people right or there have been a number of times when you know when
somebody's obviously not doing well you do a thing where you communicate clearly with them and
say look we don't think you're doing that well we need to put you on some kind of performance
improvement thing or have expect higher expectations and very often when people have options
they will quit shortly into that process because of whatever reason because maybe if the problem is
they're only working at home for one hour a day because it's a remote thing maybe they don't want
to work more than one hour a day and they figure they can do that at some other company right maybe
they're actually working three jobs and aren't telling you and that's why they're only working one hour a
day right um this is one of the hard things about the remote scenario is because i can't really see
what's happening from because we don't install any of this invasive spyware on people's machines or
whatever i i don't ever want to do that although who knows at some point it may become financially
infeasible to run a company without doing that but we don't do it so um if someone if it looks to me
like someone's working for an hour a day i kind of have to believe that that's actually what's happening
like because otherwise like someone who is legitimately like let's just say there's some
bad actor who is legitimately exploiting you and knows that right if you say look you're just not that
productive can we work to get that up i mean they're just going to say oh yeah sorry you know the
code base is complicated i have trouble understanding it or they're going to start blaming you they're
going to be like oh this code sucks and and it should be higher quality whatever right they're not
going to say oh yeah i'm only working an hour a day because i'm also working these two other jobs
right and so it's an inherently low trust environment and i don't like that but
we've definitely had cases where there were people legit only working an hour a day and we just had
to deal with that by you know straight up firing them or i mean we've had cases of some people
who would do like an hour every two weeks and because i wasn't directly i don't know we were just
giving them a lot of chances to improve like during covet especially you know it was an unhappy time
and people have enough difficulties in their lives and stuff and you try to just be very lenient but um
you also the company will go out of business if people don't program right yeah so you just need
eventually you need to put your foot down and say like dude we need you to do stuff and so we've had
to shorten all of this we've had a bunch of that as well like i'm not even if anyone is out there
thinking i'm talking about them um i'm thinking of at least four different people right there
right like that's how many times this has happened uh so so hiring is hard is just you know what i'm
trying to say there's any correlation between like the stuff people say or do during the interview
and then performing nicely afterwards
i think there is i think when you get someone who's really at the high end
and they're programming because they they really legitimately enjoy programming and they have a lot
of good experience and they um and they've done significant things before you can tell that in
the interview questions so you can start talking to them and you can get really into details about what
they did and they'll have interesting answers and they'll be able to tell you the details this is it
okay so one of the things that happens at bigger companies is you'll have a team of several programmers who
worked on some feature or system and in reality like one or two of those people carried most of
the weight and then the rest of them were just sort of hanging on right and how do you tell the
difference because because on the resume those people's titles and job descriptions look the same
right how do you know and the way that you know is you just start talking if you're technically literate
you can't do this if you're not technically literate but you just start talking to them like oh you
wrote the collision detection system for this game engine like what kind of primitives were you
colliding with oh okay so you did you do an early uh an early out check where you check a looser
bounding like a big sphere with multiple things inside right what did that look like and then
how did you prevent the overhead of that from being too large and what did you have any cash
coherency problems and and how did you get around that did you like reorient the way the data structure
was stored you can just go further and further and you don't ask a preset list of questions that's
the thing because that won't work you have to dynamically tailor it to what they're talking about
and you have to have enough of a clue about what they're talking about to ask good questions and then
to understand if the answer is good right and so that's really the art of of the interview um
so there's a video on youtube that i always thought was pretty good that illustrates this um it's casey
muratori doing an interview with sean mcgrath it's not a real interview it's like a mock interview but
it's really long it's like 90 minutes and it's just him asking sean about what he has done
and i think that's a very good example of how to interview a technical person um now i also
interview like artists and stuff right 3d artists modelers and stuff and i don't have as deep of
domain knowledge there i've been in games a long time and so i can ask some decent questions there but
i'm not going to be able to ask questions that are as good as the ones that i'm able to ask about
programming and that's just a limitation there i have to trust when we hire someone onto the art
team i have to trust to some degree that the other people on the art team have vetted that person
in a reasonable way um but okay so apart from though apart from that telling you technical ability
asking these questions it also does tell you about motivation to a reasonable degree because you can
you can hear in someone's voice how are they talking about these things are they interested are they
proud of this solution that they had right or are they just like burned out and trying to get through
the interview and like don't really ever want to program again in their life like you can tell these
things and that helps but even so it's just hard like i mean to be fair a lot of the times
a lot of the times when we've had these severe problems with like people just not really doing
anything it was where we had a shorter interview process where we were being less
so we would do a little bit of this question and answer like i was talking about but i never would
like super grill people but i'm going to switch to doing the 90 minute version and and that's
why i say we need to interview better because i i do think
like again there's this like wanting to be nice to people and wanting to assume like oh you worked at
some big game company like electronic arts or epic for five years surely you did a good job and were
exposed to all the knowledge around games and all that and then you ask some cursory questions and they
have pretty good answers and like like or okay at least answers and i don't go into that much detail
because i don't know that much about how that system worked or whatever and then that person just ends up
bad so um it's hard it's hard but i would encourage people to watch that youtube video and use that method
because i'm going to go more and more in that direction um i don't think you want to sit there and quiz
people with like leet code questions or whatever because that doesn't actually that doesn't really
tell you if they're actually good although i do think there's a place for one or two of those maybe
to start things out or more often you can organically integrate those into the question and answer process
so for example when i was talking about the collision detection question you could be like oh did you
use a tree structure for that or did you use like a grid and if they give you the answer like oh we used
a tree structure i would say why didn't you use a grid did did nobody think about it uh was there
a reason you wanted to use the tree is there some property of it right and you're starting to get to
this deep knowledge around trees and not just like did this person memorize how to do the breadth first
search right like there was this thing going around twitter the past week about like here's the
programming question that i ask and if someone can't answer this it's a no higher and it's like
a very simple binary tree and it's like print out each horizontal level of the tree on one line right
and it's it's very easy even if you have never encountered the problem before if you understand trees
you should be able to answer this in like 30 seconds unless you're totally
flustered right and there's a couple different ways to do it even which is the silly thing um but
you know everybody got enraged about it like what do you mean i write all this software i don't
know anything about trees and it's like oh man that's that's just where we have this every five
years or something there's a big flare-up about people being pissed off that they they program all
kinds of javascript and don't know anything about data structures right yeah uh but but those kind of
questions are very artificial but you can get to them very naturally if you're conversant in the
subject matter to begin with yeah okay there are game studios that try to brand the game studio itself
and i feel like yeah tecla is at the opposite end yes that's intentional it's maybe a mistake
because maybe i would like to make more money and if you had studio brand i mean what happened is
de facto i sort of became the recognizable brand right because people people who played the previous
games and want another one are like where's this dude's next game so maybe it didn't help
to have the company have a weird name but that was what i was very explicitly thinking that it's like i
don't i don't want this to be a company that's about the brand of the company and in retrospect
maybe that's a mistake because like if you if you open the witness yeah you don't see like
tecla logo oh that part yeah well that's that's related but different um the new game is going to be
like this also by the way unless unless somehow we sign with a publisher that forces us to put a splash
screen on so this this has happened in rare cases um like if we sign with a publisher and they have
in the contract you must put our screen up when the game starts then we would probably put our own up
because at that point you've already disrupted the player experience and so why should we let the
publisher have more branding than we have but if we don't have to then the plan is for this game to
just drop you directly into the game so to be clear both braid and the witness it's not even just
that there's no splash screen there's no main menu or anything like you go directly into the game and
that's sort of an artistic statement or but it's also just sort of a like look if my job is a designer
i mean here's the thing you'll go you'll go on the internet and all these people are like teaching
you how to design games right and it's all monetization which is a word that i hate or like
how to how to be viral or something and like okay all that stuff's fine but or it's not really fine
because it's very corrosive but like if do you want to make something really good or not and if you want
to make something really good your number one priority has to be the experience of the player
right the main reason for you making this thing has to be to make an interesting or fun or mind
expanding or whatever kind of experience for the player that has to be the number one item on the
list of all the things you consider anytime you're making a decision right and then how does that play
out into other parts of games like if i'm trying to give you a good experience why would i wait make you
wait longer to start the game so that you watch an advertisement for my studio
which it's not even a real sub it's like a like a logo is like brainwashing right because i'm not
telling you i'm not telling you why my studio is good i'm forcing you to get the impression in your brain
of the name and the image and that's actually the opposite that's a parasitic relationship where
you're using the player's brain like as a resource that you're trying to extract something from
and i try not to do that to the greatest extent possible which is why we don't have this kind of
branding right and it's another it's another reason but we don't really have it anywhere so like if you
run the witness you can hit escape to pop the menu up we don't have a company logo there either
it's just the menu that lets you do the things right yeah um if you look if you look in the credits
well okay there's no credits screen in the witness the credits is a thing that you only get to by
working very hard to get to the end of the game um and in there you maybe will hear the name of the
company right so it's really buried it's really buried it's like a secret of its own yes yes uh i
mean you know you can look it up on because sites like mobi games or whatever extract the credits and
post them but yeah i've always been very anti that because i've always been very much about the goal of
this is to make the best experience that we can given our limited capacity as human beings to do
what we can do and it's just so much of the games industry veers away from that very quickly and i just
it makes me sad you know it makes me sad so it ties into my next question which was
how do you view your task as the game designer is is there something more than like creating the best
experience possible for the player yeah i mean that's a very vague and general statement right
and so when you start a new game that new game is about something like there's some core idea to it
hopefully maybe it's just a fun game mechanic like i'm gonna make a tactics game where the combat's
interesting and like maybe i like xcom but i want to make it different like that's that's a very game
mechanical reason but that's still good enough so then you say like okay making a good experience is
about making sure these mechanics really work and not getting in the way of them making sure like if i if
i'm doing a tactics game and you want to make good decisions i want to make sure the scene is readable
so i can see everything that matters and uh unless i'm making some statement and the game is more about
the confusion of war and then that's a different rubric on which to make decisions right but whichever one
of those things you pick to start with then becomes your basis for making decisions going forward and
so sometimes is game mechanical like that sometimes it is uh it is not sometimes it's more philosophical
so like in the witness there is a core idea to the game that i won't spoiler although you could very
easily spoil yourself searching the game on the internet now but there's a core idea behind the game that
uh is sort of prior to mechanics a little bit it determined the mechanics but it's more
fundamental than that and and that drove all the decision making in the game it affected the puzzles
it affected the art style uh like the witness has very bold colors with not a lot of high frequency detail
and the reason is because of this poor philosophy that's behind the game but that reason
was not in play in braid and it's also not in play in the new game and so all these games look different
from each other because they're doing different things right and so as long as you know as long as
you have a very concrete goal then for any decision you have to make you can say does this help me achieve
that goal or does it make it harder or is it orthogonal very few things are completely orthogonal but you
could be like is it mostly orthogonal and then once you have that um
that helps you make your decisions and it doesn't help it doesn't only help you make the decisions
in an intelligent way but it helps you make a set of decisions that globally are coherent with the point
of the game it's like a you know like a ferris magnet where the reason it has magnetism is because
the little pieces of it are aligned right you want your game to be that way you want the pieces to be
aligned to create this magnetic field that's strong you don't want them to be all be misaligned
and create nothing and so that's one very important piece of how that is done i think so what
when you were when you are the one who's designing the game what kind of things you're searching for
that changes every game right um so in the new game
part of what we're doing is we're exploring the space of game design that you get when you
intentionally create a combinator oh i just spilled my tea when you intentionally create a combinatoric
explosion so um you know this is a thing that game designers have known happen for a long time
is that you could take a couple different mechanics you could you can just make up any mechanic that you
want like oh my guy has a grappling hook or i could double jump or um you know i can zoom in
and aim that way like these are all different things and then game designers have known for a long time
that you get this very interesting phenomenon when game mechanics interact with each other as opposed
to being orthogonal like if they're totally orthogonal well okay this let me not use the word orthogonal
because there's a way that orthogonal can mean the opposite of what i intended to be like the complete
opposite because in the programming language way if things are orthogonal that means they're composable
to make a bigger thing right and that is actually good in game design but what i'm trying to say here is
sometimes there's just you come up with some mechanics and they don't interact in any way and
don't even apply to the same situations and they're just like more things that happen in the game and when
you do that it feels kind of dead and it feels like the game is trying very hard right but when they're not when
they interact with each other that generates more possibility and it generates uh fun essentially or
surprise or just interestingness and this has been known certainly since the 90s probably since the 80s or
maybe even earlier right and so part of the idea of this game is to focus on that effect let's look at
that effect very closely and just see what we can do with it and and that is the mission statement for
this game and so when we say is this a good level um there's a bunch of criteria that i won't get into
about how that's a good level there's a speech actually that's related to this that um it's from
indycade 2011 uh me and mark ten bosch who's been working on a game since then that still isn't out
if you think 10 years is a long time to work on a game uh i know several people
have been working on games for substantially longer than that um anyway uh so
um there's a bunch of general criteria that propagate over but some of them are very specific
to this game like okay this game is about the combinatorics does this level observe some new
space of the combinatorics does it use the objects to generate a new situation that we haven't seen before
is that situation interesting um are we able to make that situation simply or is it really contrived
do we have to like pile a bunch of crap in the level to barely make this thing happen that's probably a
bad level right um but again in the same way with the programming language where it's like the goal is to
get the power first and then maybe we can get some simplicity back later by refining the language design
here it's like okay i made this interesting thing happen with this ugly level now now that i have
that can we make it less ugly right um and so
this is just how we decide right and um for every game though because the ultimate idea behind the game
is different then the exact criteria for making those decisions is a little bit different okay okay
i have a somewhat related question regarding this to the witness which i i'm not gonna spoil it as well
but like it's it is let's say about noticing patterns right sure yeah
was this the core idea of the witness then and the game is built around that or
um yes uh there's another brief talk that i gave at indicate that i think is still on youtube
this one's only 10 minutes but this was like when i was early i think it was also in 2011 or maybe 2012
where the game was still several years from being done but it was far enough along that i knew that
the design was successful and that it was going to be a good game right when i gave it was sort of part
of a panel talk where each of us spoke the way you'll know it's the right one maybe i can uh look it up
after and you can put it in show notes or something but um it was also like phil fish notorious game
designer phil fish was also in this panel i think or no maybe that's a different one i don't know if you
manage to look it up i can add it into yeah i'll look it up maybe this is there's two different ones
actually this probably wasn't the phil fish one never mind i will look it up and i will unambiguously
if i can if it still exists on youtube i will give you the link but uh during that one i talk about
what is essentially the core idea of the game and i can try to describe it in a non-spoilery way
right which is that in puzzle game design for a while there's been this observation that some puzzles
are a lot more fun and interesting to solve than other ones and what is it and and valve put it this
way in a in a speech about portal sometime they said that in a when you solve a good puzzle you have this
aha moment where you really understand what it was about right and i actually try to take it further
than they did like i think designing just to create that kind of moment is a little bit too reductive
because i think the content of what your aha is about what that realization is about actually
matters and so one of the things we do in the witness is try to build some kind of abstract picture
out of all these moments we string them together and try to make and so from the puzzles in the very
beginning of the game when i used to go and talk about this game at at speeches i would take some of
the very early puzzles like just you go through the dots right or you you have the little things in
the squares that are right outside the starting area um and i would talk about how you have to gain
realization of what those mean from moment to moment right and um it's uh it's about sort of creating a
continuous stream of those realizations as you go along and that was the core idea of the game although
what i just said is one step more concrete the actual core idea is more abstract than that and
but but if people watch this speech they'll see me give a pretty good explanation i think
yeah what do you think draws you to games i don't know sometimes i wonder why i do all this
anymore um part of that is just what part of the project i'm in i'm really late in a project
and when that's true you're in what is kind of the less exciting part because you were super excited in
the beginning because the idea was new and you're like oh man this game's gonna be so cool and whatever
right and then after you worked on it a couple years it's been a lot of really hard work and it's tiring
and you're just you're not as excited about these ideas because they're old ideas to you now and
part of the excitement of ideas is when they're new and so there's there's some psychological skill
involved in bringing back the excitement making it fresh again remembering why these are exciting ideas
right um lately this project has been so long that this past few weeks i've been really excited just
by like oh my god we're actually getting toward the end in a visible way we're not just lost in the
desert forever and that's exciting um but uh
uh i forgot what your original question was again what really draws you to games and what draws me to
games yeah um i mean i just always really liked games from even when i was a little kid like before
before before i knew that i was going to work in games i just made little hobby games on home computers
like when i first learned to program that was the very thing first thing i did was made a really stupid
game on it um yeah i don't know and then now it's it's a way for me to explore ideas about the world
in like ideas about reality like what is reality and what's going on and what are we doing um i just
have found this way to explore that through games that in some way is more unique because
like our culture just hasn't done that very much right like if i wanted to write some essays or some
fictional novel that was inspired by like thinking about our role in the universe and what the universe is
it's like i could make an individual contribution but there is a lot of that out there right and i would
just be putting my own spot in there although you know i can write a lot faster than i can program video
games so maybe that would have been a good idea um but instead you know like the this idea that there's a
running system like in some sense the the universe is a running system right and so if you want to talk
about it having a running system that changes from moment to moment is um
it certainly at least gives you a way to think about things or a way to talk about things if you
talk through the game the actual game and not the plot of the game or the setting of the game
if you actually use the interactivity of the game it gives you a way to approach these topics that
uh can't be done anywhere else and there don't seem to be very many people who are interested in this
um i probably know of i don't know how many people do i know who even
are trying to do this in a serious way as opposed to just like whatever i mean i maybe know two
other people on the whole planet earth right so uh
i mean i've always wanted to do things that wouldn't be done if i didn't do them and this
definitely qualifies okay okay do you know tim kane who worked on fallout
um i don't think i've ever met him i certainly know who he is okay um but i i don't know him
personally he started a youtube channel some time ago and he created this video game development
caution when he was saying that like a lot changed in game dev industry since like in like last 20 years
or so and there's a lot more like caution in terms of game programmers but also game ideas
and yeah i was wondering what are your thoughts on that
um you know i know of this video i haven't i haven't seen the actual video so it's hard it's hard to
respond to respond to it uh what i will say is i think that's true um but it's very ironic because
this has also been like when i entered video games even by the time i'd only been in the industry two or
three years we would all go to the game developers conference and all of us independent developers would
be complaining about how uh you know triple a developers wouldn't take any risks and they didn't
have that much creativity and and all that right and so we already thought it was a problem back then
but yes it's much more of a problem today than it was back then it just keeps getting worse right so
um i don't have a solution to that i mean i sort of did at one time and that happened uh
so i wrote this manifesto about all this uh in 2002 about how look it's not surprising that they
don't take risks because these games are so expensive and if you're going to lose all that money
you're not going to get more money people aren't going to trust you with it right so
it's not surprising that people are very conservative in that context and so if we want
creativity in game design the place to do it is at smaller budget levels right so the place for
creativity to happen is for indie developers to take the risks at low budget levels and then
that can create like if an indie makes a game mechanic that people like that can create uh
you know a pathway for higher budget level games to do that thing and that has happened actually since
then over and over that that was actually the the idea behind this thing that i did at the gdc for a
while called the experimental gameplay workshop um it's since been taken over by people who have
totally corrupted it and it's no longer the cool thing that it used to be but um the uh
but i don't just mean with regard to that workshop but like the whole industry has ended up working
like this so there's all these things that are game mechanics in aaa games um that came from small indie
projects right so like what is one of the generic things that we have going on right now is we have
all these hero shooters where you have skills and you have an ultimate that you build up and then you can
use it at the right moment and do something really powerful and it's like all that came from dota which
was a warcraft mod made by just like some dude right or like i think i think tower defense came first
and that was just like a mod and then dota was like a mod for tower defense or something i don't
exactly remember how it worked but that was essentially that project was so indie it wasn't even really
commercial at all right and yet that that was now the foundation of one of the ideas that all these
triple a developers can't even get away from they just keep doing it over and over right and that has
happened repeatedly uh in many caps so like battle royales when those were big for a while right um
those like obviously you know pub g was pretty big but you know that got i forget what the
i forget what that dude's smaller thing was before that i think it was also a mod um
the arm or rust it might have been an armor mod yeah i don't know um but the point being you just
see this literally everywhere is that the experimentation happens it catches okay so here's another place
where it happened so quickly and burned itself out so quickly that you could see the entire cycle right
which is all the the auto battler games oh yeah where like somebody had like a dota 2 mod that was
like auto chess or something and then this was valve original thing right i think no no no i valve cloned
it some indie guys had the original auto chess mod and they tried to sell it to valve and valve was like
no we'll just build our own i think i think is the way it played out but then like all these other
companies made their own auto battlers and there was like the year of the auto battler because these
were so easy to put together um and then it turned out people didn't really want to play this game that
much it just was exciting because it was a little bit new and it burned itself out within literally like
a year or two years maybe i don't know so you can see these things happen and that's really the only
place that innovation comes from anymore is like smaller indies and the thing that bums me out is
that most indie games are actually not that creative either they're just making some game with slightly
different characters and slightly different mechanics but sometimes sometimes games are still
trying to be different and that's literally all the design life that we have left in
the game industry it's not coming from the high budget companies at all why is that that people
decide to like start the indie career and then they do the project that doesn't really do anything new
i think people just have different reasons for wanting to be in games and
some of those reasons are fine like for some people it's just enough to make a cool game that's theirs
that does exactly what they want to do with like new characters or something right or a new art style
or not even new but like this is my art style that i want and that's not bad like obviously if you look
at some much older genre like literature right most literature is not experimental literature that's
trying to innovate in the form it's just stories that people wanted to tell right and so that's
probably mostly what's happening in games now is these are just games that people wanted
to make and they're not really pushing the medium i've always been about pushing the medium because i think
there's a long way to push it still i think we don't really understand that well what games could
really be um and so with every one of my projects i'm trying to push on some boundary to do something
new but there's plenty of reasons to make games like look if you make a game that somebody really likes
and they get a lot of enjoyment about out of playing who cares if it's like innovative or whatever
right i mean you made a good experience for somebody and that's cool that's like we you know we have
to not forget that that's totally fine um but also though i think if we don't have
this inflow of creativity coming in we're really missing something you know it ties into
the subject of like i met at the conference a developer who said that he should have done the
better thing like stardew valley and stick with the game he made and try to create like because
it was successful like try to create sort of community around it updated dlc patches and things
like that instead of just starting a new game that was a long shot and didn't pan out and there's a lot of
games now that try to be sort of like not even like a franchise but like a community that like grows
what do you think about this like game development style
i mean i think it's fine it obviously works for some people but
if you're a developer and you think oh i did this and i should have done this other thing
you're assuming that you know how the other thing would have gone
maybe you would try to build a community and because everybody's trying to build communities now
there's more communities than there is demand for communities and so it's very hard to build a
community now probably and so maybe it would have gone as bad or worse except you wouldn't have even
had a new game you would have only had your old game right so it's just it's very hard to know
what is really the best thing to do or how things will go
um so far i've since i did braid which was sort you know i was in the games industry for a while
before that but that was that was like the first thing in like what i've been doing since then of
these kind of art games i've always been working on single player puzzle games and that's just a
certain kind of thing that is not very conducive to community building right like the kind of game
that you have a community around is something like stardew valley or like terraria excuse me terraria or
something um where there's just a lot of replayability you know and a lot of like oh this can be my hobby
for a really long time which is hard to be true for a puzzle game that's like short and then you
finish it although who knows maybe this new game is so long that someone can play it for like two years
uh and it'll be their fun thing um
but yeah like that strategy if you want to call it a strategy works better on some games and worse
on some other games right if you have a multiplayer game it's much easier to have a community
right because people are online to begin with to play it um however most multiplayer games are
kind of just clones of each other now even more so than single player games and so that's really weird
uh so then it can be harder to differentiate if you're just a clone of you know like so one of these
trends is so because we're getting worse at making games because games are so complicated they take so
long um things that are not very easy like auto battlers just take so long so like there was this
big pubg thing when pubg came out and then you had all these battle royales trying to follow and fortnite
followed it really fast but there were other ones that took longer but then even not that long after
that you had like escape from tarkov which is has become the genre we now know of as extraction shooter
right right and there were some people trying to clone it right away but they didn't get very far
and it took until 2024 for like or maybe 2023 for legitimate extraction shooter competition to start
entering and escape from tarkov showed up on the sea i don't remember what year 2019 2018 something like
that it took like years and years for people to to try to clone this game um and none of the clones have
been like as successful that i've seen they've all just sort of started out and then fizzled and that
just goes to show that like this whole dynamic is complicated and and difficult and it's even if you have
this ready-made community of of like the escape from tarkov community and you're making a game like
like one of these games which i just saw a streamer play for a little bit i think it's not even out
yet i think it's still in beta is like this game delta force um i think that's in closed beta or
something i i don't know you can fact check this at the end uh but it doesn't seem very successful to
me like nobody's really talking about it um maybe that's because it's in closed beta or maybe that's
because it just totally hasn't succeeded right and so even when you think you can hook into
an existing community sometimes it's just really difficult to do um on the other hand
so jason rohrer who's one of the guys who's another independent game developer who's actually
doing experimental things he made a game some years ago called one hour one life where it's a very
lo-fi game it's just 2d it's networked but it's 2d and you just walk around kind of like don't starve
or something like that but lower budget and but it was very ambitious in that the idea is you log into
the game you only live for one hour and then your character dies but you and all the other players have
to somehow build a civilization and there's like a really big tech tree starting with you know sticks and
stones and ending with like computers and spaceships and you have to do that whole tech tree when your
characters die in an hour right and um when was it released a long time ago i don't remember what year
uh let's look up one hour one life release date a long time ago do you know whether they they achieved
computers um in the early days the whole tech tree hadn't been built out and that's when i was
following the game so i'm i'm not sure how that has gone but it was a very successful game for him and
it had a community of people who were super into this game part of that is because it was so different
from anything else like that description that i just gave i'm not aware of any other game trying to
be anything close to that i mean there's a couple of games that are vaguely in the same dimension
but there's nothing that's really that game so that was one way that maybe you get a community is
with uniqueness right or whatever um but can you just walk up with a generic game and have it succeed
or if it doesn't succeed build a community and have that succeed i mean maybe because who it's very
unpredictable business but um i would say that that's the low probability uh of success route okay
so we're not planning to uh build functionalities like leaving notes in sokoban game for what from one
player to other players no there's not gonna be like trap ahead or whatever okay okay
where do you get your motivation from given that you get a lot of vitriol on the internet
i don't know if i really do anymore i there was definitely a time when i did and it makes me very fed
up with communities um but at this point like here's the thing uh like the thing about the internet
is it's very negative really toward anyone doing anything interesting and really the pill for that
to me is even today like so elon musk has gone through several cycles of people liking him and people
thinking he's stupid and whatever but even today there's a large percentage of people out there who
are like this guy's just an idiot he doesn't know anything and he just like inherited money and bought
rocket ships with it or something i don't know what they think but like here's a person who has
single-handedly changed civilization in a very positive way more than once right and yet this person
has people saying negative things about him all the time right um now the people saying those negative
things i mean you know there certainly are some criticisms you could have about him but there's
criticisms you could have about anybody right and like why are you so interested in criticizing this
person you know there's just something about human psychology
that under certain conditions makes us want to attack people right and once you recognize that
that that's what that is and then also that um that most of the people doing this kind of internet
attacking are doing it because they don't have anything better to do with their time like most
people who are doing productive things that are difficult like they don't have time to sit on the
internet all day and say stuff about people they're like doing things and then so like okay hey i make
a programming language there's other people making programming languages am i going to look at someone
else's language and go that guy's stupid he's an idiot he doesn't know anything he's like unethical blah
blah blah for not using memory safety no i'm not going to do that because i understand that the space of
decisions is very complex and there's a number of opinions that you could have about how things are going
to go and i think i'm in a better place in that space of decisions than let's say my so-called competitors
although there's no money involved really so whatever but um because i understand the size
and complexity of the space and how difficult it can be to implement things um you just don't
like once you're a player in that there's just no reason to denigrate somebody else
who's playing in the same territory unless you just have psychological problems or something so most
people don't right um like you don't see people who have made successful video games that make money
going around telling other game designers that they're stupid like that's just not usually how
it works um sometimes it is so you have like linux torvalds yelling at programmers um although linus has
mellowed out a little bit these days but you know but also there's there are also reasons to be very
stringent and exacting about quality when you're trying to get people to do well it's just i there
are more productive ways to do it than that but i understand like so the thing i'm trying to get at is
when you see this giant wave of internet negativity and i've had you know i've had people with hundreds of
thousands or in some case millions of followers like retweeting all their followers with like
very selectively curated things to make me look as evil and stupid as possible and i've had like i've
had waves of this that last for like two weeks of people putting shitty negative comments into my feed
and all this like literally two weeks of it um and it's just you realize at some point that this is all
low quality stuff um like this is not this is not high quality information coming into my feed
this is like just garbage right and so are you gonna let yourself be controlled by garbage you know
and i don't mean the people i don't mean like the trump garbage people comments i mean like just this
flow of negativity coming in and a lot of people will a lot of people will let themselves be controlled
by the um and i kind of get that because it it really is it really sucks um but at the same time
i've always been an independent thinker and what does it mean to be an independent thinker it means
that your opinion is not controlled by the opinions of others and here's the thing as a society that's
going to be who the real creative people are like what does it mean to be creative it means you had an idea
that is different from the ideas that other people had and then you went and made it or something
right in order to have an idea that's different from what other people have you have to be thinking
in some territory that they weren't thinking in somehow you have to have some kind of beliefs or
motivations that were different from other people's because otherwise there's so many people in the world
that they would have done it already and so the thing that we haven't come to grips with
is that the people who are creative are going to be the people who you don't agree with on everything
because that's that's the definition of creative right and so are you going to build a society and
a an online culture in which you violent or violently in terms of like via root what am i trying to say i'm
thinking of different words just very with extreme uh negativity and prejudice assault anything that
doesn't a hundred percent align with everything that you think somebody's supposed to believe
or are you gonna let creative people disagree with you because you value the creative creativity
that they contribute to society and i'm not i'm not talking about me i'm not saying oh i'm so creative
but like hundreds or thousands of people on the internet this has been the pattern with at least
those are the ones i know of i could probably name over a hundred without stopping right
but um and i think well the table has turned at least in the u.s um the atmosphere has shifted very
quickly it turns out nobody really liked this and all the people who used to do this are off like hiding
on blue sky or whatever and attacking each other and then you know we just had giant platform like
you know mark zuckerberg who runs not just one of the biggest social media platforms but like three
at least uh just said hey we're gonna be a lot more about free speech and you know not claiming
that there's one right viewpoint to have right and so i think we've passed through this time hopefully at
least things can always turn again right and i realize in europe things are a lot worse there's not
really free speech anywhere in europe that i can tell right now um or i mean england is no longer part
of europe right but that that's one of the places where it's the worst right now like they're
arresting people for for saying relatively normal things and so i don't know where that's going to
go and it could always turn back around in the u.s but right now it feels a lot better here and
i'm glad that i held on to my um
my self-respect and my individuality and
my ability to think whatever i want to think right and um didn't succumb because the number one
you know the number one pattern of this cancel culture that's been running the internet for the
past 10 years was people assault you they try to destroy your reputation um they try to destroy your
good standing in polite society and then they just say well you have to apologize right and apologizing
isn't isn't worth anything it just because they'll still keep attacking you after that nobody will
remember the apology and everyone will remember the bad thing but what apology does is it's you
admitting that they're correct right that they were correct to to have this issue with you and to attack
you in this way and so from then on you can never be right anymore that's the function of the apology
is it's the final victory and um i'm glad that i never apologized for anything that people were angry
at me for and i can think of some other prominent cases in which i'm glad that they didn't apologize
either because if everybody had just apologized and capitulated 100 of the time we would no longer
have the free speech in america that we have now and it's probably important to the continuing of
civilization that we have this free speech and so i'm very glad to have done my very very very small
part in that uh who knows though um it still kind of sucks it's still kind of
so do you know what just happened please keep this meaning um i just got disconnected and it said you
got disconnected due to a server error and i went and looked and it's because you know once in a
while google logs you out and makes you log in again okay they logged me out in the middle of the
meeting and then that made the meeting fail so i had to like log back into my google account which by
the way your password is saved in your web browser so it's literally just clicking the button like no i
didn't want to be logged out and and that made the meeting fail in the middle so this is just another
example of how security it's very secure if i can't have a meeting then nobody impersonating me
can have a meeting exactly anyway it kind of sucks that like you know if people search for me on the
internet there's probably a lot of just negative things that they could find that are distortions
that are not things that i said or believed but the you know the number one tactic is to take anything
you said and trim it down into the most negative attention getting thing right yeah yeah yeah and
so maybe that'll maybe that'll kick up again but as of right now um i'm glad that i stood by my
principles uh we'll see what will you see what were you at most attacked for whether i don't know
there's several things you know um i was actually fortunate because the first mass attack that i got was
so random and clearly had nothing to do with me that it prepared me for the later ones so the first
one was actually gamer gate and what happened in gamer gate was they were chasing down all sorts of
things which about about game journalism and all that and looking for corruption and then one of the
corruptions that they thought they found was oh to bring back phil fish who was a notorious game
developer at this point um he wasn't yet as notorious back then but he made this game called fez uh which
was signed to indie fund in um whatever year that was 2010 2011 i don't know one of those years uh 2012
and it also won the award uh in in the igf like one of the game design awards and some of the members
in indie fund were on the award committee and they were like this is corruption indie fund was
cheating at the awards right and any fund was a game funding thing that i was one of the co-founders of
right um and then they they they really harassed uh one or two people who were not me more but um
they also harassed me and i was like look guys you may not have looked at a calendar but
the igf awards like they take place at the beginning of march or whatever it was maybe even
february back then like really early in the year and if you look when we signed fez it was late in
the year like yes we signed both those events happened in the same year but they were in the opposite
order we signed fez to indie fund in part because it was so successful and won awards and stuff and we
were like okay let's back this game right and but that's whatever it wasn't you know it wasn't the
worst thing but i had about four or five days of people yelling at me in the inbox or saying like oh
we're sicking the securities and exchange commission on you have fun in jail or whatever and i'm just like
guys so you know i i i actually made a fake apology where i was like yes it's true
we invented a time machine and went back in time to the awards and voted the other way for this game
so that we would make money and that was kind of funny uh and so that prepared me for this modern wave
of internet harassment um but honestly um the the other so the social justice thing so-called social
so-called justice you could put quotes around both of those words which was the term nobody really uses
that term anymore but that was what it was around 2014 when this sort of started as like the backlash
the gamer gate or whatever those people are way way way worse um and the reason is because they
will legitimately attempt to ruin to ruin your name in all of society like they'll call you sexist or
they'll call you racist or whatever and if you just get if that just if somebody googles you and it says
this person is a racist i never had racist i don't think or i'm sure a lot of people said that but like
because they say anything but you know i'm just taking that as an example like that really is
is pretty bad like if anyone who wants to know anything about you does a search and it says oh
this person's accused of this bad thing all over the place um and so uh you know that's actually not
what people are i mean i've never had the racism problem that i know of um some people called me sexist
for reasons that we won't get into i'm not sexist but some people called me that um really the thing
that people are the most mad about me for is i'm not communist i'm not socialist and like among indie
game developers that's that's like the absolute worst thing um to believe that uh to believe that
there's merit and that people who work hard should be rewarded for working harder
um and that not everybody should be compensated equally because not everybody brings equal amounts
of effort or equal amounts of talent or even ignoring all that like the structure of a situation
may be just such that one person's role is more valuable to getting the thing done or helping it make
money or whatever like that that person should be compensated more even if that person is equally
talented or less talented than somebody else just because their contribution in terms of the creation
of wealth was bigger right and and this is the foundation right it's like so either you believe
so all the people who are mad all the indie developers who are mad believe in this like communist utopia
where everybody's life is better than it is now because we've changed the economic system to something
unspecified certainly it's not that version of communism that failed every other time and
certainly it won't cause millions of people to be mass murdered like those other times but it'll just be
something that we we haven't we can't tell you what it is because we don't know but it's going to be
great trust me and it's not capitalism because capitalism is terrible like all those people who are
like the majority the thing is it's a minority like almost nobody actually believes this but it you're
punished so severely for speaking out for saying no i don't think that's a good idea that you'll just get
demolished right by the vocal people in the industry and these are still the most vocal people in the
industry now um you know uh it's kind of crazy so that's actually what people are in the past many years
that's what people are the most angry at me about also just other just libertarian ish i'm not really
a libertarian i think there should be a healthy amount of government but like i said like hey we
shouldn't have mask mandates right or no sorry i i said vaccine mandates i said we shouldn't mandate
that people take this weird gene therapy to keep their job and like people were so angry at me for
years and guess what now that's the accepted position like the small the small parts of america
like some places in the military and the government that required people to take this vaccine to keep
their job have now all gotten sued and people have won those lawsuits and they won a lot of money because
it was unconstitutional and illegal right and but i said this on the internet at the wrong time exactly um
and got a lot of people very angry at me and so it's just all these things there's a certain it
changed this is the thing that you notice though it changes from year to year there's some groupthink
that a certain category of people just swear to like they can't possibly believe that this groupthink
could ever be wrong and they'll get incredibly angry at you for questioning it and then three years later
it's like oh yeah that was not right um or you just forget forget that it exists yeah well that too
that too okay all right we have at most 10 more minutes because i have literally another meeting
so i have two things first of all my internet mind thinks like this casey says he hates design or
he's bad at design he doesn't want to do design casey moratorium but he loves programming and he was
jonathan blow programmer turned into game designer and they all know each other supposedly like each other
why there's no game project of casey and jonathan blow combining forces you know you could ask this
about any two people who you know of from doing work and the answer is they're kind of busy on their
own things yeah like you know i made a programming language i know casey well enough that if he were to
design a programming language it would be very different right and so that collaboration wouldn't
make that much sense in that space um when it comes to game design he actually did help out on the witness
um for a little bit you can find on the internet there's a video where he talks about the collision
system that he made that's not a you know co-designer kind of collaboration or anything like that but it
is um a significant contribution that made the game better than it would have been for sure
um but yeah the answer is just we're usually busy and we're doing things that we're very interested in
he's very much on this educational route right so he's doing his computer enhanced stuff
and that takes a lot of his time as well right um i will say i think casey is better at design
than he claims but i do think he just doesn't like design as much or not in the same way as me or
something he doesn't spend as much time on it as i do so that's just the situation there but that's
that's just literally what it is for everything it's so much work to do these things that like
everybody's busy doing their stuff and it's just hard to form collaborations like i didn't expect this
game to take freaking 10 years um i expected it to take 18 months to two years because it was it was
supposed to be a much much smaller game so what if i had started that as a collaboration with somebody
and then it turned into a 10-year thing like one or the other person would have bailed out
right or something so it's fine okay have you seen any of the fan channels that clips uh your streams
like do the highlights sometimes yeah and you know some of those i think are pretty fine and valuable
for people but some of them i really don't like the way they come out you know like so one of the
one of the examples of a distortion that's probably very innocent right but again gets me a lot of hate
is like so i played elden ring and the first session that i played i played for a couple hours i had a
very rough time getting into the game and understanding the game i didn't like it very much because i hadn't
really played any of the pre like bloodborne or dark souls or any of that right and so i just sort of gave
my comments at the end of that first play session but i was like yeah but i'll continue to play but
i was like oh this is a rough game i didn't really like it etc um i went on to play 40 to 50 to 60 more
hours of the game and end of liking it more because once you get into it and it works better you know
you can do the combat and it's more fun and stuff i didn't play it all the way through but i played it
pretty far for someone who has all this work to do but you know this clip goes out and it's just
this one clip of me saying i didn't like it that much and that's what everybody on the internet thinks
i think of elden ring now and because there's so many like fanboys of this genre they're all mad at me
because i think they think i think elden ring sucks and it's like no i played it pretty far it was fine
but people don't see that they just see the clip and so that's the problem with this kind of a thing but
there are um there are great edits have you seen uh the jonathan blow clips that made me consider
quitting my job for real no you know once in a while one of these will come up on youtube because
of the algorithm and i mostly don't clip on them because click on them sorry because i just don't
i i i don't want to be like narcissistic and watching oh this is clips people made of me
it to some extent it's just fine to let let that be what it is and i'll just pretend that i'm not
seeing it and it's fine i said so i don't know i haven't seen this one this one part in particular
okay okay this is really cool i love it like i don't know if i will watch it but you can send it
okay uh what games do you play now um not that many because it's just hard to find games that i
know that i'm gonna want to play um i can name some games that i played recently if usually when
i try to answer this question i also just forget right because i work on so many different things
and my mind's changing around all the time um i definitely played stalker 2 recently right for
some number of i probably played that for like 10 hours or something and i kind of bounced off it
um i've been i play a lot of the zaktronic solitaire collection um that's been my go-to game i've got
like more than a thousand wins i've got like 1400 wins but um that's starting to be a little much
i played lock digital recently uh which was a little puzzle game someone made seems like
very few people have played that uh but i bought that and played it i played the indiana jones in
the great circle briefly did not like that game at all uh bailed i'm looking through my steam list right
now to aid my memory um i played path of exile for you know around 15 hours didn't like that there was
this little mind sweeper kind of game called proverbs that i actually played for 10 hours because i would
just sort of start it up at the end of a stream when i was tired um but not true uh i played that when
it came out which was more than a year ago actually i think okay um but i enjoyed that for a bit and then
you know that was a time when i was very busy because i was trying to get work done on braid
anniversary edition so i didn't have a lot of game time um what else ufo 50 i played some of
i didn't play all 50 games uh core keeper i played a bunch of uh warhammer space marine 2 i played for
like one hour i don't know let me see on steam what does it say 49 minutes i played that for 49 minutes
um you know so mostly i just play games animal well yeah i played animal well i played um
to the ending and then passed it for a while where you're sort of starting to do some of the more
secret stuff but but then i kind of bounced off it you know at that point but you know i played that
game and i i kind of enjoyed it and kind of was really frustrated with it you know because it can be a
really frustrating game a lot of the time okay so okay then uh we're reaching the end so thank you
so much for joining me yeah right on and uh thanks for doing this and i'm glad we could have such a
wide-ranging conversation yeah thank you so much for like you're you're unscripted and unfiltered i think
you're treating the internet as it came out and it's very inspiring yes to a lot of sometimes it causes
me problems yes but but i just i i you know if we're in a world where we can't speak openly about
the things we care about that doesn't sound very good to me so yeah i think i'm going to try to do
what i can to preserve what we have sometimes thank you so much for listening to this episode of the game
engineering podcast don't forget to subscribe on youtube and follow on spotify and other podcasting
platforms see you in the next episode
