[lamb,mu,w] = SVMhard2(10,u14,v14)
and produces the output shown in Figure 52.5. Observe that there is one blue support vector
and two red support vectors.
52.8 Applications of ADMM to ` 1
-Norm Problems
Another important application of ADMM is to ` 1
-norm minimization problems, especially
lasso minimization, discussed below and in Section 55.4. This involves the special case of
ADMM where f(x) = Ï„ k xk 1
and A = I. In particular, in the one-dimensional case, we need
to solve the minimization problem: find
x
âˆ— = arg min
x
ï¿¾
Ï„ |x| + (Ï/2)(x âˆ’ v)
2

,
with x, v âˆˆ R, and Ï, Ï„ > 0. Let c = Ï„/Ï and write
f(x) =
2
Ï„
c
ï¿¾
2c|x| + (x âˆ’ v)
2

.
Minimizing f over x is equivalent to minimizing
g(x) = 2c|x| + (x âˆ’ v)
2 = 2c|x| + x
2 âˆ’ 2xv + v
2
,
52.8. APPLICATIONS OF ADMM TO ` 1
-NORM PROBLEMS 1897
-50 -40 -30 -20 -10 0 10 20 30 40
-50
-40
-30
-20
-10
0
10
20
30
40
50
Figure 52.5: An example of hard margin SVM.
which is equivalent to minimizing
h(x) = x
2 + 2(c|x| âˆ’ xv)
over x. If x â‰¥ 0, then
h(x) = x
2 + 2(cx âˆ’ xv) = x
2 + 2(c âˆ’ v)x = (x âˆ’ (v âˆ’ c))2 âˆ’ (v âˆ’ c)
2
.
If v âˆ’ c > 0, that is, v > c, since x â‰¥ 0, the function x 7â†’ (x âˆ’ (v âˆ’ c))2 has a minimum for
x = v âˆ’ c > 0, else if v âˆ’ c â‰¤ 0, then the function x 7â†’ (x âˆ’ (v âˆ’ c))2 has a minimum for
x = 0.
If x â‰¤ 0, then
h(x) = x
2 + 2(âˆ’cx âˆ’ xv) = x
2 âˆ’ 2(c + v)x = (x âˆ’ (v + c))2 âˆ’ (v + c)
2
.
if v + c < 0, that is, v < âˆ’c, since x â‰¤ 0, the function x 7â†’ (x âˆ’ (v + c))2 has a minimum for
x = v + c, else if v + c â‰¥ 0, then the function x 7â†’ (x âˆ’ (v + c))2 has a minimum for x = 0.
In summary, infx h(x) is the function of v given by
Sc(v) =
ï£±
ï£´ï£²
ï£´ï£³
v âˆ’ c if v > c
0 if |v| â‰¤ c
v + c if v < âˆ’c.
The function Sc is known as a soft thresholding operator . The graph of Sc shown in Figure
52.6.
1898 CHAPTER 52. DUAL ASCENT METHODS; ADMM
Figure 52.6: The graph of Sc (when c = 2).
One can check that
Sc(v) = (v âˆ’ c)+ âˆ’ (âˆ’v âˆ’ c)+,
and also
Sc(v) = (1 âˆ’ c/|v|)+v, v 6 = 0,
which shows that Sc is a shrinkage operator (it moves a point toward zero).
The operator Sc is extended to vectors in R
n
component wise, that is, if x = (x1, . . . , xn),
then
Sc(x) = (Sc(x1), . . . , Sc(xn)).
We now consider several ` 1
-norm problems.
(1) Least absolute deviation.
This is the problem of minimizing k Ax âˆ’ bk 1
, rather than k Ax âˆ’ bk 2
. Least absolute
deviation is more robust than least squares fit because it deals better with outliers.
The problem can be formulated in ADMM form as follows:
minimize k zk 1
subject to Ax âˆ’ z = b,
with f = 0 and g = k k 1
. As usual, we assume that A is an m Ã— n matrix of rank n,
so that A> A is invertible. ADMM (in scaled form) can be expressed as
x
k+1 = (A
> A)
âˆ’1A
> (b + z
k âˆ’ u
k
)
z
k+1 = S1/Ï(Axk+1 âˆ’ b + u
k
)
u
k+1 = u
k + Axk+1 âˆ’ z
k+1 âˆ’ b.
52.8. APPLICATIONS OF ADMM TO ` 1
-NORM PROBLEMS 1899
(2) Basis pursuit.
This is the following minimization problem:
minimize k xk 1
subject to Ax = b,
where A is an m Ã— n matrix of rank m < n, and b âˆˆ R
m, x âˆˆ R
n
. The problem is to
find a sparse solution to an underdetermined linear system, which means a solution x
with many zero coordinates. This problem plays a central role in compressed sensing
and statistical signal processing.
Basis pursuit can be expressed in ADMM form as the problem
minimize IC(x) + k zk 1
subject to x âˆ’ z = 0,
with C = {x âˆˆ R
n
| Ax = b}. It is easy to see that the ADMM procedure (in scaled
form) is
x
k+1 = Î C(z
k âˆ’ u
k
)
z
k+1 = S1/Ï(x
k+1 + u
k
)
u
k+1 = u
k + x
k+1 âˆ’ z
k+1
,
where Î C is the orthogonal projection onto the subspace C. In fact, it is not hard to
show that
x
k+1 = (I âˆ’ A
> (AA> )
âˆ’1A)(z
k âˆ’ u
k
) + A
> (AA> )
âˆ’1
b.
In some sense, an ` 1
-minimization problem is reduced to a sequence of ` 2
-norm probï¿¾lems. There are ways of improving the efficiency of the method; see Boyd et al. [28]
(Section 6.2)
(3) General ` 1
-regularized loss minimization.
This is the following minimization problem:
minimize l(x) + Ï„ k xk 1
,
where l is any proper closed and convex loss function, and Ï„ > 0. We convert the
problem to the ADMM problem:
minimize l(x) + Ï„ k zk 1
subject to x âˆ’ z = 0.
1900 CHAPTER 52. DUAL ASCENT METHODS; ADMM
The ADMM procedure (in scaled form) is
x
k+1 = arg min
x

l(x) + (Ï/2)
  x âˆ’ z
k + u
k


2
2

z
k+1 = SÏ„ /Ï(x
k+1 + u
k
)
u
k+1 = u
k + x
k+1 âˆ’ z
k+1
.
The x-update is a proximal operator evaluation. In general, one needs to apply a
numerical procedure to compute x
k+1, for example, a version of Newtonâ€™s method.
The special case where l(x) = (1/2) k Ax âˆ’ bk
2
2
is particularly important.
(4) Lasso regularization.
This is the following minimization problem:
minimize (1/2) k Ax âˆ’ bk
2
2 + Ï„ k xk 1
.
This is a linear regression with the regularizing term Ï„ k xk 1
instead of Ï„ k xk 2
, to enï¿¾courage a sparse solution. This method was first proposed by Tibshirani around 1996,
under the name lasso, which stands for â€œleast absolute selection and shrinkage operaï¿¾tor.â€ This method is also known as ` 1
-regularized regression, but this is not as cute as
â€œlasso,â€ which is used predominantly. This method is discussed extensively in Hastie,
Tibshirani, and Wainwright [89].
The lasso minimization is converted to the following problem in ADMM form:
minimize
1
2
k
Ax âˆ’ bk
2
2 + Ï„ k zk 1
subject to x âˆ’ z = 0.
Then the ADMM procedure (in scaled form) is
x
k+1 = (A
> A + ÏI)
âˆ’1
(A
> b + Ï(z
k âˆ’ u
k
))
z
k+1 = SÏ„ /Ï(x
k+1 + u
k
)
u
k+1 = u
k + x
k+1 âˆ’ z
k+1
.
Since Ï > 0, the matrix A> A+ÏI is symmetric positive definite. Note that the x-update
looks like a ridge regression step (see Section 55.1).
There are various generalizations of lasso.
(5) Generalized Lasso regularization.
This is the following minimization problem:
minimize (1/2) k Ax âˆ’ bk
2
2 + Ï„ k F xk 1
,
52.9. SUMMARY 1901
where A is an m Ã— n matrix, F is a p Ã— n matrix, and either A has rank n or F has
rank n. This problem is converted to the ADMM problem
minimize k Ax âˆ’ bk
2
2 + Ï„ k zk 1
subject to F x âˆ’ z = 0,
and the corresponding ADMM procedure (in scaled form) is
x
k+1 = (A
> A + ÏF > F)
âˆ’1
(A
> b + ÏF > (z
k âˆ’ u
k
))
z
k+1 = SÏ„ /Ï(F xk+1 + u
k
)
u
k+1 = u
k + F xk+1 âˆ’ z
k+1
.
(6) Group Lasso.
This a generalization of (3). Here we assume that x is split as x = (x1, . . . , xN ),
with xi âˆˆ R
ni and n1 + Â· Â· Â· + xN = n, and the regularizing term k xk 1
is replaced by
P
N
i=1 k xik 2
. When ni = 1, this reduces to (3). The z-update of the ADMM procedure
needs to modified. We define the soft thresholding operator Sc : R
m â†’ R
m given by
Sc(v) =  1 âˆ’
k
v
c
k
2
 +
v,
with Sc(0) = 0. Then the z-update consists of the N updates
z
k
i
+1 = SÏ„ /Ï(x
k
i
+1 + u
k
), i = 1, . . . , N.
The method can be extended to deal with overlapping groups; see Boyd et al. [28]
(Section 6.4).
There are many more applications of ADMM discussed in Boyd et al. [28], including
consensus and sharing. See also Strang [171] for a brief overview.
52.9 Summary
The main concepts and results of this chapter are listed below:
â€¢ Dual ascent.
â€¢ Augmented Lagrangian.
â€¢ Penalty parameter.
â€¢ Method of multipliers.
â€¢ ADMM (alternating direction method of multipliers).
1902 CHAPTER 52. DUAL ASCENT METHODS; ADMM
â€¢ x-update, z-update, Î»-update.
â€¢ Scaled form of ADMM.
â€¢ Residual, dual residual.
â€¢ Stopping criteria.
â€¢ Proximity operator, proximal minimization.
â€¢ Quadratic programming.
â€¢ KKT equations.
â€¢ Soft thresholding operator.
â€¢ Shrinkage operator.
â€¢ Least absolute deviation.
â€¢ Basis pursuit.
â€¢ General ` 1
-regularized loss minimization.
â€¢ Lasso regularization.
â€¢ Generalized lasso regularization.
â€¢ Group lasso.
52.10 Problems
Problem 52.1. In the method of multipliers described in Section 52.2, prove that choosing
Î±
k = Ï guarantees that (u
k+1, Î»k+1) satisfies the equation
âˆ‡Juk+1 + A
> Î»
k+1 = 0.
Problem 52.2. Prove that the Inequality (A1) follows from the Inequalities (A2) and (A3)
(see the proof of Theorem 52.1). For help consult Appendix A of Boyd et al. [28].
Problem 52.3. Consider Example 52.8. Prove that if f = IC, the indicator function of a
nonempty closed convex set C, then
x
+ = arg min
x
ï¿¾
IC(x) + (Ï/2) k x âˆ’ vk
2
2
 = Î C(v),
the orthogonal projection of v onto C. In the special case where C = R
n
+ (the first orthant),
then
x
+ = (v)+,
the vector obtained by setting the negative components of v to zero.
52.10. PROBLEMS 1903
Problem 52.4. Prove that the soft thresholding operator Sc from Section 52.8 satisfies the
equations
Sc(v) = (v âˆ’ c)+ âˆ’ (âˆ’v âˆ’ c)+,
and
Sc(v) = (1 âˆ’ c/|v|)+v, v 6 = 0.
Problem 52.5. Rederive the formula
Sc(v) =
ï£±
ï£´ï£²
ï£´ï£³
v âˆ’ c if v > c
0 if |v| â‰¤ c
v + c if v < âˆ’c
using subgradients.
Problem 52.6. In basis pursuit (see Section 52.8 (2)) prove that
x
k+1 = (I âˆ’ A
> (AA> )
âˆ’1A)(z
k âˆ’ u
k
) + A
> (AA> )
âˆ’1
b.
Problem 52.7. Implement (in Matlab) ADMM applied to lasso regularization as described
in Section 52.6 (4). The stopping criterion should be based on feasibility tolerances  pri
and  dual, say 10âˆ’4
, and on a maximum number of iteration steps, say 10000. There is a
build in Matlab function wthresh implementing soft thresholding. You may use the Matlab
command randn to create a random data set X and a random response vector y (see the
help menu in Matlab under lasso). Try various values of Ï and Ï„ . You will observe that
the choice of Ï greatly affects the rate of convergence of the procedure.
1904 CHAPTER 52. DUAL ASCENT METHODS; ADMM
Part IX
Applications to Machine Learning
1905
Chapter 53
Positive Definite Kernels
This chapter is an introduction to positive definite kernels and the use of kernel functions in
machine learning.
Let X be a nonempty set. If the set X represents a set of highly nonlinear data, it
may be advantageous to map X into a space F of much higher dimension called the feature
space, using a function Ï•: X â†’ F called a feature map. This idea is that Ï• â€œunwindsâ€ the
description of the objects in F in an attempt to make it linear. The space F is usually a
vector space equipped with an inner product hâˆ’, âˆ’i. If F is infinite dimensional, then we
assume that it is a Hilbert space.
Many algorithms that analyze or classify data make use of the inner products h Ï•(x), Ï•(y)i ,
where x, y âˆˆ X. These algorithms make use of the function Îº: X Ã— X â†’ C given by
Îº(x, y) = h Ï•(x), Ï•(y)i , x, y âˆˆ X,
called a kernel function.
The kernel trick is to pretend that we have a feature embedding Ï•: X â†’ F (actually
unknown), but to only use inner products h Ï•(x), Ï•(y)i that can be evaluated using the
original data through the known kernel function Îº. It turns out that the functions of the
form Îº as above can be defined in terms of a condition which is reminiscent of positive
semidefinite matrices (see Definition 53.2). Furthermore, every function satisfying Definition
53.2 arises from a suitable feature map into a Hilbert space; see Theorem 53.8.
We illustrate the kernel methods on kernel PCA (see Section 53.4).
53.1 Feature Maps and Kernel Functions
Definition 53.1. Let X be a nonempty set, let H be a (complex) Hilbert space, and let
Ï•: X â†’ H be a function called a feature map. The function Îº: X Ã— X â†’ C given by
Îº(x, y) = h Ï•(x), Ï•(y)i , x, y âˆˆ X,
is called a kernel function.
1907
1908 CHAPTER 53. POSITIVE DEFINITE KERNELS
Remark: A feature map is often called a feature embedding, but this terminology is a bit
misleading because it suggests that such a map is injective, which is not necessarily the case.
Unfortunately this terminology is used by most people.
Example 53.1. Suppose we have two feature maps Ï•1 : X â†’ R
n1 and Ï•2 : X â†’ R
n2
, and let
Îº1(x, y) = h Ï•1(x), Ï•1(y)i and Îº2(x, y) = h Ï•2(x), Ï•2(y)i be the corresponding kernel functions
(where hâˆ’, âˆ’i is the standard inner product on R
n
). Define the feature map Ï•: X â†’ R
n1+n2
by
Ï•(x) = (Ï•1(x), Ï•2(x)),
an (n1 + n2)-tuple. We have
h
Ï•(x), Ï•(y)i = h (Ï•1(x), Ï•2(x)),(Ï•1(y), Ï•2(y))i = h Ï•1(x), Ï•1(y)i + h Ï•2(x), Ï•2(y)i
= Îº1(x, y) + Îº2(x, y),
which shows that the map Îº given by
Îº(x, y) = Îº1(x, y) + Îº2(x, y)
is the kernel function corresponding to the feature map Ï•: X â†’ R
n1+n2
.
Example 53.2. Let X be a subset of R
2
, and let Ï•1 : X â†’ R
3 be the map given by
Ï•1(x1, x2) = (x
2
1
, x2
2
,
âˆš
2x1x2).
Figure 53.1 illustrates Ï•1 : X â†’ R
3 when X = {((x1, x2) | âˆ’10 â‰¤ x1 â‰¤ 10, âˆ’10 â‰¤ x2 â‰¤ 10}.
Observe that linear relations in the feature space H = R
3
correspond to quadratic relaï¿¾tions in the input space (of data). We have
h
Ï•1(x), Ï•1(y)i = h (x
2
1
, x2
2
,
âˆš
2x1x2),(y1
2
, y2
2
,
âˆš
2y1y2)i
= x
2
1
y1
2 + x
2
2
y2
2 + 2x1x2y1y2
= (x1y1 + x2y2)
2 = h x, yi 2
,
where h x, yi is the usual inner product on R
2
. Hence the function
Îº(x, y) = h x, yi 2
is a kernel function associated with the feature space R
3
.
If we now consider the map Ï•2 : X â†’ R
4 given by
Ï•2(x1, x2) = (x
2
1
, x2
2
, x1x2, x1x2),
we check immediately that
h
Ï•2(x), Ï•2(y)i = Îº(x, y) = h x, yi 2
,
which shows that the same kernel can arise from different maps into different feature spaces.
53.1. FEATURE MAPS AND KERNEL FUNCTIONS 1909
Figure 53.1: The parametric surface Ï•1(x1, x2) = (x
2
1
, x2
2
,
âˆš
2x1x2) where âˆ’10 â‰¤ x1 â‰¤ 10 and
âˆ’10 â‰¤ x2 â‰¤ 10.
Example 53.3. Example 53.2 can be generalized as follows. Suppose we have a feature map
Ï•1 : X â†’ R
n and let Îº1(x, y) = h Ï•1(x), Ï•1(y)i be the corresponding kernel function (where
its
hâˆ’,
n
âˆ’i
2
components
is the standard inner product on R
n
). Define the feature map Ï•: X â†’ R
n Ã— R
n by
Ï•(x)(i,j) = (Ï•1(x))i(Ï•1(x))j
, 1 â‰¤ i, j â‰¤ n,
with the inner product on R
n Ã— R
n given by
h
u, vi =
nX
i,j=1
u(i,j)v(i,j)
.
Then we have
h
Ï•(x), Ï•(y)i =
nX
i,j=1
Ï•(i,j)(x)Ï•(i,j)(y)
=
nX
i,j=1
(Ï•1(x))i(Ï•1(x))j (Ï•1(y))i(Ï•1(y))j
=
nX
i=1
(Ï•1(x))i(Ï•1(y))i
nX
j=1
(Ï•1(x))j (Ï•1(y))j
= (Îº1(x, y))2
.
1910 CHAPTER 53. POSITIVE DEFINITE KERNELS
Thus the map Îº given by Îº(x, y) = (Îº1(x, y))2
is a kernel map associated with the feature
map Ï•: X â†’ R
n Ã— R
n
. The feature map Ï• is a direct generalization of the feature map Ï•2
of Example 53.2.
The above argument is immediately adapted to show that if Ï•1 : X â†’ R
n1 and Ï•2 : X â†’
R
n2 are two feature maps and if Îº1(x, y) = h Ï•1(x), Ï•1(y)i and Îº2(x, y) = h Ï•2(x), Ï•2(y)i are
the corresponding kernel functions, then the map defined by
Îº(x, y) = Îº1(x, y)Îº2(x, y)
is a kernel function for the feature space R
n1 Ã— R
n2 and the feature map
Ï•(x)(i,j) = (Ï•1(x))i(Ï•2(x))j
, 1 â‰¤ i â‰¤ n1, 1 â‰¤ j â‰¤ n2.
Example 53.4. Note that the feature map Ï•: X â†’ R
n Ã—R
n
is not very economical because
if i 6 = j then the components Ï•(i,j)(x) and Ï•(j,i)(x) are both equal to (Ï•1(x))i(Ï•1(x))j
.
Therefore we can define the more economical embedding Ï•
0 : X â†’ R(
n+1
2 ) given by
Ï•
0 (x)(i,j) =
(
(Ï•1(x))2
i
i = j,
âˆš
2(Ï•1(x))i(Ï•1(x))j i < j,
where the pairs (i, j) with 1 â‰¤ i â‰¤ j â‰¤ n are ordered lexicographically. The feature map Ï•
is a direct generalization of the feature map Ï•1 of Example 53.2.
Observe that Ï•
0 can also be defined in the following way which makes it easier to come
up with the generalization to any power:
Ï•
0(i1,...,in)
(x) = 
i1 Â· Â· Â·
2
in

1/2
(Ï•1(x))i
1
1
(Ï•1(x))i
1
2
Â· Â· Â·(Ï•1(x))i
1
n
, i1 + i2 + Â· Â· Â· + in = 2, ij âˆˆ N,
where the n-tuples (i1, . . . , in) are ordered lexicographically. Recall that for any m â‰¥ 1 and
any (i1, . . . , in) âˆˆ N
m such that i1 + i2 + Â· Â· Â· + in = m, we have

i1 Â· Â· Â·
m
in

=
i1! Â· Â· Â·
m!
in!
.
More generally, for any m â‰¥ 2, using the multinomial theorem, we can define a feature
embedding Ï•: X â†’ R(
n+
m
mâˆ’1
) defining the kernel function Îº given by Îº(x, y) = (Îº1(x, y))m,
with Ï• given by
Ï•(i1,...,in)(x) = 
i1 Â· Â· Â·
m
in

1/2
(Ï•1(x))i
1
1
(Ï•1(x))i
1
2
Â· Â· Â·(Ï•1(x))i
1
n
, i1 + i2 + Â· Â· Â· + in = m, ij âˆˆ N,
where the n-tuples (i1, . . . , in) are ordered lexicographically.
53.1. FEATURE MAPS AND KERNEL FUNCTIONS 1911
Example 53.5. For any positive real constant R > 0, the constant function Îº(x, y) = R is
a kernel function corresponding to the feature map Ï•: X â†’ R given by Ï•(x, y) = âˆš
R.
By definition, the function Îº
01
: R
n â†’ R given by Îº
01
(x, y) = h x, yi is a kernel function
(the feature map is the identity map from R
n
to itself). We just saw that for any positive
real constant R > 0, the constant Îº
02
(x, y) = R is a kernel function. By Example 53.1, the
function Îº
03
(x, y) = Îº
01
(x, y) + Îº
02
(x, y) is a kernel function, and for any integer d â‰¥ 1, by
Example 53.4, the function Îºd given by
Îºd(x, y) = (Îº
03
(x, y))d = (h x, yi + R)
d
,
is a kernel function on R
n
. By the binomial formula,
Îºd(x, y) =
d
X
m=0
R
dâˆ’mh x, yi m.
By Example 53.1, the feature map of this kernel function is the concatenation of the features
of the d + 1 kernel maps Rdâˆ’mh x, yi m. By Example 53.3, the components of the feature map
of the kernel map Rdâˆ’mh x, yi m are reweightings of the functions
Ï•(i1,...,in)(x) = x
i
1
1 x
i
2
2
Â· Â· Â· x
i
n
n
, i1 + i2 + Â· Â· Â· + in = m,
with (i1, . . . , in) âˆˆ N
n
. Thus the components of the feature map of the kernel function Îºd
are reweightings of the functions
Ï•(i1,...,in)(x) = x
i
1
1 x
i
2
2
Â· Â· Â· x
i
n
n
, i1 + i2 + Â· Â· Â· + in â‰¤ d,
with (i1, . . . , in) âˆˆ N
n
. It is easy to see that the dimension of this feature space is ï¿¾ m+d
d

.
There are a number of variations of the polynomial kernel Îºd; all-subsets embedding
kernels, ANOVA kernels; see Shaweâ€“Taylor and Christianini [159], Chapter III.
In the next example the set X is not a vector space.
Example 53.6. Let D be a finite set and let X = 2D be its power set. If |D| = n,
let H = R
X âˆ¼= R
2
n
. We are assuming that the subsets of D are enumerated in some
fashion so that each coordinate of R
2
n
corresponds to one of these subsets. For example, if
D = {1, 2, 3, 4}, let
U1 = âˆ… U2 = {1} U3 = {2} U4 = {3}
U5 = {4} U6 = {1, 2} U7 = {1, 3} U8 = {1, 4}
U9 = {2, 3} U10 = {2, 4} U11 = {3, 4} U12 = {1, 2, 3}
U13 = {1, 2, 4} U14 = {1, 3, 4} U15 = {2, 3, 4} U16 = {1, 2, 3, 4}.
Let Ï•: X â†’ H be the feature map defined as follows: for any subsets A, U âˆˆ X,
Ï•(A)U =
(
0 otherwise
1 if U âŠ† A
.
1912 CHAPTER 53. POSITIVE DEFINITE KERNELS
For example, if A1 = {1, 2, 3}, we obtain the vector
Ï•({1, 2, 3}) = (1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0),
and if A2 = {2, 3, 4}, we obtain the vector
Ï•({2, 3, 4}) = (1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0).
For any two subsets A1 and A2 of D, it is easy to check that
h
Ï•(A1), Ï•(A2)i = 2|A1âˆ©A2|
,
the number of common subsets of A1 and A2. For example, A1 âˆ© A2 = {2, 3}, and
h
Ï•(A1), Ï•(A2)i = 4.
Therefore, the function Îº: X Ã— X â†’ R given by
Îº(A1, A2) = 2|A1âˆ©A2|
, A1, A2 âŠ† D
is a kernel function.
Kernels on collections of sets can be defined in terms of measures.
Example 53.7. Let (D, A) be a measurable space, where D is a nonempty set and A is a
Ïƒ-algebra on D (the measurable sets). Let X be a subset of A. If Âµ is a positive measure
on (D, A) and if Âµ is finite, which means that Âµ(D) is finite, then we can define the map
Îº1 : X Ã— X â†’ R given by
Îº1(A1, A2) = Âµ(A1 âˆ© A2), A1, A2 âˆˆ X.
We can show that Îº is a kernel function as follows. Let H = L2
Âµ
(D, A, R) be the Hilbert
space of Âµ-square-integrable functions with the inner product
h
f, gi =
Z
D
f(s)g(s) dÂµ(s),
and let Ï•: X â†’ H be the feature embedding given by
Ï•(A) = Ï‡A, A âˆˆ X,
the characteristic function of A. Then we have
Îº1(A1, A2) = Âµ(A1 âˆ© A2) = Z
D
Ï‡A1âˆ©A2
(s) dÂµ(s)
=
Z
D
Ï‡A1
(s)Ï‡A2
(s) dÂµ(s) = h Ï‡A1
, Ï‡A2
i
= h Ï•(A1), Ï•(A2)i .
53.1. FEATURE MAPS AND KERNEL FUNCTIONS 1913
The above kernel is called the intersection kernel. If we assume that Âµ is normalized so
that Âµ(D) = 1, then we also have the union complement kernel:
Îº2(A1, A2) = Âµ(A1 âˆ© A2) = 1 âˆ’ Âµ(A1 âˆª A2).
The sum Îº3 of the kernels Îº1 and Îº2 is the agreement kernel:
Îºs(A1, A2) = 1 âˆ’ Âµ(A1 âˆ’ A2) âˆ’ Âµ(A2 âˆ’ A1).
Many other kinds of kernels can be designed, in particular, graph kernels. For comï¿¾prehensive presentations of kernels, see SchÂ¨olkopf and Smola [145] and Shaweâ€“Taylor and
Christianini [159].
Kernel functions have the following important property.
Proposition 53.1. Let X be any nonempty set, let H be any (complex) Hilbert space, let
Ï•: X â†’ H be any function, and let Îº: X Ã— X â†’ C be the kernel given by
Îº(x, y) = h Ï•(x), Ï•(y)i , x, y âˆˆ X.
For any finite subset S = {x1, . . . , xp} of X, if KS is the p Ã— p matrix
KS = (Îº(xj
, xi))1â‰¤i,jâ‰¤p = (h Ï•(xj ), Ï•(xi)i )1â‰¤i,jâ‰¤p,
then we have
u
âˆ—KS u â‰¥ 0, for all u âˆˆ C
p
.
Proof. We have
u
âˆ—KS u = u
> KS
> u =
p
X
i,j=1
Îº(xi
, xj )uiuj
=
p
X
i,j=1
h
Ï•(x), Ï•(y)i uiuj
=
*
p
X
i=1
uiÏ•(xi),
p
X
j=1
ujÏ•(xj )
+ =


 

p
X
i=1
uiÏ•(xi)




2
â‰¥ 0,
as claimed.
1914 CHAPTER 53. POSITIVE DEFINITE KERNELS
53.2 Basic Properties of Positive Definite Kernels
Proposition 53.1 suggests a second approach to kernel functions which does not assume that
a feature space and a feature map are provided. We will see in Section 53.3 that the two
approaches are equivalent. The second approach is useful in practice because it is often
difficult to define a feature space and a feature map in a simple manner.
Definition 53.2. Let X be a nonempty set. A function Îº: X Ã— X â†’ C is a positive definite
kernel if for every finite subset S = {x1, . . . , xp} of X, if KS is the p Ã— p matrix
KS = (Îº(xj
, xi))1â‰¤i,jâ‰¤p
called a Gram matrix , then we have
u
âˆ—KS u =
p
X
i,j=1
Îº(xi
, xj )uiuj â‰¥ 0, for all u âˆˆ C
p
.
Observe that Definition 53.2 does not require that u
âˆ—KS u > 0 if u 6 = 0, so the terminology
positive definite is a bit abusive, and it would be more appropriate to use the terminology
positive semidefinite. However, it seems customary to use the term positive definite kernel,
or even positive kernel.
Proposition 53.2. Let Îº: X Ã— X â†’ C be a positive definite kernel. Then Îº(x, x) â‰¥ 0 for
all x âˆˆ X, and for any finite subset S = {x1, . . . , xp} of X, the p Ã— p matrix KS given by
KS = (Îº(xj
, xi))1â‰¤i,jâ‰¤p
is Hermitian, that is, KS
âˆ— = KS.
Proof. The first property is obvious by choosing S = {x}. To prove that KS is Hermitian,
observe that we have
(u + v)
âˆ—KS(u + v) = u
âˆ—KSu + u
âˆ—KSv + v
âˆ—KSu + v
âˆ—KSv,
and since (u + v)
âˆ—KS(u + v), uâˆ—KSu, vâˆ—KSv â‰¥ 0, we deduce that
2A = u
âˆ—KSv + v
âˆ—KSu (1)
must be real. By replacing u by iu, we see that
2B = âˆ’iuâˆ—KSv + ivâˆ—KSu (2)
must also be real. By multiplying Equation (2) by i and adding it to Equation (1) we get
u
âˆ—KSv = A + iB. (3)
53.2. BASIC PROPERTIES OF POSITIVE DEFINITE KERNELS 1915
By subtracting Equation (3) from Equation (1) we get
v
âˆ—KSu = A âˆ’ iB.
Then
u
âˆ—KS
âˆ—
v = v
âˆ—KSu = A âˆ’ iB = A + iB = u
âˆ—KSv,
for all u, v âˆˆ C
âˆ—
, which implies KS
âˆ— = KS.
If the map Îº: X Ã— X â†’ R is real-valued, then we have the following criterion for Îº to be
a positive definite kernel that only involves real vectors.
Proposition 53.3. If Îº: X Ã— X â†’ R, then Îº is a positive definite kernel iff for any finite
subset S = {x1, . . . , xp} of X, the p Ã— p real matrix KS given by
KS = (Îº(xk, xj ))1â‰¤j,kâ‰¤p
is symmetric, that is, KS
> = KS, and
u
> KS u =
p
X
j,k=1
Îº(xj
, xk)ujuk â‰¥ 0, for all u âˆˆ R
p
.
Proof. If Îº is a real-valued positive definite kernel, then the proposition is a trivial conseï¿¾quence of Proposition 53.2.
For the converse assume that Îº is symmetric and that it satisfies the second condition of
the proposition. We need to show that Îº is a positive definite kernel with respect to complex
vectors. If we write uk = ak + ibk, then
u
âˆ—KS u =
p
X
j,k=1
Îº(xj
, xk)(aj + ibj )(ak âˆ’ ibk)
=
p
X
j,k=1
(ajak + bj bk)Îº(xj
, xk) + i
p
X
j,k=1
(bjak âˆ’ aj bk)Îº(xj
, xk)
=
p
X
j,k=1
(ajak + bj bk)Îº(xj
, xk) + i
X
1â‰¤j<kâ‰¤p
