Con
tributions
to
Inductiv
e
Logic
Programming
Afstudeerscriptie
Bestuurlijk
e
Informatica
R.
M.
de
W
olf
	0
Erasm
us
Univ
ersiteit
Rotterdam
Dr.
S.-H.
Nienh
uys-Cheng
Mei
		

Con
ten
ts
Preface
iii

What
is
Inductiv
e
Logic
Programming?

.
The
imp
ortance
of
learning
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Inductiv
e
learning
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
The
problem
setting
for
ILP
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Other
problem
settings
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
A
brief
history
of
the
eld
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
An
outline
of
the
thesis
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


The
Subsumption
Theorem
for
Sev
eral
F
orms
of
Resolution

.
In
tro
duction
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Preliminaries
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
The
Subsumption
Theorem
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
The
Subsumption
Theorem
for
ground

and
C
:
:
:
:
:
	
..
The
Subsumption
Theorem
when
C
is
ground
:
:
:
:
:
:
:
0
..
The
Subsumption
Theorem
(general
case)
:
:
:
:
:
:
:
:
:

.
The
refutation-completeness
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
F
rom
Subsumption
Theorem
to
refutation-completeness
:

..
F
rom
refutation-completeness
to
Subsumption
Theorem
:

.
Linear
resolution
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
Denitions
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
The
refutation-completeness
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
The
Subsumption
Theorem
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Input
resolution
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
SLD-resolution
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
The
refutation-completeness
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
The
Subsumption
Theorem
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Summary
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:


Unfolding
	
.
In
tro
duction
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Unfolding
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
UD

-sp
ecialization
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
UD

-sp
ecialization
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
UDS-sp
ecialization
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

i

ii
CONTENTS
.
Relation
with
in
v
erse
resolution
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Summary
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0

Least
Generalizations
and
Greatest
Sp
ecializations

.
In
tro
duction
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Preliminaries
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Least
generalizations
and
greatest
sp
ecializations
:
:
:
:
:
:
:
:
:

.
Subsumption
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
.
Least
generalizations
under
implication
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

..
A
sucien
t
condition
for
the
existence
of
an
LGI
:
:
:
:
:

..
The
LGI
is
computable
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

.
Greatest
sp
ecializations
under
implication
:
:
:
:
:
:
:
:
:
:
:
:
:
	
.
Least
generalizations
under
relativ
e
implication
:
:
:
:
:
:
:
:
:
:
0
.
Greatest
sp
ecializations
under
relativ
e
implication
:
:
:
:
:
:
:
:

.	
Summary
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A
Denitions
from
Logic

A.
Syn
tax
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A.
Seman
tics
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A..
In
terpretations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A..
Mo
dels
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A..
Con
v
en
tions
to
simplify
notation
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
A.
Normal
forms
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
A..
Prenex
conjunctiv
e
normal
form
:
:
:
:
:
:
:
:
:
:
:
:
:
:
0
A..
Sk
olem
standard
form
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A.
Herbrand
in
terpretations
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A.
Horn
clauses
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A.
Substitution
and
unication
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A..
Substitution
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

A..
Unication
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:
:

Bibliograph
y

Author
Index
	
Sub
ject
Index
	

Preface
This
graduation
thesis
is
the
result
of
nearly
t
w
o
y
ears
of
researc
h
in
to
v
arious
asp
ects
of
Inductiv
e
Logic
Programming
(ILP),
p
erformed
b
y
m
y
sup
ervisor
Shan-Hw
ei
Nienh
uys-Cheng
and
m
yself.
ILP
is
a
v
ery
y
oung
eld
of
researc
h,
whic
h
can
b
e
seen
as
the
in
tersection
of
Mac
hine
Learning
and
Logic
Program-
ming.
Accordingly
,
it
is
concerned
with
learning
a
general
theory
from
giv
en
examples,
within
the
framew
ork
pro
vided
b
y
(clausal)
logic.
Lik
e
so
man
y
other
y
oung
researc
h
comm
unities,
ILP
is
c
haracterized
b
y
a
mild
form
of
c
haos.
Most
denitions
and
results
are
only
a
v
ailable
in
widely
scattered
researc
h
pap
ers.
As
a
consequence,
concepts
are
not
alw
a
ys
uniformly
dened,
often
v
ague,
and
pro
ofs
are
not
alw
a
ys
correct.
Eviden
tly
,
what
ILP
needs
is
a
b
o
ok
collecting
these
concepts
and
results
in
a
self-con
tained,
unied
and
rigorous
manner.
Near
the
end
of
the
spring
of
		,
just
at
the
momen
t
when
I
started
w
orrying
ab
out
a
topic
on
whic
h
to
graduate,
Shan-Hw
ei
came
along
and
ask
ed
me
to
join
her
in
writing
precisely
suc
h
a
b
o
ok.
The
researc
h
presen
ted
in
this
thesis
is
actually
a
spin-o
of
the
researc
h
w
e
ha
v
e
done
for
our
b
o
ok.
This
b
o
ok
is
b
y
no
w
nearly
nished
and
is
to
b
e
published
early
next
y
ear.
The
researc
h
in
this
thesis
can
b
e
divided
in
to
three
parts:
deduction,
sp
e-
cialization
of
theories,
and
least
generalizations
and
greatest
sp
ecializations
of
sets
of
clauses.
These
directions
of
researc
h
corresp
ond
to
Chapters
,

and
,
resp
ectiv
ely
,
whic
h
form
the
main
part
of
the
thesis.
Chapter

is
based
on
[NCW	a
,
NCW	d
,
NCW	e
,
NCW	f
,
NCW	d
]

,
a
n
um
b
er
of
articles
join
tly
written
b
y
Shan-Hw
ei
and
m
yself.
Chapter

is
based
on
our
pap
ers
[NCW	b,
NCW	c
,
NCW	a
,
NCW	c
],
while
Chapter

is
a
sligh
tly
revised
v
ersion
of
our
article
[NCW	b
].
These
three
c
hapters
are
preceded
b
y
an
in
tro
ductory
c
hapter
whic
h
denes
and
discusses
the
basic
problem
setting
of
ILP
,
giv
es
a
brief
history
of
the
eld
and
outlines
the
thesis.
F
urthermore,
in
order
to
mak
e
the
thesis
a
self-con
tained
text
an
app
endix
is
added,
whic
h
giv
es
the
main
denitions
from
logic
that
w
e
need.
Let
me
nish
this
preface
b
y
expressing
m
y
gratitude
to
Shan-Hw
ei
Nienh
uys-
Cheng.
During
the
past
t
w
o
y
ears,
as
our
b
o
ok
slo
wly
to
ok
shap
e
and
the
ab
o
v
e-
men
tioned
articles
w
ere
written,
I
ha
v
e
sp
en
t
man
y
hours
discussing,
c
hatting
and
(sometimes)
arguing
with
her.
I
w
ould
lik
e
to
thank
her
v
ery
m
uc
h
for
in
tro
ducing
me
to
the
w
orld
of
scien
tic
researc
h,
for
giving
me
a
feel
of
what
a
go
o
d
pro
of
should
lo
ok
lik
e,
and
for
our
pleasan
t,
fruitful,
and
v
ery
stim
ulating
co
op
eration.

Our
pap
er
[NCW	f
]
w
as
a
w
arded
the
Best
P
ap
er
Aw
ard
at
NAIC'	.
iii

Chapter

What
is
Inductiv
e
Logic
Programming?
.
The
imp
ortance
of
learning
Him
she
found
sw
eating
with
toil
as
he
mo
v
ed
to
and
fro
ab
out
his
b
ello
ws
in
eager
haste;
for
he
w
as
fashioning
trip
o
ds,
t
w
en
t
y
in
all,
to
stand
around
the
w
all
of
his
w
ell-builded
hall,
and
golden
wheels
had
he
set
b
eneath
the
base
of
eac
h
that
of
themselv
es
they
migh
t
en
ter
the
gathering
of
the
go
ds
at
his
wish
and
again
return
to
his
house,
a
w
onder
to
b
ehold.
Iliad,
XVI
I
I,
{
(pp.
{
of
[Hom
],
second
v
olume).
This
quotation
from
Homer's
Iliad
is
p
erhaps
the
rst
ev
er
reference
in
W
est-
ern
literature
to
something
lik
e
A
rticial
Intel
ligenc
e
:
man-made
(or
in
this
case,
go
d-made)
artifacts
displa
ying
in
telligen
t
b
eha
viour.
As
Thetis,
Ac
hilles'
mother,
en
ters
Hephaestus'
house
in
order
to
fetc
h
her
son
a
new
armour,
she
nds
Hephaestus
constructing
something
w
e
to
da
y
w
ould
call
r
ob
ots.
His
t
w
en
t
y
trip
o
ds
are
of
themselves
to
serv
e
the
gathering
of
the
go
ds
(bring
them
fo
o
d,
etc.),
whenev
er
Hephaestus
so
desires.
Let
us
consider
for
a
momen
t
the
kind
of
b
eha
viour
suc
h
a
trip
o
d
should
displa
y
.
Ob
viously
,
it
should
b
e
able
to
recognise
Hephaestus'
v
oice,
and
to
extract
his
wishes
from
his
w
ords.
But
furthermore,
when
serving
the
go
ds,
the
trip
o
d
should
\kno
w"
and
act
up
on
man
y
requiremen
ts,
suc
h
as
the
follo
wing:
.
If
there
is
roasted
o
wl
for
dinner,
don't
giv
e
an
y
to
P
allas
A
thena.
.
Don't
come
to
o
close
to
Hera
if
Zeus
has
committed
adultery
again.
.
Stop
fetc
hing
wine
for
Dion
ysus
when
he
is
to
o
drunk.
:
:
:
It
is
clear
that
this
list
can
b
e
con
tin
ued
without
end.
Again
and
again,
one
can
think
of
new
situations
that
the
trip
o
d
should
b
e
able
to
adapt
to
prop
erly
.
It
seems
imp
ossible
to
tak
e
all
these
requiremen
ts
in
to
accoun
t
explicitly
in
the
construction
of
the
in
telligen
t
trip
o
d.
The
task
of
\co
ding"
eac
h
of
the
innite
n
um
b
er
of
requiremen
ts
in
to
the
trip
o
ds
ma
y
b
e
considered
to
o
m
uc
h,
ev
en
for
Hephaestus,
certainly
one
of
the
most
industrious
among
the
Greek
go
ds.



CHAPTER
.
WHA
T
IS
INDUCTIVE
LOGIC
PR
OGRAMMING?
One
solution
to
this
problem
w
ould
b
e
to
initially
endo
w
the
trip
o
d
with
a
mo
dest
amoun
t
of
general
kno
wledge
ab
out
what
he
should
do,
and
to
giv
e
it
the
abilit
y
to
le
arn
from
the
w
a
y
the
en
vironmen
t
reacts
to
its
b
eha
viour.
That
is,
if
the
trip
o
d
do
es
something
wrong,
it
can
adjust
its
kno
wledge
and
its
b
eha
viour
accordingly
,
th
us
a
v
oiding
making
the
same
mistak
e
in
the
future.

In
that
w
a
y
,
the
trip
o
d
need
not
kno
w
ev
erything
b
eforehand.
Instead,
it
can
build
up
most
of
the
required
kno
wledge
along
the
w
a
y
.
Th
us
the
trip
o
d's
abilit
y
to
learn
w
ould
sa
v
e
Hephaestus
a
lot
of
trouble.
The
imp
ortance
of
learning
is
not
restricted
to
artifacts
built
to
serv
e
divine
wishes.
Also
for
man
y
more
earthly
purp
oses,
the
need
for
learning
can
easily
b
e
seen.
F
or
instance,
constructing
a
kno
wledge
base
for
some
exp
ert
system
b
y
in
terviewing
exp
erts
and
writing
do
wn
the
rules
they
giv
e,
is
a
v
ery
exp
ensiv
e
and
time-consuming
business.
It
w
ould
b
e
m
uc
h
easier
if
the
exp
ert
system
w
ere
able
to
learn
its
rules
itself,
from
a
n
um
b
er
of
giv
en
examples.
Suc
h
le
arning
fr
om
examples
will
b
e
the
topic
of
this
thesis.
.
Inductiv
e
learning
Learning
a
general
theory
from
sp
ecic
examples,
commonly
called
induction,
has
b
een
a
topic
of
inquiry
for
cen
turies.
It
is
often
seen
as
a
main
source
of
scien
tic
kno
wledge.
Supp
ose
w
e
are
giv
en
a
large
n
um
b
er
of
patien
t's
records
from
a
hospital,
consisting
of
prop
erties
of
eac
h
patien
t,
including
symptoms
and
diseases.
W
e
w
an
t
to
nd
some
general
rules,
concerning
whic
h
symptoms
indicate
whic
h
diseases.
The
hospital's
records
pro
vide
examples
from
whic
h
w
e
can
nd
clues
as
to
what
those
rules
are.
Consider
measles,
a
virus
disease.
If
ev
ery
patien
t
in
the
hospital
who
has
a
fev
er
and
has
red
sp
ots
suers
from
measles,
w
e
could
infer
the
general
rule
.
\If
someone
has
a
fev
er
and
red
sp
ots,
he
has
measles."
Moreo
v
er,
if
eac
h
patien
t
with
measles
also
has
red
sp
ots,
w
e
can
infer
.
\If
someone
has
measles,
he
will
get
red
sp
ots."
These
inferences
are
cases
of
induction.
Note
that
these
rules
not
only
tell
us
something
ab
out
the
p
eople
in
the
hospital's
records,
but
are
in
fact
ab
out
everyone.
Accordingly
,
they
ha
v
e
predictiv
e
p
o
w
er:
they
can
b
e
used
to
mak
e
predictions
ab
out
future
patien
ts
with
the
same
symptoms
or
diseases.
Usually
when
w
e
w
an
t
to
learn
something,
w
e
do
not
start
from
scratc
h:
most
often
w
e
already
ha
v
e
some
b
ackgr
ound
know
le
dge
relev
an
t
to
the
learning
task.
F
or
instance,
in
the
hospital
records
w
e
migh
t
nd
a
case
of
a
patien
t
a
in
an
early
fase
of
measles:
he
has
a
fev
er,
but
not
y
et
red
sp
ots.
Then
the
previous
rule
no.

cannot
b
e
used.
No
w
supp
ose
in
the
records
w
e
see
that
this
p
erson
has
the
same
address
as
another
patien
t
b
suering
from
measles.
Since
w
e
kno
w
that
measles
is
a
rather
con
tagious
disease,
w
e
can
infer
that
a

Of
course,
for
this
sc
heme
to
w
ork,
w
e
ha
v
e
to
assume
that
the
trip
o
d
\surviv
es"
its
initial
failures.
If
Zeus
immediately
smashes
the
trip
o
d
in
to
pieces
for
bringing
him
white
instead
of
red
wine,
the
trip
o
d
w
on't
b
e
able
to
learn
from
its
exp
erience.

..
INDUCTIVE
LEARNING

also
has
measles.
The
fact
that
measles
is
con
tagious,
is
not
something
that
is
expressed
in
the
hospital
records.
Instead,
it
is
a
piece
of
kno
wledge
that
w
e
already
had.
Nev
ertheless,
this
piece
of
bac
kground
kno
wledge
com
bined
with
the
examples
allo
ws
us
to
induce
the
general
rule
.
\If
x
has
a
fev
er,
y
has
measles,
and
x
and
y
liv
e
in
the
same
house,
then
x
has
measles."
This
rule
can
then
b
e
com
bined
with
rule
no.

to
predict
that
x
will
get
red
sp
ots.
Induction
is
often
view
ed
as
the
dual
of
deduction:
in
the
latter
case
w
e
deriv
e
the
sp
ecial
case
from
the
general
theory
,
while
in
the
former,
w
e
construct
a
general
theory
from
a
n
um
b
er
of
giv
en
particular
cases,
namely
the
examples.
One
imp
ortan
t
dierence
b
et
w
een
deduction
and
induction,
is
the
fact
that
deduction
is
truth-pr
eserving
:
if
the
general
theory
is
true,
then
the
deriv
ed
particular
cases
are
also
true.
Induction,
on
the
other
hand,
is
not
truth-
preserving:
the
examples
ma
y
b
e
true,
while
the
induced
theory
is
false.
F
or
instance,
ev
en
if
our
rules
on
measles
are
true
for
all
records
of
all
the
hospitals
in
the
w
orld,
they
ma
y
still
b
e
false
for
p
eople
not
in
the
records.
The
study
of
induction
can
b
e
approac
hed
from
man
y
angles.
It
used
to
b
e
mainly
an
issue
for
philosophers
of
science
(see
Section
.),
but
is
no
w
ada
ys
also
often
studied
in
relation
to
computer
algorithms,
within
the
eld
of
Ar-
ticial
In
telligence
(AI).
As
Marvin
Minsky
,
one
of
the
founders
of
AI,
wrote:
\Articial
In
telligence
is
the
science
of
making
mac
hines
do
things
that
w
ould
require
in
telligence
if
done
b
y
man"
[Min,
p.
v].
Giv
en
this
view,
the
study
of
induction
is
indeed
part
of
AI,
since
learning
from
examples
certainly
requires
in
telligence
if
done
b
y
man.
The
branc
h
of
AI
whic
h
studies
learning
is
called
Machine
L
e
arning.
Some
of
the
main
approac
hes
in
Mac
hine
Learning
are
learning
in
neur
al
networks,
de
ci-
sion
tr
e
es,
genetic
algorithms
and
nally
lo
gic.
The
latter
approac
h
is
no
w
ada
ys
called
Inductiv
e
Logic
Programming
(ILP).
Stephen
Muggleton,
when
in
tro
duc-
ing
the
name
Inductiv
e
Logic
Programming,
dened
this
eld
as
the
in
tersection
of
Mac
hine
Learning
and
Logic
Programming.
Th
us
ILP
studies
learning
from
examples,
within
the
framew
ork
pro
vided
b
y
clausal
logic.
Here
the
examples
and
bac
kground
kno
wledge
are
giv
en
as
clauses,
and
the
theory
that
is
to
b
e
induced
from
these,
is
also
to
consist
of
clauses.
Using
logic
has
some
imp
ortan
t
adv
an
tages
o
v
er
other
approac
hes
used
in
Mac
hine
Learning:

Logic
pro
vides
a
uniform
and
v
ery
expressiv
e
means
of
represen
tation:
the
bac
kground
kno
wledge
and
the
examples,
as
w
ell
as
the
induced
theory
,
can
all
b
e
represen
ted
as
form
ulas
in
a
clausal
language.

Kno
wledge
represen
ted
as
rules
and
facts
o
v
er
certain
predicates
comes
m
uc
h
closer
to
natural
language
than
an
y
of
the
other
approac
hes.
Hence
the
set
of
clauses
that
an
ILP-system
induces
is
m
uc
h
easier
to
in
terpret
for
us
h
umans
than,
for
instance,
a
neural
net
w
ork.

The
use
of
bac
kground
kno
wledge
ts
v
ery
naturally
within
a
logical
ap-
proac
h
to
w
ards
Mac
hine
Learning.


CHAPTER
.
WHA
T
IS
INDUCTIVE
LOGIC
PR
OGRAMMING?
The
remainder
of
this
c
hapter
is
organized
as
follo
ws.
In
the
next
section,
w
e
will
dene
the
problem
setting
of
induction
in
the
precise
terms
of
clausal
logic
and
in
tro
duce
some
terminology
.
In
Section
.
w
e
discuss
some
alternativ
es
to
this
setting.
Section
.
giv
es
a
brief
surv
ey
of
the
history
of
induction
in
general
and
ILP
in
particular.
W
e
end
the
c
hapter
with
an
outline
of
the
rest
of
the
thesis.
.
The
problem
setting
for
ILP
Inductiv
e
Logic
Programming
concerns
learning
a
general
theory
from
giv
en
examples
on
the
predicates
that
w
e
w
an
t
to
learn,
p
ossibly
taking
bac
kground
kno
wledge
in
to
accoun
t.
W
e
can
distinguish
b
et
w
een
t
w
o
kinds
of
examples:
p
ositiv
e
examples,
whic
h
are
true,
and
negativ
e
examples,
whic
h
are
false.
Usu-
ally
,
the
p
ositiv
e
and
negativ
e
examples
are
giv
en
as
sets
E
+
and
E
 ,
resp
ec-
tiv
ely
,
of
gr
ound
atoms.
Ho
w
ev
er,
ground
clauses
are
also
sometimes
used
as
examples,
for
instance
in
a
le
ast
gener
alization-approac
h.
In
fact,
one
migh
t
ev
en
use
non-ground
clauses
as
examples,
though
this
w
ould
b
e
v
ery
un
usual.
In
ILP
,
b
oth
bac
kground
kno
wledge
and
the
induced
theory
are
represen
ted
as
nite
sets
of
clauses.
After
the
learning
is
done,
the
theory
together
with
the
bac
kground
kno
wledge
should
imply
all
giv
en
p
ositiv
e
examples
(this
is
called
c
ompleteness
)
and
should
not
con
tradict
the
giv
en
negativ
e
examples
(c
onsistency
).
Completeness
and
consistency
together
form
c
orr
e
ctness.
Denition
.
Let

b
e
a
nite
set
of
clauses
and
E
+
and
E
 =
fe

;
e

;
:
:
:
g
b
e
sets
of
clauses.

is
c
omplete
w.r.t.
E
+
if

j
=
E
+
.

is
c
onsistent
w.r.t.
E
 if

[
f:e

;
:e

;
:
:
:
g
is
satisable.

is
c
orr
e
ct
w.r.t.
E
+
and
E
 ,
if

is
complete
w.r.t.
E
+
and
consisten
t
w.r.t.
E
 .

It
follo
ws
from
Prop
osition
A.
that
if

implies
one
of
the
clauses
in
E
 ,
then
it
is
not
consisten
t
w.r.t.
E
 .
The
con
v
erse
need
not
hold.
F
or
instance,
let

=
fP
(a)
_
P
(b)g
and
E
 =
fP
(a);
P
(b)g.
Then

do
es
not
imply
an
y
of
the
negativ
e
examples,
but
is
still
not
consisten
t
w.r.t.
E
 .
Ho
w
ev
er,
if
w
e
restrict
the
p
ossible
theories
to
denite
programs
and
the
negativ
e
examples
to
ground
atoms,
then
the
con
v
erse
do
es
hold:
Prop
osition
.
L
et

b
e
a
denite
pr
o
gr
am
and
E
 b
e
a
set
of
gr
ound
atoms.
Then

is
c
onsistent
w.r.t.
E
 i

j
=
e,
for
every
e

E
 .
Pro
of

is
consisten
t
w.r.t.
E
 =
fe

;
e

;
:
:
:
g
i

[
f:e

;
:e

;
:
:
:
g
is
satisable
i
(b
y
Prop
osition
A.)

[
f:e

;
:e

;
:
:
:
g
has
an
Herbrand
mo
del
i
M

do
es
not
con
tain
an
y
e

E
 i
(b
y
Theorem
A.)

j
=
e,
for
ev
ery
e

E
 .

Sev
eral
deviations
from
correctness
are
the
follo
wing:

..
THE
PR
OBLEM
SETTING
F
OR
ILP

Denition
.
Let

b
e
a
nite
set
of
clauses
and
E
+
and
E
 b
e
sets
of
clauses.

is
to
o
str
ong
w.r.t.
E
 ,
if

is
not
consisten
t
w.r.t.
E
 .

is
to
o
we
ak
w.r.t.
E
+
,
if

is
not
complete
w.r.t.
E
+
.

is
overly
gener
al
w.r.t.
E
+
and
E
 ,
if

is
complete
w.r.t.
E
+
but
not
consisten
t
w.r.t.
E
 .

is
overly
sp
e
cic
w.r.t.
E
+
and
E
 ,
if

is
consisten
t
w.r.t.
E
 but
not
complete
w.r.t.
E
+
.

Note
that

is
correct
i
it
is
neither
to
o
strong
nor
to
o
w
eak.
Example
.
Supp
ose
w
e
ha
v
e
E
+
=
fP
(s(0));
P
(s

(0));
P
(s

(0));
P
(s

(0))g,
and
E
 =
fP
(0);
P
(s

(0));
P
(s

(0))g.
Then

=
f(P
(s

(x))
 
P
(x));
P
(s(0))g
is
correct
w.r.t.
E
+
and
E
 .
Note
that

can
b
e
view
ed
as
c
haracterizing
the
o
dd
n
um
b
ers.

0
=
fP
(s

(x))g
is
b
oth
to
o
strong
w.r.t.
E
 and
to
o
w
eak
w.r.t.
E
+
.
It
is
to
o
strong
b
ecause
it
implies
some
negativ
e
examples
and
it
is
to
o
w
eak
b
ecause
it
do
es
not
imply
the
p
ositiv
e
example
P
(s(0)).

00
=
fP
(s(x))g
is
o
v
erly
general
w.r.t.
E
+
and
E
 .
<
No
w
the
learning
problem
for
ILP
can
b
e
formally
dened.
This
problem
setting
sometimes
go
es
under
the
names
of
normal
setting,
or
explanatory
setting
(since
the
theory
should,
in
a
sense,
b
e
an
explanation
of
the
examples).
Inductiv
e
Logic
Programming:
Problem
Setting.
Giv
en:
A
nite
set
of
clauses
B
(b
ackgr
ound
know
le
dge
),
and
sets
of
clauses
E
+
and
E
 (p
ositiv
e
and
negativ
e
examples).
Find:
A
nite
set
of
clauses

(the
ory),
suc
h
that

[
B
is
correct
w.r.t.
E
+
and
E
 .
As
w
e
ha
v
e
emphasized
ab
o
v
e,
E
+
and
E
 are
most
often
restricted
to
ground
atoms.
W
e
ma
y
sometimes
b
e
learning
from
scratc
h.
In
this
case,
no
bac
kground
kno
wledge
is
presen
t,
and
B
(the
empt
y
set)
can
b
e
dropp
ed
from
the
problem
setting.
Note
that
a
solution

do
es
not
alw
a
ys
exist.
The
rst
reason
for
this
is
rather
trivial:
B
[
E
+
ma
y
b
e
inconsisten
t
w.r.t.
the
negativ
e
examples,
for
instance
if
P
(a)
is
b
oth
a
p
ositiv
e
and
a
negativ
e
example
at
the
same
time.
T
o
solv
e
this,
w
e
ha
v
e
to
require
that
B
[
E
+
is
consisten
t
w.r.t.
E
 .
The
second
reason
for
the
non-existence
of
a
solution
is
more
profound.
Note
that
our
problem
setting
allo
ws
innite
sets
of
examples.
One
instance
of
this
is
Shapiro's
setting
for
mo
del
inference
[Shab].
Here
the
examples
are
giv
en
in
an
enumer
ation,
whic
h
ma
y
b
e
innite.
Allo
wing
an
innite
n
um
b
er
of
examples
implies,
roughly
,
that
there
are
\more"
p
ossible
sets
of
examples
than
there
are
theories.
Hence
a
correct
theory
do
es
not
alw
a
ys
exist,
ev
en
when
the
examples
can
only
b
e
ground
atoms
and
bac
kground
kno
wledge
is
not
used,
as
pro
v
ed
in
the
next
theorem.
The
pro
of
of
this
theorem
emplo
ys
t
w
o
dieren
t
\kinds
of
innit
y".
The
rst
kind
concerns
sets
con
taining
the
same
n
um
b
er
of
elemen
ts
as
the
set
of
natural
n
um
b
ers.
Suc
h
sets
are
called
enumer
ably
innite.
The
second
kind
of
innite
set
is
called
unc
ountable.
An
example
of
an
uncoun
table
set
is
the
set
of


CHAPTER
.
WHA
T
IS
INDUCTIVE
LOGIC
PR
OGRAMMING?
real
n
um
b
ers.
It
is
w
ell-kno
wn
that
the
p
ower
set
of
an
en
umerably
innite
set
S
(the
set
of
all
subsets
of
S
)
is
uncoun
table
and
that
the
latter
is
\larger"
than
the
former.
A
more
extensiv
e
in
tro
duction
in
to
these
matters
can
b
e
found
in
man
y
mathematics
b
o
oks,
for
instance
[BJ	
].
Theorem
.
Ther
e
exist
sets
E
+
and
E
 of
gr
ound
atoms,
such
that
ther
e
is
no
nite
set
of
clauses
which
is
c
orr
e
ct
w.r.t.
E
+
and
E
 .
Pro
of
Consider
a
clausal
language
C
con
taining
(p
ossibly
among
others)
a
function
sym
b
ol
of
arit
y


and
a
constan
t
a.
Let
A
b
e
the
set
of
ground
atoms
in
C
.
If

is
some
nite
set
of
clauses,
let
A

=
fA

A
j

j
=
Ag.
The
n
um
b
er
of
clauses
in
C
is
en
umerably
innite.
Then
b
ecause
a
theory
is
a
nite
set
of
clauses,
the
n
um
b
er
of
theories
is
also
en
umerably
innite.
Th
us
the
n
um
b
er
of
dieren
t
A

's
induced
b
y
all
p
ossible
theories,
is
also
only
en
umerably
innite.
The
p
o
w
er
set
of
A
is
uncoun
table.
Since
an
uncoun
table
set
is
m
uc
h
larger
than
an
en
umerably
innite
one,
there
m
ust
b
e
a
set
E
+

A,
suc
h
that
there
is
no
nite

for
whic
h
A

=
E
+
.
Dene
E
 =
AnE
+
.
No
w
for
a
theory

to
b
e
correct
w.r.t.
E
+
and
E
 ,
w
e
m
ust
ha
v
e
A

=
E
+
.
Hence
there
is
no
suc
h
.

If
E
+
is
nite,
then

=
E
+
will
b
e
a
correct
theory
,
but
a
rather
unin
terest-
ing
one.
In
this
case,
w
e
w
ould
not
ha
v
e
learned
an
ything
b
ey
ond
the
giv
en
examples:
the
induced
theory
has
no
predictiv
e
p
o
w
er.
T
o
a
v
oid
this,
w
e
can
put
some
constrain
ts
on
the
theory
.
F
or
instance,
w
e
migh
t
demand
that

con
tains
less
clauses
than
the
n
um
b
er
of
giv
en
p
ositiv
e
examples.
In
that
case,

=
E
+
is
ruled
out.
Since
constrain
ts
lik
e
these
mainly
dep
end
on
the
partic-
ular
application
at
hand,
w
e
will
not
dev
ote
m
uc
h
atten
tion
to
them.
An
yho
w,
if
one
or
more
correct
theories
do
exist,
then
they
are
\hidden"
somewhere
in
the
set
of
clauses
in
the
language
w
e
use.
Accordingly
,
nding
a
satisfactory
theory
means
that
w
e
ha
v
e
to
se
ar
ch
among
the
a
v
ailable
clauses:
learning
is
searc
hing
for
a
correct
theory
[Mit
].
Hence
the
set
of
a
v
ailable
clauses
is
called
the
se
ar
ch
sp
ac
e.
The
t
w
o
basic
steps
in
the
searc
h
for
a
correct
theory
are
sp
e
cialization
and
gener
alization.
If
the
curren
t
theory
(together
with
the
bac
kground
kno
wledge)
is
to
o
strong,
it
needs
to
b
e
w
eak
ened.
That
is,
w
e
need
to
nd
a
more
sp
ecic
theory
,
suc
h
that
the
new
theory
and
the
bac
kground
kno
wledge
are
consis-
ten
t
w.r.t.
the
negativ
e
examples.
This
is
called
sp
ecialization.
On
the
other
hand,
if
the
curren
t
theory
do
es
not
imply
all
p
ositiv
e
examples,
it
needs
to
b
e
strengthened:
w
e
need
to
nd
a
more
general
theory
whic
h
(together
with
the
bac
kground
kno
wledge)
can
imply
all
p
ositiv
e
examples.
This
is
generalization.
Note
that
a
theory
ma
y
b
e
b
oth
to
o
strong
and
to
o
w
eak
at
the
same
time,
witness

0
in
Example
..
In
this
case,
b
oth
sp
ecialization
and
generalization
are
called
for.
In
general,
nding
a
correct
theory
means
rep
eatedly
adjusting
the
theory
to
the
examples
with
these
t
w
o
tec
hnique
(sp
ecialization
and
gener-
alization).
Whether
a
particular
theory
is
to
o
w
eak
or
to
o
strong,
can
b
e
tested
using
one
of
the
pro
of
pro
cedures
w
e
will
in
tro
duce
in
the
next
c
hapter.

..
THE
PR
OBLEM
SETTING
F
OR
ILP

In
general,
most
ILP-systems
conform
roughly
to
the
follo
wing
sc
heme:
Input:
B
,
E
+
and
E
 .
Output:
A
theory
,
suc
h
that

[
B
is
correct
w.r.t.
E
+
and
E
 .
Start
with
some
initial
(p
ossibly
empt
y

)
theory
.
Rep
eat
.
If

[
B
is
to
o
strong,
sp
ecialize
.
.
If

[
B
is
to
o
w
eak,
generalize
.
un
til

[
B
is
correct
w.r.t.
E
+
and
E
 .
Output
.
Th
us
the
main
op
erations
an
ILP-system
should
p
erform,
are
sp
ecialization
and
generalization.
The
follo
wing
c
hapters
can
b
e
considered
as
an
in
v
estigation
in
to
a
n
um
b
er
of
dieren
t
approac
hes
to
w
ards
sp
ecialization
and
generalization,
whic
h
can
b
e
used
when
searc
hing
for
a
correct
theory
.
W
e
will
no
w
in
tro
duce
some
terminology
often
used
in
ILP:
T
op-do
wn
and
b
ottom-up
One
useful
distinction
among
ILP-systems
concerns
the
direction
in
whic
h
a
system
searc
hes.
First,
there
is
the
top-down
approac
h,
whic
h
starts
with
a

suc
h
that

[
B
is
o
v
erly
general,
and
sp
ecializes
this.
Secondly
,
there
is
the
b
ottom-up
approac
h
whic
h
starts
with
a

suc
h
that

[
B
is
o
v
erly
sp
ecic,
and
generalizes
this.
Admittedly
,
a
top-do
wn
system
ma
y
sometimes
lo
cally
adapt
itself
to
the
examples
b
y
a
generalization
step.
Suc
h
a
generalization
step
ma
y
b
e
needed
to
correct
a
(large)
earlier
sp
ecialization
step,
whic
h
made
the
theory
to
o
w
eak.
After
the
correction,
the
system
con
tin
ues
its
general
top-do
wn
searc
h.
Analogously
,
a
b
ottom-up
system
ma
y
sometimes
mak
e
a
sp
ecialization
step.
Nev
ertheless,
a
system
can
usually
b
e
classied
in
a
natural
w
a
y
as
top-do
wn
or
b
ottom-up,
dep
ending
on
the
general
direction
of
its
searc
h.
Example
.
Consider
the
sets
E
+
and
E
 of
Example
..
Assume
the
bac
kground
kno
wledge
is
empt
y
.
A
top-do
wn
approac
h
ma
y
tak
e
the
follo
wing
steps
to
reac
h
a
correct
theory
.
.
Start
with

=
fP
(x)g.
.
This
is
clearly
o
v
erly
general,
since
it
implies
all
negativ
e
examples.
Sp
e-
cialize
it
to

=
fP
(s(x));
P
(0)g.
.

is
still
to
o
general,
for
instance,
it
implies
P
(0)

E
 .
Sp
ecialize
it
to

=
fP
(s

(x));
P
(s(0))g.
.
No
w

no
longer
implies
P
(0),
but
it
is
still
o
v
erly
general.
When
w
e
sp
ecialize
further
to

=
f(P
(s

(x))
 
P
(x));
P
(s(0))g,
w
e
end
up
with
a
theory
that
is
correct
w.r.t.
E
+
and
E
 .
<

If
w
e
start
with
a
non-empt
y
theory
,
the
learning
task
is
sometimes
called
the
ory
r
evision.


CHAPTER
.
WHA
T
IS
INDUCTIVE
LOGIC
PR
OGRAMMING?
Single-
and
m
ultiple-predicate
learning
W
e
can
also
distinguish
b
et
w
een
single-pr
e
dic
ate
le
arning
and
multiple-pr
e
dic
ate
le
arning.
In
the
former
case,
all
giv
en
examples
are
instances
of
only
one
pred-
icate
P
and
the
aim
of
the
learning
task
is
to
nd
a
set
of
clauses
whic
h
implies
P
(x

;
:
:
:
;
x
n
)
just
for
those
tuples
hx

;
:
:
:
;
x
n
i
whose
denotation
\b
elongs"
to
the
concept
denoted
b
y
P
.
In
other
w
ords,
the
set
of
clauses
should
\recognize"
the
instances
of
P
.
In
m
ultiple-predicate
learning,
the
examples
are
instances
of
more
than
one
predicate.
Note
that
m
ultiple-predicate
learning
cannot
alw
a
ys
b
e
split
in
to
sev
eral
single-predicate
problems,
b
ecause
the
dieren
t
predicates
in
a
m
ultiple-
predicate
learning
task
ma
y
b
e
related.
Batc
h
learning
and
incremen
tal
learning
The
distinction
b
et
w
een
b
atch
le
arning
and
incr
emental
le
arning
concerns
the
w
a
y
the
examples
are
giv
en.
In
batc
h
learning,
w
e
are
giv
en
all
examples
E
+
and
E
 righ
t
at
the
outset.
This
has
the
adv
an
tage
that
noise
(errors
in
the
giv
en
examples)
can
b
e
measured
and
dealt
with
b
y
applying
statistical
tec
h-
niques
to
the
set
of
all
examples
[LD	
].
Since
the
treatmen
t
of
noise
is
usually
application-dep
enden
t,
w
e
will
not
giv
e
m
uc
h
atten
tion
to
noisy
examples
in
this
thesis.
On
the
other
hand,
in
incremen
tal
learning
the
examples
are
giv
en
one
b
y
one,
and
the
system
eac
h
time
adjusts
its
theory
to
the
examples
giv
en
so
far,
b
efore
obtaining
the
next
example.
In
teractiv
e
and
non-in
teractiv
e
Inter
active
systems
can
in
teract
with
their
user
in
order
to
obtain
some
ex-
tra
information.
F
or
instance,
they
can
ask
the
user
whether
some
particular
ground
atom
is
true
or
not.
In
this
w
a
y
,
an
in
teractiv
e
system
generates
some
of
its
o
wn
examples
during
the
searc
h.
A
non-in
teractiv
e
system
do
es
not
ha
v
e
the
p
ossibilit
y
to
in
teract
with
the
user.
Bias
Bias
concerns
an
ything
whic
h
constrains
the
searc
h
for
theories
[UM
].
W
e
can
distinguish
t
w
o
kinds
of
bias:
language
bias
and
se
ar
ch
bias.
L
anguage
bias
has
to
do
with
constrain
ts
on
the
clauses
in
the
searc
h
space.
These
ma
y
for
instance
b
e
a
restriction
to
Horn
clauses,
to
clauses
without
function
sym
b
ols
and
constan
ts,
to
clauses
with
at
most
n
literals,
etc.
The
more
restrictions
w
e
put
on
clauses,
the
smaller
the
searc
h
space,
and
hence
the
faster
a
system
will
nish
its
searc
h.
On
the
other
hand,
restrictions
on
the
a
v
ailable
clauses
ma
y
cause
man
y
go
o
d
theories
to
b
e
o
v
erlo
ok
ed.
F
or
example,
w
e
ma
y
restrict
the
searc
h
space
to
clauses
of
at
most

literals,
but
if
the
only
correct
theory
con
tains
clauses
of

or
more
literals,
no
solution
will
b
e
found.
Th
us
there
is
in
general
a
tr
ade-o
b
et
w
een
the
eciency
of
an
ILP-system
and
the
qualit
y
of
the
theory
it
comes
up
with.
One
imp
ortan
t
matter
concerning
language
bias,
is
the
capabilit
y
of
a
sys-
tem
to
in
tro
duce
new
predicates
when
needed.
A
restriction
of
the
language
to
the
predicates
already
in
use
in
the
bac
kground
theory
and
the
examples

..
OTHER
PR
OBLEM
SETTINGS
	
ma
y
sometimes
b
e
to
o
strict.
In
that
case
pr
e
dic
ate
invention
(the
automatic
in
tro
duction
of
new
useful
predicates)
is
called
for.
F
or
example,
if
w
e
are
learning
ab
out
family
relations
and
neither
the
examples
nor
the
bac
kground
kno
wledge
con
tain
a
predicate
for
p
ar
entho
o
d,
it
w
ould
b
e
nice
if
the
system
could
in
tro
duce
suc
h
a
useful
predicate
itself.
Se
ar
ch
bias
has
to
do
with
the
w
a
y
a
system
searc
hes
its
space
of
a
v
ailable
clauses.
One
extreme
is
exhaustiv
e
searc
h,
whic
h
searc
hes
the
searc
h
space
completely
.
Ho
w
ev
er,
usually
exhaustiv
e
searc
h
w
ould
tak
e
far
to
o
m
uc
h
time,
so
the
searc
h
has
to
b
e
guided
b
y
certain
heuristics.
These
indicate
whic
h
parts
of
the
space
are
searc
hed
and
whic
h
are
ignored.
Again,
this
ma
y
cause
the
system
to
o
v
erlo
ok
some
go
o
d
theories.
So
here
w
e
see
another
trade-o
b
et
w
een
eciency
and
the
qualit
y
of
the
nal
theory
.
If
a
system
has
found
that
a
correct
theory
is
not
a
v
ailable
using
its
presen
t
language
and
searc
h
bias,
it
can
try
again
using
a
more
general
language
and/or
a
more
thorough
searc
h
pro
cedure.
This
is
called
shifting
the
bias.
.
Other
problem
settings
The
normal
problem
setting
that
w
e
in
tro
duced
ab
o
v
e,
is
used
in
some
form
or
other
b
y
the
ma
jorit
y
of
ILP-researc
hers.
Ho
w
ev
er,
in
recen
t
y
ears
a
family
of
other
problem
settings
has
app
eared.
These
settings
ha
v
e
in
common
that
the
induced
theory
should
no
longer
imply
the
p
ositiv
e
examples,
but
should
b
e
a
general
relation
that
is
true
for
the
examples.
Examples
are
Helft's
non-
monotonic
setting
for
induction
[Hel	
,
DRD	
],
Flac
h's
we
ak
induction
[Fla	
]
and
c
onrmatory
induction
[Fla	
,
Fla	
].
These
settings
are
w
ell-suited
for
the
problem
of
data-mining
or
know
le
dge
disc
overy
:
giv
en
a
large
amoun
t
of
data
(usually
only
p
ositiv
e
examples),
nd
\in
teresting"
regularities
among
the
data.
Ho
w
ev
er,
since
as
y
et
there
is
not
m
uc
h
consensus
in
ILP
on
one
particular
setting
for
this
problem,
w
e
restrict
ourselv
es
to
the
\normal"
problem
setting
dened
in
the
previous
section.
Nev
ertheless,
sp
ecialization
and
generalization
of
clausal
theories
are
the
main
op
erations
not
only
for
our
setting,
but
also
within
the
alternativ
e
settings.
Hence
the
tec
hniques
of
the
next
c
hapters
are
applicable
within
those
alternativ
e
settings
as
w
ell.
Apart
from
comparing
our
setting
with
alternativ
e
settings
used
within
ILP
,
w
e
can
also
compare
it
with
problem
settings
outside
of
ILP
.
One
of
these
is
the
problem
of
ab
duction,
rst
in
tro
duced
b
y
the
philosopher
Charles
Sanders
P
eirce
[P
ei
].
The
logical
form
of
ab
duction
is
roughly
the
same
as
for
induc-
tion
[DK	
,
KKT	].
Both
pro
ceed
from
giv
en
examples
and
some
bac
kground
kno
wledge.
Ho
w
ev
er,
the
theory
that
ab
duction
pro
duces
should
b
e
a
p
articu-
lar
fact
(often
represen
table
as
one
or
more
ground
atoms)
that
together
with
the
bac
kground
kno
wledge
explains
the
examples,
whereas
induction
should
pro
duce
a
gener
al
the
ory.
F
or
example,
supp
ose
y
ou
are
Robinson
Cruso
e
on
his
island
and
y
ou
see
a
strange
h
uman
fo
otprin
t
in
the
sand.
Since
y
ou
kno
w
that
h
uman
fo
otprin
ts
are
pro
duced
b
y
h
uman
b
eings
and
the
fo
otprin
t
is
not
y
our
o
wn,
y
ou
can
conclude
on
the
basis
of
y
our
bac
kground
kno
wledge
that
someone
else
has
visited
y
our

0
CHAPTER
.
WHA
T
IS
INDUCTIVE
LOGIC
PR
OGRAMMING?
island.
Inferring
this
particular
explanation
of
the
example
(the
presence
of
the
fo
otprin
t)
is
a
case
of
ab
duction.
.
A
brief
history
of
the
eld
Lik
e
most
other
scien
tic
disciplines,
the
study
of
induction
started
out
as
a
part
of
philosoph
y
.
Philosophers
particularly
fo
cused
on
the
role
induction
pla
ys
in
the
empirical
sciences.
F
or
instance,
the
ancien
t
Greek
philosopher
Aristotle
c
haracterized
science
roughly
as
deduction
from
rst
principles,
whic
h
w
ere
to
b
e
obtained
b
y
induction
from
exp
erience
[Ari0
].
After
the
Middle
Ages,
the
philosopher
F
rancis
Bacon
[Bac0
]
again
stressed
the
imp
ortance
of
induction
from
exp
erience
as
the
main
scien
tic
activit
y
.
In
later
cen
turies,
induction
w
as
tak
en
up
b
y
man
y
philosophers.
Da
vid
Hume
[Hum
,
Hum]
form
ulated
what
is
no
w
ada
ys
called
the
`problem
of
induction',
or
`Hume's
problem':
ho
w
can
induction
from
a
nite
n
um
b
er
of
cases
result
in
kno
wledge
ab
out
the
innit
y
of
cases
to
whic
h
an
induced
general
rule
applies?
What
justies
inferring
a
general
rule
(or
\la
w
of
nature")
from
a
nite
n
um
b
er
of
cases?
Surprisingly
,
Hume's
answ
er
w
as
that
there
is
no
suc
h
justication.
In
his
view,
it
is
simply
a
psyc
hological
fact
ab
out
h
umans
b
eings
that
when
w
e
observ
e
some
particular
pattern
recur
in
dieren
t
cases
(without
observing
coun
terexamples
to
the
pattern),
w
e
tend
to
exp
ect
this
pattern
to
app
ear
in
all
similar
cases.
In
Hume's
view,
this
inductiv
e
exp
ectation
is
a
habit,
analogous
to
the
habit
of
a
dog
who
runs
to
the
do
or
after
hearing
his
master
call,
exp
ecting
to
b
e
let
out.
Later
philosphers
suc
h
as
John
Stuart
Mill
[Mil]
tried
to
answ
er
Hume's
problem
b
y
stating
conditions
under
whic
h
an
inductiv
e
inference
is
justied.
Other
philosophers
who
made
imp
ortan
t
commen
ts
on
induction
w
ere
Stanley
Jev
ons
[Jev
]
and
Charles
Sanders
P
eirce
[P
ei
].
In
our
cen
tury
,
induction
w
as
mainly
discussed
b
y
philosophers
and
mathe-
maticians
who
w
ere
also
in
v
olv
ed
in
the
dev
elopmen
t
and
application
of
formal
logic.
Their
treatmen
t
of
induction
w
as
often
in
terms
of
the
probabilit
y
or
the
\degree
of
conrmation"
that
a
particular
theory
or
h
yp
othesis
receiv
es
from
a
v
ailable
empirical
data.
Some
of
the
main
con
tributors
are
Bertrand
Russell
[Rus0,
Rus
],
Rudolf
Carnap
[Car
,
Car0
],
Carl
Hemp
el
[Hema
,
Hemb
,
Hem
],
Hans
Reic
hen
bac
h
[Rei	
],
and
Nelson
Go
o
dman
[Go
o
].
P
articularly
in
Go
o
dman's
w
ork,
an
increasing
n
um
b
er
of
unexp
ected
concep-
tual
problems
app
eared
for
induction.
In
the
	0s
and
	0s,
induction
w
as
sw
orn
o
b
y
philosophers
of
sci-
ence
suc
h
as
Karl
P
opp
er
[P
op	
].

Ho
w
ev
er,
in
roughly
those
same
y
ears,
it
w
as
recognised
in
the
rapidly
expanding
eld
of
Articial
In
telligence
that
the
kno
wledge
an
AI-system
needs
to
p
erform
its
tasks,
should
not
all
b
e
hand-
co
ded
in
to
the
system
b
eforehand.
Instead,
it
is
m
uc
h
more
ecien
t
to
pro
vide
the
system
with
a
relativ
ely
small
amoun
t
of
kno
wledge
and
with
the
abilit
y
to

In
terestingly
enough,
Thomas
Kuhn,
P
opp
ers
an
tip
o
de
in
the
philosoph
y
of
science,
later
b
ecame
in
v
olv
ed
in
computer
mo
dels
of
(inductiv
e)
concept
learning
from
examples.
See
pp.
{
of
[Kuh].

..
A
BRIEF
HISTOR
Y
OF
THE
FIELD

adapt
itself
to
the
situations
it
encoun
ters|to
le
arn
from
its
exp
erience.
Th
us
the
study
of
induction
switc
hed
from
philosoph
y
to
Articial
In
telligence.
Clause
Samm
ut
[Sam	
]
starts
his
article
on
the
history
of
ILP
with
the
w
ork
of
Bruner,
Go
o
dno
w
and
Austin
[BGA
]
in
cognitiv
e
psyc
hology
.
They
analyzed
the
w
a
y
h
uman
b
eings
learn
concepts
from
p
ositiv
e
and
negativ
e
in-
stances
(examples)
of
that
concept.
In
the
early
	0s,
Banerji
[Ban
]
used
rst-order
logic
as
a
represen
tational
to
ol
for
suc
h
concept
learning.
Around
	0,
Gordon
Plotkin
[Plo0
,
Plob,
Ploa
]
w
as
probably
the
rst
to
formalize
induction
in
terms
of
clausal
logic.
His
idea
w
as
to
generalize
giv
en
ground
clauses
(p
ositiv
e
examples)
b
y
computing
their
le
ast
gener
alization.
This
generalization
could
b
e
relativ
e
to
bac
kground
kno
wledge
consisting
of
ground
literals.
Plotkin's
w
ork,
whic
h
is
related
to
that
of
John
Reynolds
[Rey0
],
is
still
quite
prominen
t
within
ILP
.
Clauses
are
still
used
b
y
virtually
ev
ery-
one
for
expressing
theory
,
examples
and
bac
kground
kno
wledge,
and
Plotkin's
use
of
subsumption
as
a
notion
of
generalit
y
is
also
widespread.
During
the
	0s,
Plotkin's
w
ork
w
as
con
tin
ued
b
y
Stev
en
V
ere
[V
er
,
V
er
],
while
Brian
Cohen's
incremen
tal
system
Confucius
w
as
inspired
b
y
Banerji.
In
the
early
	0s,
Samm
ut's
Mar
vin
[Sam
,
SB
]
w
as
a
direct
descen-
dan
t
of
Confucius.
Mar
vin
is
an
in
teractiv
e
concept
learner,
whic
h
em-
plo
ys
b
oth
generalization
and
sp
ecialization.
A
t
around
the
same
time,
Eh
ud
Shapiro
[Shab,
Shaa
]
dened
his
setting
for
mo
del
infer
enc
e
and
con
tructed
his
mo
del
inference
algorithm.
This
is
a
top-do
wn
algorithm
aimed
at
nding
c
omplete
axiomatizations
of
giv
en
examples.
Shapiro's
w
ork
con
tains
man
y
seminal
ideas,
in
particular
the
use
of
the
Backtr
acing
A
lgorithm
for
nding
false
clauses
in
the
theory
,
and
the
concept
of
a
r
enement
op
er
ator,
used
for
sp
ecializing
a
theory
.
Shapiro
implemen
ted
his
algorithm,
though
only
for
Horn
clauses,
in
his
mo
del
inference
system
Mis.
He
later
incorp
orated
this
w
ork
in
his
PhD
thesis
[Sha],
as
part
of
a
system
for
debugging
denite
programs.
Then
in
the
second
half
of
the
	0s|no
doubt
partly
as
a
consequence
of
the
increasing
p
opularit
y
of
Logic
Programming
and
Pr
olog|researc
h
con-
cerning
mac
hine
learning
within
a
clausal
framew
ork
increased
rapidly
.
W
ra
y
Bun
tine
[Bun,
Bun]
generalized
subsumption,
in
order
to
o
v
ercome
some
of
its
limitations.
Stephen
Muggleton
built
his
system
Duce
[Mug
],
aimed
at
generalizing
giv
en
pr
op
ositional
clauses.
It
b
ecame
clear
that
Duce's
general-
ization
op
erators
could
b
e
seen
as
in
v
ersions
of
resolution
steps.
Th
us
in
[MB
]
Muggleton,
together
with
Bun
tine,
in
tro
duced
inverse
r
esolution.
They
imple-
men
ted
in
v
erse
resolution,
b
oth
as
an
op
erator
for
making
generalization
steps
and
as
a
to
ol
for
predicate
in
v
en
tion
in
Cigol
(`logic'
bac
kw
ards).
In
the
next
y
ears,
in
v
erse
resolution
drew
a
lot
of
atten
tion
and
spark
ed
o
m
uc
h
new
researc
h.
Some
early
alternativ
es
to
in
v
erse
resolution
w
ere
implemen
ted
in
F
oil,
Linus
and
Golem.
F
oil
[Qui	0,
QCJ	]
is
based
on
a
do
wn
w
ard
renemen
t
op
erator
guided
b
y
information-based
searc
h
heuristics,
in
whic
h
J.
R.
Quinlan
generalized
his
earlier
w
ork
on
decision
trees
[Qui
]
to
Horn
clauses.
Linus
w
as
dev
elop
ed
b
y
Nada
La
vra

c
and
Sa

so
D

zeroski
[LDG	
,
LD	
].
It
solv
es
ILP-
problems
b
y
transforming
them
to
a
simpler
attribute-value
form,
represen
ted
as
a
set
of
ob
jects
with
certain
prop
erties,
and
then
applying
one
of
sev
eral


CHAPTER
.
WHA
T
IS
INDUCTIVE
LOGIC
PR
OGRAMMING?
p
ossible
attribute-v
alue
learners
to
learn
a
general
theory
from
this
simpler
form.
See
[LD	a
,
LD	b
,
LD	
]
for
a
detailed
comparison
of
F
oil
and
Linus.
Muggleton
and
F
eng's
Golem
[MF	
]
is
in
a
w
a
y
a
return
to
Plotkin:
it
is
based
on
Plotkin's
relativ
e
least
generalization,
though
with
additional
restrictions
for
the
sak
e
of
eciency
.
In
		0,
Stephen
Muggleton
rst
in
tro
duced
the
name
Inductiv
e
Logic
Pro-
gramming,
and
dened
this
eld
as
the
in
tersection
of
Mac
hine
Learning
and
Logic
Programming
[Mug	0
,
Mug	
].
In
the
next
y
ear
he
organized,
together
with
P
a
v
el
Brazdil,
the
rst
In
ternational
W
orkshop
on
Inductiv
e
Logic
Pro-
gramming,
bringing
together
for
the
rst
time
a
n
um
b
er
of
researc
hers
in
v
olv
ed
in
learning
from
examples
in
a
clausal
framew
ork.
Since
		
these
In
ternational
W
orkshops
ha
v
e
b
een
rep
eated
ev
ery
y
ear,
establishing
ILP
as
a
ourishing
eld
of
inquiry
.
.
An
outline
of
the
thesis
In
this
section,
w
e
will
giv
e
an
outline
of
the
remainder
of
the
thesis.
Three
topics
are
of
particular
concern
in
ILP:
deduction,
sp
ecialization,
and
general-
ization.
Eac
h
of
these
will
b
e
addressed
in
later
c
hapters.
De
duction
allo
ws
us
to
nd
out
whether
the
curren
t
theory
is
correct
(com-
plete
and
consisten
t)
w.r.t.
the
examples.
This
is
clearly
imp
ortan
t,
since
it
determines
the
direction
in
whic
h
the
theory
has
to
b
e
adapted:
if
the
theory
is
not
complete,
it
has
to
b
e
strengthened;
if
the
theory
is
not
consisten
t,
it
has
to
b
e
w
eak
ened.
In
the
next
c
hapter
w
e
will
in
v
estigate
four
dieren
t
deductiv
e
pro
cedures,
eac
h
based
on
the
r
esolution
principle.
F
or
\unconstrained"
resolu-
tion,
linear
resolution
and
SLD-resolution,
w
e
will
pro
v
e
a
ma
jor
completeness
result,
called
the
Subsumption
The
or
em.
Moreo
v
er,
w
e
will
sho
w
that
this
the-
orem
is
equiv
alen
t
to
the
r
efutation-c
ompleteness,
for
eac
h
of
these
kinds
of
resolution.
On
the
other
hand,
w
e
will
also
sho
w
that
b
oth
of
these
complete-
ness
results
do
not
hold
for
input
resolution.
Sp
e
cialization
can
b
e
used
to
w
eak
en
a
theory
.
In
Chapter

w
e
in
v
esti-
gate
the
use
of
unfolding
as
a
sp
ecialization
to
ol.
W
e
dene
three
increas-
ingly
strong
sp
ecialization
metho
ds,
UD

-sp
ecialization,
UD

-sp
ecialization
and
UDS-sp
ecialization,
based
on
unfolding,
clause
deletion
and
subsumption.
The
latter
is
a
complete
sp
ecialization
tec
hnique
for
denite
programs,
while
the
rst
t
w
o
are
not.
Finally
,
in
Chapter

w
e
discuss
le
ast
gener
alizations
and
gr
e
atest
sp
e
cial-
izations
of
sets
of
clauses.
These
can
resp
ectiv
ely
b
e
used
to
strengthen
and
w
eak
en
a
theory
.
Usually
,
least
generalizations
are
only
considered
under
the
subsumption
order.
W
e
extend
it
here
to
the
lo
gic
al
implic
ation
order,
whic
h
is
more
p
o
w
erful
than
subsumption.
It
is
in
teresting
to
note
that
the
pro
ofs
of
b
oth
the
completeness
result
giv
en
in
Chapter
,
as
w
ell
as
the
main
new
result
of
Chapter

(the
existence
of
a
least
generalization
under
implication
in
the
presence
of
a
function-free
clause),
dep
end
on
the
Subsumption
Theorem(s)
of
Chapter
.
This
giv
es
a
kind
of
unit
y
and
coherence
to
the
thesis.

Chapter

The
Subsumption
Theorem
for
Sev
eral
F
orms
of
Resolution
.
In
tro
duction
The
Subsumption
The
or
em
is
the
follo
wing
statemen
t:
If

is
a
set
of
clauses
and
C
is
a
clause,
then

logically
implies
C
(
j
=
C
)
i
C
is
a
tautology
,
or
there
exists
a
clause
D
whic
h
subsumes
C
and
whic
h
can
b
e
deriv
ed
from

b
y
some
form
of
resolution.
Dieren
t
v
ersions
of
the
theorem
exist,
dep
ending
on
the
instan
tiation
of
\some
form
of
resolution."
W
e
could
allo
w
arbitrary
binary
trees
of
resolution
steps
(\unconstrained
resolution")
as
deriv
ation,
or
w
e
could
allo
w
only
linear
deriv
a-
tions,
etc.
This
is
similar
to
the
r
efutation-c
ompleteness
for
pro
of
b
y
con
tradic-
tion:
here
w
e
ha
v
e
the
refutation-completeness
of
unconstrained
resolution,
the
refutation-completeness
of
linear
resolution,
etc.
The
refutation-completeness
is
a
form
of
completeness
that
is
m
uc
h
b
et-
ter
kno
wn
than
the
Subsumption
Theorem.
It
states
that
a
set
of
clauses
is
unsatisable
i
the
set
has
a
refutation
(a
deriv
ation
of
the
empt
y
clause
,
whic
h
represen
ts
a
con
tradiction).
It
can
b
e
used
to
pro
v
e
an
y
case
of
logi-
cal
implication
b
et
w
een
clauses.
F
or
if
w
e
ha
v
e
a
set
,
a
clause
C
,

is
a
Sk
olem
substitution
for
C
w.r.t.

and
C

=
L

_
:
:
:
_
L
n
,
then

j
=
C
i

[
f:L

;
:
:
:
;
:L
n
g
is
unsatisable
i

[
f:L

;
:
:
:
;
:L
n
g
has
a
refutation.
Ho
w
ev
er,
the
Subsumption
Theorem
is
a
more
\direct"
form
of
complete-
ness
than
the
refutation-completeness.
By
the
Subsumption
Theorem,
w
e
can
straigh
tforw
ardly
pro
v
e
C
from

b
y
taking
a
n
um
b
er
of
resolution
steps
start-
ing
from
clauses
in
,
and
then
taking
a
subsumption
step
leading
to
C
.
There
is
no
need
to
use
the
detour
whic
h
rst
negates
C
and
then
applies
pro
of
b
y
refutation.
In
a
deriv
ation
of
a
clause
whic
h
subsumes
C
,
the
relation
b
et
w
een
on
one
hand
the
premises
in

and
on
the
other
hand
the
conclusion
C
,
is
m
uc
h



THE
SUBSUMPTION
THEOREM
easier
to
see
than
in
a
pro
of
b
y
refutation.
Accordingly
,
the
Subsumption
The-
orem
giv
es
us
a
more
clear
view
of
the
structure
of
logical
implication
than
the
refutation-completeness.
F
or
this
reason,
the
Subsumption
Theorem
is
some-
times
a
more
con
v
enien
t
result
than
the
refutation-completeness,
p
erhaps
not
for
ecien
t
deduction,
but
certainly
for
theoretical
analysis.
Examples
of
suc
h
theoretical
analysis
are
the
v
arious
w
a
ys
the
theorem
is
applied
in
Inductiv
e
Logic
Programming.
The
use
of
subsumption
is
v
ery
p
opular
in
ILP
,
since
it
is
decidable
and
mac
hine-implemen
table.
Ho
w
ev
er,
subsumption
is
w
eak
er
than
implication:
if
C
subsumes
D
then
C
j
=
D
,
but
not
alw
a
ys
the
other
w
a
y
around,
tak
e
for
instance
C
=
P
(f
(x))
 
P
(x)
and
D
=
P
(f

(x))
 
P
(x).
So
it
is
desirable
to
mak
e
the
step
from
subsumption
to
implication,
and
the
Subsumption
Theorem
pro
vides
an
excellen
t
\bridge"
for
those
who
w
an
t
to
mak
e
this
step,
since
it
states
that
implication
=
resolution
+
subsumption.
It
is
used
for
instance
in
[Mug	c
,
IA	
,
IA	
,
LNC	b,
LNC	a
].
The
theorem
is
also
an
essen
tial
ingredien
t
in
the
pro
ofs
of
the
main
results
in
later
c
hapters
of
the
presen
t
thesis.
It
is
rather
doubtful
whether
w
e
w
ould
ha
v
e
found
those
same
results
if
w
e
only
had
the
refutation-completeness
at
our
disp
osal,
but
not
the
Subsumption
Theorem.
As
our
surv
ey
later
on
in
this
section
will
sho
w,
in
automated
theorem
pro
ving
the
Subsumption
Theorem
receiv
ed
most
atten
tion
around
	0.
In
ILP
,
the
Subsumption
Theorem
w
as
rst
redisco
v
ered
b
y
Bain
and
Muggle-
ton
[BM	
].

A
pro
of
of
the
Subsumption
Theorem
for
unconstrained
resolu-
tion,
based
on
the
refutation-completeness,
is
giv
en
in
the
app
endix
of
[BM	
].
Ho
w
ev
er,
this
pro
of
seems
not
fully
correct.
F
or
example,
it
do
es
not
tak
e
factors
in
to
accoun
t,
whereas
factors
are
necessary
for
completeness.
With-
out
factors
one
cannot
deriv
e
the
empt
y
clause

from
the
unsatisable
set
f(P
(x)
_
P
(y
));
(:P
(u)
_
:P
(v
))g
(see
[GN
]).
F
urthermore,
it
is
not
alw
a
ys
clear
ho
w
the
concepts
that
are
used
in
the
pro
of
are
dened,
and
ho
w
the
Sk
olemization
w
orks.
Ev
en
though
the
pro
of
in
[BM	
]
is
not
quite
correct,
it
is
often
quoted|
sometimes
ev
en
incorrectly
.
The
t
w
o
main
form
ulations
of
the
Subsumption
Theorem
that
w
e
ha
v
e
found
in
ILP-literature,
are
the
follo
wing:
S
Let

b
e
a
set
of
clauses
and
C
a
clause
whic
h
is
not
a
tautology
.
Dene
R
0
()
=

and
R
n
()
=
R
n 
()
[
fC
j
C
is
a
resolv
en
t
of
C

;
C


R
n 
()g.
Also
dene
R

()
=
R
0
()
[
R

()
[
:
:
:
.
Then
the
Sub-
sumption
Theorem
is
stated
as
follo
ws:

j
=
C
i
there
exists
a
clause
D

R

()
suc
h
that
D
subsumes
C
.
S
0
Let

b
e
a
set
of
clauses
and
C
a
clause
whic
h
is
not
a
tautology
.
Dene
L

()
=

and
L
n
()
=
fC
j
C
is
a
resolv
en
t
of
C


L
n 
()
and
C


g.
Also
dene
L

()
=
L

()
[
L

()
[
:
:
:
.
Then
the
Subsumption
Theorem
is
stated
as
follo
ws:

j
=
C
i
there
exists
a
clause
D

L

()
suc
h
that
D
subsumes
C
.

F
rom
p
ersonal
comm
unication
with
Stephen
Muggleton,
w
e
kno
w
Bain
and
Muggleton
disco
v
ered
the
theorem
themselv
es,
indep
enden
tly
of
[Lee
].
Only
afterw
ards
did
they
found
out
from
references
in
other
literature
that
their
theorem
w
as
roughly
the
same
as
the
theorem
in
Lee's
thesis.

..
INTR
ODUCTION

S
is
giv
en
in
[BM	
],
S
0
is
giv
en
in
[Mug	c
].
[Mug	c
]
do
es
not
include
a
pro
of
of
S
0
,
but
refers
instead
to
[BM	
].
In
other
w
ork
suc
h
as
[IA	
,
NCL
T	
,
LNC	b,
MDR	
,
BG	
],
the
theorem
is
also
giv
en
in
the
form
of
S
0
.
These
texts
do
not
giv
e
a
pro
of
of
S
0
,
but
refer
instead
to
[BM	
]
or
[Mug	c
].
That
is,
they
refer
to
a
pro
of
of
S
assuming
that
this
is
also
a
pro
of
of
S
0
.
But
clearly
that
is
not
the
case,
b
ecause
S
0
demands
that
at
least
one
of
the
paren
t
clauses
of
a
clause
in
L

()
is
a
mem
b
er
of
,
so
S
0
is
stronger
than
S.
In
fact,
whereas
S
is
true,
S
0
is
actual
ly
false!
If
S
0
w
ere
true,
then
input
resolution
w
ould
b
e
refutation-complete
whic
h
it
is
not,
as
w
e
will
see
in
Section
..
The
confusion
ab
out
S
0
is
p
erhaps
a
consequence
of
the
subtle
distinction
b
et
w
een
linear
resolution
and
input
resolution.
S
0
emplo
ys
a
form
of
input
resolution,
whic
h
is
a
sp
ecial
case
of
linear
resolution.
Linear
resolution
is
complete,
as
is
w
ell-kno
wn,
but
input
resolution
is
not.
Ho
w
ev
er,
the
articles
w
e
men
tioned
do
not
alw
a
ys
use
S
0
itself.
[LNC	b
,
NCL
T	
]
are
restricted
to
Horn
clauses.
In
Section
.
w
e
sho
w
that
SLD-
resolution
for
Horn
clauses
has
its
o
wn
Subsumption
Theorem,
so
for
Horn
clauses
there
is
no
problem.
If
w
e
examine
[Mug	c
,
IA	
,
MDR	
,
BG	
],
carefully
,
then
w
e
see
that
the
results
of
these
articles
(whic
h
are
also
ab
out
non-Horn
clauses)
only
dep
end
on
a
sp
ecial
case
of
S
0
,
namely
the
case
where

consists
of
a
single
clause.
Unfortunately
,
S
0
do
es
not
ev
en
hold
in
this
sp
ecial
case.
W
e
giv
e
a
coun
terexample
in
Section
..
This
means
that
results
whic
h
are
consequences
of
this
sp
ecial
case
of
S
0
need
to
b
e
reconsidered.

These
particularly
include
results
on
nth
p
owers
and
nth
r
o
ots.
If
D

L
n
(fC
g),
then
D
is
called
an
nth
p
o
w
er
of
C
,
and
C
is
called
an
nth
ro
ot
of
D
.
Clearly
,
the
falsit
y
of
S
0
renders
false
the
completeness
of
p
o
w
ers
and
ro
ots
rep
orted
in
[Mug	c
,
MDR	
,
BG	
].
This
confusion
in
the
ILP-comm
unit
y
ab
out
v
arious
forms
of
the
Subsump-
tion
Theorem
pro
vided
the
motiv
ation
for
the
researc
h
w
e
presen
t
in
this
c
hap-
ter.
Our
aim
w
as
to
nd
out
for
whic
h
v
ersions
of
resolution
the
Subsumption
Theorem
holds,
and
for
whic
h
it
do
es
not.
Let
us
rst
see
what
results
ha
v
e
already
b
een
pro
v
ed
in
the
literature.
Surprisingly
,
the
Subsumption
Theorem
is
men
tioned
no
where
in
the
standard
reference
b
o
oks
on
resolution,
suc
h
as
[CL,
Lo
v
,
Llo
].
Hence
w
e
ha
v
e
to
rely
on
journals,
conference
pro
ceedings
and
theses.
A
w
eak
form
of
the
Subsumption
Theorem
w
as
rst
pro
v
ed
b
y
Lee
in
	
in
his
PhD
thesis
[Lee
],
only

y
ears
after
Robinson's
in
tro
duction
of
the
resolution
principle
in
[Rob
].
His
result
is
the
follo
wing:

j
=
C
i
C
is
a
tautology
,
or
there
exists
a
clause
D
whic
h
implies
C
(and
th
us
not
necessarily
subsumes
C
)
and
whic
h
can
b
e
deriv
ed
from

b
y
unconstrained
resolution.
The
\real"
Subsumption
Theorem|i.e.,
where
D
subsumes
C
rather
than
only
implying
it|app
ears
to
ha
v
e
b
een
rst
pro
v
ed
in
[SCL	
].
Here
the
result
is
pro
v
ed
for
sev
eral
forms
of
semantic
resolution.
Since
seman
tic
resolution
is
a
constrained
form
of
resolution,
their
results
immediately
imply
the
Sub-

Idestam-Almquist
has
adjusted
his
results
from
[IA	
]
in
[IA	],
incorp
orating
our
ndings
as
published
in
[NCW	d
].


THE
SUBSUMPTION
THEOREM
sumption
Theorem
for
unconstrained
resolution.

Ko
w
alski
[Ko
w0
]
explicitly
pro
v
ed
the
result
for
unconstrained
resolution,
but
his
pro
of
is
rather
sk
etc
h
y
and
presupp
oses
kno
wledge
of
seman
tic
trees.
Minicozzi
and
Reiter
[MR
]
pro
v
ed
the
Subsumption
Theorem
for
linear
resolution.
After
that,
in
terest
in
the
Subsumption
Theorem
seems
to
ha
v
e
faded
somewhat.
Ho
w
ev
er,
recen
tly
Inoue
[Ino	
]
has
dev
elop
ed
SOL-resolution
(Skip
Ordered
Linear
resolution)
and
pro
v
ed
a
v
ersion
of
the
Subsumption
Theorem
for
it.
He
also
ga
v
e
an
o
v
erview
of
the
results
of
[Lee
,
SCL	,
MR
].
In
this
c
hapter,
w
e
consider
four
kinds
of
resolution:
\unconstrained"
res-
olution,
linear
resolution,
input
resolution,
and
SLD-resolution,
the
latter
only
for
Horn
clauses.
W
e
collect
some
of
the
results
men
tioned
in
the
last
paragraph
and
con
tribute
some
results
of
our
o
wn.
The
c
hapter
is
organized
as
follo
ws.
In
the
next
section
w
e
start
out
with
our
main
denitions.
In
Section
.
w
e
giv
e
a
new,
direct
pro
of
of
the
Subsump-
tion
Theorem
for
unconstrained
resolution.
In
our
opinion,
this
pro
of
is
easier
to
understand
than
earlier
pro
ofs
of
the
same
result
[Ko
w0
,
BM	
],
whic
h
pre-
supp
ose
the
refutation-completeness
of
resolution.
In
Section
.,
w
e
then
sho
w
that
the
refutation-completeness
of
unconstrained
resolution
is
an
immediate
corollary
of
the
Subsumption
Theorem.
Con
v
ersely
,
in
the
same
section
w
e
also
giv
e
a
second
pro
of
of
the
Subsumption
Theorem,
this
time
starting
from
the
refutation-completeness.
Th
us
these
t
w
o
completeness
results
are
actually
equiv
alen
t:
the
one
can
b
e
pro
v
ed
from
the
other.
The
Subsumption
Theorem
holds
for
linear
resolution
as
w
ell.
In
Section
.
w
e
giv
e
a
pro
of
of
this
result
whic
h
is
similar
to
the
pro
of
giv
en
in
[MR
].
Moreo
v
er,
w
e
also
sho
w
that
the
Subsumption
Theorem
for
linear
resolution
is
equiv
alen
t
to
the
refutation-completeness
of
linear
resolution.
In
Section
.,
w
e
sho
w
that
the
Subsumption
Theorem
do
es
not
hold
for
input
resolution,
not
ev
en
in
case

con
tains
only
one
clause,
whic
h
is
a
new
result.
Finally
,
in
Section
.
w
e
discuss
SLD-resolution
for
Horn
clauses.
W
e
rst
giv
e
a
pro
of
of
the
w
ell-kno
wn
refutation-completeness
of
SLD-resolution.
This
pro
of
is
easier
to
understand
than
the
one
giv
en
in
[Llo
],
since
our
pro
of
do
es
not
require
xed-p
oin
t
theory
.
W
e
then
pro
ceed
to
pro
v
e
the
Subsumption
The-
orem
for
SLD-resolution.
This
new
result
generalizes
Theorem

of
[MP	
],
whic
h
giv
es
the
result
for
the
case
where

con
tains
only
one
clause.
Moreo
v
er,
as
in
the
cases
of
unconstrained
and
linear
resolution,
w
e
sho
w
that
the
Sub-
sumption
Theorem
is
equiv
alen
t
to
the
refutation-completeness
also
in
case
of
SLD-resolution.

.
Preliminaries
In
this
section
w
e
dene
the
main
concepts
concerning
resolution.

The
name
\completeness
theorem
for
consequence
nding"
is
also
sometimes
used.
As
far
as
w
e
kno
w,
the
name
\Subsumption
Theorem"
w
as
in
tro
duced
in
[Ko
w0
].

Though
this
equiv
alence
holds
for
eac
h
of
the
forms
of
resolution
that
w
e
discuss
here,
it
do
es
not
holds
for
ev
ery
conceiv
able
kind
of
resolution.
[MR
]
discusses
m.c.l.-resolution.
This
is
refutation-complete,
but
the
Subsumption
Theorem
do
es
not
hold
for
it.

..
PRELIMINARIES

Denition
.
Let
C

and
C

b
e
clauses.
If
C

and
C

ha
v
e
no
v
ariables
in
common,
then
they
are
said
to
b
e
standar
dize
d
ap
art.

Denition
.
Let
C

=
L

_
:
:
:
_
L
i
_
:
:
:
_
L
m
and
C

=
M

_
:
:
:
_
M
j
_
:
:
:
_
M
n
b
e
t
w
o
clauses
whic
h
are
standardized
apart.
If
the
substitution

is
an
mgu
(most
general
unier)
of
the
set
fL
i
;
:M
j
g,
then
the
clause
(L

_
:
:
:
_
L
i 
_
L
i+
_
:
:
:
_
L
m
_
M

_
:
:
:
_
M
j
 
_
M
j
+
_
:
:
:
_
M
n
)
is
called
a
binary
r
esolvent
of
C

and
C

.
The
literals
L
i
and
M
j
are
said
to
b
e
the
literals
r
esolve
d
up
on.

Denition
.
Let
C
b
e
a
clause,
L

;
:
:
:
;
L
n
(n

)
some
uniable
literals
from
C
and

an
mgu
for
the
set
fL

;
:
:
:
;
L
n
g.
Then
the
clause
obtained
b
y
deleting
L


;
:
:
:
;
L
n

from
C

is
called
a
factor
of
C
.

Note
that
ev
ery
non-empt
y
clause
C
is
a
factor
of
C
itself,
using
the
iden
tit
y
substitution
"
as
mgu
for
one
literal
in
C
.
F
actors
are
sometimes
built
in
to
the
resolution
step
itself|for
instance
in
Robinson's
original
pap
er
[Rob
],
where
sets
of
literals
from
b
oth
paren
t
clauses
are
unied|but
w
e
ha
v
e
c
hosen
to
separate
the
denitions
of
a
factor
and
a
binary
resolv
en
t.
The
reason
for
this
is
that
binary
resolution
without
factors
is
sucien
t
in
case
of
SLD-resolution
for
Horn
clauses.
Denition
.
Let
C

and
C

b
e
t
w
o
clauses.
A
r
esolvent
R
of
C

and
C

is
a
binary
resolv
en
t
of
a
factor
of
C

and
a
factor
of
C

,
where
the
literals
resolv
ed
up
on
are
the
literals
unied
b
y
the
resp
ectiv
e
factors.
C

and
C

are
called
the
p
ar
ent
clauses
of
R
.

It
is
easy
to
sho
w
that
resolution
is
sound:
if
R
is
a
resolv
en
t
of
C

and
C

,
then
fC

;
C

g
j
=
R
.
Belo
w
w
e
dene
a
derivation.
In
later
sections,
w
e
will
put
some
constrain
ts
on
this
concept,
yielding,
resp
ectiv
ely
,
linear,
input
and
SLD-deriv
ations.
The
kind
of
deriv
ation
dened
in
this
section,
will
sometimes
b
e
referred
to
as
\un-
constrained"
resolution.
Denition
.
Let

b
e
a
set
of
clauses
and
C
a
clause.
A
derivation
of
C
from

is
a
nite
sequence
of
clauses
R

;
:
:
:
;
R
k
=
C
,
suc
h
that
eac
h
R
i
is
either
in

or
a
resolv
en
t
of
t
w
o
clauses
in
fR

;
:
:
:
;
R
i 
g.
If
suc
h
a
deriv
ation
exists,
w
e
write

`
r
C
.
A
deriv
ation
of
the
empt
y
clause

from

is
called
a
r
efutation
of
.

A
deriv
ation
of
a
clause
C
from
a
set

can
b
e
represen
ted
as
a
binary
tree
of
resolution
steps,
with
clauses
from

as
lea
v
es
and
C
as
ro
ot.
If
w
e
add
a
subsumption
step
to
a
deriv
ation,
w
e
get
a
de
duction.
Denition
.
Let
C
and
D
b
e
clauses.
W
e
sa
y
C
subsumes
D
if
there
exists
a
substitution

suc
h
that
C


D
.



THE
SUBSUMPTION
THEOREM
If
C
subsumes
D
,
then
C
j
=
D
.
Subsumption
is
also
sometimes
called

-
subsumption.
Example
.
C
=
P
(x)
_
Q(x;
y
)
subsumes
D
=
P
(a)
_
Q(a;
y
)
_
R
(x).
<
Denition
.
Let

b
e
a
set
of
clauses
and
C
a
clause.
W
e
sa
y
there
exists
a
de
duction
of
C
from
,
written
as

`
d
C
,
if
C
is
a
tautology
,
or
if
there
exists
a
clause
D
suc
h
that

`
r
D
and
D
subsumes
C
.
If

`
d
C
,
w
e
sa
y
C
can
b
e
de
duc
e
d
from
.

Example
.
T
o
illustrate
these
denitions,
w
e
will
giv
e
an
example
of
a
de-
duction
of
the
clause
C
=
R
(a)
_
S
(a)
from
the
set

=
f(P
(x)
_
Q(x)
_
R
(x));
(:P
(x)
_
Q(a));
(:P
(x)
_
:Q(x));
(P
(x)
_
:Q(x))g.
Figure
.
sho
ws
a
deriv
ation
of
the
clause
D
=
R
(a)
_
R
(a)
from
.
Note
that
w
e
use
the
factor
Q(a)
_
R
(a)
of
the
paren
t
clause
C

=
Q(x)
_
R
(x)
_
Q(a)
in
the
last
step
of
the
deriv
ation,
and
also
the
factor
P
(y
)
_
R
(y
)
of
C

=
P
(y
)
_
P
(y
)
_
R
(y
)
in
the
step
leading
to
C

.
Since
D
subsumes
C
,
w
e
ha
v
e

`
d
C
.
It
is
not
v
ery
dicult
to
see
the
equiv
alence
b
et
w
een
our
denition
of
a
deriv
ation
and
the
denition
of
R
n
()
w
e
ga
v
e
in
Section
..
F
or
instance,
in
gure
.,
C

;
C

;
C

;
C

;
C
0

are
v
arian
ts
of
clauses
in
R
0
()
(C

and
C
0

are
v
arian
ts
of
the
same
clause).
C

;
C

are
in
R

(),
C

is
in
R

()
and
D
is
in
R

().
C

=
P
(x)
_
Q(x)
_
R(x)
C

=
:P
(y
)
_
Q(a)
@
@
@
@
R
    	
C

=
Q(x)
_
R(x)
_
Q(a)
C

=
P
(x)
_
:Q(x)
C
0

=
P
(y
)
_
Q(y
)
_
R(y
)
C

=
:P
(x)
_
:Q(x)
@
@
@
@
R
    	
C

=
P
(y
)
_
P
(y
)
_
R(y
)
@
@
@
@
R
    	
C

=
:Q(y
)
_
R(y
)
@
@
@
@
R
    	
D
=
R(a)
_
R(a)
?
subsumption
C
=
R(a)
_
S
(a)
Figure
.:
A
deduction
of
C
from

<
.
The
Subsumption
Theorem
In
this
section,
w
e
pro
v
e
the
Subsumption
Theorem
for
(unconstrained)
reso-
lution:

j
=
C
i

`
d
C
.
Th
us
an
y
clause
whic
h
is
a
logical
consequence
of

..
THE
SUBSUMPTION
THEOREM
	
,
can
b
e
deduced
from
.
W
e
pro
v
e
this
in
a
n
um
b
er
of
successiv
e
steps
in
the
follo
wing
subsections.
First
w
e
pro
v
e
the
result
in
case
b
oth

and
C
are
ground,
then
w
e
pro
v
e
it
in
case

consists
of
arbitrary
clauses
but
C
is
ground,
and
nally
w
e
pro
v
e
the
theorem
when
neither

nor
C
need
b
e
ground.
..
The
Subsumption
Theorem
for
ground

and
C
Lemma
.
L
et

b
e
a
set
of
gr
ound
clauses
and
C
b
e
a
gr
ound
clause.
If

j
=
C
,
then

`
d
C
.
Pro
of
By
Theorem
A.,
w
e
can
assume

is
nite.
Assume
C
is
not
a
tautology
.
Then
w
e
need
to
nd
a
clause
D
suc
h
that

`
r
D
and
D

C
(for
ground
clauses
D
and
C
,
D
subsumes
C
i
D

C
).
The
pro
of
is
b
y
induction
on
the
n
um
b
er
of
clauses
in
.
.
Supp
ose

=
fC

g.
W
e
will
sho
w
that
C


C
.
Supp
ose
C


C
.
Then
there
exists
a
literal
L
suc
h
that
L

C

but
L

C
.
Let
I
b
e
an
in
terpretation
whic
h
mak
es
L
true
and
all
literals
in
C
false
(suc
h
an
I
exists,
since
C
is
not
a
tautology).
Then
I
is
a
mo
del
of
C

,
but
not
of
C
.
But
that
con
tradicts

j
=
C
.
So
C


C
,
and

`
d
C
.
.
(See
gure
.
for
illustration
of
this
case).
Supp
ose
the
theorem
holds
if
jj

m.
W
e
will
pro
v
e
that
this
implies
that
the
theorem
also
holds
if
jj
=
m
+
.
Let

=
fC

;
:
:
:
;
C
m+
g
and

0
=
fC

;
:
:
:
;
C
m
g.
If
C
m+
subsumes
C
or

0
j
=
C
,
then
the
theorem
holds.
So
assume
C
m+
do
es
not
subsume
C
and

0
j
=
C
.
The
idea
is
to
deriv
e,
using
the
induction
h
yp
othesis,
a
n
um
b
er
of
clauses
from
whic
h
a
deriv
ation
of
a
subset
of
C
can
b
e
constructed.
First
note
that
since

0
[
fC
m+
g
j
=
C
,
it
follo
ws
from
Theorem
A.
that

0
j
=
(C
m+
!
C
),
hence

0
j
=
C
_
:C
m+
.
Let
L

;
:
:
:
;
L
k
b
e
all
the
literals
in
C
m+
whic
h
are
not
in
C
(k


since
C
m+
do
es
not
subsume
C
).
Then
w
e
can
write
C
m+
=
L

_
:
:
:
_
L
k
_
C
0
,
where
C
0

C
.
Since
C
do
es
not
con
tain
L
i
(

i

k
),
the
clause
C
_
:L
i
is
not
a
tautology
.
Also,
since

0
j
=
C
_
:C
m+
and
C
m+
is
ground,
w
e
ha
v
e
that

0
j
=
C
_
:L
i
,
for
eac
h
i.
Then
b
y
the
induction
h
yp
othesis
there
exists
for
eac
h
i
a
ground
clause
D
i
suc
h
that

0
`
r
D
i
and
D
i

(C
_
:L
i
).
W
e
will
use
C
m+
and
the
deriv
ations
from

0
of
these
D
i
to
construct
a
deriv
ation
of
a
subset
of
C
from
.
F
or
eac
h
i,
:L
i

D
i
,
otherwise
D
i

C
and

0
j
=
C
.
So
w
e
can
write
eac
h
D
i
as
:L
i
_
D
0
i
,
and
D
0
i

C
(the
case
where
some
D
i
con
tains
:L
i
more
than
once
can
b
e
solv
ed
b
y
taking
a
factor
of
D
i
).
No
w
w
e
can
construct
a
deriv
ation
of
the
ground
clause
dened
as
D
=
C
0
_
D
0

_
:
:
:
_
D
0
k
from
,
using
C
m+
and
the
deriv
ations
of
D

;
:
:
:
;
D
k
from

0
.
See
gure
.
for
a
sc
hematic
represen
tation
of
this
deriv
ation.
In
this
tree,
the
deriv
ations
of
D

;
:
:
:
;
D
k
are
indicated
b
y
the
v
ertical
dots.
So
w
e
ha
v
e
that

`
r
D
.
Since
C
0

C
,
and
D
0
i

C
for
eac
h
i,
w
e
ha
v
e
that
D

C
.
Hence

`
d
C
.


0
THE
SUBSUMPTION
THEOREM
C
m+
=
L

_
:
:
:
_
L
k
_
C
0
.
.
.
D

=
:L

_
D
0

@
@
@
@
R
    	
L

_
:
:
:
_
L
k
_
C
0
_
D
0

.
.
.
D

=
:L

_
D
0

@
@
@
@
R
    	
L

_
:
:
:
_
L
k
_
C
0
_
D
0

_
D
0

.
.
.
L
k
_
C
0
_
D
0

_
:
:
:
_
D
0
k
 
.
.
.
D
k
=
:L
k
_
D
0
k
@
@
@
@
R
    	
D
=
C
0
_
D
0

_
:
:
:
_
D
0
k
Figure
.:
The
tree
for
the
deriv
ation
of
D
from

..
The
Subsumption
Theorem
when
C
is
ground
In
this
section,
w
e
will
pro
v
e
the
Subsumption
Theorem
in
case
C
is
ground
and

is
a
set
of
arbitrary
clauses.
The
idea
is
to
\translate"

j
=
C
to

g
j
=
C
,
where

g
is
a
set
of
ground
instances
of
clauses
of
.
Then
b
y
Lemma
.
there
is
a
clause
D
suc
h
that

g
`
r
D
and
D
subsumes
C
.
Finally
,
w
e
\lift"
this
deriv
ation
to
a
deriv
ation
from
.
The
next
t
w
o
results
sho
w
that
logical
implication
b
et
w
een
clauses
can
b
e
translated
to
logical
implication
b
et
w
een
ground
clauses.
The
rst
of
these
is
Herbrand's
Theorem.
Theorem
.
(Herbrand)
A
set
of
clauses

is
unsatisable
i
ther
e
exists
a
nite
unsatisable
set

g
of
gr
ound
instanc
es
of
clauses
in
.
Pro
of
(:

g
is
a
nite
set
of
ground
instances
of
clauses
in
,
so

j
=

g
.
Hence
if

g
is
unsatisable,
then

is
unsatisable.
):
Let

0
b
e
the
(p
ossibly
innite)
set
of
all
ground
instances
of
clauses
in
.
Let
I
b
e
an
Herbrand
in
terpretation.
It
is
not
v
ery
dicult
to
see
that
I
is
an
Herbrand
mo
del
of
a
clause
C
i
I
is
an
Herbrand
mo
del
of
the
set
of
all
ground
instances
of
C
.
Therefore
I
is
a
mo
del
of

i
I
is
a
mo
del
of

0
.
No
w
w
e
ha
v
e
the
follo
wing:

is
unsatisable
i
(b
y
Prop
osition
A.)

has
no
Herbrand
mo
dels
i

0
has
no
Herbrand
mo
dels
i
(b
y
Prop
osition
A.)

0
is
unsatisable.
Finally
,
b
y
the
Compactness
Theorem
(Theorem
A.)
there
is
a
nite
unsatis-
able
subset

g
of

0
.


..
THE
SUBSUMPTION
THEOREM

Theorem
.
L
et

b
e
a
set
of
clauses
and
C
b
e
a
gr
ound
clause.
If

j
=
C
,
then
ther
e
exists
a
nite
set

g
of
gr
ound
instanc
es
of
clauses
in
,
such
that

g
j
=
C
.
Pro
of
Let
C
=
L

_
:
:
:
_
L
k
(k

0).
If

is
unsatisable
then
the
lemma
follo
ws
immediately
from
Theorem
.,
so
supp
ose

is
satisable.
Note
that
since
C
is
ground,
:C
is
equiv
alen
t
to
:L

^
:
:
:
^
:L
k
.
Then:

j
=
C
i
(b
y
Prop
osition
A.)

[
f:C
g
is
unsatisable
i

[
f:L

;
:
:
:
;
:L
k
g
is
unsatisable
i
(b
y
Theorem
.)
there
exists
a
nite
unsatisable
set

0
,
consisting
of
ground
in-
stances
of
clauses
from

[
f:L

;
:
:
:
;
:L
k
g.
Since

is
satisable,
the
unsatisable
set

0
m
ust
con
tain
one
or
more
mem
b
ers
of
the
set
f:L

;
:
:
:
;
:L
k
g,
i.e.

0
=

g
[
f:L
i

;
:
:
:
;
:L
i
j
g,
where

g
is
a
nite
non-empt
y
set
of
ground
instances
of
clauses
in
.
So:

0
is
unsatisable
i

g
[
f:L
i

;
:
:
:
;
:L
i
j
g
is
unsatisable
i

g
[
f:(L
i

_
:
:
:
_
L
i
j
)g
is
unsatisable
i
(b
y
Prop
osition
A.)

g
j
=
(L
i

_
:
:
:
_
L
i
j
).
Since
fL
i

;
:
:
:
;
L
i
j
g

C
,
it
follo
ws
that

g
j
=
C
.

Example
.
Let

=
f(P
(f
(x))
_
:P
(x));
P
(x)g
and
C
=
P
(f
(f
(a))).
Then

j
=
C
.

g
=
f(P
(f
(f
(a)))
_
:P
(f
(a)));
(P
(f
(a))
_
:P
(a));
P
(a)g
is
a
set
of
ground
instances
of
clauses
of
,
and

g
j
=
C
.
<
The
follo
wing
t
w
o
lemmas
are
sucien
t
to
\lift"
a
deriv
ation,
that
is,
to
turn
a
deriv
ation
from
instances
of
certain
clauses
in
to
a
deriv
ation
from
those
clauses
themselv
es.
Lemma
.
L
et
C

and
C

b
e
two
clauses
and
C
0

and
C
0

b
e
instanc
es
of
C

and
C

,
r
esp
e
ctively.
If
R
0
is
a
r
esolvent
of
C
0

and
C
0

,
then
ther
e
exists
a
r
esolvent
R
of
C

and
C

,
such
that
R
0
is
an
instanc
e
of
R
.
Pro
of
W
e
assume
without
loss
of
generalit
y
that
C

and
C

,
and
C
0

and
C
0

are
standardized
apart.
Let
C

=
L

_
:
:
:
_
L
m
,
C

=
M

_
:
:
:
_
M
n
,
C
0

=
C



and
C
0

=
C



.
Supp
ose
R
0
is
a
resolv
en
t
of
C
0

and
C
0

.
Then
R
0
is
a
binary
resolv
en
t
of
a
factor
of
C
0

and
a
factor
of
C
0

.
See
the
gure
for
illustration.
F
or
notational
con
v
enience,
w
e
assume
without
loss
of
generalit
y
that
the
factor
of
C
0

is
(L

_
:
:
:
_
L
a
)



,
where


is
an
mgu
for
L
a


;
:
:
:
;
L
m


.
Similarly
,
the
factor
of
C
0

that
is
used,
is
(M

_
:
:
:
_
M
b
)



,
where


is
an
mgu
for
M
b


;
:
:
:
;
M
n


.
Let
L
i




and
M
j




b
e
the
literals
resolv
ed
up
on,
with
mgu
.
Abbreviate
L

_
:
:
:
_
L
i 
_
L
i+
_
:
:
:
_
L
a
to
D

and
M

_
:
:
:
_
M
j
 
_
M
j
+
_
:
:
:
_
M
b
to
D

.
Then
R
0
=
(D





_
D





).


THE
SUBSUMPTION
THEOREM
By
our
assumption
of
standardizing
apart,
this
can
b
e
written
as
R
0
=
(D

_
D

)







.
Let


b
e
an
mgu
for
L
a
_
:
:
:
_
L
m
.
Then
(L

_
:
:
:
_
L
a
)

is
a
factor
of
C

.
Note
that




is
a
unier
for
L
a
;
:
:
:
;
L
m
.
Since


is
an
mgu
for
L
a
;
:
:
:
;
L
m
,
there
exists
a
substitution


suc
h
that




=




.
Similarly
,
(M

_
:
:
:
_
M
b
)

is
a
factor
of
C

,
with


as
mgu
for
M
b
_
:
:
:
_
M
n
,
and
there
is
a


suc
h
that




=




.
Since
L
i




and
:M
j




can
b
e
unied
(they
ha
v
e

as
mgu)
and

i
is
more
general
than

i

i
(i
=
;
),
L
i


and
:M
j


can
b
e
unied.
Let

b
e
an
mgu
for
L
i


and
:M
j


.
Dene
R
=
(D



_
D



)
,
whic
h
can
b
e
written
as
R
=
(D

_
D

)




.
Since
R
is
a
binary
resolv
en
t
of
the
ab
o
v
e-men
tioned
factors
of
C

and
C

,
it
is
a
resolv
en
t
of
C

and
C

.
C

H
H
H
H
j


C








factor
factor
H
H
H
H
j







R


?


?

?


?


?
C
0

H
H
H
H
j


C
0








factor
factor
H
H
H
H
j







R
0
It
remains
to
sho
w
that
R
0
is
an
instance
of
R
.
Since
L
i







=
L
i







=
L
i





=
:M
j





=
:M
j





=
:M
j






,
the
substitution





is
a
unier
for
L
i


and
:M
j


.

is
an
mgu
for
L
i


and
:M
j


,
so
there
exists
a
substitution

suc
h
that





=


.
Therefore
R
0
=
(D

_
D

)








=
(D

_
D

)








=
(D

_
D

)








=
(D

_
D

)





=
R

.
Hence
R
0
is
an
instance
of
R
.

Lemma
.
(Deriv
ation
lifting)
L
et

b
e
a
set
of
clauses
and

0
a
set
of
instanc
es
of
clauses
in
.
Supp
ose
R
0

;
:
:
:
;
R
0
k
is
a
derivation
of
the
clause
R
0
k
fr
om

0
.
Then
ther
e
exists
a
derivation
R

;
:
:
:
;
R
k
of
the
clause
R
k
fr
om
,
such
that
R
0
i
is
an
instanc
e
of
R
i
,
for
e
ach
i.
Pro
of
The
pro
of
is
b
y
induction
on
k
.
.
Supp
ose
k
=
.
R
0



0
,
so
there
exists
a
clause
R



suc
h
that
R
0

is
an
instance
of
R

.
.
Supp
ose
the
lemma
holds
if
k

m.
Let
R
0

;
:
:
:
;
R
0
m
;
R
0
m+
b
e
a
deriv
ation
of
R
0
m+
from

0
.
By
the
induction
h
yp
othesis,
there
exists
a
deriv
ation
R

;
:
:
:
;
R
m
of
R
m
from
,
suc
h
that
R
0
i
is
an
instance
of
R
i
for
all
i,


i

m.
If
R
0
m+


0
,
the
lemma
is
ob
vious.
Otherwise,
R
0
m+
is
a
resolv
en
t
of
t
w
o
clauses
C
0

and
C
0

in
fR
0

;
:
:
:
;
R
0
m
g.
Then
there
exist
t
w
o
clauses
C

and
C

in
fR

;
:
:
:
;
R
m
g
suc
h
that
C
0

is
an
instance
of
C

and
C
0

is
an
instance
of
C

.
It
follo
ws
from
Lemma
.
that
there
is
a
resolv
en
t
R
m+
of
C

and
C

,
suc
h
that
R
0
m+
is
an
instance
of
R
m+
.
So
the
lemma
holds
for
k
=
m
+
.

..
THE
SUBSUMPTION
THEOREM


The
previous
lemmas
are
sucien
t
to
pro
v
e
the
Subsumption
Theorem
for
the
case
where
C
is
ground.
Lemma
.
L
et

b
e
a
set
of
clauses
and
C
b
e
a
gr
ound
clause.
If

j
=
C
,
then

`
d
C
.
Pro
of
Assume
C
is
not
a
tautology
.
W
e
w
an
t
to
nd
a
clause
D
suc
h
that

`
r
D
and
D
subsumes
C
.
F
rom

j
=
C
and
Theorem
.,
there
exists
a
nite
set

g
suc
h
that
eac
h
clause
in

g
is
a
ground
instance
of
a
clause
in
,
and

g
j
=
C
.
Then
from
Lemma
.
there
exists
a
clause
D
0
suc
h
that

g
`
r
D
0
,
and
D
0
subsumes
C
.
Let
R
0

;
:
:
:
;
R
0
k
=
D
0
b
e
a
deriv
ation
of
D
0
from

g
.
It
follo
ws
from
Lemma
.
that
w
e
can
lift
this
to
a
deriv
ation
R

;
:
:
:
;
R
k
of
R
k
from
,
where
D
0
is
an
instance
of
R
k
.
Let
D
=
R
k
.
Then

`
r
D
and
D
subsumes
C
(since
D
0
subsumes
C
).

..
The
Subsumption
Theorem
(general
case)
Finally
w
e
pro
v
e
the
Subsumption
Theorem
for
arbitrary

and
C
.
The
follo
w-
ing
lemma
sho
ws
that
if
w
e
ha
v
e
deriv
ed
some
clause
D
from

whic
h
subsumes
C

|where

is
a
Sk
olem
substitution
for
C
w.r.t.
|then
D
also
subsumes
C
.
F
or
instance,
supp
ose
D
=
P
(x),
C
=
P
(y
)
_
Q(z
)
and

=
fy
=a;
z
=bg.
D
subsumes
C

,
but
since

replaces
eac
h
v
ariable
b
y
a
constan
t
that
do
es
not
app
ear
in
,
C
or
D
,
D
also
subsumes
C
itself.
Lemma
.
L
et
C
and
D
b
e
clauses.
L
et

=
fx

=a

;
:
:
:
;
x
n
=a
n
g
b
e
a
Skolem
substitution
for
C
w.r.t.
D
.
If
D
subsumes
C

,
then
D
also
subsumes
C
.
Pro
of
Since
D
subsumes
C

,
there
exists
a
substitution

suc
h
that
D


C

.
Let

b
e
the
substitution
fy

=t

;
:
:
:
;
y
m
=t
m
g.
Let

0
b
e
the
substitution
obtained
from

b
y
replacing
eac
h
a
i
b
y
x
i
in
ev
ery
t
j
.
Note
that

=

0

.
Since

only
replaces
eac
h
x
i
b
y
a
i
(

i

n),
it
follo
ws
that
D

0

C
,
so
D
subsumes
C
.

Finally
w
e
can
pro
v
e
the
general
case
of
the
Subsumption
Theorem:
Theorem
.
(Subsumption
Theorem)
L
et

b
e
a
set
of
clauses
and
C
b
e
a
clause.
Then

j
=
C
i

`
d
C
.
Pro
of
(:
By
the
soundness
of
resolution
and
subsumption.
):
Assume
C
is
not
a
tautology
.
Let

b
e
a
Sk
olem
substitution
for
C
w.r.t.
.
Then
C

is
a
ground
clause
whic
h
is
not
a
tautology
,
and

j
=
C

.
So
b
y
Lemma
.
there
is
a
clause
D
suc
h
that

`
r
D
and
D
subsumes
C

.
Since
D
is
deriv
ed
from
,
D
do
es
not
con
tain
an
y
of
the
constan
ts
in

.
Therefore

is
also
a
Sk
olem
substitution
for
C
w.r.t.
D
.
Then
b
y
Lemma
.,
D
subsumes
C
.
Hence

`
d
C
.



THE
SUBSUMPTION
THEOREM
.
The
refutation-completeness
..
F
rom
Subsumption
Theorem
to
refutation-completeness
The
Subsumption
Theorem
actually
tells
us
that
resolution
and
subsumption
form
a
complete
set
of
deriv
ation-rules
for
clauses.
Though
the
resolution
rule
b
y
itself
is
not
complete
for
clauses
in
general,
for
instance,
P
(x)
j
=
P
(a)
but
P
(x)
`
r
P
(a),
resolution
is
complete
w.r.t.
unsatisable
sets
of
clauses.
This
refutation-completeness
is
an
easy
consequence
of
the
Subsumption
Theorem:
Theorem
.
(Refutation-completeness)
L
et

b
e
a
set
of
clauses.
Then

is
unsatisable
i

`
r
.
Pro
of
(:
By
the
soundness
of
resolution.
):
Supp
ose

is
unsatisable.
Then

j
=
.
So
b
y
Theorem
.
there
exists
a
clause
D
,
suc
h
that

`
r
D
and
D
subsumes
the
empt
y
clause
.
But

is
the
only
clause
whic
h
subsumes
,
so
D
=
.

..
F
rom
refutation-completeness
to
Subsumption
Theorem
In
the
previous
subsection,
w
e
sho
w
ed
that
the
refutation-completeness
is
a
direct
consequence
of
the
Subsumption
Theorem.
Here
w
e
will
sho
w
the
con-
v
erse:
that
w
e
can
obtain
the
Subsumption
Theorem
from
the
refutation-
completeness.
This
establishes
the
equiv
alence
of
the
Subsumption
Theorem
and
the
refutation-completeness:
the
one
can
b
e
pro
v
ed
from
the
other.
T
o
pro
v
e
the
Subsumption
Theorem
from
the
refutation-completeness,
w
e
will
rst
sho
w
ho
w
to
turn
a
refutation
of

[
f:L

;
:
:
:
;
:L
k
g
in
to
a
deduc-
tion
of
L

_
:
:
:
_
L
k
from
.
Th
us
our
pro
of
is
constructiv
e,
and
some-
what
similar
to
the
approac
h
in
[BM	
].
W
e
start
with
an
example.
Sup-
p
ose

=
f(P
(x)
_
:R
(f
(f
(b))));
(R
(f
(x))
_
:R
(x))g
and
C
=
P
(x)
_
Q(x)
_
:R
(b).
First
w
e
note
that

=
fx=ag
is
a
Sk
olem
substitution
for
C
w.r.t.
.
No
w
:C

,
f:P
(a);
:Q(a);
R
(b)g.
Figure
.
sho
ws
a
refutation
of

[
f:P
(a);
:Q(a);
R
(b)g.
No
w
b
y
omitting
the
lea
v
es
of
the
refutation-tree
whic
h
come
from
:C

(the
framed
literals)
and
b
y
making
appropriate
c
hanges
in
the
tree,
w
e
get
a
deriv
ation
of
the
clause
D
=
P
(x)
_
:R
(b)
(gure
.).
D
subsumes
C
,
so
w
e
ha
v
e
turned
the
refutation
of
gure
.
in
to
a
deduction
of
C
from
.
This
approac
h
also
w
orks
in
the
general
case.
The
follo
wing
lemma
do
es
most
of
the
w
ork.
Lemma
.
L
et

b
e
a
set
of
clauses
and
C
=
L

_
:
:
:
_
L
k
b
e
a
non-tautolo
gous
gr
ound
clause.
If

[
f:L

;
:
:
:
;
:L
k
g
`
r
,
then

`
d
C
.
Pro
of
Supp
ose

[
f:L

;
:
:
:
;
:L
k
g
`
r
.
Then
there
exists
a
refutation
R

;
:
:
:
;
R
n
=

of

[
f:L

;
:
:
:
;
:L
k
g.
Let
r
b
e
the
n
um
b
er
of
resolv
en
ts
in
this
sequence
(r
=
n the
n
um
b
er
of
mem
b
ers
of

[
f:L

;
:
:
:
;
:L
k
g
in
R

;
:
:
:
;
R
n
).
W
e
pro
v
e
the
lemma
b
y
induction
on
r
.

..
THE
REFUT
A
TION-COMPLETENESS

R(f
(x))
_
:R(x)
R(b)
@
@
@
@
R
    	
R(f
(b))
R(f
(x))
_
:R(x)
@
@
@
@
R
    	
R(f
(f
(b)))
P
(x)
_
:R(f
(f
(b)))
:P
(a)
@
@
@
@
R
    	
:R(f
(f
(b)))
@
@
@
@
R
    	

Figure
.:
A
refutation
of

[
f:P
(a);
:Q(a);
R
(b)g
R(f
(y
))
_
:R(y
)
R(f
(x))
_
:R(x)
@
@
@
@
R
    	
R(f
(f
(y
)))
_
:R(y
)
P
(x)
_
:R(f
(f
(b)))
@
@
@
@
R
    	
D
=
P
(x)
_
:R(b)
?
subsumption
C
=
P
(x)
_
Q(x)
_
:R(b)
Figure
.:
A
deduction
of
C
from
,
obtained
from
the
previous
gure
.
Supp
ose
r
=
0.
Then
R
n
=


,
so
the
lemma
holds.
.
Supp
ose
the
lemma
holds
for
r

m.
W
e
will
pro
v
e
that
this
implies
that
the
lemma
also
holds
for
r
=
m
+
.
Let
R

;
:
:
:
;
R
n
=

b
e
a
refutation
of

[
f:L

;
:
:
:
;
:L
k
g
con
taining
m
+

resolv
en
ts.
Let
R
i
b
e
the
rst
resolv
en
t.
Then
R

;
:
:
:
;
R
n
=

is
a
refutation
of

[
fR
i
g
[
f:L

;
:
:
:
;
:L
k
g
con
taining
only
m
resolv
en
ts,
since
R
i
is
no
w
one
of
the
original
premises.
Hence
b
y
the
induction
h
yp
othesis,
there
is
a
clause
D
,
suc
h
that

[
fR
i
g
`
r
D
and
D
subsumes
C
.
Supp
ose
R
i
is
itself
a
resolv
en
t
of
t
w
o
mem
b
ers
of
.
Then
w
e
also
ha
v
e

`
r
D
,
so
the
lemma
holds
in
this
case.
Note
that
R
i
cannot
b
e
a
resolv
en
t
of
t
w
o
mem
b
ers
of
f:L

;
:
:
:
;
:L
k
g
b
ecause
this
set
do
es
not
con
tain
a
complemen
tary
pair,
since
C
is
not
a
tautology
.
The
only
remaining
case
w
e
ha
v
e
to
c
hec
k,
is
where
R
i
is
a
resolv
en
t
of
C
0


and
some
:L
s
(

s

k
).
Let
C
0
=
M

_
:
:
:
_
M
j
_
:
:
:
_
M
h
.
Supp
ose
R
i
is
a
binary
resolv
en
t
of
(M

_
:
:
:
_
M
j
)
(a
factor
of
C
0
,
using

as
an
mgu
for
fM
j
;
:
:
:
;
M
h
g)
and
:L
s
,
with

as
mgu
for
M
j

and
L
s
.
Then
R
i
=
(M

_
:
:
:
_
M
j
 
)

and
C
0


=
R
i
_
L
s
_
:
:
:
_
L
s
(h
 j
+

copies
of
L
s
),
since
M
j
;
:
:
:
;
M
h
are
all
unied
to
L
s
b
y


.
No
w
replace
eac
h
time
R
i
app
ears
as
leaf
in
the
deriv
ation-tree
of
D
b
y


THE
SUBSUMPTION
THEOREM
C
0


=
R
i
_
L
s
_
:
:
:
_
L
s
,
and
add
L
s
_
:
:
:
_
L
s
to
all
decendan
ts
of
suc
h
an
R
i
-leaf.
Then
w
e
obtain
a
deriv
ation
of
D
_
L
s
_
:
:
:
_
L
s
from

[
fC
0


g.
Since
C
0


is
an
instance
of
a
clause
from
,
w
e
can
lift
(b
y
Lemma
.)
this
deriv
ation
to
a
deriv
ation
from

of
a
clause
D
0
,
whic
h
has
D
_
L
s
_
:
:
:
_
L
s
as
an
instance.
Since
D
subsumes
C
,
D
0
also
subsumes
C
.
Hence

`
d
C
.

No
w
w
e
can
pro
v
e
the
Subsumption
Theorem
(Theorem
.)
once
more,
this
time
starting
from
Theorem
..
Theorem
.
(Subsumption
Theorem)
L
et

b
e
a
set
of
clauses
and
C
b
e
a
clause.
Then

j
=
C
i

`
d
C
.
Pro
of
(:
By
the
soundness
of
resolution
and
subsumption.
):
If
C
is
a
tautology
,
the
theorem
is
ob
vious.
Assume
C
is
not
a
tautology
.
Let

b
e
a
Sk
olem
substitution
for
C
w.r.t.
.
Supp
ose
C

=
L

_
:
:
:
_
L
k
.
Since
C
is
not
a
tautology
,
C

is
not
a
tautology
.
C

is
ground
and

j
=
C

,
so
b
y
Prop
osition
A.
the
set
of
clauses

[
f:L

;
:
:
:
;
:L
k
g
is
unsatisable.
Then
it
follo
ws
from
Theorem
.
that

[
f:L

;
:
:
:
;
:L
k
g
`
r
.
Therefore
b
y
Lemma
.,
there
exists
a
clause
D
suc
h
that

`
r
D
and
D
subsumes
C

.
Finally
,
from
Lemma
.,
D
also
subsumes
C
itself.
Hence

`
d
C
.

No
w
that
w
e
ha
v
e
sho
wn
that
the
Subsumption
Theorem
can
b
e
pro
v
ed
from
the
refutation-completeness,
and
vice
v
ersa,
w
e
also
ha
v
e
the
follo
wing:
Theorem
.
F
or
unc
onstr
aine
d
r
esolution,
the
Subsumption
The
or
em
and
the
r
efutation-c
ompleteness
ar
e
e
quivalent.
.
Linear
resolution
Linear
resolution
is
c
haracterized
b
y
the
linear
shap
e
of
its
deriv
ations.
It
is
more
ecien
t
than
unconstrained
resolution,
b
ecause
the
n
um
b
er
of
p
ossible
deriv
ations
is
signican
tly
decreased
b
y
the
linear
constrain
t
on
the
shap
e
of
a
deriv
ation.
It
w
as
indep
enden
tly
in
tro
duced
b
y
Lo
v
eland
[Lo
v0
]
and
Luc
k-
ham
[Luc0
].
An
imp
ortan
t
further
restriction
called
SL-r
esolution
(Linear
res-
olution
with
a
Selection
function)
w
as
in
tro
duced
and
sho
wn
to
b
e
refutation-
complete
b
y
Ko
w
alski
and
Kuehner
[KK
].
Minicozzi
and
Reiter
pro
v
ed
the
Subsumption
Theorem
for
linear
resolution
in
[MR
].
More
recen
tly
,
In-
oue
[Ino	
]
dev
elop
ed
SOL-resolution
(Skip
Ordered
Linear
resolution)
and
pro
v
ed
a
v
ersion
of
the
Subsumption
Theorem
for
it.

..
LINEAR
RESOLUTION

..
Denitions
F
or
the
sak
e
of
transparency
,
w
e
will
dene
a
v
ery
simple
form
of
linear
res-
olution
here.
Man
y
features
and
restrictions
could
b
e
added
on
to
impro
v
e
eciency
(see
the
references
giv
en
ab
o
v
e).
W
e
will
pro
v
e
the
Subsumption
Theorem
and
the
refutation-completeness
for
this
form
of
linear
resolution.
After
that,
w
e
will
dene
a
further
restriction
of
linear
resolution
called
input
resolution
and
sho
w
that
this
is
not
complete
for
general
clauses,
not
ev
en
when
the
set
of
premises
con
tains
only
one
clause.
Denition
.
Let

b
e
a
set
of
clauses
and
C
b
e
a
clause.
A
line
ar
derivation
of
C
from

is
a
nite
sequence
of
clauses
R
0
;
:
:
:
;
R
k
=
C
,
suc
h
that
R
0


and
eac
h
R
i
with


i

k
is
a
resolv
en
t
of
R
i 
and
a
clause
C
i


[
fR
0
;
:
:
:
;
R
i 
g.
R
0
is
called
the
top
clause,
R
0
;
:
:
:
;
R
k
the
c
enter
clauses,
and
C

;
:
:
:
;
C
k
are
called
the
side
clauses
of
this
linear
deriv
ation.
If
a
linear
deriv
ation
of
C
from

exists,
w
e
write

`
l
r
C
.
A
linear
deriv
ation
of

from

is
called
a
line
ar
r
efutation
of
.

Linear
deriv
ations
are
c
haracterized
b
y
the
\linear"
shap
e
of
their
corresp
onding
deriv
ation-trees.
See
gure
..
Suc
h
a
tree
can
b
e
turned
in
to
a
deriv
ation-tree
for
unconstrained
resolution
b
y
adding
the
deriv
ations
of
eac
h
side
clause
C
i
whic
h
is
not
in
.
R
0
?
C








R

?
C








R

.
.
.
R
k
 
?
C
k







R
k
Figure
.:
The
c
haracteristic
shap
e
of
a
linear
deriv
ation
Linear
deductions
are
dened
as
follo
ws:
Denition
.	
Let

b
e
a
set
of
clauses
and
C
a
clause.
There
exists
a
line
ar
de
duction
of
C
from
,
written
as

`
l
d
C
,
if
C
is
a
tautology
,
or
if
there
exists
a
clause
D
suc
h
that

`
l
r
D
and
D
subsumes
C
.

..
The
refutation-completeness
A
pro
of
of
the
refutation-completeness
of
a
form
of
linear
resolution
called
OL-r
esolution
(Ordered
Linear
resolution),
is
giv
en
in
Theorem
.
of
[CL].


THE
SUBSUMPTION
THEOREM
Ho
w
ev
er,
this
pro
of
con
tains
an
error.
In
fact,
OL-resolution
is
not
refutation-
complete,
as
describ
ed
on
pp.
{
of
[Ino	
].
Nev
ertheless,
w
e
can
adapt
the
pro
of
of
[CL
]
to
yield
a
correct
pro
of
for
our
o
wn
denition
of
linear
resolution.
First
w
e
pro
v
e
the
case
for
ground
clauses,
whic
h
is
then
lifted.
The
pro
of
of
the
follo
wing
lifting
lemma
is
similar
to
Lemma
..
Lemma
.
(Linear
deriv
ation
lifting)
L
et

b
e
a
set
of
clauses
and

0
b
e
a
set
of
instanc
es
of
clauses
in
.
Supp
ose
R
0
0
;
:
:
:
;
R
0
k
is
a
line
ar
derivation
of
the
clause
R
0
k
fr
om

0
.
Then
ther
e
exists
a
line
ar
derivation
R
0
;
:
:
:
;
R
k
of
the
clause
R
k
fr
om
,
such
that
R
0
i
is
an
instanc
e
of
R
i
,
for
e
ach
i.
The
next
lemma
is
the
refutation-completeness
of
linear
resolution
for
ground
clauses.
Lemma
.
If

is
an
unsatisable
set
of
gr
ound
clauses
and
C


such
that
nfC
g
is
satisable,
then
ther
e
is
a
line
ar
r
efutation
of

with
C
as
top
clause.
Pro
of
By
the
Compactness
Theorem
(Theorem
A.),
w
e
can
assume

is
nite.
Let
n
b
e
the
n
um
b
er
of
distinct
ground
atoms
app
earing
in
literals
in
clauses
in
.
W
e
pro
v
e
the
lemma
b
y
induction
on
n.
.
If
n
=
0,
then

=
fg.
Since
nfC
g
is
satisable,
C
=

.
Supp
ose
the
lemma
holds
for
n

m
and
supp
ose
m
+

distinct
atoms
app
ear
in
.
W
e
distinguish
t
w
o
cases.
Case
:
Supp
ose
C
=
L,
where
L
is
a
literal.
W
e
rst
delete
all
clauses
from

whic
h
con
tain
the
literal
L
(so
w
e
also
delete
C
itself
from
).
Then
w
e
replace
clauses
whic
h
con
tain
the
literal
:L
b
y
clauses
con-
structed
b
y
deleting
these
:L
(so
for
example,
L

_
:L
_
L

will
b
e
replaced
b
y
L

_
L

).
Call
the
nite
set
obtained
in
this
w
a
y
 .
Note
that
the
literal
L,
nor
its
negation,
app
ears
in
clauses
in
 .
If
M
w
ere
a
Herbrand
mo
del
of
 ,
then
M
[
fLg
w
ould
b
e
a
Herbrand
mo
del
of
.
Th
us
since

is
unsatisable,
 m
ust
b
e
unsatisable.
No
w
let

0
b
e
an
unsatisable
subset
of
 ,
suc
h
that
ev
ery
prop
er
subset
of

0
is
satisable.

0
m
ust
con
tain
a
clause
D
0
obtained
from
a
mem
b
er
of

whic
h
con
tained
:L,
for
otherwise
the
unsatisable
set

0
w
ould
b
e
a
subset
of
nfC
g,
con
tradicting
the
assumption
that
nfC
g
is
satisable.
By
construction
of

0
,
w
e
ha
v
e
that

0
nfD
0
g
is
satisable.
F
urthermore,

0
con
tains
at
most
m
distinct
atoms,
so
b
y
the
induction
h
yp
othesis
there
exists
a
linear
refutation
of

0
with
top
clause
D
0
.
See
the
left
of
gure
.
for
illustration.
The
side
clauses
in
this
refutation
that
are
not
previous
cen
ter
clauses,
are
either
mem
b
ers
of

or
obtained
from
mem
b
ers
of

b
y
the
deletion
of
:L.
In
the
latter
kind
of
side
clauses,
put
bac
k
the
deleted
:L
literals,
and
add
these
:L
to
all
later
cen
ter
clauses.
Note
that
afterw
ards,
these
cen
ter
clauses
ma
y
con
tain
m
ultiple
copies
of
:L.
In
particular,
the
last
cen
ter
clause
c
hanges
from

to
:L
_
:
:
:
_
:L.
Since
D
0
is
a
resolv
en
t
of
C
and
D
=
:L
_
D
0

,
w
e
can
add
C
and
D
as
paren
t
clauses
on
top
of
the
previous
top
clause
D
0
.
That
w
a
y
,
w
e
get
a
linear
deriv
ation
of
:L
_
:
:
:
_
:L
from
,
with
top
clause
C
.
Finally
,
the
literals
in

..
LINEAR
RESOLUTION
	
D
0


0
?
C



0






R

?
C



0







C
=
L


?
D
=
:L
_
D
0








D
0
?
C

_
:L








R

_
:L
?
C









:L
?
L







Figure
.:
Case

of
the
pro
of
:L
_
:
:
:
_
:L
can
b
e
resolv
ed
a
w
a
y
using
the
top
clause
C
=
L
as
side
clause.
This
yields
a
linear
refutation
of

with
top
clause
C
(see
the
righ
t
of
gure
.).
Case
:
Supp
ose
C
=
L
_
C
0
,
where
C
0
is
a
non-empt
y
clause.
C
0
cannot
con
tain
:L,
for
otherwise
C
w
ould
b
e
a
tautology
,
con
tradicting
the
assumption
that

is
unsatisable
while
nfC
g
is
satisable.
Obtain

0
from

b
y
deleting
clauses
con
taining
:L,
and
b
y
remo
ving
the
literal
L
from
the
remaining
clauses.
Note
that
C
0


0
.
If
M
w
ere
an
Herbrand
mo
del
of

0
,
then
M
[
f:Lg
w
ould
b
e
an
Herbrand
mo
del
of
.
Th
us
since

is
unsatisable,

0
is
unsatisable.
F
urthermore,
b
ecause
nfC
g
is
satisable,
b
y
Prop
osition
A.
there
is
an
Herbrand
mo
del
M
0
of
nfC
g.
Since

is
unsatisable,
M
0
is
not
a
mo
del
of
C
.
L
is
a
literal
in
C
,
hence
L
m
ust
b
e
false
under
M
0
.
Ev
ery
clause
in

0
nfC
0
g
is
obtained
from
a
clause
in
nfC
g
b
y
deleting
L
from
it.
Since
M
0
is
a
mo
del
of
ev
ery
clause
in
nfC
g
and
L
is
false
under
M
0
,
ev
ery
clause
in

0
nfC
0
g
is
true
under
M
0
.
Therefore
M
0
is
a
mo
del
of

0
nfC
0
g,
whic
h
sho
ws
that

0
nfC
0
g
is
satisable.
Then
b
y
the
induction
h
yp
othesis,
there
exists
a
linear
refutation
of

0
with
top
clause
C
0
.
No
w
similar
to
case
,
put
bac
k
previously
deleted
L
literals
to
the
top
and
side
clauses,
and
to
the
appropriate
cen
ter
clauses.
This
giv
es
a
linear
deriv
ation
of
L
_
:
:
:
_
L
from

with
top
clause
C
.
Note
that
fLg
[
(nfC
g)
is
unsatisable,
b
ecause
L
is
false
in
an
y
Her-
brand
mo
del
of
nfC
g,
as
sho
wn
ab
o
v
e.
On
the
other
hand,
nfC
g
is
satisable.
Th
us
b
y
case

of
this
pro
of,
there
exists
a
linear
refutation
of
fLg
[
(nfC
g)
with
top
clause
L.
Since
L
is
a
factor
of
L
_
:
:
:
_
L,
w
e
can
put
our
linear
deriv
ation
of
L
_
:
:
:
_
L
\on
top"
of
this
linear
refutation
of
fLg
[
(nfC
g)
with
top
clause
L,
th
us
obtaining
a
linear
refutation
of

with
top
clause
C
.

Theorem
.
(Refutation-completeness
of
linear
resolution)
L
et

b
e
a
set
of
clauses.
Then

is
unsatisable
i

`
l
r
.

0
THE
SUBSUMPTION
THEOREM
Pro
of
(:
By
the
soundness
of
resolution.
):
Supp
ose

is
unsatisable.
Then
b
y
Theorem
.,
there
is
a
nite
unsat-
isable
set

g
of
ground
instances
of
clauses
in

0
.
Let

0
g
b
e
an
unsatisable
subset
of

g
and
C


0
g
suc
h
that

0
g
nfC
g
is
satisable.
F
rom
Lemma
.,
w
e
ha
v
e

0
g
`
l
r
.
Hence

`
l
r

b
y
Lemma
..

..
The
Subsumption
Theorem
Starting
from
the
refutation-completeness,
it
is
no
w
p
ossible
to
pro
v
e
also
the
Subsumption
Theorem
for
linear
resolution.
Our
pro
of
is
similar
to
the
one
giv
en
in
[MR
].
W
e
use
the
refutation-completeness
and
then
turn
a
linear
refutation
in
to
a
linear
deduction,
using
the
follo
wing
lemma:
Lemma
.	
L
et

b
e
a
set
of
clauses
and
C
=
L

_
:
:
:
_
L
k
b
e
a
non-tautolo
gous
gr
ound
clause.
If

[
f:L

;
:
:
:
;
:L
k
g
`
l
r
,
then

`
l
d
C
.
Pro
of
Supp
ose

[
f:L

;
:
:
:
;
:L
k
g
`
l
r
.
Then
there
exists
a
linear
refutation
R
0
;
:
:
:
;
R
n
=

of

[
f:L

;
:
:
:
;
:L
k
g.
Notice
that
the
top
clause
and
the
rst
side
clause
in
this
linear
refutation
cannot
b
oth
b
e
mem
b
ers
of
f:L

;
:
:
:
;
:L
k
g,
b
ecause
C
is
not
a
tautology
.
Th
us
w
e
can
assume
R
0

.
It
is
then
p
ossible
to
pro
v
e
b
y
induction
on
n
that
this
linear
refutation
can
b
e
transformed
in
to
a
linear
deduction
of
C
from

with
top
clause
R
0
:
.
If
n
=
0,
then
R
0
=


.
.
Supp
ose
the
lemma
holds
for
n

m.
Let
R
0
;
:
:
:
;
R
m+
=

b
e
a
linear
refutation
of

[
f:L

;
:
:
:
;
:L
k
g.
Then
R

;
:
:
:
;
R
m+
is
a
linear
refutation
of

[
fR

g
[
f:L

;
:
:
:
;
:L
k
g.
By
the
induction
h
yp
othesis,
there
is
a
linear
deriv
ation
of
a
clause
D
from

[
fR

g,
with
top
clause
R

,
suc
h
that
D
subsumes
C
.
Supp
ose
R

is
itself
a
resolv
en
t
of
t
w
o
mem
b
ers
of
.
Then
w
e
also
ha
v
e

`
l
r
D
,
so
the
lemma
holds
in
this
case.
The
only
remaining
case
w
e
ha
v
e
to
c
hec
k,
is
where
R

is
a
resolv
en
t
of
R
0


and
some
:L
s
(

s

k
).
Let
R
0
=
M

_
:
:
:
_
M
j
_
:
:
:
_
M
h
.
Supp
ose
R

is
a
binary
resolv
en
t
of
(M

_
:
:
:
_
M
j
)
(a
factor
of
R
0
,
using

as
an
mgu
for
fM
j
;
:
:
:
;
M
h
g)
and
:L
s
,
with

as
mgu
for
M
j

and
L
s
.
Then
R

=
(M

_
:
:
:
_
M
j
 
)

and
R
0


=
R

_
L
s
_
:
:
:
_
L
s
(h
 j
+

copies
of
L
s
),
since
M
j
;
:
:
:
;
M
h
are
all
unied
to
L
s
b
y


.
No
w
replace
eac
h
time
R

app
ears
as
leaf
(i.e.,
top
or
side
clause)
in
the
deriv
ation-tree
of
D
b
y
R
0


=
R

_
L
s
_
:
:
:
_
L
s
,
and
add
L
s
_
:
:
:
_
L
s
to
all
decendan
ts
of
suc
h
an
R

-leaf.
This
giv
es
a
new
deriv
ation,
in
whic
h
eac
h
resolv
en
t
is
the
corresp
onding
resolv
en
t
in
the
old
deriv
ation
of
D
plus
some
extra
copies
of
L
s
.
Th
us
w
e
obtain
a
linear
deriv
ation
of
D
_
L
s
_
:
:
:
_
L
s
from

[
fR
0


g.
Since
R
0


is
an
instance
of
a
clause
from
,
w
e
can
lift
(b
y
Lemma
.)
this
deriv
ation
to
a
deriv
ation
from

of
a
clause
D
0
,
whic
h
has
D
_
L
s
_
:
:
:
_
L
s
as
an
instance.
Since
D
subsumes
C
,
D
0
also
subsumes
C
.
Hence

`
l
d
C
.


..
INPUT
RESOLUTION

Theorem
.
(Subsumption
Theorem
for
linear
resolution)
L
et

b
e
a
set
of
clauses
and
C
b
e
a
clause.
Then

j
=
C
i

`
l
d
C
.
Pro
of
(:
By
the
soundness
of
resolution
and
subsumption.
):
If
C
is
a
tautology
,
the
theorem
is
ob
vious.
Assume
C
is
not
a
tautology
.
Let

b
e
a
Sk
olem
substitution
for
C
w.r.t.
.
Let
C

b
e
the
clause
L

_
:
:
:
_
L
k
.
Since
C
is
not
a
tautology
,
C

is
not
a
tautology
.
C

is
ground
and

j
=
C

,
so
the
set
of
clauses

[
f:L

;
:
:
:
;
:L
k
g
is
unsatisable
b
y
Prop
osition
A..
Then
it
follo
ws
from
Theorem
.
that

[
f:L

;
:
:
:
;
:L
k
g
`
l
r
.
Therefore
b
y
Lemma
.	,
there
exists
a
clause
D
suc
h
that

`
l
r
D
and
D
subsumes
C

.
F
rom
Lemma
.,
D
also
subsumes
C
itself.
Hence

`
l
d
C
.

W
e
ha
v
e
no
w
pro
v
ed
the
Subsumption
Theorem
of
linear
resolution
starting
from
the
refutation-completeness
of
linear
resolution.
Con
v
ersely
,
the
latter
also
follo
ws
immediately
from
the
former,
in
the
same
w
a
y
as
Theorem
.
follo
w
ed
from
Theorem
.
in
the
previous
section.
Hence
also
for
linear
resolution
w
e
ha
v
e
the
equiv
alence
b
et
w
een
these
t
w
o
completeness
results.
Theorem
.
F
or
line
ar
r
esolution,
the
Subsumption
The
or
em
and
the
r
efu-
tation-c
ompleteness
ar
e
e
quivalent.
.
Input
resolution
Linear
resolution
is
a
restriction
of
unconstrained
resolution.
Linear
resolution
can
itself
b
e
further
restricted
to
input
resolution,
b
y
stipulating
that
eac
h
side
clause
should
b
e
a
mem
b
er
of
.
Con
trary
to
linear
resolution,
input
resolution
is
not
complete,
not
ev
en
when
the
set
of
premises

con
tains
only
one
clause.
Before
w
e
giv
e
our
coun
terexample,
w
e
will
rst
formally
dene
input
resolution:
Denition
.0
Let

b
e
a
set
of
clauses
and
C
b
e
a
clause.
An
input
deriva-
tion
of
C
from

is
a
linear
deriv
ation
in
whic
h
eac
h
side
clause
C
i
is
a
mem
b
er
of
.
The
side
clauses
C

;
:
:
:
;
C
k
in
an
input
deriv
ation
are
also
called
input
clauses.
If
an
input
deriv
ation
of
C
from

exists,
w
e
write

`
ir
C
.
An
input
deriv
ation
of

from

is
called
an
input
r
efutation
of
.

Denition
.
Let

b
e
a
set
of
clauses
and
C
a
clause.
There
exists
an
input
de
duction
of
C
from
,
written
as

`
id
C
,
if
C
is
a
tautology
,
or
if
there
exists
a
clause
D
suc
h
that

`
ir
D
and
D
subsumes
C
.

It
is
w
ell-kno
wn
that
input
resolution
is
not
refutation-complete.
A
simple
prop
ositional
example
suces
to
sho
w
this.
Let

=
f(P
_
Q);
(P
_
:Q);
(:P
_
Q);
(:P
_
:Q)g.
Figure
.
sho
ws
a
refutation
b
y
unconstrained
resolution
of
.
This
pro
v
es
that

is
unsatisable.
Unfortunately
,
there
do
es
not
exist
an
input
refutation
of
.
It
is
easy
to
see
the
reason
for
this.
T
o
reac
h
the
empt
y
clause
,
the
last
input
clause
in
an
input
refutation
of

should
con
tain
only
one
literal,
or
ha
v
e
a
factor
con
taining


THE
SUBSUMPTION
THEOREM
P
_
Q
P
_
:Q
:P
_
Q
:P
_
:Q
@
@
@
@
R
    	
P
_
P
@
@
@
@
R
    	
:P
_
:P
@
@
@
@
R
    	

Figure
.:
An
unconstrained
refutation
of

only
one
literal.
Ho
w
ev
er,
eac
h
clause
in

con
tains
t
w
o
distinct
literals.
Hence
there
is
no
input
refutation
of
.
So
input
resolution
is
not
refutation-complete.
This
implies
also
that
the
Subsumption
Theorem
do
es
not
hold
either
for
input
resolution,
since
the
refutation-completeness
w
ould
b
e
a
direct
consequence
of
it.
W
e
can
in
fact
pro
v
e
a
stronger
negativ
e
result,
namely
that
the
Subsumption
Theorem
for
input
resolution
is
not
ev
en
true
in
the
simple
case
where

con
tains
only
a
single
clause.
In
our
coun
terexample
w
e
let

=
fC
g,
where
C
is
the
follo
wing
clause:
C
=
P
(x

;
x

)
_
Q(x

;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x

):
Figure
.
sho
ws
that
clause
D
(see
b
elo
w)
can
b
e
deriv
ed
from
C
b
y
uncon-
strained
resolution.
This
also
sho
ws
that
C
j
=
D
.
C

C

C

C

@
@
@
@
R
    	
D

@
@
@
@
R
    	
D

?
factor
?
factor
D
0

D
0

@
@
@
@
R
    	
D
Figure
.:
The
deriv
ation
of
D
from
C
b
y
unconstrained
resolution
Figure
.
mak
es
use
of
the
clauses
listed
b
elo
w.
C

,
C

,
C

,
C

are
v
arian
ts
of
C
.
D

is
a
binary
resolv
en
t
of
C

and
C

,
D

is
a
binary
resolv
en
t
of
C

and
C

(the
underlined
literals
are
the
literals
resolv
ed
up
on).
D
0

is
a
factor
of
D

,
using
the
substitution
fx

=x

;
x

=x

g.
D
0

is
a
factor
of
D

,
using
fx

=x

;
x

=x
	
g.
Finally
,
D
is
a
binary
resolv
en
t
of
D
0

and
D
0

.
C

=
P
(x

;
x

)
_
Q(x

;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x

).

..
INPUT
RESOLUTION

C

=
P
(x

;
x

)
_
Q(x

;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x

).
C

=
P
(x
	
;
x
0
)
_
Q(x
0
;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x
	
).
C

=
P
(x

;
x

)
_
Q(x

;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x

).
D

=
P
(x

;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x

)
_
P
(x

;
x

)
_
Q(x

;
x

)
_
:P
(x

;
x

).
D

=
P
(x
	
;
x
0
)
_
:Q(x

;
x

)
_
:P
(x

;
x
	
)
_
P
(x

;
x

)
_
Q(x

;
x
0
)_
:P
(x

;
x

).
D
0

=
P
(x

;
x

)
_
:Q(x

;
x

)
_
:P
(x

;
x

)
_
Q(x

;
x

)
_
:P
(x

;
x

).
D
0

=
P
(x
	
;
x
0
)
_
:Q(x

;
x

)
_
:P
(x

;
x
	
)
_
P
(x
	
;
x

)
_
Q(x

;
x
0
).
D
=
:Q(x

;
x

)
_
:P
(x

;
x

)
_
Q(x

;
x

)
_
:P
(x

;
x

)
_
P
(x

;
x
0
)_
:Q(x

;
x

)
_
P
(x

;
x

)
_
Q(x

;
x
0
):
Th
us
D
can
b
e
deriv
ed
from
C
using
unconstrained
resolution.
Ho
w
ev
er,
neither
D
nor
a
clause
whic
h
subsumes
D
can
b
e
deriv
ed
from
C
using
only
input
resolution.
W
e
pro
v
e
this
in
Prop
osition
..
This
sho
ws
that
input
resolution
is
not
complete,
not
ev
en
if

con
tains
only
one
clause.
The
follo
wing
lemma
sho
ws
that
eac
h
clause
whic
h
can
b
e
deriv
ed
from
C
b
y
input
resolution
con
tains
an
instance
of
P
(x

;
x

)
_
:P
(x

;
x

)
or
an
instance
of
Q(x

;
x

)
_
:Q(x

;
x

).
Lemma
.0
L
et
C
b
e
as
dene
d
ab
ove.
If
C
`
ir
E
,
then
E
c
ontains
an
instanc
e
of
P
(x

;
x

)
_
:P
(x

;
x

)
or
an
instanc
e
of
Q(x

;
x

)
_
:Q(x

;
x

).
Pro
of
Let
R
0
;
:
:
:
;
R
k
=
E
b
e
an
input
deriv
ation
of
E
from
C
.
W
e
pro
v
e
the
lemma
b
y
induction
on
k
:
.
R
0
=
C
,
so
the
lemma
is
ob
vious
if
k
=
0.
.
Supp
ose
the
lemma
holds
for
k

n.
Let
R
0
;
:
:
:
;
R
n+
=
E
b
e
an
input
deriv
ation
of
E
from
C
.
Note
that
the
only
factor
of
C
is
C
itself.
There-
fore
E
is
a
binary
resolv
en
t
of
C
and
a
factor
of
R
m
.
Let

b
e
the
mgu
used
in
obtaining
this
binary
resolv
en
t.
If
P
(x

;
x

)
or
:P
(x

;
x

)
is
the
lit-
eral
resolv
ed
up
on
in
C
,
then
E
m
ust
con
tain
(Q(x

;
x

)
_
:Q(x

;
x

))
.
Otherwise
Q(x

;
x

)
or
:Q(x

;
x

)
is
the
literal
resolv
ed
up
on
in
C
,
so
then
E
con
tains
(P
(x

;
x

)
_
:P
(x

;
x

))
.
Hence
the
lemma
also
holds
for
k
=
n
+
.

Prop
osition
.
L
et
C
and
D
b
e
as
dene
d
ab
ove.
Then
C
`
id
D
.
Pro
of
Supp
ose
C
`
id
D
.
Then
since
D
is
not
a
tautology
,
there
exists
a
clause
E
suc
h
that
C
`
ir
E
and
E
subsumes
D
.
F
rom
Lemma
.0
w
e
kno
w
that
E
con
tains
an
instance
of
P
(x

;
x

)
_
:P
(x

;
x

)
or
an
instance
of
Q(x

;
x

)
_
:Q(x

;
x

).
It
is
easy
to
see
that
neither
P
(x

;
x

)
_
:P
(x

;
x

)
nor
Q(x

;
x

)
_
:Q(x

;
x

)
subsumes
D
.
But
then
E
do
es
not
subsume
D
,
so
w
e
found
a
con
tradiction.
Hence
C
`
id
D
.



THE
SUBSUMPTION
THEOREM
So
w
e
see
that
input
resolution
is
not
complete:
C
j
=
D
,
but
C
`
id
D
.
This
is
unfortunate,
since
input
resolution
is
more
ecien
t
than
unconstrained
res-
olution
or
linear
resolution.
Ho
w
ev
er,
if
w
e
restrict
ourselv
es
to
Horn
clauses,
a
sp
ecial
case
of
input
resolution
called
SLD-r
esolution
can
b
e
sho
wn
to
b
e
complete.
This
will
b
e
the
topic
of
the
next
section.
.
SLD-resolution
SLD-resolution
for
Horn
clauses
w
as
in
tro
duced
b
y
Ko
w
alski
[Ko
w
].
It
is
simpler
than
the
unconstrained
or
linear
resolution
that
w
e
need
for
general
clauses.
Denition
.
Let

b
e
a
set
of
Horn
clauses
and
C
b
e
a
Horn-clause.
An
SLD-derivation
of
C
from

is
a
nite
sequence
of
Horn
clauses
R
0
;
:
:
:
;
R
k
=
C
,
suc
h
that
R
0


and
eac
h
R
i
(

i

k
)
is
a
binary
resolv
en
t
of
R
i 
and
a
denite
program
clause
C
i

,
using
the
head
of
C
i
and
a
sele
cte
d
atom
in
the
b
o
dy
of
R
i 
as
the
literals
resolv
ed
up
on.
R
0
is
called
the
top
clause
and
the
C
i
are
the
input
clauses
of
this
SLD-
deriv
ation.
If
an
SLD-deriv
ation
of
C
from

exists,
w
e
write

`
sr
C
.
An
SLD-deriv
ation
of

from

is
called
an
SLD-r
efutation
of
.

Note
that
either
eac
h
R
i
in
an
SLD-deriv
ation
is
a
goal,
or
eac
h
R
i
is
a
denite
program
clause.
Also
note
that
eac
h
resolv
en
t
in
an
SLD-deriv
ation
is
a
binary
resolv
en
t,
so
no
factors
are
used
here.
The
selected
atom
can
b
e
selected
b
y
a
so-
called
c
omputation
rule,
and
it
can
b
e
sho
wn
that
the
refutation-completeness
of
SLD-resolution
is
indep
enden
t
of
the
computation
rule
that
is
used.
W
e
will
not
go
in
to
that
here
(see
[Llo]).
Denition
.
Let

b
e
a
set
of
Horn
clauses
and
C
a
Horn
clause.
There
exists
an
SLD-de
duction
of
C
from
,
written
as

`
sd
C
,
if
C
is
a
tautology
,
or
if
there
is
a
Horn
clause
D
,
suc
h
that

`
sr
D
and
D
subsumes
C
.

Example
.
Consider

=
fP
(0;
x;
x);
(P
(s(x);
y
;
s(z
))
 
P
(x;
y
;
z
))g,
a
set
of
clauses
whic
h
formalizes
addition.
Let
us
see
ho
w
w
e
can
pro
v
e
C
=
P
(s

(0);
s(0);
s

(0))
(that
is,

+

=
)
from
this
set
b
y
SLD-resolution.
Figure
.	
sho
ws
an
SLD-deriv
ation
of
R

=
P
(s

(0);
y
;
s

(y
))
from
.
Here
the
selected
atoms
are
underlined.
Since
R

subsumes
C
,
w
e
ha
v
e

`
sd
C
.
<
..
The
refutation-completeness
In
this
subsection,
w
e
will
pro
v
e
the
w
ell-kno
w
result
that
SLD-resolution
is
refutation-complete:
a
set
of
Horn
clauses
is
unsatisable
i
it
has
an
SLD-
refutation.
Our
pro
of
is
similar
to
the
pro
of
for
the
refutation-completeness
of
linear
resolution
that
w
e
ga
v
e
in
Section
..
It
is
dieren
t
from
the
pro
of
giv
en
in
[Llo],
since
our
pro
of
do
es
not
require
xed-p
oin
t
theory
.
Instead,
it
only
uses
the
basic
denitions
of
resolution.
First
w
e
establish
the
refutation-
completeness
for
ground
Horn
clauses:

..
SLD-RESOLUTION

R
0
=
P
(s(x);
y
;
s(z
))
 
P
(x;
y
;
z
)
?
C

=
P
(s(u);
v
;
s(w
))
 
P
(u;
v
;
w
)







R

=
P
(s

(x);
y
;
s

(z
))
 
P
(x;
y
;
z
)
?
C

=
P
(0;
v
;
v
)







R

=
P
(s

(0);
y
;
s

(y
))
?
subsumes
C
=
P
(s

(0);
s(0);
s

(0))
Figure
.	:
An
SLD-deduction
of
C
from

Lemma
.
If

is
a
nite
unsatisable
set
of
gr
ound
Horn
clauses,
then

`
sr
.
Pro
of
Let
n
b
e
the
n
um
b
er
of
atomic
clauses
(clauses
whic
h
consist
of
a
single
p
ositiv
e
literal)
in
.
The
pro
of
is
b
y
induction
on
n.
.
If
n
=
0,
then


,
for
otherwise
the
empt
y
set
w
ould
b
e
an
Herbrand
mo
del
of
.
.
Supp
ose
the
lemma
holds
for
0

n

m.
Supp
ose

con
tains
m
+

atomic
clauses.
If



the
lemma
is
ob
vious,
so
supp
ose


.
Let
A
b
e
an
atomic
clause
in
.
W
e
rst
delete
all
clauses
from

whic
h
ha
v
e
A
as
head
(so
w
e
also
delete
the
atomic
clause
A
from
).
Then
w
e
replace
clauses
whic
h
ha
v
e
A
in
their
b
o
dy
b
y
clauses
constructed
b
y
deleting
these
atoms
A
from
the
b
o
dy
(so
for
example,
B
 
A;
B

;
:
:
:
;
B
k
will
b
e
replaced
b
y
B
 
B

;
:
:
:
;
B
k
).
Call
the
set
obtained
in
this
w
a
y

0
.
If
M
w
ere
a
Herbrand
mo
del
of

0
,
then
M
[
fAg
w
ould
b
e
a
Herbrand
mo
del
of
.
Th
us
since

is
unsatisable,

0
m
ust
b
e
unsatisable.

0
only
con
tains
m
atomic
clauses,
so
b
y
the
induction
h
yp
othesis,
there
is
an
SLD-refutation
of

0
.
If
this
refutation
only
uses
clauses
from

0
whic
h
w
ere
also
in
,
then
this
is
also
an
SLD-refutation
of
,
so
then
w
e
are
done.
Otherwise,
if
C
is
the
top
clause
or
an
input
clause
in
this
refutation
and
C

,
then
C
w
as
obtained
from
some
C
0


b
y
deleting
all
atoms
A
from
the
b
o
dy
of
C
0
.
F
or
all
suc
h
C
,
do
the
follo
wing:
restore
the
previously
deleted
copies
of
A
to
the
b
o
dy
of
C
(whic
h
turns
C
in
to
C
0
again),
and
add
these
atoms
A
to
all
later
resolv
en
ts.
This
w
a
y
,
w
e
can
turn
the
SLD-refutation
of

0
in
to
an
SLD-deriv
ation
of
 
A;
:
:
:
;
A
from
.
(See
gure
.0
for
illustration,
where
w
e
add
previously
deleted
atoms
A
to
the
b
o
dies
of
R
0
and
C

.)
Since
also
A

,
w
e
can
construct
an
SLD-refutation
of
,
using
A
a
n
um
b
er
of
times
as
input
clause
to
resolv
e
a
w
a
y
all
mem
b
ers
of
the
goal
 
A;
:
:
:
;
A.



THE
SUBSUMPTION
THEOREM
R
0


?
C










R

?
C










R

=

(R
0
_
:A)


?
C










R

_
:A
?
C

_
:A









 
A;
A
?
A









 
A
?
A










Figure
.0:
The
SLD-refutations
of

0
(left)
and

(righ
t)
The
pro
of
of
the
lifting
lemma
for
SLD-resolution
is
similar
to
Lemma
..
Lemma
.
(SLD-deriv
ation
lifting)
L
et

b
e
a
set
of
Horn
clauses
and

0
b
e
a
set
of
instanc
es
of
clauses
in
.
Supp
ose
R
0
0
;
:
:
:
;
R
0
k
is
an
SLD-
derivation
of
the
clause
R
0
k
fr
om

0
.
Then
ther
e
exists
an
SLD-derivation
R
0
;
:
:
:
;
R
k
of
the
clause
R
k
fr
om
,
such
that
R
0
i
is
an
instanc
e
of
R
i
,
for
e
ach
i.
The
previous
lemmas
allo
w
us
to
pro
v
e
the
refutation-completeness
of
SLD-
resolution:
Theorem
.	
(Refutation-completeness
of
SLD-resolution)
L
et

b
e
a
set
of
Horn
clauses.
Then

is
unsatisable
i

`
sr
.
Pro
of
(:
By
the
soundness
of
resolution.
):
Supp
ose

is
unsatisable.
By
Theorem
.,
there
is
a
nite
unsatisable
set

0
of
ground
instances
of
clauses
in
.
F
rom
Lemma
.,
w
e
ha
v
e

0
`
sr
.
Using
Lemma
.,
w
e
can
lift
this
to

`
sr
.

..
The
Subsumption
Theorem
Here
w
e
will
pro
v
e
the
Subsumption
Theorem
for
SLD-resolution.
As
in
the
case
of
linear
resolution,
w
e
establish
this
result
b
y
translating
a
refutation
to
a
deduction,
using
the
follo
wing
lemma:
Lemma
.
L
et

b
e
a
set
of
Horn
clauses
and
C
=
L

_
:
:
:
_
L
k
b
e
a
non-
tautolo
gous
gr
ound
Horn
clause.
If

[
f:L

;
:
:
:
;
:L
k
g
`
sr
,
then

`
sd
C
.
Pro
of
Supp
ose

[
f:L

;
:
:
:
;
:L
k
g
`
sr
,
that
is,
there
exists
an
SLD-refu-
tation
R
0
;
:
:
:
;
R
n
=

of

[
f:L

;
:
:
:
;
:L
k
g.
By
induction
on
n:
.
If
n
=
0,
then
R
0
=


,
so
then
the
lemma
is
ob
vious.

..
SLD-RESOLUTION

.
Supp
ose
the
lemma
holds
for
n

m.
Let
R
0
;
:
:
:
;
R
m+
=

b
e
an
SLD-refutation
of

[
f:L

;
:
:
:
;
:L
k
g.
Then
R

;
:
:
:
;
R
m+
is
an
SLD-
refutation
of

[
fR

g
[
f:L

;
:
:
:
;
:L
k
g.
By
the
induction
h
yp
othesis,
there
is
an
SLD-deriv
ation
R
0

;
R
0

;
:
:
:
;
R
0
l
from

[
fR

g,
where
R
0
l
sub-
sumes
C
.
Note
that
R

m
ust
b
e
a
denite
goal,
so
R

can
only
b
e
used
as
top
clause
in
this
deriv
ation.
If
R
0

=
R

,
then
R
0


.
Moreo
v
er,
in
that
case
R

is
used
no
where
in
the
SLD-deriv
ation
of
R
0
l
,
so
then
this
is
an
SLD-deriv
ation
of
R
0
l
from
,
and
hence

`
sd
C
.
In
case
R
0

=
R

,
w
e
distinguish
three
p
ossibilities:
.
R

is
a
binary
resolv
en
t
of
a
goal
G


and
a
denite
clause
C


.
Then
G;
R
0

;
R
0

;
:
:
:
;
R
0
l
,
with
C

as
rst
input
clause,
is
an
SLD-
deriv
ation
from
.
R
0
l
subsumes
C
,
so
then

`
sd
C
.
.
R

is
a
binary
resolv
en
t
of
a
negativ
e
literal
:L

f:L

;
:
:
:
;
:L
k
g
and
a
denite
clause
C



(note
that
this
means
that
C
is
a
denite
program
clause,
with
L
as
head).
Let

b
e
the
mgu
used
in
this
resolution-step,
so
C


=
L
_
R

.
Then
C


;
L
_
R
0

;
:
:
:
;
L
_
R
0
l
is
an
SLD-deriv
ation
of
L
_
R
0
l
from

[
fC


g.
(See
Figure
.
for
illustration.)
C


is
an
instance
of
a
clause
in
,
so
b
y
Lemma
.,
w
e
can
nd
an
SLD-deriv
ation
from

of
a
clause
D
,
of
whic
h
L
_
R
0
l
is
an
instance.
Since
R
0
l
subsumes
C
and
L

C
,
L
_
R
0
l
subsumes
C
,
and
hence
D
also
subsumes
C
.
Therefore

`
sd
C
.
:L
?
C










R
0

=
R

?
C










R
0

.
.
.
C


=
L
_
R

?
C










L
_
R
0

.
.
.
Figure
.:
Illustration
of
case

of
the
pro
of
.
R

is
a
binary
resolv
en
t
of
a
goal
G


and
a
p
ositiv
e
literal
L

f:L

;
:
:
:
;
:L
k
g.
Let

b
e
the
mgu
used
in
this
resolution
step,
so
G
=
:L
_
R

.
Then
G
=
:L
_
R
0

;
:L
_
R
0

;
:
:
:
;
:L
_
R
0
l
is
an
SLD-deriv
ation
of
:L
_
R
0
l
from

[
fG
g.
G
is
an
instance
of
a
clause
in
,
so
b
y
Lemma
.,
w
e
can
nd
an
SLD-deriv
ation
from

of
a
clause
D
,
of
whic
h
:L
_
R
0
l
is
an
instance.
Since
R
0
l
subsumes
C
and
:L

C
,
:L
_
R
0
l
subsumes
C
,
and
hence
D
also
subsumes
C
.
Therefore

`
sd
C
.

No
w
w
e
can
pro
v
e
the
Subsumption
Theorem
for
SLD-resolution.
This
result
generalizes
Theorem

of
[MP	
],
whic
h
giv
es
the
theorem
for
the
case
where

con
tains
only
one
clause
(though
ignoring
that
C
ma
y
b
e
a
tautology).
Theorem
.0
(Subsumption
Theorem
for
SLD-resolution)
L
et

b
e
a
set
of
Horn
clauses
and
C
b
e
a
Horn
clause.
Then

j
=
C
i

`
sd
C
.


THE
SUBSUMPTION
THEOREM
Pro
of
(:
By
the
soundness
of
resolution
and
subsumption.
):
If
C
is
a
tautology
,
the
theorem
is
ob
vious.
Assume
C
is
not
a
tautology
.
Let

b
e
a
Sk
olem
substitution
for
C
w.r.t.
.
Let
C

b
e
the
clause
L

_
:
:
:
_
L
k
.
Since
C
is
not
a
tautology
,
C

is
not
a
tautology
.
C

is
ground
and

j
=
C

,
so
b
y
Prop
osition
A.
the
set
of
clauses

[
f:L

;
:
:
:
;
:L
k
g
is
unsatisable.
Then
it
follo
ws
from
Theorem
.	
that

[
f:L

;
:
:
:
;
:L
k
g
`
sr
.
Therefore
b
y
Lemma
.,
there
exists
a
clause
D
suc
h
that

`
sr
D
and
D
subsumes
C

.
F
rom
Lemma
.,
D
also
subsumes
C
itself.
Hence

`
sd
C
.

Note
the
follo
wing
sp
ecial
case
of
this
result:
if

is
a
denite
program
and
A
is
an
atom
suc
h
that

j
=
A,
then
there
exists
an
atom
B
suc
h
that

`
sr
B
and
A
is
an
instance
of
B
.
F
urthermore,
analogous
to
the
case
of
linear
resolution,
w
e
also
ha
v
e
the
follo
wing
equiv
alence:
Theorem
.
F
or
SLD-r
esolution,
the
r
efutation-c
ompleteness
and
the
Sub-
sumption
Theor
em
ar
e
equivalent.
.
Summary
The
Subsumption
Theorem
is
the
follo
wing
statemen
t:
If

is
a
set
of
clauses
and
C
is
a
clause,
then

j
=
C
i
C
is
a
tautology
,
or
there
exists
a
clause
D
whic
h
subsumes
C
and
whic
h
can
b
e
deriv
ed
from

b
y
some
form
of
resolution.
This
theorem
is
a
more
direct
form
of
completeness
than
the
b
etter-kno
wn
refutation-completeness
of
resolution
and
hence
sometimes
more
useful,
partic-
ularly
for
theoretical
analysis.
Dieren
t
v
ersions
of
the
theorem
exist,
dep
ending
on
the
instan
tiation
of
\some
form
of
resolution."
W
e
ha
v
e
pro
v
ed
here
that
the
Subsumption
Theo-
rem
holds
for
unconstrained
resolution
and
linear
resolution
for
general
clauses.
Moreo
v
er,
for
eac
h
of
these
t
w
o
forms
of
resolution,
the
Subsumption
Theorem
is
equiv
alen
t
to
the
refutation-completeness
of
that
form
of
resolution:
the
one
can
b
e
pro
v
ed
from
the
other.
On
the
other
hand,
the
Subsumption
Theorem
do
es
not
hold
for
input
resolution,
not
ev
en
in
the
simple
case
where

con-
tains
only
one
clause.
F
or
SLD-resolution
for
Horn
clauses,
the
Subsumption
Theorem
do
es
hold,
and
is
again
equiv
alen
t
to
the
refutation-completeness
of
SLD-resolution.

Chapter

Unfolding
.
In
tro
duction
In
an
ILP-problem,
it
is
sometimes
the
case
that
w
e
initially
start
with
a
theory
that
is
o
v
erly
general:
it
is
complete,
but
not
consisten
t.
The
problem
of
nding
a
correct
theory
then
b
ecomes
the
problem
of
sp
e
cializing
the
initial
theory
to
a
correct
one.
In
this
c
hapter
w
e
will
in
v
estigate
ho
w
suc
h
sp
ecialization
can
b
e
done
using
unfolding.
This
is
a
sp
ecialization-op
erator
whic
h
constructs
resol-
v
en
ts
from
giv
en
paren
t
clauses.
W
e
will
restrict
atten
tion
to
denite
program
clauses,
so
the
theories
should
b
e
denite
programs.
F
urthermore,
w
e
will
also
assume
that
the
giv
en
examples
E
+
and
E
 consist
of
ground
atoms
(ground
instances
of
one
or
more
predicates).
Let
us
rst
formally
dene
the
sp
e
cialization
pr
oblem
:
Giv
en:
A
denite
program

and
t
w
o
disjoin
t
sets
of
ground
atoms
E
+
and
E
 ,
suc
h
that

is
o
v
erly
general
w.r.t.
E
+
and
E
 ,
and
supp
ose
there
exists
a
denite
program

0
suc
h
that

j
=

0
and

0
is
correct
w.r.t.
E
+
and
E
 .
Find:
One
suc
h
a

0
.
Clearly
,
this
is
a
sp
ecial
case
of
the
general
problem
setting
of
Chapter
.
W
e
need
to
presupp
ose
the
existence
of
a
correct
sp
ecialization

0
of
,
b
ecause
a
correct
program
do
es
not
alw
a
ys
exist,
as
pro
v
ed
in
Theorem
..
Hence
trying
to
solv
e
a
sp
ecialization
problem
only
mak
es
sense
when
a
correct
sp
ecialization
exists.
Note
that
bac
kground
kno
wledge
can
b
e
included
in
,
so
w
e
will
not
men
tion
bac
kground
kno
wledge
separately
in
this
c
hapter.
A
natural
w
a
y
to
sp
ecialize

is,
rst,
to
replace
a
clause
in

b
y
all
its
resolv
en
ts
up
on
some
b
o
dy-atom
in
this
clause.
Constructing
these
resolv
en
ts
is
called
unfolding.
The
new
program
obtained
in
this
w
a
y
after
unfolding
a
clause
in
,
is
clearly
implied
b
y
.
The
function
of
the
replaced
clause
is
tak
en
o
v
er
b
y
the
set
of
resolv
en
ts
pro
duced
b
y
unfolding.
W
e
can
then,
secondly
,
delete
some
new
clauses
from
the
program
that
ha
v
e
to
do
with
the
negativ
e
examples,
th
us
sp
ecializing
the
program.
Hop
efully
,
after
rep
eating
these
t
w
o
steps
a
n
um
b
er
of
times,
w
e
can
get
rid
of
all
negativ
e
examples.
This
metho
d
w
as
in
tro
duced
in
[BIA	
].
	

0
CHAPTER
.
UNF
OLDING
F
or
simplicit
y
,
let
all
examples
b
e
ground
instances
of
P
(x

;
:
:
:
;
x
n
),
for
some
predicate
P
.
The
motiv
ation
for
the
metho
d
describ
ed
ab
o
v
e,
is
the
fact
that
it
can
b
e
used
to
prune
negativ
e
examples
from
the
SLD-tree
for

[
f 
P
(x

;
:
:
:
;
x
n
)g.

W
e
will
illustrate
this
b
y
an
example.
Consider
the
program
,
consisting
of
the
follo
wing
clauses:
C

=
P
(x;
y
)
 
Q(x;
y
)
C

=
Q(b;
b)
 
Q(a;
a)
C

=
Q(a;
a)
and
E
+
=
fP
(b;
b)g,
E
 =
fP
(a;
a)g.
The
SLD-tree
for

[
f 
P
(x;
y
)g
is
sho
wn
on
the
left
of
gure
..
The
success
branc
hes
corresp
onding
to
refuta-
tions
of
p
ositiv
e
examples
are
mark
ed
with
a
`+',
for
negativ
e
examples
with
a
` '.
 
P
(x;
y
)
?

 
Q(x;
y
)
    	

@
@
@
@
R


fx=a;
y
=ag;
  
Q(a;
a)
?


fx=b;
y
=bg;
+
 
P
(x;
y
)
    	
,
@
@
@
@
R
,

fx=a;
y
=ag;
  
Q(a;
a)
?


fx=b;
y
=bg;
+
 
P
(x;
y
)
?
,
 
Q(a;
a)
?


fx=b;
y
=bg;
+
Figure
.:
The
SLD-trees
for
,

0
and

00
P
(a;
a)
is
a
negativ
e
example,
so
w
e
w
ould
lik
e
to
remo
v
e
this
b
y
w
eak
ening
the
program.
This
could
b
e
done
b
y
deleting
C

or
C

from
.
Ho
w
ev
er,
this
w
ould
also
mak
e
the
p
ositiv
e
example
P
(b;
b)
no
longer
deriv
able,
th
us
rendering
the
program
to
o
w
eak.
Another
w
a
y
to
sp
ecialize
is,
rst,
to
unfold
C

up
on
Q(x;
y
).
The
follo
wing
C
;
and
C
;
are
the
t
w
o
clauses
pro
duced
b
y
unfolding
C

.
C
;
=
P
(b;
b)
 
Q(a;
a)
(resolv
en
t
of
C

and
C

)
C
;
=
P
(a;
a)
(resolv
en
t
of
C

and
C

)
No
w
w
e
replace
the
unfolded
clause
C

b
y
its
resolv
en
ts
C
;
and
C
;
.
This
results
in

0
=
fC

;
C

;
C
;
;
C
;
g.
The
SLD-tree
for

0
[
f 
P
(x;
y
)g
is
sho
wn
in
the
middle
of
gure
..
In
this
tree,
the
negativ
e
example
is
directly
connected
to
the
ro
ot,
via
the
branc
h
that
uses
C
;
.
No
w
the
negativ
e
example
can
b
e
pruned
from
the
tree
b
y
deleting
C
;
from

0
,
whic
h
do
es
not
aect
the

An
SLD-tree
for

[
fGg
is
a
tree
con
taining
all
SLD-deriv
ations
from

[
fGg
with
the
goal
G
as
top
clause,
in
whic
h
the
selected
atoms
are
selected
b
y
some
computation
rule.
See
[Llo
]
for
more
information
on
SLD-trees.

..
UNF
OLDING

p
ositiv
e
example.
Then
w
e
obtain

00
=
fC

;
C

;
C
;
g,
whic
h
is
correct
w.r.t.
E
+
and
E
 .
The
SLD-tree
for

00
[
f 
P
(x;
y
)g
is
simply
the
tree
for

0
,
after
the
righ
tmost
branc
h
has
b
een
pruned
(righ
t
of
gure
.).
The
idea
b
ehind
this
metho
d
is
the
follo
wing:
.
Unfolding
remo
v
es
some
in
ternal
no
des
from
the
SLD-tree,
for
instance,
the
in
ternal
no
de
 
Q(x;
y
)
in
the
tree
on
the
left
of
gure
..
This
tends
to
separate
the
p
ositiv
e
from
the
negativ
e
examples
and
also
brings
them
closer
to
the
ro
ot
of
the
tree.
.
If
a
negativ
e
example
hangs
directly
from
the
ro
ot
and
its
input
clause
C
is
not
used
elsewhere
in
the
tree
for
a
p
ositiv
e
example,
then
the
program
can
b
e
sp
ecialized
b
y
deleting
C
.
In
other
w
ords:
unfolding
can
transform
the
SLD-tree
in
suc
h
a
w
a
y
that
neg-
ativ
e
examples
can
b
e
pruned
b
y
deleting
clauses
from
the
program,
without
also
pruning
p
ositiv
e
examples.

Th
us
the
use
of
unfolding
as
a
sp
ecialization
to
ol
can
b
e
motiv
ated
b
y
lo
oking
at
SLD-trees
and
the
SLD-refutations
those
trees
con
tain.
In
this
c
hapter
w
e
rst
dene
UD

-sp
ecialization
and
UD

-sp
ecialization,
whic
h
emplo
y
unfolding
(eac
h
in
their
o
wn
w
a
y)
and
clause
deletion.
It
will
b
e
seen
from
some
examples
that
w
e
giv
e
later
on,
that
b
oth
of
these
sp
ecializa-
tion
metho
ds
are
incomplete:
some
sp
ecialization
problems
cannot
b
e
solv
ed
in
this
w
a
y
.
Ho
w
ev
er,
if
w
e
lo
ok
at
program
sp
ecialization
through
the
p
er-
sp
ectiv
e
of
SLD-deriv
ations
rather
than
refutations,
then
w
e
can
see
from
the
Subsumption
Theorem
for
SLD-resolution
that
subsumption
is
what
w
e
need
to
mak
e
our
sp
ecialization
tec
hnique
complete.
Th
us
in
Section
.,
w
e
de-
ne
UDS-sp
ecialization,
a
sp
ecialization
tec
hnique
based
on
Unfolding,
clause
Deletion
and
Subsumption.
W
e
pro
v
e
that
UDS-sp
ecialization
is
complete:
ev-
ery
sp
ecialization
problem
has
a
UDS-sp
ecialization
as
a
solution.
Finally
,
in
Section
.
w
e
go
in
to
the
relation
b
et
w
een
program
sp
ecialization
b
y
unfolding
and
program
generalization
b
y
in
v
erse
resolution.
.
Unfolding
In
this
section,
w
e
dene
unfolding,
whic
h
will
b
e
used
in
the
next
sections
to
solv
e
sp
ecialization
problems.
Denition
.
Let

b
e
a
denite
program,
C
=
A
 
B

;
:
:
:
;
B
n
a
denite
program
clause
in

and
B
i
the
i-th
atom
in
the
b
o
dy
of
C
.
Let
fC

;
:
:
:
;
C
m
g
b
e
the
set
of
clauses
in

whose
head
can
b
e
unied
with
B
i
.
Then
unfolding
C
up
on
B
i
in

means
constructing
the
set
U
C
;i
=
fD

;
:
:
:
;
D
m
g,
where
eac
h
D
j
is
the
resolv
en
t
of
C
j
and
C
,
using
B
i
and
the
head
of
C
j
as
the
literals
resolv
ed
up
on.


In
[BIA	,
Bos	a
],
Bostr
om
and
Idestam-Almquist
presen
t
the
algorithm
Spectre,
whic
h
implemen
ts
this
sp
ecialization
tec
hnique
for
single-predicate
learning.
In
[Bos	b
],
Spectre
i
i
is
presen
ted,
whic
h
o
v
ercomes
some
diculties
of
Spectre
concerning
recursiv
e
clauses
and
whic
h
can
b
e
applied
to
m
ultiple-predicate
learning.
Unfolding
w
as
also
imple-
men
ted
in
[A
GB	
],
com
bined
with
a
v
ersion
of
Shapiro's
Bac
ktracing
Algorithm
[Shab
].


CHAPTER
.
UNF
OLDING
Example
.
Let

consist
of
the
follo
wing
clauses:
C

=
P
(f
(x))
 
P
(x);
Q(x)
C

=
Q(x)
 
R
(x;
a)
C

=
P
(f
(a))
C

=
Q(b)
Supp
ose
w
e
w
an
t
to
unfold
C

up
on
Q(x)
in
the
program
.
fC

;
C

g
is
the
set
of
clauses
in

whose
head
can
b
e
unied
with
Q(x),
so
U
C

;
=
f(P
(f
(x))
 
P
(x);
R
(x;
a));
(P
(f
(b))
 
P
(b))g.
<
Note
that
U
C
;i
ma
y
b
e
the
empt
y
set.
This
is
the
case
if
there
is
no
program
clause
whose
head
unies
with
the
i-th
atom
in
the
b
o
dy
of
C
.
Note
also
that
an
atom
cannot
b
e
unfolded,
since
it
has
no
b
o
dy-atoms.
Using
the
set
U
C
;i
,
w
e
can
construct
a
new
program
from

in
t
w
o
w
a
ys.
The
rst
w
a
y
,
used
in
[BIA	
],
r
eplac
es
C
b
y
U
C
;i
,
th
us
obtaining
the
program
(nfC
g)
[
U
C
;i
.
The
second
w
a
y
adds
U
C
;i
to
,
without
deleting
the
unfolded
clause
C
from
the
program.
Denition
.
Let

b
e
a
denite
program
and
U
C
;i
the
set
of
clauses
con-
structed
b
y
unfolding
C
up
on
B
i
in
.
Then

u;C
;i
=
(nfC
g)
[
U
C
;i
is
called
the
typ
e

pr
o
gr
am
resulting
from
unfolding
C
up
on
B
i
in
.

u;C
;i
=

[
U
C
;i
is
called
the
typ
e

pr
o
gr
am
resulting
from
unfolding
C
up
on
B
i
in
.

In
the
next
sections,
w
e
will
see
ho
w
these
t
w
o
t
yp
es
of
unfolding
can
b
e
used
for
program
sp
ecialization.
Here
w
e
will
rst
sho
w
that
constructing
the
t
yp
e

program
preserv
es
the
least
Herbrand
mo
del
of
the
program,
while
constructing
the
t
yp
e

program
preserv
es
logical
equiv
alence,
whic
h
is
stronger.
Prop
osition
.
L
et

b
e
a
denite
pr
o
gr
am,
G
a
denite
go
al
and

u;C
;i
the
typ
e

pr
o
gr
am
r
esulting
fr
om
unfolding
C
up
on
B
i
in
.
Then

[
fGg
`
sr

i

u;C
;i
[
fGg
`
sr
.
Pro
of
(:
Supp
ose

u;C
;i
[
fGg
`
sr
.
Then
b
y
the
soundness
of
resolution,

u;C
;i
[
fGg
is
unsatisable.
It
is
easy
to
see
that

j
=

u;C
;i
.
Hence

[
fGg
is
unsatisable,
and
b
y
Theorem
.	,
w
e
ha
v
e

[
fGg
`
sr
.
):
Supp
ose

[
fGg
`
sr

and
C
(the
unfolded
clause)
is
A
 
B

;
:
:
:
;
B
i
;
:
:
:
;
B
n
,
whic
h
w
e
abbreviate
to
A
 
B

;
B
i
;
B

(where
B

=
B

;
:
:
:
;
B
i 
and
B

=
B
i+
;
:
:
:
;
B
n
).
B
i
is
the
atom
unfolded
up
on.
If
there
is
an
SLD-
refutation
of

[
fGg
in
whic
h
C
isn't
used
as
an
input
clause,
then
this
is
also
an
SLD-refutation
of

u;C
;i
[
fGg.
But
supp
ose
C
is
used
as
input
clause
in
all
SLD-refutations
of

[
fGg.
W
e
will
pro
v
e
that
from
suc
h
a
refutation,
a
refutation
of

u;C
;i
[
fGg
can
b
e
constructed.
Supp
ose
w
e
ha
v
e
a
refutation
of

[
fGg
with
goals
G
0
;
:
:
:
;
G
n
and
input
clauses
C

;
:
:
:
;
C
n
,
whic
h
uses
C
at
least
once
as
input
clause.
By
the
indep
en-
dence
of
the
computation
rule
(Theorem
	.
of
[Llo
]),
w
e
can
assume
that
for
an
y
k
,
if
C
is
the
input
clause
in
the
step
leading
from
G
k
 
to
G
k
,
then
the
instance
of
B
i
that
is
inserted
in
G
k
b
y
C
,
is
the
selected
atom
in
G
k
.
Supp
ose
the
j
-th
input
clause
is
C
.
W
e
picture
this
part
of
the
refutation
on
the
left
of
gure
..
Here
w
e
mak
e
the
follo
wing
notational
con
v
en
tions:

..
UNF
OLDING


G
j
 
,
the
(j
 )-th
goal,
is
the
goal
 
A

;
:
:
:
;
A
k
;
:
:
:
;
A
m
,
whic
h
w
e
abbreviate
to
 
A

;
A
k
;
A

.

The
input
clause
used
in
the
(j
+
)-th
step
is
C
j
+
=
A
0
 
B
0
,
where
B
0
is
an
abbreviation
of
B
0

;
:
:
:
;
B
0
r
.


j
is
an
mgu
for
A
k
and
A
(used
in
the
j
-th
resolution
step).


j
+
is
an
mgu
for
B
i

j
and
A
0
(used
in
the
(j
+
)-th
resolution
step).
.
.
.
G
j
 
= 
A

;
A
k
;
A

?
C
j
=
C
=
A
 
B

;
B
i
;
B

;

j







G
j
= 
(A

;
B

;
B
i
;
B

;
A

)
j
?
C
j
+
=
A
0
 
B
0
;

j
+







G
j
+
= 
(A

;
B

;
B
0
;
B

;
A

)
j

j
+
.
.
.
.
.
.
G
j
 
= 
A

;
A
k
;
A

?
C
0
=
(A
 
B

;
B
0
;
B

)
;

0







G
0
j
+
= 
(A

;
(B

;
B
0
;
B

)
;
A

)
0
.
.
.
Figure
.:
F
rom
the
tree
on
the
left,
w
e
can
construct
the
tree
on
the
righ
t,
using
C
0
instead
of
C
.
Since
the
(j
+
)-th
step
of
the
tree
on
the
left
of
gure
.
sho
ws
that
B
i
and
A
0
can
b
e
unied
(sa
y
,
with
mgu

),
the
clause
C
0
=
(A
 
B

;
B
0
;
B

)
(the
result
of
resolving
C
with
C
j
+
=
A
0
 
B
0
)
m
ust
b
e
in
U
C
;i
.
W
e
assume
without
loss
of
generalit
y
that
G
j
 
,
C
j
=
C
,
C
j
+
,
and
C
0
are
standardized
apart.
What
w
e
w
an
t
is
to
construct
a
tree
whic
h,
instead
of
using
C
in
the
j
-th
step,
uses
C
0
.
F
or
this,
w
e
will
sho
w
that
G
j
+
is
a
v
arian
t
of
the
goal
G
0
j
+
,
whic
h
can
b
e
deriv
ed
from
G
j
 
and
C
0
.
Then
w
e
can
replace
the
j
-th
step
(whic
h
uses
C
)
and
the
(j
+
)-th
step
b
y
one
single
step
whic
h
do
esn't
need
C
an
ymore,
but
instead
uses
C
0
.

j
+
is
an
mgu
for
A
0
and
B
i

j
and
A
0

j
=
A
0
(b
ecause
of
the
standard-
izing
apart),
so

j

j
+
is
a
unier
for
A
0
and
B
i
.

is
an
mgu
for
A
0
and
B
i
,
so
there
exists
a
substitution

suc
h
that


=

j

j
+
.
A

=
A
j

j
+
=
A
k

j

j
+
=
A
k


=
A
k

,
so

is
a
unier
for
A
and
A
k
.
This
sho
ws
that
A
and
A
k
can
b
e
unied.
Let

0
b
e
an
mgu
for
A
and
A
k
.
Let
G
0
j
+
= 
(A

;
(B

;
B
0
;
B

)
;
A

)
0
b
e
the
goal
deriv
ed
from
G
j
 
and
C
0
.
W
e
will
sho
w
that
G
j
+
and
G
0
j
+
are
v
arian
ts.
.
W
e
ha
v
e
already
sho
wn
that

is
a
unier
for
A
and
A
k
.
F
urthermore,

0
is
an
mgu
for
A
and
A
k
,
so
there
exists
a
substitution

suc
h
that

0

=

.
No
w
G
j
+
= 
(A

;
B

;
B
0
;
B

;
A

)
j

j
+
= 
(A

;
B

;
B
0
;
B

;
A

)

= 
(A

;
B

;
B
0
;
B

;
A

)

0

= 
(A

;
(B

;
B
0
;
B

)
;
A

)
0

=
G
0
j
+

.

0
is
an
mgu
for
A
k
and
A
and
A
k

=
A
k
(b
ecause
of
the
standardizing
apart),
so


0
is
a
unier
for
A
k
and
A.
F
urthermore,

j
is
an
mgu
for
A
k
and
A,
so
there
exists
a
substitution

0
suc
h
that

j

0
=


0
.


CHAPTER
.
UNF
OLDING
A
0

0
=
A
0

j

0
=
A
0


0
=
B
i


0
=
B
i

j

0
,
so

0
is
a
unier
for
A
0
and
B
i

j
.
F
urthermore,

j
+
is
an
mgu
for
A
0
and
B
i

j
,
so
there
ex-
ists
a
substitution

0
suc
h
that

j
+

0
=

0
.
No
w
w
e
ha
v
e
G
0
j
+
= 
(A

;
(B

;
B
0
;
B

)
;
A

)
0
= 
(A

;
B

;
B
0
;
B

;
A

)

0
= 
(A

;
B

;
B
0
;
B

;
A

)
j

0
= 
(A

;
(B

;
B
0
;
B

)
;
A

)
j

j
+

0
=
G
j
+

0
W
e
ha
v
e
sho
wn
that
G
j
+
=
G
0
j
+

and
G
0
j
+
=
G
j
+

0
,
so
G
j
+
and
G
0
j
+
are
v
arian
ts.
Since
G
j
+
and
G
0
j
+
are
v
arian
ts,
w
e
ha
v
e
sho
wn
that
the
t
w
o
resolution
steps
leading
from
G
j
 
to
G
j
+
can
b
e
replaced
b
y
a
single
resolution
step,
whic
h
uses
C
0
as
input
clause.
In
the
same
w
a
y
,
w
e
can
eliminate
all
other
uses
of
C
as
input
clause
in
the
rest
of
the
tree,
b
y
constructing
a
refutation
whic
h
uses
some
clause
in
U
C
;i
to
replace
a
usage
of
C
,
eac
h
time
replacing
t
w
o
resolution
steps
b
y
one
single
resolution
step.
Finally
w
e
get
an
SLD-refutation
of

[
U
C
;i
[
fGg
whic
h
do
esn't
use
C
at
all.
This
means
that
w
e
ha
v
e
in
fact
found
an
SLD-refutation
of

u;C
;i
[
fGg.

A
direct
consequence
of
the
pro
of
giv
en
ab
o
v
e,
is
the
follo
wing:
Corollary
.
L
et

b
e
a
denite
pr
o
gr
am,
G
a
denite
go
al
and

u;C
;i
the
typ
e

pr
o
gr
am
r
esulting
fr
om
unfolding
C
up
on
B
i
in
.
Supp
ose
ther
e
exists
an
SLD-r
efutation
of
length
n
of

[
fGg,
which
uses
C
r
times
as
input
clause.
Then
ther
e
exists
an
SLD-r
efutation
of
length
n
 r
of

u;C
;i
[
fGg.
In
tuitiv
ely
,
this
corollary
sho
ws
that
unfolding
mak
es
refutations
shorter.
So
unfolding
has
the
p
oten
tial
of
impro
ving
the
eciency
of
an
SLD-based
theorem
pro
v
er.
Esp
ecially
unfolding
often-used
clauses
is
w
orth
while,
since
then
the
v
alue
r
men
tioned
in
the
corollary
is
highest.
On
the
other
hand,
unfolding
usually
increases
the
n
um
b
er
of
clauses.
So
what
w
e
see
here
is
an
in
teresting
trade-o
b
et
w
een
the
n
um
b
er
of
clauses
and
the
a
v
erage
length
of
a
refutation:
unfolding
usually
decreases
the
a
v
erage
length
of
a
refutation,
but
also
usually
increases
the
n
um
b
er
of
clauses
in
the
program.
W
e
no
w
pro
ceed
to
pro
v
e
that
constructing
the
t
yp
e

program
preserv
es
the
least
Herbrand
mo
del
M

of
the
program.
This
is
also
pro
v
ed
in
[TS],
though
dieren
tly
from
our
pro
of.
Theorem
.
L
et

b
e
a
denite
pr
o
gr
am,
C


and

u;C
;i
the
typ
e

pr
o
gr
am
r
esulting
fr
om
unfolding
C
up
on
B
i
in
.
Then
M

=
M

u;C;i
.
Pro
of
Let
A
b
e
some
ground
atom.
Then:
A

M

i
(b
y
Theorem
A.)

j
=
A
i
(b
y
Prop
osition
A.)

[
f 
Ag
is
unsatisable
i
(b
y
Theorem
.	)

[
f 
Ag
`
sr

i
(b
y
Prop
osition
.)

u;C
;i
[
f 
Ag
`
sr

i
(b
y
Theorem
.	)

u;C
;i
[
f 
Ag
is
unsatisable
i
(b
y
Prop
osition
A.)

u;C
;i
j
=
A
i
(b
y
Theorem
A.)
A

M

u;C;i
.

..
UD

-SPECIALIZA
TION

Hence
M

=
M

u;C;i
.

Th
us
constructing
the
t
yp
e

program
preserv
es
the
least
Herbrand
mo
del.
Ho
w
ev
er,
it
do
es
not
preserv
e
logical
equiv
alence.
T
ak
e
for
instance

=
fC
=
P
(f
(x))
 
P
(x)g.
Then

u;C
;
=
fP
(f

(x))
 
P
(x)g.
No
w
M

=
M

u;C;
=
;,
but

,

u;C
;
since

u;C
;
j
=
.
Note
that
this
means
that
a
sp
ecialization
of

need
not
b
e
a
sp
ecialization
of

u;C
;i
.
This
is
actually
one
of
the
reasons
for
the
fact
that
t
yp
e

unfolding
and
clause
deletion
cannot
solv
e
all
sp
ecialization
problems
(see
Section
.).
On
the
other
hand,
constructing
the
t
yp
e

program
do
es
preserv
e
logical
equiv
alence.
Since



u;C
;i
w
e
ha
v
e

u;C
;i
j
=
;
and
b
ecause

u;C
;i
n
is
a
set
of
resolv
en
ts
of
clauses
in
,
w
e
also
ha
v
e

j
=

u;C
;i
.
Prop
osition
.
L
et

b
e
a
denite
pr
o
gr
am,
C


and

u;C
;i
the
typ
e

pr
o
gr
am
r
esulting
fr
om
unfolding
C
up
on
B
i
in
.
Then

,

u;C
;i
.
.
UD

-sp
ecialization
As
w
e
ha
v
e
seen
in
the
in
tro
duction,
unfolding
together
with
clause
deletion
can
b
e
used
to
solv
e
some
sp
ecialization
problems.
In
this
section
w
e
formalize
this
in
a
metho
d
called
UD

-sp
ecialization.
The
name
is
an
acron
ym
for
Unfolding
and
clause
Deletion,
the
`'
indicates
that
w
e
use
the
t
yp
e

program
resulting
from
unfolding
here.
UD

-sp
ecialization
corresp
onds
to
the
approac
h
tak
en
in
[BIA	
].
Denition
.
Let

and

0
b
e
denite
programs.
W
e
sa
y

0
is
a
UD

-
sp
e
cialization
of
,
if
there
exists
a
sequence


=
;


;
:
:
:
;

n
=

0
(n

)
of
denite
programs,
suc
h
that
for
eac
h
j
=
;
:
:
:
;
n
 ,
either
.

j
+
=

j
u;C;i
.
.

j
+
=

j
nfC
g
for
some
C


j
.

If

j
+
=

j
u;C;i
,
then
eac
h
clause
in

j
+
is
either
in

j
,
or
a
resolv
en
t
of
t
w
o
clauses
in

j
.
Hence

j
j
=

j
+
in
this
case.
If

j
+
=

j
nfC
g,
then
clearly

j
j
=

j
+
.
Th
us
w
e
ha
v
e
the
follo
wing:
Prop
osition
.
L
et

b
e
a
denite
pr
o
gr
am
and

0
a
UD

-sp
e
cialization
of
.
Then

j
=

0
.
F
or
a
solution

0
to
a
sp
ecialization
problem,
w
e
ha
v
e
t
w
o
conditions:

j
=

0
and

0
should
b
e
correct
w.r.t.
E
+
and
E
 .
The
previous
prop
osition
sho
ws
that
a
UD

-sp
ecialization
of

alw
a
ys
satises
the
rst
condition.
Ho
w
ev
er,
the
second
condition
cannot
alw
a
ys
b
e
satised
b
y
UD

-sp
ecializa-
tion.
Tw
o
kinds
of
steps
can
b
e
tak
en
here:

j
+
can
b
e
the
result
of
un-
folding
a
clause
in

j
,
or
b
y
deleting
a
clause
from

j
.
The
rst
kind
of
step
preserv
es
the
least
Herbrand
mo
del,
the
second
kind
p
ossibly
reduces
it.
In
fact,
not
only
deleting
a
clause,
but
also
the
unfolding
step
ma
y
w
eak
en


CHAPTER
.
UNF
OLDING
the
program.
F
or
instance,
supp
ose

=
fP
(a);
(P
(x)
 
P
(f
(x)))g.
Then

0
=
fP
(a);
(P
(x)
 
P
(f

(x)))g
is
the
result
of
unfolding
P
(x)
 
P
(f
(x))
in
.
Whereas
this
unfolding
step
has
not
aected
the
least
Herbrand
mo
del|
M

=
M

0
=
fP
(a)g|it
has
indeed
made
the
program
w
eak
er:

j
=

0
,
but

0
j
=
.
Actually
,
ev
en
if
a
correct
program

0
is
implied
b
y
the
original
program
,
this

0
need
no
longer
b
e
implied
b
y
a
program

00
obtained
from

b
y
UD

-sp
ecialization.
Since
further
UD

-sp
ecializations
of

00
can
only
yield
pro-
grams
whic
h
are
implied
b
y

00
(and
hence
do
not
imply
the
solution

0
),
UD

-
sp
ecialization
will
not
reac
h
a
solution
of
the
sp
ecialization
problem
in
this
case.
Consider

=
f(P
(f
(x))
 
P
(x));
P
(a)g.
Let
M

=
fP
(a);
P
(f
(a));
P
(f

(a));
P
(f

(a))
:
:
:
g,
and
let
E
+
=
M

nfP
(f

(a))g
and
E
 =
fP
(f

(a))g.
See
g-
ure
..
 
P
(x)
   	

@
@
@
R


fx=ag;
+
 
P
(x)
   	

@
@
@
R


fx=f
(a)g;
+
 
P
(x)
   	

@
@
@
R


fx=f

(a)g;
  
P
(x)
   	

@
@
@
R

.
.
.

fx=f

(a)g;
+
Figure
.:
The
SLD-tree
for

[
f 
P
(x)g
Let


=
.
The
only
clause
that
can
b
e
unfolded
is
P
(f
(x))
 
P
(x).
Unfolding
this
clause
results
in


=
f(P
(f

(x))
 
P
(x));
P
(f
(a));
P
(a)g:
Then
unfolding
P
(f

(x))
 
P
(x)
giv
es


=
f(P
(f

(x))
 
P
(x));
P
(f

(a));
P
(f

(a));
P
(f
(a));
P
(a)g:
Notice
that
M


=
M


=
M


,
but
unfolding
has
nev
ertheless
w
eak
ened
the
program:


j
=


j
=


,
but


j
=


and


j
=


.
In


,
P
(f

(x))
 
P
(x)
can
b
e
unfolded,
etc.
It
is
not
dicult
to
see
that
in
general,
an
y
UD

-
sp
ecialization
of

is
a
subset
of
fP
(f

n
(x))
 
P
(x));
P
(f

n
 
(a));
P
(f

n
 
(a));
:
:
:
;
P
(f

(a));
P
(f
(a));
P
(a)g;
for
some
n.
In
order
to
sp
ecialize
this
program
suc
h
that
P
(f

(a))
is
no
longer
deriv
able,
w
e
m
ust
in
an
y
case
remo
v
e
P
(f

(a)).
Ho
w
ev
er,
this
w
ould
also
prune
some
of
the
p
ositiv
e
examples
(suc
h
as
P
(f

n
+
(a)))
from
the
program

..
UD

-SPECIALIZA
TION

via
the
clause
P
(f

n
(x))
 
P
(x).
Hence
there
is
no
UD

-sp
ecialization
that
solv
es
this
particular
sp
ecialization
problem.
Note
that

00
=
f(P
(f

(x))
 
P
(x));
(P
(f

(x))
 
P
(x));
P
(f
(a));
P
(a)g
is
a
solution
for
this
particular
sp
ecialization
problem.

j
=

00
,
but
the
sp
e-
cializations


;


;
:
:
:
no
longer
imply
this
correct
program

00
.
So
in
this
case,
UD

-sp
ecialization
has
\skipp
ed"
o
v
er
the
righ
t
solution.
In
the
next
section,
w
e
will
sho
w
ho
w
this
can
b
e
solv
ed
b
y
UD

-sp
ecialization.
.
UD

-sp
ecialization
The
previous
example
sho
w
ed
the
incompleteness
of
UD

-sp
ecialization.
But
supp
ose
w
e
c
hange
our
strategy
,
suc
h
that
the
unfolded
clause
is
not
remo
v
ed
immediately
from
the
program.
That
is,
supp
ose
w
e
use
t
yp
e

instead
of
t
yp
e

unfolding.
This
increases
the
n
um
b
er
of
clauses
that
can
later
on
b
e
used
in
unfolding.
In
this
case,
w
e
c
an
nd
a
correct
sp
ecialization
w.r.t.
the
examples
giv
en
in
Section
.,
as
follo
ws.
W
e
start
with

0

=
,
and
unfold
P
(f
(x))
 
P
(x)
without
remo
ving
the
unfolded
clause.
This
giv
es

0

:

0

=
f(P
(f

(x))
 
P
(x));
(P
(f
(x))
 
P
(x));
P
(f
(a));
P
(a)g:
No
w
w
e
unfold
P
(f

(x))
 
P
(x),
again
without
remo
ving
the
unfolded
clause.
This
giv
es

0

:

0

=
f(P
(f

(x))
 
P
(x));
(P
(f

(x))
 
P
(x));
(P
(f

(x))
 
P
(x));
(P
(f
(x))
 
P
(x));
P
(f

(a));
P
(f

(a));
P
(f
(a));
P
(a)g:
If
w
e
remo
v
e
(P
(f

(x))
 
P
(x)),
(P
(f
(x))
 
P
(x)),
P
(f

(a))
and
P
(f

(a))
from

0

,
w
e
obtain

00
:

00
=
f(P
(f

(x))
 
P
(x));
(P
(f

(x))
 
P
(x));
P
(f
(a));
P
(a)g:
This
is
a
correct
sp
ecialization
of

w.r.t.
E
+
and
E
 :

00
j
=
E
+
and

00
j
=
P
(f

(a)).
This
example
induces
a
second
kind
of
sp
ecialization,
UD

-sp
ecialization,
whic
h
diers
from
UD

-sp
ecialization
in
the
use
of
t
yp
e

unfolding
instead
of
t
yp
e

unfolding.

Denition
.
Let

and

0
b
e
denite
programs.
W
e
sa
y

0
is
a
UD

-
sp
e
cialization
of
,
if
there
exists
a
sequence


=
;


;
:
:
:
;

n
=

0
(n

)
of
denite
programs,
suc
h
that
for
eac
h
j
=
;
:
:
:
;
n
 ,
either
.

j
+
=

j
u;C;i
.

Henrik
Bostr
om
(p
ersonal
comm
unication)
made
us
a
w
are
of
the
fact
that
the
co
v
ering
algorithm
of
[Bos	a
],
with
whic
h
his
unfolding-algorithm
Spectre
is
compared,
is
in
fact
equiv
alen
t
to
our
UD

-sp
ecialization.
He
also
ga
v
e
an
example
of
a
solution
of
a
sp
ecialization
problem
whic
h
could
b
e
found
b
y
the
co
v
ering
algorithm,
though
not
b
y
Spectre,
b
ecause
the
h
yp
othesis-space
of
Spectre
is
a
prop
er
subset
of
the
h
yp
othesis-space
of
the
co
v
ering
algorithm.


CHAPTER
.
UNF
OLDING
.

j
+
=

j
nfC
g
for
some
C


j
.

Note
that
an
y
UD

-sp
ecialization
is
also
a
UD

-sp
ecialization,
since
obtaining
the
t
yp
e

program
and
then
remo
ving
the
unfolded
clause
in
the
next
step
is
equiv
alen
t
to
obtaining
the
t
yp
e

program.
The
follo
wing
prop
osition
is
ob
vious:
Prop
osition
.
L
et

b
e
a
denite
pr
o
gr
am
and

0
a
UD

-sp
e
cialization
of
.
Then

j
=

0
.
Since
an
y
UD

-sp
ecialization
is
a
UD

-sp
ecialization,
while
some
UD

-sp
ecia-
lizations
cannot
b
e
found
with
UD

-sp
ecialization
(see
the
example
ab
o
v
e),
UD

-sp
ecialization
is
\more
complete"
than
UD

-sp
ecialization.
Unfortunately
,
UD

-sp
ecialization
is
still
not
sucien
tly
strong
to
pro
vide
a
solution
for
all
sp
ecialization
problems.
Consider
the
follo
wing:

=
fP
(x)g,
E
+
=
fP
(f
(a));
P
(f

(a))g
and
E
 =
fP
(a)g.

0
=
fP
(f
(x))g
is
a
solution
for
this
sp
ecializa-
tion
problem.
Ho
w
ev
er,
no
solution
can
b
e
found
b
y
UD

-sp
ecialization.
Since

con
tains
only
a
single
atom,
no
unfolding
can
tak
e
place
here.
Hence
the
only
UD

-sp
ecializations
of

are

itself
and
the
empt
y
set,
neither
of
whic
h
is
correct.
So
some
sp
ecialization
problems
do
not
ha
v
e
a
UD

-sp
ecialization
as
a
solution.
.
UDS-sp
ecialization
In
order
to
extend
UD

-sp
ecialization
to
a
metho
d
whic
h
can
solv
e
all
sp
e-
cialization
problems,
w
e
ha
v
e
to
allo
w
the
p
ossibilit
y
of
taking
a
subsumption
step.

In
general,
w
e
can
dene
UDS-sp
ecialization
(Unfolding,
clause
Deletion,
Subsumption)
as
follo
ws:
Denition
.
Let

and

0
b
e
denite
programs.
W
e
sa
y

0
is
a
UDS-
sp
e
cialization
of
,
if
there
exists
a
sequence


=
;


;
:
:
:
;

n
=

0
(n

)
of
denite
programs,
suc
h
that
for
eac
h
j
=
;
:
:
:
;
n
 ,
one
of
the
follo
wing
holds:
.

j
+
=

j
u;C;i
.
.

j
+
=

j
nfC
g
for
some
C


j
.
.

j
+
=

j
[
fC
g
for
a
C
that
is
subsumed
b
y
a
clause
in

j
.

UDS-sp
ecialization
is
indeed
complete:
an
y
sp
ecialization
problem
has
a
UDS-
sp
ecialization
as
solution.
F
or
the
pro
of
of
completeness,
w
e
use
the
Subsump-
tion
Theorem
for
SLD-resolution
(Theorem
.0).
Theorem
.
L
et

and

0
b
e
denite
pr
o
gr
ams,
such
that

0
c
ontains
no
tautolo
gies.
Then

j
=

0
i

0
is
a
UDS-sp
e
cialization
of
.

Subsumption
can
b
e
seen
as
a
solution
to
the
problem
of
ambivalent
lea
v
es
in
an
SLD-tree
[BIA	
,
Bos	b
].

..
UDS-SPECIALIZA
TION
	
Pro
of
(:
By
the
soundness
of
resolution
and
subsumption.
):
Supp
ose

j
=

0
.
Then
for
ev
ery
C


0
,
w
e
ha
v
e

j
=
C
.
Let
C
b
e
some
particular
clause
in

0
that
is
not
in
.
Then
b
y
the
Subsumption
Theorem
for
SLD-resolution,
there
exists
an
SLD-deriv
ation
from

of
a
clause
D
whic
h
subsumes
C
,
as
sho
wn
in
gure
..
R
0


?
C










R

.
.
.
R
n 
?
C
n









R
n
=
D
?
subsumes
C
Figure
.:
An
SLD-deduction
of
C
from

Since
R

is
a
resolv
en
t
of
R
0
and
C

(up
on
the
selected
atom
B
i
in
R
0
),
if
w
e
unfold
R
0
in

up
on
B
i
w
e
get
the
program

u;R
0
;i
whic
h
con
tains
R

.
No
w
when
w
e
unfold
R

in

u;R
0
;i
,
w
e
get
a
program
whic
h
con
tains
R

,
etc.
Th
us
after
n
applications
of
(t
yp
e
)
unfolding,
w
e
can
pro
duce
a
UDS-sp
ecialization
(a
sup
erset
of
)
con
taining
the
clause
R
n
=
D
.
Since
D
subsumes
C
,
w
e
can
add
C
to
the
program,
b
y
the
third
item
in
the
denition
of
UDS-sp
ecialization.
If
w
e
do
this
for
ev
ery
C


0
that
is
not
in
,
w
e
get
a
program

00
whic
h
con
tains
ev
ery
clause
in

0
.
Since

00
is
obtained
from

b
y
a
nite
n
um
b
er
of
applications
of
unfolding
and
subsumption,

00
is
a
UDS-sp
ecialization
of
.
No
w
delete
from

00
all
those
clauses
that
are
not
in

0
.
Then
w
e
obtain

0
as
a
UDS-sp
ecialization
of
.
Th
us
if

j
=

0
,
then

0
is
a
UDS-sp
ecialization
of
.

No
w
supp
ose
w
e
ha
v
e
,

0
,
E
+
and
E
 ,
suc
h
that

j
=

0
and

0
is
correct
w.r.t.
E
+
and
E
 .
W
e
can
assume

0
con
tains
no
tautologies.
Then
it
follo
ws
from
the
previous
theorem
that

0
is
a
UDS-sp
ecialization
of
.
This
sho
ws
that
UDS-sp
ecialization
is
complete:

Corollary
.
(Completeness
of
UDS-sp
ecialization)
Every
sp
e
cializa-
tion
pr
oblem
with

as
initial
pr
o
gr
am
has
a
UDS-sp
e
cialization
of

as
solution.

UDS-sp
ecialization
need
not
sp
ecialize
minimal
ly
in
the
sense
adv
o
cated
in
[W
ro	
]:
a
UDS-sp
ecialization
of
an
initial

ma
y
b
e
considerably
dieren
t
from
.
On
the
other
hand,
the
approac
h
of
[W
ro	
]
has
the
disadv
an
tage
that
eac
h
clause
in
a
sp
ecialized
theory
should
b
e
equal
to
or
subsumed
b
y
a
clause
in
the
initial

(p.
,
p
ostulate
),
whic
h
is
quite
restrictiv
e.

0
CHAPTER
.
UNF
OLDING
Eciency:
Note
that
if
w
e
w
an
t
to
unfold
some
particular
clause
C
,
w
e
actually
only
need
to
consider
the
resolv
en
ts
of
C
and
clauses
from
the
original
.
This
is
clear
from
gure
.,
since
in
order
to
pro
duce
R
i+
,
w
e
only
need
to
resolv
e
R
i
with
C
i+
,
whic
h
is
a
mem
b
er
of
the
original
.
In
other
w
ords,
w
e
only
need
to
add
a
subset
of
U
C
;i
to
the
program.
W
e
migh
t
dene
U
0
C
;i
as
the
set
of
resolv
en
ts
up
on
B
i
of
C
and
clauses
from
the
original

and
then
use

j
+
=

j
[
U
0
C
;i
instead
of

j
+
=

j
u;C;i
=

j
[
U
C
;i
.
This
reduces
the
n
um
b
er
of
clauses
that
unfolding
pro
duces,
and
hence
impro
v
es
eciency
.
.
Relation
with
in
v
erse
resolution
As
w
e
ha
v
e
already
seen
in
Chapter
,
there
are
basically
t
w
o
p
ossible
ap-
proac
hes
in
ILP
.
W
e
ha
v
e
the
top-down
approac
h
(of
whic
h
UDS-sp
ecialization
is
an
example)
whic
h
starts
with
an
o
v
erly
general
program
and
sp
ecializes
this,
and
the
b
ottom-up
approac
h,
whic
h
starts
with
an
o
v
erly
sp
ecic
program
and
generalizes
this.
There
is
an
in
teresting
relation
b
et
w
een
our
previous
analysis
of
program
sp
ecialization
on
the
one
hand,
and
program
generalization
b
y
in-
verse
r
esolution
(see
for
instance
[MB
,
Mug	a
,
Rou	
,
SA	
])
on
the
other
hand.
The
in
v
ersion
of
resolution
is
a
w
ell-kno
wn
approac
h
to
w
ards
generaliza-
tion
in
ILP
.
Here
the
in
v
ersion
of
a
resolution
step
can
b
e
view
ed
as
the
dual
of
unfolding.
Ho
w
ev
er,
in
the
same
w
a
y
as
sp
ecialization
b
y
unfolding
is
not
complete
without
subsumption,
its
dual
also
needs
(the
in
v
ersion
of
)
subsumption.
Most
researc
h
in
in
v
erse
resolution
has
fo
cused
on
in
v
erting
resolution
steps,
mostly
ignoring
the
in
v
ersion
of
the
nal
subsumption
step.
By
the
previous
analysis,
in
v
erting
a
subsumption
step
will
b
e
necessary
for
completeness.
F
or
example,
w
e
cannot
generalize

=
fP
(f
(x))g
to

0
=
fP
(x)g
just
b
y
in
v
erting
resolution
steps.
.
Summary
The
sp
e
cialization
pr
oblem,
a
sp
ecial
case
of
the
general
problem
setting
for
ILP
,
can
b
e
stated
as
follo
ws:
Giv
en:
A
denite
program

and
t
w
o
disjoin
t
sets
of
ground
atoms
E
+
and
E
 ,
suc
h
that

is
o
v
erly
general
w.r.t.
E
+
and
E
 ,
and
supp
ose
there
exists
a
denite
program

0
suc
h
that

j
=

0
and

0
is
correct
w.r.t.
E
+
and
E
 .
Find:
One
suc
h
a

0
.
Unfolding,
constructing
the
set
U
C
;i
of
resolv
en
ts
of
a
clause
C


with
clauses
in
,
can
b
e
used
as
a
to
ol
for
solving
suc
h
problems.
The
t
yp
e

program
is
obtained
b
y
replacing
C
in

b
y
U
C
;i
,
while
the
t
yp
e

program
is

[
U
C
;i
.
Constructing
the
t
yp
e

program
preserv
es
the
least
Herband
mo
del,
while
the
t
yp
e

program
preserv
es
logical
equiv
alence
with
the
original
program.

..
SUMMAR
Y

W
e
dened
three
increasingly
strong
sp
ecialization
tec
hniques
here.
UD

-
and
UD

-sp
ecialization
emplo
y
clause
deletion
and,
resp
ectiv
ely
,
the
t
yp
e

and
t
yp
e

programs
resulting
from
unfolding.
Both
are
incomplete.
If
w
e
add
to
UD

-sp
ecialization
the
p
ossibilit
y
of
taking
a
subsumption
step,
w
e
obtain
UDS-
sp
ecialization.
This
is
a
complete
sp
ecialization
metho
d:
ev
ery
sp
ecialization
problem
with

as
initial
program
has
a
UDS-sp
ecialization
of

as
solution.


CHAPTER
.
UNF
OLDING

Chapter

Least
Generalizations
and
Greatest
Sp
ecializations
.
In
tro
duction
Inductiv
e
Logic
Programming
is
concerned
with
learning
from
examples.
Learn-
ing
from
examples
means
adjusting
a
theory
to
the
examples.
As
w
e
ha
v
e
seen
in
Chapter
,
the
t
w
o
main
op
erations
in
ILP
for
adjustmen
t
of
a
theory
,
are
gener
alization
and
sp
e
cialization.
Generalization
strengthens
a
theory
that
is
to
o
w
eak,
while
sp
ecialization
w
eak
ens
a
theory
that
is
to
o
strong.
These
op-
erations
only
mak
e
sense
within
a
gener
ality
or
der,
whic
h
is
a
relation
stating
when
some
clause
is
more
general
than
some
other
clause.
The
three
most
imp
ortan
t
generalit
y
orders
used
in
ILP
are
subsumption
(also
called

-subsumption),
logical
implication
and
implication
relativ
e
to
bac
k-
ground
kno
wledge.

In
the
subsumption
order,
w
e
sa
y
that
clause
C
is
more
general
than
D
|or,
equiv
alen
tly
,
D
is
more
sp
ecic
than
C
|in
case
C
sub-
sumes
D
.
In
the
implication
order,
w
e
sa
y
that
C
is
more
general
than
D
if
C
logically
implies
D
.
Finally
,
C
is
more
general
than
D
relativ
e
to
bac
kground
kno
wledge

(
is
a
set
of
clauses),
if
fC
g
[

logically
implies
D
.
Of
these
three
orders,
subsumption
is
the
most
tractable.
In
particular,
subsumption
is
decidable,
whereas
logical
implication
is
not
decidable,
not
ev
en
for
Horn
clauses,
as
established
in
[MP	
].
In
turn,
relativ
e
implication
is
harder
than
implication:
b
oth
are
undecidable,
but
pro
of
pro
cedures
for
implication
need
to
tak
e
only
deriv
ations
from
C
in
to
accoun
t,
whereas
a
pro
of
pro
cedure
for
r
elative
implication
should
c
hec
k
all
deriv
ations
from
fC
g
[
.
Within
a
generalit
y
order,
there
are
t
w
o
approac
hes
to
generalization
or
sp
ecialization.
The
rst
approac
h
generalizes
or
sp
ecializes
individual
clauses.
W
e
will
not
discuss
this
in
an
y
detail
in
this
c
hapter,
and
only
men
tion
it
for
completeness'
sak
e.
This
approac
h
can
b
e
traced
bac
k
to
Reynolds'
concept
of
a
c
over
[Rey0
].
It
w
as
implemen
ted
for
example
b
y
Shapiro
in
the
subsumption
order,
in
the
form
of
r
enement
op
er
ators
[Shab].
Ho
w
ev
er,
a
clause
C
whic
h
implies
another
clause
D
need
not
subsume
this
D
.
F
or
instance,
tak
e
C
=
P
(f
(x))
 
P
(x)
and
D
=
P
(f

(x))
 
P
(x).
Then
C
do
es
not
subsume
D
,

There
is
also
relativ
e
subsumption
[Plob
],
whic
h
will
b
e
briey
touc
hed
in
Section
..



GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
but
C
j
=
D
.
Th
us
subsumption
is
w
eak
er
than
implication.
A
further
sign
of
this
w
eakness
is
the
fact
that
tautologies
need
not
b
e
subsume-equiv
alen
t,
ev
en
though
they
are
logically
equiv
alen
t.
The
second
approac
h
generalizes
or
sp
ecializes
sets
of
clauses.
This
is
the
approac
h
w
e
will
b
e
concerned
with
in
this
c
hapter.
Here
the
concept
of
a
le
ast
gener
alization

is
imp
ortan
t.
The
use
of
suc
h
le
ast
generalizations
allo
ws
us
to
generalize
cautiously
,
a
v
oiding
o
v
er-generalization.
Least
generalizations
of
sets
of
clauses
w
ere
rst
discussed
b
y
Plotkin
[Plo0
,
Ploa
,
Plob].
He
pro
v
ed
that
an
y
nite
set
S
of
clauses
has
a
least
generalization
under
subsumption
(LGS).
This
is
a
clause
whic
h
subsumes
all
clauses
in
S
and
whic
h
is
subsumed
b
y
all
other
clauses
that
also
subsume
all
clauses
in
S
.
P
ositiv
e
examples
can
b
e
generalized
b
y
taking
their
LGS.

Of
course,
w
e
need
not
tak
e
an
LGS
of
al
l
p
ositiv
e
examples,
whic
h
w
ould
yield
a
theory
consisting
of
only
one
clause.
Instead,
w
e
migh
t
divide
the
p
ositiv
e
examples
in
to
subsets,
and
tak
e
a
separate
LGS
of
eac
h
subset.
That
w
a
y
w
e
obtain
a
theory
con
taining
more
than
one
clause.
F
or
this
second
approac
h,
subsumption
is
again
not
fully
satisfactory
.
F
or
example,
if
S
consists
of
the
clauses
D

=
P
(f

(a))
 
P
(a)
and
D

=
P
(f
(b))
 
P
(b),
then
the
LGS
of
S
is
P
(f
(y
))
 
P
(x).
The
clause
P
(f
(x))
 
P
(x),
whic
h
seems
more
appropriate
as
a
least
generalization
of
S
,
cannot
b
e
found
b
y
Plotkin's
approac
h,
b
ecause
it
do
es
not
subsume
D

.
As
this
exam-
ple
also
sho
ws,
the
subsumption
order
is
particularly
unsatisfactory
when
w
e
consider
r
e
cursive
clauses:
clauses
whic
h
can
b
e
resolv
ed
with
themselv
es.
Because
of
the
w
eakness
of
subsumption,
it
is
desirable
to
mak
e
the
step
from
the
subsumption
order
to
the
more
p
o
w
erful
implication
order.
Accord-
ingly
,
it
is
imp
ortan
t
to
nd
out
whether
Plotkin's
p
ositiv
e
result
on
the
exis-
tence
of
LGS's
also
holds
for
implication.
Th
us
the
question
whether
an
y
nite
set
of
clauses
has
a
least
generalization
under
implication
(LGI),
has
b
een
de-
v
oted
quite
a
lot
of
atten
tion
recen
tly
.
Sofar,
this
question
has
only
b
een
partly
answ
ered.
F
or
instance,
Idestam-Almquist
[IA	
,
IA	
]
studies
least
general-
izations
under
T-implic
ation
as
an
appro
ximation
to
LGI's.
Muggleton
and
P
age
[MP	
]
in
v
estigate
self-satur
ate
d
clauses.
A
clause
is
self-saturated
if
it
is
subsumed
b
y
an
y
clause
whic
h
implies
it.
A
clause
D
is
a
self-saturation
of
C
,
if
C
and
D
are
logically
equiv
alen
t
and
D
is
self-saturated.
As
stated
in
[MP	
],
if
t
w
o
clauses
C

and
C

ha
v
e
self-saturations
D

and
D

,
then
an
LGS
of
D

and
D

is
also
an
LGI
of
C

and
C

.
This
answ
ers
our
question
concerning
the
existence
of
LGI's
for
clauses
whic
h
ha
v
e
a
self-saturation.
Ho
w
ev
er,
Muggleton
and
P
age
also
sho
w
that
there
exist
clauses
whic
h
ha
v
e
no
self-saturation.
So
the
concept
of
self-saturation
cannot
solv
e
our
question
in
general.
Use
of
the
third
generalit
y
order,
relativ
e
implication,
is
ev
en
more
desirable
than
the
use
of
\plain"
implication.
Relativ
e
implication
allo
ws
us
to
tak
e
bac
kground
kno
wledge
in
to
accoun
t,
whic
h
can
b
e
used
to
formalize
man
y
useful
prop
erties
and
relations
of
the
domain
of
application.
F
or
this
reason,
least

Least
generalizations
are
often
called
least
gener
al
generalizations,
for
instance
in
[Plob
,
MP	
,
IA	,
IA	,
Nib
],
though
not
in
[Plo0
],
but
w
e
feel
this
`general'
is
redundan
t.

There
is
also
a
relation
b
et
w
een
least
generalization
under
subsumption
and
inverse
r
es-
olution
[Mug	a
].

..
INTR
ODUCTION

generalizations
under
implication
relativ
e
to
bac
kground
kno
wledge
also
deserv
e
atten
tion.
Apart
from
the
least
generalization,
there
is
also
its
dual:
the
gr
e
atest
sp
e-
cialization.
Greatest
sp
ecializations
ha
v
e
b
een
accorded
m
uc
h
less
atten
tion
in
ILP
than
least
generalizations,
but
the
concept
of
a
greatest
sp
ecialization
ma
y
nev
ertheless
b
e
useful
(see
the
b
eginning
of
Section
.).
In
this
c
hapter,
w
e
giv
e
a
systematic
treatmen
t
of
the
existence
and
non-
existence
of
least
generalizations
and
greatest
sp
ecializations,
applied
to
eac
h
of
these
three
generalit
y
orders.
Apart
from
distinguishing
b
et
w
een
these
three
orders,
w
e
also
distinguish
b
et
w
een
languages
of
general
clauses
and
more
restricted
languages
of
Horn
clauses.
Though
most
researc
hers
in
ILP
restrict
atten
tion
to
Horn
clauses,
general
clauses
are
also
sometimes
used
[Plo0
,
Plob,
Shab,
DRB	
,
IA	
,
IA	
].
Moreo
v
er,
man
y
researc
hers
who
do
not
use
general
clauses
actually
allo
w
negativ
e
literals
to
app
ear
in
the
b
o
dy
of
a
clause.
That
is,
they
use
clauses
of
the
form
A
 
L

;
:
:
:
;
L
n
,
where
A
is
an
atom
and
eac
h
L
i
is
a
literal.
These
are
called
pr
o
gr
am
clauses
[Llo].
Program
clauses
are
in
fact
logically
equiv
alen
t
to
general
clauses.
F
or
instance,
the
program
clause
P
(x)
 
Q(x);
:R
(x)
is
equiv
alen
t
to
the
non-Horn
clause
P
(x)
_
:Q(x)
_
R
(x).
F
or
these
t
w
o
reasons,
w
e
consider
not
only
languages
of
Horn
clauses,
but
also
pa
y
atten
tion
to
languages
of
general
clauses.
The
com
bination
of
three
generalit
y
orders
and
t
w
o
dieren
t
p
ossible
lan-
guages
of
clauses
giv
es
a
total
of
six
dieren
t
ordered
languages.
F
or
eac
h
of
these,
w
e
can
ask
whether
least
generalizations
(LG's)
and
greatest
sp
ecializa-
tions
(GS's)
alw
a
ys
exist.
W
e
surv
ey
results
already
obtained
b
y
others
and
also
con
tribute
some
answ
ers
of
our
o
wn.
F
or
the
sak
e
of
clarit
y
,
w
e
will
summarize
the
results
of
our
surv
ey
righ
t
at
the
outset.
In
the
follo
wing
table
`+'
signies
a
p
ositiv
e
answ
er,
` '
means
a
negativ
e
answ
er.
Horn
clauses
General
clauses
Quasi-order
LG
GS
LG
GS
Subsumption
()
+
+
+
+
Implication
(j
=)
  +
for
function-free
+
Relativ
e
implication
(j
=

)
   +
T
able
.:
Existence
of
LG's
and
GS's
Our
o
wn
con
tributions
to
this
table
are
threefold.
First
and
foremost,
w
e
pro
v
e
that
if
S
is
a
nite
set
of
clauses
con
taining
at
least
one
non-tautologous
function-free
clause

(apart
from
this
non-tautologous
function-free
clause,
S
ma
y
con
tain
an
arbitrary
nite
n
um
b
er
of
other
clauses,
including
clauses
whic
h
con
tain
functions),
then
there
exists
a
computable
LGI
of
S
.
This
result
is
on
the
one
hand
based
on
the
Subsumption
Theorem,
whic
h
allo
ws
us
to
restrict
atten
tion
to
nite
sets
of
ground
instances
of
clauses
and
on
the
other
hand
on
a
mo
dication
of
some
pro
ofs
concerning
T-implication
whic
h
can
b
e
found
in
[IA	
,
IA	
].
An
immediate
corollary
of
this
result
is
the
existence
and
computabilit
y
of
an
LGI
of
an
y
nite
set
of
function-free
clauses.
As
far
as
w
e

A
clause
whic
h
only
con
tains
constan
ts
and
v
ariables
as
terms.


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
kno
w,
b
oth
our
general
LGI-result
and
this
particular
corollary
are
new
results.
Niblett
[Nib,
p.
]
claims
that
\it
is
simple
to
sho
w
that
there
are
lggs
if
the
language
is
restricted
to
a
xed
set
of
constan
t
sym
b
ols
since
all
Herbrand
in
terpretations
are
nite."
Y
et
ev
en
for
this
sp
ecial
case
of
our
general
result,
it
app
ears
that
no
pro
of
has
b
een
published.
Initially
,
w
e
found
a
direct
pro
of
of
this
case,
but
this
w
as
not
really
an
y
simpler
than
the
pro
of
of
the
more
general
result
that
w
e
giv
e
in
this
c
hapter.
Niblett's
idea
that
the
pro
of
is
simple
ma
y
b
e
due
to
some
confusion
ab
out
the
relation
b
et
w
een
Herbrand
mo
dels
and
logical
implication
(whic
h
is
dened
in
terms
of
al
l
mo
dels,
not
just
Herbrand
mo
dels).
W
e
will
describ
e
this
at
the
end
of
Subsection
...
Or
p
erhaps
one
migh
t
think
that
the
decidabilit
y
of
implication
for
function-free
clauses
immediately
implies
the
existence
of
an
LGI.
But
in
fact,
decidabilit
y
is
not
a
sucien
t
condition
for
the
existence
of
a
least
generalization.
F
or
example,
it
is
decidable
whether
one
function-free
clause
C
implies
another
function-free
clause
D
relativ
e
to
function-free
bac
kground
kno
wledge.
Y
et
least
generalizations
relativ
e
to
function-free
bac
kground
kno
wledge
do
not
alw
a
ys
exist,
as
w
e
will
sho
w
in
Section
..
Our
LGI-result
do
es
not
solv
e
the
general
question
of
the
existence
of
LGI's,
but
it
do
es
pro
vide
a
p
ositiv
e
answ
er
for
a
large
class
of
cases:
the
presence
of
one
non-tautologous
function-free
clause
in
a
nite
S
already
guaran
tees
the
existence
and
computabilit
y
of
an
LGI
of
S
,
no
matter
what
other
clauses
S
con
tains.

Because
of
the
prominence
of
function-free
clauses
in
ILP
,
this
case
ma
y
b
e
of
great
practical
signifcance.
Often,
in
particular
in
implemen
tations
of
ILP-systems,
the
language
is
required
to
b
e
function-free,
or
function
sym
b
ols
are
remo
v
ed
from
clauses
and
put
in
the
bac
kground
kno
wledge
b
y
tec
hniques
suc
h
as
attening
[Rou	
].
W
ell-kno
wn
ILP-systems
suc
h
as
F
oil
[QCJ	],
Linus
[LD	
]
and
Mobal
[MWKE	
]
all
use
only
function-free
clauses.
More
than
one
half
of
the
ILP-systems
surv
ey
ed
b
y
Da
vid
Aha
[Aha	
]
is
restricted
to
function-free
clauses.
F
unction-free
clauses
are
also
sucien
t
for
most
appli-
cations
concerning
databases.
Our
second
con
tribution
sho
ws
that
a
set
S
need
not
ha
v
e
a
least
general-
ization
relativ
e
to
some
bac
kground
kno
wledge
,
not
ev
en
when
S
and

are
b
oth
function-free.
Thirdly
,
w
e
con
tribute
a
complete
discussion
of
existence
and
non-existence
of
greatest
sp
ecializations
in
eac
h
of
the
six
ordered
languages.
In
particular,
w
e
sho
w
that
an
y
nite
set
of
clauses
has
a
greatest
sp
ecialization
under
impli-
cation.
Com
bining
this
with
the
corollary
of
our
result
on
LGI's,
it
follo
ws
that
a
function-free
clausal
language
is
a
lattic
e.

Note
that
ev
en
for
function-free
clauses,
the
subsumption
order
is
still
not
enough.
Con-
sider
D

=
P
(x;
y
;
z
)
 
P
(y
;
z
;
x)
and
D

=
P
(x;
y
;
z
)
 
P
(z
;
x;
y
).
D

is
a
resolv
en
t
of
D

and
D

and
D

is
a
resolv
en
t
of
D

and
D

.
Hence
D

and
D

are
logically
equiv
alen
t.
This
means
that
D

is
an
LGI
of
the
set
fD

;
D

g.
Ho
w
ev
er,
the
LGS
of
these
t
w
o
clauses
is
P
(x;
y
;
z
)
 
P
(u;
v
;
w
),
whic
h
is
clearly
an
o
v
er-generalization.

..
PRELIMINARIES

.
Preliminaries
In
this
c
hapter,
it
will
b
e
con
v
enien
t
to
ignore
the
order
and
p
ossible
duplication
of
literals
in
a
clause.
Clearly
,
this
order
and
duplication
do
es
not
aect
the
truth-v
alue
of
a
clause.
Th
us
P
(x)
_
Q(x)
_
P
(x)
and
Q(x)
_
Q(x)
_
P
(x)
can
b
oth
b
e
considered
as
the
same
clause
P
(x)
_
Q(x).
The
union
C
[
D
of
t
w
o
clauses
denotes
a
clause
whic
h
con
tains
ev
ery
literal
in
C
and
D
.
The
t
w
o
languages
of
clauses
that
will
b
e
considered
in
this
c
hapter
are
the
follo
wing:
Denition
.
Let
A
b
e
an
alphab
et
of
the
rst-order
logic.
Then
the
clausal
language
C
by
A
is
the
set
of
all
clauses
whic
h
can
b
e
constructed
from
the
sym
b
ols
in
A.
The
Horn
language
H
by
A
is
the
set
of
all
Horn
clauses
whic
h
can
b
e
constructed
from
the
sym
b
ols
in
A.

Here
w
e
just
presupp
ose
some
arbitrary
alphab
et
A,
and
consider
the
clausal
language
C
and
Horn
language
H
based
on
this
A.
Three
increasingly
strong
generalit
y
orders
on
clauses
are
subsumption,
im-
plication
and
r
elative
implication.
Belo
w
w
e
rep
eat
the
denitions
of
subsump-
tion
and
implication,
and
in
tro
duce
the
denition
of
relativ
e
implication.
Denition
.
Let
C
and
D
b
e
clauses
and

b
e
a
set
of
clauses.
W
e
sa
y
that
C
subsumes
D
,
denoted
as
C

D
,
if
there
exists
a
substitution

suc
h
that
C


D
.

C
and
D
are
subsume-e
quivalent
if
C

D
and
D

C
.

(lo
gic
al
ly)
implies
C
,
denoted
as

j
=
C
,
if
ev
ery
mo
del
of

is
also
a
mo
del
of
C
.
C
(lo
gic
al
ly)
implies
D
,
denoted
as
C
j
=
D
,
if
fC
g
j
=
D
.
C
and
D
are
(lo
gic
al
ly)
e
quivalent
if
C
j
=
D
and
D
j
=
C
.
C
implies
D
r
elative
to
,
denoted
as
C
j
=

D
,
if

[
fC
g
j
=
D
.
C
and
D
are
e
quivalent
r
elative
to

if
b
oth
C
j
=

D
and
D
j
=

C
.

If
C

D
,
then
C
j
=
D
.
The
con
v
erse
do
es
not
hold,
as
the
examples
in
the
In
tro
duction
sho
w
ed.
Similarly
,
if
C
j
=
D
,
then
C
j
=

D
,
and
again
the
con
v
erse
need
not
hold.
Consider
the
clauses
C
=
P
(a)
_
:P
(b),
D
=
P
(a)
and

=
fP
(b)g:
then
C
j
=

D
,
but
C
j
=
D
.
The
next
lemma
w
as
rst
pro
v
ed
b
y
Gottlob
[Got
].
Actually
,
it
is
an
immediate
corollary
of
the
Subsumption
Theorem:
Lemma
.
(Gottlob)
L
et
C
and
D
b
e
non-tautolo
gous
clauses.
If
C
j
=
D
,
then
C
+

D
+
and
C
 
D
 .
Pro
of
Since
C
+

C
,
if
C
j
=
D
,
then
w
e
ha
v
e
C
+
j
=
D
.
Since
C
+
cannot
b
e
resolv
ed
with
itself,
it
follo
ws
from
the
Subsumption
Theorem
that
C
+

D
.
But
then
C
+
m
ust
subsume
the
p
ositiv
e
literals
in
D
,
hence
C
+

D
+
.
Similarly
C
 
D
 .

An
imp
ortan
t
consequence
of
this
lemma
concerns
the
depth
of
clauses,
dened
as
follo
ws:

Righ
t
from
the
v
ery
rst
applications
of
subsumption
in
ILP
,
there
has
b
een
some
con-
tro
v
ersy
ab
out
the
sym
b
ol
used
for
subsumption:
Plotkin
[Plo0
]
used
`',
while
Reynolds
[Rey0]
used
`'.
W
e
use
`'
here,
similar
to
Reynolds'
`',
b
ecause
w
e
feel
it
serv
es
the
in
tuition
to
view
C
as
someho
w
\bigger"
or
\stronger"
than
D
,
if
C

D
holds.


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
Denition
.
Let
t
b
e
a
term.
If
t
is
a
v
ariable
or
constan
t,
then
the
depth
of
t
is
.
If
t
=
f
(t

;
:
:
:
;
t
n
),
n

,
then
the
depth
of
t
is

plus
the
depth
of
the
t
i
with
largest
depth.
The
depth
of
a
clause
C
is
the
depth
of
the
term
with
largest
depth
in
C
.

Example
.
The
term
t
=
f
(a;
x)
has
depth
.
C
=
P
(f
(x))
 
P
(g
(f
(x);
a))
has
depth
,
since
g
(f
(x);
a)
has
depth
.
<
It
follo
ws
from
Gottlob's
lemma
that
if
C
j
=
D
,
then
the
depth
of
C
is
smaller
than
or
equal
to
the
depth
of
D
,
for
otherwise
C
+
cannot
subsume
D
+
or
C
 cannot
subsume
D
 .
F
or
instance,
tak
e
D
=
P
(x;
f
(x;
g
(y
)))
 
P
(g
(a);
b),
whic
h
has
depth
.
Then
a
clause
C
con
taining
a
term
f
(x;
g

(y
))
(depth
)
cannot
imply
D
.
Lemma
.
L
et

b
e
a
set
of
clauses,
C
b
e
a
clause,
and

b
e
a
Skolem
substitution
for
C
w.r.t.
.
Then

j
=
C
i

j
=
C

.
Pro
of
):
Ob
vious.
(:
Supp
ose
C
is
not
a
tautology
and
let

=
fx

=a

;
:
:
:
;
x
n
=a
n
g.
If

j
=
C

,
it
follo
ws
from
the
Subsumption
Theorem
that
there
is
a
D
suc
h
that

`
r
D
and
D

C

.
Th
us
there
is
a

,
suc
h
that
D


C

.
Note
that
since

`
r
D
and
none
of
the
constan
ts
a

;
:
:
:
;
a
n
app
ears
in
,
none
of
these
constan
ts
app
ears
in
D
.
No
w
let

0
b
e
obtained
b
y
replacing
in

all
o
ccurrences
of
a
i
b
y
x
i
,
for
ev
ery


i

n.
Then
D

0

C
,
hence
D

C
.
Therefore

`
d
C
,
and
hence

j
=
C
.

.
Least
generalizations
and
greatest
sp
ecializa-
tions
In
this
section,
w
e
will
dene
the
concepts
w
e
need
concerning
least
generaliza-
tions
and
greatest
sp
ecializations.
Denition
.
Let
 b
e
a
set
and
R
b
e
a
binary
relation
on
 (i.e.,
R

 
 ).
.
R
is
r
eexive
on
 ,
if
xR
x
for
ev
ery
x

 .
.
R
is
tr
ansitive
on
 ,
if
for
ev
ery
x;
y
;
z

 ,
xR
y
and
y
R
z
implies
xR
z
.
.
R
is
symmetric
on
 ,
if
for
ev
ery
x;
y

 ,
xR
y
implies
y
R
x.
.
R
is
anti-symmetric
on
 ,
if
for
ev
ery
x;
y
;
z

 ,
xR
y
and
y
R
x
implies
x
=
y
.
If
R
is
b
oth
reexiv
e
and
transitiv
e
on
 ,
w
e
sa
y
R
is
a
quasi-or
der
on
 .
If
R
is
b
oth
reexiv
e,
transitiv
e
and
an
ti-symmetric
on
 ,
w
e
sa
y
R
is
a
p
artial
or
der
on
 .
If
R
is
reexiv
e,
transitiv
e
and
symmetric
on
 ,
R
is
an
e
quivalenc
e
r
elation
on
 .


..
LEAST
GENERALIZA
TIONS
AND
GREA
TEST
SPECIALIZA
TIONS	
A
quasi-order
R
on
 induces
an
equiv
alence-relation

on
 ,
as
follo
ws:
w
e
sa
y
x;
y

 are
e
quivalent
induced
b
y
R
(denoted
x

y
)
if
b
oth
xR
y
and
y
R
x.
Using
this
equiv
alence
relation,
a
quasi-order
R
on
 induces
a
partial
order
R
0
on
the
set
of
equiv
alence
classes
in
 ,
dened
as
follo
ws:
if
[x]
denotes
the
equiv
alence
class
of
x
(i.e.,
[x]
=
fy
j
x

y
g),
then
[x]R
0
[y
]
i
xR
y
.
W
e
rst
giv
e
a
general
denition
of
least
generalizations
and
greatest
sp
e-
cializations
for
sets
of
clauses
ordered
b
y
some
quasi-order,
whic
h
w
e
then
in-
stan
tiate
in
dieren
t
w
a
ys.
Denition
.
Let
 b
e
a
set
of
clauses,

b
e
a
quasi-order
on
 ,
S

 b
e
a
nite
set
of
clauses
and
C

 .
If
C

D
for
ev
ery
D

S
,
then
w
e
sa
y
C
is
a
gener
alization
of
S
under
.
Suc
h
a
C
is
called
a
le
ast
gener
alization
(LG)
of
S
under

in
 ,
if
w
e
ha
v
e
C
0

C
for
ev
ery
generalization
C
0

 of
S
under
.
Dually
,
C
is
a
sp
e
cialization
of
S
under
,
if
D

C
for
ev
ery
D

S
.
Suc
h
a
C
is
called
a
gr
e
atest
sp
e
cialization
(GS)
of
S
under

in
 ,
if
w
e
ha
v
e
C

C
0
for
ev
ery
sp
ecialization
C
0

 of
S
under
.

It
is
easy
to
see
that
if
some
set
S
has
an
LG
or
GS
under

in
 ,
then
this
LG
or
GS
will
b
e
unique
up
to
the
equiv
alence
induced
b
y

in
 .
That
is,
if
C
and
D
are
b
oth
LG's
or
GS's
of
some
set
S
,
then
w
e
ha
v
e
C

D
.
The
concepts
dened
ab
o
v
e
are
instances
of
the
mathematical
concepts
of
(least)
upp
er
b
ounds
and
(greatest)
lo
w
er
b
ounds.
Th
us
w
e
can
sp
eak
of
lattice-
prop
erties
of
a
quasi-
or
partially
ordered
set
of
clauses:
Denition
.
Let
 b
e
a
set
of
clauses
and

a
quasi-order
on
 .
If
for
ev
ery
nite
subset
S
of
 there
exist
b
oth
a
least
generalization
and
a
greatest
sp
ecialization
of
S
under

in
 ,
then
 ordered
b
y

is
called
a
lattic
e.

It
should
b
e
noted
that
usually
in
mathematics,
a
lattice
is
dened
for
a
partial
order
instead
of
a
quasi-order.
Ho
w
ev
er,
since
in
ILP
w
e
usually
ha
v
e
to
deal
with
individual
clauses
rather
than
with
equiv
alence
classes
of
clauses,
it
is
con
v
enien
t
for
us
to
dene
`lattice'
for
a
quasi-order
here.
An
yho
w,
if
a
quasi-
order

is
a
lattice
on
 ,
then
the
partial
order
induced
b
y

is
a
lattice
on
the
set
of
equiv
alence
classes
in
 .
In
ILP
,
there
are
t
w
o
main
instan
tiations
for
the
set
of
clauses
 :
either
w
e
tak
e
a
clausal
language
C
,
or
w
e
tak
e
a
Horn
language
H
.
Similarly
,
there
are
three
in
teresting
c
hoices
for
the
quasi-order
:
w
e
can
use
either

(sub-
sumption),
j
=
(implication),
or
j
=

(relativ
e
implication)
for
some
bac
kground
kno
wledge
.
It
is
easy
to
see
that
eac
h
of
these
is
indeed
a
quasi-order
on
a
set
of
clauses.
In
the
-order,
w
e
will
sometimes
abbreviate
the
terms
`least
generalization
of
S
under
subsumption'
and
`greatest
sp
ecialization
of
S
un-
der
subsumption'
to
`LGS
of
S
'
and
`GSS
of
S
',
resp
ectiv
ely
.
Similarly
,
in
the
j
=-order
w
e
will
sometimes
sp
eak
of
an
LGI
(least
generalization
under
implica-
tion)
and
a
GSI.
In
the
j
=

-order,
w
e
will
use
LGR
(least
generalization
under
r
elative
implication)
and
GSR.
These
t
w
o
dieren
t
languages
and
three
dieren
t
quasi-orders
giv
e
a
to-
tal
of
six
com
binations.
F
or
eac
h
com
bination,
w
e
can
ask
whether
an
LG
or

0
GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
GS
of
ev
ery
nite
set
S
exists.
In
the
next
section,
w
e
will
review
the
an-
sw
ers
for
subsumption
giv
en
b
y
others
or
b
y
ourselv
es.
Then
w
e
dev
ote
t
w
o
sections
to
least
generalizations
and
greatest
sp
ecializations
under
implication,
resp
ectiv
ely
.
Finally
,
w
e
discuss
least
generalizations
and
greatest
sp
ecializa-
tions
under
relativ
e
implication.
The
results
of
this
surv
ey
ha
v
e
already
b
een
summarized
in
T
able
.
in
the
In
tro
duction.
.
Subsumption
First
w
e
dev
ote
some
atten
tion
to
subsumption.
Least
generalizations
under
subsumption
ha
v
e
b
een
discussed
extensiv
ely
b
y
Plotkin
[Plo0
].
The
main
result
in
his
framew
ork
is
the
follo
wing:
Theorem
.
(Existence
of
LGS
in
C
)
L
et
C
b
e
a
clausal
language.
Then
for
every
nite
S

C
,
ther
e
exists
an
LGS
of
S
in
C
.
If
S
only
con
tains
Horn
clauses,
then
it
can
b
e
sho
wn
that
the
LGS
of
S
is
itself
also
a
Horn
clause.
Th
us
the
question
for
the
existence
of
an
LGS
of
ev
ery
nite
set
S
of
clauses
is
answ
ered
p
ositiv
ely
for
b
oth
clausal
languages
and
for
Horn
languages.
Plotkin
established
the
existence
of
an
LGS,
but
he
seems
to
ha
v
e
ignored
the
GSS
in
[Plo0
,
Plob],
p
ossibly
b
ecause
it
is
a
v
ery
straigh
tforw
ard
result.
It
is
in
fact
fairly
easy
to
sho
w
that
the
GSS
of
some
nite
set
S
of
clauses
is
simply
the
union
of
all
clauses
in
S
after
they
are
standardized
apart.

W
e
include
the
pro
of
here.
Theorem
.
(Existence
of
GSS
in
C
)
L
et
C
b
e
a
clausal
language.
Then
for
every
nite
S

C
,
ther
e
exists
a
GSS
of
S
in
C
.
Pro
of
Supp
ose
S
=
fD

;
:
:
:
;
D
n
g

C
.
Without
loss
of
generalit
y
,
w
e
assume
the
clauses
in
S
are
standardized
apart.
Let
D
=
D

[
:
:
:
[
D
n
,
then
D
i

D
,
for
ev
ery


i

n.
No
w
let
C

C
b
e
suc
h
that
D
i

C
,
for
ev
ery


i

n.
Then
for
ev
ery


i

n,
there
is
a

i
suc
h
that
D
i

i

C
and

i
only
acts
on
v
ariables
in
D
i
.
If
w
e
let

=


[
:
:
:
[

n
,
then
D

=
D



[
:
:
:
[
D
n

n

C
.
Hence
D

C
,
so
D
is
a
GSS
of
S
in
C
.

This
establishes
that
a
clausal
language
C
ordered
b
y

is
a
lattice.
Pro
ving
the
existence
of
a
GSS
of
ev
ery
nite
set
of
Horn
clauses
in
H
requires
a
little
more
w
ork,
but
here
also
the
result
is
p
ositiv
e.
F
or
example,
D
=
P
(a)
 
P
(f
(a));
Q(y
)
is
a
GSS
of
D

=
P
(x)
 
P
(f
(x))
and
D

=
P
(a)
 
Q(y
).
Note
that
D
can
b
e
obtained
b
y
applying

=
fx=ag
(the
mgu
for
the
heads
of
D

and
D

)
to
D

[
D

,
the
GSS
of
D

and
D

in
C
.
This
idea

Note
that
this
has
nothing
to
do
with
unic
ation.
F
or
instance,
if
S
=
fP
(a;
x);
P
(y
;
b)g,
then
the
GSS
of
S
in
C
w
ould
b
e
P
(a;
x)
_
P
(y
;
b).
Ho
w
ev
er,
if
w
e
w
ould
instan
tiate
 in
Denition
.
to
the
set
of
atoms,
then
the
greatest
sp
ecialization
of
t
w
o
atoms
in
the
set
of
atoms
should
itself
also
b
e
an
atom.
The
GSS
of
t
w
o
atoms
is
then
their
most
general
unication
[Rey0].
F
or
instance,
the
GSS
of
S
w
ould
in
this
case
b
e
P
(a;
b).

..
SUBSUMPTION

will
b
e
used
in
the
follo
wing
pro
of.
Here
w
e
assume
H
con
tains
an
articial
b
ottom
elemen
t
(T
rue)
?,
suc
h
that
C

?
for
ev
ery
C

H
,
and
?

C
for
ev
ery
C
=
?.
Note
that
?
is
not
subsume-equiv
alen
t
with
other
tautologies.
Theorem
.
(Existence
of
GSS
in
H
)
L
et
H
b
e
a
Horn
language,
with
?

H
.
Then
for
every
nite
S

H
,
ther
e
exists
a
GSS
of
S
in
H
.
Pro
of
Supp
ose
S
=
fD

;
:
:
:
;
D
n
g

H
.
Without
loss
of
generalit
y
w
e
assume
the
clauses
in
S
are
standardized
apart,
D

;
:
:
:
;
D
k
are
the
denite
program
clauses
in
S
and
D
k
+
;
:
:
:
;
D
n
are
the
denite
goals
in
S
.
If
k
=
0
(i.e.,
if
S
only
con
tains
goals),
then
it
is
easy
to
sho
w
that
D

[
:
:
:
[
D
n
is
a
GSS
of
S
in
H
.
If
k


and
the
set
fD
+

;
:
:
:
;
D
+
k
g
is
not
uniable,
then
?
is
a
GSS
of
S
in
H
.
Otherwise,
let

b
e
an
mgu
for
fD
+

;
:
:
:
;
D
+
k
g,
and
let
D
=
D


[
:
:
:
[
D
n

(note
that
actually
D
i

=
D
i
for
k
+


i

n,
since
the
clauses
in
S
are
standardized
apart).
Since
D
has
exactly
one
literal
in
its
head,
it
is
a
denite
program
clause.
F
urthermore,
w
e
ha
v
e
D
i

D
for
ev
ery


i

n,
since
D
i


D
.
T
o
sho
w
that
D
is
a
GSS
of
S
in
H
,
supp
ose
C

H
is
some
clause
suc
h
that
D
i

C
for
ev
ery


i

n.
F
or
ev
ery


i

n,
let

i
b
e
suc
h
that
D
i

i

C
and

i
only
acts
on
v
ariables
in
D
i
.
Let

=


[
:
:
:
[

n
.
F
or
ev
ery


i

k
,
D
+
i

=
D
+
i

i
=
C
+
,
so

is
a
unier
of
fD
+

;
:
:
:
;
D
+
k
g.
But

is
an
mgu
for
this
set,
so
there
is
a

suc
h
that

=


.
No
w
D

=
D



[
:
:
:
[
D
n


=
D


[
:
:
:
[
D
n

=
D



[
:
:
:
[
D
n

n

C
.
Hence
D

C
,
so
D
is
a
GSS
of
S
in
H
.
See
gure
.
for
illustration
of
the
case
where
n
=
.

D

H
H
H
H
j

J
J
J
J
J
J
^


D
















D
?

C
Figure
.:
D
is
a
GSS
of
D

and
D

Th
us
a
Horn
language
H
ordered
b
y

is
also
a
lattice.
W
e
end
this
section
b
y
briey
discussing
Plotkin's
r
elative
subsumption
[Plob].
This
is
an
extension
of
subsumption
whic
h
tak
es
bac
kground
kno
wl-
edge
in
to
accoun
t.
This
bac
kground
kno
wledge
is
rather
restricted:
it
m
ust
b
e
a
nite
set

of
gr
ound
liter
als.
Because
of
its
restrictiv
eness,
w
e
ha
v
e
not
included
relativ
e
subsumption
in
T
able
..
Nev
ertheless,
w
e
men
tion
it
here,
b
ecause
least
generalization
under
relativ
e
subsumption
forms
the
basis
of
the
w
ell-kno
wn
ILP
system
Golem
[MF	
].
Denition
.
Let
C
;
D
b
e
clauses,

=
fL

;
:
:
:
;
L
m
g
b
e
a
nite
set
of
ground
literals.
Then
C
subsumes
D
r
elative
to
,
denoted
b
y
C


D
,
if
C

(D
[
f:L

;
:
:
:
;
:L
m
g).

It
is
easy
to
see
that


is
reexiv
e
and
transitiv
e,
so
it
imp
oses
a
quasi-order
on
a
set
of
clauses.


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
Supp
ose
S
=
fD

;
:
:
:
;
D
n
g
and

=
fL

;
:
:
:
;
L
m
g.
It
is
easy
to
see
that
an
LGS
of
f(D

[
f:L

;
:
:
:
;
:L
m
g);
:
:
:
;
(D
n
[
f:L

;
:
:
:
;
:L
m
g)g
is
a
least
gener-
alization
of
S
under


,
so
ev
ery
nite
set
of
clauses
has
a
least
generalization
under


in
C
.
Moreo
v
er,
if
eac
h
D
i
is
a
Horn
clause
and
eac
h
L
j
is
a
p
ositive
ground
literal
(i.e.,
a
ground
atom),
then
this
least
generalization
will
itself
also
b
e
a
Horn
clause.
Accordingly
,
if

is
a
nite
set
of
p
ositiv
e
ground
literals,
then
ev
ery
nite
set
of
Horn
clauses
has
a
least
generalization
under


in
H
.
.
Least
generalizations
under
implication
No
w
w
e
turn
from
subsumption
to
the
implication
order.
In
this
section
w
e
will
discuss
LGI's,
in
the
next
section
w
e
handle
GSS's.
F
or
Horn
clauses,
the
LGI-question
has
already
b
een
answ
ered
negativ
ely
in
[MDR	
].
Let
D

=
P
(f

(x))
 
P
(x),
D

=
P
(f

(x))
 
P
(x),
C

=
P
(f
(x))
 
P
(x)
and
C

=
P
(f

(y
))
 
P
(x).
Then
w
e
ha
v
e
b
oth
C

j
=
fD

;
D

g
and
C

j
=
fD

;
D

g.
It
is
not
v
ery
dicult
to
see
that
there
are
no
more
sp
ecic
Horn
clauses
than
C

and
C

that
imply
b
oth
D

and
D

.
F
or
C

:
no
resolv
en
t
of
C

with
itself
implies
D

and
no
clause
that
is
prop
erly
subsumed
b
y
C

still
implies
D

and
D

.
F
or
C

:
ev
ery
resolv
en
t
of
C

with
itself
is
a
v
arian
t
of
C

,
and
no
clause
that
is
prop
erly
subsumed
b
y
C

still
implies
D

and
D

.
Th
us
C

and
C

are
b
oth
\minimal"
generalizations
under
implication
of
fD

;
D

g.
Since
C

and
C

are
not
logically
equiv
alen
t
under
implication,
there
is
no
LGI
of
fD

;
D

g
in
H
.
Ho
w
ev
er,
the
fact
that
there
is
no
LGI
of
fD

;
D

g
in
H
,
do
es
not
mean
that
D

and
D

ha
v
e
no
LGI
in
C
,
since
a
Horn
language
is
a
more
restricted
space
than
a
clausal
language.
In
fact,
it
is
sho
wn
in
[MP	
]
that
C
=
P
(f
(x))
_
P
(f

(y
))
 
P
(x)
is
an
LGI
of
D

and
D

in
C
.
F
or
this
reason,
it
ma
y
b
e
w
orth
while
for
the
LGI
to
consider
a
clausal
language
instead
of
only
Horn
clauses.
In
the
next
subsection,
w
e
sho
w
that
an
y
nite
set
of
clauses
whic
h
con-
tains
at
least
one
non-tautologous
function-free
clause,
has
an
LGI
in
C
.
An
immediate
corollary
of
this
result
is
the
existence
of
an
LGI
of
an
y
nite
set
of
function-free
clauses.
In
our
usage
of
the
w
ord,
a
`function-free'
clause
ma
y
con
tain
constan
ts,
ev
en
though
constan
ts
are
sometimes
seen
as
functions
of
arit
y
0.
Denition
.
A
clause
is
function-fr
e
e
if
it
do
es
not
con
tain
function
sym
b
ols
of
arit
y

or
more.

Note
that
a
clause
is
function-free
i
it
has
depth
.
In
case
of
sets
of
clauses
whic
h
all
con
tain
function
sym
b
ols,
the
LGI-question
remains
op
en.
..
A
sucien
t
condition
for
the
existence
of
an
LGI
In
this
subsection,
w
e
will
sho
w
that
an
y
nite
set
S
of
clauses
con
taining
at
least
one
non-tautologous
function-free
clause,
has
an
LGI
in
C
.

..
LEAST
GENERALIZA
TIONS
UNDER
IMPLICA
TION

Denition
.	
Let
C
b
e
a
clause,
x

;
:
:
:
;
x
n
all
distinct
v
ariables
in
C
,
and
K
a
set
of
terms.
Then
the
instanc
e
set
of
C
w.r.t.
K
is
I
(C
;
K
)
=
fC

j

=
fx

=t

;
:
:
:
;
x
n
=t
n
g;
where
t
i

K
,
for
ev
ery


i

ng.
If

=
fC

;
:
:
:
;
C
k
g
is
a
set
of
clauses,
then
the
instanc
e
set
of

w.r.t.
K
is
I
(;
K
)
=
I
(C

;
K
)
[
:
:
:
[
I
(C
k
;
K
).

Example
.
If
C
=
P
(x)
_
Q(y
)
and
T
=
fa;
f
(z
)g,
then
I
(C
;
T
)
=
f(P
(a)
_
Q(a));
(P
(a)
_
Q(f
(z
)));
(P
(f
(z
))
_
Q(a));
(P
(f
(z
))
_
Q(f
(z
)))g.
<
Denition
.0
Let
S
b
e
a
nite
set
of
clauses,
and

b
e
a
Sk
olem
substitution
for
S
.
Then
the
term
set
of
S
b
y

is
the
set
of
all
terms
(including
subterms)
o
ccurring
in
S

.

A
term
set
of
S
b
y
some

is
a
nite
set
of
ground
terms.
Example
.
The
term
set
of
D
=
P
(f

(x);
y
;
z
)
 
P
(y
;
z
;
f

(x))
b
y

=
fx=a;
y
=b;
z
=cg
is
T
=
fa;
f
(a);
f

(a);
b;
cg.
<
Our
denition
of
a
term
set
corresp
onds
to
what
Idestam-Almquist
[IA	
,
IA	
]
calls
a
`minimal
term
set'.
In
his
denition,
if

is
a
Sk
olem
substitution
for
a
set
of
clauses
S
=
fD

;
:
:
:
;
D
n
g
w.r.t.
some
other
set
of
clauses
S
0
,
then
a
term
set
of
S
is
a
nite
set
of
terms
whic
h
con
tains
the
minimal
term
set
of
S
b
y

as
a
subset.
Using
his
notion
of
term
set,
he
denes
T-implic
ation
as
follo
ws:
if
C
and
D
are
clauses
and
T
is
a
term
set
of
fD
g
b
y
some
Sk
olem
substitution

w.r.t.
fC
g,
then
C
T-implies
D
w.r.t.
T
,
if
I
(C
;
T
)
j
=
D

.
T-implication
is
decidable,
w
eak
er
than
logical
implication
and
stronger
than
subsumption.
[IA	
,
IA	
]
giv
es
the
result
that
an
y
nite
set
of
clauses
has
a
least
generalization
under
T-implication
w.r.t.
an
y
term
set
T
.
Ho
w
ev
er,
as
he
also
notes,
T-implication
is
not
transitiv
e
and
hence
not
a
quasi-order.
Therefore
it
do
es
not
t
in
to
our
general
framew
ork
here.
F
or
this
reason,
w
e
will
not
discuss
it
fully
here,
and
for
the
same
reason
w
e
ha
v
e
not
included
a
ro
w
for
T-implication
in
T
able
..
Let
us
no
w
b
egin
with
the
pro
of
of
our
result
concerning
the
existence
of
LGI's.
Consider
C
=
P
(x;
y
;
z
)
 
P
(z
;
x;
y
),
and
D
,

and
T
as
ab
o
v
e.
Then
C
j
=
D
and
also
I
(C
;
T
)
j
=
D

,
since
D

is
a
resolv
en
t
of
P
(f

(a);
b;
c)
 
P
(c;
f

(a);
b)
and
P
(c;
f

(a);
b)
 
P
(b;
c;
f

(a)),
whic
h
are
in
I
(C
;
T
).
As
w
e
will
sho
w
in
the
next
lemma,
this
holds
in
general:
if
C
j
=
D
and
C
is
function-
free,
then
w
e
can
restrict
atten
tion
to
the
ground
instances
of
C
instan
tiated
to
terms
in
the
term
set
of
D
b
y
some

.
The
pro
of
of
Lemma
.
uses
the
follo
wing
idea.
Consider
a
deriv
ation
of
a
clause
E
from
a
set

of
ground
clauses.
Supp
ose
some
of
the
clauses
in

con
tain
terms
not
app
earing
in
E
.
Then
an
y
literals
con
taining
these
terms
in

m
ust
b
e
resolv
ed
a
w
a
y
in
the
deriv
ation.
This
means
that
if
w
e
replace
all
the
terms
in
the
deriv
ation
that
are
not
in
E
,
b
y
some
other
term
t,
then
the
result
will
b
e
another
deriv
ation
of
E
.
F
or
example,
the
left
of
gure
.
sho
ws
a
deriv
ation
of
length

of
E
.
The
term
f

(b)
in
the
paren
t
clauses
do
es
not
app
ear
in
E
.
If
w
e
replace
this
term
b
y
the
constan
t
a,
the
result
is
another
deriv
ation
of
E
(righ
t
of
the
gure).


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
P
(b)
 
P
(f

(b))
P
(f

(b))
 
Q(a;
f
(a))
@
@
@
R
   	
E
=
P
(b)
 
Q(a;
f
(a))
P
(b)
 
P
(a)
P
(a)
 
Q(b;
f
(a))
@
@
@
R
   	
E
=
P
(b)
 
Q(a;
f
(a))
Figure
.:
T
ransforming
the
left
deriv
ation
yields
the
righ
t
deriv
ation
Lemma
.
L
et
C
b
e
a
function-fr
e
e
clause,
D
b
e
a
clause,

b
e
a
Skolem
substitution
for
D
w.r.t.
fC
g
and
T
b
e
the
term
set
of
D
by

.
Then
C
j
=
D
i
I
(C
;
T
)
j
=
D

.
Pro
of
(:
Since
C
j
=
I
(C
;
T
)
and
I
(C
;
T
)
j
=
D

,
w
e
ha
v
e
C
j
=
D

.
No
w
C
j
=
D
b
y
Lemma
..
):
If
D
is
a
tautology
,
then
D

is
a
tautology
,
so
this
case
is
ob
vious.
Supp
ose
D
is
not
a
tautology
,
then
D

is
not
a
tautology
.
Since
C
j
=
D

,
it
follo
ws
from
Theorem
.
that
there
exists
a
nite
set

of
ground
instances
of
C
,
suc
h
that

j
=
D

.
By
the
Subsumption
Theorem,
there
exists
a
deriv
ation
from

of
a
clause
E
,
suc
h
that
E

D

.
Since

is
ground,
E
m
ust
also
b
e
ground,
so
w
e
ha
v
e
E

D

.
This
implies
that
E
only
con
tains
terms
from
T
.
Let
t
b
e
an
arbitrary
term
in
T
and
let

0
b
e
obtained
from

b
y
replacing
ev
ery
term
in
clauses
in

whic
h
is
not
in
T
,
b
y
t.
Note
that
since
eac
h
clause
in

is
a
ground
instance
of
the
function-free
clause
C
,
ev
ery
clause
in

0
is
also
a
ground
instance
of
C
.
No
w
it
is
easy
to
see
that
the
same
replacemen
t
of
terms
in
the
deriv
ation
of
E
from

results
in
a
deriv
ation
of
E
from

0
:
()
eac
h
resolution
step
in
the
deriv
ation
from

can
also
b
e
carried
out
in
the
deriv
ation
from

0
,
since
the
same
terms
in

are
replaced
b
y
the
same
terms
in

0
and
()
the
terms
in

that
are
not
in
T
(and
hence
are
replaced
b
y
t),
do
not
app
ear
in
the
conclusion
E
of
the
deriv
ation.
Since
there
is
a
deriv
ation
of
E
from
,
w
e
ha
v
e

0
j
=
E
,
and
hence

0
j
=
D

.

0
is
a
set
of
ground
instances
of
C
and
all
terms
in

0
are
terms
in
T
,
so

0

I
(C
;
T
).
Hence
I
(C
;
T
)
j
=
D

.

Lemma
.
cannot
b
e
generalized
to
the
case
where
C
con
tains
function
sym
b
ols
of
arit
y

,
tak
e
C
=
P
(f
(x);
y
)
 
P
(z
;
x)
and
D
=
P
(f
(a);
a)
 
P
(a;
f
(a))
(from
the
example
giv
en
on
p.

of
[IA	
]).
Then
T
=
fa;
f
(a)g
is
the
term
set
of
D
,
and
w
e
ha
v
e
C
j
=
D
,
y
et
it
can
b
e
seen
that
I
(C
;
T
)
j
=
D
.
The
argumen
t
used
in
the
previous
lemma
do
es
not
w
ork
here,
b
ecause
dieren
t
terms
in
some
ground
instance
need
not
relate
to
dieren
t
v
ariables.
F
or
example,
in
the
ground
instance
P
(f

(a);
a)
 
P
(a;
f
(a))
of
C
,
w
e
cannot
just
replace
f

(a)
b
y
some
other
term,
for
then
the
resulting
clause
w
ould
not
b
e
an
instance
of
C
.
On
the
other
hand,
Lemma
.
can
b
e
generalized
to
a
set
of
clauses
instead
of
a
single
clause.
If

is
a
nite
set
of
function-free
clauses,
C
is
an
arbitrary
clause
and

is
a
Sk
olem
substitution
for
C
w.r.t.
,
then
w
e
ha
v
e
that

j
=
C
i
I
(;
T
)
j
=
C

.
The
pro
of
is
almost
literally
the
same
as
ab
o
v
e.

..
LEAST
GENERALIZA
TIONS
UNDER
IMPLICA
TION

This
result
implies
that

j
=
C
is
reducible
to
an
implication
I
(;
T
)
j
=
C

b
et
w
een
ground
clauses.
Since,
b
y
the
next
lemma,
implication
b
et
w
een
ground
clauses
is
decidable,
it
follo
ws
that

j
=
C
is
decidable
in
case

is
function-free.
Lemma
.
The
pr
oblem
whether

j
=
C
,
wher
e

is
a
nite
set
of
gr
ound
clauses
and
C
is
a
gr
ound
clause,
is
de
cidable.
Pro
of
Let
C
=
L

_
:
:
:
_
L
n
and
A
b
e
the
set
of
all
ground
atoms
o
ccurring
in

and
C
.
No
w:

j
=
C
i
(b
y
Prop
osition
A.)

[
f:L

;
:
:
:
;
:L
n
g
is
unsatisable
i
(b
y
Prop
osition
A.)

[
f:L

;
:
:
:
;
:L
n
g
has
no
Herbrand
mo
del
i
no
subset
of
A
is
an
Herbrand
mo
del
of

[
f:L

;
:
:
:
;
:L
n
g.
Since
A
is
nite,
the
last
statemen
t
is
decidable.

Corollary
.
The
pr
oblem
whether

j
=
C
,
wher
e

is
a
nite
set
of
function-
fr
e
e
clauses
and
C
is
a
clause,
is
de
cidable.
The
follo
wing
sequence
of
results
more
or
less
follo
ws
the
pattern
of
Lemma

to
Theorem

of
Idestam-Almquist's
[IA	
]
(similar
to
Lemma
.0
to
Theorem
.
of
[IA	
]).
There
he
giv
es
a
pro
of
of
the
existence
of
a
least
generalization
under
T-implication
of
an
y
nite
set
of
(not
necessarily
function-free)
clauses.
W
e
can
adjust
the
pro
of
in
suc
h
a
w
a
y
that
w
e
can
use
it
to
establish
the
existence
of
an
LGI
of
an
y
nite
set
of
clauses
con
taining
at
least
one
non-
tautologous
and
function-free
clause.
Lemma
.
L
et
S
b
e
a
nite
set
of
non-tautolo
gous
clauses,
V
=
fx

;
:
:
:
;
x
m
g
b
e
a
set
of
variables
and
let
G
=
fC

;
C

;
:
:
:
g
b
e
a
(p
ossibly
innite)
set
of
gener
alizations
of
S
under
implic
ation.
Then
the
set
G
0
=
I
(C

;
V
)
[
I
(C

;
V
)
[
:
:
:
is
a
nite
set
of
clauses.
Pro
of
Let
d
b
e
the
maximal
depth
of
the
terms
in
clauses
in
S
.
It
follo
ws
from
Lemma
.
that
G
(and
hence
also
G
0
)
cannot
con
tain
terms
of
depth
greater
than
d,
nor
predicates,
functions
or
constan
ts
other
than
those
in
S
.
The
set
of
literals
whic
h
can
b
e
constructed
from
predicates
in
S
,
and
from
terms
of
depth
at
most
d
consisting
of
functions
and
constan
ts
in
S
and
v
ariables
in
V
,
is
nite.
Hence
the
set
of
clauses
whic
h
can
b
e
constructed
from
those
literals
is
also
nite.
G
0
is
a
subset
of
this
set,
so
G
0
is
a
nite
set
of
clauses.

Lemma
.
L
et
D
b
e
a
clause,
C
b
e
a
function-fr
e
e
clause
such
that
C
j
=
D
,
T
=
ft

;
:
:
:
;
t
n
g
b
e
the
term
set
of
D
by

,
V
=
fx

;
:
:
:
;
x
m
g
b
e
a
set
of
variables
and
m

n.
If
E
is
an
LGS
of
I
(C
;
V
),
then
E
j
=
D
.
Pro
of
Let

=
fx

=t

;
:
:
:
;
x
n
=t
n
;
x
n+
=t
n
;
:
:
:
;
x
m
=t
n
g
(it
do
es
not
matter
to
whic
h
terms
the
v
ariables
x
n+
;
:
:
:
;
x
m
are
mapp
ed
b
y

,
as
long
as
they
are
mapp
ed
to
terms
in
T
).
Supp
ose
I
(C
;
V
)
=
fC


;
:
:
:
;
C

k
g.
Then
I
(C
;
T
)
=


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
fC



;
:
:
:
;
C

k

g.
Let
E
b
e
an
LGS
of
I
(C
;
V
)
(note
that
E
m
ust
b
e
function-
free).
Then
for
ev
ery


i

k
,
there
are

i
suc
h
that
E

i

C

i
.
This
means
that
E

i


C

i

and
hence
E

i

j
=
C

i

,
for
ev
ery


i

k
.
Therefore
E
j
=
I
(C
;
T
).
Since
C
j
=
D
,
w
e
kno
w
from
Lemma
.
that
constan
ts
app
earing
in
C
m
ust
also
app
ear
in
D
.
This
means
that

is
a
Sk
olem
substitution
for
D
w.r.t.
fC
g.
Then
from
Lemma
.
w
e
kno
w
I
(C
;
T
)
j
=
D

,
hence
E
j
=
D

.
F
urthermore,
since
E
is
an
LGS
of
I
(C
;
V
),
all
constan
ts
in
E
also
app
ear
in
C
,
hence
all
constan
ts
in
E
m
ust
app
ear
in
D
.
Th
us

is
also
a
Sk
olem
substitution
for
D
w.r.t.
fE
g.
Therefore
E
j
=
D
b
y
Lemma
..

Consider
C
=
P
(x;
y
;
z
)
 
P
(y
;
z
;
x)
and
D
= 
Q(w
).
Both
C
and
D
im-
ply
the
clause
E
=
P
(x;
y
;
z
)
 
P
(z
;
x;
y
);
Q(b).
No
w
note
that
C
[
D
=
P
(x;
y
;
z
)
 
P
(y
;
z
;
x);
Q(w
)
also
implies
E
.
This
holds
for
clauses
in
general,
ev
en
in
the
presence
of
bac
kground
kno
wledge
.
The
next
lemma
is
v
ery
general,
but
in
this
section
w
e
only
need
the
sp
ecial
case
where
C
and
D
are
function-free
and

is
empt
y
.
W
e
need
the
general
case
to
pro
v
e
the
existence
of
a
GSR
in
Section
..
Lemma
.
L
et
C
,
D
and
E
b
e
clauses
such
that
C
and
D
ar
e
standar
dize
d
ap
art,
and
let

b
e
a
set
of
clauses.
If
C
j
=

E
and
D
j
=

E
,
then
C
[
D
j
=

E
.
Pro
of
Supp
ose
C
j
=

E
and
D
j
=

E
,
and
let
M
b
e
a
mo
del
of

[
fC
[
D
g.
Since
C
and
D
are
standardized
apart,
the
clause
C
[
D
is
equiv
alen
t
to
the
form
ula
(C
)
_
(D
)
(where
(C
)
denotes
the
univ
ersally
quan
tied
clause
C
).
This
means
that
M
is
a
mo
del
of
C
or
a
mo
del
of
D
.
F
urthermore,
M
is
also
a
mo
del
of
,
so
it
follo
ws
from

[
fC
g
j
=
E
or

[
fD
g
j
=
E
that
M
is
a
mo
del
of
E
.
Therefore

[
fC
[
D
g
j
=
E
,
hence
C
[
D
j
=

E
.

No
w
w
e
can
pro
v
e
the
existence
of
an
LGI
of
an
y
nite
set
S
of
clauses
whic
h
con
tains
at
least
one
non-tautologous
and
function-free
clause.
In
fact
w
e
can
pro
v
e
something
stronger,
namely
that
this
LGI
is
a
sp
e
cial
LGI.
This
is
an
LGI
that
is
not
only
implied,
but
actually
subsume
d
b
y
an
y
other
generalization
of
S
:
Denition
.
Let
C
b
e
a
clausal
language
and
S
b
e
a
nite
subset
of
C
.
An
LGI
C
of
S
in
C
is
called
a
sp
e
cial
LGI
of
S
in
C
,
if
C
0

C
for
ev
ery
generalization
C
0

C
of
S
under
implication.

Note
that
if
D
is
an
LGI
of
a
set
con
taining
at
least
one
non-tautologous
function-free
clause,
then
b
y
Lemma
.
D
is
itself
function-free,
b
ecause
it
should
imply
the
function-free
clause(s)
in
S
.
F
or
instance,
C
=
P
(x;
y
;
z
)
 
P
(y
;
z
;
x);
Q(w
)
is
an
LGI
of
D

=
P
(x;
y
;
z
)
 
P
(y
;
z
;
x);
Q(f
(a))
and
D

=
P
(x;
y
;
z
)
 
P
(z
;
x;
y
);
Q(b).
Note
that
this
LGI
is
prop
erly
subsumed
b
y
the
LGS
of
fD

;
D

g,
whic
h
is
P
(x;
y
;
z
)
 
P
(x
0
;
y
0
;
z
0
);
Q(w
).
An
LGI
ma
y
sometimes
b
e
the
empt
y
clause
,
for
example
if
S
=
fP
(a);
Q(a)g.

..
LEAST
GENERALIZA
TIONS
UNDER
IMPLICA
TION

Theorem
.
(Existence
of
sp
ecial
LGI
in
C
)
L
et
C
b
e
a
clausal
language.
If
S
is
a
nite
set
of
clauses
fr
om
C
,
and
S
c
ontains
at
le
ast
one
non-tautolo
gous
function-fr
e
e
clause,
then
ther
e
exists
a
sp
e
cial
LGI
of
S
in
C
.
Pro
of
Let
S
=
fD

;
:
:
:
;
D
n
g
b
e
a
nite
set
of
clauses
from
C
,
suc
h
that
S
con
tains
at
least
one
non-tautologous
function-free
clause.
W
e
can
assume
without
loss
of
generalit
y
that
S
con
tains
no
tautologies.
Let

b
e
a
Sk
olem
substitution
for
S
,
T
=
ft

;
:
:
:
;
t
m
g
b
e
the
term
set
of
S
b
y

,
V
=
fx

;
:
:
:
;
x
m
g
b
e
a
set
of
v
ariables
and
G
=
fC

;
C

;
:
:
:
g
b
e
the
set
of
all
generalizations
of
S
under
implication
in
C
.
Note
that


G,
so
G
is
not
empt
y
.
Since
eac
h
clause
in
G
m
ust
imply
the
function-free
clause(s)
in
S
,
it
follo
ws
from
Lemma
.
that
all
mem
b
ers
of
G
are
function-free.
By
Lemma
.,
the
set
G
0
=
I
(C

;
V
)
[
I
(C

;
V
)
[
:
:
:
is
a
nite
set
of
clauses.
Since
G
0
is
nite,
the
set
of
I
(C
i
;
V
)'s
is
also
nite.
F
or
simplicit
y
,
let
fI
(C

;
V
);
:
:
:
;
I
(C
k
;
V
)g
b
e
the
set
of
all
distinct
I
(C
i
;
V
)'s.
Let
E
i
b
e
an
LGS
of
I
(C
i
;
V
),
for
ev
ery


i

k
,
suc
h
that
E

;
:
:
:
;
E
k
are
standardized
apart.
F
or
ev
ery


j

n,
the
term
set
of
D
j
b
y

is
some
set
ft
j

;
:
:
:
;
t
j
s
g

T
,
suc
h
that
m

j
s
.
F
rom
Lemma
.,
w
e
ha
v
e
that
E
i
j
=
D
j
,
for
ev
ery


i

k
and


j

n,
hence
E
i
j
=
S
.
No
w
let
F
=
E

[
:
:
:
[
E
k
,
then
w
e
ha
v
e
F
j
=
S
from
Lemma
.
(applying
the
case
of
Lemma
.
where

is
empt
y).
T
o
pro
v
e
that
F
is
a
sp
ecial
LGI
of
S
,
it
remains
to
sho
w
that
C
j

F
,
for
ev
ery
j

.
F
or
ev
ery
j

,
there
is
an
i
(

i

k
),
suc
h
that
I
(C
j
;
V
)
=
I
(C
i
;
V
).
So
for
this
i,
E
i
is
an
LGS
of
I
(C
j
;
V
).
C
j
is
itself
also
a
generalization
of
I
(C
j
;
V
)
under
subsumption,
hence
C
j

E
i
.
Then
nally
C
j

F
,
since
E
i

F
.

As
a
consequence,
w
e
also
immediately
ha
v
e
the
follo
wing:
Corollary
.
(Existence
of
LGI
for
function-free
clauses)
L
et
C
b
e
a
clausal
language.
Then
for
every
nite
set
of
function-fr
e
e
clauses
S

C
,
ther
e
exists
an
LGI
of
S
in
C
.
Pro
of
Let
S
b
e
a
nite
set
of
function-free
clauses
in
C
.
If
S
only
con
tains
tautologies,
an
y
tautology
will
b
e
an
LGI
of
S
.
Otherwise,
let
S
0
b
e
obtained
b
y
deleting
all
tautologies
from
S
.
By
the
previous
theorem,
there
is
a
sp
ecial
LGI
of
S
0
.
Clearly
,
this
is
also
a
sp
ecial
LGI
of
S
itself
in
C
.

This
corollary
is
not
trivial,
since
ev
en
though
the
n
um
b
er
of
Herbrand
in
ter-
pretations
of
a
language
without
function
sym
b
ols
is
nite
(due
to
the
fact
that
the
n
um
b
er
of
all
p
ossible
ground
atoms
is
nite
in
this
case),
S
ma
y
nev
er-
theless
b
e
implied
b
y
an
innite
n
um
b
er
of
non-equiv
alen
t
clauses.
This
ma
y
seem
lik
e
a
parado
x,
since
there
are
only
nitely
man
y
categories
of
clauses
that
can
\b
eha
v
e
dieren
tly"
in
a
nite
n
um
b
er
of
nite
Herbrand
in
terpre-
tations.
Th
us
it
w
ould
seem
that
the
n
um
b
er
of
non-equiv
alen
t
function-free
clauses
should
also
b
e
nite.
This
is
a
misunderstanding,
since
logical
implica-
tion
(and
hence
also
logical
equiv
alence)
is
dened
in
terms
of
al
l
in
terpreta-
tions,
not
just
Herbrand
in
terpretations.
F
or
instance,
dene
D

=
P
(a;
a)
and


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
P
(b;
b),
C
n
=
fP
(x
i
;
x
j
)
j
i
=
j;


i;
j

ng.
Then
w
e
ha
v
e
C
n
j
=
fD

;
D

g,
C
n
j
=
C
n+
and
C
n+
j
=
C
n
,
for
ev
ery
n

,
see
[LNC	a
].
Another
in
teresting
consequence
of
Theorem
.
concerns
self-saturation
(see
the
In
tro
duction
to
this
c
hapter
for
the
denition
of
self-saturation).
If
C
is
a
sp
ecial
LGI
of
some
set
S
,
then
it
is
clear
that
C
is
self-saturated:
an
y
clause
whic
h
implies
C
also
implies
S
and
hence
m
ust
subsume
C
,
since
C
is
a
sp
ecial
LGI
of
S
.
No
w
consider
S
=
fD
g,
where
D
is
some
non-tautologous
function-free
clause.
Then
a
sp
ecial
LGI
C
of
S
will
b
e
logically
equiv
alen
t
to
D
.
Moreo
v
er,
since
this
C
will
b
e
self-saturated,
it
is
a
self-saturation
of
D
.
Corollary
.
If
D
is
a
non-tautolo
gous
function-fr
e
e
clause,
then
ther
e
exists
a
self-satur
ation
of
D
.
..
The
LGI
is
computable
In
the
previous
subsection
w
e
pro
v
ed
the
existenc
e
of
an
LGI
in
C
of
ev
ery
nite
set
S
of
clauses
con
taining
at
least
one
non-tautologous
function-free
clause.
In
this
subsection,
w
e
will
establish
the
c
omputability
of
suc
h
an
LGI.
The
next
algorithm,
extracted
from
the
pro
of
of
the
previous
section,
computes
this
LGI
of
S
.
Algorithm
.
(LGI-Algorithm)
Input:
A
nite
set
S
of
clauses,
con
taining
at
least
one
non-tautologous
function-free
clause.
Output:
An
LGI
of
S
in
C
.
.
Remo
v
e
all
tautologies
from
S
(a
clause
is
a
tautology
i
it
con
tains
literals
A
and
:A),
call
the
remaining
set
S
0
.
.
Let
m
b
e
the
n
um
b
er
of
distinct
terms
(including
subterms)
in
S
0
,
let
V
=
fx

;
:
:
:
;
x
m
g.
(Notice
that
this
m
is
the
same
n
um
b
er
as
the
n
um
b
er
of
terms
in
the
term
set
T
used
in
the
pro
of
of
Theorem
..)
.
Let
G
b
e
the
(nite)
set
of
all
clauses
whic
h
can
b
e
constructed
from
predicates
and
constan
ts
in
S
0
and
v
ariables
in
V
.
.
Let
fU

;
:
:
:
;
U
n
g
b
e
the
set
of
all
subsets
of
G.
.
Let
H
i
b
e
an
LGS
of
U
i
,
for
ev
ery


i

n.
These
H
i
can
b
e
computed
b
y
Plotkin's
algorithm
[Plo0
].
.
Remo
v
e
from
fH

;
:
:
:
;
H
n
g
all
clauses
whic
h
do
not
imply
S
0
(since
eac
h
H
i
is
function-free,
b
y
Corollary
.
this
implication
is
decidable),
and
standardize
the
remaining
clauses
fH

;
:
:
:
;
H
q
g
apart.
.
Return
the
clause
H
=
H

[
:
:
:
[
H
q
.
The
correctness
of
this
algorithm
follo
ws
from
the
pro
of
of
Theorem
..
First
notice
that
H
j
=
S
b
y
Lemma
..
F
urthermore,
note
that
all
I
(C
i
;
V
)'s
men-
tioned
in
the
pro
of
of
Theorem
.,
are
elemen
ts
of
the
set
fU

;
:
:
:
;
U
n
g.
This
means
that
for
ev
ery
E
i
in
the
set
fE

;
:
:
:
;
E
k
g
men
tioned
in
that
pro
of,
there
is
a
clause
H
j
in
fH

;
:
:
:
;
H
q
g
suc
h
that
E
i
and
H
j
are
subsume-equiv
alen
t.
Then
it
follo
ws
that
the
LGI
F
=
E

[
:
:
:
[
E
k
of
that
pro
of
subsumes
the
clause
H
=
H

[
:
:
:
[
H
q
that
our
algorithm
returns.
On
the
other
hand,
F
is
a
sp
ecial
LGI,
so
F
and
H
m
ust
b
e
subsume-equiv
alen
t.

..
GREA
TEST
SPECIALIZA
TIONS
UNDER
IMPLICA
TION
	
Supp
ose
the
n
um
b
er
of
distinct
constan
ts
in
S
0
is
c
and
the
n
um
b
er
of
distinct
v
ariables
in
step

of
the
algorithm
is
m.
F
urthermore,
supp
ose
there
are
p
distinct
predicate
sym
b
ols
in
S
0
,
with
resp
ectiv
e
arities
a

;
:
:
:
;
a
p
.
Then
the
n
um
b
er
of
distinct
atoms
that
can
b
e
formed
from
these
constan
ts,
v
ariables
and
predicates,
is
l
=
P
p
i=
(c
+
m)
a
i
,
and
the
n
um
b
er
of
distinct
literals
that
can
b
e
formed,
is


l
.
The
set
G
of
distinct
clauses
whic
h
can
b
e
formed
from
these
literals
is
the
p
o
w
er
set
of
this
set
of
literals,
so
jGj
=

l
.
Then
the
set
fU

;
:
:
:
;
U
n
g
of
all
subsets
of
G
con
tains

jGj
=


l
mem
b
ers.
Th
us
the
algorithm
outlined
ab
o
v
e
is
not
v
ery
ecien
t
(to
sa
y
the
least).
A
more
ecien
t
algorithm
ma
y
exist,
but
since
implication
is
harder
than
sub-
sumption
and
the
computation
of
an
LGS
is
already
quite
exp
ensiv
e,
w
e
should
not
put
our
hop
es
to
o
high.
Nev
ertheless,
the
existence
of
the
LGI-algorithm
do
es
establish
the
theoretical
p
oin
t
that
the
LGI
of
an
y
nite
set
of
clauses
con
taining
at
least
one
non-tautologous
function-free
clause,
is
eectiv
ely
com-
putable.
Theorem
.
(Computabilit
y
of
LGI)
L
et
C
b
e
a
clausal
language.
If
S
is
a
nite
set
of
clauses
fr
om
C
,
and
S
c
ontains
at
le
ast
one
non-tautolo
gous
function-fr
e
e
clause,
then
the
LGI
of
S
in
C
is
c
omputable.
.
Greatest
sp
ecializations
under
implication
No
w
w
e
turn
from
least
generalizations
under
implication
to
greatest
sp
ecial-
izations.
Finding
least
generalizations
of
sets
of
clauses
is
common
practice
in
ILP
.
On
the
other
hand,
the
greatest
sp
ecialization,
whic
h
is
the
dual
of
the
least
generalization,
is
used
hardly
ev
er.
Nev
ertheless,
the
GSI
of
t
w
o
clauses
D

and
D

migh
t
b
e
useful.
Supp
ose
that
w
e
ha
v
e
one
p
ositiv
e
example
e
+
and
t
w
o
negativ
e
examples
e
 
and
e
 
,
and
supp
ose
that
D

implies
e
+
and
e
 
,
while
D

implies
e
+
and
e
 
.
Then
it
migh
t
v
ery
w
ell
b
e
that
the
GSI
of
D

and
D

still
implies
e
+
,
but
is
consisten
t
w.r.t.
fe
 
;
e
 
g.
Then
w
e
could
obtain
a
correct
sp
ecialization
b
y
taking
the
GSI
of
D

and
D

.
It
is
ob
vious
from
the
previous
sections
that
the
existence
of
an
LGI
of
S
is
quite
hard
to
establish.
F
or
clauses
whic
h
all
con
tain
functions,
the
existence
of
an
LGI
is
still
an
op
en
question
and
ev
en
for
the
case
where
S
con
tains
at
least
one
non-tautologous
function-free
clause,
the
pro
of
w
as
far
from
trivial.
Ho
w
ev
er,
the
existence
of
a
GSI
in
C
is
m
uc
h
easier
to
pro
v
e.
In
fact,
a
GSI
of
a
nite
set
S
is
the
same
as
the
GSS
of
S
,
namely
the
union
of
the
clauses
in
S
after
these
are
standardized
apart.
T
o
see
the
reason
for
this
dissymmetry
,
let
us
tak
e
a
step
bac
k
from
the
clausal
framew
ork
and
consider
full
rst-order
logic
for
a
momen
t.
If


and


are
t
w
o
arbitrary
rst-order
form
ulas,
then
it
can
b
e
easily
sho
wn
that
their
least
generalization
is
just


^


:
this
conjunction
implies


and


,
and
m
ust
b
e
implied
b
y
an
y
other
form
ula
whic
h
implies
b
oth


and


.
Dually
,
the
greatest
sp
ecialization
is
just


_


:
this
is
implied
b
y
b
oth


and


and
m
ust
imply
an
y
other
form
ula
that
is
implied
b
y
b
oth


and


.
See
gure
..
No
w
supp
ose


and


are
clauses.
Then
wh
y
do
w
e
ha
v
e
a
problem
in
nding
the
LGI
of


and


?
The
reason
for
this
is
that


^


is
not
a
clause.

0
GENERALIZA
TIONS
AND
SPECIALIZA
TIONS


^


   	
@
@
@
R




@
@
@
R
   	


_


Figure
.:
Least
generalization
and
greatest
sp
ecialization
in
rst-order
logic
Instead
of
using


^


,
w
e
ha
v
e
to
nd
some
least
clause
whic
h
implies
b
oth
clauses


and


.
Suc
h
a
clause
app
ears
quite
hard
to
nd
sometimes.
On
the
other
hand,
in
case
of
sp
ecialization
there
is
no
problem.
Here
w
e
can
tak
e


_


as
GSI,
since


_


is
equiv
alen
t
to
a
clause,
if
w
e
handle
the
univ
ersal
quan
tiers
in
fron
t
of
a
clause
prop
erly
.
If


and


are
standardized
apart,
then
the
form
ula


_


is
equiv
alen
t
to
the
clause
whic
h
is
the
union
of


and


.
This
fact
w
as
used
in
the
pro
of
of
Lemma
..
Supp
ose
S
=
fD

;
:
:
:
;
D
n
g,
and
D
0

;
:
:
:
;
D
0
n
are
v
arian
ts
of
these
clauses
whic
h
are
standardized
apart.
Then
clearly
D
=
D
0

[
:
:
:
[
D
0
n
is
a
GSI
of
S
,
since
it
follo
ws
from
Lemma
.
that
an
y
sp
ecialization
of
S
under
implication
is
implied
b
y
D
.
Th
us
w
e
ha
v
e
the
follo
wing
result:
Theorem
.
(Existence
of
GSI
in
C
)
L
et
C
b
e
a
clausal
language.
Then
for
every
nite
S

C
,
ther
e
exists
a
GSI
of
S
in
C
.
The
previous
theorem
holds
for
clauses
in
general,
so
in
particular
also
for
function-free
clauses.
F
urthermore,
Corollary
.
guaran
tees
us
that
in
a
func-
tion-free
clausal
language,
an
LGI
of
ev
ery
nite
S
exists.
This
means
that
the
set
of
function-free
clauses
quasi-ordered
b
y
logical
implication,
is
in
fact
a
lattice.
Corollary
.
(Lattice-structure
of
function-free
clauses
under
j
=)
A
function-fr
e
e
clausal
language
or
der
e
d
by
implic
ation
is
a
lattic
e.
In
case
of
a
Horn
language
H
,
w
e
cannot
apply
the
same
pro
of
metho
d
as
in
the
case
of
a
clausal
language,
since
the
union
of
t
w
o
Horn
clauses
need
not
b
e
a
Horn
clause
itself.
In
fact,
w
e
can
sho
w
that
not
ev
ery
nite
set
of
Horn
clauses
has
a
GSI
in
H
.
Here
w
e
can
use
the
same
clauses
that
w
e
used
to
sho
w
that
sets
of
Horn
clauses
need
not
ha
v
e
an
LGI
in
H
,
this
time
from
the
p
ersp
ectiv
e
of
sp
ecialization
instead
of
generalization.
Again,
let
D

=
P
(f

(x))
 
P
(x),
D

=
P
(f

(x))
 
P
(x),
C

=
P
(f
(x))
 
P
(x)
and
C

=
P
(f

(y
))
 
P
(x).
Then
C

j
=
fD

;
D

g
and
C

j
=
fD

;
D

g,
and
there
is
no
Horn
clause
D
suc
h
that
D
j
=
D

,
D
j
=
D

,
C

j
=
D
and
C

j
=
D
.
Hence
there
is
no
GSI
of
fC

;
C

g
in
H
.
.
Least
generalizations
under
relativ
e
implication
Implication
is
stronger
than
subsumption,
but
r
elative
implication
is
ev
en
more
p
o
w
erful,
b
ecause
bac
kground
kno
wledge
can
b
e
used
to
mo
del
all
sorts
of
useful

..
LEAST
GENERALIZA
TIONS
UNDER
RELA
TIVE
IMPLICA
TION

prop
erties
and
relations.
In
this
section,
w
e
will
discuss
least
generalizations
under
implication
relativ
e
to
some
giv
en
bac
kground
kno
wledge

(LGR's).
In
the
next
section,
w
e
treat
greatest
sp
ecializations
under
relativ
e
implication.
First,
w
e
will
pro
v
e
the
equiv
alence
b
et
w
een
our
denition
of
relativ
e
impli-
cation
and
a
denition
giv
en
b
y
Niblett
[Nib,
p.
].
He
giv
es
the
follo
wing
denition
of
subsumption
relativ
e
to
a
bac
kground
kno
wledge

(to
distinguish
it
from
our
notion
of
subsumption,
w
e
will
call
this
`N-subsumption'):

Denition
.
Clause
C
N-subsumes
clause
D
with
resp
ect
to
bac
kground
kno
wledge

if
there
is
a
substitution

suc
h
that

`
(C

!
D
)
(here
`!'
is
the
implication-connectiv
e,
and
``'
is
an
arbitrary
sound
and
complete
pro
of
pro
cedure).

Prop
osition
.
L
et
C
and
D
b
e
clauses
and

b
e
a
set
of
clauses.
Then
C
N-subsumes
D
with
r
esp
e
ct
to

i
C
j
=

D
.
Pro
of
C
N-subsumes
D
with
resp
ect
to

i
There
is
a

suc
h
that

`
(C

!
D
)
i
(b
y
sound-
and
completeness
of
``')
There
is
a

suc
h
that

j
=
(C

!
D
)
i
(b
y
Theorem
A.)
There
is
a

suc
h
that

[
fC

g
j
=
D
i
(for
the
`if
',
put

=
")

[
fC
g
j
=
D
i
C
j
=

D
.

Since
j
=
is
the
sp
ecial
case
of
j
=

where

is
empt
y
,
our
coun
terexamples
to
the
existence
of
LGI's
or
GSI's
in
H
are
also
coun
terexamples
to
the
existence
of
LGR's
or
GSR's
in
H
.
In
other
w
ords,
the
` '-en
tries
in
the
second
ro
w
of
T
able
.
carry
o
v
er
to
the
third
ro
w.
F
or
general
clauses,
the
LGR-question
also
has
a
negativ
e
answ
er.
W
e
will
sho
w
here
that
ev
en
if
S
and

are
b
oth
nite
sets
of
function-fr
e
e
clauses,
an
LGR
of
S
relativ
e
to

need
not
exist.
Let
D

=
P
(a),
D

=
P
(b),
S
=
fD

;
D

g,
and

=
f(P
(a)
_
:Q(x));
(P
(b)
_
:Q(x))g.
W
e
will
sho
w
that
this
S
has
no
LGR
relativ
e
to

in
C
.
Supp
ose
C
is
an
LGR
of
S
relativ
e
to
.
Note
that
if
C
con
tains
the
literal
P
(a),
then
the
Herbrand
in
terpretation
whic
h
mak
es
P
(a)
true
and
whic
h
mak
es
all
other
ground
literals
false,
w
ould
b
e
a
mo
del
of

[
fC
g
but
not
of
D

,
so
then
w
e
w
ould
ha
v
e
C
j
=

D

.
Similarly
,
if
C
con
tains
P
(b)
then
C
j
=

D

.
Hence
C
cannot
con
tain
P
(a)
or
P
(b).
No
w
let
d
b
e
a
constan
t
not
app
earing
in
C
.
Let
D
=
P
(x)
_
Q(d),
then
D
j
=

S
.
By
the
denition
of
an
LGR,
w
e
should
ha
v
e
D
j
=

C
.
Then
b
y
the
Subsumption
Theorem,
there
m
ust
b
e
a
deriv
ation
from

[
fD
g
of
a
clause
E
,
whic
h
subsumes
C
.
The
set
of
all
clauses
whic
h
can
b
e
deriv
ed
(in
0
or
more
resolution-steps)
from

[
fD
g
is

[
fD
g
[
f(P
(a)
_
P
(x));
(P
(b)
_
P
(x))g
.
But
none
of
these
clauses
subsumes
C
,
b
ecause
C
do
es
not
con
tain
the
constan
t
d,
nor
the
literals
P
(a)
or
P
(b).
Hence
D
j
=

C
,
con
tradicting
the
assumption
that
C
is
an
LGR
of
S
relativ
e
to

in
C
.

Niblett
attributes
this
denition
to
Plotkin,
though
Plotkin
giv
es
a
rather
dieren
t
de-
nition
of
relativ
e
subsumption,
as
w
e
ha
v
e
seen
in
Section
..


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS
As
w
e
ha
v
e
seen,
in
general
the
LGR
of
S
relativ
e
to

need
not
exist.
Ho
w
ev
er,
w
e
can
iden
tify
a
sp
ecial
case
in
whic
h
the
LGR
do
es
exist.
This
case
migh
t
b
e
of
practical
in
terest.
Supp
ose

=
fL

;
:
:
:
;
L
m
g
is
a
nite
set
of
function-fr
e
e
gr
ound
literals.
W
e
can
assume

do
es
not
con
tain
complemen
tary
literals
(i.e.,
A
and
:A),
for
otherwise

w
ould
b
e
inconsisten
t.
Also,
supp
ose
S
=
fD

;
:
:
:
;
D
n
g
is
a
set
of
clauses,
at
least
one
of
whic
h
is
non-tautologous
and
function-free.
Then
C
j
=

D
i
i
fC
g
[

j
=
D
i
i
C
j
=
D
i
_
:(L

^
:
:
:
^
L
m
)
i
C
j
=
D
i
_
:L

_
:
:
:
_
:L
m
.
This
means
that
an
LGI
of
the
set
of
clauses
fD

_
:L

_
:
:
:
_
:L
m
;
:
:
:
;
D
n
_
:L

_
:
:
:
_
:L
m
g
is
also
an
LGR
of
S
relativ
e
to
.
If
some
D
k
_
:L

_
:
:
:
_
:L
m
is
non-tautologous
and
function-free,
this
LGI
exists
and
is
computable.
Hence
in
this
sp
ecial
case,
the
LGR
of
S
relativ
e
to

exists
and
is
computable.
.
Greatest
sp
ecializations
under
relativ
e
implica-
tion
Since
the
coun
terexample
to
the
existence
of
GSI's
in
H
is
also
a
coun
terexample
to
the
existence
of
GSR's
in
H
,
the
only
remaining
question
in
the
j
=

-order
is
the
existence
of
GSR's
in
C
.
The
answ
er
to
this
question
is
p
ositiv
e.
In
fact,
lik
e
the
GSS
and
the
GSI,
the
GSR
of
some
nite
set
S
in
C
is
just
the
union
of
the
(standardized
apart)
clauses
in
S
.
Theorem
.
(Existence
of
GSR
in
C
)
L
et
C
b
e
a
clausal
language
and


C
.
Then
for
every
nite
S

C
,
ther
e
exists
a
GSR
of
S
r
elative
to

in
C
.
Pro
of
Supp
ose
S
=
fD

;
:
:
:
;
D
n
g

C
.
Without
loss
of
generalit
y
,
w
e
assume
the
clauses
in
S
are
standardized
apart.
Let
D
=
D

[
:
:
:
[
D
n
,
then
D
i
j
=

D
,
for
ev
ery


i

n.
No
w
let
C

C
b
e
suc
h
that
D
i
j
=

C
,
for
ev
ery


i

n.
Then
from
Lemma
.,
w
e
ha
v
e
D
j
=

C
.
Hence
D
is
a
GSR
of
S
relativ
e
to

in
C
.

.	
Summary
In
ILP
,
the
three
main
generalit
y
orders
are
subsumption,
implication
and
rel-
ativ
e
implication.
The
t
w
o
main
languages
are
clausal
languages
and
Horn
languages.
This
giv
es
a
total
of
six
dieren
t
ordered
sets.
In
this
c
hapter,
w
e
ha
v
e
giv
en
a
systematic
treatmen
t
of
the
existence
or
non-existence
of
least
gen-
eralizations
and
greatest
sp
ecializations
in
eac
h
of
these
six
ordered
sets.
The
outcome
of
this
in
v
estigation
has
b
een
summarized
in
T
able
.
on
p.
.
The
only
remaining
op
en
question
is
the
existence
or
non-existence
of
a
least
gen-
eralization
under
implication
in
C
for
sets
of
clauses
whic
h
all
con
tain
function
sym
b
ols.
T
able
.
mak
es
explicit
the
trade-o
b
et
w
een
dieren
t
generalit
y
orders.
On
the
one
hand,
implication
is
b
etter
suited
as
a
generalit
y
order
than
sub-
sumption,
particularly
in
case
of
recursiv
e
clauses.
Relativ
e
implication
is
still

.	.
SUMMAR
Y

b
etter,
b
ecause
it
allo
ws
us
to
tak
e
bac
kground
kno
wledge
in
to
accoun
t.
On
the
other
hand,
w
e
can
see
from
the
table
that
as
far
as
the
existence
of
least
generalizations
go
es,
subsumption
is
more
attractiv
e
than
logical
implication,
and
logical
implication
is
in
turn
more
attractiv
e
than
relativ
e
implication.
F
or
subsumption,
least
generalizations
alw
a
ys
exist.
F
or
logical
implication,
w
e
can
only
pro
v
e
the
existence
of
least
generalizations
in
the
presence
of
a
function-
free
clause.
And
nally
,
for
relativ
e
implication,
least
generalizations
need
not
ev
en
exist
in
a
function-free
language.
In
practice
this
means
that
w
e
cannot
ha
v
e
it
all:
if
w
e
c
ho
ose
to
use
a
v
ery
strong
generalit
y
order,
w
e
ha
v
e
few
p
ositiv
e
results
to
go
on,
whereas
if
w
e
w
an
t
to
guaran
tee
the
existence
of
least
generalizations,
w
e
are
committed
to
the
w
eak
est
generalit
y
order:
subsump-
tion.


GENERALIZA
TIONS
AND
SPECIALIZA
TIONS

App
endix
A
Denitions
from
Logic
First-or
der
lo
gic
w
as
initially
conceiv
ed
b
y
Gottlob
F
rege
[F
re	
],
and
further
dev
elop
ed
b
y
Alfred
North
Whitehead
and
Bertrand
Russell
[WR
].
Its
se-
man
tics
w
as
dev
elop
ed
b
y
Alfred
T
arski
[T
ar
,
T
ar
].
In
this
app
endix,
w
e
include
the
denitions
from
rst-order
logic
that
are
used
in
this
thesis.
The
app
endix
is
mainly
in
tended
to
mak
e
the
thesis
self-
con
tained,
it
do
es
not
con
tain
a
full
discussion
with
examples.
F
or
a
more
extensiv
e
in
tro
duction,
w
e
refer
to
[CL,
Llo,
Men
,
BJ	
].
A.
Syn
tax
The
syn
tax
of
rst-order
logic
denes
what
constitutes
a
w
ell-formed
form
ula.
Denition
A.
An
alphab
et
consists
of
the
follo
wing
sym
b
ols:
.
A
set
of
c
onstants
:
a;
b;
:
:
:
,
whic
h
ma
y
b
e
subscripted.
.
A
set
of
variables
:
u;
v
;
w
;
x;
y
;
:
:
:
,
whic
h
ma
y
b
e
subscripted.
.
A
set
of
function
symb
ols
:
f
;
g
;
:
:
:
,
whic
h
ma
y
b
e
subscripted.
Eac
h
function
sym
b
ol
has
a
natural
n
um
b
er
(its
arity)
assigned
to
it.
.
A
non-empt
y
set
of
pr
e
dic
ate
symb
ols
:
P
;
Q;
:
:
:
,
whic
h
ma
y
b
e
subscripted.
Eac
h
predicate
sym
b
ol
has
a
natural
n
um
b
er
(its
arity)
assigned
to
it.
.
The
follo
wing
v
e
c
onne
ctives
:
:,
^,
_,
!
and
$.
.
Tw
o
quantiers:
	
(called
the
existential
quan
tier)
and

(called
the
universal
quan
tier).
.
Three
punctuation
symb
ols
:
`(',
`)'
and
`,'.

The
arity
of
a
function
or
predicate
sym
b
ol
is
the
n
um
b
er
of
its
argumen
ts.
Denition
A.
T
erms
are
dened
as
follo
ws:
.
A
constan
t
is
a
term.
.
A
v
ariable
is
a
term.
.
If
f
is
an
n-ary
function
sym
b
ol
and
t

;
:
:
:
;
t
n
are
terms,
then
f
(t

;
:
:
:
;
t
n
)
is
a
term.




APPENDIX
A.
DEFINITIONS
FR
OM
LOGIC
Denition
A.
Wel
l-forme
d
formulas
(or
just
formulas)
are
dened
as
follo
ws:
.
If
P
is
an
n-ary
predicate
sym
b
ol
and
t

;
:
:
:
;
t
n
are
terms,
then
P
(t

;
:
:
:
;
t
n
)
is
a
form
ula,
called
an
atom.
.
If

is
a
form
ula,
then
:
is
a
form
ula.
.
If

and
 
are
form
ulas,
then
(
^
 
),
(
_
 
),
(
!
 
)
and
(
$
 
)
are
form
ulas.
.
If

is
a
form
ula
and
x
is
a
v
ariable,
then
	x

and
x

are
form
ulas.
A
form
ula
whic
h
is
not
an
atom
is
called
a
c
omp
osite
form
ula.

Denition
A.
The
rst-or
der
language
giv
en
b
y
an
alphab
et
is
the
set
of
all
form
ulas
whic
h
can
b
e
constructed
from
the
sym
b
ols
of
the
alphab
et.

Denition
A.
The
sc
op
e
of
x
(resp
ectiv
ely
	x)
in
x

(resp.
	x
)
is
.

Denition
A.
A
b
ound
o
c
curr
enc
e
of
a
v
ariable
in
a
form
ula
is
an
o
ccurrence
of
this
v
ariable
immediately
follo
wing
a
quan
tier
or
an
o
ccurrence
within
the
scop
e
of
a
quan
tier
whic
h
has
the
same
v
ariable
immediately
after
the
quan-
tier.
An
o
ccurrence
of
a
v
ariable
whic
h
is
not
b
ound,
is
called
fr
e
e.

Denition
A.
A
close
d
formula
is
a
form
ula
whic
h
do
es
not
con
tain
an
y
free
o
ccurrences
of
v
ariables.

Denition
A.
A
gr
ound
term
is
a
term
whic
h
do
es
not
con
tain
an
y
v
ariables.
A
gr
ound
formula
is
a
form
ula
whic
h
do
es
not
con
tain
an
y
v
ariables.

A.
Seman
tics
The
seman
tics
of
rst-order
logic
is
concerned
with
interpr
etations,
whic
h
giv
e
meaning
to
the
form
ulas
in
a
language.
A..
In
terpretations
A
pre-in
terpretation
is
a
mapping
from
terms
in
the
language
to
ob
jects
in
a
domain.
Denition
A.	
A
pr
e-interpr
etation
J
of
a
rst-order
language
L
consists
of
the
follo
wing:
.
A
non-empt
y
set
D
,
called
the
domain
of
the
pre-in
terpretation.
.
Eac
h
constan
t
in
L
is
assigned
an
elemen
t
of
D
.
.
Eac
h
n-ary
function
sym
b
ol
f
in
L
is
assigned
a
mapping
J
f
from
D
n
to
D
.


A..
SEMANTICS

The
domain
D
ma
y
b
e
either
nite
or
innite.
Here
D
n
=
f(d

;
:
:
:
;
d
n
)
j
d
i

D
;
for
ev
ery


i

ng.
The
mapping
from
v
ariables
to
ob
jects
in
the
domain
is
done
b
y
a
variable
assignment:
Denition
A.0
Let
J
b
e
a
pre-in
terpretation
with
domain
D
of
a
rst-order
language
L.
A
variable
assignment
V
with
resp
ect
to
L,
is
a
mapping
from
the
set
of
v
ariables
in
L
to
the
domain
D
of
J
.
W
e
use
V
(x=d)
to
denote
the
v
ariable
assignmen
t
whic
h
maps
the
v
ariable
x
to
d

D
and
maps
the
other
v
ariables
according
to
V
.

The
com
bination
of
a
pre-in
terpretation
and
a
v
ariable
assignmen
t
assigns
an
ob
ject
in
the
domain
to
eac
h
term
in
the
language:
Denition
A.
Let
J
b
e
a
pre-in
terpretation
with
domain
D
of
a
rst-order
language
L,
and
let
V
b
e
a
v
ariable
assignmen
t
w.r.t.
L.
The
term
assignment
w.r.t.
J
and
V
of
the
terms
in
L
is
the
follo
wing
mapping
from
the
set
of
terms
in
L
to
the
domain
D
:
.
Eac
h
constan
t
is
mapp
ed
to
an
elemen
t
in
D
b
y
J
.
.
Eac
h
v
ariable
is
mapp
ed
to
an
elemen
t
in
D
b
y
V
.
.
If
d

;
:
:
:
;
d
n
are
the
elemen
ts
of
the
domain
to
whic
h
the
terms
t

;
:
:
:
;
t
n
are
mapp
ed,
resp
ectiv
ely
,
and
J
f
is
the
function
from
D
n
to
D
assigned
to
the
function
sym
b
ol
f
b
y
J
,
then
the
term
f
(t

;
:
:
:
;
t
n
)
is
mapp
ed
to
J
f
(d

;
:
:
:
;
d
n
).

Giv
en
a
pre-in
terpretation,
an
in
terpretation
is
a
mapping
from
form
ulas
to
truth-v
alues:
Denition
A.
An
interpr
etation
I
of
a
rst-order
language
L
consists
of
the
follo
wing:
.
A
pre-in
terpretation
J
,
with
some
domain
D
,
of
L.
I
is
b
ase
d
on
J
.
.
Eac
h
n-ary
predicate
sym
b
ol
P
in
L
is
assigned
a
mapping
I
P
from
D
n
to
fT
;
F
g.

Denition
A.
Let
I
b
e
an
in
terpretation,
based
on
the
pre-in
terpretation
J
with
domain
D
,
of
the
rst-order
language
L,
and
let
V
b
e
a
v
ariable
assignmen
t
w.r.t.
L.
Let
Z
b
e
the
term
assignmen
t
w.r.t.
J
and
V
.
Then
a
form
ula

in
L
has
a
truth-value
under
I
and
V
,
as
follo
ws:
.
If

is
the
atom
P
(t

;
:
:
:
;
t
n
)
and
d
i
is
the
domain-elemen
t
assigned
to
t
i
b
y
Z
(i
=
;
:
:
:
;
n),
then
the
truth-v
alue
of

under
I
and
V
is
I
P
(d

;
:
:
:
;
d
n
).
.
If

is
a
form
ula
of
the
form
: 
,
( 
^
),
( 
_
),
( 
!
)
or
( 
$
),
then
the
truth-v
alue
of

is
determined
b
y
the
follo
wing
truth-table
for
the
v
e
connectiv
es:


As
can
b
e
seen
from
this
table,
the
connectiv
e
`:'
is
to
b
e
in
terpreted
as
`not',
`^'
as
`and',
`_'
as
`or',
`!'
as
`if:
:
:
then'
and
`$'
as
`if,
and
only
if
'.


APPENDIX
A.
DEFINITIONS
FR
OM
LOGIC
 

: 
( 
^
)
( 
_
)
( 
!
)
( 
$
)
T
T
F
T
T
T
T
T
F
F
F
T
F
F
F
T
T
F
T
T
F
F
F
T
F
F
T
T
T
able
A.:
The
truth-table
for
the
v
e
connectiv
es
.
If

is
a
form
ula
of
the
form
	x
 
,
then

has
truth-v
alue
T
under
I
and
V
if
there
exists
an
elemen
t
d

D
for
whic
h
 
has
truth-v
alue
T
under
I
and
V
(x=d).
Otherwise,

has
truth-v
alue
F
under
I
and
V
.
.
If

is
a
form
ula
of
the
form
x
 
,
then

has
truth-v
alue
T
under
I
and
V
if
for
all
elemen
ts
d

D
,
 
has
truth-v
alue
T
under
I
and
V
(x=d).
Otherwise,

has
truth-v
alue
F
under
I
and
V
.

It
is
not
v
ery
dicult
to
see
that
the
truth-v
alue
under
some
I
and
V
of
a
close
d
form
ula
do
es
not
dep
end
on
the
v
ariable
assignmen
t
V
.
In
this
thesis,
w
e
are
only
in
terested
in
closed
form
ulas,
so
w
e
can
lea
v
e
out
the
v
ariable
assignmen
t
V
and
sp
eak
of
\truth-v
alue
under
I
"
instead
of
\truth-v
alue
under
I
and
V
".
Also,
when
w
e
use
the
w
ord
`form
ula'
later
on,
w
e
mean
`closed
form
ula'.
Denition
A.
Let

b
e
a
form
ula
in
the
rst-order
language
L
and
I
an
in
terpretation
of
L.
Then

is
said
to
b
e
true
under
I
if
its
truth-v
alue
under
I
is
T
.
I
is
then
said
to
satisfy
,
or
to
make

true.
Similarly
,

is
said
to
b
e
false
under
I
if
its
truth-v
alue
is
F
under
I
.
I
is
then
said
to
falsify
,
or
to
make

false.

A..
Mo
dels
An
in
terpretation
is
a
mo
del
of
a
form
ula,
if
it
mak
es
that
form
ula
true:
Denition
A.
Let

b
e
a
form
ula
and
I
an
in
terpretation.
I
is
said
to
b
e
a
mo
del
of

if
I
satises
.

is
then
said
to
have
I
as
a
mo
del.

Denition
A.
Let

b
e
a
set
of
form
ulas
and
I
an
in
terpretation.
I
is
said
to
b
e
a
mo
del
of

if
I
is
a
mo
del
of
all
form
ulas


.

is
then
said
to
have
I
as
a
mo
del.

Denition
A.
Let

b
e
a
set
of
form
ulas
and

a
form
ula.
Then

is
said
to
b
e
a
lo
gic
al
c
onse
quenc
e
of

(written
as

j
=
),
if
ev
ery
mo
del
of

is
also
a
mo
del
of
.
W
e
also
sometimes
sa
y

(lo
gic
al
ly)
implies
.
If

=
f 
g,
this
can
also
b
e
written
as
 
j
=
.

Denition
A.
Let

and
 b
e
sets
of
form
ulas.
Then
 is
said
to
b
e
a
lo
gic
al
c
onse
quenc
e
of

(written
as

j
=
 ),
if

j
=
,
for
ev
ery


 .


A..
SEMANTICS
	
If

is
not
a
logical
consequence
of
,
w
e
write

j
=
,
and
similarly

j
=
 if
not

j
=
 .
Denition
A.	
Tw
o
form
ulas

and
 
are
said
to
b
e
(lo
gic
al
ly)
e
quivalent,
denoted
b
y

,
 
,
if
b
oth

j
=
 
and
 
j
=

(so

and
 
ha
v
e
exactly
the
same
mo
dels).
Similarly
,
t
w
o
sets
of
form
ulas

and
 are
said
to
b
e
(lo
gic
al
ly)
e
quivalent,
if
b
oth

j
=
 and
 j
=
.

Denition
A.0
Let

b
e
a
form
ula.
Then:
.

is
called
valid,
or
a
tautolo
gy,
if
ev
ery
in
terpretation
is
a
mo
del
of
.
This
can
b
e
written
as
j
=
.

is
called
invalid
otherwise.
.

is
called
satisable,
or
c
onsistent,
if
some
in
terpretation
is
a
mo
del
of
.
.

is
called
inc
onsistent,
or
unsatisable,
or
a
c
ontr
adiction,
if
no
in
ter-
pretation
is
a
mo
del
of
.
In
other
w
ords,

is
inconsisten
t
if
it
has
no
mo
dels.
.

is
called
c
ontingent
if
it
is
satisable,
but
in
v
alid.

The
ab
o
v
e
denition
sub
divides
the
set
of
all
form
ulas
as
pictured
in
gure
A..
All
form
ulas
z
}|
{
T
autology
z
}|
{
Alw
a
ys
true
Con
tingen
t
z
}|
{
Sometimes
true,
sometimes
false
|
{z
}
Satisable
Inconsisten
t
z
}|
{
Alw
a
ys
false
|
{z
}
Unsatisable
Figure
A.:
The
class
of
tautologies,
con
tingen
t
form
ulas,
etc.
These
concepts
can
b
e
dened
similarly
for
a
set

of
form
ulas.

is
a
tautology
if
ev
ery
in
terpretation
is
a
mo
del
of
,

is
satisable
if
it
has
at
least
one
mo
del,
etc.
Note
that
an
unsatisable
set
of
form
ulas
logically
implies
an
ything,
since
it
has
no
mo
dels.
W
e
no
w
state
a
n
um
b
er
of
results,
whose
easy
pro
ofs
are
omitted.
Theorem
A.
(Deduction
Theorem)
L
et

b
e
a
set
of
formulas
and

and
 
b
e
formulas.
Then

[
fg
j
=
 
i

j
=
(
!
 
).
Prop
osition
A.
L
et

b
e
a
set
of
formulas
and

a
formula.
Then

j
=

i

[
f:g
is
unsatisable.
Prop
osition
A.
If

and
 
ar
e
formulas,
then

,
 
i
j
=
(
$
 
).
Prop
osition
A.
The
fol
lowing
assertions
hold.
.

,
::

0
APPENDIX
A.
DEFINITIONS
FR
OM
LOGIC
.
(:
_
: 
)
,
:(
^
 
)
.
(:
^
: 
)
,
:(
_
 
))
.
((
_
 
)
^
)
,
((
^
)
_
( 
^
))
.
((
^
 
)
_
)
,
((
_
)
^
( 
_
))
.
(
!
 
)
,
(:
_
 
)
.
(
$
 
)
,
((
!
 
)
^
( 
!
))
.
x

,
:	x
:
	.
	x

,
:x
:
F
or
a
pro
of
of
the
follo
wing
Compactness
Theorem,
see
[BJ	
].
Theorem
A.
(Compactness)
If

is
an
innite,
unsatisable
set
of
formu-
las,
then
ther
e
exists
a
nite,
unsatisable
subset
of
.
Note
the
follo
wing
consequence
of
this
theorem:
Theorem
A.
L
et

b
e
an
innite
set
of
formulas
and

b
e
a
formula.
If

j
=
,
then
ther
e
is
a
nite
subset

0
of
,
such
that

0
j
=
.
Pro
of
If

j
=
,
then
b
y
Prop
osition
A.,

[
f:g
is
unsatisable.
By
the
Compactness
Theorem,
there
is
a
nite
unsatisable
set
 

[
f:g.
Put

0
=
 nf:g.
Then

0

,
and
since

0
[
f:g
is
unsatisable,
w
e
ha
v
e

0
j
=

b
y
Prop
osition
A..

A..
Con
v
en
tions
to
simplify
notation
In
order
to
a
v
oid
an
o
v
erload
of
brac
k
ets,
w
e
can
mak
e
a
n
um
b
er
of
simplifying
con
v
en
tions.
Firstly
,
w
e
can
omit
the
outer
brac
k
ets
around
a
form
ula.
Sec-
ondly
,
since

_
( 
_
)
and
(
_
 
)
_

are
equiv
alen
t,
they
can
b
oth
b
e
written
as

_
 
_
.
Suc
h
a
form
ula
is
called
a
disjunction.
Similarly
,
w
e
can
write

^
 
^

(a
c
onjunction
)
instead
of

^
( 
^
)
and
(
^
 
)
^
.
Finally
,
w
e
will
sometimes
abbreviate
iterated
function
sym
b
ols
in
the
follo
wing
manner:
f

(a)
denotes
f
(f
(a)),
f

(a)
denotes
f
(f
(f
(a))),
etc.
A.
Normal
forms
In
this
section
w
e
will
dene
t
w
o
normal
forms:
prenex
conjunctiv
e
normal
form
and
Sk
olem
standard
form.
A..
Prenex
conjunctiv
e
normal
form
Denition
A.
A
liter
al
is
an
atom
or
the
negation
of
an
atom.
A
p
ositive
liter
al
is
an
atom,
a
ne
gative
liter
al
is
the
negation
of
an
atom.

Here
w
e
adopt
the
notational
con
v
en
tion
that
the
negation
of
a
negativ
e
literal
is
the
atom
in
that
literal:
if
L
=
:A,
then
:L
=
A.
Denition
A.
A
clause
is
a
nite
disjunction
of
zero
or
more
literals.


A..
NORMAL
F
ORMS

A
disjunction
of
zer
o
literals
is
called
the
empty
clause,
denoted
b
y
.
It
represen
ts
a
con
tradiction.
Clauses
are
imp
ortan
t,
b
ecause
sets
of
clauses
are
commonly
used
to
express
theories
in
Inductiv
e
Logic
Programming.
Denition
A.
A
form
ula
is
in
pr
enex
c
onjunctive
normal
form
if
it
has
the
follo
wing
form:
q

x

:
:
:
q
n
x
n
|
{z
}
P
r
enex
(C

^
:
:
:
^
C
m
)
|
{z
}
M
atr
ix
;
where
eac
h
q
i
is
either
	
or
,
x

;
:
:
:
;
x
n
are
all
the
v
ariables
o
ccurring
in
the
form
ula,
and
eac
h
C
j
is
a
clause.
The
rst
part
of
the
form
ula
(the
sequence
of
quan
tiers
with
v
ariables)
is
called
the
pr
enex
of
the
form
ula.
The
second
part
is
called
the
matrix
of
the
form
ula

,
whic
h
w
e
sometimes
abbreviate
to
M
[x

;
:
:
:
;
x
m
].

In
fact,
an
y
form
ula

can
b
e
transformed
in
to
an
equiv
alen
t
form
ula
 
in
prenex
conjunctiv
e
normal
form
(see
pp.
{	
of
[CL]
or
Prop
osition
.
of
[Llo]):
Theorem
A.
L
et

b
e
a
formula.
Then
ther
e
exists
a
formula
 
in
pr
enex
c
onjunctive
normal
form,
such
that

and
 
ar
e
e
quivalent.
A..
Sk
olem
standard
form
This
section
discusses
the
Sk
olem
standard
form
of
a
form
ula.
It
is
obtained
from
the
prenex
conjunctiv
e
normal
form
b
y
replacing
existen
tially
quan
tied
v
ariables
b
y
functional
terms.
Denition
A.
Let

=
q

x

:
:
:
q
n
x
n
M
[x

;
:
:
:
;
x
m
]
b
e
a
form
ula
in
prenex
conjunctiv
e
normal
form.
Then
a
Skolemize
d
form
of

is
a
form
ula

0
obtained
b
y
applying
the
follo
wing
pro
cedure
to
:
.
Set

0
to
.
.
If
the
prenex
of

0
con
tains
only
univ
ersal
quan
tiers,
then
stop.
.
Let
q
i
b
e
the
rst
(from
the
left)
existen
tial
quan
tier
in

0
.
Let
x
i

;
:
:
:
;
x
i
j
b
e
the
v
ariables
on
the
left
of
x
i
(that
is,
those
v
ariables
from
x

;
:
:
:
;
x
i 
that
ha
v
e
not
b
een
deleted).
.
Add
a
new
j
-ary
function
sym
b
ol,
whic
h
w
e
denote
here
b
y
f
,
to
the
alphab
et.
Replace
eac
h
o
ccurrence
of
x
i
in
the
matrix
of

0
b
y
the
term
f
(x
i

;
:
:
:
;
x
i
j
).
If
there
are
no
univ
ersal
quan
tiers
to
the
left
of
x
i
in

0
,
then
replace
eac
h
o
ccurrence
of
x
i
b
y
a
new
constan
t
whic
h
is
added
to
the
alphab
et.
.
Delete
	x
i
from
the
prenex
of

0
.
.
Goto
step
n
um
b
er
.
The
new
function
sym
b
ols
and
constan
ts
whic
h
are
added
to
the
alphab
et
are
called
Skolem
functions
and
Skolem
c
onstants,
resp
ectiv
ely
.


This
term
`matrix'
is
just
a
name
w
e
use,
it
do
es
not
ha
v
e
v
ery
m
uc
h
in
common
with
the
mathematical
concept
of
a
matrix.


APPENDIX
A.
DEFINITIONS
FR
OM
LOGIC
F
or
example,
xy
P
(x;
y
;
f
(x;
y
))
is
a
Sk
olemized
form
of
xy
	z
P
(x;
y
;
z
),
obtained
b
y
replacing
the
existen
tially
quan
tied
v
ariable
z
b
y
the
term
f
(x;
y
).
The
standard
form
of
a
form
ula
is
a
conjunction
of
univ
ersally
quan
tied
clauses.
Denition
A.
Let

b
e
a
(not
necessarily
closed)
form
ula
and
x

;
:
:
:
;
x
n
b
e
all
distinct
v
ariables
that
o
ccur
free
in
.
Then
()
denotes
the
closed
form
ula
x

:
:
:
x
n
.

Denition
A.
Let

b
e
a
form
ula,

0
b
e
a
prenex
conjunctiv
e
normal
form
of

and

00
=
(C

^
:
:
:
^
C
n
)
b
e
a
Sk
olemized
form
of

0
.
Then
 
=
(C

)
^
:
:
:
^
(C
n
)
is
called
a
Skolem
standar
d
form
(or
just
a
standar
d
form)
of
.
W
e
sa
y

has
 
as
a
standard
form.

The
standard
form
of
a
set
f

;
:
:
:
;

n
g
of
form
ulas
is
simply
the
standard
form
of
the
form
ula


^
:
:
:
^

n
.
A
standard
form
(C

)
^
:
:
:
^
(C
n
)
can
also
b
e
written
as
a
set
fC

;
:
:
:
;
C
n
g
of
clauses.
When
w
e
are
dealing
with
clauses,
w
e
will
assume
eac
h
clause
to
b
e
univ
ersally
quan
tied.
So
for
instance,
if

=
fC

;
:
:
:
;
C
n
g
is
a
set
of
clauses
and
C
is
a
clause,
w
e
use

j
=
C
to
abbreviate
(C

)
^
:
:
:
^
(C
n
)
j
=
(C
).
Putting
a
form
ula
in
standard
from
do
es
not
preserv
e
logical
equiv
alence.
F
or
instance,
P
(a)
is
a
standard
form
of
	x
P
(x),
but
	x
P
(x)
,
P
(a),
b
ecause
	x
P
(x)
j
=
P
(a).
Ho
w
ev
er,
b
y
the
follo
wing
theorem
(Theorem
.
of
[CL
]),
standard
form
do
es
preserv
e
unsatisabilit
y
.
Theorem
A.
L
et

b
e
a
formula
and
 
b
e
a
standar
d
form
of
.
Then

is
unsatisable
i
 
is
unsatisable.
A.
Herbrand
in
terpretations
Herbr
and
in
terpretations
are
in
terpretations
whic
h
ha
v
e
the
set
of
ground
terms
as
domain
and
whic
h
in
terpret
eac
h
ground
term
in
the
language
as
that
same
ground
term
in
the
domain.
Denition
A.
Let
L
b
e
a
rst-order
language.
The
Herbr
and
universe
U
L
for
L
is
the
set
of
all
ground
terms
whic
h
can
b
e
formed
out
of
the
constan
ts
and
function
sym
b
ols
in
L.
In
case
L
do
es
not
con
tain
an
y
constan
ts,
w
e
add
one
arbitrary
constan
t
to
the
alphab
et
to
b
e
able
to
form
ground
terms.

Denition
A.
Let
L
b
e
a
rst-order
language.
The
Herbr
and
b
ase
B
L
for
L
is
the
set
of
all
ground
atoms
whic
h
can
b
e
formed
out
of
the
predicate
sym
b
ols
in
L
and
the
terms
in
the
Herbrand
univ
erse
U
L
.

Denition
A.	
Let
L
b
e
a
rst-order
language.
The
Herbr
and
pr
e-inter-
pr
etation
for
L
is
the
pre-in
terpretation
consisting
of
the
follo
wing:
.
The
domain
of
the
pre-in
terpretation
is
the
Herbrand
univ
erse
U
L
.
.
Constan
ts
in
L
are
assigned
themselv
es
in
U
L
.

A..
HORN
CLA
USES

.
Eac
h
n-ary
function
sym
b
ol
f
in
L
is
assigned
the
mapping
J
f
from
U
n
L
to
U
L
,
dened
b
y
J
f
(t

;
:
:
:
;
t
n
)
=
f
(t

;
:
:
:
;
t
n
).

Denition
A.0
Let
L
b
e
a
rst-order
language
and
J
an
Herbrand
pre-
in
terpretation.
An
y
in
terpretation
based
on
J
is
called
an
Herbr
and
inter-
pr
etation.

An
Herbrand
in
terpretation
I
can
b
e
iden
tied
with
the
set
of
ground
atoms
that
are
true
under
I
.
Denition
A.
Let
I
b
e
an
Herbrand
in
terpretation
of
a
rst-order
language
L.
If
I
is
a
mo
del
of
,
it
is
called
an
Herbr
and
mo
del
of
.

In
this
thesis,
w
e
will
simply
assume
some
xed
language
L,
and
sp
eak
of
interpr
etations,
instead
of
in
terpretations
of
L.
The
follo
wing
result
(see
[CL
,
Theorem
.]
or
[Llo,
Prop
osition
.])
sho
ws
that
when
w
e
are
dealing
with
clauses,
w
e
can
restrict
atten
tion
to
Her-
brand
mo
dels.
Prop
osition
A.
A
set
of
clauses

has
a
mo
del
i

has
an
Herbr
and
mo
del.
A.
Horn
clauses
Horn
clauses
are
a
restricted,
but
v
ery
useful
kind
of
clauses.
Denition
A.
A
denite
pr
o
gr
am
clause
is
a
clause
con
taining
one
p
ositiv
e,
and
zero
or
more
negativ
e
literals.
A
(denite)
go
al
is
a
clause
con
taining
only
negativ
e
literals.
A
Horn
clause
is
either
a
denite
program
clause,
or
a
denite
goal.

If
a
denite
program
clause
consists
of
the
p
ositiv
e
literal
A
and
the
nega-
tiv
e
literals
:B

;
:
:
:
:B
n
,
then
suc
h
a
clause
can
b
e
written
as
the
follo
wing
implication:
(B

^
:
:
:
^
B
n
)
!
A:
In
most
pap
ers
and
b
o
oks
ab
out
Logic
Programming,
this
is
written
as:
A
 
B

;
:
:
:
;
B
n
:
A
is
called
the
he
ad
of
the
clause,
B

;
:
:
:
;
B
n
is
called
the
b
o
dy
of
the
clause.
It
will
b
e
con
v
enien
t
to
denote
the
head
of
a
clause
C
b
y
C
+
and
the
b
o
dy
b
y
C
 .
In
case
of
an
atom
A
(that
is,
if
n
=
0),
w
e
can
omit
the
` '-sym
b
ol.
A
denite
goal
can
b
e
written
as
 
B

;
:
:
:
;
B
n
:
The
empt
y
clause

is
also
considered
to
b
e
a
goal.


APPENDIX
A.
DEFINITIONS
FR
OM
LOGIC
Denition
A.
A
denite
pr
o
gr
am
is
a
nite
set
of
denite
program
clauses.

Prop
osition
A.
(Prop
osition
.
of
[Llo
])
L
et

b
e
a
denite
pr
o
gr
am.
If
fM

;
M

;
:
:
:
;
M
k
;
:
:
:
g
is
a
(p
ossibly
innite)
set
of
Herbr
and
mo
dels
of
,
then
their
interse
ction
M
=
\
i
M
i
is
also
an
Herbr
and
mo
del
of
.
It
follo
ws
from
the
previous
prop
osition
that
the
in
tersection
of
al
l
Herbrand
mo
dels
of
,
whic
h
will
b
e
called
the
le
ast
Herbrand
mo
del,
is
itself
also
an
Herbrand
mo
del
of
.
Denition
A.
Let

b
e
a
denite
program.
The
in
tersection
of
all
Herbrand
mo
dels
of

is
called
the
le
ast
Herbr
and
mo
del
of
,
and
is
denoted
b
y
M

.

Theorem
A.
(Theorem
.
of
[Llo
])
If

is
a
denite
pr
o
gr
am,
then
M

=
fA

B

j

j
=
Ag.
A.
Substitution
and
unication
A..
Substitution
A
substitution
replaces
v
ariables
b
y
terms.
Denition
A.
A
substitution

is
a
nite
set
fx

=t

;
:
:
:
;
x
n
=t
n
g,
n

0;
where
the
x
i
are
distinct
v
ariables
and
the
t
i
are
terms.
W
e
sa
y
t
i
is
substitute
d
for
x
i
.
x
i
=t
i
is
called
a
binding
for
x
i
.
The
substitution

is
called
a
gr
ound
substitution
if
ev
ery
t
i
is
ground.
The
substitution
giv
en
b
y
the
empt
y
set
(n
=
0)
is
called
the
identity
sub-
stitution,
or
the
empty
substitution,
and
is
denoted
b
y
".

Denition
A.
An
expr
ession
is
either
a
term,
a
literal,
or
a
conjunction
or
disjunction
of
literals.
A
simple
expr
ession
is
a
term
or
a
literal.

Denition
A.
Let

=
fx

=t

;
:
:
:
;
x
n
=t
n
g
b
e
a
substitution,
and
E
an
ex-
pression.
Then
E

,
the
instanc
e
of
E
b
y

,
is
the
expression
obtained
from
E
b
y
sim
ultaneously
replacing
eac
h
o
ccurrence
of
x
i
b
y
t
i
,


i

n.
E

is
called
a
gr
ound
instanc
e
of
E
if
E

is
ground.

Denition
A.
Let

=
fx

=s

;
:
:
:
;
x
m
=s
m
g
and

=
fy

=t

;
:
:
:
;
y
n
=t
n
g
b
e
substitutions.
Then
the
c
omp
osition


is
the
substitution
obtained
from
fx

=(s


);
:
:
:
;
x
m
=(s
m

);
y

=t

;
:
:
:
;
y
n
=t
n
g
b
y
deleting
an
y
binding
x
i
=(s
i

)
for
whic
h
x
i
=
(s
i

),
and
an
y
binding
y
j
=t
j
for
whic
h
y
j

fx

;
:
:
:
;
x
m
g.

Denition
A.	
Let

and

b
e
substitutions.
W
e
sa
y

is
an
instanc
e
of

if
there
exists
a
substitution

suc
h
that


=

.


A..
SUBSTITUTION
AND
UNIFICA
TION

Prop
osition
A.
(Prop
osition
.
of
[Llo
])
L
et
E
b
e
an
expr
ession
and

,

and

b
e
substitutions.
Then
the
fol
lowing
hold:
.

=

"
=
"
.
.
(E

)
=
E
(

).
.
(

)
=

(

).
Since
(

)
=

(

),
w
e
can
omit
brac
k
ets
b
et
w
een
substitutions.
Denition
A.0
Let
E
b
e
an
expression
and

=
fx

=y

;
:
:
:
;
x
n
=y
n
g
b
e
a
substitution.
W
e
sa
y

is
a
r
enaming
substitution
for
E
if
eac
h
x
i
o
ccurs
in
E
,
and
y

;
:
:
:
;
y
n
are
distinct
v
ariables
suc
h
that
eac
h
y
i
is
either
equal
to
some
x
j
in

,
or
y
i
do
es
not
o
ccur
in
E
.

Denition
A.
Let
E
and
F
b
e
expressions.
W
e
sa
y
E
and
F
are
variants,
or
E
is
a
v
arian
t
of
F
,
if
there
exist
substitutions

and

suc
h
that
E
=
F

and
F
=
E

.

It
is
easy
to
sho
w
that
if
E
and
F
are
v
arian
ts,
then
there
are
r
enaming
sub-
stitutions

and

suc
h
that
E
=
F

and
F
=
E

.
W
e
will
sometimes
need
a
Skolem
substitution,
whic
h
substitutes
new
con-
stan
ts
for
the
v
ariables
in
a
clause.
Denition
A.
Let

b
e
a
set
of
clauses,
C
b
e
a
clause,
x

;
:
:
:
;
x
n
b
e
all
the
v
ariables
app
earing
in
C
and
a

;
:
:
:
;
a
n
b
e
distinct
constan
ts
not
app
earing
in

or
C
.
Then
the
substitution
fx

=a

;
:
:
:
;
x
n
=a
n
g
is
called
a
Skolem
substitution
for
C
w.r.t.
.

A..
Unication
A
unier
for
the
set
of
expressions
fE

;
E

;
:
:
:
;
E
n
g
is
a
substitution

suc
h
that
E


=
E


=
:
:
:
=
E
n

.
Denition
A.
Let

b
e
a
nite
set
of
expressions.
A
substitution

is
called
a
unier
for

if

is
a
singleton
(a
set
con
taining
exactly
one
elemen
t).
If
there
exists
a
unier
for
,
w
e
sa
y

is
uniable.

Denition
A.
If

is
a
unier
for

and
if
for
an
y
unier

for

there
exists
a
substitution

suc
h
that

=


,
then

is
called
a
most
gener
al
unier
(abbreviated
to
mgu)
for
.

It
can
b
e
sho
wn
that
an
y
nite
uniable
set
of
simple
expressions
has
an
mgu
(see
Theorem
.
of
[Llo
]
or
Theorem
.
of
[CL
]).


APPENDIX
A.
DEFINITIONS
FR
OM
LOGIC

Bibliograph
y
[A
GB	]
Zolt
an
Alexin,
Tib
or
Gyim
oth
y
,
and
Henrik
Bostr
om.
In
tegrating
algorithmic
debugging
and
unfolding
transformation
in
an
in
terac-
tiv
e
learner.
In
De
Raedt
[DR	
],
pages
{.
[Aha	]
Da
vid
W.
Aha.
Relating
relational
learning
algorithms.
In
Mug-
gleton
[Mug	b
],
pages
{.
[Ari0]
Aristotle.
Posterior
A
nalytics.
Harv
ard
Univ
ersit
y
Press,
Cam-
bridge
(MA),
	0.
Edited
and
translated
b
y
Hugh
T
redennic
k.
[Bac0]
F
rancis
Bacon.
Novum
Or
ganum.
0.
[Ban]
Ranan
B.
Banerji.
A
language
for
the
description
of
concepts.
Gener
al
Systems,
	:{,
	.
[BG	]
F
rancesco
Bergadano
and
Daniele
Gunetti.
Inductive
L
o
gic
Pr
o-
gr
amming:
F
r
om
Machine
L
e
arning
to
Softwar
e
Engine
ering.
The
MIT
Press,
		.
[BGA]
J.
S.
Bruner,
J.
J.
Go
o
dno
w,
and
G.
A.
Austin.
A
Study
of
Think-
ing.
Wiley
,
New
Y
ork,
	.
[BIA	]
Henrik
Bostr
om
and
P
eter
Idestam-Almquist.
Sp
ecialization
of
logic
programs
b
y
pruning
SLD-trees.
In
W
rob
el
[W
ro	
],
pages
{.
[BJ	]
George
S.
Bo
olos
and
Ric
hard
C.
Jerey
.
Computability
and
L
o
gic.
Cam
bridge
Univ
ersit
y
Press,
Cam
bridge
(UK),
third
edition,
		.
[BM	]
Mic
hael
Bain
and
Stephen
Muggleton.
Non-monotonic
learning.
In
Muggleton
[Mug	b
],
pages
{.
[Bos	a]
Henrik
Bostr
om.
Co
v
ering
vs.
divide-and-conquer
for
top-do
wn
in-
duction
of
logic
programs.
In
Pr
o
c
e
e
dings
of
the
th
International
Joint
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-	),
pages
	{
00.
Morgan
Kaufmann,
		.
[Bos	b]
Henrik
Bostr
om.
Sp
ecialization
of
recursiv
e
predicates.
In
N.
La
vra

c
and
S.
W
rob
el,
editors,
Pr
o
c
e
e
dings
of
the
th
Eur
o-
p
e
an
Confer
enc
e
on
Machine
L
e
arning
(ECML-	),
v
olume
	
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
	{0.
Springer-V
erlag,
		.



BIBLIOGRAPHY
[Bra	]
P
a
v
el
B.
Brazdil,
editor.
Pr
o
c
e
e
dings
of
the
th
Eur
op
e
an
Con-
fer
enc
e
on
Machine
L
e
arning
(ECML-	),
v
olume

of
L
e
ctur
e
Notes
in
A
rticial
Intel
ligenc
e.
Springer-V
erlag,
		.
[Bun]
W
ra
y
Bun
tine.
Generalized
subsumption.
In
Pr
o
c
e
e
dings
of
the
Eur
op
e
an
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(ECAI-),
	.
[Bun]
W
ra
y
Bun
tine.
Generalized
subsumption
and
its
applications
to
in-
duction
and
redundancy
.
A
rticial
Intel
ligenc
e,
:	{,
	.
[Car0]
Rudolf
Carnap.
L
o
gic
al
F
oundations
of
Pr
ob
ability.
Routledge
&
Kegan
P
aul,
London,
	0.
[Car]
Rudolf
Carnap.
The
Continuum
of
Inductive
Metho
ds.
The
Uni-
v
ersit
y
of
Chicago
Press,
Chicago,
	.
[CL]
Chin-Liang
Chang
and
Ric
hard
Char-T
ung
Lee.
Symb
olic
L
o
gic
and
Me
chanic
al
The
or
em
Pr
oving.
Academic
Press,
San
Diego,
	.
[DK	]
Y
annis
Dimop
oulos
and
An
tonis
Kak
as.
Ab
duction
and
inductiv
e
learning.
In
De
Raedt
[DR	
],
pages
{.
[DR	]
Luc
De
Raedt,
editor.
Pr
o
c
e
e
dings
of
the
th
International
Work-
shop
on
Inductive
L
o
gic
Pr
o
gr
amming
(ILP-	).
Katholiek
e
Uni-
v
ersiteit
Leuv
en,
		.
[DR	]
Luc
De
Raedt,
editor.
A
dvanc
es
in
Inductive
L
o
gic
Pr
o
gr
amming.
IOS
Press,
Amsterdam,
		.
[DRB	]
Luc
De
Raedt
and
Maurice
Bruyno
oghe.
A
theory
of
clausal
disco
v-
ery
.
In
Pr
o
c
e
e
dings
of
the
th
International
Joint
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-	),
pages
0{0.
Morgan
Kauf-
mann,
		.
[DRD	]
Luc
De
Raedt
and
Sa

so
D

zeroski.
First
order
j
k
-clausal
theories
are
P
A
C-learnable.
A
rticial
Intel
ligenc
e,
0:{	,
		.
[Fla	]
P
eter
A.
Flac
h.
A
framew
ork
for
Inductiv
e
Logic
Programming.
In
Muggleton
[Mug	b
],
pages
	{.
[Fla	]
P
eter
A.
Flac
h.
Inductiv
e
Logic
Programming
and
philosoph
y
of
science.
In
W
rob
el
[W
ro	
],
pages
{.
[Fla	]
P
eter
A.
Flac
h.
Conje
ctur
es:
A
n
Inquiry
Conc
erning
the
L
o
gic
of
Induction.
PhD
thesis,
Tilburg
Univ
ersit
y
,
		.
[F
re	]
Gottlob
F
rege.
Be
grisschrift,
eine
der
arithmetischen
nachge-
bildete
F
ormelspr
ache
des
r
einen
Denkens.
Halle,
	.
English
translation
in
[Hei
].
[GN]
Mic
hael
R.
Genesereth
and
Nils
J.
Nilsson.
L
o
gic
al
F
oundations
of
A
rticial
Intel
ligenc
e.
Morgan
Kaufmann,
P
alo
Alto
(CA),
	.

BIBLIOGRAPHY
	
[Go
o]
Nelson
Go
o
dman.
F
act,
Fiction,
and
F
or
e
c
ast.
Harv
ard
Univ
ersit
y
Press,
Cam
bridge
(MA),
fourth
edition,
	.
[Got]
Georg
Gottlob.
Subsumption
and
implication.
Information
Pr
o-
c
essing
L
etters,
():0	{,
	.
[Hei]
Jean
v
an
Heijeno
ort,
editor.
F
r
om
Fr
e
ge
to
G
odel:
A
Sour
c
e
Bo
ok
in
Mathematic
al
L
o
gic,
	{	.
Harv
ard
Univ
ersit
y
Press,
Cam
bridge
(MA),
	.
[Hel	]
Nicolas
Helft.
Induction
as
nonmonotonic
inference.
In
Pr
o
c
e
e
dings
of
the
st
International
Confer
enc
e
on
Principles
of
Know
le
dge
R
epr
esentation
and
R
e
asoning,
pages
	{.
Morgan
Kaufmann,
		.
[Hema]
Carl
G.
Hemp
el.
Studies
in
the
logic
of
conrmation
(part
I).
Mind,
():{,
	.
[Hemb]
Carl
G.
Hemp
el.
Studies
in
the
logic
of
conrmation
(part
I
I).
Mind,
():	{,
	.
[Hem]
Carl
G.
Hemp
el.
Philosophy
of
Natur
al
Scienc
e.
Pren
tice-Hall,
Englew
o
o
d
Clis,
	.
[Hom]
Homer.
The
Iliad.
Harv
ard
Univ
ersit
y
Press,
Cam
bridge
(MA),
	.
T
ranslated
b
y
A.
T.
Murra
y
.
Tw
o
v
olumes.
[Hum]
Da
vid
Hume.
A
n
Enquiry
Conc
erning
Human
Understanding.
Gatew
a
y
edition,
Chicago,
	.
Originally
.
[Hum]
Da
vid
Hume.
A
T
r
e
atise
of
Human
Natur
e.
Dolphin
Bo
oks.
Dou-
bleda
y
,
	.
Originally
	{0.
[IA	]
P
eter
Idestam-Almquist.
Gener
alization
of
Clauses.
PhD
thesis,
Sto
c
kholm
Univ
ersit
y
,
		.
[IA	]
P
eter
Idestam-Almquist.
Generalization
of
clauses
under
implica-
tion.
Journal
of
A
rticial
Intel
ligenc
e
R
ese
ar
ch,
:{	,
		.
[Ino	]
Katsumi
Inoue.
Linear
resolution
for
consequence
nding.
A
rticial
Intel
ligenc
e,
:0{,
		.
[Jev]
Stanley
Jev
ons.
The
Principles
of
Scienc
e:
A
T
r
e
atise.
MacMillan,
.
[KK]
Rob
ert
Ko
w
alski
and
Donald
Kuehner.
Linear
resolution
with
se-
lection
function.
A
rticial
Intel
ligenc
e,
:{0,
	.
[KKT	]
A.
C.
Kak
as,
R.
A.
Ko
w
alski,
and
F.
T
oni.
Ab
ductiv
e
Logic
Pro-
gramming.
Journal
of
L
o
gic
and
Computation,
():	{0,
		.

	0
BIBLIOGRAPHY
[Ko
w0]
Rob
ert
A.
Ko
w
alski.
The
case
for
using
equalit
y
axioms
in
auto-
matic
demonstration.
In
Pr
o
c
e
e
dings
of
the
Symp
osium
on
A
uto-
matic
Demonstr
ation,
v
olume

of
L
e
ctur
e
Notes
in
Mathematics,
pages
{.
Springer-V
erlag,
	0.
[Ko
w]
Rob
ert
A.
Ko
w
alski.
Predicate
logic
as
a
programming
language.
Information
Pr
o
c
essing,
:	{,
	.
[Kuh]
Thomas
Kuhn.
Second
though
ts
on
paradigms.
In
F
rederic
Supp
e,
editor,
The
Structur
e
of
Scientic
The
ories,
pages
	{.
Uni-
v
ersit
y
of
Illinois
Press,
second
edition,
	.
[LD	a]
Nada
La
vra

c
and
Sa

so
D

zeroski.
Inductiv
e
learning
of
relations
from
noisy
examples.
In
Muggleton
[Mug	b
],
pages
	{.
[LD	b]
Nada
La
vra

c
and
Sa

so
D

zeroski.
Renemen
t
graphs
for
F
OIL
and
LINUS.
In
Muggleton
[Mug	b
],
pages
	{.
[LD	]
Nada
La
vra

c
and
Sa

so
D

zeroski.
Inductive
L
o
gic
Pr
o
gr
amming:
T
e
chniques
and
Applic
ations.
Ellis
Horw
o
o
d,
		.
[LDG	]
N.
La
vra

c,
S.
D

zeroski,
and
M.
Grob
elnik.
Learning
non-recursiv
e
denitions
of
relations
with
LINUS.
In
Y.
Ko
drato,
editor,
Pr
o
c
e
e
dings
of
the
th
Eur
op
e
an
Working
Sessions
on
L
e
arning
(EWSL-	),
v
olume

of
L
e
ctur
e
Notes
in
A
rticial
Intel
ligenc
e,
pages
{.
Springer-V
erlag,
		.
[Lee]
Ric
hard
Char-T
ung
Lee.
A
Completeness
The
or
em
and
a
Computer
Pr
o
gr
am
for
Finding
The
or
ems
Derivable
fr
om
Given
Axioms.
PhD
thesis,
Univ
ersit
y
of
California,
Berk
eley
,
	.
[Llo]
John
W.
Llo
yd.
F
oundations
of
L
o
gic
Pr
o
gr
amming.
Springer-
V
erlag,
Berlin,
second
edition,
	.
[LNC	a]
P
atric
k
R.
J.
v
an
der
Laag
and
Shan-Hw
ei
Nienh
uys-Cheng.
Ex-
istence
and
nonexistence
of
complete
renemen
t
op
erators.
In
F.
Bergadano
and
L.
De
Raedt,
editors,
Pr
o
c
e
e
dings
of
the
th
Eu-
r
op
e
an
Confer
enc
e
on
Machine
L
e
arning
(ECML-	),
v
olume

of
L
e
ctur
e
Notes
in
A
rticial
Intel
ligenc
e,
pages
0{.
Springer-
V
erlag,
		.
[LNC	b]
P
atric
k
R.
J.
v
an
der
Laag
and
Shan-Hw
ei
Nienh
uys-Cheng.
A
note
on
ideal
renemen
t
op
erators
in
inductiv
e
logic
programming.
In
W
rob
el
[W
ro	
],
pages
{.
[Lo
v0]
Donald
W.
Lo
v
eland.
A
linear
format
for
resolution.
In
Pr
o
c
e
e
dings
of
the
IRIA
Symp
osium
on
A
utomatic
Demonstr
ation,
V
ersail
les,
F
r
anc
e,
	,
pages
{.
Springer-V
erlag,
	0.
[Lo
v]
Donald
W.
Lo
v
eland.
A
utomate
d
The
or
em
Pr
oving:
A
L
o
gic
al
Ba-
sis.
North
Holland,
New
Y
ork,
	.

BIBLIOGRAPHY
	
[Luc0]
Donald
Luc
kham.
Renemen
ts
in
resolution
theory
.
In
Pr
o
c
e
e
dings
of
the
IRIA
Symp
osium
on
A
utomatic
Demonstr
ation,
V
ersail
les,
F
r
anc
e,
	,
pages
{	0.
Springer-V
erlag,
	0.
[MB]
Stephen
Muggleton
and
W
ra
y
Bun
tine.
Mac
hine
in
v
en
tion
of
rst-
order
predicates
b
y
in
v
erting
resolution.
In
John
Laird,
editor,
Pr
o-
c
e
e
dings
of
the
th
International
Confer
enc
e
on
Machine
L
e
arning
(ICML-),
pages
	{.
Morgan
Kaufmann,
	.
[MDR	]
Stephen
Muggleton
and
Luc
De
Raedt.
Inductiv
e
Logic
Program-
ming:
Theory
and
metho
ds.
Journal
of
L
o
gic
Pr
o
gr
amming,
	{
0:	{	,
		.
[Men]
Elliott
Mendelson.
Intr
o
duction
to
Mathematic
al
L
o
gic.
W
adsw
orth
&
Bro
oks,
Belmon
t
(CA),
third
edition,
	.
[MF	]
Stephen
Muggleton
and
Cao
F
eng.
Ecien
t
induction
of
logic
pro-
grams.
In
Muggleton
[Mug	b
],
pages
{	.
[Mil]
John
Stuart
Mill.
A
System
of
L
o
gic,
R
atio
cinative
and
Inductive.
Harp
er,
New
Y
ork,
.
[Min]
Marvin
L.
Minsky
,
editor.
Semantic
Information
Pr
o
c
essing.
The
MIT
Press,
Cam
bridge
(MA),
	.
[Mit]
T
om
M.
Mitc
hell.
Generalization
as
searc
h.
A
rticial
Intel
ligenc
e,
:0{,
	.
[MP	]
Jerzy
Marcink
o
wski
and
Leszek
P
ac
holski.
Undecidabilit
y
of
the
horn-clause
implication
problem.
In
Pr
o
c
e
e
dings
of
the
r
d
A
nnual
IEEE
Symp
osium
on
F
oundations
of
Computer
Scienc
e,
pages
{
,
Pittsburg,
		.
[MP	]
Stephen
Muggleton
and
C.
Da
vid
P
age.
Self-saturation
of
denite
clauses.
In
W
rob
el
[W
ro	
],
pages
{.
[MR]
Eliana
Minicozzi
and
Ra
ymond
Reiter.
A
note
on
linear
resolution
strategies
in
consequence-nding.
A
rticial
Intel
ligenc
e,
:{0,
	.
[Mug]
Stephen
Muggleton.
Duce,
an
oracle
based
approac
h
to
construc-
tiv
e
induction.
In
Pr
o
c
e
e
dings
of
the
0th
International
Joint
Con-
fer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-),
pages
{	.
Mor-
gan
Kaufmann,
	.
[Mug	0]
Stephen
Muggleton.
Inductiv
e
Logic
Programming.
In
Pr
o
c
e
e
d-
ings
of
the
st
Confer
enc
e
on
A
lgorithmic
L
e
arning
The
ory,
T
oky
o,
		0.
Ohmsha.
[Mug	]
Stephen
Muggleton.
Inductiv
e
Logic
Programming.
New
Gener
a-
tion
Computing,
():	{,
		.

	
BIBLIOGRAPHY
[Mug	a]
Stephen
Muggleton.
Inductiv
e
logic
programming.
In
Inductive
L
o
gic
Pr
o
gr
amming
[Mug	b
],
pages
{.
[Mug	b]
Stephen
Muggleton,
editor.
Inductive
L
o
gic
Pr
o
gr
amming,
v
ol-
ume

of
APIC
Series.
Academic
Press,
		.
[Mug	c]
Stephen
Muggleton.
In
v
erting
implication.
In
S.
Muggleton
and
K.
F
uruk
a
w
a,
editors,
Pr
o
c
e
e
dings
of
the
nd
International
Work-
shop
on
Inductive
L
o
gic
Pr
o
gr
amming
(ILP-	),
T
oky
o,
		.
ICOT
Researc
h
Cen
ter.
ICOT
T
ec
hnical
Memorandum
TM-.
[MWKE	]
K.
Morik,
S.
W
rob
el,
J.-U.
Kietz,
and
W.
Emde.
Know
le
dge
A
c
qui-
sition
and
Machine
L
e
arning:
The
ory,
Metho
ds
and
Applic
ations.
Academic
Press,
London,
		.
[NCL
T	]
Shan-Hw
ei
Nienh
uys-Cheng,
P
atric
k
R.
J.
v
an
der
Laag,
and
Leon
v
an
der
T
orre.
Constructing
renemen
t
op
erators
b
y
deconstruct-
ing
logical
implication.
In
Pietro
T
orasso,
editor,
Pr
o
c
e
e
dings
of
the
r
d
Confer
enc
e
of
the
Italian
Asso
ciation
for
A
rticial
Intel
ligenc
e
(AI*IA-	),
v
olume

of
L
e
ctur
e
Notes
in
A
rticial
Intel
ligenc
e,
pages
{	.
Springer-V
erlag,
		.
[NCW	a]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
The
equiv
a-
lence
of
the
subsumption
theorem
and
the
refutation-completeness
for
unconstrained
resolution.
In
K.
Kanc
hanasut
and
J.-J.
L

evy
,
editors,
Pr
o
c
e
e
dings
of
the
Ase
an
Computer
Scienc
e
Confer
enc
e
(A
CSC-	),
v
olume
0
of
L
e
ctur
e
Notes
in
Computer
Scienc
e,
pages
	{.
Springer-V
erlag,
		.
[NCW	b]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
The
sp
ecializa-
tion
problem
and
the
completeness
of
unfolding.
In
J.
C.
v
an
Vliet,
editor,
Pr
o
c
e
e
dings
of
Computing
Scienc
e
in
the
Netherlands
(CSN-
	),
pages
{	.
SION,
		.
[NCW	c]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
Sp
ecializing
def-
inite
programs
b
y
unfolding.
In
Pr
o
c
e
e
dings
of
Benele
arn
'	.
Uni-
v
ersit

e
Libre
de
Bruxelles,
		.
[NCW	d]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
The
subsumption
theorem
in
Inductiv
e
Logic
Programming:
F
acts
and
fallacies.
In
De
Raedt
[DR	
],
pages
{0.
[NCW	e]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
The
subsumption
theorem
revisited:
Restricted
to
SLD-resolution.
In
J.
C.
v
an
Vliet,
editor,
Pr
o
c
e
e
dings
of
Computing
Scienc
e
in
the
Netherlands
(CSN-
	),
pages
{.
SION,
		.
[NCW	f
]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
Tidying
up
the
mess
around
the
subsumption
theorem
in
Inductiv
e
Logic
Program-
ming.
In
J.
C.
Bio
c
h
and
Y.-H.
T
an,
editors,
Pr
o
c
e
e
dings
of
the
Sev-

BIBLIOGRAPHY
	
enth
Dutch
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(NAIC-	),
pages
{0.
Erasm
us
Univ
ersit
y
Rotterdam,
		.
[NCW	a]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
A
complete
metho
d
for
program
sp
ecialization
based
on
unfolding.
In
W
olf-
gang
W
ahlster,
editor,
Pr
o
c
e
e
dings
of
the
Eur
op
e
an
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(ECAI-	),
pages
{,
		.
In
press.
[NCW	b]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
Least
general-
izations
and
greatest
sp
ecializations
of
sets
of
clauses.
Journal
of
A
rticial
Intel
ligenc
e
R
ese
ar
ch,
:{,
		.
[NCW	c]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
The
sp
ecializa-
tion
problem
and
the
completeness
of
unfolding.
Machine
L
e
arning,
		.
Submitted.
[NCW	d]
Shan-Hw
ei
Nienh
uys-Cheng
and
Ronald
de
W
olf.
The
subsumption
theorem
in
Inductiv
e
Logic
Programming:
F
acts
and
fallacies.
In
De
Raedt
[DR	
],
pages
{.
[Nib]
Tim
Niblett.
A
study
of
generalisation
in
logic
programs.
In
D.
Sleeman,
editor,
Pr
o
c
e
e
dings
of
the
r
d
Eur
op
e
an
Working
Ses-
sions
on
L
e
arning
(EWSL-),
pages
{,
	.
[P
ei]
Charles
Sanders
P
eirce.
Col
le
cte
d
Pap
ers.
Harv
ard
Univ
ersit
y
Press,
Cam
bridge
(MA),
	.
Edited
b
y
Charles
Harstshorne
and
P
aul
W
eiss.
V
olumes
I{VI
I.
[Plo0]
Gordon
D.
Plotkin.
A
note
on
inductiv
e
generalization.
Machine
Intel
ligenc
e,
:{,
	0.
[Ploa]
Gordon
D.
Plotkin.
A
utomatic
Metho
ds
of
Inductive
Infer
enc
e.
PhD
thesis,
Edin
burgh
Univ
ersit
y
,
	.
[Plob]
Gordon
D.
Plotkin.
A
further
note
on
inductiv
e
generalization.
Machine
Intel
ligenc
e,
:0{,
	.
[P
op	]
Karl
R.
P
opp
er.
The
L
o
gic
of
Scientic
Disc
overy.
Hutc
hinson,
London,
		.
[QCJ	]
J.
R.
Quinlan
and
R.
M.
Cameron-Jones.
F
oil:
A
midterm
rep
ort.
In
Brazdil
[Bra	
],
pages
{0.
[Qui]
J.
Ross
Quinlan.
Induction
of
decision
trees.
Machine
L
e
arning,
():{0,
	.
[Qui	0]
J.
Ross
Quinlan.
Learning
logical
denitions
from
relations.
Ma-
chine
L
e
arning,
():	{,
		0.
[Rei	]
Hans
Reic
hen
bac
h.
The
The
ory
of
Pr
ob
ability.
Univ
ersit
y
of
Cali-
fornia
Press,
Berk
eley
and
Los
Angeles,
		.

	
BIBLIOGRAPHY
[Rey0]
John
C.
Reynolds.
T
ransformational
systems
and
the
algebraic
structure
of
atomic
form
ulas.
Machine
Intel
ligenc
e,
:{,
	0.
[Rob]
J.
Alan
Robinson.
A
mac
hine
orien
ted
logic
based
on
the
resolution
principle.
Journal
of
the
A
CM,
:{,
	.
[Rou	]
C

eline
Rouv
eirol.
Extensions
of
in
v
ersion
of
resolution
applied
to
theory
completion.
In
Muggleton
[Mug	b
],
pages
{	.
[Rus]
Bertrand
Russell.
Human
Know
le
dge:
It's
Sc
op
e
and
Limits.
George
Allen
and
Un
win
Ltd.,
London,
	.
[Rus0]
Bertrand
Russell.
The
Pr
oblems
of
Philosophy.
Oxford
Univ
ersit
y
Press,
	0.
Originally
	.
[SA	]
T
aisuk
e
Sato
and
Sumitak
a
Akiba.
Inductiv
e
resolution.
In
Pr
o-
c
e
e
dings
of
the
th
International
Workshop
on
A
lgorithmic
L
e
arn-
ing
The
ory
(AL
T-	),
v
olume

of
L
e
ctur
e
Notes
in
A
rticial
Intel
ligenc
e,
pages
0{0.
Springer-V
erlag,
		.
[Sam]
Claude
A.
Samm
ut.
L
e
arning
Conc
epts
by
Performing
Exp
eri-
ments.
PhD
thesis,
Univ
ersit
y
of
New
South
W
ales,
	.
[Sam	]
Claude
A.
Samm
ut.
The
origins
of
Inductiv
e
Logic
Programming:
A
prehistoric
tale.
In
Stephen
Muggleton,
editor,
Pr
o
c
e
e
dings
of
the
r
d
International
Workshop
on
Inductive
L
o
gic
Pr
o
gr
amming
(ILP-	),
pages
{,
Ljubljana,
		.
Jo

zef
Stefan
Institute.
T
ec
hnical
Rep
ort
IJS-DP-0.
[SB]
C.
A.
Samm
ut
and
R.
B.
Banerji.
Learning
concepts
b
y
asking
questions.
In
R.
S.
Mic
halski,
J.
G.
Carb
onell,
and
T.
M.
Mitc
hell,
editors,
Machine
L
e
arning:
A
n
A
rticial
Intel
ligenc
e
Appr
o
ach,
v
olume
,
pages
{	.
Morgan
Kaufmann,
Los
Altos
(CA),
	.
[SCL	]
J.
R.
Slagle,
C.
L.
Chang,
and
R.
C.
T.
Lee.
Completeness
theo-
rems
for
seman
tic
resolution
in
consequence-nding.
In
Pr
o
c
e
e
dings
of
the
st
International
Joint
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-	),
pages
{,
		.
[Shaa]
Eh
ud
Y.
Shapiro.
An
algorithm
that
infers
theories
from
facts.
In
Pr
o
c
e
e
dings
of
the
th
International
Joint
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-),
pages
{,
V
ancouv
er,
	.
Morgan
Kaufmann.
[Shab]
Eh
ud
Y.
Shapiro.
Inductiv
e
inference
of
theories
from
facts.
Re-
searc
h
Rep
ort
	,
Y
ale
Univ
ersit
y
,
	.
[Sha]
Eh
ud
Y.
Shapiro.
A
lgorithmic
Pr
o
gr
am
Debugging.
The
MIT
Press,
	.

BIBLIOGRAPHY
	
[T
ar]
Alfred
T
arski.
Der
W
ahrheitsb
egri
in
den
formalisierten
Sprac
hen.
Studia
Philosophic
a,
pages
{0,
	.
English
translation
in
[T
ar
].
[T
ar]
Alfred
T
arski.
L
o
gic,
Semantics,
Metamathematics.
Pap
ers
fr
om
	
to
	.
Oxford
Univ
ersit
y
Press,
New
Y
ork,
	.
[TS]
Hisao
T
amaki
and
T
aisuk
e
Sato.
Unfold/fold
transformation
of
logic
programs.
In
Sten-

Ak
e
T
arnlund,
editor,
Pr
o
c
e
e
dings
of
the
nd
International
L
o
gic
Pr
o
gr
amming
Confer
enc
e,
pages
{,
Uppsala,
	.
Uppsala
Univ
ersit
y
.
[UM]
P
.
Utgo
and
T.
M.
Mitc
hell.
Acquisition
of
appropriate
bias
for
inductiv
e
concept
learning.
In
Pr
o
c
e
e
dings
of
the
National
Con-
fer
enc
e
on
A
rticial
Intel
ligenc
e,
pages
{,
Los
Altos
(CA),
	.
Morgan
Kaufmann.
[V
er]
Stev
en
V
ere.
Induction
of
concepts
in
the
predicate
calculus.
In
Pr
o
c
e
e
dings
of
the
th
International
Joint
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-),
pages
{,
	.
[V
er]
Stev
en
V
ere.
Induction
of
relational
pro
ductions
in
the
presence
of
bac
kground
information.
In
Pr
o
c
e
e
dings
of
the
th
International
Joint
Confer
enc
e
on
A
rticial
Intel
ligenc
e
(IJCAI-),
	.
[WR]
Alfred
North
Whitehead
and
Bertrand
Russell.
Principia
Mathe-
matic
a.
Cam
bridge
Univ
ersit
y
Press,
	.
Originally
	0{	.
[W
ro	]
Stefan
W
rob
el.
On
the
prop
er
denition
of
minimalit
y
in
sp
ecial-
ization
and
theory
revision.
In
Brazdil
[Bra	
],
pages
{.
[W
ro	]
Stefan
W
rob
el,
editor.
Pr
o
c
e
e
dings
of
the
th
International
Work-
shop
on
Inductive
L
o
gic
Pr
o
gr
amming
(ILP-	),
v
olume

of
GMD-Studien,
Bad
Honnef/Bonn,
		.
Gesellsc
haft
f

ur
Mathe-
matik
und
Daten
v
erarb
eitung.

Author
Index
Aha,
D.,

Akiba,
S.,
0
Alexin,
Z.,
n
Aristotle,
0
Austin,
G.,
0
Bacon,
F.,
0
Bain,
M.,
,

Banerji,
R.,

Bergadano,
F.,

Bo
olos,
G.,
,
,
0
Bostr
om,
H.,
	,
n,
,
,
,
n
Brazdil,
P
.,

Bruner,
J.,
0
Bruyno
oghe,
M.,

Bun
tine,
W.,
,
0
Cameron-Jones,
R.
M.,
,

Carnap,
R.,
0
Chang,
C.
L.,
,
,
,
,
,

Cohen,
B.,

De
Raedt,
L.,
	,
,
,

Dimop
olous,
Y.,
	
D

zeroski,
S.,
,
	,
,

Emde,
W.,

F
eng,
C.,
,

Flac
h,
P
.,
	
F
rege,
G.,

Genesereth,
M.,

Go
o
dman,
N.,
0
Go
o
dno
w,
J.,
0
Gottlob,
G.,

Grob
elnik,
M.,

Gunetti,
D.,

Gyim
oth
y
,
T.,
n
Helft,
N.,
	
Hemp
el,
C.,
0
Homer,

Hume,
D.,
0
Idestam-Almquist,
P
.,
,
,
	,
n,
,
,
n,
,
,
,

Inoue,
K.,
,
,

Jerey
,
R.,
,
,
0
Jev
ons,
S.,
0
Kak
as,
A.,
	
Kietz,
J.-U.,

Ko
w
alski,
R.,
	,
,
,

Kuehner,
D.,

Kuhn,
T.,
0
Laag,
P
.
v
an
der,
,
,

La
vra

c,
N.,
,
,

Lee,
R.
C.
T.,
,
,
,
,
,
,

Llo
yd,
J.,
,
,
0n,
,
,
,
{
Lo
v
eland,
D.,
,

Luc
kham,
D.,

Marcink
o
wski,
J.,

Mendelson,
E.,

Mill,
J.
S.,
0
Minicozzi,
E.,
,
,
0
Minsky
,
M.,

Mitc
hell,
T.,
,

Morik,
K.,

Muggleton,
S.,
,
,
,
{,
,
,
0,
,
,

Niblett,
T.,
n,
,

Nienh
uys-Cheng,
S.-H.,
,
,

Nilsson,
N.,

P
ac
holski,
L.,

	

A
UTHOR
INDEX
	
P
age,
C.
D.,
,
,
,

P
eirce,
C.
S.,
	,
0
Plotkin,
G.,
,
,
,
,
n,
0,
,
,
n
P
opp
er,
K.,
0
Quinlan,
J.
R.,
,

Reic
hen
bac
h,
H.,
0
Reiter,
R.,
,
,
0
Reynolds,
J.,
,
,
n,
0n
Robinson,
J.
A.,
,

Rouv
eirol,
C.,
0,

Russell,
B.,
0,

Samm
ut,
C.,
0
Sato,
T.,
,
0
Shapiro,
E.,
,
,
n,
,

Slagle,
J.,

T
amaki,
H.,

T
arski,
A.,

T
oni,
F.,
	
T
orre,
L.
v
an
der,

Utgo,
P
.,

V
ere,
S.,

Whitehead,
A.
N.,

W
olf,
R.
de,
n
W
rob
el,
S.,
	n,


Sub
ject
Index
ab
duction,
	
alphab
et,
,

am
biv
alen
t
leaf,
n
an
ti-symmetric,

arit
y
,

Articial
In
telligence,
,
,
0
atom,

attribute-v
alue
learning,

bac
kground
kno
wledge,
,

Bac
ktracing
Algorithm,
,
n
batc
h
learning,

bias,

binary
resolv
en
t,

binding,

b
o
dy
of
a
clause,

b
ottom-up
approac
h
to
ILP
,
,
0
b
ound
v
ariable,

cen
ter
clause,

Cigol,

clausal
language
(C
),
,
,
	
clause,
,
,
,
0
closed
form
ula,
,

restriction
to,

Compactness
Theorem,
0
complete
(w.r.t.
examples),

comp
osite
form
ula,

comp
osition,

computation
rule,

conrmatory
problem
setting,
	
Confucius,

conjunction,
0
connectiv
e,

consisten
t,
	
consisten
t
(w.r.t.
examples),

constan
t,

con
tingen
t,
	
con
tradiction,
	
correct
(w.r.t.
examples),

co
v
er,

data-mining,
	
decidable
function-free
clausal
implication,

ground
clausal
implication,

decision
tree,
,

deduction,
,

Deduction
Theorem,
	
denite
goal,

denite
program,
,
	,

denite
program
clause,

depth
of
a
term
or
clause,

deriv
ation,

disjunction,
0
domain,

Duce,

empt
y
clause
(),

empt
y
substitution,

en
umerably
innite
set,

en
umeration,

equiv
alence,
	
equiv
alence
relation,

equiv
alen
t,

example,

existen
tial
quan
tier,

explanatory
problem
setting,

expression,

falsify
,

rst-order
language,

attening,

F
oil,
,

form
ula,
	
free
v
ariable,

function
sym
b
ol,

	

SUBJECT
INDEX
		
function-free
clause,
,

generalization,
,
,
,
	
genetic
algorithm,

Golem,
,

Gottlob's
Lemma,

greatest
sp
ecialization
(GS),
,
	
in
rst-order
logic,
	
under
implication
(GSI),
	,
	,
0
for
Horn
clauses,
0
under
relativ
e
implication
(GSR),
	,

under
subsumption
(GSS),
	,
0
for
Horn
clauses,

ground
form
ula,

ground
instance,

ground
substitution,

ground
term,

head
of
a
clause,

Herbrand
base,

Herbrand
in
terpretation,
,
,

Herbrand
mo
del,
,

Herbrand
pre-in
terpretation,

Herbrand
univ
erse,

Herbrand's
Theorem,
0
Horn
clause,
,
,

Horn
language
(H
),
,
,
	
iden
tit
y
substitution,

implication,
,
,
,
,
	,
,

inconsisten
t,
	
incremen
tal
learning,

induction,

not
truth-preserving,

Inductiv
e
Logic
Programming,
,
,
,
,

history
of,
0
input
clause,
,

input
deduction,

input
deriv
ation,

input
refutation,

input
resolution,
,
,

not
complete
for
one
premise,

not
refutation-complete,

instance,

instance
set,

in
teractiv
e
learning,

in
terpretation,

in
v
alid,
	
in
v
erse
resolution,
,
,
0,
n
kno
wledge
disco
v
ery
,
	
language
bias,

lattice,
,
	
under
implication,
0
under
subsumption,
0,

learning,

least
generalization
(LG),
,
,
	
in
rst-order
logic,
	
under
implication
(LGI),
,
,
	,

computable,
	
for
Horn
clauses,

sp
ecial,

under
relativ
e
implication
(LGR),
	,
,

under
relativ
e
subsumption,

under
subsumption
(LGS),
,
	,
0
for
Horn
clauses,
0
under
T-implication,
,

least
Herbrand
mo
del,

LGI-Algorithm,

Lifting
Lemma
for
linear
resolution,

for
SLD-resolution,

for
unconstrained
resolution,

linear
deduction,

linear
deriv
ation,

linear
refutation,

linear
resolution,
,
,

Linus,
,

literal,
0
L
n
,

Logic
Programming,
,

logical
consequence,

m.c.l.-resolution,
n
Mac
hine
Learning,

Mar
vin,


00
SUBJECT
INDEX
Mis,

Mobal,

mo
del,
,

mo
del
inference
problem,
,

most
general
unier
(mgu),

m
ultiple-predicate
learning,

N-subsumption,

negativ
e
example,

negativ
e
literal,
0
neural
net
w
ork,

noise,

non-in
teractiv
e
learning,

non-monotonic
problem
setting,
	
normal
problem
setting,

notational
con
v
en
tions,
0
nth
p
o
w
ers,

nth
ro
ots,

o
v
erly
general
(w.r.t.
examples),

o
v
erly
sp
ecic
(w.r.t.
examples),

paren
t
clause,

partial
order,

p
ositiv
e
example,

p
ositiv
e
literal,
0
p
o
w
er
set,

pre-in
terpretation,

predicate
in
v
en
tion,
	
predicate
sym
b
ol,

prenex
conjunctiv
e
normal
form,

problem
setting
of
ILP
,
,
	
non-existence
of
solution
for,

program
clause,

Pr
olog,

punctuation
sym
b
ol,

quasi-order,

recursiv
e
clause,

renemen
t
op
erator,
,

reexiv
e,

refutation,

refutation-completeness,
,

of
linear
resolution,
	,

of
SL-resolution,

of
SLD-resolution,
,

of
unconstrained
resolution,
,

relation,

relativ
e
implication,
,
,
,
	,

relativ
e
subsumption,
n,

renaming
substitution,

resolution,
,

resolv
en
t,

R
n
,

satisable,
	
satisfy
,

scop
e,

searc
h
bias,

searc
h
space,

selected
atom,

self-saturation,
,

seman
tics,

shifting
the
bias,
	
side
clause,

simple
expression,

single-predicate
learning,

Sk
olem
standard
form,

Sk
olem
substitution,

Sk
olemized
form,

SLD-deduction,

SLD-deriv
ation,

SLD-refutation,

SLD-resolution,
,
,
,

SLD-tree,
0
sp
ecialization,
,
,
,
	
sp
ecialization
problem,
	
Spectre,
n,
n
Spectre
i
i,
n
standard
form,
,

standardized
apart,

substitution,

subsume-equiv
alen
t,

subsumption,
,
,
,
,
,
,
,
n,
,
	,
0
Subsumption
Theorem,
,
,
,

for
linear
resolution,
,
,

for
seman
tic
resolution,

for
SLD-resolution,
,
,
,


SUBJECT
INDEX
0
for
SOL-resolution,
,

for
unconstrained
resolution,
,
,

t
w
o
form
ulations
in
ILP
,

symmetric,

syn
tax,

T-implication,
,
,
,

tautology
,
	
term,

term
assignmen
t,

term
set,

theory
revision,
n
to
o
strong
(w.r.t.
examples),

to
o
w
eak
(w.r.t.
examples),

top
clause,
,

top-do
wn
approac
h
to
ILP
,
,
0
transitiv
e,

truth-table,

truth-v
alue,
,

t
yp
e

program
(unfolding),

preserv
es
M

,

t
yp
e

program
(unfolding),

preserv
es
equiv
alence,

UD

-sp
ecialization,
,
,

UD

-sp
ecialization,
,
,

UDS-sp
ecialization,
,
,

completeness
of,
	
unconstrained
resolution,

uncoun
table
set,

undecidable
Horn
clause
implication,

unfolding,
,
	,

uniable,

unier,

univ
ersal
quan
tication,

univ
ersal
quan
tier,

unsatisable,
	
v
alid,
	
v
ariable,

v
ariable
assignmen
t,
,

v
arian
t,

w
eak
induction,
	
w
ell-formed
form
ula,


