Using Panda3D to construct a simulator for testing a shoal of
Robotic Fish
TECHNICAL REPORT: CES-517
ISSN 1744-8050
John Oyekan, Bowen Lu, Huosheng Hu
School of Computer Science and Electronic Engineering
University of Essex, Wivenhoe Park
Colchester CO4 3SQ, United Kingdom
Email: jooyek@essex.ac.uk, blu@essex.ac.uk, hhu@essex.ac.uk
23 December 2011

Contents
1
Introduction
2
2
Project Requirements and Design Thinking
5
2.1
Functional Requirements: Shall Statements
. . . . . . . . . . . . . . . . . . . . . . . .
5
2.2
Software Architecture
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
2.3
Software Design and build phases
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
2.3.1
Real-time 3D animation showing a simulated port . . . . . . . . . . . . . . . . .
7
2.3.2
Interfaces for loading various port models and pollution models . . . . . . . . .
8
2.3.3
Potential capability on introducing kinematic model
. . . . . . . . . . . . . . .
8
2.3.4
Design Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.4
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
3
Choice of Tools for Simulator Development
9
3.1
Architecture and Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
3.2
Development of Plumes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
3.3
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
4
Algorithm Development for Simulator
16
4.1
Experiments in 2D Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
4.1.1
Diffusion based Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
4.1.2
A Flow information Controller
. . . . . . . . . . . . . . . . . . . . . . . . . .
17
4.2
Two Dimensional Simulation Results . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
4.3
Experiments in Three Dimensional Environment
. . . . . . . . . . . . . . . . . . . . .
20
4.3.1
Pollution Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
4.3.2
Control law . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
4.4
Three Dimensional Simulation Results . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
4.5
Summary
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
5
Conclusion
25
1

Chapter 1
Introduction
The EU Shoal project was launched to investigate how robotic agents could be used to monitor the water
quality of sea ports around the world. The project would involve the use of bio-inspired robotic ﬁsh
equipped with advanced swarm intelligence algorithms to enable a shoal of them perform co-operative
surveillance of the sea port. The use of a shoal of robotic ﬁsh follows from nature in that a group’s
performance at ﬁnding food is increased drastically compared to when a single individual looks for
food. This biological strategy has been studied and is planned to be used on a shoal of robotic ﬁsh
in order to increase their chances of ﬁnding a pollution source either in the form of a leaking pipe or
a rouge ship releasing hazardous substances into the water body. A robotic ﬁsh platform as shown in
Figure 1.1 was chosen because of increase in swimming efﬁciency and power usage as compared with
other Autonomous Underwater Vehicles platforms. Additionally, the shape also enables it to blend with
wild life and so reduces stress on them.
However, in order to be able to develop algorithms, a simulator is needed so that the algorithms can
be tested before deployment on physical platforms. This is partly due to the impractically of tweaking
software parameter values continuously and releasing the robots into the marine environment to test the
effect of the parameter values. In the worst case scenario, a wrong parameter value could result in the
loss of the robotic ﬁsh platform costing a lot of money.
The approach of testing algorithms in simulators before deployment into the physical environment
as been carried out in various research projects over the years. Some have developed custom based
simulators while others have used commercially available simulators. For example Tu et al developed a
custom simulator in order to investigate ﬁsh behaviours in [1] while in [2], generation of ﬁsh motions for
use on a physical platform was investigated. In [3], Nawaz et al developed a simulator to test a sensor
monitoring system that was to be deployed to monitor underwater nuclear storage pools. However, these
scenarios assumed an environment with little or no disturbance or turbulence affecting the plume or
pollutant concentration generated by a pollutant source.
In order to introduce disturbance into the environment, one might consider using a laminar ﬂow
ﬁeld and a random number generator to introduce disturbance into the ﬁeld. However, this does not take
into consideration the structure of the environment. In order to take the structure of the environment
into consideration, computational ﬂuid dynamics simulation of the environment needs to be performed.
However, computational ﬂuid dynamics simulations take up a lot of computational resources and it is
not possible to perform them in real time especially if the environment to be simulated is very large and
the grid resolution is very small. Farrell et al [4] were able to solve this problem partially by using a set
of computational ﬂuid dynamics equations with a colored noise process but without taking the structure
of the environment into consideration. This led to a plume that meandered in the ﬂow ﬁeld but did not
interact with the physical environment. However in [5], Zarzhitsky et al used Farrell et al’s code in an
environment with obstacles and this resulted in plume interaction and meandering.
In addition to studying the effect of the developed swarm algorithms, the simulator would also enable
2

Figure 1.1: The Robotic Fish Platform [6].
the study of the effect of the hydrodynamics of the platform on the plume structure, effect of acoustic
communication issues on the algorithm among other factors. Results from these studies could then be
used to improve the robotic ﬁsh platform as well as the swarm algorithm. As the robotic ﬁsh would be
operating in a 3D environment, we developed a 3D simulator that provides a mechanism to carry out the
above mentioned studies.
In order to develop the simulator, simulator platforms that could be used were investigated. For
example, the webot simulator was considered. The webot simulator is a 3 Dimensional commercial
simulator that has been around for over 15 years [7]. It includes robot models for the pioneer robot [8],
sony aibo [9], kephera robots [10] and so on. However, this was not used because of its proprietary
nature. Furthermore, access to the underlying code for modiﬁcation purposes to suit the Robotic Shoal
project is restricted and hence another discouragement from using webots. Another simulation environ-
ment that was considered was MobileSim by ARIA. This simulation environment did not have models
for the robotic ﬁsh and modifying the underlying development code was considered to be a lot of work
especially in the time scale of the project. Simbad 3D simulator developed in Java was also considered
[11]. In all the simulators mentioned so far and considered, it was not clear how to the pollutant particles
that make up the plume structure of pollution could be developed readily. Hence it was considered to
build a custom simulator. By building a custom simulator for the Robotic Shoal project, it was possible
to have full control over the development process in various ways including the introduction of various
computational ﬂuid dynamics ﬂow ﬁelds, sensor models, custom built robots and so on.
As a result of the limitations of the investigated simulators, Panda3D [12] was investigated has a
suitable platform upon which to develop a simulator. The platform has the following features:
• It is an open source game engine developed in Python scripting language. This language has a lot
of support in the research community making it possible to use readily available codes to aid the
simulator development and reduce development time.
• Python could also be written in an object oriented way which makes it suitable to use when
multiple objects need to be developed.
• Panda3D also has a C++ extension that can be used to develop programs.
• It has a physics engine that enables collision between objects to be detected and addressed accord-
ingly.
3

• Recently, an artiﬁcial intelligence module that comprises of behaviours such as ﬂocking, obstacle
avoidance, pursue etc as been added. These behaviours could be used on simulated robots when
building a simulator.
• The use of textures on objects in Panda3D is very easy and so is camera control. It also offers
integration with model development software such as Blender, 3dMax and so. In other words, the
use of Panda3D encouraged ﬂexibility that was needed in this project to achieve different things.
The rest of this report is organized as follows. In the next chapter, the project requirements and
speciﬁcations are discussed. Chapter 3 discusses how various tools were used with Panda3D to construct
the simulator while chapter 4 discusses testing the approach used and examples of using various control
algorithm in the simulator. Finally, a brief conclusion and future work are discussed in Chapter 5.
4

Chapter 2
Project Requirements and Design
Thinking
This chapter aims to present the requirements that the simulator to be constructed should meet. In order
to do this, the functional requirement in the form of a set of shall statements in section 2.1 were ﬁrst
constructed. Following this, the functional parts of the simulator are discussed with how they would link
together in a software architectural diagram as presented in section 2.2. The software design and design
phases are discussed in section 2.3.
2.1
Functional Requirements: Shall Statements
In this section, the proposed ﬁnal status for the simulator is presented. The simulator:
• Shall be able to simulate a representation of the robotic ﬁsh in a marine environment.
• Shall provide an interface so that various developers can add and develop their control codes.
• Shall simulate the ﬂuid dynamics of an underwater environment.
• Shall be capable of switching between different ﬂow regimes representing different peclet num-
bers.
• Shall simulate the pollution conditions at various peclet numbers.
• Shall simulate pollution leaking from an underwater pipe and ships.
• Shall simulate different pollutants released into the water.
• Shall simulate pollution dispersion as a result of waves, currents, and passing ships.
• Shall be capable of changing the ﬂow parameter values of the simulated river.
• Shall take interaction between different objects into consideration.
• Shall take the physical properties (e.g viscosity, density e.t.c) of the pollution transportation
medium into consideration.
• Shall ensure that computation time is efﬁcient enough to enable real time interaction with objects
in the simulator.
• Shall make sure that there is an interface to which a user can comfortably interact with.
5

2.2
Software Architecture
The software architecture that was designed during the writing of the requirements speciﬁcation for the
simulator is presented in Figure 2.1. This architecture shows the components needed to achieve the task
and also shows the communication and relationship between each component.
Figure 2.1: Showing the proposed Software Architecture.
• Force ﬁeld database manager: is designed as a bunch of CFD simulated results from Open-
FOAM, which gives the ﬂowing information of the water body in the port, and its content is a grid
6

map of force vectors.
• A physics engine: is computer software that provides an approximate simulation of certain simple
physical systems, such as rigid body dynamics (including collision detection), soft body dynamics,
and ﬂuid dynamics, of use in the domains of computer graphics, video games and ﬁlm. (From
Wikipedia). The physics engine module processes interactions of forces on each of the objects. It
reads the force ﬁeld information from the force ﬁeld database, applies constant forces (including
force of gravity and buoyancy, etc.), and eventually outputs position change information for all
objects. The physics engine is connected to the pollution module and the moveable objects module
(robotic ﬁsh and ships).
• Pollution model module: is a library of pollution models, which has different diffusion be-
haviours, depending on the properties of leaking materials. These models read force ﬁeld in-
formation through the physics engine interface and update the pollutant distribution.
• Ship dynamics algorithm module: simply moves ship objects (potential leaking source) around
the port according to a preﬁxed or random path.
• Robotic ﬁsh control algorithm module: is a set of pollution monitoring algorithms for mobile
sensor networks, which is the kernel of detecting pollution distribution. Currently, BCT-FLK and
DSVR-CVT would be investigated as potential algorithms to be used and tested on the robotic
ﬁsh platform [13][14]. This module reads the position of robotic ﬁsh and pollutant concentration
of current position as input to optimise the distribution of robotic ﬁsh.
Most of the computations are contained in the Physics Engine and Pollution Models. Depending
on the computational demands, these two parts should be developed in C++. They could also be
compiled into a dynamic link library (DLL ﬁles) with standard interface so that they can be used
in different simulator environments. This would also enable the maintenance work required for
them to be simpliﬁed and suitable for team development.
2.3
Software Design and build phases
2.3.1
Real-time 3D animation showing a simulated port
Although the computation capability of Graphic Process Units (GPU) has improved a lot recently, it
is still not fast enough for a synchronous real-time simulation with large scale complex 3 Dimensional
environment. Hence a front-back asynchronous design should be introduced to this simulator, where
a 3 Dimensional environment animation would be running in the front end while the computational
ﬂuid dynamics (CFD) ﬁeld and pollution monitoring algorithms would be running in the back end. The
back end is the kernel of simulator, which can actually run individually (without front end). In this
design structure, the 3 Dimensional animation is isolated from the pollution monitoring algorithms’
feedback loop resulting in a clariﬁcation of each function into modules. Without the interference from
the 3 Dimensional animation, collision detection in the physics engine can be replaced with user deﬁned
collision avoidance algorithm. This is because the physics engine collision detection could result in
heavy computational burden as a result of keeping track of various objects in the simulator.
Key notes:
• Front-back design.
• Front and back ends are running in different frequency rate (asynchronous design).
• Collision detection disabled, using our own collision avoidance algorithm.
7

2.3.2
Interfaces for loading various port models and pollution models
In order to make sure that this simulator is extendable, and also for further redevelopment, the Python
language was chosen as the choice of design language. Python has a fast development speed building on
an object-oriented programming (OOP) framework, and supports various other main trend languages.
One port model, one pollution model, and two pollution monitoring algorithms would be tested and used
ﬁrst. They could also be extended to all Python supported languages. Currently a BCT-FLK algorithm
coded in Python and DSVR-CVT coded in C is used to test integration with other languages. On the
other hand, a 3 Dimensional physics engine and animation package, Panda3D, is supported by Python.
Key notes:
• Python is chosen as the framework development language.
• Fast development speed.
• Hybrid programming with multiple languages.
• Module libraries. Extendable with multiple languages.
• Port (CFD) models
• Pollution models
• Monitoring algorithms
• Panda3D physics engine is employed.
2.3.3
Potential capability on introducing kinematic model
Blender was chosen for building all 3D models and animations for port and robotic ﬁsh. Since the
main purpose of current development is testing and demonstrating the efﬁciency of high level control
algorithms, a point model is employed. In order to have a lower level kinematic model implemented,
the shape and joint information is needed, and then, Blender can be used to build the shape and joint
parameters precisely. Key notes:
• Blender is capable for building joint models.
2.3.4
Design Phase
Following from the above, the working plan that would be used in sequence is as follows:
• 3D animation model for ﬁsh and water environment. Later we will consider additional models for
port, ship, and etc. (Blender)
• Physics engine DLL, develop in C++. (Visual C++)
• Build 3D simulator module in Python. (with Blender or Panda3D)
2.4
Summary
In this chapter, the software requirements for the simulator has been brieﬂy presented together with the
software architecture that would be followed to build the simulator. In addition, the issues that could
arise during the development and testing of the simulator have been presented with possible solutions to
these issues. In the next chapter, the process of building the simulator would be presented.
8

Chapter 3
Choice of Tools for Simulator
Development
After describing the requirements needed by the simulator in Chapter 2, an investigation into the tools
needed to develop the simulator was carried out. However, before starting the development of the sim-
ulator, a location to use as a test case to compare obtained results was chosen. The location chosen was
beside the University of Essex, University Quays Accommodation where the River colne ﬂows past as
shown in Figure 3.1.
This location was chosen because of its accessibility thereby making it possible to compare the
natural ﬂow ﬁeld with a simulated ﬂow ﬁeld. Also, this location is affected by the tidal effect from the
Black sea making it possible to view its bed when the tide is low. This made it possible to develop a
representation of the 3 dimensional map of the river bed in addition to its boundaries.
Furthermore, the area chosen is affected by various ﬂow regimes including turbulent ﬂow regimes.
As a result, different sections of the area would have different ﬂow regimes making it possible to test the
behaviour and performance of developed algorithms in various scenarios.
3.1
Architecture and Framework
As mentioned in Chapter 1, Panda 3D was considered as a suitable platform upon which to develop the
robotic ﬁsh simulator. However in addition to Panda 3D, a series of other tools were also considered
and used. The framework as shown in Figure 3.2 was used to combine the tools. An explanation of the
various tools and how they were used will now follow.
• In order to develop the simulator, a picture of the environment as shown in Figure 3.1 was ﬁrst
taken. This picture was then used in Blender and OpenFoam computational ﬂuid dynamics pack-
age.
• Blender is an open source development package that can be used to develop 3 Dimensional worlds
and introduce various effects [15]. Blender also incorporates a physics game engine and particle
system which makes it possible to introduce interactions between various objects in the simulated
environment and also create smoke, moving water and other similar effects. However, it was
discovered that there was no control over each individual particle in a user developed particle
system. As a result, it was impossible to control the shape of a simulated pollutant plume. Blender
was used in this project to develop the environment of interest by using the picture taken as shown
in Figure 3.3 and to develop the robotic ﬁsh. The environment developed was setup in Blender so
that when imported into Panda3D, the boundaries of the environment could act as actual physical
boundaries to prevent objects from going through them. This was achieved by using the chicken
9

Figure 3.1: Showing the river colne at the University Quays in Colchester
tool in Blender. In developing the robotic ﬁsh, a bone frame based on a 3 Dimensional ﬁsh model
was used as shown in Figure 3.4. In this design, each of the joint is customisable, including the
quantity and organisation of the bones. Although we are using point model for ﬁsh movement at
current stage, this bone frame can potentially support kinematic methods in future work.
Figure 3.5 shows textured ﬁsh model. As mentioned above, we created a series of animation of
swimming ﬁsh in different ﬂipping frequency for different moving speed.
• OpenFoam [16] is an open source computational ﬂuid dynamics program that incorporates its
own mesh generators e.g snappyHex and blockMesh. The process of meshing simply converts an
environment into grids or cells that enable the computer to perform ﬁnite element computations
across the environment of interest. The environment shown in Figure 3.1 was simpliﬁed and con-
verted into a mesh as shown in Figure 3.6(a). In order to perform Computational Fluid dynamics,
equations that govern the ﬂow of ﬂuid in the environment have to be derived. The choice of these
equations would depend on whether the ﬂuid is to be turbulent, laminar, viscous, incompressible
and so on. After the equation to describe the ﬂuid as been chosen, the environment is divided up
discretely using a mesh generator so that the ﬂuid equation could be solved discretely for the vari-
ous areas in the environment [16]. Depending on the size of the environment and the resolution of
the meshes, the results from the computational ﬂuid simulation could take up to days. As a result,
it is very challenging to perform real time computational ﬂuid dynamics of an environment with-
out incurring computational overheads. In order to obtain computational ﬂuid dynamics results
quicker, the environment to be simulated was reduced by a factor of 10 before expanding back
into normal real life dimensions.The results of doing a computational ﬂuid dynamics computation
on the Figure 3.6(a) is shown in Figure 3.6(b).
The structure of OpenFoam enables users to easily establish different ﬂow regimes ranging from
10

(a)
(b)
Figure 3.2: Developing the Robotic ﬁsh simulator. Fig. (a) shows the framework used; Fig. (b) shows
the steps followed towards construction.
Figure 3.3: Showing the simulated river colne at the University Quays in Colchester.
11

Figure 3.4: Bone frame of ﬁsh model
Figure 3.5: Textured ﬁsh model
laminar to turbulent by setting ﬂow parameters in equations. For more information, the reader is
referred to the OpenFoam manual at [16]. OpenFoam was used to generate ﬂow ﬁeld data which
was then used in Panda3D to advect pollution particles and affect the dynamics of the Robots in
the simulator.
• With the framework shown in Figure 3.2, it was possible to make a module that could incorporate
various controllers for testing on physical robots in Panda3D.
3.2
Development of Plumes
In a ﬂowing river, a pipe leaking a pollutant would result in the formation of a plume. In order to develop
a plume in these studies, an environment was constructed as shown in Figure 3.7. The environment had
dimensions of 400 by 1000 with obstacles placed in it to generate its boundaries. Computational ﬂuid
dynamics simulation was then performed on this environment using OpenFoam computational ﬂuid
dynamics package. Flow vectors were obtained from the simulation carried out. The use of particles
for simulating smoke has been used in many simulations and animations. Many theories exist that use
particles such as SPH. However, the downside of using particles to simulate smoke is that to simulate
realistic smoke, many particles are required and this results in a heavy computational burden.
Another way of simulating pollution is through the use of various models such as puff models or
gaussian models. The disadvantage of using the gaussian model is that it is difﬁcult to control the reso-
lution of the movement of a section of the plume. However, by combining these two theories together,
it is possible to achieve a system in which, the particles can still be controlled as in a normal smoke
simulation and still achieve a plume like effect by using it with Gaussian based model.
As result, the plume puffs in this work were constructed from a Gaussian distribution of particles
around a mean point µ that was advected from the plume source according to the ﬂow ﬁeld. The spread
or standard deviation ω of the distribution of particles was increased according to the equation 3.1 where
12

(a)
0
5
10
15
20
25
30
35
40
45
0
20
40
60
80
100
120
X
Y
(b)
Figure 3.6: Showing the meshed simulated environment- Fig. (a) and showing the velocity vectors
obtained from openFoam advecting a particle in the simulated marine environment- Fig. (b)
13

Figure 3.7: Test Environment
Figure 3.8: Simulated robotic ﬁsh deployed in the 3D simulator
k is a constant that can be tuned to the user’s preference.
ωt+1 = ωt + kt
(3.1)
In this way, the plume shown in Figure 3.7 was obtained. By multiplying the ﬂow vectors with either
a constant or random value, it is possible to control the x and y speeds of the plume resulting in either a
deﬁned plume with a predictable path or a meandering plume. In this case, the x and y speeds xv and yv
were set to 14 times their scalar values. In Figure 3.7, it can be observed that the plume was more patchy
towards the source. This is because the ﬂow ﬁeld energy was strong in the narrow space. However this
energy dissipated after the area enlarged resulting in a less patchy section of the plume. This energy was
slightly regained in the lower section of the simulated environment resulting in a patchy plume again.
The plume development approach was then tested in a 3D environment with the robotic ﬁsh deployed in
it as shown in Figure 3.8.
3.3
Summary
This chapter has brieﬂy discussed the processes involved in the development of the simulator for the
Robotic ﬁsh. It discusses how various tools were combined and the results obtained. The results show
14

that it has potential for use in the EU Shoal project.
15

Chapter 4
Algorithm Development for Simulator
In this chapter, two different bio inspired controllers were compared to test the approach discussed in
chapter 3 to the development of a Robotic ﬁsh simulator. They were a diffusion based controller based
upon the bacteria behaviour and a ﬂow based controller based upon a male moth behaviour. First, exper-
iments were conducted in a 2 Dimensional environment before testing in a 3 Dimensional environment.
4.1
Experiments in 2D Environment
4.1.1
Diffusion based Controller
There has been various investigations into the development of controllers that can operate in diffusion
like environments. For example, Mayhew et al used inspiration from a line minimization-based algo-
rithm in [17] to develop a robust source-seeking hybrid controller. In their work, gradient information
and exact coordinates of the vehicles (For vehicles in GPS denied environments) were not needed. In
[18], Baronov et al developed a hybrid reactive control law that enables an agent to ascend or descend
along a potential ﬁeld. However, some researchers have looked towards nature and taken inspiration
from the bacteria as in [19] and [20]. In [19], Marques et al compared a rule based bacteria controller
with the silkworm algorithm amongst other algorithms while in [20], Dhariwal et al used a keller segel
model of bacteria population as an inspiration to develop a source seeking controller.
In this chapter, the Berg and Brown model [21] is used because of its ease of analysis and ability to
compare the behaviour of the bacteria algorithm driven robots with biological results. In addition, this
model was chosen above models such as the one in [22] because it was deemed sufﬁcient to implement
a biased random walk. Furthermore, it gives the user the ability to control both the exploratory and
exploitation behaviour of robotic agents through the tuning of its parameters.
The bacterium motion is governed by a series of tumbles and run phases. A run phase can be viewed
as a straight line for simplicity purposes while the tumble phase can be viewed as reorienting itself to a
randomly chosen direction. When the bacteria is moving towards a favorable food source, the run phase
is increased in duration whilst if moving in an unfavourable direction, the tumble phase is increased.
This was discovered and modelled by Berg and Brown according to the equations 4.1 to 4.3.
τ = τoexp(αdPb
dt )
(4.1)
dPb
dt = τ −1
m
∫t
−∞
dPb
dt
′ exp((t′ −t)
τm
)dt′,
(4.2)
dPb
dt =
kd
(kd + C)2
dC
dt
(4.3)
16

τ is the mean run time and τo is the mean run time in the absence of concentration gradients, α is a
constant of the system based on the chemotaxis sensitivity factor of the bacteria, Pb is the fraction of the
receptor bound at concentration C. In this work, C was the present reading taken by the Robotic agent.
kd is the dissociation constant of the the bacterial chemoreceptor. dPb
dt is the rate of change of Pb. dPb
dt
is the weighted rate of change of Pb, while τm is the time constant of the bacterial system. The above
equations determine the time between tumbles and hence the length of the run phase between tumbles.
During the tumble phase, the agent can randomly choose a range of angles in the uniform distribution
σε{0..., 360}.
In addition to the above equations, we also use a “foraging equation” that controls the velocity of
the agents. This equation enables agents to dwell longer in areas of high pollution concentration and
lesser in areas of low pollution concentration. This equation is presented in equation 4.4 where β is
the dynamic velocity that depends on the present reading of the pollution C, βo is the standard velocity
without any reading and vk is a constant for tuning the dynamic velocity β.
β = βo ∗vk
C
(4.4)
The bacteria controller does not rely on ﬂow information and needs only a pollution measuring
sensor.
4.1.2
A Flow information Controller
Most controllers that use ﬂow information in navigating towards the source of a pollution are inspired by
the moth behaviour. Examples include the spiral surge algorithm developed by Hayes et al in [23] and
casting algorithms developed by Li et al in [24]. The spiral surge algorithm is suitable for high turbulent
conditions in which there are patchy distributions of pollution. Nevertheless, the ﬂow information con-
troller that was chosen in this investigation was the one developed in [24] because of its performance in
ﬁeld trial tests. The passive strategy for maintaining contact with plume was chosen. The strategy relies
on having a sensor that reads both the medium’s ﬂow information and a sensor for detecting pollution
levels C. Whenever the pollution sensor detects a value above threshold υ , the agent gets the ﬂow
information in its immediate vicinity and moves upstream.
As mentioned previously, chemicals in a turbulent environment often undergo “tearing” leading
to a patchy distribution in addition to meandering in a non-uniform environment. As a result, of the
patchiness of the plume, it is possible that the agent might not have any reading during its upstream
travel for sometime even though it is on course towards the source of the plume.
In order to solve this, a constant κ is used. If the pollution sensor reading C at time t has been above
the threshold υ for the last κ seconds tϵ[t −κ, t], then it is assumed that the agent is still in contact
with the plume and upstream motion is continued. Every time an above threshold reading is obtained,
a variable TLAST is set to the current time t. Another variable called TLOST is used to determine when
the plume is lost and is calculated by using TLOST = TLAST + κ. When TLOST is equal to TLAST + κ,
the agent tries to reacquire the plume by going at 90◦to the present direction of the agent. This is carried
out by using equations 4.5 and 4.6 where ζv is the commanded heading of the vehicle, ζu is given by
equation 4.7 and ψ can be either −90 or +90 depending on equation 4.6. The agents uses equation 4.7
to go upstream and this is obtained by adding 180◦to the instantaneous wind direction ζw.
ζv(t) = ζu(t) + sign(ψ)
(4.5)
ψ =
{
+90
if
ζv(Tlost) −ζw(Tlost) > −180◦
−90
if
ζv(Tlost) −ζw(Tlost) < −180◦
(4.6)
17

(a)
(b)
(c)
(d)
(e)
(f)
Figure 4.1: Showing stages of the agents ﬁnding the source of the plume using the ﬂow controller
method.
ζu(t) = ζw(t) + 180
(4.7)
In this investigation, κ was set to 1000 ms and υ set to 1. For more information on the ﬂow controller
and its pseudo code implementation, the reader is referred to [24].
4.2
Two Dimensional Simulation Results
The oval agents representing those using the ﬂow controller method were placed in a well established
plume as shown in Figure 4.1(a) with the blue square indicating the source. It was discovered that all
the agents were able to ﬁnd the plume source for this method with an average iteration of 230.
However, for the bacteria controller, the technique failed to follow the plume as is shown in Figure
4.2(a). The boundaries of the environment were deliberately not considered in this experiment for com-
parison purposes. Reliance on the gradient information makes the bacteria controller fail because it is
not possible to get that information in such a turbulent environment. Nevertheless, it was discovered that
18

(a)
(b)
(c)
(d)
(e)
(f)
Figure 4.2: Agent distributions for ordinary bacteria behaviour - Fig 4.2(a); modiﬁed bacteria behaviour
- Fig 4.2(b) to 4.2(d); and for modiﬁed bacteria behaviour with negative gradient - Fig 4.2(e) to 4.2(f).
Red was used for the square shaped agents so that it could stand out of the black boundary. Their size
was also made smaller so that the forming of the shpae of the plume could be seen more clearly.
19

if the straight runs were modiﬁed into circular casting motions by using a biological inspired step angle
of σ ϵ 59 degrees ± rand() based on the S.putrefaciens tracking a falling algae, it is possible to obtain an
emergent characteristic as shown in Figure 4.2(b) to 4.2(d).
This characteristic enabled some of the agents to ﬁnd the source even though it took a larger number
of iterations (over 5000) compared to the ﬂow controller method whilst still forming the shape of the
plume as shown in Figure 4.2(d). The plume in Figure 4.2(d) was deliberately left out to show that
the agents followed the structure of the plume. This behaviour was obtained by using the bacteria
parameters kd = 1000, α = 500, τo = 2, βo = 6 in order to achieve more exploitation when in the
plume than exploration of the environment. Another emergent property that was discovered was that
when an agent got to the source, the agent stopped moving. Stopping at the source was something not
programmed into the agent’s behaviour. This property could be as a result of the kd parameter being
saturated and could be used as a way of declaring the source of the plume.
By changing the sign in equation 4.3 to negative as in −dC
dt , it was possible to make the bacteria
dwell on the outskirts of the plume as shown in Figure 4.2(e) and Figure 4.2(f). In this case, the agents
were always pushed to the boundary of the plume whenever they come into contact with the plume.
This behaviour could be used to contain the pollution plume whilst tracing its shape and moving to the
source.
4.3
Experiments in Three Dimensional Environment
In this section, the possibility of deploying the coverage controller developed in this report to a 3 di-
mensional environment similarly to what a robotic ﬁsh in a marine environment would encounter is
investigated. A scenario in which robotic ﬁsh agents are deployed into a marine environment in order
to track a pollutant to its source whilst providing data to the base to construct a map of the pollutant is
investigated. It is assumed here that the agents have a low level control law such as a PID controller that
would enable them to maintain a particular position precisely.
4.3.1
Pollution Simulation
In this investigation, an underwater scenario was simulated as closely as possible. Turbulence was not
taken into consideration as this is left for future experiments. In this scenario, the ﬂow ﬁeld used in
section 4.1 was used but was also extended to 3 dimensions. The ﬂow ﬁeld enable the advection of puffs
resulting in plumes. In this investigation, each puff was simulated using equation 4.8 with Q = 3000. In
addition, the plume was meandered by using a random number generator to disrupt the y velocity of the
plume resulting in Figure 3.8.
PollutionReading =
m
∑
i=0
Qi
R2
i
(4.8)
4.3.2
Control law
The controller presented in section 4.1 was used except that an extra dimension was added. In order
to extend the algorithm for operation in a 3 dimensional environment, another random variable θ for
the bacteria chemotaxis behaviour had to be created. This variable could randomly choose a range
of angles in the set θε{0..., 360} similar to σ. Together, these two variables controlled the randomly
chosen direction of the bacteria chemotaxis behaviour. The dynamic velocity β was then used to obtain
the velocity of the agent and hence its position as shown below.
Ψ = β ×


sin(θ) cos(σ)
sin(θ) sin(σ)
cos(θ)


(4.9)
20

where Ψ is the global coordinates of (x, y, z). Deploying a coverage controller such as the Voronoi
partition method in this environment would be very costly computationally due to the need to compute
the estimated sensory information in the extra dimension. However, the use of our technique does not
require this. Instead, point measurements are used. In addition to the bacteria algorithm, a ﬂocking
behaviour given by equation 4.10 was used as well during three dimensional experiments.
The behaviour enables collective foraging to aid the group’s success in exploring the environment
and ﬁnding a pollution source. Craig Reynolds was the ﬁrst to model this behaviour in his work on boids
in 1986 [25]. His model has gone on to be used by various researchers using various models [26]. In this
work however, the morse potential as shown in equation 4.10 is used instead. where r is the Euclidean
distance between two closest neighbors. Gains of 1 for the repulsion term GR and 0.99 for the attractant
term GA were used. It was discovered that it is possible to control how closely the agents get to each
other whilst not colliding by adjusting the GG gain.
Foutput = GG ∗[GR ∗exp(−r/20) −GA ∗exp(−r/20)]
(4.10)
The environment discussed in section 4.3.1 above is made up of diffusion of the puffs and their
advection in the environment. As result, a scheme that has the capability to ﬁnd pollution in a diffusion
based environment and a medium Peclet environment is needed. Such multipurpose controller does not
exist to date as most schemes have concentrated efforts to one particular kind of ﬂow environment. From
section 4.1, it was discovered that the bacteria controller has the following features:
• Is effective in a diffusion based environments where ﬂow information is not present
• Has a good exploration behaviour due to it diffusive behaviour
• And can form the visual distribution of a plume but is not effective in ﬁnding its source.
It was also gleaned that the ﬂow based controller has the following features:
• Is good at ﬁnding the source of pollutant in a medium Peclet environment.
• Requires a threshold value for detecting pollutant in the environment above which it follows the
ﬂow information obtained from the environment to the source.
• Is not good in a diffusion based environment due to lack of ﬂow information.
• Does not have an embedded exploratory behaviour.
• Cannot be used to form a visual distribution of the pollutant in the environment and is not good
for collecting data for building a map as the agents utilizing the scheme are programmed to go
directly to the source of the plume.
From the above, the weaknesses of one scheme can be strengthen by the strengths of the second
scheme. As a result, the following control law is proposed: If a port, for example, is to be monitored
and source of pollutants found, then we propose using the BactFlock method to distribute the agents
in the environment and for exploration in order to ﬁnd the pollutant particles. Due to dependence on
gradient information, the BactFlock method would navigate the agents towards higher concentrations
of pollutants in the environment. This might bring the agent into the mean ﬂow of the river or it might
result in navigation towards a local maximum. Once the pollutant reading is above a certain threshold
value ϖ however, the agent can start using the ﬂow based controller to navigate up stream. This control
law can be described as in equation 4.11.
motion =
{
BactFlock
if
pollution value < ϖ
flowcontroller
if
pollution value > ϖ
(4.11)
21

However, not all pollutant sources are in the mean ﬂow of a river. For example, sometimes, the
source of pollution could be a ship that is moored in the part of the port with very low velocity ﬂow
ﬁeld resulting in a diffusion based environment. In addition to this, in a sea port, the areas with the
largest amount of pollution are those areas with lower ﬂow ﬁelds. This is because the pollutant particles
are bound to experience less disturbance here resulting in higher concentration levels. Whereas the
areas with the least amount of pollution are those areas that have high ﬂow rates due to the continuous
emptying of the area. As a result, if the source of a pollutant is to be found in this scenario, a control law
that switches between the BactFlock controller and the ﬂow based controller as shown in equation 4.12
could be more appropriate. This would enable the source of a pollutant in a low velocity ﬂow region
to be found using the BactFlock method and to be found in a high velocity ﬂow region using the ﬂow
based controller.
motion =
{
BactFlock
if
flow value < ϖ
flowcontroller
if
flow value > ϖ
(4.12)
where ϖ is the value of the ﬂow in the environment.
4.4
Three Dimensional Simulation Results
Experiments were carried out using the control law 4.11. A map of the pollutant being detected was
also generated using a support vector regression algorithm package. Each agent contributed to the map
regardless its position in the simulated environment. As can be seen in the screen shot in Figure 4.3,
the agents started out close to the surface of the river port. This is to simulate deployment of robotic
ﬁsh from a ship on the surface. However as time progressed, they moved according to the gradient
information towards the plume and followed it to the source. In Figure 4.4, it can be seen that they were
still able to form the distribution of the plume as a result of the BactFlock method and still move towards
the source of the pollutant as a result of the ﬂow controller.
4.5
Summary
In summary, the deployment of various algorithms in the developed simulator has been investigated in
this chapter. The results show the feasibility of using the algorithms in the developed simulator serving
as a test bench for future algorithm developments and expansion of the simulator.
22

(a)
(b)
(c)
Figure 4.3: Showing deployment of Robots in a simulated marine environment at initial stages of plume
exploration. The middle ﬁgure shows the position of the agents while the ﬁgure on the right shows the
spatiotemporal map generated by the SVR at the base.
23

(d)
(e)
(f)
Figure 4.4: Robots forming a distribution of a plume whilst ﬁnding its source in a medium Peclet
environment. The middle ﬁgure shows the position of the agents while the ﬁgure on the right show the
spatiotemporal map generated by the SVR at the base.
24

Chapter 5
Conclusion
This report has discussed the development of a simulator that could be used to test algorithms that are
aimed to be deployed on a shoal of Robotic ﬁsh. Experiments conducted and results show that the
approach presented in this report is feasible and has potential to be developed for use on a wider scale.
The approach takes into consideration the computational ﬂuid dynamics of an environment into
consideration which is unlike most robotic simulators. In fact, the developed simulator in this report
according to our present knowledge is probably the ﬁrst 3Dimensional simulator that takes the ﬂuid
dynamics of an environment into consideration whilst the user is developing control algorithms for
robots.
Furthermore, as it is difﬁcult to carry out computational ﬂuid simulation of an environment in real
time, the approach used to achieve this in this report safes computational time and makes it possible to
perform real time simulations.
Future work would investigate the possibility of using fuzzy logic for example to dynamically adjust
the ﬂow ﬁeld created by the motion of water through an environment when a dynamic object moves
through the ﬂow ﬁeld. At present, for simplicity, this is not considered. But in future work, the effect of
the robotic ﬁsh on the plume generated and how it affects the control algorithm as a whole would be an
interesting topic to investigate. In addition, the plan is to incorporate the Gijon port in Spain as shown
in the google map in Figure 5.1(a) into the simulator so that this can be used to further test developed
algorithms in an environment similar to the one that the robotic ﬁsh would be deployed in in the near
future. The boundaries of the Gijon port have been constructed as in Figures 5.1(b) and 5.1(c) with the
next aim of performing computational ﬂuid dynamics on the structures.
Acknowledgements:This research has been ﬁnancially supported by European Union FP7 pro-
gram, ICT-231646, SHOAL and the UK Engineering and Physical Sciences Research Council (EP-
SRC). We would also like to thank Robin Dowling for his technical support.
25

(a)
(b)
(c)
Figure 5.1: Developing the Gijon Port for use in the simulator. Fig. (a) shows Gijon Port in Spain from
overhead; Fig. (b) shows the area covered by land around the Port while Fig. (c) shows the area covered
by the sea.
26

Bibliography
[1] X. Tu and D. Terzopoulos, “Arti cial Fishes: Physics, Locomotion, Perception, Behavior.”
[2] J. Liu and H. Hu, “Biological Inspiration: From Carangiform Fish to Multi-Joint Robotic
Fish,” Journal of Bionic Engineering, vol. 7, no. 1, pp. 35–48, Mar. 2010.
[3] S. Nawaz, M. Hussain, S. Watson, and N. Trigoni, “An Underwater Robotic Network for
Monitoring Nuclear Waste Storage Pools,” University Computing, pp. 1–20.
[4] J. A. Farrell, J. Murlis, X. Long, and W. Li, “Filament-Based Atmospheric Dispersion Model
to Achieve Short Time-Scale Structure to Odor plumes.pdf,” 2002.
[5] D. Zarzhitsky, D. F. Spears, and W. M. Spears, “Swarms for chemical plume tracing,” In
Proc. of the IEEE Swarm Intelligence Symp. (SIS05) 1.
[6] H. Hu, J. Liu, I. Dukes, G. Francis, W. Park, and U. Kingdom, “Design of 3D Swim Pat-
terns for Autonomous Robotic Fish,” in Proceedings of IEEE/RSJ International Conference
on Intelligent Robots and Systems, Beijing, China., 2006, pp. 2406 – 2411.
[7] Cyberbotics,
“Webots
robot
simulator
-
Overview.”
[Online].
Available:
http://www.cyberbotics.com/overview
[8] Adept
Mobile
Robots,
“Adept,
Autonomous
Mobile
Robots,
P3-
DX,”
Last
Accessed
31
March
2003.
[Online].
Available:
http://www.mobilerobots.com/researchrobots/researchrobots/pioneerp3dx.aspx
[9] Sony, “About AIBO.” [Online]. Available: http://www.sonyaibo.net/aboutaibo.htm
[10] K-Team, “K-Team Corporation Mobile Robotics.”
[11] Simbad, “Simbad 3d Robot Simulator.” [Online]. Available: http://simbad.sourceforge.net/
[12] C. Mellon, “Panda3D - Free 3D Game Engine.” [Online]. Available: http://www.panda3d.org/
[13] B. Lu, D. Gu, and H. Hu, “Environmental Field Estimation of Mobile Sensor Networks Using
Support Vector Regression,” in International Conference on Intelligent Robots and Systems,
2010, pp. 2926–2931.
[14] J. Oyekan, H. Hu, and D. Gu, “Bio-Inspired Coverage of Invisible Hazardous Substances in
the Environment,” International Journal of Information Acquisition, vol. 7, no. 3, p. 193, 2010.
[15] Blender, “Blender.” [Online]. Available: http://www.blender.org/
[16] H. Jasak, “OpenFOAM : Open source CFD in research and industry,” pp. 89–94, Dec. 2009.
[Online]. Available: http://www.openfoam.com/docs/user/
27

[17] C. G. Mayhew, R. G. Sanfelice, and A. R. Teel, “Robust source-seeking hybrid controllers for
nonholonomic vehicles ,” American Control Conference, pp. 2722–2727, 2008.
[18] D. Baronov and J. Baillieul, “Autonomous vehicle control for ascending/descending along a
potential ﬁeld with two applications,” Proceedings of the American Control Conference, pp.
678–683, 2008.
[19] L. Marques, U. Nunes, and T. D. Almeida, “Olfaction-based mobile robot navigation ,” Thin
Solid Films, vol. 418, no. 1, pp. 51–58, 2002.
[20] A. Dhariwal, G. S. Sukhatme, and A. A. G. Requicha, “Bacterium-inspired robots for envi-
ronmental monitoring,” Proceedings of the IEEE International Conference on Robotics and
Automation, New Orleans, LA, USA,, vol. 2, pp. 1436–1443, 2004.
[21] D. A. Brown and H. C. Berg, “Temporal stimulation of chemotaxis in Escherichia coli,” Pro-
ceedings National Academy of Science of the United States America, vol. 71, pp. 1388–1392,
1974.
[22] T. Yi, Y. Huang, M. Simon, and J. Doyle, “Robust perfect adaptation in bacterial chemotaxis
through integral feedback control,” Proc. Natl. Acad. Sci., vol. 97, no. 9, pp. 4649–4653, 2000.
[23] A. T. Hayes, A. Martinoli, and R. M. Goodman, “Distributed odor source localization,” IEEE
Sensors Journal, vol. 2, no. 3, pp. 260–271, 2002.
[24] W. Li, J. A. Farrell, and R. T. Card, “Strategies for Tracking Fluid-Advected Odor Plumes,”
Adaptive Behavior, vol. 9, no. 3-4, pp. 143 – 170, 2001.
[25] C. W. Reynolds, “Flocks, herds and schools: A distributed behavioral model,” ACM SIG-
GRAPH Computer Graphics, vol. 21, no. 4, pp. 25–34, Aug. 1987.
[26] R. Olfati-saber, “Flocking for multi-agent dynamic systems: algorithms and theory,” IEEE
Trans.
28

