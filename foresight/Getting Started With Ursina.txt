Getting Started
1) Install Python 3.6 or newer. https://www.python.org/downloads/
2) Open cmd/terminal and type:
# code
pip install ursina
# text
If you want to install the newest version from GitHub, you can install like this:
# code
pip install https://github.com/pokepetter/ursina/archive/master.zip
# text
or
# code
pip install git+https://github.com/pokepetter/ursina.git
# text
Keep in mind that things *could* break.
If you want to easily edit the source, it's recommended to clone the git
repo and install as develop like this. Make sure you have git installed. https://git-scm.com/
# code
git clone https://github.com/pokepetter/ursina.git
python setup.py develop
# text
Also install any of the optional dependencies you want from the list below,
or install them all with:
# code
pip install ursina[extras]
# text
On some systems you might have to use pip3 instead of pip in order to use Python 3 and not the old
Python 2.
If the pip command is not found, you can use:
# code
python -m pip install ursina
# text
Building
# title building your app
# center, width 1000, arial
# size 5, bold
Building
# size 1, normal
# left

## Building Your App with ursina.build
Open cmd in the project folder and run
# code
python -m ursina.build
# text
It will then move the necessary files to a 'build' directory which you can then distribute.
## Building Your App with auto-py-to-exe (singlefile)
1. pip install auto-py-to-exe
2. go to cmd and type auto-py-to-exe to open the gui
3. enter script location
4. select onefile
5. select either console based or window based
6. icon (optional)
7. under additional files, click add folder and add
panda3d-1.10.6.dist-info,
panda3d,
panda3d_tools,
ursina-3.1.0.dist-info,
ursina,
and any other files included for your app/game
8. advanced (optional)
9. settings to set an output location (optional)
10. finally select "convert .py to .exe"
Coordinate System
# title
ursina engine
documentation
# center, bold, arial, size 5
<a href="index.html" style="text-decoration: none;
color:inherit">ursina engine
ʕ •ᴥ•ʔゝ□</a>
# normal, size 3, left, width 650
## Entity Coordinate System
# code
y (up)
|
|
(forward) z |
\ |
\|
*---------- x (right)

# text
## UI Coordinate System
# code
_______________________(.5, .5)____(window.top_right)
| ' ' |
| ' ' |
| ' ' |
| ' ' |
| ' (0, 0) ' |(.5*window.aspect_ratio, 0)
| ' ' |
| ' ' |
|
' ' |
|_______'__________________'_______|
(-.5, -.5)
# text
## Rotation
Positive value is clock-wise around axis.
Imagine looking from a positive point on the axis and turing the
entity left.
# code
_______
/
\->
__
/ \ y
| v |
| z | __
\ | / \
\| v |
*---------- x |
|
# text
## Origin

Setting the origin will move the origin point of the model.
This can be especially useful when working with ui.
# code
(-.5,.5)
+--------+ *--------+
| | | |
| (0,0) | | |
| | | |
+--------+ +--------+
(0,.5)
+----*---+ +--------+
| | | |
| | | * (.5,0)
| | | |
+--------+ +--------+
# text

© 2021 GitHub, Inc.
# title ursina engine documentation
# center, bold, arial, size 5
<a href="index.html" style="text-decoration: none; color:inherit">ursina engine
ʕ •ᴥ•ʔゝ□</a>
# normal, size 3, left, width 650
## Entity Coordinate System
# code
y (up)
|
|
(forward) z |
\ |
\|
*---------- x (right)
# text

## UI Coordinate System
# code
_______________________(.5, .5)____(window.top_right)
|
'
'
|
|
'
'
|
|
'
'
|
|
'
'
|
|
'
(0, 0)
'
|(.5*window.aspect_ratio, 0)
|
'
'
|
|
'
'
|
|
'
'
|
|_______'__________________'_______|
(-.5, -.5)
# text
## Rotation
Positive value is clock-wise around axis.
Imagine looking from a positive point on the axis and turing the entity left.
# code
_______
/
\->
__
/ \
y
| v
|
|
z |
__
\ |
/ \
\|
v |
*---------- x
|
|
# text
## Origin
Setting the origin will move the origin point of the model.
This can be especially useful when working with ui.
# code
(-.5,.5)
+--------+
*--------+
|
|
|
|
| (0,0) |
|
|
|
|
|
|
+--------+
+--------+

(0,.5)
+----*---+
+--------+
|
|
|
|
|
|
|
* (.5,0)
|
|
|
|
+--------+
+--------+
# text
© 2021 GitHub, Inc.
Documentation
# style
a.button:hov
er
{background-
color:
#4CAF50}
# title ursina engine documentation
# center, bold, arial, size 5
<a href="index.html" style="text-decoration: none;
color:inherit">ursina engine
ʕ •ᴥ•ʔゝ□</a>
# normal, size 3, left, width 650
# size 1
[API Reference, cheat_sheet.html]
## Guides
[Installation, installation.html]
[Entity Basics, entity_basics.html]
[Ursina's Coordinate System, coordinate_system.html]
[F.A.Q., faq.html]
[Build and Release, building.html]
## Tutorials
[Introduction, introduction_tutorial.html,
icons/entity_basics_icon.jpg]
[Inventory Tutorial, inventory_tutorial.html,
icons/inventory_icon.jpg]
[Platformer Tutorial, platformer_tutorial.html,
icons/installation_guide_icon.jpg]
## Video Tutorials

[Introduction to Ursina (Breakout) ↗, https://youtu.be/P8J6K6p-
JzY]
[Creating Minecraft in Python ↗, https://youtu.be/DHSRaVeQxIk]
## Example Projects
[Tic Tac Toe,
https://github.com/pokepetter/ursina/blob/master/samples/tic_tac_t
oe.py, icons/tic_tac_toe_icon.jpg]
[Inventory,
https://github.com/pokepetter/ursina/blob/master/samples/inventory
.py, icons/inventory_icon.jpg]
[Pong,
https://github.com/pokepetter/ursina/blob/master/samples/pong.py,
icons/installation_guide_icon.jpg]
[Minecraft Clone,
https://github.com/pokepetter/ursina/blob/master/samples/minecraft
_clone.py, icons/minecraft_clone_icon.jpg]
[Cookie Clicker,
https://github.com/pokepetter/ursina/blob/master/samples/clicker_g
ame.py, icons/installation_guide_icon.jpg]
[Culumn Graph,
https://github.com/pokepetter/ursina/blob/master/samples/culumn_gr
aph.py, icons/column_graph_icon.jpg]
[Platformer,
https://github.com/pokepetter/ursina/blob/master/samples/platforme
r.py, icons/installation_guide_icon.jpg]
[Value of Life,
https://github.com/pokepetter/ld44_life_is_currency,
icons/value_of_life_icon.jpg]
[Castaway, https://github.com/pokepetter/pyweek_30_castaway,
icons/castaway_icon.jpg]
# style a.button:hover {background-color: #4CAF50}
# title ursina engine documentation
# center, bold, arial, size 5
<a href="index.html" style="text-decoration: none; color:inherit">ursina engine
ʕ •ᴥ•ʔゝ□</a>
# normal, size 3, left, width 650
# size 1
[API Reference, cheat_sheet.html]
## Guides

[Installation, installation.html]
[Entity Basics, entity_basics.html]
[Ursina's Coordinate System, coordinate_system.html]
[F.A.Q., faq.html]
[Build and Release, building.html]
## Tutorials
[Introduction, introduction_tutorial.html, icons/entity_basics_icon.jpg]
[Inventory Tutorial, inventory_tutorial.html, icons/inventory_icon.jpg]
[Platformer Tutorial, platformer_tutorial.html, icons/installation_guide_icon.jpg]
## Video Tutorials
[Introduction to Ursina (Breakout) ↗, https://youtu.be/P8J6K6p-JzY]
[Creating Minecraft in Python ↗, https://youtu.be/DHSRaVeQxIk]
## Example Projects
[Tic Tac Toe, https://github.com/pokepetter/ursina/blob/master/samples/tic_tac_toe.py,
icons/tic_tac_toe_icon.jpg]
[Inventory, https://github.com/pokepetter/ursina/blob/master/samples/inventory.py,
icons/inventory_icon.jpg]
[Pong, https://github.com/pokepetter/ursina/blob/master/samples/pong.py,
icons/installation_guide_icon.jpg]
[Minecraft Clone, https://github.com/pokepetter/ursina/blob/master/samples/minecraft_clone.py,
icons/minecraft_clone_icon.jpg]
[Cookie Clicker, https://github.com/pokepetter/ursina/blob/master/samples/clicker_game.py,
icons/installation_guide_icon.jpg]
[Culumn Graph, https://github.com/pokepetter/ursina/blob/master/samples/culumn_graph.py,
icons/column_graph_icon.jpg]
[Platformer, https://github.com/pokepetter/ursina/blob/master/samples/platformer.py,
icons/installation_guide_icon.jpg]
[Value of Life, https://github.com/pokepetter/ld44_life_is_currency, icons/value_of_life_icon.jpg]
[Castaway, https://github.com/pokepetter/pyweek_30_castaway, icons/castaway_icon.jpg]
Documentation Generator dot py
from
pathlib
import
Path
from pprint import pprint
import keyword
import builtins
import textwrap
from ursina import color, lerp, application

def indentation(line):
return len(line) - len(line.lstrip())
def get_module_attributes(str):
attrs = list()
for l in str.split('\n'):
if len(l) == 0:
continue
if l.startswith(tuple(keyword.kwlist) + tuple(dir(builtins)) + (' ', '#',
'\'', '\"', '_')):
continue
attrs.append(l)
return attrs
def get_classes(str):
classes = dict()
for c in str.split('\nclass ')[1:]:
class_name = c.split(':', 1)[0]
if class_name.startswith(('\'', '"')):
continue
# print(class_name)
classes[class_name] = c.split(':', 1)[1]
return classes
def get_class_attributes(str):
attributes = list()
lines = str.split('\n')
start = 0
end = len(lines)
for i, line in enumerate(lines):
if line == '''if __name__ == '__main__':''':
break
found_init = False
if line.strip().startswith('def __init__'):
if found_init:
break
start = i
for j in range(i+1, len(lines)):
if (indentation(lines[j]) == indentation(line)
and not lines[j].strip().startswith('def late_init')
):

end = j
found_init = True
break
init_section = lines[start:end]
# print('init_section:', start, end, init_section)
for i, line in enumerate(init_section):
if line.strip().startswith('self.') and ' = ' in line and
line.startswith(' '*8) and not line.startswith(' '*9):
stripped_line = line.split('self.', 1)[1]
if '.' in stripped_line.split(' ')[0] or stripped_line.startswith('_'):
continue
key = stripped_line.split(' = ')[0]
value = stripped_line.split(' = ')[1]
if i < len(init_section) and indentation(init_section[i+1]) >
indentation(line):
# value = 'multiline'
start = i
end = i
indent = indentation(line)
for j in range(i+1, len(init_section)):
if indentation(init_section[j]) <= indent:
end = j
break
for l in init_section[start+1:end]:
value += '\n' + l[4:]
attributes.append(key + ' = ' + value)
if '@property' in code:
for i, line in enumerate(lines):
if line.strip().startswith('@property'):
name = lines[i+1].split('def ')[1].split('(')[0]
# include comments for properties
if '#' in lines[i+1]:
name += ((20-len(name)) * ' ') + '<gray>#' + lines[i+1].split('#',1)[1] +
'</gray>'
if not name in [e.split(' = ')[0] for e in attributes]:
attributes.append(name)
return attributes

def get_functions(str, is_class=False):
functions = dict()
lines = str.split('\n')
functions = list()
lines = str.split('\n')
ignore_functions_for_property_generation = 'generate_properties(' in str
for i, line in enumerate(lines):
if line == '''if __name__ == '__main__':''' or 'docignore' in line:
break
if line.strip().startswith('def '):
if not is_class and line.split('(')[1].startswith('self'):
continue
name = line.split('def ')[1].split('(')[0]
if name.startswith('_') or lines[i-1].strip().startswith('@'):
continue
if ignore_functions_for_property_generation:
if name.startswith('get_') or name.startswith('set_'):
continue
params = line.replace('(self, ', '(')
params = params.replace('(self)', '()')
params = params.split('(', 1)[1].rsplit(')', 1)[0]
comment = ''
if '#' in line:
comment = '#' + line.split('#')[1]
functions.append((name, params, comment))
return functions
def clear_tags(str):
for tag in ('purple', 'olive', 'yellow', 'blue'):
str = str.replace(f'<{tag}>', '')
str = str.replace(f'</{tag}>', '')
return str
def get_example(str, name=None): # use name to highlight the relevant
class
key = '''if __name__ == '__main__':'''
lines = list()
example_started = False

for l in str.split('\n'):
if example_started:
lines.append(l)
if l == key:
example_started = True
example = '\n'.join(lines)
example = textwrap.dedent(example)
example = example.split('# test\n')[0]
ignore = ('app = Ursina()', 'app.run()', 'from ursina import *')
if 'class Ursina' in str: # don't ignore in main.py
ignore = ()
lines = [e for e in example.split('\n') if not e in ignore and not
e.strip().startswith('#')]
import re
styled_lines = list()
for line in lines:
line = line.replace('def ', '<purple>def</purple> ')
line = line.replace('from ', '<purple>from</purple> ')
line = line.replace('import ', '<purple>import</purple> ')
line = line.replace('for ', '<purple>for</purple> ')
line = line.replace('elif ', '<purple>elif</purple> ')
line = line.replace('if ', '<purple>if</purple> ')
line = line.replace(' not ', ' <purple>not</purple> ')
line = line.replace('else:', '<purple>else</purple>:')
line = line.replace('Entity', '<olive>Entity</olive>')
for e in ('print', 'range', 'hasattr', 'getattr', 'setattr'):
line = line.replace(f'{e}(' , f'<blue>{e}</blue>(')
# colorize ursina specific params
for e in ('enabled', 'parent', 'world_parent', 'model',
'highlight_color', 'color',
'texture_scale', 'texture', 'visible',
'position', 'z', 'y', 'z',
'rotation', 'rotation_x', 'rotation_y', 'rotation_z',
'scale', 'scale_x', 'scale_y', 'scale_z',
'origin', 'origin_x', 'origin_y', 'origin_z',
'text', 'on_click', 'icon', 'collider', 'shader', 'curve', 'ignore',
'vertices', 'triangles', 'uvs', 'normals', 'colors', 'mode', 'thickness'
):
line = line.replace(f'{e}=' , f'<olive>{e}</olive>=')

# colorize numbers
for i in range(10):
line = line.replace(f'{i}', f'<yellow>{i}</yellow>')
# destyle Vec2 and Vec3
line = line.replace(f'<yellow>3</yellow>(', '3(')
line = line.replace(f'<yellow>2</yellow>(', '2(')
# highlight class name
if name:
if '(' in name:
name = name.split('(')[0]
line = line.replace(f'{name}(', f'<purple><b>{name}</b></purple>(')
line = line.replace(f'={name}(', f'=<purple><b>{name}</b></purple>(')
# line = line.replace(f'.{name}', f'.<font colorK
if ' #' in line:
# remove colored words inside strings
line = clear_tags(line)
line = line.replace(' #', ' <gray>#')
line += '</gray>'
styled_lines.append(line)
lines = styled_lines
example = '\n'.join(lines)
# find triple qutoted strings
if example.count("'''") % 2 == 0 and example.count("'''") > 1:
parts = example.strip().split("'''")
parts = [e for e in parts if e]
is_quote = example.strip().startswith("'''")
for i in range(not is_quote, len(parts), 2):
parts[i] = clear_tags(parts[i])
parts[i] = "<green>'''" + parts[i] + "'''</green>"
example = ''.join(parts)
# find single quoted words
styled_lines = []
for line in example.split('\n'):
quotes = re.findall('\'(.*?)\'', line)
quotes = ['\'' + q + '\'' for q in quotes]
for q in quotes:
line = line.replace(q, '<green>' + clear_tags(q) + '</green>')

styled_lines.append(line)
example = '\n'.join(styled_lines)
return example.strip()
def is_singleton(str):
for l in str.split('\n'):
# if l.startswith('sys.modules['):
if l.startswith('instance = '):
return True
result = False
path = application.package_folder
most_used_info = dict()
module_info = dict()
class_info = dict()
# ignore files that are not commited
ignored_files = list()
from git import Repo
repo = Repo(path.parent)
ignored_files = repo.untracked_files
ignored_files = [Path(path.parent / e) for e in ignored_files]
for f in ignored_files:
print('ignoring:', f)
ignored_files.append(path / 'gamepad.py')
for f in path.glob('*.py'):
if f in ignored_files:
continue
if f.name.startswith('_') or f.name == 'build.py':
module_info['build'] = (
f,
'python -m ursina.build',
{},
'',
'''open cmd at your project folder and run 'python -m ursina.build' to
package your app for windows.'''
)
continue
with open(f, encoding='utf8') as t:
code = t.read()
code = code.replace('<', '&lt').replace('>', '&gt')

if not is_singleton(code):
name = f.stem
attrs, funcs = list(), list()
attrs = get_module_attributes(code)
funcs = get_functions(code)
example = get_example(code, name)
if attrs or funcs:
module_info[name] = (f, '', attrs, funcs, example)
# continue
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'Enum' in class_name:
class_definition = class_definition.split('def ')[0]
attrs = [l.strip() for l in class_definition.split('\n') if ' = ' in l]
class_info[class_name] = (f, '', attrs, '', '')
continue
if 'def __init__' in class_definition:
# init line
params = '__init__('+ class_definition.split('def
__init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
class_info[class_name] = (f, params, attrs, methods, example)
# singletons
else:
module_name = f.name.split('.')[0]
classes = get_classes(code)
for class_name, class_definition in classes.items():
# print(module_name)
attrs, methods = list(), list()
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
module_info[module_name] = (f, '', attrs, methods, example)
prefab_info = dict()
for f in path.glob('prefabs/*.py'):
if f.name.startswith('_') or f in ignored_files:
continue
with open(f, encoding='utf8') as t:
code = t.read()

code = code.replace('<', '&lt').replace('>', '&gt')
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'def __init__' in class_definition:
params = '__init__('+ class_definition.split('def
__init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
prefab_info[class_name] = (f, params, attrs, methods, example)
script_info = dict()
for f in path.glob('scripts/*.py'):
if f.name.startswith('_') or f in ignored_files:
continue
# if f.is_file() and f.name.endswith(('.py', )):
with open(f, encoding='utf8') as t:
code = t.read()
if not 'class ' in code:
name = f.name.split('.')[0]
attrs, funcs = list(), list()
attrs = get_module_attributes(code)
funcs = get_functions(code)
example = get_example(code)
if attrs or funcs:
script_info[name] = (f, '', attrs, funcs, example)
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'def __init__' in class_definition:
params = '__init__('+ class_definition.split('def
__init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
script_info[class_name] = (f, params, attrs, methods, example)
asset_info = dict()
model_names = [f'\'{f.stem}\'' for f in
path.glob('models_compressed/*.ursinamesh')]
asset_info['models'] = ('', '', model_names, '', '''e =
Entity(model='quad')''')

texture_names = [f'\'{f.stem}\'' for f in path.glob('textures/*.*')]
asset_info['textures'] = ('', '', texture_names, '', '''e =
Entity(model='cube', texture='brick')''')
shaders = [f'{f.stem}' for f in path.glob('shaders/*.*')]
asset_info['shaders'] = ('', '', shaders, '', '''from ursina.shaders
import normals_shader\ne = Entity(shader=normals_shader)''')
for f in path.glob('models/procedural/*.py'):
if f.name.startswith('_') or f in ignored_files:
continue
with open(f, encoding='utf8') as t:
code = t.read()
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'def __init__' in class_definition:
params = '__init__('+ class_definition.split('def
__init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
asset_info[class_name] = (f, params, attrs, methods, example)
most_used_info = dict()
for name in ('Entity(NodePath)', 'Text(Entity)', 'Button(Entity)',
'mouse', 'raycaster',):
for d in (module_info, class_info, prefab_info):
if name in d:
most_used_info[name] = d[name]
del d[name]
def html_color(color):
return f'hsl({color.h}, {int(color.s*100)}%, {int(color.v*100)}%)'
def make_html(style, file_name):
if style == 'light':
base_color = color.color(60, 0, .99)
background_color = lerp(base_color, base_color.invert(), 0)
else:
base_color = color.color(60, 1, .01)
background_color = lerp(base_color, base_color.invert(), .125)
text_color = lerp(background_color, background_color.invert(), .9)
example_color = lerp(background_color, text_color, .1)

scrollbar_color = html_color(lerp(background_color, text_color, .1))
link_color = html_color(color.gray)
init_color = html_color(base_color.invert())
style = f'''
<style>
html {{
scrollbar-face-color: {html_color(text_color)};
scrollbar-base-color: {html_color(text_color)};
scrollbar-3dlight-color: {html_color(text_color)}4;
scrollbar-highlight-color: {html_color(text_color)};
scrollbar-track-color: {html_color(background_color)};
scrollbar-arrow-color: {html_color(background_color)};
scrollbar-shadow-color: {html_color(text_color)};
scrollbar-darkshadow-color: {html_color(text_color)};
}}
::-webkit-scrollbar {{ width: 8px; height: 3px;}}
::-webkit-scrollbar {{ width: 8px; height: 3px;}}
::-webkit-scrollbar-button {{ background-color: {scrollbar_color}; }}
::-webkit-scrollbar-track {{ background-color:
{html_color(background_color)};}}
::-webkit-scrollbar-track-piece {{ background-color:
{html_color(background_color)};}}
::-webkit-scrollbar-thumb {{ height: 50px; background-color:
{scrollbar_color}; border-radius: 3px;}}
::-webkit-scrollbar-corner {{ background-color:
{html_color(background_color)};}}
::-webkit-resizer {{ background-color: {html_color(background_color)};}}
body {{
margin: auto;
background-color: {html_color(background_color)};
color: {html_color(text_color)};
font-family: monospace;
position: absolute;
top:0;
left: 24em;
font-size: 1.375em;
font-weight: lighter;
max-width: 100%;
overflow-x: hidden;
white-space: pre-wrap;
}}
a {{
color: {link_color};
}}

purple {{color: hsl(289.0, 50%, 50%);}}
gray {{color: gray;}}
olive {{color: olive;}}
yellow {{color: darkgoldenrod;}}
green {{color: seagreen;}}
blue {{color: hsl(210, 50%, 50%);}}
.example {{
padding-left: 1em;
background-color: {html_color(example_color)};
}}
.params {{
color:{init_color};
font-weight:bold;
}}
</style>
'''
# return style
html = '<title> ursina cheat sheet</title>'
html += '''
<b>Ursina cheat sheet</b>
This document lists most modules and classes in ursina. Each section is
structured as follows:
ClassName(BaseClass)
module location
parameters
How instantiate the class, ie. Button(text='', **kwargs).
'**kwargs' in this case, means you can give it optional keyword
arguments.
For example, Button('Start', scale=.25, color=color.blue, position=(-
.1,.25)) also incldues
information on how big the button should be, its color and its position.
attributes
Names of values we can get/set, sometimes followed by its starting value
and a short explanation.
For example, 'scale', 'color' and 'position' are
attributes we gave the Button above. These are members of Entity, which
Button class
inherits from, so the Button class can also access these.
methods/functions
these ends with (), which means they are functions that can be called.

Also lists their parameters and default arguments.
For example, Entity has a method called 'look_at()'. You need to give it
a
'target' (an Entity or position) to look at and optionally say
which axis will be facing the target.
example
You can search the document with Ctrl+F for instant search results.
'''
sidebar = '''
<div class="sidebar" style="
left: 0px;
position: fixed;
top: 0px;
padding-top:40px;
padding-left:20px;
bottom: 0;
overflow-y: scroll;
width: 15em;
z-index: 1;
">
<a href="cheat_sheet.html">light</a> <a
href="cheat_sheet_dark.html">dark</a>
'''
for i, class_dictionary in enumerate((most_used_info, module_info,
class_info, prefab_info, script_info, asset_info)):
for name, attrs_and_functions in class_dictionary.items():
print('generating docs for', name)
location, params, attrs, funcs, example = attrs_and_functions
params = params.replace('__init__', name.split('(')[0])
params = params.replace('(self, ', '(')
params = params.replace('(self)', '()')
name = name.replace('ShowBase', '')
name = name.replace('NodePath', '')
for parent_class in ('Entity', 'Button', 'Draggable', 'Text', 'Collider',
'Mesh', 'Prismatoid'):
name = name.replace(f'({parent_class})', f'(<a style="color: gray;"
href="#{parent_class}">{parent_class}</a>)')
base_name = name
if '(' in base_name:
base_name = base_name.split('(')[0]

base_name = base_name.split(')')[0]
name = name.replace('(', '<gray>(')
name = name.replace(')', ')</gray>')
v = lerp(text_color.v, background_color.v, .2)
# v = .5
col = color.color(50-(i*30), .9, v)
col = html_color(col)
sidebar += f'''<a style="color:{col};"
href="#{base_name}">{base_name}</a>\n'''
html += '\n'
html += f'''<div id="{base_name}"><div id="{base_name}"
style="color:{col}; font-size:1.75em; font-
weight:normal;">{name}</div>'''
html += '<div style="position:relative; padding:0em 0em 2em 1em;
margin:0;">'
# location
location = str(location)
if 'ursina' in location:
location = location.split('ursina')[-1]
github_link = 'https://github.com/pokepetter/ursina/tree/master/ursina' +
location.replace('\\', '/')
location = location.replace('\\', '.')[:-3]
html += f'''<a
href="{github_link}"><gray>ursina{location}</gray></a><br><br>'''
if params:
params = f'<params class="params">{params}</params>\n'
html += params + '\n'
for e in attrs:
if ' = ' in e:
e = f'''{e.split(' = ')[0]}<gray> = {e.split(' = ')[1]}</gray> '''
html += f'''{e}\n'''
html += '\n'
for e in funcs:
e = f'{e[0]}(<gray>{e[1]}</gray>) <gray>{e[2]}</gray>'
html += e + '\n'
if example:
html += '\n<div class="example">' + example +'\n</div>'
html += '\n</div></div>'
html = html.replace('<gray></gray>', '')

sidebar += '\n'
sidebar += '</div>'
html += '</div>'
html = sidebar + style + '<div id="content">' + html + '</div>' +
'</body>'
with open(file_name, 'w', encoding='utf-8') as f:
f.write(html)
make_html('light', 'cheat_sheet.html')
make_html('dark', 'cheat_sheet_dark.html')
from pathlib import Path
from pprint import pprint
import keyword
import builtins
import textwrap
from ursina import color, lerp, application
def indentation(line):
return len(line) - len(line.lstrip())
def get_module_attributes(str):
attrs = list()
for l in str.split('\n'):
if len(l) == 0:
continue
if l.startswith(tuple(keyword.kwlist) + tuple(dir(builtins)) + (' ', '#', '\'', '\"', '_')):
continue
attrs.append(l)
return attrs
def get_classes(str):
classes = dict()
for c in str.split('\nclass ')[1:]:
class_name = c.split(':', 1)[0]
if class_name.startswith(('\'', '"')):
continue
# print(class_name)
classes[class_name] = c.split(':', 1)[1]
return classes
def get_class_attributes(str):
attributes = list()

lines = str.split('\n')
start = 0
end = len(lines)
for i, line in enumerate(lines):
if line == '''if __name__ == '__main__':''':
break
found_init = False
if line.strip().startswith('def __init__'):
if found_init:
break
start = i
for j in range(i+1, len(lines)):
if (indentation(lines[j]) == indentation(line)
and not lines[j].strip().startswith('def late_init')
):
end = j
found_init = True
break
init_section = lines[start:end]
# print('init_section:', start, end, init_section)
for i, line in enumerate(init_section):
if line.strip().startswith('self.') and ' = ' in line and line.startswith(' '*8) and not line.startswith('
'*9):
stripped_line = line.split('self.', 1)[1]
if '.' in stripped_line.split(' ')[0] or stripped_line.startswith('_'):
continue
key = stripped_line.split(' = ')[0]
value = stripped_line.split(' = ')[1]
if i < len(init_section) and indentation(init_section[i+1]) > indentation(line):
# value = 'multiline'
start = i
end = i
indent = indentation(line)
for j in range(i+1, len(init_section)):
if indentation(init_section[j]) <= indent:
end = j
break
for l in init_section[start+1:end]:
value += '\n' + l[4:]
attributes.append(key + ' = ' + value)
if '@property' in code:
for i, line in enumerate(lines):
if line.strip().startswith('@property'):
name = lines[i+1].split('def ')[1].split('(')[0]
# include comments for properties
if '#' in lines[i+1]:

name += ((20-len(name)) * ' ') + '<gray>#' + lines[i+1].split('#',1)[1] + '</gray>'
if not name in [e.split(' = ')[0] for e in attributes]:
attributes.append(name)
return attributes
def get_functions(str, is_class=False):
functions = dict()
lines = str.split('\n')
functions = list()
lines = str.split('\n')
ignore_functions_for_property_generation = 'generate_properties(' in str
for i, line in enumerate(lines):
if line == '''if __name__ == '__main__':''' or 'docignore' in line:
break
if line.strip().startswith('def '):
if not is_class and line.split('(')[1].startswith('self'):
continue
name = line.split('def ')[1].split('(')[0]
if name.startswith('_') or lines[i-1].strip().startswith('@'):
continue
if ignore_functions_for_property_generation:
if name.startswith('get_') or name.startswith('set_'):
continue
params = line.replace('(self, ', '(')
params = params.replace('(self)', '()')
params = params.split('(', 1)[1].rsplit(')', 1)[0]
comment = ''
if '#' in line:
comment = '#' + line.split('#')[1]
functions.append((name, params, comment))
return functions
def clear_tags(str):
for tag in ('purple', 'olive', 'yellow', 'blue'):
str = str.replace(f'<{tag}>', '')
str = str.replace(f'</{tag}>', '')
return str
def get_example(str, name=None):
# use name to highlight the relevant class
key = '''if __name__ == '__main__':'''
lines = list()
example_started = False

for l in str.split('\n'):
if example_started:
lines.append(l)
if l == key:
example_started = True
example = '\n'.join(lines)
example = textwrap.dedent(example)
example = example.split('# test\n')[0]
ignore = ('app = Ursina()', 'app.run()', 'from ursina import *')
if 'class Ursina' in str: # don't ignore in main.py
ignore = ()
lines = [e for e in example.split('\n') if not e in ignore and not e.strip().startswith('#')]
import re
styled_lines = list()
for line in lines:
line = line.replace('def ', '<purple>def</purple> ')
line = line.replace('from ', '<purple>from</purple> ')
line = line.replace('import ', '<purple>import</purple> ')
line = line.replace('for ', '<purple>for</purple> ')
line = line.replace('elif ', '<purple>elif</purple> ')
line = line.replace('if ', '<purple>if</purple> ')
line = line.replace(' not ', ' <purple>not</purple> ')
line = line.replace('else:', '<purple>else</purple>:')
line = line.replace('Entity', '<olive>Entity</olive>')
for e in ('print', 'range', 'hasattr', 'getattr', 'setattr'):
line = line.replace(f'{e}(' , f'<blue>{e}</blue>(')
# colorize ursina specific params
for e in ('enabled', 'parent', 'world_parent', 'model', 'highlight_color', 'color',
'texture_scale', 'texture', 'visible',
'position', 'z', 'y', 'z',
'rotation', 'rotation_x', 'rotation_y', 'rotation_z',
'scale', 'scale_x', 'scale_y', 'scale_z',
'origin', 'origin_x', 'origin_y', 'origin_z',
'text', 'on_click', 'icon', 'collider', 'shader', 'curve', 'ignore',
'vertices', 'triangles', 'uvs', 'normals', 'colors', 'mode', 'thickness'
):
line = line.replace(f'{e}=' , f'<olive>{e}</olive>=')
# colorize numbers
for i in range(10):
line = line.replace(f'{i}', f'<yellow>{i}</yellow>')
# destyle Vec2 and Vec3
line = line.replace(f'<yellow>3</yellow>(', '3(')
line = line.replace(f'<yellow>2</yellow>(', '2(')
# highlight class name

if name:
if '(' in name:
name = name.split('(')[0]
line = line.replace(f'{name}(', f'<purple><b>{name}</b></purple>(')
line = line.replace(f'={name}(', f'=<purple><b>{name}</b></purple>(')
# line = line.replace(f'.{name}', f'.<font colorK
if ' #' in line:
# remove colored words inside strings
line = clear_tags(line)
line = line.replace(' #', ' <gray>#')
line += '</gray>'
styled_lines.append(line)
lines = styled_lines
example = '\n'.join(lines)
# find triple qutoted strings
if example.count("'''") % 2 == 0 and example.count("'''") > 1:
parts = example.strip().split("'''")
parts = [e for e in parts if e]
is_quote = example.strip().startswith("'''")
for i in range(not is_quote, len(parts), 2):
parts[i] = clear_tags(parts[i])
parts[i] = "<green>'''" + parts[i] + "'''</green>"
example = ''.join(parts)
# find single quoted words
styled_lines = []
for line in example.split('\n'):
quotes = re.findall('\'(.*?)\'', line)
quotes = ['\'' + q + '\'' for q in quotes]
for q in quotes:
line = line.replace(q, '<green>' + clear_tags(q) + '</green>')
styled_lines.append(line)
example = '\n'.join(styled_lines)
return example.strip()
def is_singleton(str):
for l in str.split('\n'):
# if l.startswith('sys.modules['):
if l.startswith('instance = '):
return True
result = False

path = application.package_folder
most_used_info = dict()
module_info = dict()
class_info = dict()
# ignore files that are not commited
ignored_files = list()
from git import Repo
repo = Repo(path.parent)
ignored_files = repo.untracked_files
ignored_files = [Path(path.parent / e) for e in ignored_files]
for f in ignored_files:
print('ignoring:', f)
ignored_files.append(path / 'gamepad.py')
for f in path.glob('*.py'):
if f in ignored_files:
continue
if f.name.startswith('_') or f.name == 'build.py':
module_info['build'] = (
f,
'python -m ursina.build',
{},
'',
'''open cmd at your project folder and run 'python -m ursina.build' to package your app for
windows.'''
)
continue
with open(f, encoding='utf8') as t:
code = t.read()
code = code.replace('<', '&lt').replace('>', '&gt')
if not is_singleton(code):
name = f.stem
attrs, funcs = list(), list()
attrs = get_module_attributes(code)
funcs = get_functions(code)
example = get_example(code, name)
if attrs or funcs:
module_info[name] = (f, '', attrs, funcs, example)
# continue
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'Enum' in class_name:
class_definition = class_definition.split('def ')[0]
attrs = [l.strip() for l in class_definition.split('\n') if ' = ' in l]
class_info[class_name] = (f, '', attrs, '', '')
continue
if 'def __init__' in class_definition:
# init line
params = '__init__('+ class_definition.split('def __init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)

class_info[class_name] = (f, params, attrs, methods, example)
# singletons
else:
module_name = f.name.split('.')[0]
classes = get_classes(code)
for class_name, class_definition in classes.items():
# print(module_name)
attrs, methods = list(), list()
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
module_info[module_name] = (f, '', attrs, methods, example)
prefab_info = dict()
for f in path.glob('prefabs/*.py'):
if f.name.startswith('_') or f in ignored_files:
continue
with open(f, encoding='utf8') as t:
code = t.read()
code = code.replace('<', '&lt').replace('>', '&gt')
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'def __init__' in class_definition:
params = '__init__('+ class_definition.split('def __init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
prefab_info[class_name] = (f, params, attrs, methods, example)
script_info = dict()
for f in path.glob('scripts/*.py'):
if f.name.startswith('_') or f in ignored_files:
continue
# if f.is_file() and f.name.endswith(('.py', )):
with open(f, encoding='utf8') as t:
code = t.read()
if not 'class ' in code:
name = f.name.split('.')[0]
attrs, funcs = list(), list()
attrs = get_module_attributes(code)
funcs = get_functions(code)
example = get_example(code)
if attrs or funcs:
script_info[name] = (f, '', attrs, funcs, example)
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'def __init__' in class_definition:

params = '__init__('+ class_definition.split('def __init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
script_info[class_name] = (f, params, attrs, methods, example)
asset_info = dict()
model_names = [f'\'{f.stem}\'' for f in path.glob('models_compressed/*.ursinamesh')]
asset_info['models'] = ('', '', model_names, '', '''e = Entity(model='quad')''')
texture_names = [f'\'{f.stem}\'' for f in path.glob('textures/*.*')]
asset_info['textures'] = ('', '', texture_names, '', '''e = Entity(model='cube', texture='brick')''')
shaders = [f'{f.stem}' for f in path.glob('shaders/*.*')]
asset_info['shaders'] = ('', '', shaders, '', '''from ursina.shaders import normals_shader\ne =
Entity(shader=normals_shader)''')
for f in path.glob('models/procedural/*.py'):
if f.name.startswith('_') or f in ignored_files:
continue
with open(f, encoding='utf8') as t:
code = t.read()
classes = get_classes(code)
for class_name, class_definition in classes.items():
if 'def __init__' in class_definition:
params = '__init__('+ class_definition.split('def __init__(')[1].split('\n')[0][:-1]
attrs = get_class_attributes(class_definition)
methods = get_functions(class_definition, is_class=True)
example = get_example(code, class_name)
asset_info[class_name] = (f, params, attrs, methods, example)
most_used_info = dict()
for name in ('Entity(NodePath)', 'Text(Entity)', 'Button(Entity)', 'mouse', 'raycaster',):
for d in (module_info, class_info, prefab_info):
if name in d:
most_used_info[name] = d[name]
del d[name]
def html_color(color):
return f'hsl({color.h}, {int(color.s*100)}%, {int(color.v*100)}%)'
def make_html(style, file_name):
if style == 'light':
base_color = color.color(60, 0, .99)
background_color = lerp(base_color, base_color.invert(), 0)
else:
base_color = color.color(60, 1, .01)
background_color = lerp(base_color, base_color.invert(), .125)
text_color = lerp(background_color, background_color.invert(), .9)

example_color = lerp(background_color, text_color, .1)
scrollbar_color = html_color(lerp(background_color, text_color, .1))
link_color = html_color(color.gray)
init_color = html_color(base_color.invert())
style = f'''
<style>
html {{
scrollbar-face-color: {html_color(text_color)};
scrollbar-base-color: {html_color(text_color)};
scrollbar-3dlight-color: {html_color(text_color)}4;
scrollbar-highlight-color: {html_color(text_color)};
scrollbar-track-color: {html_color(background_color)};
scrollbar-arrow-color: {html_color(background_color)};
scrollbar-shadow-color: {html_color(text_color)};
scrollbar-darkshadow-color: {html_color(text_color)};
}}
::-webkit-scrollbar {{ width: 8px; height: 3px;}}
::-webkit-scrollbar {{ width: 8px; height: 3px;}}
::-webkit-scrollbar-button {{ background-color: {scrollbar_color}; }}
::-webkit-scrollbar-track {{ background-color: {html_color(background_color)};}}
::-webkit-scrollbar-track-piece {{ background-color: {html_color(background_color)};}}
::-webkit-scrollbar-thumb {{ height: 50px; background-color: {scrollbar_color}; border-radius:
3px;}}
::-webkit-scrollbar-corner {{ background-color: {html_color(background_color)};}}
::-webkit-resizer {{ background-color: {html_color(background_color)};}}
body {{
margin: auto;
background-color: {html_color(background_color)};
color: {html_color(text_color)};
font-family: monospace;
position: absolute;
top:0;
left: 24em;
font-size: 1.375em;
font-weight: lighter;
max-width: 100%;
overflow-x: hidden;
white-space: pre-wrap;
}}
a {{
color: {link_color};
}}
purple {{color: hsl(289.0, 50%, 50%);}}
gray {{color: gray;}}
olive {{color: olive;}}
yellow {{color: darkgoldenrod;}}
green {{color: seagreen;}}
blue {{color: hsl(210, 50%, 50%);}}
.example {{
padding-left: 1em;
background-color: {html_color(example_color)};
}}
.params {{
color:{init_color};
font-weight:bold;
}}

</style>
'''
# return style
html = '<title> ursina cheat sheet</title>'
html += '''
<b>Ursina cheat sheet</b>
This document lists most modules and classes in ursina. Each section is structured as follows:
ClassName(BaseClass)
module location
parameters
How instantiate the class, ie. Button(text='', **kwargs).
'**kwargs' in this case, means you can give it optional keyword arguments.
For example, Button('Start', scale=.25, color=color.blue, position=(-.1,.25)) also incldues
information on how big the button should be, its color and its position.
attributes
Names of values we can get/set, sometimes followed by its starting value and a short
explanation.
For example, 'scale', 'color' and 'position' are
attributes we gave the Button above. These are members of Entity, which Button class
inherits from, so the Button class can also access these.
methods/functions
these ends with (), which means they are functions that can be called.
Also lists their parameters and default arguments.
For example, Entity has a method called 'look_at()'. You need to give it a
'target' (an Entity or position) to look at and optionally say
which axis will be facing the target.
example
You can search the document with Ctrl+F for instant search results.
'''
sidebar = '''
<div class="sidebar" style="
left: 0px;
position: fixed;
top: 0px;
padding-top:40px;
padding-left:20px;
bottom: 0;
overflow-y: scroll;
width: 15em;
z-index: 1;
">
<a href="cheat_sheet.html">light</a> <a href="cheat_sheet_dark.html">dark</a>
'''
for i, class_dictionary in enumerate((most_used_info, module_info, class_info, prefab_info,
script_info, asset_info)):
for name, attrs_and_functions in class_dictionary.items():
print('generating docs for', name)
location, params, attrs, funcs, example = attrs_and_functions
params = params.replace('__init__', name.split('(')[0])
params = params.replace('(self, ', '(')
params = params.replace('(self)', '()')

name = name.replace('ShowBase', '')
name = name.replace('NodePath', '')
for parent_class in ('Entity', 'Button', 'Draggable', 'Text', 'Collider', 'Mesh', 'Prismatoid'):
name = name.replace(f'({parent_class})', f'(<a style="color: gray;"
href="#{parent_class}">{parent_class}</a>)')
base_name = name
if '(' in base_name:
base_name = base_name.split('(')[0]
base_name = base_name.split(')')[0]
name = name.replace('(', '<gray>(')
name = name.replace(')', ')</gray>')
v = lerp(text_color.v, background_color.v, .2)
# v = .5
col = color.color(50-(i*30), .9, v)
col = html_color(col)
sidebar += f'''<a style="color:{col};" href="#{base_name}">{base_name}</a>\n'''
html += '\n'
html += f'''<div id="{base_name}"><div id="{base_name}" style="color:{col}; font-size:1.75em;
font-weight:normal;">{name}</div>'''
html += '<div style="position:relative; padding:0em 0em 2em 1em; margin:0;">'
# location
location = str(location)
if 'ursina' in location:
location = location.split('ursina')[-1]
github_link = 'https://github.com/pokepetter/ursina/tree/master/ursina' +
location.replace('\\', '/')
location = location.replace('\\', '.')[:-3]
html += f'''<a href="{github_link}"><gray>ursina{location}</gray></a><br><br>'''
if params:
params = f'<params class="params">{params}</params>\n'
html += params + '\n'
for e in attrs:
if ' = ' in e:
e = f'''{e.split(' = ')[0]}<gray> = {e.split(' = ')[1]}</gray> '''
html += f'''{e}\n'''
html += '\n'
for e in funcs:
e = f'{e[0]}(<gray>{e[1]}</gray>) <gray>{e[2]}</gray>'
html += e + '\n'
if example:
html += '\n<div class="example">' + example +'\n</div>'
html += '\n</div></div>'
html = html.replace('<gray></gray>', '')
sidebar += '\n'

sidebar += '</div>'
html += '</div>'
html = sidebar + style + '<div id="content">' + html + '</div>' + '</body>'
with open(file_name, 'w', encoding='utf-8') as f:
f.write(html)
make_html('light', 'cheat_sheet.html')
make_html('dark', 'cheat_sheet_dark.html')
Entity basics
#
title
entity
basics
# center, width 1000, arial
# size 5, bold
Entity Basics
# size 1, normal
# left
## What is an Entity?
An entity is a thing in the world, and is the "god class" in ursina.
It's like a GameObject in Unity or an Actor in Unreal.
It can have a position, rotation, and scale.
It can have a model, texture and color.
It can have an update function, input function and scripts.
For an overview of all its attributes and functions, see
https://www.ursinaengine.org/cheat_sheet.html#Entity
## Setting a model
There are several included models like 'quad', 'plane', 'cube' and
'sphere',
but you can also use your own.
To do that simply give the base name of your model and it will glob/search
for
the model and take the first one it finds.
Supported file types are:
* obj
* bam (binary format)
* blend (gets auto converted to an obj)
* ursinamesh (custom human readable format identical to how you'd make a
Mesh in code)

# code
Entity(model='name_of_your_model')
# text
## Texture
Setting a texture is similar to setting a model. Just give it a name in
this case as well:
# code
e1 = Entity(model='cube', texture='texture_name')
# other ways are:
e2 = Entity(model='cube', texture=e1.texture) # or set it to another
Texture
e3 = Entity(model='cube', texture=PIL.Image.new(mode="RGBA",
size=(854,480))) # set a PIL texture
e4 = Entity(model='cube', texture='movie_name.mp4') # set video texture
# text
For 2d graphics there's also the Sprite class, which is simply an Entity
with a
'quad' model and scale set to automatically fit the size and aspect ratio
of the texture.
# code
s = Sprite('texture_name')
print(s.aspect_ratio)
# text
## Setting the color
# code
e.color = color.red # set it to a color in the color module
e.color = color.color(120, .5, .5) # hsv color
e.color = color.rgb(.8, .1, 0) # rgb color
e.color = e.color.tint(.1) # tint the color
e.color = color.random_color() # set it to a random color
e.color = lerp(color.red, color.green, .5) # set it to a color half way
between red and green
# text
## Moving

You can move an entity by setting the attributes:
'position', 'x', 'y', 'z', 'world_position', 'world_x', 'world_y',
'world_z'
# code
# you can give it a position when you create i, or you can omit it and set
it later
e = Entity(position=(0,0,0))
# set position relative to parent entity:
e.position = Vec3(0,0,0)
e.position = Vec2(0,0)
e.position = (0,0,0)
e.position = (0,0)
# shortcuts for individual axes:
e.x = 0
e.y = 0
e.z = 0
# set position relative to the world:
e.world_position = (0,0,0)
# text
See https://www.ursinaengine.org/coordinate_system.html for more
information on how the coordinate system works.
## Rotating
#code
e.rotation = (0,0,0)
e.rotation_y = 90
# text
The look_at() method can also be for pointing an entity at something:
#code
other entity = Entity(position=(10,1,8))
e.look_at(other_entity) # make z-axis(forward) point at other_entity
e.look_at(other_entity, axis='up') # optinally define which axis
# text
## Scaling
Change the size of the entity by setting the scale attribute:

# code
e = Entity(model='cube', scale=(3,1,1))
# text
## Update
An Entity's update method will be called automatically:
# code
e = Entity()
def my_update():
e.x += 1 * time.dt # dt is short for delta time, the duration since the
last frame.
e.update = my_update
# text
Or you can implement it by inheriting the Entity class:
# code
class Player(Entity):
def update(self):
self.x += 1 * time.dt
# text
## Input
The same goes for the input method:
# code
class Player(Entity):
def input(self, key):
if key == 'w':
self.position += self.forward
if key == 'd':
self.animate('rotation_y', self.rotation_y + 90, duration=.1)
if key == 'a':
self.animate('rotation_y', self.rotation_y - 90, duration=.1)
# text
## Mouse Input
Entities can react to the mouse as long as they have collider.
Buttons will have one by default, but you can also assign one.

To get the entity currently under the mouse:
#code
print(mouse.entity)
# text
To check if and entity with a collider is hovered by the mouse:
# code
print(my_entity.hovered)
# text
There are also functions for handling mouse clicks and hover/unhover.
These only works if the Entity has a collider and the function/callable is
assigned.
# code
on_click()
on_double_click()
on_mouse_enter()
on_mouse_exit()
# text
Example:
# code
def action():
print('Ow! That hurt!')
Entity(model='quad', parent=camera.ui, scale=.1, collider='box',
on_click=action) # on_click should be a function/callable/Func/Sequence
# text
on_mouse_enter and on_mouse_exit example:
# code
b = Button(scale=(.5, .25), text='zzz')
b.on_mouse_enter = Func(setattr, b, 'text', 'Hi, friend :D')
b.on_mouse_exit = Func(setattr, b, 'text', '''No! Don't leave me ;-;''')
# text
## Other Magic Functions
Sometimes you want side effects when you enable/diable and entity, like
play an animation or something.
# code
on_enable()
on_disable()
# text
# title entity basics
# center, width 1000, arial

# size 5, bold
Entity Basics
# size 1, normal
# left
## What is an Entity?
An entity is a thing in the world, and is the "god class" in ursina.
It's like a GameObject in Unity or an Actor in Unreal.
It can have a position, rotation, and scale.
It can have a model, texture and color.
It can have an update function, input function and scripts.
For an overview of all its attributes and functions, see
https://www.ursinaengine.org/cheat_sheet.html#Entity
## Setting a model
There are several included models like 'quad', 'plane', 'cube' and 'sphere',
but you can also use your own.
To do that simply give the base name of your model and it will glob/search for
the model and take the first one it finds.
Supported file types are:
* obj
* bam (binary format)
* blend (gets auto converted to an obj)
* ursinamesh (custom human readable format identical to how you'd make a Mesh in code)
# code
Entity(model='name_of_your_model')
# text
## Texture
Setting a texture is similar to setting a model. Just give it a name in this case as well:
# code
e1 = Entity(model='cube', texture='texture_name')
# other ways are:
e2 = Entity(model='cube', texture=e1.texture) # or set it to another Texture
e3 = Entity(model='cube', texture=PIL.Image.new(mode="RGBA", size=(854,480))) # set a PIL
texture
e4 = Entity(model='cube', texture='movie_name.mp4') # set video texture
# text
For 2d graphics there's also the Sprite class, which is simply an Entity with a
'quad' model and scale set to automatically fit the size and aspect ratio of the texture.
# code
s = Sprite('texture_name')

print(s.aspect_ratio)
# text
## Setting the color
# code
e.color = color.red # set it to a color in the color module
e.color = color.color(120, .5, .5) # hsv color
e.color = color.rgb(.8, .1, 0) # rgb color
e.color = e.color.tint(.1) # tint the color
e.color = color.random_color() # set it to a random color
e.color = lerp(color.red, color.green, .5) # set it to a color half way between red and green
# text
## Moving
You can move an entity by setting the attributes:
'position', 'x', 'y', 'z', 'world_position', 'world_x', 'world_y', 'world_z'
# code
# you can give it a position when you create i, or you can omit it and set it later
e = Entity(position=(0,0,0))
# set position relative to parent entity:
e.position = Vec3(0,0,0)
e.position = Vec2(0,0)
e.position = (0,0,0)
e.position = (0,0)
# shortcuts for individual axes:
e.x = 0
e.y = 0
e.z = 0
# set position relative to the world:
e.world_position = (0,0,0)
# text
See https://www.ursinaengine.org/coordinate_system.html for more
information on how the coordinate system works.
## Rotating
#code
e.rotation = (0,0,0)
e.rotation_y = 90
# text
The look_at() method can also be for pointing an entity at something:
#code

other entity = Entity(position=(10,1,8))
e.look_at(other_entity) # make z-axis(forward) point at other_entity
e.look_at(other_entity, axis='up') # optinally define which axis
# text
## Scaling
Change the size of the entity by setting the scale attribute:
# code
e = Entity(model='cube', scale=(3,1,1))
# text
## Update
An Entity's update method will be called automatically:
# code
e = Entity()
def my_update():
e.x += 1 * time.dt # dt is short for delta time, the duration since the last frame.
e.update = my_update
# text
Or you can implement it by inheriting the Entity class:
# code
class Player(Entity):
def update(self):
self.x += 1 * time.dt
# text
## Input
The same goes for the input method:
# code
class Player(Entity):
def input(self, key):
if key == 'w':
self.position += self.forward
if key == 'd':
self.animate('rotation_y', self.rotation_y + 90, duration=.1)
if key == 'a':
self.animate('rotation_y', self.rotation_y - 90, duration=.1)
# text

## Mouse Input
Entities can react to the mouse as long as they have collider.
Buttons will have one by default, but you can also assign one.
To get the entity currently under the mouse:
#code
print(mouse.entity)
# text
To check if and entity with a collider is hovered by the mouse:
# code
print(my_entity.hovered)
# text
There are also functions for handling mouse clicks and hover/unhover.
These only works if the Entity has a collider and the function/callable is assigned.
# code
on_click()
on_double_click()
on_mouse_enter()
on_mouse_exit()
# text
Example:
# code
def action():
print('Ow! That hurt!')
Entity(model='quad', parent=camera.ui, scale=.1, collider='box', on_click=action) # on_click should
be a function/callable/Func/Sequence
# text
on_mouse_enter and on_mouse_exit example:
# code
b = Button(scale=(.5, .25), text='zzz')
b.on_mouse_enter = Func(setattr, b, 'text', 'Hi, friend :D')
b.on_mouse_exit = Func(setattr, b, 'text', '''No! Don't leave me ;-;''')
# text
## Other Magic Functions
Sometimes you want side effects when you enable/diable and entity, like play an animation or
something.
# code
on_enable()
on_disable()
# text
FAQ
#

ursina
FAQ
# center, width 1000, arial
# size 5, bold
Frequently Asked Questions
# size 1, normal
# left
<b>How do I update ursina?</b>
# code
pip install https://github.com/pokepetter/ursina/archive/master.zip
# text
<b>How should I structure my project?</b>
Like this:
# code
project_folder/ # create a new folder for each project
enemies.py
level.py
main.py # the starting script
player.py
player_sprite.png
textures/ # assets can be placed alongside the scripts or in a folder
below
enemy_1.png
enemy_2.png
# text
<b>How do I move the camera?</b>
The camera is an Entity, so you can move and rotate it just like
everything else:
# code
camera.position = Vec3(1,1,0)
# text
<b>Why should I use Python for game development. Isn't it slow?</b>
Not really. The most performance critical part are written in C++ or
shader code.
Python can make you more productive as a developer and thus make it easier

to structure your project in a good way, rather than micro-optimize.
<b>How do I call a function with a delay?</b>
# code
invoke(some_function, arg1, kwarg1='some kwarg', delay=2)
# text
<b>How do I add lights?</b>
If all you want are some simple lights to make 3D shapes look more
interesting,
look at the program 'lights.py' in the samples folder. For anything more
complicated,
you are on your own. The DirectionalLight has shadows too, but it's
recommended to use the
lit_with_shadows_shader on entities. The shadow area will be calcualted
based on the scene bounds,
so keep that in mind when isinstanciation the light.
<b>How can I use panda3d alongside ursina?</b>
What you need to know is that Entity is a NodePath and Ursina is a
ShowBase.
You can also write custom shaders, see panda3d's shader documentation for
that.
<b>How do I detect collisions?</b>
One way is with raycasts. They can hit anything with a collider.
https://www.ursinaengine.org/cheat_sheet.html#raycaster
https://www.ursinaengine.org/cheat_sheet.html#HitInfo
https://www.ursinaengine.org/cheat_sheet.html#Collider
There's also intersects(), which use the entity's collider and check if it
intersects other colliders.
Like raycast(), it also returns a HitInfo.
Here's an example from the FirstPersonController:

# code
# cast a ray from the player position in the walk direction.
# only move forward if it doesn't hit anything.
origin = self.world_position + (self.up*.5) + (self.direction/2)
ray = raycast(origin , self.direction, ignore=[self,], distance=.25,
debug=False)
if not ray.hit:
self.position += self.direction * self.speed * time.dt
# text
# ursina FAQ
# center, width 1000, arial
# size 5, bold
Frequently Asked Questions
# size 1, normal
# left
<b>How do I update ursina?</b>
# code
pip install https://github.com/pokepetter/ursina/archive/master.zip
# text
<b>How should I structure my project?</b>
Like this:
# code
project_folder/
# create a new folder for each project
enemies.py
level.py
main.py
# the starting script
player.py
player_sprite.png
textures/
# assets can be placed alongside the scripts or in a folder below
enemy_1.png
enemy_2.png
# text
<b>How do I move the camera?</b>
The camera is an Entity, so you can move and rotate it just like everything else:
# code
camera.position = Vec3(1,1,0)
# text

<b>Why should I use Python for game development. Isn't it slow?</b>
Not really. The most performance critical part are written in C++ or shader code.
Python can make you more productive as a developer and thus make it easier
to structure your project in a good way, rather than micro-optimize.
<b>How do I call a function with a delay?</b>
# code
invoke(some_function, arg1, kwarg1='some kwarg', delay=2)
# text
<b>How do I add lights?</b>
If all you want are some simple lights to make 3D shapes look more interesting,
look at the program 'lights.py' in the samples folder. For anything more complicated,
you are on your own. The DirectionalLight has shadows too, but it's recommended to use the
lit_with_shadows_shader on entities. The shadow area will be calcualted based on the scene
bounds,
so keep that in mind when isinstanciation the light.
<b>How can I use panda3d alongside ursina?</b>
What you need to know is that Entity is a NodePath and Ursina is a ShowBase.
You can also write custom shaders, see panda3d's shader documentation for that.
<b>How do I detect collisions?</b>
One way is with raycasts. They can hit anything with a collider.
https://www.ursinaengine.org/cheat_sheet.html#raycaster
https://www.ursinaengine.org/cheat_sheet.html#HitInfo
https://www.ursinaengine.org/cheat_sheet.html#Collider
There's also intersects(), which use the entity's collider and check if it intersects other colliders.
Like raycast(), it also returns a HitInfo.
Here's an example from the FirstPersonController:
# code
# cast a ray from the player position in the walk direction.
# only move forward if it doesn't hit anything.
origin = self.world_position + (self.up*.5) + (self.direction/2)
ray = raycast(origin , self.direction, ignore=[self,], distance=.25, debug=False)

if not ray.hit:
self.position += self.direction * self.speed * time.dt
# text
Features
##
Programmer
Comfort
Powered by Python
* Clean pythonic syntax.
* Hackable.
* Access to the Python ecosystem.
* Fast Panda3d (C++) core.
3D
2D
UI
Asset Reloading
Code Reloading
Free and Open Source
Downsides
no physics
not well suited for big open world games
Use Blender as a Level Editor

## Programmer Comfort
Powered by Python
* Clean pythonic syntax.
* Hackable.
* Access to the Python ecosystem.
* Fast Panda3d (C++) core.
3D
2D
UI
Asset Reloading
Code Reloading
Free and Open Source
Downsides
no physics
not well suited for big open world games
Use Blender as a Level Editor
Index
# style a.button {background-color: #6b943a;} a.button:hover {background-color: #a9a33a}
# title ursina engine
# center, bold, arial, size 5, width 900
ursina engine
ʕ •ᴥ•ʔゝ□
# size 1.25, bold
# normal

open source game engine
# bold
# normal
[Download, #Getting Started] [Documentation, documentation.html]
<a href="https://github.com/pokepetter/ursina"><img src="icons/github_icon.png"></img></a>
<a href="https://twitter.com/ursinaengine"><img src="icons/twitter_icon.png"></img></a> <a
href="https://discord.gg/ydXfhyb"><img src="icons/discord_icon.png"></img></a> <a
href="https://www.patreon.com/ursinaengine"><img src="icons/patreon_icon.png"></img></a>
<iframe width="900" height="505" src="https://www.youtube-
nocookie.com/embed/j71j88oCTNo" frameborder="0" allow="accelerometer; autoplay; encrypted-
media; gyroscope; picture-in-picture" allowfullscreen></iframe>
# left
## Powered by Python
Ursina makes it easier to develop games, visualizations and other kinds of software.
The concise API combined with the power of the Python programming language,
makes life easier for the developer so they can focus on what they are making.
Things you won't miss from other game engines:
• Waiting for your code to compile
• The editor crashing and possibly losing your work
• Not being able to fix engine bugs or add features
• Overly verbose code
• Uncustomizable workflow
• Waiting for imports
• Long build times
• Revenue cut or subscription fee
## Useful Features
• Reload code/textures/models while in-game
• Automatic import of .psd and .blend files
• Play in fullscreen while developing
• Easy to use mesh class for making procedural geometry
• Lots of included procedural 3D primitives
## Platforms
• Windows
• Linux
## Free and Open Source
Licensed under the permissive MIT license,
you can use Ursina for whatever you want. No subscription fee, no revenue cut.

## Getting Started
# insert _getting_started.txt
## Dependencies
• python 3.6+
• panda3d
• screeninfo, for detecting screen resolution
• pillow, for texture manipulation
• psutil, for measuring memory usage (optional)
• hurry.filesize, for converting bytes to megabytes (optional)
• imageio, for recording and converting to gifs (optional)
• psd-tools3, for converting .psd files (optional)
• blender, for converting .blend files (optional)
Optional dependencies must be installed manually.
## Examples
Entity Example:
# code
from ursina import *
# import everything we need with one line.
app = Ursina()
ground = Entity(
model = 'cube',
color = color.magenta,
z = -.1,
y = -3,
origin = (0, .5),
scale = (50, 1, 10),
collider = 'box'
)
app.run()
# opens a window and starts the game.
# text
## How do I make a game?
Ursina games are made by writing Python code. You can use any text editor you want.
1) Create an empty .py file called 'ursina_game.py'
2) Copy this text into your new file:
# code
from ursina import *

app = Ursina()
player = Entity(model='cube', color=color.orange, scale_y=2)
def update(): # update gets automatically called.
player.x += held_keys['d'] * .1
player.x -= held_keys['a'] * .1
app.run() # opens a window and starts the game.
# text
3) Type this in the terminal to start the game. I recommend setting a hotkey
for this in your text editor:
# code
python ursina_game.py
# text
The game should start! You can now move the orange box around with 'a' and 'd'!
To close the window, you can by default, press shift+q or press the red x.
# left, size 2, bold
# image made_with_ursina.jpg
# size .75, center, normal
A variety of games made with Ursina
Installation
# arial, normal, size 1, width 1024
# bold, size 3
Installing ursina
# normal, size 1
# insert _getting_started.txt
3) If everything went well, you can go to the introduction tutorial where
we'll cover how to create a basic program and how to run it.
[Introduction Tutorial, introduction_tutorial.html]
## Troubleshooting
<b>ursina installed sucessfully, but python can't find it when I try to run a script</b>
If you're using a venv, make sure you're installing it to the venv and not to the default location.
Alternatively you can just not use a venv.
Introductory Tutorial (Introduction Tutorial)

[←Back,
documentation.html]
# arial, normal, size 1, width 1024
# bold, size 3
Introduction Tutorial
# normal, size 1
## Creating and running a game
1) Open your preferred text editor. If you're new to
programming, here are some suggestions:
* Atom
* Visual Studio Code
* Sublime Text
2)
Create a new folder for your project. This will contain
scripts and assets.
For ursina to find 3d models and textures, they should be in
the same folder or in
a folder below the starting script.
In this folder, create a new file called main.py. This will
contain out little game.
3) At the top of the file, write:
# code
from ursina import *
# text
This will import all the necessary things we need from the
engine in one line.
It means something like 'from ursina import all'. It's also
possible to import parts of the engine
like this:
# code
from ursina.prefabs import Button
# text
Or import something that's not included by default:
# code
from ursina.prefabs.first_person_controller import
FirstPersonController
# text
4) Here's a really basic example game with comments to

explain what were doing.
We will simply make a orange box move right and left when we
press 'd' or 'a'.
# code
from ursina import *
# create a window
app = Ursina()
# most things in ursina are Entities. An Entity is a thing
you place in the world.
# you can think of them as GameObjects in Unity or Actors in
Unreal.
# the first paramenter tells us the Entity's model will be a
3d-model called 'cube'.
# ursina includes some basic models like 'cube', 'sphere' and
'quad'.
# the next parameter tells us the model's color should be
orange.
# 'scale_y=2' tells us how big the entity should be in the
vertical axis, how tall it should be.
# in ursina, positive x is right, positive y is up, and
positive z is forward.
player = Entity(model='cube', color=color.orange, scale_y=2)
# create a function called 'update'.
# this will automatically get called by the engine every
frame.
def update():
player.x += held_keys['d'] * time.dt
player.x -= held_keys['a'] * time.dt
# this part will make the player move left or right based on
our input.
# to check which keys are held down, we can check the
held_keys dictionary.
# 0 means not pressed and 1 means pressed.
# time.dt is simply the time since the last frame. by
multiplying with this, the
# player will move at the same speed regardless of how fast
the game runs.
def input(key):

if key == 'space':
player.y += 1
invoke(setattr, player, 'y', player.y-1, delay=.25)
# start running the game
app.run()
# text
5) Now we have to tell Python to run the script. To do this,
open the command line and
go to the current folder. An easy way to do this is to type
'cmd' in the address bar.
Run the command below.
# code
python main.py
# text
An alternative is to install the 'atom-python-run' package in
Atom so you can start
the game by pressing F5.
[←Back, documentation.html]
# arial, normal, size 1, width 1024
# bold, size 3
Introduction Tutorial
# normal, size 1
## Creating and running a game
1) Open your preferred text editor. If you're new to programming, here are some suggestions:
* Atom
* Visual Studio Code
* Sublime Text
2)
Create a new folder for your project. This will contain scripts and assets.
For ursina to find 3d models and textures, they should be in the same folder or in
a folder below the starting script.
In this folder, create a new file called main.py. This will contain out little game.
3) At the top of the file, write:
# code
from ursina import *
# text
This will import all the necessary things we need from the engine in one line.
It means something like 'from ursina import all'. It's also possible to import parts of the engine

like this:
# code
from ursina.prefabs import Button
# text
Or import something that's not included by default:
# code
from ursina.prefabs.first_person_controller import FirstPersonController
# text
4) Here's a really basic example game with comments to explain what were doing.
We will simply make a orange box move right and left when we press 'd' or 'a'.
# code
from ursina import *
# create a window
app = Ursina()
# most things in ursina are Entities. An Entity is a thing you place in the world.
# you can think of them as GameObjects in Unity or Actors in Unreal.
# the first paramenter tells us the Entity's model will be a 3d-model called 'cube'.
# ursina includes some basic models like 'cube', 'sphere' and 'quad'.
# the next parameter tells us the model's color should be orange.
# 'scale_y=2' tells us how big the entity should be in the vertical axis, how tall it should be.
# in ursina, positive x is right, positive y is up, and positive z is forward.
player = Entity(model='cube', color=color.orange, scale_y=2)
# create a function called 'update'.
# this will automatically get called by the engine every frame.
def update():
player.x += held_keys['d'] * time.dt
player.x -= held_keys['a'] * time.dt
# this part will make the player move left or right based on our input.
# to check which keys are held down, we can check the held_keys dictionary.
# 0 means not pressed and 1 means pressed.
# time.dt is simply the time since the last frame. by multiplying with this, the
# player will move at the same speed regardless of how fast the game runs.
def input(key):
if key == 'space':
player.y += 1
invoke(setattr, player, 'y', player.y-1, delay=.25)
# start running the game
app.run()
# text

5) Now we have to tell Python to run the script. To do this, open the command line and
go to the current folder. An easy way to do this is to type 'cmd' in the address bar.
Run the command below.
# code
python main.py
# text
An alternative is to install the 'atom-python-run' package in Atom so you can start
the game by pressing F5.
Inventory Tutorial
#
center,
width
1000,
arial
# size 5, bold
Inventory Tutorial
# size 1, normal
In this tutorial we will make a drag and drop inventory like this.
# image inventory_2.gif
# left
## 1 Setting up the class
Let's begin by making an Inventory class
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__()
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
app.run()
# text
## 2 Adding graphics

However, if we run the code, we'll see that there's nothing visible.
Let's parent it to the ui and set the model to 'quad', an included model.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui, # +
model = 'quad' # +
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
app.run()
# text
If we look at it now, we see it's a white square in the middle of the
screen.
Let's set it to a nicer shape. We also want (0,0) to be in the upper left
corner
because it makes it easier to add items later. Let's also give it a
texture and a color.
If we have both, the color value will tint the texture.
Now, this is nice and all, but wouldn't it be nice to show a grid as
well?
There are multiple way to do that, but in this case, we'll simply make
the texture repeat
by setting texture_scale to (5,6). That'll nicely fit the size of our
inventory.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8), # +
origin = (-.5, .5), # +
position = (-.3,.4), # +
texture = 'white_cube', # +
texture_scale = (5,8), # +

color = color.dark_gray # +
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
app.run()
# text
## 3 Adding placeholder items
Let's try to add some items to the inventory.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
item = Button(parent=inventory, color=color.red, position=(0,0)) # +
item = Button(parent=inventory, color=color.green, position=(2,0)) # +
app.run()
# text
Well, that didn't go as planned. The items cover the entire inventory and
the second item is way off to the left.
Let's fix this by making another object to put the items under.
Scale the object to the size of an item.
They also don't fit the grid. Fix that by setting origin to the upper
left

corner, (-.5,.5).
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
self.item_parent = Entity(parent=self, scale=(1/5,1/8)) # +
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
item = Button(parent=inventory.item_parent, origin=(-.5,.5),
color=color.red, position=(0,0)) # +
item = Button(parent=inventory.item_parent, origin=(-.5,.5),
color=color.green, position=(2,0)) # +
app.run()
# text
## 4 Adding items
We've added some items manually to make sure they get the right scale and
position,
but we should make an append() function so it's easy to add items.
Let's start by making a function called 'append()' and make it spawn an
item
when we send it a string. We'll also set the button's text to the string
we
receive so we can differentiate them.
Let's give them a random color too, why not.
Lastly, let's call inventory.append('test item') a couple of times to
make sure it works.

# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
self.item_parent = Entity(parent=self, scale=(1/5,1/8))
def append(self, item): # +
Button( # +
parent = inventory.item_parent, # +
model = 'quad', # +
origin = (-.5,.5), # +
color = color.random_color(), # +
z = -.1 # +
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
inventory.append('test item') # +
inventory.append('test item') # +
app.run()
# text
## 5 Find a free slot in the inventory
The items gets added, but they overlap. We need to find the first open
slot in the inventory
and place the item there. We can to this by checking each grid position
and see if any
if the items occupy that position already.
# code
from ursina import *

class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
self.item_parent = Entity(parent=self, scale=(1/5,1/8))
def find_free_spot(self): # +
taken_spots = [(int(e.x), int(e.y)) for e in self.item_parent.children] #
+
for y in range(8): # +
for x in range(5): # +
if not (x,-y) in taken_spots: # +
return (x,-y) # +
def append(self, item):
Button(
parent = inventory.item_parent,
model = 'quad',
origin = (-.5,.5),
color = color.random_color(),
position = self.find_free_spot(), # +
z = -.1
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
for i in range(7): # +
inventory.append('test item') # +
app.run()
# text
## 6 Add random item button
Make a button to add a random item to the inventory. This is not part of

the inventory itself,
but it's useful in order to test it.
Assign the button's 'on_click' to a function, and it will call that
function when we click it.
button.on_click = inventory
Let's make an tuple with those and make the button choose a random item
from the tuple
using random.choice(items)
# code
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
def add_item(): # +
inventory.append(random.choice(('bag', 'bow_arrow', 'gem', 'orb',
'sword'))) # +
for i in range(7): # +
add_item() # +
add_item_button = Button( # +
scale = (.1,.1), # +
x = -.5, # +
color = color.lime.tint(-.25), # +
text = '+', # +
tooltip = Tooltip('Add random item'), # +
on_click = add_item # +
) # +
app.run()
# text
## 7 Adding textures and hover text
To add textures, just set texture=item and it will try to find a
texture with that name. It searches first in the project's assets and
then
in the assets included with ursina. I've included some icons for the
purpose
if this tutorial, but feel free to add your own.
Let's also remove the random color and instead show the item's name when
we hover it with the mouse.
If a button has 'tooltip' set to something, it will show it when we hover
the Button.

# code
def append(self, item):
icon = Button( # +
parent = inventory.item_parent,
model = 'quad',
texture = item, # +
color = color.white, # +
origin = (-.5,.5),
position = self.find_free_spot(),
z = -.1,
)
name = item.replace('_', ' ').title() # +
icon.tooltip = Tooltip(name) # +
icon.tooltip.background.color = color.color(0,0,0,.8) # +
# text
## 8 Drag n' drop
We can't move the items! That's not fun.
However, that's easy to change. Just spawn a Draggable instead of Button.
Draggable inherits from Button, so the tooltips will still work!
# code
def append(self, item):
icon = Draggable( # +
parent = inventory.item_parent,
model = 'quad',
texture = item,
color = color.white,
origin = (-.5,.5),
position = self.find_free_spot(),
z = -.1,
)
name = item.replace('_', ' ').title()
icon.tooltip = Tooltip(name)
icon.tooltip.background.color = color.color(0,0,0,.8)
# text
## 9 Snap to grid on_drop
The items can be moved now, but they don't follow the grid.
Let's round the position when we drop it.
Draggable's will automatically call on_drag() and on_drop() if has them.

round the position on drop
# code
def append(self, item):
icon = Draggable(
parent = inventory.item_parent,
model = 'quad',
texture = item,
color = color.white,
origin = (-.5,.5),
position = self.find_free_spot(),
z = -.1,
)
name = item.replace('_', ' ').title()
icon.tooltip = Tooltip(name)
icon.tooltip.background.color = color.color(0,0,0,.8)
def drop(): # +
icon.x = int(icon.x) # +
icon.y = int(icon.y) # +
icon.drop = drop # +
# text
## 10 Swap items
Add a drag function to remember the start position as org_pos.
# code
def drag(): # +
icon.org_pos = (icon.x, icon.y) # +
def drop():
icon.x = int(icon.x)
icon.y = int(icon.y)
'''if the spot is taken, swap positions'''
for c in self.children: # +
if c == icon: # +
continue # +
if c.x == icon.x and c.y == icon.y: # +
print('swap positions') # +
c.position = icon.org_pos # +

icon.drag = drag # +
icon.drop = drop
# text
## 11 Stay inside the inventory, please
We shouldn't be able to drop the items outside of the inventory.
# code
def drop():
icon.x = int(icon.x)
icon.y = int(icon.y)
'''if outside, return to original position''' # +
if icon.x < 0 or icon.x >= 1 or icon.y > 0 or icon.y <= -1: # +
icon.position = (icon.org_pos) # +
return # +
'''if the spot is taken, swap positions'''
for c in self.children:
if c == icon:
continue
if c.x == icon.x and c.y == icon.y:
print('swap positions')
c.position = icon.org_pos
icon.drop = drop
# text
## 12 Bugfix: Make the dragged items render on top
All the items are at the same depth, so it hard to say how they will
overlap.
It feels natural that the item we're currently dragging stays on top,
so we'll move it back a bit when we drag it and forward when we drop it.
# code
def drag():
icon.org_pos = (icon.x, icon.y)
icon.z -= .01 # ensure the dragged item overlaps the rest # +
def drop():
icon.x = int(icon.x)

icon.y = int(icon.y)
icon.z += .01 # +
'''if outside, return to original position'''
if icon.x < 0 or icon.x >= 1 or icon.y > 0 or icon.y <= -1:
icon.position = (icon.org_pos)
return
'''if the spot is taken, swap positions'''
for c in self.children:
if c == icon:
continue
if c.x == icon.x and c.y == icon.y:
print('swap positions')
c.position = icon.org_pos
icon.drag = drag
icon.drop = drop
# text
# center, width 1000, arial
# size 5, bold
Inventory Tutorial
# size 1, normal
In this tutorial we will make a drag and drop inventory like this.
# image inventory_2.gif
# left
## 1 Setting up the class
Let's begin by making an Inventory class
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__()
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
app.run()
# text

## 2 Adding graphics
However, if we run the code, we'll see that there's nothing visible.
Let's parent it to the ui and set the model to 'quad', an included model.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
# +
model = 'quad'
# +
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
app.run()
# text
If we look at it now, we see it's a white square in the middle of the screen.
Let's set it to a nicer shape. We also want (0,0) to be in the upper left corner
because it makes it easier to add items later. Let's also give it a texture and a color.
If we have both, the color value will tint the texture.
Now, this is nice and all, but wouldn't it be nice to show a grid as well?
There are multiple way to do that, but in this case, we'll simply make the texture repeat
by setting texture_scale to (5,6). That'll nicely fit the size of our inventory.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
# +
origin = (-.5, .5),
# +
position = (-.3,.4),
# +
texture = 'white_cube',
# +
texture_scale = (5,8),
# +
color = color.dark_gray
# +
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
app.run()
# text

## 3 Adding placeholder items
Let's try to add some items to the inventory.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
item = Button(parent=inventory, color=color.red, position=(0,0))
# +
item = Button(parent=inventory, color=color.green, position=(2,0))
# +
app.run()
# text
Well, that didn't go as planned. The items cover the entire inventory and
the second item is way off to the left.
Let's fix this by making another object to put the items under.
Scale the object to the size of an item.
They also don't fit the grid. Fix that by setting origin to the upper left
corner, (-.5,.5).
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
self.item_parent = Entity(parent=self, scale=(1/5,1/8))
# +

if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
item = Button(parent=inventory.item_parent, origin=(-.5,.5), color=color.red, position=(0,0))
# +
item = Button(parent=inventory.item_parent, origin=(-.5,.5), color=color.green,
position=(2,0))
# +
app.run()
# text
## 4 Adding items
We've added some items manually to make sure they get the right scale and position,
but we should make an append() function so it's easy to add items.
Let's start by making a function called 'append()' and make it spawn an item
when we send it a string. We'll also set the button's text to the string we
receive so we can differentiate them.
Let's give them a random color too, why not.
Lastly, let's call inventory.append('test item') a couple of times to make sure it works.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
self.item_parent = Entity(parent=self, scale=(1/5,1/8))
def append(self, item):
# +
Button(
# +
parent = inventory.item_parent,
# +
model = 'quad',
# +
origin = (-.5,.5),
# +
color = color.random_color(),
# +
z = -.1
# +
)

if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
inventory.append('test item')
# +
inventory.append('test item')
# +
app.run()
# text
## 5 Find a free slot in the inventory
The items gets added, but they overlap. We need to find the first open slot in the inventory
and place the item there. We can to this by checking each grid position and see if any
if the items occupy that position already.
# code
from ursina import *
class Inventory(Entity):
def __init__(self):
super().__init__(
parent = camera.ui,
model = 'quad',
scale = (.5, .8),
origin = (-.5, .5),
position = (-.3,.4),
texture = 'white_cube',
texture_scale = (5,8),
color = color.dark_gray
)
self.item_parent = Entity(parent=self, scale=(1/5,1/8))
def find_free_spot(self):
# +
taken_spots = [(int(e.x), int(e.y)) for e in self.item_parent.children]
# +
for y in range(8):
# +
for x in range(5):
# +
if not (x,-y) in taken_spots:
# +
return (x,-y)
# +
def append(self, item):
Button(
parent = inventory.item_parent,
model = 'quad',
origin = (-.5,.5),
color = color.random_color(),
position = self.find_free_spot(),
# +
z = -.1
)
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()

for i in range(7):
# +
inventory.append('test item')
# +
app.run()
# text
## 6 Add random item button
Make a button to add a random item to the inventory. This is not part of the inventory itself,
but it's useful in order to test it.
Assign the button's 'on_click' to a function, and it will call that function when we click it.
button.on_click = inventory
Let's make an tuple with those and make the button choose a random item from the tuple
using random.choice(items)
# code
if __name__ == '__main__':
app = Ursina()
inventory = Inventory()
def add_item():
# +
inventory.append(random.choice(('bag', 'bow_arrow', 'gem', 'orb', 'sword'))) # +
for i in range(7):
# +
add_item()
# +
add_item_button = Button(
# +
scale = (.1,.1),
# +
x = -.5,
# +
color = color.lime.tint(-.25),
# +
text = '+',
# +
tooltip = Tooltip('Add random item'),
# +
on_click = add_item
# +
)
# +
app.run()
# text
## 7 Adding textures and hover text
To add textures, just set texture=item and it will try to find a
texture with that name. It searches first in the project's assets and then
in the assets included with ursina. I've included some icons for the purpose
if this tutorial, but feel free to add your own.
Let's also remove the random color and instead show the item's name when we hover it with the
mouse.
If a button has 'tooltip' set to something, it will show it when we hover the Button.
# code
def append(self, item):
icon = Button(
# +

parent = inventory.item_parent,
model = 'quad',
texture = item,
# +
color = color.white,
# +
origin = (-.5,.5),
position = self.find_free_spot(),
z = -.1,
)
name = item.replace('_', ' ').title()
# +
icon.tooltip = Tooltip(name)
# +
icon.tooltip.background.color = color.color(0,0,0,.8)
# +
# text
## 8 Drag n' drop
We can't move the items! That's not fun.
However, that's easy to change. Just spawn a Draggable instead of Button.
Draggable inherits from Button, so the tooltips will still work!
# code
def append(self, item):
icon = Draggable(
# +
parent = inventory.item_parent,
model = 'quad',
texture = item,
color = color.white,
origin = (-.5,.5),
position = self.find_free_spot(),
z = -.1,
)
name = item.replace('_', ' ').title()
icon.tooltip = Tooltip(name)
icon.tooltip.background.color = color.color(0,0,0,.8)
# text
## 9 Snap to grid on_drop
The items can be moved now, but they don't follow the grid.
Let's round the position when we drop it.
Draggable's will automatically call on_drag() and on_drop() if has them.
round the position on drop
# code
def append(self, item):
icon = Draggable(
parent = inventory.item_parent,
model = 'quad',
texture = item,
color = color.white,
origin = (-.5,.5),

position = self.find_free_spot(),
z = -.1,
)
name = item.replace('_', ' ').title()
icon.tooltip = Tooltip(name)
icon.tooltip.background.color = color.color(0,0,0,.8)
def drop():
# +
icon.x = int(icon.x)
# +
icon.y = int(icon.y)
# +
icon.drop = drop
# +
# text
## 10 Swap items
Add a drag function to remember the start position as org_pos.
# code
def drag():
# +
icon.org_pos = (icon.x, icon.y)
# +
def drop():
icon.x = int(icon.x)
icon.y = int(icon.y)
'''if the spot is taken, swap positions'''
for c in self.children:
# +
if c == icon:
# +
continue
# +
if c.x == icon.x and c.y == icon.y:
# +
print('swap positions')
# +
c.position = icon.org_pos
# +
icon.drag = drag
# +
icon.drop = drop
# text
## 11 Stay inside the inventory, please
We shouldn't be able to drop the items outside of the inventory.
# code
def drop():
icon.x = int(icon.x)
icon.y = int(icon.y)

'''if outside, return to original position'''
# +
if icon.x < 0 or icon.x >= 1 or icon.y > 0 or icon.y <= -1: # +
icon.position = (icon.org_pos)
# +
return
# +
'''if the spot is taken, swap positions'''
for c in self.children:
if c == icon:
continue
if c.x == icon.x and c.y == icon.y:
print('swap positions')
c.position = icon.org_pos
icon.drop = drop
# text
## 12 Bugfix: Make the dragged items render on top
All the items are at the same depth, so it hard to say how they will overlap.
It feels natural that the item we're currently dragging stays on top,
so we'll move it back a bit when we drag it and forward when we drop it.
# code
def drag():
icon.org_pos = (icon.x, icon.y)
icon.z -= .01 # ensure the dragged item overlaps the rest # +
def drop():
icon.x = int(icon.x)
icon.y = int(icon.y)
icon.z += .01
# +
'''if outside, return to original position'''
if icon.x < 0 or icon.x >= 1 or icon.y > 0 or icon.y <= -1:
icon.position = (icon.org_pos)
return
'''if the spot is taken, swap positions'''
for c in self.children:
if c == icon:
continue
if c.x == icon.x and c.y == icon.y:
print('swap positions')
c.position = icon.org_pos
icon.drag = drag
icon.drop = drop
# text

Platformer Tutorial dot py
# Start
by
importi
ng
ursina
and
creatin
g a
window.
from ursina import *
app = Ursina()
# ## Using the built in platformer controller
#
# A simple way to get stared is to use the built in platformer
controller.
# It's pretty basic, so you might want to write your own at a later
point.
# It is however a good starting point, so let's import it like this:
from ursina.prefabs.platformer_controller_2d import
PlatformerController2d
player = PlatformerController2d(y=1, z=.01, scale_y=1, max_jumps=2)
# You can change settings like jump_height, walk_speed, and gravity.
# If you want to larn more about how it works you can read its code here:
#
https://github.com/pokepetter/ursina/blob/master/ursina/prefabs/platforme
r_controller_2d.py
#
# If we try to play the game right now, you'll fall for all infinity, so
let's add a ground:
ground = Entity(model='quad', scale_x=10, collider='box',
color=color.black)
# ## Making a "level editor"
#
# Now, it works, but it's a pretty boring game, so let's make a more
interesting level.
# There are many ways to go about making a level, but for this we'll make
an image
# where we can simply draw the level and then generate a level based on
that.
#
# # image platformer_tutorial_level.png
#

#
#
# To generate the level we'll loop through all the pixels in the image
above and do
# something based on the color of the pixel. Make sure to save this image
to same
# folder or below as your script.
#
# If it's white, it's air, so we'll skip it.
level_parent = Entity()
def make_level(texture):
# destroy every child of the level parent.
# This doesn't do anything the first time the level is generated, but if
we want to update it several times
# this will ensure it doesn't just create a bunch of overlapping
entities.
[destroy(c) for c in level_parent.children]
for y in range(texture.height):
collider = None
for x in range(texture.width):
col = texture.get_pixel(x,y)
# If it's black, it's solid, so we'll place a tile there.
if col == color.black:
Entity(parent=level_parent, position=(x,y), model='cube', origin=(-.5,-
.5), color=color.gray, texture='white_cube', visible=True)
if not collider:
collider = Entity(parent=level_parent, position=(x,y), model='quad',
origin=(-.5,-.5), collider='box', visible=False)
else:
# instead of creating a new collider per tile, stretch the previous
collider right.
collider.scale_x += 1
else:
collider = None
# If it's green, we'll place the player there. Store this in
player.start_position so we can reset the plater position later.
if col == color.green:
player.start_position = (x, y)
player.position = player.start_position
make_level(load_texture('platformer_tutorial_level')) # generate the
level
# ## Positioning the camera
#

# Set the camera to orthographic so there's no perspective.
# Move the camera to the middle of the level and set the fov so the level
fits nicely.
# Setting the fov on an orthographic camera means setting how many units
vertically the camera can see.
camera.orthographic = True
camera.position = (30/2,8)
camera.fov = 16
# ## Adding player graphics and animations
#
# Loads an image sequence as a frame animation.
# So if you have some frames named image_000.png, image_001.png,
image_002.png and so on,
# you can load it like this: Animation('image')
# You can also load a .gif by including the file type:
Animation('image.gif')
# player.walk_animation = Animation('player_walk')
# the platformer controller has an Animator and will toggle the state
based on
# whether it's standing still, is walking or is jumping.
# All the Animator does is to make sure only one Animation is enabled at
the same time.
# Otherwise they would overlap.
# self.animator = Animator({'idle' : None, 'walk' : None, 'jump' : None})
player.traverse_target = level_parent
enemy = Entity(model='cube', collider='box', color=color.red,
position=(16,5,-.1))
def update():
if player.intersects(enemy).hit:
print('die')
player.position = player.start_position
# ## Start the game
#
app.run()
# ## Adding level graphics
#
# Coming later
pass
# Start by importing ursina and creating a window.
from ursina import *
app = Ursina()
# ## Using the built in platformer controller

#
# A simple way to get stared is to use the built in platformer controller.
# It's pretty basic, so you might want to write your own at a later point.
# It is however a good starting point, so let's import it like this:
from ursina.prefabs.platformer_controller_2d import PlatformerController2d
player = PlatformerController2d(y=1, z=.01, scale_y=1, max_jumps=2)
# You can change settings like jump_height, walk_speed, and gravity.
# If you want to larn more about how it works you can read its code here:
# https://github.com/pokepetter/ursina/blob/master/ursina/prefabs/platformer_controller_2d.py
#
# If we try to play the game right now, you'll fall for all infinity, so let's add a ground:
ground = Entity(model='quad', scale_x=10, collider='box', color=color.black)
# ## Making a "level editor"
#
# Now, it works, but it's a pretty boring game, so let's make a more interesting level.
# There are many ways to go about making a level, but for this we'll make an image
# where we can simply draw the level and then generate a level based on that.
#
# # image platformer_tutorial_level.png
#
#
#
# To generate the level we'll loop through all the pixels in the image above and do
# something based on the color of the pixel. Make sure to save this image to same
# folder or below as your script.
#
# If it's white, it's air, so we'll skip it.
level_parent = Entity()
def make_level(texture):
# destroy every child of the level parent.
# This doesn't do anything the first time the level is generated, but if we want to update it several
times
# this will ensure it doesn't just create a bunch of overlapping entities.
[destroy(c) for c in level_parent.children]
for y in range(texture.height):
collider = None
for x in range(texture.width):
col = texture.get_pixel(x,y)
# If it's black, it's solid, so we'll place a tile there.
if col == color.black:
Entity(parent=level_parent, position=(x,y), model='cube', origin=(-.5,-.5), color=color.gray,
texture='white_cube', visible=True)
if not collider:
collider = Entity(parent=level_parent, position=(x,y), model='quad', origin=(-.5,-.5),
collider='box', visible=False)
else:
# instead of creating a new collider per tile, stretch the previous collider right.
collider.scale_x += 1
else:
collider = None
# If it's green, we'll place the player there. Store this in player.start_position so we can reset
the plater position later.

if col == color.green:
player.start_position = (x, y)
player.position = player.start_position
make_level(load_texture('platformer_tutorial_level')) # generate the level
# ## Positioning the camera
#
# Set the camera to orthographic so there's no perspective.
# Move the camera to the middle of the level and set the fov so the level fits nicely.
# Setting the fov on an orthographic camera means setting how many units vertically the camera
can see.
camera.orthographic = True
camera.position = (30/2,8)
camera.fov = 16
# ## Adding player graphics and animations
#
# Loads an image sequence as a frame animation.
# So if you have some frames named image_000.png, image_001.png, image_002.png and so on,
# you can load it like this: Animation('image')
# You can also load a .gif by including the file type: Animation('image.gif')
# player.walk_animation = Animation('player_walk')
# the platformer controller has an Animator and will toggle the state based on
# whether it's standing still, is walking or is jumping.
# All the Animator does is to make sure only one Animation is enabled at the same time.
# Otherwise they would overlap.
# self.animator = Animator({'idle' : None, 'walk' : None, 'jump' : None})
player.traverse_target = level_parent
enemy = Entity(model='cube', collider='box', color=color.red, position=(16,5,-.1))
def update():
if player.intersects(enemy).hit:
print('die')
player.position = player.start_position
# ## Start the game
#
app.run()
# ## Adding level graphics
#
# Coming later
Pass

Tutorial Generator
from
pathlib
import
Path
files = [
Path('platformer_tutorial.py'),
]
for path in files:
code_parts = []
comment_parts = []
with open(path, encoding='utf8') as f:
comment_block = []
code_block = []
is_comment_block = False
lines = f.readlines()
y = 0 # track the nujmber for non-commented lines
for i, line in enumerate(lines):
if line.startswith('#'):
if not is_comment_block:
is_comment_block = True
elif code_block:
# print('--------------------end code block and add it to the list')
code_parts.append((y, ''.join(code_block)))
y += len(code_block)
code_block = []
if is_comment_block and not line.startswith('#'):
is_comment_block = False
comment_parts.append(''.join([l.lstrip('#').lstrip() for l in
comment_block]))
comment_block = []
if is_comment_block:
comment_block.append(line)
else:
# elif i > 0 and not lines[i-1].startswith('#'):
print('add:', line[:-1])
code_block.append(line)
# code_without_comments.append(line)
# code_without_comments = ''.join(code_without_comments)
print('code:', code_parts)

print('comments:', comment_parts)
print('converted:', path)
text = f'''
[←Back, documentation.html]
# arial, normal, size 1, width 1250
# center, bold, size 4
{path.stem.title().replace('_',' ')}
# left, size 1, normal\n\n\n
'''
for i, (comment, code) in enumerate(zip(comment_parts, code_parts)):
# text += f'## {i}\n'
text += comment
text += '\n# code\n'
text += code[1].rstrip()
text += '\n# text\n\n'
text += '## Result\n'
text += '# code\n'
text += ''.join([e[1] for e in code_parts])
text += '\n# text'
with open(f'{path.stem}.txt', 'w', encoding='utf-8') as text_file:
text_file.write(text)
# # left 300
# # code
# {code_without_comments}
# # text
# '''
#
# )
# from ursina import *
# app = Ursina()
# window.color = color._32
#
# text_parent = Entity(parent=camera.ui, position=(-.6,.25), scale=.85)
# # texts = []
# # for (line_number, content) in code_parts:
# # print(line_number, content)
# # texts.append(Text(content, enabled=False))
# comment = Text(scale=.85)
#
# i = 0
# def input(key):
# global i
# if key == 'space' and i < len(code_parts):

# print('----------', code_parts[i][0])
# # text.text += code_parts[i][1]
# height = len(code_parts[i-1][1]) * Text.size * .025
# text = Text(code_parts[i][1], parent=text_parent, y=-code_parts[i][0] *
Text.size)
# # text.y += len(code_parts[i-1][1]) * Text.size * .025
# text_parent.animate('y', text_parent.y + height, curve=curve.linear,
delay=.25, duration=.25)
# text.appear()
#
# comment.text = comment_parts[i]
#
# i += 1
#
# Sprite('ursina_wink_0000', parent=camera.ui, x=.5, y=-.4, scale=.2)
#
# app.run()
from pathlib import Path
files = [
Path('platformer_tutorial.py'),
]
for path in files:
code_parts = []
comment_parts = []
with open(path, encoding='utf8') as f:
comment_block = []
code_block = []
is_comment_block = False
lines = f.readlines()
y = 0 # track the nujmber for non-commented lines
for i, line in enumerate(lines):
if line.startswith('#'):
if not is_comment_block:
is_comment_block = True
elif code_block:
# print('--------------------end code block and add it to the list')
code_parts.append((y, ''.join(code_block)))
y += len(code_block)
code_block = []
if is_comment_block and not line.startswith('#'):
is_comment_block = False
comment_parts.append(''.join([l.lstrip('#').lstrip() for l in comment_block]))
comment_block = []
if is_comment_block:
comment_block.append(line)
else:

# elif i > 0 and not lines[i-1].startswith('#'):
print('add:', line[:-1])
code_block.append(line)
# code_without_comments.append(line)
# code_without_comments = ''.join(code_without_comments)
print('code:', code_parts)
print('comments:', comment_parts)
print('converted:', path)
text = f'''
[←Back, documentation.html]
# arial, normal, size 1, width 1250
# center, bold, size 4
{path.stem.title().replace('_',' ')}
# left, size 1, normal\n\n\n
'''
for i, (comment, code) in enumerate(zip(comment_parts, code_parts)):
# text += f'## {i}\n'
text += comment
text += '\n# code\n'
text += code[1].rstrip()
text += '\n# text\n\n'
text += '## Result\n'
text += '# code\n'
text += ''.join([e[1] for e in code_parts])
text += '\n# text'
with open(f'{path.stem}.txt', 'w', encoding='utf-8') as text_file:
text_file.write(text)
# # left 300
# # code
# {code_without_comments}
# # text
# '''
#
#
)
# from ursina import *
# app = Ursina()
# window.color = color._32
#
# text_parent = Entity(parent=camera.ui, position=(-.6,.25), scale=.85)
# # texts = []
# # for (line_number, content) in code_parts:
# #
print(line_number, content)
#
# texts.append(Text(content, enabled=False))
# comment = Text(scale=.85)
#
# i = 0
# def input(key):
#
global i
#
if key == 'space' and i < len(code_parts):
#
print('----------', code_parts[i][0])
#
# text.text += code_parts[i][1]

#
height = len(code_parts[i-1][1]) * Text.size * .025
#
text = Text(code_parts[i][1], parent=text_parent, y=-code_parts[i][0] * Text.size)
#
# text.y += len(code_parts[i-1][1]) * Text.size * .025
#
text_parent.animate('y', text_parent.y + height, curve=curve.linear, delay=.25, duration=.25)
#
text.appear()
#
#
comment.text = comment_parts[i]
#
#
i += 1
#
# Sprite('ursina_wink_0000', parent=camera.ui, x=.5, y=-.4, scale=.2)
#
# app.run()
Ursina_for_dummies.txt (will change name soon, this is what it was labelled.)
#
center,
width
900,
arial
# size 5, bold
Ursina Game Engine Tutorial for Dummies
# size 1, normal, left
## Summary
This is a tutorial that explains you how to setup your environment,
create a window and render a coloured cube with really simple controls.
A passing knowledge in Python is beneficial but not required, this
tutorial assumes you have no idea what you are doing at all.
Once you finish this tutorial you are expected to know:
- How to setup Python in any computer.
- How to install a python library
- Select your IDE
- Write a program
- Execute a program
- Create and destroy a graphics window using Ursina
- Draw a simple mesh
- Control the mesh using the keyboard.
- Hierarchies
- Texturing
- Texture animations
- Alpha blending
- Mouse collisons
- Text and UI

## Introduction
So you want to write your own game, sell it by tons and get rich and
famous? Then you are on the right track, but let me be straight and tell
you this is not going to happen anytime soon. Many people writing games
in big companies started somewhere and to get to the top you need to
understand the basics and that is exactly why you are here, so consider
this tutorial as the stepping stone into the game development industry.
Ursina is a Python wrapper around the Panda3D game engine, as such Python
is used to control every aspect of the engine from the initialisation,
rendering, game control, playing sounds and shutdown, therefore you will
need to build up your Python skills. Python has become one of the most
used and well respected scripting languages and plenty of companies and
game development studios use Python to automate many functions so this is
a fantastic tool to have in your belt.
Panda3D is an Open Source game engine created by Disney and still used
for production development. Panda3D already has a Python wrapper, but
Ursina enhances the engine making it seamless to work across platforms
and providing tools that make the development experience much more
comfortable.
Before we start, keep in mind the engine has a reference page here
https://www.ursinaengine.org/cheat_sheet.html in case you want to check
even more options.
## Install Python3
If you are ready to start writing your game, you need to get your
computer ready and the first step is to install Python3.6. Python is an
universal language so it is available for most operating systems. Please
follow these instructions to install it in your computer.
https://docs.python-guide.org/
https://docs.python-guide.org/starting/install3/osx
https://docs.python-guide.org/starting/install3/win
https://docs.python-guide.org/starting/install3/linux
Once done, you should be able to run:
# code
python3 --version
Python 3.7.4
# text

## Setup a virtual environment (venv) (optional)
A Python virtual environment or venv is the way Python maintains a
private space for the libraries you need for a project. You can have any
number of virtual environments in your computer and be sure all libraries
installed in one venv does not mix with libraries in the other venv so
for example you may create a "gamedev" venv and install all your game
development libraries, then create a "science" venv and install libraries
for number crunching, then create another called "music" and install all
your libraries you need to work with sound files. You may even install
multiple versions of the same libraries on each venv and be sure they
don't mix. Once you are done with a venv (or maybe it becomes too large
because you have been installing too many things) you can delete the venv
and recreate it from scratch.
## Installing the Ursina game engine
To install Ursina we need to use pip, the Python package manager.
Jump into your venv:
# code
source gamedev/bin/activate
# text
Now install the engine:
# code
pip install ursina
# text
This will download and setup ursina and other libraries required by the
engine. If you want to see which libraries are installed run:
# code
pip list
# text
You will see some libraries like Panda3d in there.
Now let me show why Python is so popular. Python has tons of other
libraries available and all of them are located in a repository called
the Python Package index or PyPI (https://pypi.org). There are hundreds
of thousands of libraries available for almost anything you may need and
they are organised and searchable. So for example you need a library to
work your sound files, you may run:
# code
pip search sound
# text
Or maybe you need to read a YAML file (yaml), or machine learning (ml),
or cover image formats. Just run a pip search and you will get something.

So lets say you want the "playsound" library installed. Run:
# code
pip install playsound
# text
Of course, we don't really need this library because ursina can play
sound as well. This is just an example.
Once you are done with this library run:
# code
pip uninstall playsound
# text
## Installing an IDE
This is a tricky one. There are plenty programming IDEs available and its
all a matter of choice. Essentially you may code in command line but
installing a nice IDE will help you be more effective. Some options:
- Sublime Text
- Atom
- PyCharm
- Visual Studio Code
- Notepad++
- Eclipse
Sublime is a good choice for a beginner as it is very lightweight (and
I'm writing this tutorial in Sublime right now), Pycharm is favoured by
Python developers, but go on search and install and test, everything in
that list is useful.
## Creating your first program
Probably the most intimidating step into writing games is to initialise
the window. There are so many concepts that goes with this initialisation
like selcting a screen size, setting the color modes, creating the back
buffers, setting up the video card, and writing down the most basic
graphics switching system and all that even before we can even see
anything.
Fortunately Ursina makes it so easy that you get all that in three lines.
Python is a scripting language, which in essence means you write a text
file and the Python interpreter will run it straight, no need to compile
or anything.
So let's start, using your file manager or your IDE, create a new folder
(i.e. ursinatutorial). Inside that folder create a new file called
window.py and write the three lines between the dashes (------)

# code
from ursina import * # Import the ursina engine
app = Ursina() # Initialise your Ursina app
app.run() # Run the app
# text
The text after the # is considered comments until the end of the line and
are ignored. Use comments to help reading your code.
So now make sure your gamedev venv is active so that python can find the
Ursina engine. Then go to the folder where your program is and run:
# code
python windows.py
# text
You will see a window with a red cross on top.
Congratulations, you have created your first window and you are a step
closer to your dream!
## Improving your window
So the window looks good, but it might improve with some work, edit your
window.py program so it
# code
from ursina import * # Import the ursina engine
app = Ursina() # Initialise your Ursina app
window.title = 'My Game' # The window title
window.borderless = False # Show a border
window.fullscreen = False # Do not go Fullscreen
window.exit_button.visible = False # Do not show the in-game red X that
loses the window
window.fps_counter.enabled = True # Show the FPS (Frames per second)
counter
app.run() # Run the app
# text
The "window" object is part of the application and you can access it
directly. Some elements of the window can be accessed after the game is
running but some not. Play with those values setting them to True or
False and check the effect. Go to the documentation at
https://www.ursinaengine.org/cheat_sheet.html#window to see even more

options for the window.
Responding to events
So now you have a window running, lets try to see how to control things
from the game.
Game engines work in "passes". On each pass it will check input
conditions, check sound buffers, compute the AI, update the internal game
state and logic, then renders the current scene to the background then
does the "flipping" which updates the contents of the screen.
The Ursina engine simplifies all this process so no need to do the
rendering by yourself, but you are allowed to use the "update" function
to test and update your internal logic need, then let the engine so the
rendering.
To use the update() function, add it to your window program as this:
# code
from ursina import * # Import the ursina engine
def update():
print("Update!") # Print Update every time this loop is executed
if held_keys['t']: # If t is pressed
print(held_keys['t']) # Print the value
app = Ursina() # Initialise your Ursina app
... The rest of the program
# text
The update function is what is called a global function. As long as it is
defined somewhere, Ursina will run it. What is going here is that the
program will print "Update!" to the console (not to the window) every
time it is called.
The engine also has an array that checks which keyboard key is pressed,
this array has one entry for each key available in the keyboard and by
default its values are set to 0. When a key its pressed its value is set
to 1, when its released it is set to 0 again.
The Pythin "if" instruction will execute the commands inside its block
only if the expression evaluates to anything that is not 0 (or null or
empty)m, so when it finds a 1 in the corresponding key it prints the
value, when the key is released it becomes 0 again so the "if" block is
no longer executed.
## Drawing some cubes

Right now the engine is running on empty. An engine is supposed to update
an scene, then draw some graphics in the background then flip to the
foreground but we are not doing anything so we only see a black screen.
Lets do something about this but before starting you need to understand
how an engine is presente.
Game engines are pretty much like filming a video. What you see in the
screen is an scene that you film through some camera lens. So the idea is
you put objects in the scene which Ursina calls Entities but other
engines refer to them in similar ways like actors or game objects. The
camera is pointing to the center of the scene which in coordinates is the
0,0,0.
So you just need to put your objects in your scene and they appear in the
screen. Really neat right?
So let's create a new entity and assign it to a variable. You may see a
variable like a reference to the object so you don't lose it. Add this
object to your window.py program BEFORE the app.run() command:
# code
... all your program
cube = Entity(model='cube', color=color.orange, scale=(2,2,2))
app.run() # Run the app
# text
Here we are creating a cube and we set the colour to orange and a size of
2. So run your program and you will see an orange square.
And now I will read your mind... "Wait a minute... we are supposed to see
a cube!!!!!"
Yeah of course, but that depends from where you see the cube, or better
said, from where the camera is looking at the cube. Let's add some
rotation to the cube so lets do some work on the update function:
# code
def update():
cube.rotation_y += time.dt * 100 # Rotate every time update is called
if held_keys['t']: # If t is pressed
print(held_keys['t']) # Print the value
# text
So what we are doing now is rotating the cube around it's Y axis (imagine
an arrow going up). The engine has a global variable called time.dt which
has the time elapsed since the last frame. The += instruction is like
saying add to the current value of the Y rotation the new time difference
so it is accumulated.

If you run this program and squint a little you may start noticing the
figure is indeed a cube.
Now try changing the colour of the cube, Ursina has a list of predefined
colours that you might find here.
https://www.ursinaengine.org/cheat_sheet.html#color Try setting the
colour to yellow or red.
Ursina also allows setting a colour using Red Green Blue (RGB) components
with values from 0 to 255, try using color.rgb(100, 50, 200) and change
the values to see the effect.
## Random values
Random values are extremely useful when building games. They can be used
to generate enemies or just to calculate probabilities like rolling dice.
Lets add some randomness to this cube.
To create a new random number generator use the Python random library.
This is part of Python so no need to install anything else. Try updating
your window.py file like this:
# code
from ursina import * # Import the ursina engine
import random # Import the random library
random_generator = random.Random() # Create a random number generator
....
# text
Now lets paint this cube randomly. Each time random() is called a number
from 0 to 1 is created, so lets do that when the R key is pressed the
cube is painted in some random colour.
# code
def update():
cube.rotation_y += time.dt * 100 # Rotate every time update is called
if held_keys['r']: # If r is pressed
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue)
# text
Now run and press the r key a few times and you should see the cube
changin colours.

While this looks cool, you might notice that if you leave the r key
pressed, the cube will flash changing colous multiple times. This happens
because the change is evaluated every time the update function is invoked
so while the key is pressed it will keep changing colours.
However, sometimes you want to act on the first press of a key only so
Ursina provides a way to capture this "when pressed" event by using the
input() function. Add this after the update function.
# code
def input(key):
if key == 'space':
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue)
# text
Now try using Random to change the scale and position of the cube. Try to
keep both scale and position to be between 0 and 5.
## Moving the camera
So, the cube is moving, now lets work out the camera. The camera is an
Entity which is part of the scene and it has a variable reference called
"camera". As an Entity, the camera can be moved using its position and
rotation, imagine you are a cameraman moving it around the scene.
For simplicity, lets try moving it up and sown when we press the q and a
keys:
# code
def update():
cube.rotation_y += time.dt * 100 # Rotate the cube every time update is
called
if held_keys['q']: # If q is pressed
camera.position += (0, time.dt, 0) # move up vertically
if held_keys['a']: # If a is pressed
camera.position -= (0, time.dt, 0) # move down vertically
# text
Now try moving the camera left and right. Try rotating the camera on the
Z azis.
The camera has other options that are useful depending on what you are
trying to render and how you want to display the scene. If you have seen

a camera you know it has a lot of knobs and dials, this is quite similar
and same as a real cameraman you need experience to learn how to use
every option. Some options you may play with are here:
https://www.ursinaengine.org/cheat_sheet.html#camera
## Adding more cubes
So we have been playing with one cube only. Let's up this a bit and learn
how to work with multiple entities. To do that we need to learn something
called a data structure. Data structures are probably the most important
pieces of any system, there are mmany data structures and learning how
and when to use each one makes you a master.
The most basic data structure is the list. Think about it as string where
you just put beads one after the other. When you want to work with things
inside, you go through the list and operate on each one, one by one.
So lets create a list and add our cube to it. So surround the cube
creation with this:
# code
cubes = [] # Create the list
cube = Entity(model='cube', color=color.orange, scale=(2,2,2))
cubes.append(cube) # Add the cube to the list
# text
So lets do it so that every time we press 'c' a cube is added to the list
in a random space coordinates between -5 and 5 in x y and z axis.
# code
def input(key):
if key == 'space':
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue) # Note I still can reference any
individual object I want
if key == 'c':
x = random_generator.random() * 10 - 5 # Value between -5 and 5
y = random_generator.random() * 10 - 5 # Value between -5 and 5
z = random_generator.random() * 10 - 5 # Value between -5 and 5
s = random_generator.random() * 1 # Scale between 0 and 1
# Create the new cube and add it to the list
newcube = Entity(model='cube', color=color.orange, position=(x, y, z),
scale=(s,s,s))
cubes.append(newcube)

# text
Now we have many cubes but in the same dull orange colour. use some code
similar to what we do when the "space" key is pressed and use color.rgb()
instead of color.orange to get a random colour when you create a cube.
## Rotating more cubes
So now all the entities are in the scene but they are not moving. Lets go
througn all entities in the scene and move them all not just the cube.
Update your update() function as:
# code
def update():
for entity in cubes: # Go through the cube list
entity.rotation_y += time.dt * 100 # Rotate all the cubes every time
update is called
if held_keys['q']: # If q is pressed
camera.position += (0, time.dt, 0) # move up vertically
if held_keys['a']: # If a is pressed
camera.position -= (0, time.dt, 0) # move down vertically
# text
So instead of just updating the rotation for one cube, we now go through
all the entities in the list and update each one. The "for" instruction
in python allows us iterating through lists.
## Hierarchies (The knee bone connected to the tight bone, the tight bone
connected to the hip bone...)
So we have discussed how objects are added to an scene but how about more
complex hierarchies like the sun and planets and moons. These are more
complicated scenes where some objects depend on the movement of their
parents.
In game engines are usually organised in hierarchies and there is usually
a way to define the parent relationship during creation. In the Ursina
engine when an object is created it is automatically assigned to the
scene but you can alter that. Remember when you added a new cube when the
letter c is pressed? Change that a bit as:
# code
...
red = random_generator.random() * 255
green = random_generator.random() * 255

blue = random_generator.random() * 255
newcube = Entity(parent=cube, model='cube', color=color.rgb(red, green,
blue), position=(x, y, z), scale=(s,s,s))
...
# text
So we are telling the newly creared Entity that the parent is not the
main scene but our beloved cube. Try and run this and press "c" to create
new cubes.
So now when the cube rotates, all objects rotate with it. In fact as we
are still rotating all the cubes in the list, if you notice the cubes are
also rotating independently.
Now, when an object is in hierarchy with another object, its position is
relative to the other object no longer to the center of the scene. In
fact its parent is now considered the starting coordinate. Want to try
this, lets do so than when a cube is added, another cube is added with
the new cube as its parent, something like this:
# code
...
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
newcube = Entity(parent=cube, model='cube', color=color.rgb(red, green,
blue), position=(x, y, z), scale=(s,s,s))
cubes.append(newcube)
# Create another child cube and add it to the list but using the newcube
as the parent, keep the same colour, make it smaller
childcube = Entity(parent=newcube, model='cube', color=color.rgb(red,
green, blue), position=(1, 0, 0), scale=(s/2, s/2, s/2))
cubes.append(childcube)
...
# text
## Adding some texture
So you are seeing a lot of things that look like cubes but don't really
feel like cubes. That is because a lot of the 3D feeling is really
provided by the object texture so lets explore them.
Textures are (usually) square images loaded into the video card memory.
As with any image, a small image is fast to load into memory and fast to
render, but provides less detail, a large image uses more memory and is
slower to render, but provides more detail. You may tend to think that

with larger textures your game will look neater but it may lead to slow
rendering times. It all depends on your game and what you want to show.
If it is a model that will be seen only from far away, why do you need
high detail? If its too close the texture will look bad. It's something
you need to agree with your graphics artist.
Anyway, get a texture from somewhere, for example get
https://www.google.com/search?q=texture+3d+square+crate and save it next
to your program file as a JPG. For this tutorial name it crate.jpg and
make sure it is square like 128x128 or 256x256 or 512x512 pixels.
Now, when creating an entity, add the texture parameter like for example:
cube = Entity(model='cube', color=color.orange, scale=(2,2,2),
texture="crate")
Notice you while the file is called "crate.jpg", you only name it
"crate". The engine will look for JPG, PNG or even PSD files
automatically. Feel free to add the parameter to all places where you
create a cube.
Now, something you will notice is that while the texture is applied to
all cubes, each one has a different colour. This is because the colour of
the texture is affected by the colour of the cube itself, so if the cube
is red the whole object will look reddish, this operation is called a
colour multiplication.
This is pretty much the same problem you have when trying to paint a wall
when there is another colur behind. Colours mix and you don't get what
you want. This is exactly why painters start with a white canvas and why
you prime a wall white before painting it with the colour you want. The
way to get the right texture colour is to provide a full white colour to
the cube, so in every entity creation relace the cube colour for
"colour.white" or color.rgb(255,255,255) like:
# code
cube = Entity(model='cube', color=color.white, scale=(2,2,2),
texture="crate")
# text
Now run your program again and you should see the real texture colour.
You may still press space to change the central cube colour.
## Texture UVs
You might notice in this example, the texture is nicely applied to each
side of the cube. However sometimes you want the texture to map in a
different way or alter how a texture is applied so we will work a bit on

this.
So the easiest way to imagine a texture is like a square piece of rubber
with each corner extending from 0 to 1. So the top left corner is a 0,0
and the lower right corner is a 1,1. Now in this models we are using,
each face of the cube is also marked with the same coordinates in the
corners, so some one corner reads as (0,0), (0,1) , (1,0) and (1,1). Then
the engine matches the corners of the texture to the corners of the cube
and all of them are nicely aligned. This coordinates in the mesh that
pins the texture against the model are called UV coordinates. The U
stands for the horizontal "x" axis and the V stands for the vertical "y"
axis.
But then what will heppen if we change the model but not the texture?
Ursina engine has some basic primitives like 'cube', 'quad', 'sky_dome',
'sphere', try them out. Use "q" to move the camera to try and see the
objects from the top. Observe how the texture wraps around each figure in
a different way. If you think the texture is a rubber surface that
stretches to match the object, then you will notice that what makes it
stretch around is how the figures are defined.
## Animating UVs (Advanced stuff)
In a normal scenario, the artists will provide models with their textures
and UV coordinates set as they have to, as a developer you just have to
load and render everything in the engine.
However, not all the textures are static and there are many cases where
textures need to be animated, this is specially true to simulate fluids
like water or lave, for example to create a river or a waterfall.
So lets get a texture first, in this case we want a waterfall so lets
searche the internet for someting useful, in this case I want a waterfall
texture that is seamless, meaning I can move it around and we shouldn't
notice the borders.
https://www.google.com/search?q=game+water+texture+seamless
There are so many of them, many are free but many are paid. I decided to
go for this one. Download it (click the ... icon next to the image) and
save it next to your window.py program as water.jpg
https://www.pinterest.com.au/pin/210050770099370255/
Now change the texture in the central cube, and also make the cube larger
so we notice the effect like this:
cube = Entity(model='cube', color=color.white, scale=(2,6,2),
texture="waterfall")
Also make it slower to rotate so it is more visible, instead of

multiplying the rotation by 100 make it by 5.
for entity in cubes:
entity.rotation_y += time.dt * 5 # Rotate all the cubes every time update
is called
Run this to see how are we doing. You should be able to see a texture on
the cube, looks like water but its not moving so it looks dull. Lets do
some animation.
Lets start buy creating a global variable to keep the texture movement,
add it after the line where we initialise the random generator. Call it
texoffset.
# code
....
random_generator = random.Random() # Create a random number generator
texoffset = 0.0 # define a variable that will keep the texture offset
....
# text
Now, in your update function, update the texture offset and use that to
update an attribute called texture_offset like this:
# code
...
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5 # Rotate all the cubes every time update
is called
if held_keys['q']: # If q is pressed
camera.position += (0, time.dt, 0) # move up vertically
if held_keys['a']: # If a is pressed
camera.position -= (0, time.dt, 0) # move down vertically
global texoffset # Inform we are going to use the variable defined
outside this function
texoffset += time.dt * 0.2 # Increment this variable just a little based
on the time
setattr(cube, "texture_offset", (0, texoffset)) # Assign the new texture
offset to the entity
...
# text
Note we are updating only the "V" (y, vertical) element of the texture,
we are not updating the U (x, horizontal) coordinate as we want water
falling down.
Now rerun and you will see the new waterfall effect!
But you know what the problem is with effects... you can always make it

better! In this case we are going to add a second wall of water also with
a vertical movement but with that is a bit transparent.
## Transparency
So we have always talked about solid colour like red, white, blue,
orange, etc. And we have used a function called color.rgb() to set the
colour, however in computer graphics colours are as solid as you want
them to be.
There is a fourth component to the colour that is called "alpha" which is
the term for "transparency" and is a component of a colour the same as
red, green or blue and it also goes from 0 to 255 where 0 means
completely transparent and 255 means completely opaque so you can't see
through. To set this transparency you can use the function color.rgba()
which allous setting the alpha level.
To test this, we are going to create a second cube on top of the first
cube, but in this case we will set the colour to a semi transparent (128)
alpha. We also make this second box larger wider and deeper than the
other box (but the same height) so it surrounds it.
# code
...
cube = Entity(model='cube', color=color.white, scale=(2,6,2),
texture="waterfall")
cubes.append(cube) # Add the cube to the list
cube2 = Entity(model='cube', color=color.rgba(255,255,255,128),
scale=(2.5,6,2.5), texture="waterfall")
cubes.append(cube2) # Add the cube to the list
...
# text
If you run now, you will be able to see the new box and if you notice the
borders you can see it is semi transparent.
Now create a second variable so we can move the water just after the
first texoffset variable:
# code
...
random_generator = random.Random() # Create a random number generator
texoffset = 0.0 # define a variable that will keep the texture offset
texoffset2 = 0.0 # define a variable that will keep the texture offset
...
# text

Finally, move the texture in the second cube but a bit faster than the
first cube thus giving a sense of water falling at different speeds:
# code
...
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5 # Rotate all the cubes every time update
is called
if held_keys['q']: # If q is pressed
camera.position += (0, time.dt, 0) # move up vertically
if held_keys['a']: # If a is pressed
camera.position -= (0, time.dt, 0) # move down vertically
global texoffset # Inform we are going to use the variable defined
outside
global texoffset2 # Inform we are going to use the variable defined
outside
texoffset += time.dt * 0.2 # Add a small number to this variable
setattr(cube, "texture_offset", (0, texoffset)) # Assign as a texture
offset
texoffset2 += time.dt * 0.3 # Add a value to this variable, but different
to the first one
setattr(cube2, "texture_offset", (0, texoffset2)) # Assign as a texture
offset of the second cube
...
# text
## Adding text and buttons.
So the final work is to add some text to our demo. Before continuing you
need to be aware that in most games there is a layer on top of the scene
called the UI layer ot front layer. This is very similar to what you see
during a sports game or during news whare there are letters on top of the
scene you are watching.
In the same way, the scene object in the Ursina engine has something
called the ui and you can create text and bitmaps and buttons on top of
it so you create an interface your players can use. In that UI you can
display your compass, character health, timers, etc.
So lets start by adding some text. Lets create it just before starting
the app, after we create the cubes:
# code
...
Text.size = 0.05

Text.default_resolution = 1080 * Text.size
info = Text(text="A powerful waterfall roaring on the mountains")
info.x = -0.5
info.y = 0.4
info.background = True
info.visible = False # Do not show this text
app.run() # opens a window and starts the game.
# text
The coordinate systems x and y of the UI are a bit complicated, (0,0)
refers to the center of the screen. To understand the coordinate system
refer to this document.
https://www.ursinaengine.org/coordinate_system.html
If you run the code above you will probably see nothing because we
intentionally started with the info.visible property set to False, now we
want to show it. We are going to use a function of the mouse cursor which
gets you which entity it is hovering at. Lets update the update()
function to this:
# code
...
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5 # Rotate all the cubes every time update
is called
if held_keys['q']: # If q is pressed
camera.position += (0, time.dt, 0) # move up vertically
if held_keys['a']: # If a is pressed
camera.position -= (0, time.dt, 0) # move down vertically
global texoffset # Inform we are going to use the variable defined
outside
global texoffset2 # Inform we are going to use the variable defined
outside
texoffset += time.dt * 0.2 # Add a small number to this variable
setattr(cube, "texture_offset", (0, texoffset)) # Assign as a texture
offset
texoffset2 += time.dt * 0.3 # Add a small number to this variable
setattr(cube2, "texture_offset", (0, texoffset2)) # Assign as a texture
offset
if mouse.hovered_entity == cube: # If the mouse is hovering over the cube
entity
info.visible = True # Make the text visible
else: # else
info.visible = False # hide it again

...
# text
Now run this program and hover the mouse on top of the cascade, you will
notice when the mouse touches the box the text is displayed, and when you
hover out it hides.
Now try using the mouse docs
https://www.ursinaengine.org/cheat_sheet.html#mouse and check if you can
do the text appear only if the cursor if over the cascade and only if the
left button is clicked (hint: mouse.left = True)
## The end
So if you got to this point, cheers, a big hooray and kudos to you! In
this time you have learned so many things that you really deserve a
treat! Your final program should look like this:
# code
from ursina import * # this will import everything we need from ursina
with just one line.
import random # Import the random library
random_generator = random.Random() # Create a random number generator
texoffset = 0.0 # define a variable that will keep the texture offset
texoffset2 = 0.0 # define a variable that will keep the texture offset
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5 # Rotate all the cubes every time update
is called
if held_keys['q']: # If q is pressed
camera.position += (0, time.dt, 0) # move up vertically
if held_keys['a']: # If a is pressed
camera.position -= (0, time.dt, 0) # move down vertically
global texoffset # Inform we are going to use the variable defined
outside
global texoffset2 # Inform we are going to use the variable defined
outside
texoffset += time.dt * 0.2 # Add a small number to this variable
setattr(cube, "texture_offset", (0, texoffset)) # Assign as a texture
offset
texoffset2 += time.dt * 0.3 # Add a small number to this variable
setattr(cube2, "texture_offset", (0, texoffset2)) # Assign as a texture
offset

if mouse.hovered_entity == cube:
info.visible = True
else:
info.visible = False
def input(key):
if key == 'space':
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue)
if key == 'c':
x = random_generator.random() * 10 - 5 # Value between -5 and 5
y = random_generator.random() * 10 - 5 # Value between -5 and 5
z = random_generator.random() * 10 - 5 # Value between -5 and 5
s = random_generator.random() * 1 # Value between 0 and 1
newcube = Entity(parent=cube, model='cube', color=color.white,
position=(x, y, z), scale=(s,s,s), texture="crate")
cubes.append(newcube)
'''Create another child cube and add it to the list but using the newcube
as the parent, keep the same colour, make it smaller'''
childcube = Entity(parent=newcube, model='cube', color=color.white,
position=(1, 0, 0), scale=(s/2, s/2, s/2), texture="crate")
cubes.append(childcube)
app = Ursina()
window.title = 'My Game' # The window title
window.borderless = False # Show a border
window.fullscreen = False # Go Fullscreen
window.exit_button.visible = False # Show the in-game red X that loses
the window
window.fps_counter.enabled = True # Show the FPS (Frames per second)
counter
cubes = [] # Create the list
cube = Entity(model='cube', color=color.white, scale=(2,6,2),
texture="waterfall", collider="box")
cube2 = Entity(model='cube', color=color.rgba(255,255,255,128),
scale=(2.5,6,2.5), texture="waterfall")
cubes.append(cube) # Add the cube to the list
cubes.append(cube2) # Add the cube to the list
Text.size = 0.05
Text.default_resolution = 1080 * Text.size
info = Text(text="A powerful waterfall roaring on the mountains")

info.x = -0.5
info.y = 0.4
info.background = True
info.visible = False # Do not show this text
app.run() # opens a window and starts the game.
# text
Try playing with this tutorial. Add some planes to the top and bottom of
your cascade and make them move slowly like calm water, add some cubes
with rock textures and maybe some with grass textures to the sides to
make a scene, cleanup the flying boxes.
Then, try making a solar system using spheres.
The key is practicing until your feel comfortable with your skills, then
we can move into more complex programs.
Good luck!
# center, width 900, arial
# size 5, bold
Ursina Game Engine Tutorial for Dummies
# size 1, normal, left
## Summary
This is a tutorial that explains you how to setup your environment, create a window and render a
coloured cube with really simple controls.
A passing knowledge in Python is beneficial but not required, this tutorial assumes you have no idea
what you are doing at all.
Once you finish this tutorial you are expected to know:
- How to setup Python in any computer.
- How to install a python library
- Select your IDE
- Write a program
- Execute a program
- Create and destroy a graphics window using Ursina
- Draw a simple mesh
- Control the mesh using the keyboard.
- Hierarchies
- Texturing
- Texture animations
- Alpha blending
- Mouse collisons
- Text and UI
## Introduction

So you want to write your own game, sell it by tons and get rich and famous? Then you are on the
right track, but let me be straight and tell you this is not going to happen anytime soon. Many people
writing games in big companies started somewhere and to get to the top you need to understand the
basics and that is exactly why you are here, so consider this tutorial as the stepping stone into the
game development industry.
Ursina is a Python wrapper around the Panda3D game engine, as such Python is used to control
every aspect of the engine from the initialisation, rendering, game control, playing sounds and
shutdown, therefore you will need to build up your Python skills. Python has become one of the most
used and well respected scripting languages and plenty of companies and game development studios
use Python to automate many functions so this is a fantastic tool to have in your belt.
Panda3D is an Open Source game engine created by Disney and still used for production
development. Panda3D already has a Python wrapper, but Ursina enhances the engine making it
seamless to work across platforms and providing tools that make the development experience much
more comfortable.
Before we start, keep in mind the engine has a reference page here
https://www.ursinaengine.org/cheat_sheet.html in case you want to check even more options.
## Install Python3
If you are ready to start writing your game, you need to get your computer ready and the first step
is to install Python3.6. Python is an universal language so it is available for most operating systems.
Please follow these instructions to install it in your computer.
https://docs.python-guide.org/
https://docs.python-guide.org/starting/install3/osx
https://docs.python-guide.org/starting/install3/win
https://docs.python-guide.org/starting/install3/linux
Once done, you should be able to run:
# code
python3 --version
Python 3.7.4
# text
## Setup a virtual environment (venv) (optional)
A Python virtual environment or venv is the way Python maintains a private space for the libraries
you need for a project. You can have any number of virtual environments in your computer and be
sure all libraries installed in one venv does not mix with libraries in the other venv so for example you
may create a "gamedev" venv and install all your game development libraries, then create a "science"
venv and install libraries for number crunching, then create another called "music" and install all your
libraries you need to work with sound files. You may even install multiple versions of the same
libraries on each venv and be sure they don't mix. Once you are done with a venv (or maybe it
becomes too large because you have been installing too many things) you can delete the venv and
recreate it from scratch.
## Installing the Ursina game engine
To install Ursina we need to use pip, the Python package manager.
Jump into your venv:

# code
source gamedev/bin/activate
# text
Now install the engine:
# code
pip install ursina
# text
This will download and setup ursina and other libraries required by the engine. If you want to see
which libraries are installed run:
# code
pip list
# text
You will see some libraries like Panda3d in there.
Now let me show why Python is so popular. Python has tons of other libraries available and all of
them are located in a repository called the Python Package index or PyPI (https://pypi.org). There are
hundreds of thousands of libraries available for almost anything you may need and they are organised
and searchable. So for example you need a library to work your sound files, you may run:
# code
pip search sound
# text
Or maybe you need to read a YAML file (yaml), or machine learning (ml), or cover image formats.
Just run a pip search and you will get something.
So lets say you want the "playsound" library installed. Run:
# code
pip install playsound
# text
Of course, we don't really need this library because ursina can play sound as well. This is just an
example.
Once you are done with this library run:
# code
pip uninstall playsound
# text
## Installing an IDE
This is a tricky one. There are plenty programming IDEs available and its all a matter of choice.
Essentially you may code in command line but installing a nice IDE will help you be more effective.
Some options:
- Sublime Text
- Atom
- PyCharm
- Visual Studio Code
- Notepad++
- Eclipse
Sublime is a good choice for a beginner as it is very lightweight (and I'm writing this tutorial in
Sublime right now), Pycharm is favoured by Python developers, but go on search and install and test,
everything in that list is useful.

## Creating your first program
Probably the most intimidating step into writing games is to initialise the window. There are so
many concepts that goes with this initialisation like selcting a screen size, setting the color modes,
creating the back buffers, setting up the video card, and writing down the most basic graphics
switching system and all that even before we can even see anything.
Fortunately Ursina makes it so easy that you get all that in three lines. Python is a scripting
language, which in essence means you write a text file and the Python interpreter will run it straight,
no need to compile or anything.
So let's start, using your file manager or your IDE, create a new folder (i.e. ursinatutorial). Inside
that folder create a new file called window.py and write the three lines between the dashes (------)
# code
from ursina import *
# Import the ursina engine
app = Ursina()
# Initialise your Ursina app
app.run()
# Run the app
# text
The text after the # is considered comments until the end of the line and are ignored. Use
comments to help reading your code.
So now make sure your gamedev venv is active so that python can find the Ursina engine. Then go
to the folder where your program is and run:
# code
python windows.py
# text
You will see a window with a red cross on top.
Congratulations, you have created your first window and you are a step closer to your dream!
## Improving your window
So the window looks good, but it might improve with some work, edit your window.py program so
it
# code
from ursina import *
# Import the ursina engine
app = Ursina()
# Initialise your Ursina app
window.title = 'My Game'
# The window title
window.borderless = False
# Show a border
window.fullscreen = False
# Do not go Fullscreen
window.exit_button.visible = False
# Do not show the in-game red X that loses the window
window.fps_counter.enabled = True
# Show the FPS (Frames per second) counter
app.run()
# Run the app
# text

The "window" object is part of the application and you can access it directly. Some elements of the
window can be accessed after the game is running but some not. Play with those values setting them
to True or False and check the effect. Go to the documentation at
https://www.ursinaengine.org/cheat_sheet.html#window to see even more options for the window.
Responding to events
So now you have a window running, lets try to see how to control things from the game.
Game engines work in "passes". On each pass it will check input conditions, check sound buffers,
compute the AI, update the internal game state and logic, then renders the current scene to the
background then does the "flipping" which updates the contents of the screen.
The Ursina engine simplifies all this process so no need to do the rendering by yourself, but you are
allowed to use the "update" function to test and update your internal logic need, then let the engine
so the rendering.
To use the update() function, add it to your window program as this:
# code
from ursina import *
# Import the ursina engine
def update():
print("Update!")
# Print Update every time this loop is executed
if held_keys['t']:
# If t is pressed
print(held_keys['t'])
# Print the value
app = Ursina()
# Initialise your Ursina app
... The rest of the program
# text
The update function is what is called a global function. As long as it is defined somewhere, Ursina
will run it. What is going here is that the program will print "Update!" to the console (not to the
window) every time it is called.
The engine also has an array that checks which keyboard key is pressed, this array has one entry for
each key available in the keyboard and by default its values are set to 0. When a key its pressed its
value is set to 1, when its released it is set to 0 again.
The Pythin "if" instruction will execute the commands inside its block only if the expression
evaluates to anything that is not 0 (or null or empty)m, so when it finds a 1 in the corresponding key it
prints the value, when the key is released it becomes 0 again so the "if" block is no longer executed.
## Drawing some cubes
Right now the engine is running on empty. An engine is supposed to update an scene, then draw
some graphics in the background then flip to the foreground but we are not doing anything so we
only see a black screen. Lets do something about this but before starting you need to understand how
an engine is presente.
Game engines are pretty much like filming a video. What you see in the screen is an scene that you
film through some camera lens. So the idea is you put objects in the scene which Ursina calls Entities
but other engines refer to them in similar ways like actors or game objects. The camera is pointing to
the center of the scene which in coordinates is the 0,0,0.

So you just need to put your objects in your scene and they appear in the screen. Really neat right?
So let's create a new entity and assign it to a variable. You may see a variable like a reference to the
object so you don't lose it. Add this object to your window.py program BEFORE the app.run()
command:
# code
... all your program
cube = Entity(model='cube', color=color.orange, scale=(2,2,2))
app.run()
# Run the app
# text
Here we are creating a cube and we set the colour to orange and a size of 2. So run your program
and you will see an orange square.
And now I will read your mind... "Wait a minute... we are supposed to see a cube!!!!!"
Yeah of course, but that depends from where you see the cube, or better said, from where the
camera is looking at the cube. Let's add some rotation to the cube so lets do some work on the
update function:
# code
def update():
cube.rotation_y += time.dt * 100
# Rotate every time update is called
if held_keys['t']:
# If t is pressed
print(held_keys['t'])
# Print the value
# text
So what we are doing now is rotating the cube around it's Y axis (imagine an arrow going up). The
engine has a global variable called time.dt which has the time elapsed since the last frame. The +=
instruction is like saying add to the current value of the Y rotation the new time difference so it is
accumulated.
If you run this program and squint a little you may start noticing the figure is indeed a cube.
Now try changing the colour of the cube, Ursina has a list of predefined colours that you might find
here. https://www.ursinaengine.org/cheat_sheet.html#color Try setting the colour to yellow or red.
Ursina also allows setting a colour using Red Green Blue (RGB) components with values from 0 to
255, try using color.rgb(100, 50, 200) and change the values to see the effect.
## Random values
Random values are extremely useful when building games. They can be used to generate enemies
or just to calculate probabilities like rolling dice. Lets add some randomness to this cube.
To create a new random number generator use the Python random library. This is part of Python so
no need to install anything else. Try updating your window.py file like this:
# code
from ursina import *
# Import the ursina engine
import random
# Import the random library
random_generator = random.Random()
# Create a random number generator

....
# text
Now lets paint this cube randomly. Each time random() is called a number from 0 to 1 is created, so
lets do that when the R key is pressed the cube is painted in some random colour.
# code
def update():
cube.rotation_y += time.dt * 100
# Rotate every time update is called
if held_keys['r']:
# If r is pressed
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue)
# text
Now run and press the r key a few times and you should see the cube changin colours.
While this looks cool, you might notice that if you leave the r key pressed, the cube will flash
changing colous multiple times. This happens because the change is evaluated every time the update
function is invoked so while the key is pressed it will keep changing colours.
However, sometimes you want to act on the first press of a key only so Ursina provides a way to
capture this "when pressed" event by using the input() function. Add this after the update function.
# code
def input(key):
if key == 'space':
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue)
# text
Now try using Random to change the scale and position of the cube. Try to keep both scale and
position to be between 0 and 5.
## Moving the camera
So, the cube is moving, now lets work out the camera. The camera is an Entity which is part of the
scene and it has a variable reference called "camera". As an Entity, the camera can be moved using its
position and rotation, imagine you are a cameraman moving it around the scene.
For simplicity, lets try moving it up and sown when we press the q and a keys:
# code
def update():
cube.rotation_y += time.dt * 100
# Rotate the cube every time update is called
if held_keys['q']:
# If q is pressed
camera.position += (0, time.dt, 0)
# move up vertically
if held_keys['a']:
# If a is pressed
camera.position -= (0, time.dt, 0)
# move down vertically
# text

Now try moving the camera left and right. Try rotating the camera on the Z azis.
The camera has other options that are useful depending on what you are trying to render and how
you want to display the scene. If you have seen a camera you know it has a lot of knobs and dials, this
is quite similar and same as a real cameraman you need experience to learn how to use every option.
Some options you may play with are here: https://www.ursinaengine.org/cheat_sheet.html#camera
## Adding more cubes
So we have been playing with one cube only. Let's up this a bit and learn how to work with multiple
entities. To do that we need to learn something called a data structure. Data structures are probably
the most important pieces of any system, there are mmany data structures and learning how and
when to use each one makes you a master.
The most basic data structure is the list. Think about it as string where you just put beads one after
the other. When you want to work with things inside, you go through the list and operate on each
one, one by one.
So lets create a list and add our cube to it. So surround the cube creation with this:
# code
cubes = []
# Create the list
cube = Entity(model='cube', color=color.orange, scale=(2,2,2))
cubes.append(cube)
# Add the cube to the list
# text
So lets do it so that every time we press 'c' a cube is added to the list in a random space coordinates
between -5 and 5 in x y and z axis.
# code
def input(key):
if key == 'space':
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue) # Note I still can reference any individual object I want
if key == 'c':
x = random_generator.random() * 10 - 5
# Value between -5 and 5
y = random_generator.random() * 10 - 5
# Value between -5 and 5
z = random_generator.random() * 10 - 5
# Value between -5 and 5
s = random_generator.random() * 1
# Scale between 0 and 1
# Create the new cube and add it to the list
newcube = Entity(model='cube', color=color.orange, position=(x, y, z), scale=(s,s,s))
cubes.append(newcube)
# text
Now we have many cubes but in the same dull orange colour. use some code similar to what we do
when the "space" key is pressed and use color.rgb() instead of color.orange to get a random colour
when you create a cube.

## Rotating more cubes
So now all the entities are in the scene but they are not moving. Lets go througn all entities in the
scene and move them all not just the cube. Update your update() function as:
# code
def update():
for entity in cubes:
# Go through the cube list
entity.rotation_y += time.dt * 100
# Rotate all the cubes every time update is called
if held_keys['q']:
# If q is pressed
camera.position += (0, time.dt, 0)
# move up vertically
if held_keys['a']:
# If a is pressed
camera.position -= (0, time.dt, 0)
# move down vertically
# text
So instead of just updating the rotation for one cube, we now go through all the entities in the list
and update each one. The "for" instruction in python allows us iterating through lists.
## Hierarchies (The knee bone connected to the tight bone, the tight bone connected to the hip
bone...)
So we have discussed how objects are added to an scene but how about more complex hierarchies
like the sun and planets and moons. These are more complicated scenes where some objects depend
on the movement of their parents.
In game engines are usually organised in hierarchies and there is usually a way to define the parent
relationship during creation. In the Ursina engine when an object is created it is automatically
assigned to the scene but you can alter that. Remember when you added a new cube when the letter
c is pressed? Change that a bit as:
# code
...
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
newcube = Entity(parent=cube, model='cube', color=color.rgb(red, green, blue), position=(x, y,
z), scale=(s,s,s))
...
# text
So we are telling the newly creared Entity that the parent is not the main scene but our beloved
cube. Try and run this and press "c" to create new cubes.
So now when the cube rotates, all objects rotate with it. In fact as we are still rotating all the cubes
in the list, if you notice the cubes are also rotating independently.
Now, when an object is in hierarchy with another object, its position is relative to the other object
no longer to the center of the scene. In fact its parent is now considered the starting coordinate.
Want to try this, lets do so than when a cube is added, another cube is added with the new cube as its
parent, something like this:
# code
...
red = random_generator.random() * 255
green = random_generator.random() * 255

blue = random_generator.random() * 255
newcube = Entity(parent=cube, model='cube', color=color.rgb(red, green, blue), position=(x, y,
z), scale=(s,s,s))
cubes.append(newcube)
# Create another child cube and add it to the list but using the newcube as the parent, keep the
same colour, make it smaller
childcube = Entity(parent=newcube, model='cube', color=color.rgb(red, green, blue),
position=(1, 0, 0), scale=(s/2, s/2, s/2))
cubes.append(childcube)
...
# text
## Adding some texture
So you are seeing a lot of things that look like cubes but don't really feel like cubes. That is because
a lot of the 3D feeling is really provided by the object texture so lets explore them.
Textures are (usually) square images loaded into the video card memory. As with any image, a small
image is fast to load into memory and fast to render, but provides less detail, a large image uses more
memory and is slower to render, but provides more detail. You may tend to think that with larger
textures your game will look neater but it may lead to slow rendering times. It all depends on your
game and what you want to show. If it is a model that will be seen only from far away, why do you
need high detail? If its too close the texture will look bad. It's something you need to agree with your
graphics artist.
Anyway, get a texture from somewhere, for example get
https://www.google.com/search?q=texture+3d+square+crate and save it next to your program file as
a JPG. For this tutorial name it crate.jpg and make sure it is square like 128x128 or 256x256 or
512x512 pixels.
Now, when creating an entity, add the texture parameter like for example:
cube = Entity(model='cube', color=color.orange, scale=(2,2,2), texture="crate")
Notice you while the file is called "crate.jpg", you only name it "crate". The engine will look for JPG,
PNG or even PSD files automatically. Feel free to add the parameter to all places where you create a
cube.
Now, something you will notice is that while the texture is applied to all cubes, each one has a
different colour. This is because the colour of the texture is affected by the colour of the cube itself,
so if the cube is red the whole object will look reddish, this operation is called a colour multiplication.
This is pretty much the same problem you have when trying to paint a wall when there is another
colur behind. Colours mix and you don't get what you want. This is exactly why painters start with a
white canvas and why you prime a wall white before painting it with the colour you want. The way to
get the right texture colour is to provide a full white colour to the cube, so in every entity creation
relace the cube colour for "colour.white" or color.rgb(255,255,255) like:
# code
cube = Entity(model='cube', color=color.white, scale=(2,2,2), texture="crate")
# text
Now run your program again and you should see the real texture colour. You may still press space
to change the central cube colour.

## Texture UVs
You might notice in this example, the texture is nicely applied to each side of the cube. However
sometimes you want the texture to map in a different way or alter how a texture is applied so we will
work a bit on this.
So the easiest way to imagine a texture is like a square piece of rubber with each corner extending
from 0 to 1. So the top left corner is a 0,0 and the lower right corner is a 1,1. Now in this models we
are using, each face of the cube is also marked with the same coordinates in the corners, so some
one corner reads as (0,0), (0,1) , (1,0) and (1,1). Then the engine matches the corners of the texture to
the corners of the cube and all of them are nicely aligned. This coordinates in the mesh that pins the
texture against the model are called UV coordinates. The U stands for the horizontal "x" axis and the
V stands for the vertical "y" axis.
But then what will heppen if we change the model but not the texture? Ursina engine has some
basic primitives like 'cube', 'quad', 'sky_dome', 'sphere', try them out. Use "q" to move the camera to
try and see the objects from the top. Observe how the texture wraps around each figure in a different
way. If you think the texture is a rubber surface that stretches to match the object, then you will
notice that what makes it stretch around is how the figures are defined.
## Animating UVs (Advanced stuff)
In a normal scenario, the artists will provide models with their textures and UV coordinates set as
they have to, as a developer you just have to load and render everything in the engine.
However, not all the textures are static and there are many cases where textures need to be
animated, this is specially true to simulate fluids like water or lave, for example to create a river or a
waterfall.
So lets get a texture first, in this case we want a waterfall so lets searche the internet for someting
useful, in this case I want a waterfall texture that is seamless, meaning I can move it around and we
shouldn't notice the borders.
https://www.google.com/search?q=game+water+texture+seamless
There are so many of them, many are free but many are paid. I decided to go for this one.
Download it (click the ... icon next to the image) and save it next to your window.py program as
water.jpg
https://www.pinterest.com.au/pin/210050770099370255/
Now change the texture in the central cube, and also make the cube larger so we notice the effect
like this:
cube = Entity(model='cube', color=color.white, scale=(2,6,2), texture="waterfall")
Also make it slower to rotate so it is more visible, instead of multiplying the rotation by 100 make it
by 5.
for entity in cubes:
entity.rotation_y += time.dt * 5
# Rotate all the cubes every time update is called
Run this to see how are we doing. You should be able to see a texture on the cube, looks like water
but its not moving so it looks dull. Lets do some animation.
Lets start buy creating a global variable to keep the texture movement, add it after the line where
we initialise the random generator. Call it texoffset.

# code
....
random_generator = random.Random()
# Create a random number generator
texoffset = 0.0
# define a variable that will keep the texture offset
....
# text
Now, in your update function, update the texture offset and use that to update an attribute called
texture_offset like this:
# code
...
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5
# Rotate all the cubes every time update is called
if held_keys['q']:
# If q is pressed
camera.position += (0, time.dt, 0)
# move up vertically
if held_keys['a']:
# If a is pressed
camera.position -= (0, time.dt, 0)
# move down vertically
global texoffset
# Inform we are going to use the variable defined outside this
function
texoffset += time.dt * 0.2
# Increment this variable just a little based on the time
setattr(cube, "texture_offset", (0, texoffset)) # Assign the new texture offset to the entity
...
# text
Note we are updating only the "V" (y, vertical) element of the texture, we are not updating the U (x,
horizontal) coordinate as we want water falling down.
Now rerun and you will see the new waterfall effect!
But you know what the problem is with effects... you can always make it better! In this case we are
going to add a second wall of water also with a vertical movement but with that is a bit transparent.
## Transparency
So we have always talked about solid colour like red, white, blue, orange, etc. And we have used a
function called color.rgb() to set the colour, however in computer graphics colours are as solid as you
want them to be.
There is a fourth component to the colour that is called "alpha" which is the term for
"transparency" and is a component of a colour the same as red, green or blue and it also goes from 0
to 255 where 0 means completely transparent and 255 means completely opaque so you can't see
through. To set this transparency you can use the function color.rgba() which allous setting the alpha
level.
To test this, we are going to create a second cube on top of the first cube, but in this case we will
set the colour to a semi transparent (128) alpha. We also make this second box larger wider and
deeper than the other box (but the same height) so it surrounds it.
# code
...
cube = Entity(model='cube', color=color.white, scale=(2,6,2), texture="waterfall")
cubes.append(cube)
# Add the cube to the list

cube2 = Entity(model='cube', color=color.rgba(255,255,255,128), scale=(2.5,6,2.5),
texture="waterfall")
cubes.append(cube2)
# Add the cube to the list
...
# text
If you run now, you will be able to see the new box and if you notice the borders you can see it is
semi transparent.
Now create a second variable so we can move the water just after the first texoffset variable:
# code
...
random_generator = random.Random()
# Create a random number generator
texoffset = 0.0
# define a variable that will keep the texture offset
texoffset2 = 0.0
# define a variable that will keep the texture offset
...
# text
Finally, move the texture in the second cube but a bit faster than the first cube thus giving a sense
of water falling at different speeds:
# code
...
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5
# Rotate all the cubes every time update is called
if held_keys['q']:
# If q is pressed
camera.position += (0, time.dt, 0)
# move up vertically
if held_keys['a']:
# If a is pressed
camera.position -= (0, time.dt, 0)
# move down vertically
global texoffset
# Inform we are going to use the variable defined outside
global texoffset2
# Inform we are going to use the variable defined outside
texoffset += time.dt * 0.2
# Add a small number to this variable
setattr(cube, "texture_offset", (0, texoffset)) # Assign as a texture offset
texoffset2 += time.dt * 0.3
# Add a value to this variable, but different to the first one
setattr(cube2, "texture_offset", (0, texoffset2)) # Assign as a texture offset of the second cube
...
# text
## Adding text and buttons.
So the final work is to add some text to our demo. Before continuing you need to be aware that in
most games there is a layer on top of the scene called the UI layer ot front layer. This is very similar to
what you see during a sports game or during news whare there are letters on top of the scene you are
watching.
In the same way, the scene object in the Ursina engine has something called the ui and you can
create text and bitmaps and buttons on top of it so you create an interface your players can use. In
that UI you can display your compass, character health, timers, etc.
So lets start by adding some text. Lets create it just before starting the app, after we create the
cubes:

# code
...
Text.size = 0.05
Text.default_resolution = 1080 * Text.size
info = Text(text="A powerful waterfall roaring on the mountains")
info.x = -0.5
info.y = 0.4
info.background = True
info.visible = False
# Do not show this text
app.run()
# opens a window and starts the game.
# text
The coordinate systems x and y of the UI are a bit complicated, (0,0) refers to the center of the
screen. To understand the coordinate system refer to this document.
https://www.ursinaengine.org/coordinate_system.html
If you run the code above you will probably see nothing because we intentionally started with the
info.visible property set to False, now we want to show it. We are going to use a function of the
mouse cursor which gets you which entity it is hovering at. Lets update the update() function to this:
# code
...
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5
# Rotate all the cubes every time update is called
if held_keys['q']:
# If q is pressed
camera.position += (0, time.dt, 0)
# move up vertically
if held_keys['a']:
# If a is pressed
camera.position -= (0, time.dt, 0)
# move down vertically
global texoffset
# Inform we are going to use the variable defined outside
global texoffset2
# Inform we are going to use the variable defined outside
texoffset += time.dt * 0.2
# Add a small number to this variable
setattr(cube, "texture_offset", (0, texoffset)) # Assign as a texture offset
texoffset2 += time.dt * 0.3
# Add a small number to this variable
setattr(cube2, "texture_offset", (0, texoffset2)) # Assign as a texture offset
if mouse.hovered_entity == cube:
# If the mouse is hovering over the cube entity
info.visible = True
# Make the text visible
else:
# else
info.visible = False
# hide it again
...
# text
Now run this program and hover the mouse on top of the cascade, you will notice when the mouse
touches the box the text is displayed, and when you hover out it hides.
Now try using the mouse docs https://www.ursinaengine.org/cheat_sheet.html#mouse and check
if you can do the text appear only if the cursor if over the cascade and only if the left button is clicked
(hint: mouse.left = True)
## The end

So if you got to this point, cheers, a big hooray and kudos to you! In this time you have learned so
many things that you really deserve a treat! Your final program should look like this:
# code
from ursina import *
# this will import everything we need from ursina with just one line.
import random
# Import the random library
random_generator = random.Random()
# Create a random number generator
texoffset = 0.0
# define a variable that will keep the texture offset
texoffset2 = 0.0
# define a variable that will keep the texture offset
def update():
for entity in cubes:
entity.rotation_y += time.dt * 5
# Rotate all the cubes every time update is called
if held_keys['q']:
# If q is pressed
camera.position += (0, time.dt, 0)
# move up vertically
if held_keys['a']:
# If a is pressed
camera.position -= (0, time.dt, 0)
# move down vertically
global texoffset
# Inform we are going to use the variable defined outside
global texoffset2
# Inform we are going to use the variable defined outside
texoffset += time.dt * 0.2
# Add a small number to this variable
setattr(cube, "texture_offset", (0, texoffset))
# Assign as a texture offset
texoffset2 += time.dt * 0.3
# Add a small number to this variable
setattr(cube2, "texture_offset", (0, texoffset2)) # Assign as a texture offset
if mouse.hovered_entity == cube:
info.visible = True
else:
info.visible = False
def input(key):
if key == 'space':
red = random_generator.random() * 255
green = random_generator.random() * 255
blue = random_generator.random() * 255
cube.color = color.rgb(red, green, blue)
if key == 'c':
x = random_generator.random() * 10 - 5
# Value between -5 and 5
y = random_generator.random() * 10 - 5
# Value between -5 and 5
z = random_generator.random() * 10 - 5
# Value between -5 and 5
s = random_generator.random() * 1
# Value between 0 and 1
newcube = Entity(parent=cube, model='cube', color=color.white, position=(x, y, z), scale=(s,s,s),
texture="crate")
cubes.append(newcube)
'''Create another child cube and add it to the list but using the newcube as the parent, keep the
same colour, make it smaller'''
childcube = Entity(parent=newcube, model='cube', color=color.white, position=(1, 0, 0),
scale=(s/2, s/2, s/2), texture="crate")
cubes.append(childcube)
app = Ursina()
window.title = 'My Game'
# The window title
window.borderless = False
# Show a border

window.fullscreen = False
# Go Fullscreen
window.exit_button.visible = False
# Show the in-game red X that loses the window
window.fps_counter.enabled = True
# Show the FPS (Frames per second) counter
cubes = []
# Create the list
cube = Entity(model='cube', color=color.white, scale=(2,6,2), texture="waterfall", collider="box")
cube2 = Entity(model='cube', color=color.rgba(255,255,255,128), scale=(2.5,6,2.5),
texture="waterfall")
cubes.append(cube)
# Add the cube to the list
cubes.append(cube2)
# Add the cube to the list
Text.size = 0.05
Text.default_resolution = 1080 * Text.size
info = Text(text="A powerful waterfall roaring on the mountains")
info.x = -0.5
info.y = 0.4
info.background = True
info.visible = False
# Do not show this text
app.run()
# opens a window and starts the game.
# text
Try playing with this tutorial. Add some planes to the top and bottom of your cascade and make
them move slowly like calm water, add some cubes with rock textures and maybe some with grass
textures to the sides to make a scene, cleanup the flying boxes.
Then, try making a solar system using spheres.
The key is practicing until your feel comfortable with your skills, then we can move into more
complex programs.
Good luck!

