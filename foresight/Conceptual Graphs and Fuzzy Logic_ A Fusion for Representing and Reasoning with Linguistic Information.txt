Tru Hoang Cao
Conceptual Graphs and Fuzzy Logic

Studies in Computational Intelligence,Volume 306
Editor-in-Chief
Prof. Janusz Kacprzyk
Systems Research Institute
Polish Academy of Sciences
ul. Newelska 6
01-447 Warsaw
Poland
E-mail: kacprzyk@ibspan.waw.pl
Further volumes of this series can be found on our
homepage: springer.com
Vol. 284. Juan R. Gonz´alez, David Alejandro Pelta,
Carlos Cruz, Germ´an Terrazas, and Natalio Krasnogor (Eds.)
Nature Inspired Cooperative Strategies for Optimization
(NICSO 2010), 2010
ISBN 978-3-642-12537-9
Vol. 285. Roberto Cipolla, Sebastiano Battiato, and
Giovanni Maria Farinella (Eds.)
Computer Vision, 2010
ISBN 978-3-642-12847-9
Vol. 286. Zeev Volkovich,Alexander Bolshoy,Valery Kirzhner,
and Zeev Barzily
Genome Clustering, 2010
ISBN 978-3-642-12951-3
Vol. 287. Dan Schonfeld, Caifeng Shan, Dacheng Tao, and
Liang Wang (Eds.)
Video Search and Mining,2010
ISBN 978-3-642-12899-8
Vol. 288. I-Hsien Ting, Hui-Ju Wu, Tien-Hwa Ho (Eds.)
Mining and Analyzing Social Networks, 2010
ISBN 978-3-642-13421-0
Vol. 289.Anne H˚akansson, Ronald Hartung, and
Ngoc Thanh Nguyen (Eds.)
Agent and Multi-agent Technology for Internet and
Enterprise Systems, 2010
ISBN 978-3-642-13525-5
Vol. 290.Weiliang Xu and John Bronlund
Mastication Robots, 2010
ISBN 978-3-540-93902-3
Vol. 291. Shimon Whiteson
Adaptive Representations for Reinforcement Learning, 2010
ISBN 978-3-642-13931-4
Vol. 292. Fabrice Guillet, Gilbert Ritschard,
Henri Briand, Djamel A. Zighed (Eds.)
Advances in Knowledge Discovery and Management, 2010
ISBN 978-3-642-00579-4
Vol. 293.Anthony Brabazon, Michael O’Neill, and
Dietmar Maringer (Eds.)
Natural Computing in Computational Finance, 2010
ISBN 978-3-642-13949-9
Vol. 294. Manuel F.M. Barros, Jorge M.C. Guilherme, and
Nuno C.G. Horta
Analog Circuits and Systems Optimization based on
Evolutionary Computation Techniques, 2010
ISBN 978-3-642-12345-0
Vol. 295. Roger Lee (Ed.)
Software Engineering, Artiﬁcial Intelligence, Networking and
Parallel/Distributed Computing, 2010
ISBN 978-3-642-13264-3
Vol. 296. Roger Lee (Ed.)
Software Engineering Research, Management and
Applications, 2010
ISBN 978-3-642-13272-8
Vol. 297. Tania Tronco (Ed.)
New Network Architectures, 2010
ISBN 978-3-642-13246-9
Vol. 298.Adam Wierzbicki
Trust and Fairness in Open, Distributed Systems, 2010
ISBN 978-3-642-13450-0
Vol. 299.Vassil Sgurev, Mincho Hadjiski, and
Janusz Kacprzyk (Eds.)
Intelligent Systems: From Theory to Practice, 2010
ISBN 978-3-642-13427-2
Vol. 300. Baoding Liu (Ed.)
Uncertainty Theory, 2010
ISBN 978-3-642-13958-1
Vol. 301. Giuliano Armano, Marco de Gemmis,
Giovanni Semeraro, and Eloisa Vargiu (Eds.)
Intelligent Information Access, 2010
ISBN 978-3-642-13999-4
Vol. 302. Bijaya Ketan Panigrahi,Ajith Abraham,
and Swagatam Das (Eds.)
Computational Intelligence in Power Engineering, 2010
ISBN 978-3-642-14012-9
Vol. 303. Joachim Diederich, Cengiz Gunay, and
James M. Hogan
Recruitment Learning, 2010
ISBN 978-3-642-14027-3
Vol. 304.Anthony Finn and Lakhmi C. Jain (Eds.)
Innovations in Defence Support Systems, 2010
ISBN 978-3-642-14083-9
Vol. 305. Stefania Montani and Lakhmi C. Jain (Eds.)
Successful Case-based Reasoning Applications, 2010
ISBN 978-3-642-14077-8
Vol. 306. Tru Hoang Cao
Conceptual Graphs and Fuzzy Logic, 2010
ISBN 978-3-642-14086-0

Tru Hoang Cao
Conceptual Graphs and
Fuzzy Logic
A Fusion for Representing and Reasoning with
Linguistic Information
123

Tru Hoang Cao
Faculty of Computer Science & Engineering
Ho Chi Minh City University of Technology
268 Ly Thuong Kiet Street
District 10
Ho Chi Minh City
Vietnam
E-mail: tru@cse.hcmut.edu.vn
ISBN 978-3-642-14086-0
e-ISBN 978-3-642-14087-7
DOI 10.1007/978-3-642-14087-7
Studies in Computational Intelligence
ISSN 1860-949X
Library of Congress Control Number: 2010930135
c⃝2010 Springer-Verlag Berlin Heidelberg
This work is subject to copyright. All rights are reserved, whether the whole or part
of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse
of illustrations, recitation, broadcasting, reproduction on microﬁlm or in any other
way, and storage in data banks. Duplication of this publication or parts thereof is
permitted only under the provisions of the German Copyright Law of September 9,
1965, in its current version, and permission for use must always be obtained from
Springer. Violations are liable to prosecution under the German Copyright Law.
The use of general descriptive names, registered names, trademarks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such
names are exempt from the relevant protective laws and regulations and therefore
free for general use.
Typeset & Cover Design: Scientiﬁc Publishing Services Pvt. Ltd., Chennai, India.
Printed on acid-free paper
9 8 7 6 5 4 3 2 1
springer.com

For my family

Preface 
Form without content is empty. Content without form is so  
indeterminate that it cannot be grasped as an object of knowledge. 
JOHN HIBBEN, Hegel’s Logic: An Essay in Interpretation
The research for my Master’s thesis and that for my PhD were related to the two 
separate theories that I later on recognized to have the common target of repre-
senting and reasoning with linguistic information. They are conceptual graphs in-
vented by John Sowa and fuzzy logic founded by Lofti Zadeh. These two theories 
are both very important if we are to design computer systems that can capture and 
reason with linguistic information as humans can.  
The capacity for humans to communicate using language allows us to give, re-
ceive, and understand information expressed within a rich and flexible representa-
tional framework. Moreover, we can reason based on natural language expres-
sions, and make decisions based on the information they convey, though this 
information usually involves imprecise terms and uncertain facts. Anyhow, for a 
computer with the conventional processing paradigm to process linguistic infor-
mation, a formalism is required.  
Such a formal language needs to have both a “body” that could smoothly match 
with the syntax of natural language expressions, and a “soul” that could deal with 
the semantics of imprecise and uncertain linguistic information. At this crossroad, 
conceptual graphs provide a syntactic structure for a smooth mapping to and from 
natural language, while fuzzy logic provides a semantic processor for approximate 
reasoning with words having vague meanings.  
This volume is the combined result of my research for the past few years, 
which has focused on the combination of conceptual graphs and fuzzy logic for 
various knowledge and information processing tasks that involves natural lan-
guage. First, it is about fuzzy conceptual graphs and their logic programming 
foundations, as a graph-based order-sorted fuzzy set logic programming language 
for automated reasoning with fuzzy object attributes and types. Second, it extends 
conceptual graphs with general quantifiers and develops direct reasoning opera-
tions on these extended conceptual graphs, which could be mapped to and from 
generally quantified natural language statements. Third, it defines similarity and 
subsumption measures between object types, names, and attributes and uses them 
for approximate retrieval of knowledge represented in graphs. Finally, it proposes 
a robust ontology-based method for understanding natural language queries using 
nested conceptual graphs. 

Preface
VIII 
Engaged in this interdisciplinary research, I have had opportunities to partici-
pate in both the research communities of conceptual graphs and fuzzy logic, and 
met with the colleagues and students whom I would like to thank for their contri-
bution to this book in one way or another over the years: 
- Vilas Wuwongse and Peter Creasy, my Master’s and PhD advisors, for their 
guidance at the beginning of my research.  
- James Baldwin, Trevor Martin, and Jonathan Rossiter for the valuable period 
of the Fril++ project in which I applied the developed order-sorted fuzzy set 
logic programming theory.  
- Lofti Zadeh and Masoud Nikravesh for hosting my research visit at BISC 
when I first came up with the idea of using fuzzy conceptual graphs for the 
Semantic Web. 
- Bikash Ghosh, Hung Wing, Robert Colomb, John Sowa, Michel Chein, 
Marie-Laure Mugnier, Eric Salvat, Gerard Ellis, Guy Mineau, Rudolf Wille, 
Jonathan Lawry, and Elie Sanchez for their fruitful discussions on the topics 
covered in this volume. 
- My students who have directly worked with me on projects relating to the 
recent development and applications of fuzzy conceptual graphs. 
In particular in writing this book, I am sincerely grateful to Hung Nguyen and 
Janusz Kacprzyk for their kind support and encouragement.  I would also like to 
thank Thomas Ditzinger, Heather King and the Springer production team for their 
dedication and professional expertise in the publishing process. 
May 2010 
Cao Hoàng Trө

Contents
Contents
1 
Introduction……………………………........................................................1 
         1.1   Motivation and Outline...........................................................................1 
         1.2   Symbol and Abbreviation Conventions..................................................4 
2 
Fuzzy Conceptual Graphs…………….........................................................5 
         2.1   Overview ................................................................................................5 
         2.2   Conceptual Graphs..................................................................................6 
         2.3   Functional Relation Types and Conjunctive Types ..............................11 
         2.4   Extended Conceptual Graphs................................................................14 
         2.5   Fuzzy Sets and Fuzzy Logics................................................................18 
         2.6   Fuzzy Types..........................................................................................26 
         2.7   Fuzzy Conceptual Graphs.....................................................................36 
         2.8   Summary...............................................................................................44 
3 
Annotated Fuzzy Logic Programming………………….……….……....47 
         3.1   Overview ..............................................................................................47 
         3.2   AFLP Syntax ........................................................................................49 
         3.3   AFLP Model-Theoretic Semantics .......................................................52 
         3.4   AFLP Fixpoint Semantics.....................................................................56 
         3.5   AFLP Reductants and Constraints........................................................59 
         3.6   AFLP Procedural Semantics.................................................................63 
         3.7   Order-Sorted AFLPs.............................................................................66 
         3.8   Generalized and Specialized AFLPs.....................................................71 
         3.9   Summary...............................................................................................78 
4 
Fuzzy Conceptual Graph Programming……………...…………………..79 
         4.1   Overview ..............................................................................................79 
         4.2   FCGP Syntax ........................................................................................80 
         4.3   FCGP Model-Theoretic Semantics.......................................................84 
         4.4   FCGP Fixpoint Semantics ....................................................................88 
         4.5   General Issues of CG Unification and Resolution................................91 
         4.6   FCG Unification and FCGP Reductants...............................................96 
         4.7   FCGP Procedural Semantics.................................................................99 
         4.8   Summary.............................................................................................103 

Contents
X
5 
Modelling and Computing with Generally Quantified Statements...…105 
         5.1   Overview ............................................................................................105 
         5.2   Fuzzy Arithmetic ................................................................................107 
         5.3   Fuzzy Conditional Probability............................................................111 
         5.4   Universally Quantified Conceptual Graphs ........................................112 
         5.5   Generally Quantified Conceptual Graphs...........................................117 
         5.6   Computing with Linguistic Quantifiers ..............................................120 
         5.7   Summary.............................................................................................124
6 
Approximate Knowledge Retrieval………………...…………………...127 
         6.1   Overview ............................................................................................127 
         6.2   Matching Measures for Entity Types, Names, and Attributes ............128 
         6.3   Storing and Querying Knowledge Graphs..........................................134 
         6.4   Approximate Knowledge Graph Matching.........................................138 
         6.5   Knowledge Management in VN-KIM ................................................141 
         6.6   Summary.............................................................................................144 
7 
Natural Language Query Understanding……………………….……...145 
         7.1   Overview ............................................................................................145 
         7.2   Ontology-Based Information Retrieval...............................................146 
         7.3   Nested Query Conceptual Graphs.......................................................151 
         7.4   Ontology-Based Query Understanding...............................................154 
         7.5   Evaluation Experiments......................................................................161 
         7.6   VN-KIM Search..................................................................................163 
         7.7   Summary.............................................................................................166
Appendices .........................................................................................................167 
         A.1   Proofs for Chapter 2...........................................................................167 
         A.2   Proofs for Chapter 3...........................................................................174 
         A.3   Proofs for Chapter 4...........................................................................181 
         A.4   Proofs for Chapter 5...........................................................................185 
References ..........................................................................................................193 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 1–4. 
springerlink.com          © Springer-Verlag Berlin Heidelberg 2010 
Chapter 1 
Introduction 
1.1   Motivation and Outline 
Natural language is a principal and important means of human communication. It 
is used to express information as inputs to be processed by human brains then, 
very often, outputs are also expressed in natural language. How humans process 
information represented in natural language is still a challenge to science, in gen-
eral, and to Artificial Intelligence, in particular. However, it is clear that, for a 
computer with the conventional processing paradigm to process natural language, 
a formalism is required. For reasoning, it is desirable that such a formalism be a 
logical one. 
A logic for handling natural language should have not only a structure of for-
mulas close to that of natural language sentences, but also a capability to deal with 
the semantics of vague linguistic terms pervasive in natural language expressions. 
Conceptual graphs (CGs) (Sowa 1976; 1984) and fuzzy logic (Zadeh 1965; 1975a) 
are two logical formalisms that emphasize the target of natural language, each of 
which is focused on one of the two mentioned desired features of a logic for han-
dling natural language. While a smooth mapping between logic and natural lan-
guage has been regarded as the main motivation of conceptual graphs (Sowa 1991; 
1997), a methodology for computing with words has been regarded as the main 
contribution of fuzzy logic (Zadeh 1978b; 1996). 
Conceptual graphs, based on semantic networks and Peirce’s existential graphs, 
combine the visual advantage of graphical languages and the expressive power of 
logic. On the one hand, the graphical notation of conceptual graphs is advanta-
geous for the representation of nested information and contexts whose representa-
tion in linear notations is difficult to follow. On the other hand, the formal  
order-sorted logic foundation of conceptual graphs provides a rigorous basis not 
only for reasoning processes performed directly on them, but also for justifying 
the soundness and the completeness of a reasoning procedure. Conceptual graphs 
have been used for solving problems in several areas such as, but not limited to, 
natural language processing, knowledge acquisition and management, database 
design and interface, and information systems. The current ISO standard includes 
the Conceptual Graph Interchange Format as one of the standard dialects for 
Common Logic, a framework for a family of logic based languages (Sowa 2008). 
Meanwhile, fuzzy logic, based on fuzzy set theory and possibility theory, has 
been developed for approximate representation of, and reasoning with, imprecise 
information often encountered in the real world as reflected in natural language. In 
particular, fuzzy logic deals with the partial truth as well as the possibility and  

2 
1   Introduction
 
necessity measures of uncertainty, contrasting with, and complementary to, the 
probability measures. Especially, vague linguistic terms, considered as information 
granules, can be denoted by fuzzy sets and then computed through fuzzy set opera-
tions. Originated from fuzzy logic, Computing with Words has emerged as a new 
computing paradigm towards incorporation of the flexibility and robustness of natu-
ral language descriptions into intelligent computer systems (Mendel et al. 2010). 
While there are still unresolved theoretical issues regarding the uncertainty 
management problem, in general, and fuzzy logic, in particular, fuzzy logic has 
been successfully applied to several areas, such as fuzzy control, expert systems, 
knowledge acquisition and fusion, decision making, and information retrieval, 
among others. For the Semantic Web (Berners-Lee, Hendler and Lassila 2001), 
Sheth, Ramakrishnan, and Thomas (2005) advocated that it would need not only a 
formal semantics of logic, but also a powerful (or soft) semantics to deal with im-
precision and uncertainty of the real world for which fuzzy logic is a key partner. 
A medium for human expression is one of the five roles that Davis, Shrobe and 
Szolovits (1993) argued for a knowledge representation, as “a language in which 
we say things about the world”. While natural language is a language that humans 
essentially use in daily life not only for expressing things but also for thinking and 
reasoning, it is too informal to be fully processed by computers. Thus, a logic with 
a smooth mapping to and from natural language like conceptual graphs is really an 
advance in knowledge representation. It compromises the medium for human ex-
pression role and the medium for machine computation role, which is another of 
the five roles that the authors argued for a knowledge representation. 
Sowa (1991) showed that natural language expressions with quantifying words 
like many, few or most could be smoothly represented in conceptual graphs but not 
in predicate logic. However, the classical logic semantics of conceptual graphs 
cannot interpret and reason with such generalized quantifiers, which are intrinsi-
cally vague. It was fuzzy logic that provided a methodology to deal with the 
vagueness and imprecision of such words (Zadeh 1983). 
However, although conceptual graphs and fuzzy logic have the common target 
of natural language, until recently they were studied and developed quite sepa-
rately. Their combination would be a great advantage towards a knowledge repre-
sentation language that can approach the expressive power of natural language. At 
this juncture, conceptual graphs provide a syntactic structure for a smooth map-
ping to and from natural language, while fuzzy logic provides a semantic proces-
sor for approximate reasoning with words having vague meanings. 
To that end, in this volume, first we formulate a framework of fuzzy types to 
represent both partial truth and uncertainty about concept and relation types in 
conceptual graphs. Like fuzzy attribute values, fuzzy types also form a lattice lay-
ing a common ground for lattice-based computation of fuzzy granules. Second, for 
automated reasoning with fuzzy conceptual graphs, we develop foundations of or-
der-sorted fuzzy set logic programming, extending the theory of annotated logic 
programs of Kifer and Subrahmanian (1992). Third, we show some recent applica-
tions of fuzzy conceptual graphs to modelling and computing with generally quan-
tified statements, approximate knowledge retrieval, and natural language query 
understanding.  

1.1   Motivation and Outline 
3
 
Here, since the term fuzzy logic has been used for different logic systems that 
have originated from the theory of fuzzy sets but with very different characteris-
tics, we use the term fuzzy set logic for one that involves fuzzy set values in for-
mulas. This is to be distinguished from partial truth-valued logic and possibilistic 
logic, where formulas are associated with real numbers in the interval [0, 1], inter-
preted as truth degrees or uncertainty degrees, respectively. 
Chapter 2 presents the formulation of fuzzy conceptual graphs. Section 2.2 
summarizes the basic notions of conceptual graphs. Sections 2.3 and 2.4 introduce 
the notions of functional relation types and conjunctive types, and extension of 
conceptual graphs with them. Section 2.5 presents the fundamentals of fuzzy set 
theory and fuzzy logics. Section 2.6 formulates fuzzy types for order-sorted fuzzy 
set logic programming and formulation of fuzzy conceptual graphs (FCGs). Sec-
tion 2.7 formally defines fuzzy conceptual graphs and their operations. 
Chapter 3 presents the framework of annotated fuzzy logic programs (AFLPs) 
for fuzzy set logic programming. Sections 3.2 and 3.3 formally define the syntax 
and the model-theoretic semantics of AFLPs. Section 3.4 studies the fixpoint se-
mantics of AFLPs as a bridge between their declarative and procedural semantics. 
In Section 3.5, AFLP reductants, which are used instead of clauses in AFLP reso-
lution steps, and fuzzy set value constraints are defined and their properties stud-
ied. Then, in Section 3.6, an SLD-resolution style proof procedure for AFLPs is 
developed and proved to be sound and complete with respect to AFLP declarative 
semantics. Section 3.7 extends AFLP to order-sorted fuzzy set logic programming 
with fuzzy types as lattice-based annotations. Section 3.8 generalizes order-sorted 
AFLPs with clauses weighted by certainty degrees in [0, 1], and specializes  
them with only special fuzzy truth-values representing truth, possibility or neces-
sity degrees. 
Chapter 4 presents FCG programs as a graph-based version of order-sorted 
fuzzy set logic programs. FCGP syntax and model-theoretic semantics are for-
mally defined in Sections 4.2 and 4.3, respectively. Section 4.4 studies the fixpoint 
semantics of FCG programs as a bridge between their declarative and procedural 
semantics. Section 4.5 discusses general issues that are common to both FCG pro-
gramming and CG programming. Section 4.6 defines FCG unification and FCGP 
reductants. Then, in Section 4.7, an SLD-resolution style proof procedure using 
graph operations for FCG programs is developed and proved to be sound and 
complete with respect to their declarative semantics.  
Chapter 5 presents an application of fuzzy conceptual graphs for linguistic 
quantifier modelling and reasoning. Sections 5.2 and 5.3 present the basics of 
fuzzy arithmetic and fuzzy conditional probability that are used in computing with 
generalized quantifiers. Section 5.4 extends existential conceptual graphs with 
universal quantifiers and defines direct operations on them. Sections 5.5 intro-
duces generalized quantifiers into fuzzy conceptual graphs and Section 5.6 defines 
reasoning mechanism on them.  
Chapter 6 presents an application of fuzzy conceptual graphs for approximate 
knowledge retrieval. Section 6.2 defines matching measures for entity types, 
names, and attributes. Section 6.3 presents a framework for storing and querying 
knowledge using fuzzy conceptual graphs. Section 6.4 presents a method for  

4 
1   Introduction
 
approximate knowledge graph matching. Section 6.5 introduces VN-KIM system 
and knowledge management in it. 
Chapter 7 presents an application of fuzzy conceptual graphs for understanding 
natural language queries. Section 7.2 presents models of ontology-based informa-
tion retrieval that exploit entity features for semantic search. Section 7.3 defines 
nested fuzzy conceptual graphs to represent queries. Section 7.4 presents an ontol-
ogy-based method to map a natural language query to a fuzzy conceptual graph 
for knowledge retrieval. Section 7.5 introduces VN-KIM Search, a semantic 
search engine that employs the presented ontology-based information retrieval 
models and natural language query processing method. 
Each chapter from Chapter 2 to Chapter 7 has an overview and a summary of 
the contents of the chapter. The proofs of the propositions and theorems in the 
chapters are presented in the Appendices, except for those that are obvious from, 
or are direct consequences of, other propositions and theorems. 
1.2   Symbol and Abbreviation Conventions 
The following general symbols are used throughout this volume: 
⊆  
: the classical/fuzzy subset relation 
∩ 
: the classical/fuzzy set intersection operator 
∪ 
: the classical/fuzzy set union operator 
≤ 
: the real number less-than-or-equal-to relation 
max : the real number maximum function 
min : the real number minimum function 
sup 
: the real number supremum function 
inf 
: the real number infimum function 
lub 
: the lattice least upper bound function  
glb 
: the lattice greatest lower bound function  
N 
: the set of all non-negative integers 
Z 
: the set of all integers 
R 
: the set of all real numbers. 
We especially use ≤ι as the common symbol for all orders used in this volume, 
under the same umbrella of information ordering, whereby A ≤ι B (or, equiva-
lently, B ≥ι A) means B is more informative, or more specific, than A. In particular, 
we write A ≤ι B if B is a subtype of A. It will be clear in a specific context which 
order this common symbol denotes. Also, we will write A <ι B (or, equivalently,  
B >ι A) to indicate that  A ≤ι B and A ≠ B.  
The following abbreviations are used throughout this volume: 
iff  : “if and only if” 
wrt : “with respect to”. 
Also, for simplicity, we may use ’s to denote a sequence of indexed expressions, 
e.g. Ei’s denoting E1, E2, ... . 
 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 5– 45. 
springerlink.com             © Springer-Verlag Berlin Heidelberg 2010 
Chapter 2 
Fuzzy Conceptual Graphs 
2.1   Overview 
Morton (1987), applying fuzzy set theory and fuzzy logic, first researched an ex-
tension of conceptual graphs (CGs) to represent and reason with the pervasive 
vagueness and imprecision of the real world reflected in natural language. The au-
thor considered perceptual fuzziness, linguistic fuzziness and propositional fuzzi-
ness for the concept types ENTITY, ATTRIBUTE and INFORMATION, respectively.  
Perceptual fuzziness expressed compatibility degrees of entities to concept 
types by real numbers in [0, 1], due to partial matching in perception processes. 
Linguistic fuzziness expressed vague attributes, which might be metric or non-
metric, by fuzzy sets. An example of a metric attribute is the age of a person, 
which may have vague values like young or not very young. An example of a non-
metric attribute is the colour of a tomato, whose value is usually vague like red or 
fairly red. Propositional fuzziness expressed compatibility degrees of CGs repre-
senting propositions or situations to the logical value true, by real numbers in [0, 
1]. The author also extended CG operations, inference rules and model theory in 
Sowa (1984) for fuzzy conceptual graphs. 
Later, Wuwongse and Manzano (1993) extended Morton’s work with fuzzy re-
lations, i.e., those with certainty degrees in [0, 1]. Wuwongse and Cao (1996) then 
introduced into fuzzy conceptual graphs (FCGs) fuzzy truth-values, which could 
denote linguistic truth-values as more usually expressed by humans than values in 
[0, 1]. This enriches the semantics of fuzzy conceptual graphs, because fuzzy 
truth-values subsume both partial truth and uncertainty, and a truth, possibility or 
necessity degree in [0, 1] can be represented as a special fuzzy truth-value. This 
also results in the homogeneity of vague data in fuzzy conceptual graphs, which 
are all defined by fuzzy sets and can be treated in the same way.  
Due to different truth-characteristics, the information or specificity order be-
tween two fuzzy entity concepts or two fuzzy relations is not simply defined inde-
pendently by the concept or relation subtype order and the fuzzy subset order. For 
example, the concept [AMERICAN_MAN: John | very true] intuitively implies the 
concept [MAN: John | true], but the concept [MAN: Mary | very false] implies the 
concept [AMERICAN_MAN: Mary | false]. Thus, it is more convenient for both theo-
retical study and machinery computation to group a type and a fuzzy truth-value 
into one lattice-based value as a fuzzy type (Cao, Creasy and Wuwongse 1997; 
Cao and Creasy 2000). 
The introduction of fuzzy types makes the structure of FCGs the same as that of 
CGs, where the main difference is only that CGs are based on basic concept types 

6 
2   Fuzzy Conceptual Graphs
 
and basic relation types, whereas FCGs are based on fuzzy concept types and 
fuzzy relation types. Thus, CG operations, such as projection or normalization, 
can be generalized in a straightforward manner for fuzzy conceptual graphs. More 
importantly, it lends the perspective of granular computing (Zadeh 1997) on fuzzy 
conceptual graphs, where fuzzy types are treated as lattice-based information 
granules like concept and relation types and fuzzy attribute values (Cao 2002). 
The contents of this chapter are organized as follows. Section 2.2 presents the 
basic notions of conceptual graphs (cf. Sowa 1984; Chein and Mugnier 2008). 
Section 2.3 introduces functional relation types, conjunctive concept types and 
conjunctive relation types, and then Section 2.4 extends conceptual graphs with 
them. Section 2.5 presents the fundamentals of fuzzy set theory and fuzzy logic 
(cf. Klir and Yuan 1995; Nguyen and Walker 2005). Section 2.6 formulates fuzzy 
types and Section 2.7 using them to generalize CGs to FCGs. Finally, Section 2.8 
concludes the chapter. 
2.2   Conceptual Graphs  
Syntax 
A conceptual graph is a bipartite graph whose two disjoint sets are one of concept 
vertices and the other of (conceptual) relation vertices, where edges connect rela-
tion vertices to concept vertices. Each concept vertex is drawn as a rectangle and 
labelled by a pair of a concept type and a concept referent, representing an entity 
whose type and referent are respectively defined by the concept type and the con-
cept referent in the pair. Each relation vertex is drawn as an oval and labelled by a 
relation type, representing a relation of the entities represented by the concept ver-
tices connected to it. Those concepts that are connected to a relation are called 
neighbour concepts of the relation. Each edge is labelled by a positive integer and, 
in practice, may be directed just for readability.  
Figure 2.2.1 is an example CG expressing “John studies a subject in Computer 
Science (CS)”. Here, for simplicity, the labels of the edges are not shown. In a tex-
tual format, concepts and relations can be respectively written in square and round 
brackets as follows: 
[STUDENT: John]→(STUDY)→[SUBJECT: ∗]→(IN)→[FIELD: CS] 
In this example, [STUDENT: John], [SUBJECT: ∗], [FIELD: CS] are concepts with 
STUDENT, SUBJECT and FIELD being concept types, whereas (STUDY) and (IN) are 
relations with STUDY and IN being relation types. The concepts respectively repre-
sent “John is a student”, “There is a subject”, and “CS is a field of study”. Mean-
while, the relations represent “The subject is in CS” and “John studies the  
subject”, respectively. 
 
 
Fig. 2.2.1 An example CG 

2.2   Conceptual Graphs 
7
 
The referents John and CS of the concepts [STUDENT: John] and [FIELD: CS] are 
called individual markers and the concepts are called individual concepts. The ref-
erent * of the concept [SUBJECT: ∗] is called a generic marker referring to an un-
specified entity and the concept is called a generic concept. In this volume, two 
concepts with two different individual markers are assumed to refer to two differ-
ent entities, while concepts with the same individual marker are assumed to refer 
to the same entity. 
To denote that two generic concepts refer to the same unspecified entity, a 
coreference link is drawn as a dotted line segment connecting them. For example, 
the below CG in Figure 2.2.2 expresses “There is a person who studies the same 
subject as John does”. In this example, the two concepts [SUBJECT: *] can be 
joined into a single one, without the need to use a coreference link. However, 
when concepts occur in different contexts, such as negative contexts, they cannot 
be joined. Two concepts are said to be coreferent if they refer to the same entity, 
that is, they have the same individual marker or they are connected by a corefer-
ence link. In the textual format, common variable symbols are used to link 
coreferent generic concepts. 
 
Fig. 2.2.2 A CG with a coreference link 
Corresponding to the notion of types (or sorts) in order-sorted predicate logic, 
concept types are partially ordered by the concept subtype order. We view it as an 
information order or specificity order in the sense that, given two concept types t1 
and t2 where t2 is a concept subtype of t1, a fact “Object x is of type t2” is more in-
formative and more specific than “Object x is of type t1”. So we write t1 ≤ι t2 to 
denote that t2 is a concept subtype of t1, e.g. PERSON ≤ι STUDENT. 
Relation types are also partially ordered. For example, with the CG in Figure 
2.2.1, one may have STUDY as a subtype of a relation type ACT, written as ACT ≤ι 
STUDY. However, for relation types there are additional issues that need to be con-
sidered. Firstly, each relation type has an arity, which defines the fixed number of 
edges incident to a relation of the relation type. Secondly, each relation type has 
argument types, each of which defines the least specific concept type for a concept 
to be attached to the corresponding edge incident to a relation of that relation type.  
Just as the notion of signature for a predicate in order-sorted predicate logic, we 
denote the signature of a relation type t by (t1, t2, ..., tn), where n is its arity and ti’s 
are its argument types. Then a relation of type t in a CG is said to be well-typed iff, 
for every i from 1 to n, the type of the concept connected to the relation by the 
edge labelled i is the same as or more specific than ti. For example, the signature 
of the relation type STUDY in the CG in Figure 2.2.1 can be (STUDENT, SUBJECT), 
with arity 2 and argument types STUDENT and SUBJECT for the edge labelled 1 and 

8 
2   Fuzzy Conceptual Graphs
 
the 
edge 
labelled 
2, 
respectively. 
Then 
the 
CG 
[PHD_STUDENT: 
John]→(STUDY)→[SUBJECT: *] is well-typed, but not the CG [PERSON: 
John]→(STUDY)→[SUBJECT: 
*], 
provided 
that 
PERSON 
≤ι 
STUDENT 
≤ι 
PHD_STUDENT. 
The question is whether two relation types of different arities or different ar-
gument types are comparable. We view a relation type as a type each entity of 
which is a tuple of entities of the argument types (being concept types) of the rela-
tion type. As such, a relation type is interpreted as a subset of the Cartesian prod-
uct of interpretations of its argument types. Thus, we assume relation types of  
different arities to be incomparable and an argument type of a relation type to be a 
subtype of the respective argument type of any supertype of that relation type. 
For a partial order on concept referents, which are basically individual markers 
and the generic marker only, it is simply that, for every individual marker i, * ≤ι i, 
and all individual markers are pairwise incomparable. Indeed, each individual 
marker represents an identified entity, so it is more informative and more specific 
than an unspecified one. Partially ordered sets of concept types, relation types, and 
concept referents form a CG signature. 
Semantics 
In the semantic aspect, Sowa (1984) gave two formal semantics of conceptual 
graphs. One is the predicate logic semantics defined through the operator Φ that 
maps a CG to a first-order predicate logic formula. The other is the CG-based se-
mantics for which the denotations of CGs are defined with respect to models rep-
resented by CGs themselves.  
Basically, Φ maps each concept or relation vertex of a CG to an atomic formula 
of first-order predicate logic, and the whole CG to the conjunction of those atomic 
formulas with all variables being existentially quantified. Each individual marker 
is mapped to a constant, each generic marker is mapped to a variable, and each 
concept or relation type is mapped to a predicate symbol. Each concept of type t 
and referent m is mapped to: 
p(Φ(m)) 
where p = Φ(t). Each relation of type t and neighbour concept referents m1, m2, ..., 
mn is mapped to: 
p(Φ(m1), Φ(m2), ..., Φ(mn)) 
where p = Φ(t). For example, if G is the CG in Figure 2.2.1, then Φ(G) is: 
∃x (student(John) ∧ subject(x) ∧ field(CS) ∧ study(John, x) ∧ in(x, CS)). 
A CG signature, with partially ordered sets of concept or relation types, is also 
mapped to formulas of first-order predicate logic. Each pair of concept types t1 
and t2 such that t1 ≤ι t2 is mapped to: 
∀x (p2(x) → p1(x)) 
where p1 = Φ(t1) and p2 = Φ(t2). Each pair of relation types t1 and t2 of arity n such 
that t1 ≤ι t2 is mapped to: 

2.2   Conceptual Graphs 
9
 
∀x1∀x2 ... ∀xn (p2(x1, x2, ..., xn) → p1(x1, x2, ..., xn)) 
where p1 = Φ(t1) and p2 = Φ(t2). For example, PERSON ≤ι STUDENT and ACT ≤ι 
STUDY are respectively mapped to the following formulas: 
∀x (student(x) → person(x)) 
and 
∀x∀y (study(x, y) → act(x, y)). 
For the CG-based semantics, a closed world model is defined as a set of normal 
CGs in which no individual marker occurs in more than one concept in the set. 
The denotation of a CG with respect to a model is evaluated to either true or false. 
It is defined through a fundamental operation in CG theory called CG projection, 
whereby it is true iff there is a projection from that CG to a CG in the model.  
A projection maps a CG to another more or equally specific one, by mapping 
each vertex of the former to a vertex of the latter that has a more or equally spe-
cific label. The label (t1, m1) of a concept is said to be more or equally specific 
than the label (t2, m2) of another concept iff t2 ≤ι t1 and m2 ≤ι m1. The label t1 of a 
relation is said to be more or equally specific than the label t2 of another relation 
iff t2 ≤ι t1. The mapping must also preserve the adjacency and position order of the 
neighbour concepts of a relation. That is, if a relation r2 of type t2 of arity n is 
mapped to a relation r1 of type t1 of the same arity then, for every i from 1 to n, the 
neighbour concept connected to r2 by the edge labelled i must be mapped to the 
neighbour concept connected to r1 by the edge labelled i. Figure 2.2.3 illustrates a 
CG projection from G to H. 
 
Fig. 2.2.3 A CG projection 
CG projection is reflexive and transitive. That is, every CG has a projection to 
itself and, given CGs G, H and F, if G has a projection to H and H has a projection 
to F, then G has a projection to F. However, in general, it is not anti-symmetric for 
arbitrary CGs as shown in Figure 2.2.4, where G and H have projections to each 
other but are not identical.  
 
Fig. 2.2.4 Non-antisymmetry of CG projection 

10 
2   Fuzzy Conceptual Graphs
 
As such, CG projection defines only a preorder (i.e., a reflexive and transitive 
relation) on CGs, which can also be regarded as an information or specificity or-
der, whereby if G has a projection to H, then G subsumes H or, in other words, H 
is more informative or more specific than G. Thus, given two CGs G and H, we 
write G ≤ι H to denote that G has a projection to H. As a preorder, CG projection 
also defines an equivalence relation (i.e., a reflexive, symmetric and transitive 
one) on CGs such that, two CGs G and  H are equivalent iff  G ≤ι H  and H ≤ι G. 
Logically, if a CG G has a projection to a CG H, then H implies G. This is 
called the soundness of CG projection. The completeness means that, if G is a 
logical consequence of H, then there is a projection from G to H. In general, CG 
projection is not complete for arbitrary CGs as shown in Figure 2.2.5, where G 
expresses “There is a person who respects himself/herself” and H expresses that 
for John in particular.  Here, H logically implies G, but there is no projection from 
G to H. However, if H is normalized into CG normal form like H*, in which no 
individual marker occurs in more than one concept as mentioned above for CG 
models, then there is a projection from G to H*.  
 
Fig. 2.2.5 CG normal form for the completeness of CG projection 
Actually, with respect to the first-order predicate logic semantics, a CG and its 
normal form are logically equivalent, and CG projection with target CGs in the 
normal form is sound and complete. That is, given a CG signature S and two CGs 
G and H where H is in the normal form, Φ(G) is a logical consequence of 
Φ(S)∧Φ(H) iff there is a projection from G to H (Chein and Mugnier 1995). 
The CG language described above is only basic CGs. For a full-fledged first 
order logic, nested CGs are needed to express negation of propositions. Firstly, a 
proposition is represented as a concept of type PROPOSITION whose referent is a 
CG describing that proposition. Then the negation of that proposition is repre-
sented by a relation of type NEG connected to the concept representing the proposi-
tion. Figure 2.2.6 illustrated a negated nested concept expressing “John does not 
study subject CS312”. For simplicity, ¬ is used to denote a NEG relation. For ex-
ample, the nested CG in Figure 2.2.7 expresses “Every student studies some  
 
 
Fig. 2.2.6 A negated nested concept 

2.3   Functional Relation Types and Conjunctive Types 
11
 
 
Fig. 2.2.7 A nested CG 
subject”, where a negated concept is nested inside another negated concept. With 
the notion of nested CGs, conceptual graphs can be further extended to modal and 
higher-order logic ones. 
2.3   Functional Relation Types and Conjunctive Types 
Functional Relation Types 
A functional relation is a special relation that imposes a constraint that the entities 
of some concepts of the relation, which we call dependent concepts, are uniquely 
determined by the entities of the other concepts, which we call determining con-
cepts. Such a functional dependency is common in data conceptual schemes and 
databases, as well as ontologies and knowledge bases.  
A functional relation type declared in a CG signature imposes the uniqueness 
constraint on any of its occurrences in CGs. In this volume, we do not apply a dis-
tinct notation for functional relation types, but have a convention that, for a func-
tional relation, the concepts attached to the edges drawn by arrows directed to the 
relation are the determining concepts, and those attached to the edges drawn by ar-
rows directed out are the dependent concepts. Also, for a functional relation type 
of arity n with m determining arguments and n − m dependent arguments, the 
edges incident to the determining concepts are labelled from 1 to m, and those in-
cident to the dependent concepts from m + 1 to n. For example, the CG in Figure 
2.3.1 expresses “John is Mary’s father”, where FATHER is a functional relation 
type with signature (PERSON, MAN), [PERSON: Mary] is the determining concept, 
and [MAN: John] is the dependent concept. 
 
Fig. 2.3.1 A CG with a functional relation type 
For the first-order predicate logic semantics defined through Φ, each functional 
relation type is also mapped to a predicate symbol as any other relation type, but 
with a uniqueness constraint. For a functional relation type t of arity n with m de-
termining arguments and n − m dependent arguments, the constraint is: 

12 
2   Fuzzy Conceptual Graphs
 
∀x1∀x2 ... ∀xm∀xm+1∀xm+2 ... ∀xn ∀ym+1∀ym+2 ... ∀yn  
(p(x1, x2, ..., xm, xm+1, xm+2, ..., xn) ∧ p(x1, x2, ..., xm, ym+1, ym+2, ..., yn)  
→ xm+1 = ym+1 ∧ xm+2 = ym+2 ∧ ... ∧ xn = yn)  
where p = Φ(t). For example, the uniqueness constraint associated with FATHER is: 
∀x∀y∀z (father(x, y) ∧ father(x, z) → y = z). 
As a consequence, given two relation types t1 and t2, if t1 is functional and t1 ≤ι 
t2, then t2 must also be functional. For example, given REAL_SQR and 
INTEGER_SQR as the square relations between real numbers and integers, respec-
tively, one has REAL_SQR is functional and REAL_SQR ≤ι INTEGER_SQR, and thus 
INTEGER_SQR is also functional.  However, the inverse does not hold, that is, if t2 
is functional and t1 ≤ι t2, then t1 is not necessarily functional. For example, given 
COMPLEX_SQRT and REAL_SQRT as the square root relations between complex 
numbers and real numbers, respectively, one has COMPLEX_SQRT ≤ι REAL_SQRT 
and REAL_SQRT is functional, but COMPLEX_SQRT is not. 
Conjunctive Types 
Usually, an object belongs to two or more types that do not have the subtype rela-
tionship. Always assuming a single type as the intersection of those types for such 
an object would demand an exponential number of type labels when the size of a 
basic type set grows (Aït-Kaci and Nasr 1986) and, more importantly, such a type 
would not be conceptually relevant (Wermelinger and Lopes 1994). Beierle et al. 
(1992) addressed the issue by distinguishing two interpretations of a type lattice, 
namely, lattice-theoretic and order-theoretic.  
An interpretation of a type is a set of objects defined to belong to the type. With 
the lattice-theoretic interpretation, the least specific common subtype of two types 
is interpreted by the intersection of their interpretations. In contrast, with the or-
der-theoretic interpretation, it is interpreted by only a subset of that intersection. 
Figure 2.3.2 shows an example type hierarchy and illustrates the difference  
between the two ways of interpreting a type lattice, where δ(t) denotes an interpre-
tation set of a type t. As discussed by Beierle et al. (1992), an order-theoretic in-
terpretation is more appropriate for applications in Artificial Intelligence than a 
lattice-theoretic one. 
Indeed, for instance, a building sight (an object of both BUILDING and SIGHT) is 
not necessarily a building worth seeing (an object of BUILDING_WORTH_SEEING). 
Meanwhile, it is not always conceptually relevant to use a type label as the inter-
section of every pair of types in a type hierarchy, such as the label 
BUILDING_SIGHT used in place of BUILDING_WORTH_SEEING in this example. 
Moreover, that would produce an exponential number of type labels.  
Therefore, with the order-theoretic interpretation, one cannot assign the type 
label BUILDING_WORTH_SEEING to St. Lucia, for example, to preserve the informa-
tion of both the facts that “St. Lucia is a building” and “St. Lucia is a sight”. For  
 

2.3   Functional Relation Types and Conjunctive Types 
13
 
 
Fig. 2.3.2 Lattice-theoretic and order-theoretic interpretations of a type lattice 
conceptual graphs, that means the two concepts [BUILDING: St. Lucia] and [SIGHT: 
St. Lucia] cannot be joined into the concept [BUILDING_WORTH_SEEING: St. Lucia] 
as their logical consequence.  
Instead of requiring such a type label, a natural way is to use {BUILDING, 
SIGHT} as a  syntactically constructed conjunctive type to join the two concepts  
into [{BUILDING, SIGHT}: St. Lucia], which clearly says what the two concepts ex-
press, that is, “St. Lucia is a building and a sight”. This notion of conjunctive 
types is necessary for joining CGs not only when the interpretation of a concept 
type lattice is order-theoretic as exemplified above, but also when just a partially 
ordered set rather than a lattice of concept types is assumed in a CG signature. 
Moreover, as pointed out in Baget (2003), conjunctive types are useful for obtain-
ing efficient CG projection. 
As in Carpenter (1992), given a partially ordered set of concept types, a con-
junctive concept type is a non-empty finite set of pairwise incomparable concept 
types. Similarly, given a partially ordered set of relation types, a conjunctive rela-
tion type is a non-empty finite set of pairwise incomparable relation types of the 
same arity. Intuitively, the proposition “x is of {t1, t2, ..., tn}” means the conjunc-
tion of the propositions “x is of t1”, “x is of t2”, ..., and “x is of tn”. Therefore,  
under the same umbrella of information and specificity ordering, a conjunctive 
(concept or relation) type T2 is said to be a subtype of a conjunctive type T1, writ-
ten as T1 ≤ι T2, iff every type in T1 has at least one of its subtypes in T2.  
Given a non-empty finite set S of types, a type t1 is said to be redundant in S iff 
there is a type t2 in S such that t1 <ι t2. Let con(S) denote the conjunctive type con-
structed from S by removing all redundant types in S. Then con(T1∪T2) = lub{T1, 
T2} is the least upper bound (wrt ≤ι) of two conjunctive types T1 and T2. As such, 
the set of all conjunctive types on a basic type set forms an upper semi-lattice un-
der the conjunctive subtype partial order.  
In particular, a type can be regarded as a conjunctive type that contains only 
one type. Thus, for simplicity, one may omit the bracelet brackets in writing a 
conjunctive type when it contains only one type. For a conjunctive relation type, 
each of its argument types is defined to be the conjunctive concept type con-
structed from the corresponding argument types of its elementary relation types,  
 

14 
2   Fuzzy Conceptual Graphs
 
 
Fig. 2.3.3 A CG with conjunctive types 
using the function con introduced above. Figure 2.3.3 shows an example CG with 
conjunctive concept and relation types saying “John is a student and a teacher. He 
likes and studies a subject that interests him”.  
For the first-order predicate logic semantics of conceptual graphs with conjunc-
tive concept types and conjunctive relation types, the operator Φ is extended in a 
straightforward manner as follows. Each concept of type {t1, t2, ..., tk} and referent 
m is mapped to: 
p1(Φ(m)) ∧ p2(Φ(m)) ∧ ... ∧ pk(Φ(m)) 
where pi = Φ(ti) for every i from 1 to k. Each relation of type {t1, t2, ..., tk} and 
neighbour concept referents m1, m2, ..., mn is mapped to: 
p1(Φ(m1), Φ(m2), ..., Φ(mn)) ∧ p2(Φ(m1), Φ(m2), ..., Φ(mn)) ∧ ... ∧ 
            pk(Φ(m1), Φ(m2), ..., Φ(mn))  
where pi = Φ(ti) for every i from 1 to k. For example, let G be the CG in Figure 
2.3.3, then Φ(G) is: 
∃x (student(John) ∧ teacher(John) ∧ subject(x) ∧  
like(John, x) ∧ study(John, x) ∧ interest(x, John)). 
2.4   Extended Conceptual Graphs 
We now formally define the signature of a CG language including functional rela-
tion types. 
Definition 2.4.1. A CG signature is a triple (TC, TR, M) where: 
1. (TC, ≤ι) is a partially ordered set of concept types. 
2. (TR, ≤ι) is a partially ordered set of relation types with the following decla-
ration for every t∈TR: 
(i)  arity(t) is a positive integer that defines the arity of t, and  
(ii)  For every i∈{1, 2, ..., arity(t)}, arg_type(t, i)∈TC defines the argument 
type for the i-th argument of t. 
Relation types of different arities are incomparable and, given two relation 
types t1 and t2 of the same arity n, if t1 ≤ι t2 then arg_type(t1, i) ≤ι 
arg_type(t2, i) for every i∈{1, 2, ..., n}. 
A subset of TR comprises functional relation types and, given two relation 
types t1 and t2, if t1 is functional and t1 ≤ι t2, then t2 must also be functional. 
3. (M, ≤ι) is a partially ordered set of concept referents consisting of pairwise 
incomparable individual markers and the generic marker * as the least  
element.  

2.4   Extended Conceptual Graphs 
15
 
For a set of concept or relation types T, we denote the set of conjunctive types 
constructed from them by T+. Also, for a conjunctive relation type T = {t1, t2, ..., 
tk}, we define: 
arity(T) = arity(t1) = arity(t2) = ... = arity(tk) 
and 
arg_type(T, i)  
= con{arg_type(t1, i), arg_type(t2, i), ..., arg_type(tk, i)}∈TC
+  
for every i from 1 to arity(T). 
In this volume, simple CGs are defined as basic CGs extended with conjunctive 
concept types and conjunctive relation types as defined below.  
Definition 2.4.2. A simple CG wrt a CG signature (TC, TR, M) is a bipartite graph 
defined by a triple (VC, VR, E) where: 
1.  VC is a set of concept vertices, each of which is labelled by a conjunctive 
concept type in TC
+ and a concept referent in M. The type and the referent 
of each concept c∈VC are denoted by type(c) and referent(c), respectively. 
2.  VR is a set of relation vertices, each of which is labelled by a conjunctive 
relation type in TR
+. The type of each relation r∈VR is denoted by type(r). 
3.  E is a set of edges, each of which connects a relation vertex to a concept 
vertex. The number of edges incident to a relation r is arity(type(r)) and the 
edges are labelled from 1 to arity(type(r)). For every i from 1 to ar-
ity(type(r)), the concept connected to r by the edge labelled i is denoted by 
neighbour(r, i). 
The CG is said to be well-typed wrt the signature iff, for every r∈VR, 
arg_type(type(r), i) ≤type(neighbour(r, i)) for every i∈{1, 2, ..., arity(type(r))}. 
 
From now on, for simplicity, a simple CG may be shortly called a CG, unless it is 
emphasized or otherwise noted. Since conjunctive concept types and conjunctive 
relation types form partially ordered sets under the umbrella of information order-
ing, the principle of CG projection as presented in Section 2.2 is still applicable to 
CGs extended with them. In the following definition, VCG and VRG respectively 
denote the set of concepts and the set of relations in a CG G. 
Definition 2.4.3. Let G and H be two simple CGs. A CG projection from G to H 
is a mapping π: G → H such that: 
1.  ∀c∈VCG: type(c) ≤ι type(πc) and referent(c) ≤ι referent(πc), and 
2.  ∀r∈VRG: type(r) ≤ι type(πr) and  
∀i∈{1, 2, ..., arity(type(r))}: neighbour(πr, i) = πneighbour(r, i). 
Given two simple CGs G and H, with functional relation types, conjunctive 
concept types and conjunctive relation types, we also write G ≤ι H to denote that G 
has a projection to H. For  example,  Figure 2.4.1  illustrates  a  CG projection   
 

16 
2   Fuzzy Conceptual Graphs
 
 
Fig. 2.4.1 A CG projection with functional relation and conjunctive types 
from G  to H, provided that PERSON ≤ι WOMAN, PARENT ≤ι MOTHER, and MOTHER 
is a functional relation type, where H says “Martina is a girl and a tennis player. 
She is a citizen of Switzerland. There is a woman who is her mother and coach”. 
As for the completeness of the basic CG projection, CG normal form is  
required for the extended CG projection. Due to the uniqueness constraint of func-
tional relation types and the use of conjunctive relation types, the normal form 
conditions have to be revised. 
Firstly, if the respective determining concepts of two relations of the same 
functional relation type coincide, then their respective dependent concepts are 
identical. It is also effective when the functional relation type of one relation is a 
subtype of the other’s, due to type inheritance. For example, in Figure 2.4.2, 
where REAL_SQR and INTEGER_SQR are functional relation types and REAL_SQR ≤ι 
INTEGER_SQR, the two dependent concepts in G are actually identical and can be 
unified into one concept vertex as in H. We note that, although G and H are se-
mantically equivalent, H cannot be projected to G. 
 
Fig. 2.4.2 Equivalent CGs with functional relation types 
Secondly, relations that have the same arity and have their respective neighbour 
concepts coinciding can be joined into one relation, whose type is the conjunctive 
relation type constructed from the types of the participating relations by the func-
tion con introduced in Section 2.3. For example, in Figure 2.4.3, G and H are 
equivalent, but there is no projection from H to G because {LIKE, STUDY} cannot 
be projected to LIKE or STUDY. 
 

2.4   Extended Conceptual Graphs 
17
 
 
Fig. 2.4.3 Equivalent CGs with conjunctive relation types 
CG normal form is now defined so that, if two relations of two functional rela-
tion types with one being a subtype of the other have their respective determining 
concepts coinciding, then their respective dependent concepts must coincide. Also, 
every tuple of concept vertices can be connected via at most one relation vertex. 
Definition 2.4.4. A simple CG G is said to be in CG normal form iff it satisfies the 
following conditions: 
1.  No two or more concepts in G have the same individual marker, and 
2.  No two or more relations of the same arity in G have the their respective 
neighbour concepts coinciding, and 
3.  There are no relations of types T1 and T2 in G such that: 
(i) {t} ≤ι T1 and {t} ≤ι T2 for some functional relation type t, and 
(ii) The two relations have their respective determining concepts (wrt t) co-
inciding. 
A CG G can be normalized, i.e., translated into CG normal form, by the following 
procedure: 
1. For every set S of concepts that have the same individual marker in G, join 
them into one concept, using the conjunctive concept type: 
T = con(∪c∈S type(c)) = lub{type(c) | c∈S}  
for the resulting concept. 
2.  While there is still a relation of type T1 and a relation of type T2 in G such 
that: 
(i)  {t} ≤ι T1 and {t} ≤ι T2 for some functional relation type t, and 
(ii) The two relations have their respective determining concepts (wrt t) co-
inciding,  
join their respective dependent concepts as in step 1. If any pair of the re-
spective dependent concepts have different individual markers, then quit 
with a failure. 
3. For every set S of relations of the same arity that have their respective 
neighbour concepts coinciding in G, join them into one relation, using the 
conjunctive relation type: 
T = con(∪r∈S type(r)) = lub{type(r) | r∈S}  
for the resulting relation. 
 

18 
2   Fuzzy Conceptual Graphs
 
We note that step 2 may fail due to individual marker conflict in joining de-
pendent concepts of functional relations. Figure 2.4.4 illustrates a CG G and its 
normal form G*, where MOTHER is a functional relation type. 
 
Fig. 2.4.4 Extended CG normal form 
The following proposition states that, given a CG G, if its normal form 
norm(G) exists, then it is the least specific normal CG (modulo CG equivalence) 
that G has a projection to. Its significance is that, for a set S of CGs, if norm(S) ex-
ists, then it is the least normal upper bound (modulo CG equivalence) of S with re-
spect to the CG projection preorder. 
Proposition 2.4.1. Let G be a simple CG such that norm(G) exists. Then: 
1.  G ≤ι norm(G). 
2.  If G ≤ι G* and G* is normal, then norm(G) ≤ι G*. 
2.5   Fuzzy Sets and Fuzzy Logics 
Fuzzy Sets 
Often encountered in the real world, as reflected in natural language, are concepts 
that are vague in nature, like young or old, short or tall, cheap or expensive. These 
concepts, or their expressions in natural language, are vague in the sense that, in 
most contexts, there is no clear-cut boundary between them and not young or not 
old, not short or not tall, not cheap or not expensive, respectively (Honderich 
1995). In other words, the membership of an object in the extension of such a con-
cept is not a matter of “to be or not to be”, but rather a matter of degree.  
Classical set theory, in which the membership grade of an element in a set can 
only be either 0 or 1, is thus inadequate to deal with vague concepts. This was the 
main motivation of Zadeh (1965) founding fuzzy set theory that generalizes clas-
sical set theory by defining membership grades to be real numbers in the interval 
[0, 1]. Goguen (1967) then extended fuzzy sets to L-fuzzy sets where membership 
grades could be values in a lattice other than [0, 1]. 
For a classical set, an element is to be or not to be in the set or, in other  
words, the membership grade of an element in the set is binary. For a fuzzy set, 
the membership grade of an element in the set is expressed by a real number in the 
interval [0, 1]. 
 

2.5   Fuzzy Sets and Fuzzy Logics 
19
 
Definition 2.5.1. A fuzzy set A on a domain U is defined by a membership func-
tion μA from U to [0, 1]. It is said to be normal if supu∈U{μA(u)} = 1 or subnormal 
otherwise. 
Figure 2.5.1 illustrates two fuzzy sets A and B on a domain U being the interval [0, 
100], where A is a normal fuzzy set and B is a subnormal one. The fuzzy set A can 
represent a class of young ages, where the interval [0, 100] is assumed to be the 
range of human ages. Here, a person of 0 to 25 years of age is definitely in the 
class, a person of 40 to 100 years of age is definitely not, and the membership 
grade in the class of a person of 25 to 40 years of age is linearly decreasing from 1 
to 0. Just as the interpretation of a vague concept like young is context-dependent, 
the membership function of a fuzzy set representing it is also context-dependent. 
For instance, in one context, the range of ages for a person to be definitely young 
is [0, 25] but, in another context, the range may be [0, 30]. 
 
Fig. 2.5.1 Normal and subnormal fuzzy sets 
On one hand, a classical (or crisp) subset A of U can be considered as a special 
fuzzy set whose membership function is defined by ∀u∈U: μA(u) = 1 if u∈A or 
μA(u) = 0 otherwise. An empty classical set is a fuzzy set whose membership func-
tion has only value 0, denoted by ∅, and a universal classical set is a fuzzy set 
whose membership function has only value 1, denoted by U itself. In practice, for 
efficient computation, membership functions of triangular or trapezoidal diagrams 
are commonly used.  
On the other hand, a fuzzy set can be defined as a set of crisp sets called its α-
cuts. Indeed, for a fuzzy set A on a domain U, an α-cut of A with α∈[0, 1] is defined 
to be Aα = {u∈U | μA(u) ≥ α}, as illustrated in Figure 2.5.2, whence μA(u) = 
sup{α∈[0, 1] | u∈Aα} for every u∈U. Given α∈[0, 1], the strong α-cut of A is  
denoted and defined by Aα+ = {u∈U | μA(u) > α}, and A0+ is called the support of A. 
Intuitively, the α-cuts of A form the skeleton of its shape, so that when α varies 
from 0 to 1 they fully shape and thus determine A. Therefore, operations on fuzzy 
sets can be reduced to operations on their equivalent α-cut representations using 
existing methods of the classical set theory. The resulting α-cuts are then  
converted back to the corresponding fuzzy sets as the final results of the fuzzy set 
operations. That is the significance of introducing the α-cut notion. In particular, 
one approach to fuzzy arithmetic as presented later in Section 5.2, is based on  
α-cuts and the interval arithmetic. 

20 
2   Fuzzy Conceptual Graphs
 
 
Fig. 2.5.2 α-cuts of a fuzzy set 
When classical sets are considered as special fuzzy sets whose membership 
functions have values in {0, 1} only, the subset relation and the basic operations 
intersection, union and complement can be defined in terms of operations on {0, 
1}. The fuzzy subset relation and fuzzy set operations generalize those of classical 
sets with operations on [0, 1] instead. 
Definition 2.5.2. Let A and B be two fuzzy sets on a domain U. Then: 
1.  A is said to be a fuzzy subset of B, denoted by A ⊆ B, iff ∀u∈U: μA(u) ≤ 
μB(u). 
2.  The fuzzy intersection of A and B is a fuzzy set denoted by A∩B and de-
fined by: ∀u∈U: μA∩B(u) = min{μA(u), μB(u)}. 
3.  The  fuzzy union  of  A and B  is  a fuzzy set denoted by  A∪B  and defined 
by: ∀u∈U: μA∪B(u) = max{μA(u), μB(u)}. 
4.  The fuzzy complement of A is a fuzzy set denoted by Ã and defined by: 
∀u∈U: μÃ(u) = 1 − μA(u). 
The definitions above of fuzzy intersection, union and complement are the stan-
dard ones. In general, other functions with similar characteristics can be used  
instead of the min, max and minus ones. One can observe that the standard fuzzy 
intersection, union and complement on fuzzy sets whose membership grades are 
only either 0 or 1, i.e., reduced to classical sets, coincide with the corresponding 
classical set operations. That coincidence is also a desired property of other func-
tions for non-standard fuzzy set operations. 
We note that, according to Definition 2.5.2, neither the equality A∩Ã = ∅ nor 
the equality A∪Ã = U holds for every fuzzy set A, whereas they do for every clas-
sical set. The intuitive meaning of a fuzzy complement is that, if A represents the 
concept young, for instance, then Ã represents the concept not young. Whereas the 
opposite concept to young is old, which can be represented by a fuzzy set denoted 
by ¬A and defined by ∀u∈U: μ¬A(u) = μA(100 − u). Figure 2.5.3 illustrates the 
difference between fuzzy complement and fuzzy opposition. 
Fuzzy sets then served as a basis for possibility theory (Zadeh 1978a), which is 
a theory to deal with possibility and necessity, in contrast to probability. A key no-
tion of possibility theory is possibility distribution. Given a variable x and a fuzzy  
 

2.5   Fuzzy Sets and Fuzzy Logics 
21
 
 
Fig. 2.5.3 Fuzzy complement and fuzzy opposition 
set A on a domain U, if x takes a value u∈U then μA(u) measures the membership 
grade of x in the extension of the concept represented by A. In contrast, if the 
value of x is ill-defined by A as a fuzzy restriction on the values that x can take, 
then μA(u) measures the possibility for u∈U to be the value of x.  
Thereby, a fuzzy proposition “x is A”, i.e., one that involves fuzzy set values 
(Zadeh 1975a), induces a possibility distribution πx associated with x on U and de-
fined by: 
∀u∈U: πx(u) = μA(u) 
where πx(u) = 0 means that x = u is impossible and πx(u) = 1 means that x = u is 
completely possible. Then, we write πx := A. 
For example, given the concept young represented by the fuzzy set A in Figure 
2.5.3, if John’s age is 30, then the membership grade of John in the set of young 
persons is μA(30) = 1 − (30 − 25)/(40 − 25) = 2/3. In contrast, with the fuzzy 
proposition “John is young”, the possibility degree for John’s age to be 30 is 
πage(John)(30) = μA(30) = 2/3. As noted in Dubois and Prade (1980), although a pos-
sibility distribution function is the same as the membership function of the fuzzy 
set inducing it, the two functions have different underlying notions, as explained 
above. 
As for a fuzzy set, a possibility distribution πx of a variable x on a domain U is 
said to be normal if supu∈U{πx(u)} = 1 or subnormal otherwise. That πx is subnor-
mal implies a partial inconsistency about x, because it means that it is not com-
pletely possible for x to take any u∈U as its value, which is assumed to be in U. 
Also, in general, x can be a tuple of n variables x1, x2, ..., xn and U the Cartesian 
product U1 × U2 × ... × Un where, for every i from 1 to n, Ui is the domain of xi. 
Then, one has a joint possibility distribution of (x1, x2, ..., xn) on U1 × U2 × ... × Un. 
Given two classical sets A and B on the same domain and A is a subset of B, the 
fact that an object belongs to A is more specific and more informative than that an 
object belongs to B. Similarly, given two possibility distributions πx and πx* of a 
variable x on a domain U, if ∀u∈U: πx(u) ≤ πx*(u), then πx is said to be more spe-
cific than πx*. The intuition is that, every u∈U is then more possible to be a value 
of x with πx* than with πx, and thus πx* is less specific or less informative than πx 
with respect to the question “Which is the actual value of x?”. For example, let  
π1 := A1, π2 := A2 and π3 := A3 where A1, A2 and A3 are the fuzzy sets in Figure 2.5.4,  
 

22 
2   Fuzzy Conceptual Graphs
 
 
Fig. 2.5.4 Specificity of possibility distributions 
representing the concepts exactly 40, about 40 and between 30 and 50 years of 
age, respectively. Then, due to A1 ⊆ A2 ⊆ A3, π1 is more specific than π2 and π2 is 
more specific than π3.  
Therefore, the fuzzy set subtype relation can be put under the same umbrella of 
that information ordering as for the object subtype relation.  With this partial or-
der, the set of fuzzy sets on a domain forms a complete lattice as defined below. 
Definition 2.5.3. The set LU of fuzzy sets on a domain U forms a complete lattice 
where:  
1.  The partial order is defined by ∀A, B ∈ LU: B ≤ι A iff A ⊆ B, 
2. For a set S of fuzzy sets, lub(S) and glb(S) are fuzzy sets defined by: 
∀u∈U: μlub(S)(u) = infA∈S{μA(u)} 
∀u∈U: μglb(S)(u) = supA∈S{μA(u)}, 
3. The greatest element and the least element are respectively denoted by TU 
and ⊥U, whose membership functions are defined by ∀u∈U: μT(u) = 0 and 
∀u∈U: μ⊥(u) = 1. 
The elements TU and ⊥U correspond to absolutely inconsistent and absolutely un-
known information, respectively. For simplicity, from now on, we omit the sub-
script U of these two elements. 
Fuzzy Logics 
In the literature, the term fuzzy logic has been used for different logic systems that 
have originated from the theory of fuzzy sets. However, they may have so differ-
ent characteristics that they need to be distinguished to avoid confusion. Actually, 
fuzzy logic has grown up with two main trends. One trend is a continuation of 
multiple-valued logic (Rescher 1969) to deal with partial truth, where a value in 
[0, 1] associated with a formula has the meaning of a truth degree. We call fuzzy 
logic in this trend partial truth-valued logic, e.g. those of Pavelka (1979), Novák 
(1987) and Hájek (1995). The other trend is a development of fuzzy logic as a 
logic to deal with possibility in contrast to probability. Possibilistic logic, devel-
oped by Dubois and Prade (1988), also has formulas associated with values in [0, 
1], but their meaning is possibility or necessity degrees instead of truth degrees.  

2.5   Fuzzy Sets and Fuzzy Logics 
23
 
Zadeh himself coined the name fuzzy logic and developed fuzzy logic as a logic 
to deal with fuzzy propositions in general, i.e., ones that involve vague linguistic 
terms represented by fuzzy sets (Zadeh 1975a). We call a fuzzy logic whose for-
mulas involve fuzzy sets fuzzy set logic. Fuzzy logic programming systems, with 
respect to their underlying fuzzy logics, can also be roughly classified into two 
groups depending on whether they involve fuzzy sets in programs or not. This 
volume is concerned with fuzzy set logic programming systems with the funda-
mentals of a theorem prover. 
For reasoning with fuzzy sets as possibility distributions, the basic principles 
are the entailment principle (Zadeh 1979) and the principle of minimum specificity 
(Dubois and Prade 1987). The entailment principle states that, a possibility distri-
bution πx of a variable x entails any possibility distribution πx* that is less specific 
than πx. Meanwhile, by the principle of minimum specificity, if x is constrained by 
two possibility distributions π1 and π2, then the least specific possibility distribu-
tion of x is defined by πx(u) = min{π1(u), π2(u)} for every u in x’s domain, which 
subsumes all other possible solutions. 
Consequently, by the entailment principle, if A ⊆ B then “x is A” entails “x is 
B” and, by the principle of minimum specificity, if “x is A” and “x is B” then “x is 
A∩B”, where x is a variable and A and B are fuzzy sets on the same domain. For 
example, let the concepts young, not young, not old and middle-aged be repre-
sented by the fuzzy sets such that old ⊆ not young, as in Figure 2.5.3, and middle-
aged = not young∩not old. Then, by the entailment principle, “John is old” entails 
“John is not young” and, by the principle of minimum specificity, if “John is not 
young” and “John is not old” then “John is middle-aged”.  
A basic inference rule in logic is one of modus ponens. In fuzzy logic, given a 
fuzzy rule “y is H ← x is B” and a fuzzy fact “x is B*”, where x is a variable and B 
and B* are fuzzy sets on a domain U, and y is a variable and H is a fuzzy set on a 
domain V, the question is how H* in a conclusion “y is H*” is derived from B, B*, 
and H. It depends on the meaning of a fuzzy rule for which there are two different 
views. One is that the rule implies a relation between the possibility of x taking a 
value u∈U and that of y taking a value v∈V and, thus, defines a joint possibility 
distribution of (x, y) on U × V (cf. Zadeh 1979). We call this view the object-level 
one. The other view, which we call the meta-level one, is that the rule implies a re-
lation between a degree of some measure of “x is B” as a whole and that of “y is 
H” as a whole (cf. Magrez and Smets 1989).  
These two different views of fuzzy rules lead to different deduction mecha-
nisms for fuzzy modus ponens. For the object-level view, deduction is performed 
through conjunction and projection of possibility distributions whereas, for the 
meta-level view, it is through propagation, qualification and modification of de-
grees of some measure. The former involves more complex computation due 
to operations on joint possibility distributions on Cartesian products of fuzzy set 
domains, whereas the latter requires only operations on possibility distributions on 
single fuzzy set domains.  
In particular, for the meta-level view of fuzzy rules, there are two complemen-
tary notions that are the relative possibility degree and relative necessity degree 
 of a fuzzy proposition with respect to another one. The following definition was 

24 
2   Fuzzy Conceptual Graphs
 
proposed in Magrez and Smets (1989) and proved in Godo and Vila (1995) not to 
have counter-intuitive behaviour problems of other definitions. 
Definition 2.5.4. Let A and A* be two fuzzy sets on a domain U. The relative pos-
sibility degree and the relative necessity degree of A given A* are respectively de-
noted by Π(A | A*) and N(A | A*) and defined by: 
Π(A | A*) = supu∈U{max(0, μA(u) + μA*(u) − 1)} 
and 
N(A | A*) = 1 − Π(Ã | A*) = infu∈U{min{1, 1 + μA(u) − μA*(u)}}. 
The intuition is that, if N(A | A*) = 1, then “x is A*” fully entails “x is A”. Based on 
the notion of relative necessity degrees, Magrez and Smets (1989) established a 
mathematical framework to devise a meta-level fuzzy modus ponens model. In ac-
cordance with this, the basis of the model is that the certainty degree of the head 
(i.e., consequent) of a rule is determined by the certainty degree of the rule and the 
certainty degree of its body (i.e., antecedent): 
c(y is H) = ⊗(c(y is H ← x is B), c(x is B))                        (Eq. 2.5.1) 
where B and H are two fuzzy sets on domains U and V, respectively, c(p) stands 
for the certainty degree of a fuzzy proposition p, and ⊗ is a t-norm.  
Supposing that a fact “x is B*” is given and “y is H*” is the conclusion to be in-
ferred, c(y is H) and c(x is B) are defined by N(H | H*) and N(B | B*), respectively. 
Then, given C(y is H ← x is B) ≥ α, (2.5.1) gives: 
N(H | H*) ≥ ⊗(α, N(B | B*))                                  (Eq. 2.5.2) 
whence the least specific solution (in accordance with the principle of minimum 
specificity) for H* is derived as follows: 
H* = H+(1− ⊗(α, N(B | B*)))                                (Eq. 2.5.3) 
where, for ε∈[0, 1], H+ε is defined by: 
∀v∈V: μH+ε(v) = min{1, μH(v) + ε}                              (Eq. 2.5.4) 
representing H being pervaded overall with an indetermination degree ε∈[0, 1]. 
The derivation is due to the following proposition. 
Proposition 2.5.1. For every fuzzy set A and α∈[0, 1], A+(1 − α) is the least spe-
cific solution for A* such that N(A | A*) ≥ α.  
In case the body of a rule (or a fact) is a conjunction “x1 is B1 & x2 is B2 & ... & xn 
is Bn” (or “x1 is B1* & x2 is B2* & ... & xn is Bn*”), we assume that the conjunction 
connective & also acts at the meta-level, whereby (2.5.3) becomes: 
H* = H+(1− ⊗(α, mini=1,n{N(Bi | Bi*)}))                          (Eq. 2.5.5) 
The model is consistent with the entailment principle and classical modus ponens, 
that is, when the body of a rule fully matches a fact, the head of the rule can be  

2.5   Fuzzy Sets and Fuzzy Logics 
25
 
inferred. When the body mismatches the fact by some mismatching degree, one 
has a degree of indetermination in reasoning, and the conclusion becomes less in-
formative than it is when there is no mismatching. In this case, there is no infor-
mation which could allow one to assign different degrees of indetermination to 
different elements of V and, thus, a constant addition is applied to H as in (2.5.5). 
For simplicity of expressions, we introduce the notion of mismatching degrees 
as the complement of relative necessity degrees as define below. 
Definition 2.5.5. Let A and A* be two fuzzy sets on a domain U. The mismatching 
degree of A to A* is denoted by Δ(A | A*) and defined by: 
Δ(A | A*) = 1 − N(A | A*) = supu∈U{max{0, μA*(u) − μA(u)}}. 
 
Fig. 2.5.5 Fuzzy set mismatching and relative necessity degrees 
As illustrated in Figure 2.5.5, Δ(A | A*) is the maximal distance from the part 
above A’s diagram of A*’s diagram to A’s diagram. With the fuzzy set mismatch-
ing degree function Δ, (2.5.3) can be rewritten as: 
H* = H+(1− ⊗(α, 1 − maxi=1,n{Δ(Bi | Bi*)})) 
= H+⊕(1− α, maxi=1,n{Δ(Bi | Bi*)})                       (Eq. 2.5.6) 
where ⊕ is the t-conorm that is dual to ⊗ with respect to the standard fuzzy com-
plement, i.e., ∀a, b∈[0, 1]: ⊕(a, b) = 1 − ⊗(1 − a, 1 − b). The following proposi-
tion states the properties of the fuzzy set mismatching degree function Δ that are 
applied in this volume.  
Proposition 2.5.1 can be equivalently restated by Proposition 2.5.2 below.  
Proposition 2.5.2. For every fuzzy set A and ε ∈ [0, 1], A+ε is the least specific 
solution for A* such that Δ(A | A*) ≤ ε. 
As noted in the proof of Proposition 2.5.2, one has Δ(A | A+ε) = ε iff infu∈U{μA(u)} 
≤ 1 − ε where U is the domain of A, in particular when A+ε ≠ ⊥. Other properties 
of the fuzzy set mismatching degree function Δ that are used in this volume are 
stated in the following proposition. 
Proposition 2.5.3. Let A, A*, A1 and A2 be fuzzy sets on the same domain. Then 
the following properties hold:  
 

26 
2   Fuzzy Conceptual Graphs
 
1. Δ(A | A*) = 0 iff A ≤ι A*, i.e., A* ⊆ A.  
2. If A1 ≤ι A2 then Δ(A | A2) ≤ Δ(A | A1). 
3. A+ε ≤ι A* iff Δ(A | A*) ≤ ε, for every ε∈[0, 1]. 
2.6   Fuzzy Types 
Objects in the real world are naturally associated with types, sorts, or classes. 
Taxonomic information, e.g. a type hierarchy, has become important part of 
knowledge bases and advanced information systems. On one hand, it helps to sys-
tematically organize knowledge and information in a hierarchy of groups of 
things. On the other hand, it helps to reduce search space and provide efficient 
computation and reasoning through inheritance.  
Order-sorted logic or, more generally, many-sorted logic (Wang 1952; Meinke 
and Tucker 1993) and order-sorted logic programming (Goguen and Meseguer 
1984; Pfenning 1992) have been researched and developed to provide logical 
foundations for automated reasoning systems with taxonomic information and in-
heritance. However, research on fuzzy logic in a similar direction, particularly, on 
order-sorted fuzzy logic and logic programming to deal with uncertainty and/or 
partial truth in such systems appears to be sporadic.  
Meanwhile, types of objects are often known with uncertainty and/or  
partial truth. It may be due to either the vague nature of a type itself or incomplete 
information in the process determining it even if the type is crisp, i.e., clearly  
defined. Examples of the first case are vague types like TALL_PERSON and 
PRETTY_WOMAN. An example of the second case is when one sees an animal and 
can only say “It is more or less true that it is a BIRD”, due to some degree of inde-
termination in the perception process, even when BIRD is a crisp type. 
Therefore, while in classical order-sorted logic an object has strictly to be or 
not to be of a type, in fuzzy logic an object is said to be of a type with an uncer-
tainty and/or truth degree. One could view this type and this degree collectively as 
a fuzzy type assigned to this object. The notion of fuzzy types here is not the same 
as the notion of vague types. A fuzzy type can be considered as a basic type, 
which can be crisp or vague (in the intuitive sense), fuzzified by an uncertainty 
and/or truth degree. It is also different from the definition of a fuzzy type as a 
fuzzy set on a set of basic types in Mulhem, Leow, and Lee (2001) and Haem-
merlé, Buche, and Thomopoulos (2007). 
Now, suppose that one has the following rules (without exception), the pattern 
of which is very common in fuzzy reasoning systems: 
if      it is true that x is a BIRD 
then it is true that x has wings (for every x) 
 
if      it is very true that x is an EAGLE 
then it is true that x is a BIRD (for every x) 
and the fact: 
It is very true that object #1 is an EAGLE 
 

2.6   Fuzzy Types 
27
 
Considering (BIRD, true) and (EAGLE, very true) as fuzzy types, one can rewrite 
the first rule above and the fact as follows: 
 
if      x is of (BIRD, true) 
then it is true that x has wings (for every x) 
 
Object #1 is of (EAGLE, very true) 
Then, if (EAGLE, very true) is defined to be a fuzzy subtype of (BIRD, true), the 
same advantage of classical order-sorted logic is obtained. That is, one can infer: 
It is true that object #1 has wings 
through integration of inheritance directly in fuzzy type unification, without using 
the second rule above. 
There are different measures of uncertainty and/or partial truth, such as prob-
ability degrees, truth degrees, possibility degrees, or necessity degrees. Fuzzy 
truth-values, defined as fuzzy sets on the interval [0, 1] representing a continuous 
scale of truth-values (Zadeh 1975a), express both partial truth and uncertainty 
(Lopez de Mantaras and Godo 1997). Also, fuzzy truth-values can denote linguis-
tic truth-values, which are more usual in human expressions than values in [0, 1].  
In this volume, fuzzy truth-values are used for representation of uncertainty 
and/or partial truth about types of objects. It brings the homogeneity of vague data 
that are all defined by fuzzy sets capturing the meaning of natural language terms. 
However, the fuzzy type framework presented below can be adapted for other 
measures as well. In a fuzzy type, a fuzzy truth-value associated with a basic type 
of an object can be interpreted either as a fuzzy truth qualification (Zadeh 1979) 
on a basic type assertion or as a membership grade as in the definition of L-fuzzy 
sets, whereby a membership grade can be a value in a lattice other than [0, 1]. 
Single Fuzzy Types 
A structure for a class of fuzzy truth-value lattices is defined for this formulation of 
fuzzy types as follows. It is necessary to distinguish the truth-characteristics of truth-
values because they are decisive for reasoning. For example, “It is very true that object 
#1 is an EAGLE” entails “It is very true that object #1 is a BIRD”, but “It is very false 
that object #1 is a BIRD” entails “It is very false that object #1 is an EAGLE”. That is, the 
truth-characteristics of truth-values effect the entailment directions. 
Definition 2.6.1. A fuzzy truth-value lattice is a lattice of fuzzy sets on [0, 1] that 
includes two complete sub-lattices T and F such that: 
1.  ∀v1∈T ∀v2∈F: v1 and v2 are incomparable, and  
2.  ∀S ⊆ T: lub(S)∈T and glb(S)∈T 
 
∀S ⊆ F: lub(S)∈F and glb(S)∈F, and 
3.  ∀v∈T ∀ε∈[0, 1]: if ∃v*∈T: v* ≤ι v+ε then v+ε∈T 
∀v∈F ∀ε ∈[0, 1]: if ∃v*∈F: v* ≤ι v+ε then v+ε∈F 
where T and F respectively denote the set of all TRUE-characteristic truth-values 
and the set of all FALSE-characteristic truth-values in the lattice. 

28 
2   Fuzzy Conceptual Graphs
 
In the definition, v+ε represents a fuzzy truth-value v being pervaded overall 
with an indetermination degree ε, as mentioned in Section 2.5. The rational of the 
third condition is that, if v is a TRUE-characteristic truth-value (i.e., v∈T) and v+ε 
still implies a TRUE-characteristic truth-value (i.e., ∃v*∈T: v* ≤ι v+ε), then v+ε 
should still be a TRUE-characteristic truth-value. The case of FALSE-characteristic 
truth-values is similar. Definition 2.6.1 gives a structure rather than a specific 
definition of a fuzzy truth-value lattice. For generality, we deliberately leave T 
and F to be specifically defined in a particular implementation.  
For a fuzzy truth-value diagram, the horizontal axis represents truth degrees 
and the vertical axis represents possibility degrees. Figure 2.6.1 illustrates some 
typical fuzzy truth-values. For a TRUE-characteristic value like true, the closer to 1 
a truth degree is, the higher its possibility degree is. Whereas, for a FALSE-
characteristic value like false, the closer to 0 a truth degree is, the higher its possi-
bility degree is. The membership functions of true and false as in the figure are  
defined as follows: 
∀u∈[0, 1]: μtrue(u) = u 
∀u∈[0, 1]: μfalse(u) = 1 − u 
The four extreme values absolutely true, absolutely false, absolutely inconsis-
tent and absolutely unknown correspond to the four-valued truth-values in Belnap 
(1977), where absolutely true and absolutely false are equivalent to the binary 
truth-values true and false in classical logic. The membership functions of these 
four values are defined as follows: 
μabsolutely true(1) = 1 and μabsolutely true(u) = 0 for all u ≠ 1 
μabsolutely false(0) = 1 and μabsolutely false(u) = 0 for all u ≠ 0 
∀u∈[0, 1]: μabsolutely inconsistent(u) = 0 
∀u∈[0, 1]: μabsolutely unknown(u) = 1. 
 
Fig. 2.6.1 Typical fuzzy truth-values 
As such, fuzzy truth-values can express both partial truth and uncertainty, be-
cause a truth degree, a possibility degree or a necessity degree in [0, 1] can be rep-
resented as a special fuzzy truth-value. Indeed, a truth degree α can be represented 
by the fuzzy truth-value τα defined by: 
μτα(α) = 1 and μτα(u) = 0 for all u ≠ α 

2.6   Fuzzy Types 
29
 
Meanwhile, a necessity degree β of a proposition p can be considered as the rela-
tive necessity degree of “p is absolutely true” given “p is τβ”, where τβ is some 
fuzzy truth-value. Thus, “p is certain at least to degree β” can be represented by “p 
is τβ” such that N(absolutely true | τβ) ≥ β. By Proposition 2.5.1, the least specific 
solution for τβ is absolutely true+(1 − β), that is: 
μτβ(1) = 1 and μτβ(u) = 1 − β for all u ≠ 1. 
It  satisfies  the  intuition  that,  if  β = 1  then  τβ =  absolutely true  and  if β = 0 
then τβ = absolutely unknown. Similarly, “p is possible at most to degree γ” can be 
represented by “p is τγ” such that Π(absolutely true | τγ) ≤ γ, whence the least spe-
cific solution for τγ is: 
μτγ(1) = γ and μτγ(u) = 1 for all u ≠ 1. 
Definition 2.6.2. A fuzzy type is defined to be a pair (t, v) where t is a basic type in 
a partially ordered set of basic types and v is a fuzzy truth-value in a fuzzy truth-
value lattice. 
The intuitive meaning of a fuzzy type assertion “x is of fuzzy type (t, v)” is “It 
is v that x is of t”. A basic type can be regarded as a special fuzzy type whose 
fuzzy truth-value is absolutely true. For example, given EAGLE and BIRD as basic 
types, (BIRD, true) and (EAGLE, very false) are fuzzy types. Basic types may also 
be vague in nature, such as TALL_MAN and YOUNG_MAN. Then one has 
(TALL_MAN, very true) and (YOUNG_MAN, false) as fuzzy types. An assertion 
“John is of fuzzy type (TALL_MAN, very true)” means “It is very true that John is a 
TALL_MAN”, and “John is of fuzzy type (YOUNG_MAN, false)” means “It is false 
that John is a YOUNG_MAN”. 
For a basis to define the fuzzy subtype relation, we assume the two following 
entailments between fuzzy type assertions. 
Assumption 2.6.1. Given a type assertion “x is of t” and two truth-values v1 and v2 
under the information order ≤ι, one has “(x is of t) is v1” entails “(x is of t) is v2” if 
v2 ≤ι v1. 
 
This assumption applied to fuzzy truth-values is a special case of the entailment 
principle for fuzzy sets presented in Section 2.5. For examples, “(Object #1 is a 
BIRD) is very true” entails “(Object #1 is a BIRD) is true”, and “(Object #1 is a 
BIRD) is very false” entails “(Object #1 is a BIRD) is false”, provided that true 
≤ι very true and false ≤ι very false. 
 
Assumption 2.6.2. Given two type assertions “x is of t1” and “x is of t2” where t1 is 
a subtype of t2 and a truth-value v, one has: 
1. “(x is of t1) is v” entails “(x is of t2) is v” if v has the TRUE characteristic. 
2. “(x is of t2) is v” entails “(x is of t1) is v” if v has the FALSE characteristic. 
 
For examples, “(Object #1 is an EAGLE) is very true” entails “(Object #1 is a BIRD) 
is very true”, and “(Object #1 is a BIRD) is very false” entails “(Object #1 is an 

30 
2   Fuzzy Conceptual Graphs
 
EAGLE) is very false”, provided that BIRD ≤ι EAGLE. This assumption means that, if 
one can assign a type to an object with a TRUE-characteristic degree, then one can 
assign a supertype of this type to the object with at least the same truth degree 
(i.e., it is possibly truer), which is actually the least specific solution subsuming all 
other possible solutions of the case. Dually, if one can assign a type to an object 
with a FALSE-characteristic degree, then one can assign a subtype of this type to 
the object with at least the same falsity degree (i.e., it is possibly falser). 
The fuzzy subtype relation defined below has the same significance as the ordi-
nary subtype relation whereby, if τ1 and τ2 are fuzzy types and τ1 is a fuzzy sub-
type of τ2, then “x is of τ1” entails “x is of τ2”. In the definition, T and F are  
respectively the TRUE-characteristic and the FALSE-characteristic complete sub-
lattices of a fuzzy truth-value lattice of discourse (Definition 2.6.1), and Δ is the 
fuzzy set mismatching degree function (Definition 2.5.5). 
 
Definition 2.6.3. Given two fuzzy types (t1, v1) and (t2, v2), (t2, v2) is said to be a 
fuzzy subtype of (t1, v1), denoted by (t1, v1) ≤ι (t2, v2), iff: 
1.  t1 = t2 and Δ(v1 | v2) = 0, or 
2. t1 <ι t2 and ∃v∈T: v ≤ι v2 and Δ(v1 | lub{v∈T | v ≤ι v2}) = 0, or  
3.  t1 >ι t2 and ∃v∈F: v ≤ι v2 and Δ(v1 | lub{v∈F | v ≤ι v2}) = 0. 
 
The rational of Definition 2.6.3 is as follows. For case 1, Δ(v1 | v2) = 0 means v1 ≤ι 
v2 (Proposition 2.5.2), whence “x is of (t2, v2)” entails “x is of (t1, v1)” due to t1 = t2 
and Assumption 2.6.1. In case 2, one has lub{v∈T | v ≤ι v2}∈T due to ∃v∈T: v 
≤ι v2 and Definition 2.6.1, and v1 ≤ι lub{v∈T | v ≤ι v2} due to Δ(v1 | lub{v∈T | v 
≤ι v2}) = 0. Then the case is based on the following entailment chain:  
1.  “x is of (t2, v2)” entails “x is of (t2, lub{v∈T | v ≤ι v2})” due to lub{v∈T | v 
≤ι v2} ≤ι v2 and Assumption 2.6.1, and  
2.  “x is of (t2, lub{v∈T | v ≤ι v2})” entails “x is of (t1, lub{v∈T | v ≤ι v2})” due 
to lub{v∈T | v ≤ι v2} ∈ T, t1 <ι t2 and Assumption 2.6.2, and  
3.  “x is of (t1, lub{v∈T | v ≤ι v2})” entails “x is of (t1, v1)” due to v1 ≤ι lub{v∈T 
| v ≤ι v2} and Assumption 2.6.1.  
Case 3 is similar. We note that, in case 2, if v2∈T then lub{v∈T | v ≤ι v2} = v2. 
Similarly, in case 3, if v2∈F then lub{v∈F | v ≤ι v2} = v2. Also, if (t1, v1) ≤ι (t2, v2), 
then v1 ≤ι v2, for any of the three cases. 
 
Example 2.6.1. For example, let us suppose the basic type hierarchy in Figure 
2.6.2. 
 
Fig. 2.6.2 An example basic type hierarchy 

2.6   Fuzzy Types 
31
 
It assumes that a handsome man must be tall and young. Then one has:  
(TALL_MAN, true) ≤ι (HANDSOME_MAN, very true) 
and  
(HANDSOME_MAN, false) ≤ι (YOUNG_MAN, very false) 
provided that true ≤ι very true and false ≤ι very false. Consequently, “It is very 
true that John is a HANDSOME_MAN” entails “It is true that John is a TALL_MAN”, 
and “It is very false that John is a YOUNG_MAN” entails “It is false that John is a 
HANDSOME_MAN”. 
The following proposition states that the fuzzy subtype relation is a partial or-
der on the set of fuzzy types defined over a partially ordered set of basic types and 
a fuzzy truth-value lattice. 
 
Proposition 2.6.1. The fuzzy subtype relation is a partial order. 
 
Conjunctive Fuzzy Types 
 
There can be more than one assertion about uncertainty and/or partial truth of a 
type for an object, e.g. “It is true that John is a TALL_MAN and it is very false that 
he is a YOUNG_MAN”. Since, fuzzy types form a partially ordered set, the conjunc-
tive type construction technique presented in Section 2.3 can be applied to provide 
single type labels as lattice-based values assigned to objects. 
 
Definition 2.6.4. A conjunctive fuzzy type is defined to be a non-empty finite set 
of pairwise incomparable fuzzy types. 
 
For example, with the basic type hierarchy in Example 2.6.1, {(TALL_MAN, true), 
(YOUNG_MAN, very false)} is a conjunctive fuzzy type, which can be assigned to 
John to reflect the expression above. However, {(HANDSOME_MAN, false), 
(YOUNG_MAN, very false)} is not a valid conjunctive fuzzy type, because 
(HANDSOME_MAN, false) ≤ι (YOUNG_MAN, very false), when false ≤ι very false. 
Conjunctive fuzzy types that express (partial) inconsistency are also allowed, such 
as {(TALL_MAN, false), (HANDSOME_MAN, more or less true)}.  
On the basis of the fuzzy subtype relation, the conjunctive fuzzy subtype rela-
tion is defined in a straightforward manner as follows. 
 
Definition 2.6.5. Given two conjunctive fuzzy types T1 and T2, T2 is said to be a 
conjunctive fuzzy subtype of T1, denoted by T1 ≤ι T2, iff ∀τ1∈T1 ∃τ2∈T2: τ1 ≤ι τ2. 
 
For example, with the basic type hierarchy in Example 2.6.1, one has: 
{(TALL_MAN, true), (HANDSOME_MAN, more or less false)}  
≤ι {(TALL_MAN, very true), (YOUNG_MAN, false)}  
because (TALL_MAN, true) ≤ι (TALL_MAN, very true) and (HANDSOME_MAN, more 
or less false) ≤ι (YOUNG_MAN, false), provided that true ≤ι very true and more or 
less false ≤ι false. 

32 
2   Fuzzy Conceptual Graphs
 
The following proposition states that the conjunctive fuzzy subtype relation is a 
partial order on the set of conjunctive fuzzy types defined over a partially ordered 
set of basic types and a fuzzy truth-value lattice. 
 
Proposition 2.6.2. The conjunctive fuzzy subtype relation is a partial order. 
 
The conjunctive type construction function con introduced in Section 2.3 can be 
adapted for fuzzy types under the fuzzy subtype partial order. Then, con(S) de-
notes the conjunctive fuzzy type constructed from a set S of fuzzy types by remov-
ing all redundant elements in S, i.e., those entailed by others. It produces an upper 
semi-lattice of conjunctive fuzzy types as stated in the following proposition. 
 
Proposition 2.6.3. The set of all conjunctive fuzzy types, defined over a partially 
ordered set of basic types and a fuzzy truth-value lattice, forms an upper semi-
lattice under the conjunctive fuzzy subtype relation where, for two conjunctive 
fuzzy types T1 and T2, lub{T1, T2} = con(T1∪T2). 
 
As such, the least upper bound of two conjunctive fuzzy types always exists. 
However, it is not true for the greatest lower bound of two conjunctive fuzzy 
types. For instance, there is no greatest lower bound of two conjunctive fuzzy 
types {(TALL_MAN, true)} and {(YOUNG_MAN, very false)}, in general. Neverthe-
less, we are interested in whether it exists when the two types do have a common 
lower bound.  
The significance is that, if a finite set S = {T1, T2, ..., Tn} of (conjunctive) fuzzy 
types has this property and the constraint X ≤ι T1 & X ≤ι T2 & ... & X ≤ι Tn does 
have a solution for the fuzzy type variable X, then there exists glb(S) as the most 
specific solution. Firstly, the following proposition states that two conjunctive 
fuzzy types T1 and T2 have this property if every pair τ1∈T1 and τ2∈T2 have this 
property. 
 
Proposition 2.6.4. Let T1 and T2 be two conjunctive fuzzy types such that 
∀τ1∈T1 ∀τ2∈T2: glb{τ1, τ2} exists if τ1 and τ2 have a common lower bound. Then, 
glb{T1, T2} = con{glb{τ1, τ2} | τ1∈T1, τ2∈T2 and glb{τ1, τ2} exists} if T1 and T2 
have a common lower bound. 
 
We now identify classes of fuzzy types that have the above-mentioned property. 
 
Definition 2.6.6. A fuzzy type (t, v) is said to be non-negative iff there does not 
exist v*∈F such that v* ≤ι v, or non-positive iff there does not exist v*∈T such 
that v* ≤ι v. A conjunctive fuzzy type is said to be non-negative (respectively non-
positive) iff it consists of only non-negative (respectively non-positive) fuzzy 
types. 
 
For example, (TALL_MAN, very true) is a non-negative fuzzy type and 
(YOUNG_MAN, false) is a non-positive one. Whereas {(TALL_MAN, true), 

2.6   Fuzzy Types 
33
 
(YOUNG_MAN, very false)} is neither a non-negative nor non-positive conjunctive 
fuzzy type. Then, the following proposition holds. 
 
Proposition 2.6.5. Let τ1 and τ2 be two fuzzy types, defined over a basic type lat-
tice and a fuzzy truth-value lattice, such that both are either: 
1. Constructed from the same basic type, or 
2. Non-negative, or 
3. Non-positive 
Then glb{τ1, τ2} exists if τ1 and τ2 have a common lower bound. 
 
In the proposition above, for case 2 and case 3, the basic type set is required to 
form a lattice, rather than just a partially ordered set, so that glb{t1, t2} and lub{t1, 
t2} for every pair of basic types t1 and t2 exist. In particular, if v1, v2∈T then 
glb{(t1, v1), (t2, v2)} = (glb{t1, t2}, glb{v1, v2}), or if v1, v2∈F then glb{(t1, v1), (t2, 
v2)} = (lub{t1, t2}, glb{v1, v2}). For example, with the basic type hierarchy in Ex-
ample 2.6.1, one has: 
glb{(TALL_MAN, true), (TALL_MAN, more or less true)}  
= (TALL_MAN, more or less true)  
and 
glb{(TALL_MAN, very false), (YOUNG_MAN, false)}  
= (lub{TALL_MAN, YOUNG_MAN}, glb{very false, false})  
= (HANDSOME_MAN, false) 
provided that more or less true ≤ι true and false ≤ι very false. 
Therefore, by Propositions 2.6.4 and 2.6.5, if T1 and T2 are two conjunctive 
fuzzy types, defined over a basic type lattice and a fuzzy truth-value lattice, such 
that both are either: 
1. Constructed from the same basic type, or 
2. Non-negative, or 
3. Non-positive 
and have a common lower bound, then glb{T1, T2} exists. 
For example, with the basic type hierarchy in Example 2.6.1, one has: 
glb{{(TALL_MAN, very true), (YOUNG_MAN, true)},  
{(HANDSOME_MAN, more or less true)}}  
= con{glb{(TALL_MAN, very true),  
 (HANDSOME_MAN, more or less true)}, 
glb{(YOUNG_MAN, true),  
 (HANDSOME_MAN, more or less true)}}  
= {(TALL_MAN, more or less true), (YOUNG_MAN, more or less true)} 
provided that more or less true ≤ι true ≤ι very true. 
Fuzzy Type Mismatching Degrees 
In reasoning with taxonomic information, a basic question is about the necessity 
of “x is of τ1” given “x is of τ2” is. If τ1 and τ2 are crisp types, it is either  

34 
2   Fuzzy Conceptual Graphs
 
absolutely necessary when τ2 is a subtype of τ1 or, in general, undefined other-
wise. If τ1 and τ2 are fuzzy types, it is a matter of degree. In each case 1, 2 or 3 of 
Definition 2.6.3 of the fuzzy subtype relation, if the value of the function Δ is not 
0, it defines the mismatching degree of (t1, v1) to (t2, v2), like the notion of the mis-
matching degree of one fuzzy set to another (Definition 2.5.5).  
Given two fuzzy types τ1 and τ2, we denote the mismatching degree of τ1 to τ2 
by Δ(τ1 | τ2), which is a value in [0, 1]. If Δ(τ1 | τ2) = 0 then τ1 ≤ι τ2. When Δ(τ1 | 
τ2) ≠ 0, “x is of τ2” does not fully entail “x is of τ1”, and Ν(τ1 | τ2) = 1 − Δ(τ1 | τ2) 
measures the relative necessity degree of “x is of τ1” given “x is of τ2”. However, 
Δ(τ1 | τ2) is undefined if τ1 and τ2 do not satisfy the conditions except one on Δ of 
any case of Definition 2.6.3. It is defined iff τ1 is matchable to τ2 as formally de-
fined below.  
 
Definition 2.6.6. A fuzzy type (t1, v1) is said to be matchable to a fuzzy type  
(t2, v2) iff: 
1.  t1 = t2, or   
2.  t1 <ι t2 and ∃v∈T: v ≤ι v2, or  
3.  t1 >ι t2 and ∃v∈F: v ≤ι v2. 
 
The mismatching degree of one fuzzy type to another is then formally defined as 
follows, where T and F are respectively the TRUE-characteristic and the FALSE-
characteristic complete sub-lattices of a fuzzy truth-value lattice of discourse. 
 
Definition 2.6.7. Let τ1 = (t1, v1) and τ2 = (t2, v2) be two fuzzy types such that τ1 is 
matchable to τ2. Then the mismatching degree of τ1 to τ2, denoted by Δ(τ1 | τ2), is 
defined to be either: 
1.  Δ(v1 | v2) if t1 = t2, or 
2.  Δ(v1 | lub{v∈T | v ≤ι v2}) if t1 <ι t2 and ∃v∈T: v ≤ι v2, or 
3.  Δ(v1 | lub{v∈F | v ≤ι v2}) if t1 >ι t2 and ∃v∈F: v ≤ι v2. 
For example, with the basic type hierarchy in Example 2.6.1, one has: 
Δ((TALL_MAN, very true) | (HANDSOME_MAN, true))  
= Δ(very true | true) 
where 1 − Δ(very true | true) measures the necessity of “It is very true that John is 
a TALL_MAN” given “It is true that John is a HANDSOME_MAN”. Meanwhile, 
(TALL_MAN, very true) is not matchable to (HANDSOME_MAN, false). Indeed, given 
“It is false that John is a HANDSOME_MAN”, one cannot say anything about the ne-
cessity of “It is very true that John is a TALL_MAN”. For simplicity, given two 
fuzzy types τ1 and τ2, we may write Δ(τ1 | τ2) without explicitly stating that τ1 is 
matchable to τ2. 
In case 2 of Definition 2.6.7 (case 3 is similar), if v2∈T then lub{v∈T | v ≤ι v2} 
= v2, whence the result is Δ(v1 | v2). Whereas, if v2∉T and {v∈T | v ≤ι v2} is infi-
nite, then lub{v∈T | v ≤ι v2} may not be computable. So, to guarantee the comput-
ability of Δ((t1, v1) | (t2, v2)), one has to avoid the case when v2∉T and ∃v∈T: v 
≤ι v2, or v2∉F and ∃v∈F: v ≤ι v2. Such a fuzzy truth-value v2 and fuzzy type (t2, v2) 
are said to be abnormal. 

2.6   Fuzzy Types 
35
 
Nevertheless, in practice, with a membership function diagram defined by 
straight line segments like v2 in Figure 2.6.3, lub{v∈T | v ≤ι v2} can be simply 
computed, even when {v∈T | v ≤ι v2} is infinite. Indeed, its diagram comprises the 
increasing parts of the diagram of v2 and the level line segments drawn from its 
(relative) maximal points, assuming that a fuzzy truth-value with a membership 
function being monotonic increasing to level unity has the TRUE-characteristic. 
 
Fig. 2.6.3 An abnormal fuzzy truth-value 
The notions of matchability and the mismatching degree of one fuzzy type 
given another are extended to conjunctive fuzzy types as follows. For the exten-
sion, the min and the max functions are used on the basis that “x is of {τ1, τ2, ..., 
τn}” means the conjunction of “x is of τ1”, “x is of τ2”, ..., and “x is of τn”. 
 
Definition 2.6.8. A conjunctive fuzzy type T1 is said to be matchable to a conjunc-
tive fuzzy type T2 iff ∀τ1∈T1 ∃τ2∈T2: τ1 is matchable to τ2. 
 
Definition 2.6.9. Let T1 and T2 be two conjunctive fuzzy types such that T1 is 
matchable to T2. Then the mismatching degree of T1 to T2, denoted by Δ(T1 | T2), is 
defined to be maxτ1∈Tminτ2∈T{Δ(τ1 | τ2) | τ1 is matchable to τ2}. 
 
For example, with the basic type hierarchy in Example 2.6.1 and true ≤ι very true, 
one has: 
Δ({(TALL_MAN, true), (HANDSOME_MAN, false)} |  
{(TALL_MAN, very true), (YOUNG_MAN, more or less false)})  
= max{Δ((TALL_MAN, true) | (TALL_MAN, very true)),  
Δ((HANDSOME_MAN, false)| (YOUNG_MAN, more or less false))}  
= max{Δ(true | very true), Δ(false | more or less false)}  
= max{0, Δ(false | more or less false)}  
= Δ(false | more or less false). 
Meanwhile, {(TALL_MAN, very true), (HANDSOME_MAN, false)} is not matchable 
to {(YOUNG_MAN, very false)}, because (TALL_MAN, very true) is not matchable 
to (YOUNG_MAN, very false). 
 

36 
2   Fuzzy Conceptual Graphs
 
As for fuzzy types, given two conjunctive fuzzy types T1 and T2, we may write 
Δ(T1 | T2) without explicitly stating that T1 is matchable to T2. Also, Δ(T1 | T2) may 
not be computable if T2 contains an abnormal fuzzy type. A conjunctive fuzzy 
type that contains an abnormal fuzzy type is said to be abnormal too.  
The fuzzy type and the conjunctive fuzzy type mismatching degree functions 
have properties similar to those of the fuzzy set mismatching degree function 
stated by Proposition 2.5.2. In the following propositions, for every ε∈[0, 1] and 
fuzzy type τ = (t, v), τ+ε denote the fuzzy type (t, v+ε).  
 
Proposition 2.6.6. For every fuzzy type τ1 and ε∈[0, 1], τ1+ε is the least specific 
solution for τ2 such that Δ(τ1 | τ2) ≤ ε. 
 
Proposition 2.6.7. Let τ1, τ2 and τ3 be fuzzy types, defined over a partially ordered 
set of basic types and a fuzzy truth-value lattice, such that τ1 is matchable to τ2. 
Then the following properties hold:  
1.  Δ(τ1 | τ2) = 0 iff τ1 ≤ι τ2.  
2.  If τ2 ≤ι τ3, then τ1 is matchable to τ3 and Δ(τ1 | τ3) ≤ Δ(τ1 | τ2). 
3.  τ1+ε ≤ι τ2 iff Δ(τ1 | τ2) ≤ ε, for every ε∈[0, 1]. 
 
For a conjunctive fuzzy type T, we define T+ε to be con{τ+ε | τ∈T}. Then similar 
properties are obtained as stated in the following propositions. 
 
Proposition 2.6.8. For every conjunctive fuzzy type T1 and ε∈[0, 1], T1+ε is the 
least specific solution for T2 such that Δ(T1 | T2) ≤ ε. 
 
Proposition 2.6.9. Let T1, T2 and T3 be conjunctive fuzzy types, defined over a 
partially ordered set of basic types and a fuzzy truth-value lattice, such that T1 is 
matchable to T2. Then the following properties hold:  
1.  Δ(T1 | T2) = 0 iff T1 ≤ι T2.  
2.  If T2 ≤ι T3, then T1 is matchable to T3 and Δ(T1 | T3) ≤ Δ(T1 | T2). 
3.  T1+ε ≤ι T2 iff Δ(T1 | T2) ≤ ε, for every ε∈[0, 1]. 
 
The significance of the above propositions is that fuzzy types and conjunctive 
fuzzy types can be treated in the same way as fuzzy set values, regarding mis-
matching degree propagation, qualification and modification. In particular, for any 
fuzzy value v, which is a fuzzy set, a fuzzy type or a conjunctive fuzzy type, and 
ε∈[0, 1], v+ε is the least specific solution for v* such that Δ(v | v*) ≤ ε. 
2.7   Fuzzy Conceptual Graphs 
With the introduction of fuzzy types, fuzzy conceptual graphs can be formulated 
with the same structure as that of CGs. The main difference is only that CGs are 
based on basic concept types and basic relation types, whereas FCGs are based on 
fuzzy concept types and fuzzy relation types. Moreover, similar to the case of  
 

2.7   Fuzzy Conceptual Graphs 
37
 
 
Fig. 2.7.1 An example FCG with fuzzy types 
CGs, conjunctive fuzzy types formulated in Section 2.6 are applied to FCGs. For 
example, Figure 2.7.1 shows the FCG expressing “It is very true that John is an 
American man who is young, and it is more or less true that he likes a car whose 
colour is blue”, where young and blue are also linguistic labels of fuzzy sets. 
As such, the signature of an FCG language is defined as consisting of a CG 
signature (Definition 2.4.1), a fuzzy truth-value lattice (Definition 2.6.1) for fuzzy 
type construction, and a set of fuzzy set lattices on different domains (Definition 
2.5.3) for fuzzy attribute values. 
Definition 2.7.1. An FCG signature is a tuple (TC, TR, M, V, A) where: 
1. (TC, TR, M) is a CG signature. 
2.  V is a fuzzy truth-value lattice. 
3.  A is a set of fuzzy set lattices. 
 
For a set of basic types T and a set of fuzzy truth-values V, we denote the set of all 
fuzzy types constructed from them by T×V and the corresponding set of conjunc-
tive fuzzy types by (T×V)+. Also, for a fuzzy relation type τ = (t, v), we define: 
arity(τ) = arity(t) 
and 
arg_type(τ, i) = arg_type(t, i) ∈ TC 
for every i from 1 to arity(τ). 
Similar to a conjunctive basic relation type, a conjunctive fuzzy relation type is 
constructed from only fuzzy relation types of the same arity. For a conjunctive 
fuzzy relation type T = {τ1, τ2, ..., τk}, we define: 
arity(T) = arity(τ1) = arity(τ2) = ... = arity(τk)  
and 
arg_type(T, i)  
= con{arg_type(τ1, i), arg_type(τ2, i), ..., arg_type(τk, i)} ∈ TC
+ 
for every i from 1 to arity(T). 
 
Definition 2.7.2. A simple FCG wrt an FCG signature (TC, TR, M, V, A) is a bi-
partite graph defined by a triple (VC, VR, E) where: 
1.  VC is a set of concept vertices, each of which is labelled by either: 
(i) A conjunctive fuzzy concept type in (TC×V)+ and a concept referent in 
M, for a fuzzy entity concept, or 

38 
2   Fuzzy Conceptual Graphs
 
(ii) A conjunctive fuzzy concept type in (TC×V)+, a concept referent in M, 
and a fuzzy attribute value in A, for a fuzzy attribute concept. 
The type and the referent of each concept c∈VC are denoted by type(c) and 
referent(c), respectively. If c is a fuzzy attribute concept, its attribute-value 
is denoted by aval(c). 
2. VR is a set of relation vertices, each of which is labelled by a conjunctive 
fuzzy relation type in (TR×V)+. The type of each relation r∈VR is denoted 
by type(r). 
3.  E is a set of edges, each of which connects a relation vertex to a concept 
vertex. The number of edges incident to a relation r is arity(type(r)) and the 
edges are labelled from 1 to arity(type(r)). For every i from 1 to ar-
ity(type(r)), the concept connected to r by the edge labelled i is denoted by 
neighbour(r, i). 
The FCG is said to be well-typed wrt the signature iff, for every r∈VR and i∈{1, 2, 
..., arity(type(r))}, arg_type(type(r), i) ≤ι type(neighbour(r, i)), where each t∈TC in 
arg_type(type(r), i) is considered as a special fuzzy concept type (t, absolutely 
true). 
 
According to the definition above, if the signature of the basic relation type LIKE 
in the FCG in Figure 2.7.1 is (PERSON, ENTITY), then the inclusion of PERSON in 
the concept [{PERSON, (AMERICAN_MAN, very true)}: John] is to make the FCG 
well-typed. That is because PERSON ≤ι (AMERICAN_MAN, very true) does not hold, 
although PERSON ≤ι AMERICAN_MAN holds. Indeed, “It is very true that John is an 
American man” does not imply “John is a person”, because very true is not abso-
lutely true and still has an uncertainty degree. From now on we simply say an 
FCG, unless emphasizing that it is a simple one.  
A CG can be considered as a special FCG, because a crisp attribute-value is a 
special fuzzy one defined by a fuzzy set whose membership function only has val-
ues 0 or 1, and a basic concept or relation type is a special fuzzy one whose fuzzy 
truth-value is absolutely true,. Basically, operations on FCGs compute with fuzzy 
types and fuzzy attribute values as lattice-based data just as CG operations do with 
basic types and crisp attribute-values. Additional issues relating to fuzziness of 
fuzzy conceptual graphs are presented and discussed below. 
FCG projection is also based on the partial orders, under the same umbrella of 
information ordering, on FCG vertex labels as CG projection is on the partial or-
ders on CG vertex labels. However, in the case of FCGs, there may be mismatch-
ing degrees between vertex labels due to mismatching degrees between fuzzy sets, 
as presented in Section 2.5, and fuzzy types, as presented in Section 2.6. Thus, a 
projection from G to H may have a mismatching degree ε, where 1 − ε measures 
the relative necessity degree of G given H. When ε = 0, H fully entails G and we 
also write G ≤ι H.  
 
Definition 2.7.3. Let G and H be two simple FCGs. An FCG projection from G to 
H is a mapping π: G → H such that: 
 

2.7   Fuzzy Conceptual Graphs 
39
 
1.  ∀c∈VCG: 
(i)  If c is a fuzzy entity concept, then referent(c) ≤ι referent(πc) and 
type(c) is matchable to type(πc).  
 
The mismatching degree of c given πc is defined to be: 
Δ(type(c) | type(πc)). 
(ii)  If c is a fuzzy attribute concept, then referent(c) ≤ι referent(πc) and 
type(c) is matchable to type(πc).  
The mismatching degree of c given πc is defined to be: 
max{Δ(type(c) | type(πc)), Δ(aval(c) | aval(πc))}. 
2.  ∀r∈VRG: neighbour(πr, i) = πneighbour(r, i) for every i ∈ {1, 2, ..., ar-
ity(type(r))}, and type(r) is matchable to type(πr). 
The mismatching degree of r given πr is defined to be: 
Δ(type(r) | type(πr)).  
The mismatching degree of π, denoted by επ, is defined to be the supremum of the 
mismatching degrees of all fuzzy concept pairs and fuzzy relation pairs in π. 
 
Figure 2.7.2 illustrates an FCG projection from G to H, whose mismatching de-
gree is:  
max{Δ(young | very young),  
 Δ((LIKE, more or less true) | (LIKE, not false))}  
= max{1, Δ(more or less true | not false)}  
= Δ(more or less true | not false) 
provided that young ≤ι very young. 
 
Fig. 2.7.2 An FCG projection 
In joining FCGs, regarding functional relations, we assume that only basic 
functional relation  types  impose  the  uniqueness  constraint,  whereby  no  fuzzy  
type  (t, v)  with v ≠ absolutely true is functional, even when t is a basic functional 
relation type. The FCG in Figure 2.7.3 exemplifies the intuition of this assump-
tion. It says “There is an Australian man who is Mary’s father, and it is not very 
true that Bill is Mary’s father”. In this case, since there is uncertainty about the fa-
therhood of Bill with respect to Mary, the unspecified Australian man is not nec-
essarily Bill. Thus, it is not sound to join the two concepts [MAN: Bill] and 
[AUSTRALIAN_MAN: *] into one concept. In other words, it is not absolutely incon-
sistent even if the two concepts refer to different entities. 
 

40 
2   Fuzzy Conceptual Graphs
 
 
Fig. 2.7.3 A functional relation under uncertainty 
Another note for joining FCGs is that, when fuzzy attribute concepts are joined, 
the attribute-values are also joined into their least upper bound, as for other lattice-
based data like conjunctive fuzzy concept or relation types. Figure 2.7.4 illustrates 
a join of two FCGs G and H into F, where  ATTR is supposed to be a basic func-
tional relation type, middle-aged = lub{not young, not old}, and PERSON 
≤ι SCIENTIST.  
 
Fig. 2.7.4 An FCG join 
In the FCGs above, the symbol @ followed by an attribute value is abbrevia-
tion of a relation between a concept representing an attribute, e.g. [AGE: *] here, 
and a concept representing the attribute value, e.g. not young (Sowa 1984). That 
is, the FCGs G and H are semantically equivalent to the following FCGs: 
[SCIENTIST: John] 
→(ATTR)→[AGE: *]→(MEAS)→[MEASURE: not young] 
and 
[{PERSON, (AMERICAN_MAN, very true)}: John] 
→(ATTR)→[AGE: *]→(MEAS)→[MEASURE: not old] 
where MEASURE is assumed to be a particular concept type of fuzzy set-based 
measures of person age, and MEAS is assumed to be a particular functional relation 
type with respect to AGE and this particular type MEASURE.  
Thus, when the concepts [SCIENTIST: John] and [{PERSON, (AMERICAN_MAN, 
very true)}: John] are joined, the two concepts [AGE: *] and then the concepts 
[MEASURE: not young] and [MEASURE: not old] are also joined, respectively. The 
resulting FCG is: 
[{SCIENTIST, (AMERICAN_MAN, very true)}: John] 
→(ATTR)→[AGE: *]→(MEAS)→[MEASURE: middle-aged] 
whose abbreviation is the FCG F. 
This also shows the general treatment of concept referents as lattice-based  
data, as mentioned in Section 2.2 about partial ordering on concept referents. FCG 

2.7   Fuzzy Conceptual Graphs 
41
 
normal form is now formally defined like CG normal form, taking into account the 
notes above.  
 
Definition 2.7.4. An FCG G is said to be in FCG normal form iff it satisfies the 
following conditions: 
1.  No two or more concepts in G have the same individual marker, and 
2.  No two or more relations of the same arity in G have their respective 
neighbour concepts coinciding, and 
3.  There are no relations of types T1 and T2 in G such that: 
(i) {(t, absolutely true)} ≤ι T1 and {(t, absolutely true)} ≤ι T2 for some ba-
sic functional relation type t, and 
(ii) The two relations have their respective determining concepts (wrt t) co-
inciding. 
Then, G is said to be a normal FCG. 
 
An FCG G can also be normalized by the following procedure similar to CG  
normalization: 
1. For every set S of fuzzy entity concepts that have the same individual 
marker in G, join them into one concept, using the type: 
T = con(∪c∈Stype(c)) = lub{type(c) | c∈S}  
for the resulting concept. 
2. For every set S of fuzzy attribute concepts that have the same individual 
marker in G, join them into one concept, using the type:  
T = con(∪c∈Stype(c)) = lub{type(c) | c∈S}  
and the fuzzy attribute value:  
a = lub{aval(c) | c∈S}  
for the resulting concept. 
3.  While there is still a relation of type T1 and a relation of type T2 in G such 
that: 
(i) {(t, absolutely true)} ≤ι T1 and {(t, absolutely true)} ≤ι T2 for some ba-
sic functional relation type t, and  
(ii) The two relations have their respective determining concepts (wrt t) co-
inciding,  
join their respective dependent concepts as in step 1 for fuzzy entity con-
cepts or step 2 for fuzzy attribute concepts. If any pair of the respective de-
pendent concepts have different individual markers, then quit with a failure. 
4. For every set S of relations of the same arity that have their respective 
neighbour concepts coinciding in G, join them into one relation, using the 
type: 
T = con(∪r∈Stype(r)) = lub{type(r) | r⎯∈S}  
for the resulting relation. 
As in CG normalization, step 3 may fail due to individual marker conflict in join-
ing dependent concepts of functional relations. For an FCG G, we also denote its 
normal form, if existing, by norm(G). For example, in Figure 2.7.4, F is the nor-
mal form of the disconnected FCG comprising G and H. 

42 
2   Fuzzy Conceptual Graphs
 
Like CGs, extended FCGs can also be nested. For example, the nested FCG in 
Figure 2.7.5 expresses “Tom shows a picture of a monster which is about 20 feet 
in length, and tells about a very unlikely situation that it exists in Lake Loch 
Ness”.  
 
Fig. 2.7.5 A nested FCG 
So far, we have not mentioned whether (F)CGs are finite or infinite. However, 
as CGs are also graphs, the notion of infinite CGs is the same as that of graphs in 
graph theory (Wilson and Beineke 1979), and all the definitions and propositions 
presented in the previous sections are intended for, and applicable to, infinite CGs 
as well. In CG model theory (Sowa 1984), a model was defined by a possibly infi-
nite set of CGs. Since a set of CGs can be regarded as a single possibly discon-
nected CG, a model can be generally defined by a single possibly infinite CG.  
As mentioned in Section 2.2, CG projection is not anti-symmetric and thus 
equivalent CGs (i.e., having projections to each other) are not necessarily identi-
cal. It was a question whether there was some characteristic such that, in an 
equivalence class of CGs, there existed one and only one CG (modulo CG iden-
tity) having that characteristic. Then, that unique CG could be used as a represen-
tative for that equivalence class and CG projection defined a partial order on the 
set of all CGs having that characteristic. For finite CGs, Mugnier (1995) proved 
that such a characteristic was one of CG irredundancy. That is, for every finite 
CG, there exists one and only one irredundant CG that is equivalent to it. 
We now prove that infinite CGs do not have this property of finite CGs. That 
is, there exists an infinite CG such that there is no irredundant CG that is equiva-
lent to it, and there exist two irredundant infinite CGs that are equivalent but are 
not identical. Firstly, we present the following definition of CG irredundancy 
adapted from Chein and Mugnier (1992) on finite CGs, which is also applicable to 
infinite CGs. 
 
Definition 2.7.5. A simple CG G is said to be irredundant iff there is no projec-
tion from G to any of its strict subgraphs. 
 
Then, the two following propositions hold. 
 
2

2.7   Fuzzy Conceptual Graphs 
43
 
Proposition 2.7.1. There exists an infinite CG such that there is no irredundant 
CG that is equivalent to it. 
 
Proposition 2.7.2. There exist two irredundant infinite CGs that are equivalent but 
are not identical. 
 
An infinite CG to prove Proposition 2.7.1 is the CG G given in Figure 2.7.6, 
where G is redundant because it has a projection to its strict subgraph g, which is 
obtained by deleting the first concept and the first relation in G, as shown in the 
figure. In fact, G is the least fixpoint (modulo CG equivalence) of the CG program 
P also shown in the figure, containing one rule if [T: *x] then [T: *x]→(R)→[T: *] 
and one fact [T: *]. 
 
Fig. 2.7.6 A redundant infinite CG and one of its strict subgraphs 
Conventionally, a type set of a CG language is assumed to be finite. However, 
our note on infinite CGs here is also intended for extensions that add to conceptual 
graphs other kinds of data that may have infinite values, such as quantitative ones, 
to enhance CG expressive power. For example, for fuzzy conceptual graphs, a 
fuzzy attribute value set or a conjunctive fuzzy type set is typically infinite. Thus, 
for generality, we do not assume the finiteness of a type set here.  
Then, the two infinite CGs G and H in Figure 2.7.7 prove Proposition 2.7.1, 
where {Tz/2 | z ∈ Z and Tp ≤ι Tq iff q ≤ p} is an infinite partially ordered set of  
 
 
Fig. 2.7.7 Two equivalent irredundant infinite CGs 
 

44 
2   Fuzzy Conceptual Graphs
 
types, which forms an infinite chain. Here, G and H are equivalent because they 
have projections to each other, as shown in the figure. However, they are irredun-
dant because, for instance, H does not have a projection to any of its strict  
sub-graphs, which is obtained by deleting some vertices from it, like the discon-
nected CG comprising h1 and h2 shown in the figure. 
The results above also apply to fuzzy conceptual graphs. Therefore, in the next 
chapter, when defining an interpretation of an FCG program by a possibly infinite 
ideal FCG, we do not assume it to be irredundant. 
2.8   Summary 
As bipartite graphs of concept vertices alternate with relation vertices, conceptual 
graphs resemble semantic networks but have a stricter syntax, where each concept 
is a pair of a concept type and a concept referent, and concept and relation types 
are predefined in an ontology. In fact, conceptual graphs are a logical notation for 
which nested conceptual graphs with negations are equivalent to order-sorted 
predicate logic. 
Functional relation types are formally integrated into a CG language radically 
as a part of its signature, for representing functional dependency and terms in 
predicate logic. Conjunctive concept and relation types are also introduced into 
conceptual graphs for joining CGs when an order-theoretic interpretation of a type 
lattice, which is more appropriate than a lattice-theoretic one, is assumed or when 
concept and relation types are just partially ordered. CG projection and normaliza-
tion are then modified accordingly for extended CGs with functional relation types 
and conjunctive concept and relation types. 
While conceptual graphs provide a logical notation that has smooth mapping 
with natural language, fuzzy set theory and fuzzy logic provide a methodology for 
defining and computing with linguistic terms expressing vague concepts pervasive 
in natural language. A fuzzy set is a generalization of a classical or crisp set that 
maps a domain to the real number interval [0, 1] instead of the binary set {0, 1}, 
and induces a possibility distribution on its domain. Reasoning on possibility dis-
tributions is based on the entailment and minimum specificity principles and the 
relative necessity and possibility measures. The set of fuzzy sets on a domain 
forms a complete lattice with the fuzzy subset relation that can be put under the 
same umbrella of information ordering as the object subtype relation. 
The formulation of a fuzzy type as a pair of a basic type and a fuzzy truth-value 
is to model uncertainty and partial truth about a basic type of an object. The fuzzy 
subtype relation and the relative necessity degree (or the complementary mis-
matching degree) between fuzzy types are defined on the basis of the basic  
subtype relation and the relative necessity degree between fuzzy truth-values. Sig-
nificantly, it is proved that fuzzy types as formulated can be treated as lattice-
based information granules as object types and fuzzy attribute values. 
 

2.8   Summary 
45
 
Fuzzy types are then applied to generalize simple CGs to simple FCGs where 
fuzzy concept types and fuzzy relation types are used in place of basic concept 
types and basic relation types. Thus, CG operations, such as projection or nor-
malization, are generalized in a straightforward manner for fuzzy conceptual  
graphs. More importantly, this brings the annotated logic programming view to 
order-sorted fuzzy set logic programming, in particular FCG programming, where 
fuzzy types in concept and relations are considered as lattice-based annotations. 
The next chapter presents the fuzzy annotated logic program formalism with fuzzy 
attribute values as annotations and their extension to the order-sorted one using 
fuzzy types. 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 47–78. 
springerlink.com              © Springer-Verlag Berlin Heidelberg 2010 
Chapter 3 
Annotated Fuzzy Logic Programming 
3.1   Overview 
Fuzzy logic programming systems can be roughly classified into two groups with 
respect to whether they involve fuzzy sets in programs or not. Systems that do not 
involve fuzzy sets usually have fuzzy terms materialized as predicate symbols and 
formulas weighted by real numbers in the interval [0, 1], interpreted as truth or 
uncertainty degrees. Examples of such systems are those of Lee (1972), Ishizuka 
and Kanai (1985), Mukaidono, Shen and Ding (1989), Atanassov and Georgiev 
(1993), Dubois, Lang and Prade (1994), Klawonn (1995), Muñoz-Hernández and 
Vaucheret (2005), and Chortaras, Stamou and Stafylopatis (2009). Systems that 
involve fuzzy sets include those of Hinde (1986), Umano (1987), Li and Liu 
(1990), Baldwin, Martin and Pilsworth (1995), Godo and Vila (1995), Virtanen 
(1996), Kullmann and Sandri (2000), and Straccia (2008). 
In this volume, we look at fuzzy set logic programming from two stand points. 
Firstly, model-theoretic semantics and theorem-proving fundamentals are to be es-
tablished so that the soundness and the completeness of a system can be justified. 
Secondly, in agreement with Dubois, Lang, and Prade (1994), it is not fully satis-
factory to have a logic system that deals with uncertainty but does not allow in-
consistency. Among the above-mentioned works on fuzzy set logic programming, 
Godo and Vila (1995), Virtanen (1996), Kullmann and Sandri (2000), and Straccia 
(2008) were carried out from the theorem prover point of view, but did not have 
complete proof procedures and did not address inconsistency. 
Before, classical logic programming had been extended for quantitative deduc-
tion on uncertainty values, initially by Van Emden (1986), when usual logical rea-
soning in terms of binary truth-values had been found to be insufficient for expert 
systems. In fact, that work aimed at providing a well-established and formal logi-
cal foundation for uncertain reasoning systems.  
Annotated logic programs were then introduced and developed by further  
work in this research direction as an essential formalism for quantitative reasoning 
and, more generally, for lattice-based reasoning, initially by Subrahmanian (1987). 
The key idea of annotated logic programming was annotating usual atomic formu-
las with lattice-based values, hence its name. In Kifer and Subrahmanian (1992),  
it was generalized to allow an annotation to be a variable, and the one in the  
head of a rule to be a function from Lm to L, with L being an annotation lattice of 
discourse.  

48 
3   Annotated Fuzzy Logic Programming
 
An annotated logic program consists of Horn-like clauses of the following 
form: 
H: ρ ← B1: μ1 & B2: μ2 & ... & Bn: μn 
where H: ρ and Bi: μi’s are called annotated atoms, with H and Bi’s being atomic 
formulas of first-order predicate logic and ρ and μi’s being expressions evaluated 
to values in a lattice. Declarative semantics and proof procedures of annotated 
logic programs were also formally defined and studied in the cited works. Annota-
tion values can be of different kinds, showing annotated logic programming as a 
general framework for lattice-based reasoning.  
Moreover, as its main motivation, annotated logic programming can deal with 
(local) inconsistency (Kifer and Lozinskii 1992), which is also a key issue of 
fuzzy logic programming (Dubois, Lang and Prade 1991). The cornerstone is that, 
in annotated logic programming, a Herbrand-like interpretation is defined as a 
mapping from a conventional Herbrand base, i.e., the set of all ground atoms 
without annotations, to an annotation lattice. Some ground atoms can be mapped 
to inconsistent values to express local inconsistencies of those atoms only. As 
such, an annotated logic program with inconsistent clauses still has models and 
does not arbitrarily entail everything. Whereas, in classical logic programming, no 
inconsistency is allowed in a model, whence a program with inconsistent clauses 
has no model and thus everything becomes its logical consequence. 
Annotated logic programming appears to be a good framework for fuzzy set 
logic programming, where fuzzy set values are treated as annotations. However, 
the classical annotated logic programming formalism is still not sufficient to be 
applied to the development of fuzzy set logic programs. Simple rules, such as “If a 
tomato is red, then it is ripe”, the pattern of which is common in fuzzy reasoning 
systems, are not expressible in the formalism. Moreover, in the semantic aspect, 
the behaviour of such a fuzzy rule to derive a conclusion when given a fact like 
“Tomato #78 is fairly red”, which does not fully match the antecedent of the rule, 
cannot be defined therein. This is due to the following  shortcomings of  the clas-
sical formalism: 
1.  Only atomic formulas can be annotated. 
2.  Only single annotation lattices are used. 
3.  Mismatching degrees between annotations are not considered. 
This chapter presents the annotated fuzzy logic program (AFLP) framework 
(Cao 1998; Cao 2000) that overcomes the above shortcomings correspondingly as 
follows: 
1.  Both atoms and terms of first-order predicate logic are regarded as objects 
and all of them can be annotated. In the above example, red and ripe can be 
regarded as annotations defined by fuzzy sets and annotated to terms 
color(x) and ripeness(x) of a tomato x. Then the rule can be represented as 
follows: 
ripeness(x): ripe ← color(x): red 
2.  Multiple annotation lattices are used, each of which is on a different  
domain. For example, red and ripe are two fuzzy sets on two different  

3.2   AFLP Syntax 
49
 
domains. Thus, one has a multiple-lattice annotated logic programming lan-
guage, in comparison to a single-lattice one. 
3.  Mismatching degrees between fuzzy sets are taken into account in defining 
the semantics of rules in fuzzy set logic programs, based on developed 
fuzzy rule models of research in fuzzy logic.  
Inherited from annotated logic programming, the AFLP approach has advan-
tages in both the syntactic and semantic aspects. In an annotated fuzzy logic pro-
gram, fuzzy set values encoded as annotations are separated from symbolic objects 
in programs, whence symbolic manipulation such as pattern matching and unifica-
tion can be performed as in classical logic programming, while fuzzy set deduc-
tion based on some computation model can be studied independently. Meanwhile, 
in an AFLP interpretation, each ground object is mapped to a fuzzy set value, 
which may be subnormal to represent a local inconsistency of that object only, 
whence local inconsistency can be handled.  
Furthermore, the AFLP framework can be adapted and generalized to be a logi-
cal formalism for granular computing (Zadeh 1997), in which annotations repre-
sent lattice-based information granules. In particular, as presented in this chapter, 
AFLPs are straightforwardly extended with fuzzy types as annotations for order-
sorted fuzzy set logic programming. As another example, Cao and Noi (2010) 
adapted AFLP for linguistic logic programming, with each an annotation being a 
linguistic expression of Lawry’s label semantics (Lawry 2006).  
Next, Section 3.2 defines the annotation base of an AFLP language, then anno-
tated objects and AFLP clauses. Section 3.3 presents the fundamentals of the de-
clarative semantics of a logic programming language, which are interpretations, 
satisfaction relations and models, for annotated fuzzy logic programs. Section 3.4 
studies the fixpoint semantics of annotated fuzzy logic programs, as a bridge be-
tween their declarative and procedural semantics. Section 3.5 introduces the no-
tions of AFLP reductants and constraints to be used for AFLP backward chaining 
proof procedures. Then, in Section 3.6, an AFLP SLD-resolution style proof pro-
cedure is developed and proved to be sound and complete with respect to AFLP 
declarative semantics. Applying the notions of fuzzy types presented in Chapter 2, 
Section 3.7 adapts AFLPs with fuzzy type lattices for order-sorted fuzzy set logic 
programming. Section 3.8 presents generalized AFLPs with clauses weighted by 
certainty degrees in [0, 1], and specialized AFLPs where the only fuzzy set values 
involved in programs are special fuzzy truth-values that represent truth, possibility 
or necessity degrees. Finally, Section 3.9 concludes the chapter. 
3.2   AFLP Syntax  
As presented in Section 2.5, the set of all fuzzy sets on a domain forms a complete 
lattice with the fuzzy subset relation as the partial order, under the same umbrella 
of information ordering. A set of complete lattices of fuzzy sets then constitutes an 
annotation base to provide fuzzy set values to be annotated to objects in annotated 
fuzzy logic programs. 
 

50 
3   Annotated Fuzzy Logic Programming
 
Definition 3.2.1. An annotation base comprises a set of complete lattices of  
fuzzy sets. 
 
An annotation base is then a part of an AFLP vocabulary. As mentioned in Section 
2.5, the membership function of a fuzzy set representing a vague concept is actu-
ally context-dependent, so here an AFLP language with its defined annotation 
base is intended for a particular context only. In the definition below, we assume a 
first-order predicate logic vocabulary as in Davis (1994).  
 
Definition 3.2.2. An AFLP vocabulary consists of a first-order predicate logic vo-
cabulary, an annotation base of fuzzy sets, and an object-annotation conformity re-
lation that maps each predicate or function symbol of the first-order predicate 
logic vocabulary to a lattice of the annotation base.  
 
In an AFLP language, both atoms and terms of its first-order predicate logic vo-
cabulary are called objects, where atoms have the form p(...) with p being a predi-
cate symbol, and terms have the form f(...) with f being a function symbol.  
According to the conformity relation, each object can be annotated with only an 
annotation in the lattice that corresponds to its predicate or function symbol. Typi-
cally, atoms are annotated with fuzzy truth-values and terms with fuzzy sets on 
other domains. 
 
Definition 3.2.3. An annotated object of an AFLP language is defined to be of the 
form Obj: A, where Obj is an object and A is an expression evaluated to a fuzzy set 
value of the language’s annotation base, which satisfy the language’s object-
annotation conformity relation. 
 
The form of AFLP clauses, as well as that of annotated logic program ones, is 
similar to that of Horn clauses of predicate logic programs. The difference is only 
that annotated objects (respectively annotated atoms) are used in AFLP clauses 
(respectively annotated logic program clauses), in contrast to atoms used in Horn 
clauses. 
 
Definition 3.2.4. An AFLP clause is defined to be of the form: 
Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn 
where Obj: H and Obji: Bi’s are annotated objects with H and Bi’s being fuzzy set 
constants. Obj: H is called the head (i.e., consequent), and Obj1: B1 & Obj2: B2 & 
... & Objn: Bn the body (i.e., antecedent) of the clause, where the body can be 
empty. An annotated fuzzy logic program is defined to be a finite set of AFLP 
clauses. 
 
Example 3.2.1. As usual, a clause is called a fact if its body is empty, or a rule 
otherwise. The following AFLP consists of one rule intended to say “If a tomato is 
red, then it is ripe” and one fact to say “Tomato #78 is fairly red”, where red, ripe 
and fairly red are linguistic labels of fuzzy sets: 
ripeness(x): ripe ← color(x): red 
color(#78): fairly red. 

3.2   AFLP Syntax 
51
 
Example 3.2.2. In the following AFLP, buy() and like() are atoms, while price() is 
a term, in classical predicate logic terminology, where the atoms are annotated 
with fuzzy truth-values true and very true: 
buy(John, y): very true ← like(John, y): true ∧ price(y): not expensive 
like(John, #36): very true 
price(#36): fairly cheap. 
Assuming y and #36 to stand for cars, the rule says “If it is true that John likes a 
car and the car’s price is not expensive, then it is very true that he buys it”. The 
first fact says “It is very true that John likes car #36”. The second fact says “The 
price of car #36 is fairly cheap”. 
 
For annotated logic programs, there are two notions of declarative semantics, 
namely, restricted and general ones (Kifer and Subrahmanian 1992). The differ-
ence is that, in a restricted interpretation, each ground atom is mapped to a value 
in an annotation lattice whereas, in a general interpretation, each ground atom is 
mapped to an ideal of the annotation lattice. These two declarative semantics no-
tions are also applied to and studied for annotated fuzzy logic programs. 
In lattice theory (Grätzer 1978), an ideal of an upper semi-lattice L with the par-
tial order denoted by ≤ι is any subset S of L such that: (1) S is downward closed, 
i.e., if a∈S, b∈L and b ≤ι a then b∈S; and (2) S is closed under finite least upper 
bounds, i.e., if a, b∈S then lub{a, b}∈S. In the application of the notion of ideals 
to fuzzy set lattices, the first condition is in agreement with the entailment princi-
ple and the second condition with the principle of minimum specificity, both of 
which are presented in Section 2.5. 
For example, if an ideal contains very young, then it also contains young, pro-
vided that young ≤ι very young. For another example, let not expensive, not cheap 
and moderate be linguistic labels of fuzzy sets such that not expensive and not 
cheap are complements of expensive and cheap, respectively, and moderate = not 
expensive ∩ not cheap. Then, if an ideal contains not expensive and not cheap, it 
also contains moderate. 
For each element a∈L, the set {x∈L | x ≤ι a} is called a principal ideal. Since a 
principal ideal is defined by the greatest element in it, we may write just a to de-
note the principal ideal {x∈L | x ≤ι a}, for simplicity. It is an important property 
that, given a principal ideal p and a set of ideals J, if p ≤ι lub(J) then p ≤ι lub(F) 
with F being a finite subset of J.  
The classical set intersection of two ideals is also an ideal, whence the least 
ideal containing all ideals in a given set of ideals is unique. Thus, the set of all 
ideals of L forms a complete lattice with the classical subset relation as the partial 
order, also denoted by ≤ι. That is, given two ideals s and t, s ≤ι t iff s ⊆ t. The glb 
and the lub of a set of ideals are respectively their set intersection and the least 
ideal containing them. The greatest element is L itself, and the least element is the 
empty set ∅. 
The significance of the difference between the restricted and the general  
declarative semantics is that a finite sound and complete mechanical proof proce-
dure for annotated fuzzy logic programs and, in general, for lattice-based logic  

52 
3   Annotated Fuzzy Logic Programming
 
programs, with respect to the general declarative semantics is ensured to exist, but 
not with respect to the restricted one. The following definition identifies a class of 
annotated fuzzy logic programs for which there exists a finite sound and complete 
proof procedure with respect to the restricted declarative semantics, as stated later 
on in Section 3.4. In the definition, we apply the definition of unifiable predicates 
and terms from Lloyd (1987). 
 
Definition 3.2.5. A restricted AFLP is one in which: 
1. If Obj1: B is in the body of a clause and Obj2: H is the head of a clause 
whose body is not empty, and Obj1 and Obj2 are unifiable, then H = B+ε, for 
some ε∈[0, 1], and 
2. If Obj1: H1 and Obj2: H2 are the heads of two clauses, and Obj1 and Obj2 are 
unifiable, then H1 = H2+ε or H2 = H1+ε, for some ε∈[0, 1]. 
 
For example, both the programs in Examples 3.2.1 and 3.2.2 are restricted AFLPs. 
The program in Example 3.2.2 is not restricted any more if the following fact is 
added: 
buy(John, #36): not very false 
provided that not very false <ι very true and for every ε∈[0, 1] not very false ≠ very 
true+ε. 
3.3   AFLP Model-Theoretic Semantics 
In this section, we assume an AFLP language of discourse L. We denote the set of 
all fuzzy sets of its annotation base by AL and the set of all ideals of the complete 
lattices forming AL by ideal(AL). 
As in previous works on annotated logic programs, mainly concerned with 
logic programming, our attention is also restricted to Herbrand-like interpretations 
only. However, in contrast to those works, in annotated fuzzy logic programs not 
only atoms but also terms can be annotated, as mentioned in the introduction of 
this chapter. Therefore, an AFLP Herbrand base is defined to contain all ground 
objects, which are ground atoms and ground terms. 
 
Definition 3.3.1. The AFLP Herbrand base of L, denoted by BL, is the set of all 
ground objects that can be formed out of the predicate, function, and constant 
symbols of L’s first-order predicate logic vocabulary. 
 
Example 3.3.1. As in classical logic programming, given an AFLP P, it is suffi-
cient to refer only to the AFLP Herbrand base of P, denoted by BP , which is the 
set of all ground objects that can be formed out of the predicate, function, and 
constant symbols appearing in P. For instance, with P being the program in Ex-
ample 3.2.1, one has BP = {color(#78), ripeness(#78)}. 
 
As mentioned in Section 3.2, depending on whether BL is mapped to AL or 
ideal(AL), one has a restricted or a general AFLP interpretation, corresponding to 
the restricted or the general declarative semantics of annotated fuzzy logic programs. 

3.3   AFLP Model-Theoretic Semantics 
53
 
Definition 3.3.2. A restricted AFLP interpretation (r-interpretation) is a mapping:  
Ir: BL → AL.  
A general AFLP interpretation (g-interpretation) is a mapping: 
Ig: BL → ideal(AL).  
The mappings have to satisfy the object-annotation conformity relation of L. 
 
Example 3.3.2. Two possible r-interpretations of the program in Example 3.2.1 
are: 
I1 = {color(#78) 6 very red, ripeness(#78) 6 not ripe} 
I2 = {color(#78) 6 fairly red, ripeness(#78) 6 fairly ripe}. 
 
The set of all r-interpretations and the set of all g-interpretations for L form com-
plete lattices as defined below. 
 
Definition 3.3.3. The set of all r-interpretations forms a complete lattice where: 
1.  The partial order, also denoted by ≤ι, is defined by: 
I1 ≤ι I2 iff ∀Obj ∈ BL: I1(Obj) ≤ι I2(Obj) 
where I1 and I2 are r-interpretations, 
2.  The lub and the glb of a set S of r-interpretations are defined by: 
∀Obj∈BL: lub(S)(Obj) = lubI∈S{I(Obj)} 
∀Obj∈BL: glb(S)(Obj) = glbI∈S{I(Obj)}, 
3.  The greatest element and the least element are the r-interpretations that map 
every object of BL to the greatest element and the least element, respec-
tively, of its corresponding lattice among those forming AL. We denote the 
least element of r-interpretations by I⊥, which maps every object to the 
fuzzy set ⊥. 
 
Definition 3.3.4. The set of all g-interpretations forms a complete lattice where: 
1.  The partial order, also denoted by ≤ι, is defined by: 
I1 ≤ι I2 iff ∀Obj∈BL: I1(Obj) ≤ι I2(Obj)  
where I1 and I2 are g-interpretations, 
2.  The lub and the glb of a set S of g-interpretations are defined by: 
∀Obj∈BL: lub(S)(Obj) = lubI∈S{I(Obj)} 
∀Obj∈BL: glb(S)(Obj) = glbI∈S{I(Obj)}, 
3.  The greatest element and the least element are the g-interpretations that 
map every object of BL to the greatest element and the least element, re-
spectively, of its corresponding lattice among those forming ideal(AL). We 
denote the least element of g-interpretations by I∅, which maps every object 
to the empty set ∅.  
 
Intuitively, a fact is true with respect to an interpretation, which can be meta-
phorically thought of as a possible world, iff there is in the interpretation an asser-
tion that is more specific or more informative than the fact. For annotated fuzzy 
logic programs, this  means  that, a  ground annotated object  Obj: A  is  satisfied 
 by an r-interpretation I  iff  A ≤ι I(Obj), or by a g-interpretation I iff  A∈I(Obj).  

54 
3   Annotated Fuzzy Logic Programming
 
In the g-interpretation case, one can also write the condition as A ≤ι I(Obj), con-
sidering A as a principal ideal defined by itself. 
For the semantics of fuzzy rules, we apply the meta-level fuzzy rule model of 
Magrez and Smets (1989) presented in Section 2.5, which satisfies all intuitively 
required properties and be computationally efficient. That is, given the following 
inference pattern, where H and H* are fuzzy sets on a universe of discourse U and, 
for each i from 1 to n, Bi and Bi* are fuzzy sets on a universe of discourse Ui: 
y is H ← x1 is B1 & x2 is B2 & ... & xn is Bn 
x1 is B1* & x2 is B2* & ... & xn is Bn* 
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 
y is H* 
one has: 
H* = H+maxi=1,n{Δ(Bi | Bi*)}                                                  
obtained from Equation 2.5.6 with the fuzzy rule certainty degree α = 1. 
 
Example 3.3.3. Let us suppose the following relations between fuzzy set values of 
linguistic labels: 
fairly red = red+ε ≤ι red  
fairly ripe = ripe+ε ≤ι ripe 
which imply Δ(red | fairly red) = Δ(ripe | fairly ripe) = ε. Then, given the rule “If a 
tomato is red, then it is ripe” and the fact “Tomato #78 is fairly red”, the conclu-
sion “Tomato #78 is ripe+Δ(red | fairly red)”, i.e., “Tomato #78 is fairly ripe”, can 
be inferred. 
 
The following definitions of the satisfaction relations between AFLP interpreta-
tions and AFLP clauses are based on the fuzzy rule model presented above. For 
simplicity, the same symbol |= is used to denote both the satisfaction relations 
with respect to the restricted and the general semantics. It will be clear in a spe-
cific context which one this symbol applies to. Also, in the definitions below, for 
the case of clauses with empty bodies, we define max(∅) = 0. 
 
Definition 3.3.5. Let P be an AFLP and I be an r-interpretation. The restricted 
satisfaction relation is defined as follows: 
1.  I |= P iff I |= C, for every clause C in P, 
2.   I |= C iff I |= gC , for every ground instance gC of clause C, 
3.  I |= Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn (a ground instance) iff 
H+maxi=1,n{Δ(Bi | I(Obji))} ≤ι I(Obj). 
I is a restricted model (r-model) of P iff I |= P. 
 
Definition 3.3.6. Let P be an AFLP and I be a g-interpretation. The general satis-
faction relation is defined as follows: 
1.   I |= P iff I |= C, for every clause C in P, 
2.   I |= C iff I |= gC , for every ground instance gC of clause C, 
3.  I |= Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn (a ground instance) iff 
H+maxi=1,n{Δ(Bi | Bi*)}∈I(Obj) where Bi*∈I(Obji) for every i from 1 to n. 
I is a general model (g-model) of P iff I |= P. 

3.3   AFLP Model-Theoretic Semantics 
55
 
By Definition 3.3.5, for every ground clause Obj: A and r-interpretation I, I |= Obj: 
A iff A ≤ι I(Obj). Thus, given two r-interpretations I1 and I2, if I1 |= Obj: A and I1 
≤ι I2 then  I2 |= Obj: A. Similarly, by  Definition 3.3.6, for every  ground  clause 
 Obj: A  and g-interpretation I, I |= Obj: A iff A∈I(Obj) and thus, given two g-
interpretations I1 and I2, if I1 |= Obj: A and I1 ≤ι I2 then I2 |= Obj: A. 
 
Example 3.3.4. Let P be the program having only one clause age(John): young, 
and I be the r-interpretation {age(John) 6 very young}. Then I is an r-model of 
P, provided that young ≤ι very young. For another example, suppose the relations 
between red, fairly red, ripe, and fairly ripe as in Example 3.3.3 and red ≤ι very 
red, but ripe ≤ι not ripe does not hold. Then, in Example 3.3.2, I2 is an r-model of 
the program, but I1 is not. 
 
As usual, a program Q is said to be a logical consequence of a program P with re-
spect to the restricted semantics iff, for every r-interpretation I, if I |= P then I |= 
Q. Two programs P and Q are said to be equivalent with respect to the restricted 
semantics iff P is a logical consequence of Q, and Q is a logical consequence of P 
with respect to the restricted semantics. A conjunction Obj1: B1 & Obj2: B2 & ... & 
Objn: Bn is said to be a logical consequence of P with respect to the restricted se-
mantics iff every Obji: Bi (1 ≤ i ≤ n) is a logical consequence of P with respect to 
the restricted semantics. Those with respect to the general semantics are defined 
similarly.  
We note that, for any AFLP P and Obj∈BL, Obj: ⊥ is a logical consequence of 
P with respect to the restricted semantics, but this does not hold with respect to the 
general semantics. That is because the least r-interpretation I⊥ maps every object 
to ⊥, while the least g-interpretation I∅ maps every object to ∅. Also on the basis 
of Definitions 3.3.5 and 3.3.6, for any Obj∈BL, Obj: B is a logical consequence of 
Obj: A if A ⊆ B, and {Obj: A, Obj: B} is equivalent to Obj: A∩B, with respect to 
both the restricted and the general semantics. These are respectively in accordance 
with the entailment principle and the principle of minimum specificity presented 
in Section 2.5. 
As analysed in Cao (2004), unlike the model-theoretic semantics of fuzzy truth-
value logic (Esteva, Garcia-Calvés and Godo 1994) and possibilistic logic (Du-
bois, Lang and Prade 1994), an advantage of AFLP model-theoretic semantics is 
that an AFLP having local inconsistencies about some objects does not arbitrarily 
entail everything about other objects. For example, let P be the AFLP {price(#36): 
expensive, price(#36): cheap, age(John): young}. Here, there is an inconsistency to 
some degree about price(#36) when expensive∩cheap is a subnormal fuzzy set. 
However, P still has a model I = {price(#36) 6 T, age(John) 6 young}, for in-
stance, and age(John): very young is not a logical consequence of P, when young 
<ι very young. Naturally, the local inconsistency about price(#36) here should not 
have any implication regarding John’s age. Moreover, if expensive ∩ cheap is 
subnormal but not equal to T, i.e., the inconsistency is only partial, then P also 
does not imply price(#36): A when expensive∩cheap <ι A, i.e., A is more inconsis-
tent than expensive∩cheap. 

56 
3   Annotated Fuzzy Logic Programming
 
3.4   AFLP Fixpoint Semantics 
As for classical logic programs and annotated logic programs, each AFLP P is as-
sociated with a function RP that maps r-interpretations to r-interpretations for the 
restricted semantics, and a function TP that maps g-interpretations to g-
interpretations for the general semantics. These functions, respectively for the re-
stricted and the general semantics, provide links between the declarative and the 
procedural semantics of P. 
Definition 3.4.1. Let I be an r-interpretation and Obj∈BL. Then RP(I)(Obj) is de-
fined to be lub{H+ε | Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn is a ground 
instance of a clause in P, and ε = maxi=1,n{Δ(Bi | I(Obji))}}. 
Definition 3.4.2. Let I be a g-interpretation and Obj∈BL. Then TP(I)(Obj) is de-
fined to be the least ideal containing {H+ε | Obj: H ← Obj1: B1 & Obj2: B2 & ... & 
Objn: Bn is a ground instance of a clause in P, and ε = maxi=1,n{Δ(Bi | Bi*)} where 
Bi*∈I(Obji) for every i from 1 to n}. 
For example, let P be the program in Example 3.2.1 and I = {color(#78)  6 very 
red, ripeness(#78) 6 ⊥}. Then RP(I) = {color(#78) 6 fairly red, ripeness(#78) 
6 ripe}, provided that red ≤ι very red. Intuitively, RP(I⊥) consists of all ground 
instances of the facts in P. Then RP(RP(I⊥)) consists of all ground instances of the 
facts and the conclusions obtained from application of the rules in P with the facts, 
and so on. 
Definition 3.4.3. The upward iterations of RP and TP are defined as follows: 
1.   RP↑0 = I⊥,  
RP↑α = RP(RP↑(α − 1)), if α is a successor ordinal, 
RP↑α = lub{RP↑β | β < α}, if α is a limit ordinal. 
2.   TP↑0 = I∅,  
TP↑α = TP(TP↑(α − 1)), if α is a successor ordinal, 
TP↑α = lub{TP↑β | β < α}, if α is a limit ordinal. 
For example, let P be the program in Example 3.2.1 and assume the relations be-
tween red, fairly red, ripe, and fairly ripe as in Example 3.3.3. Then one has: 
RP↑0 = I⊥ = {color(#78) 6 ⊥, ripeness(#78) 6 ⊥} 
RP↑1  = RP(RP↑0)  
= {color(#78) 6 fairly red, ripeness(#78) 6 ripe+Δ(red | ⊥)} 
RP↑2  = RP(RP↑1) 
= {color(#78) 6 fairly red,  
ripeness(#78) 6 ripe+Δ(red | fairly red)} 
= {color(#78) 6 fairly red, ripeness(#78) 6 fairly ripe} 
RP↑3 = RP(RP↑2) = RP↑2  
... 
RP↑ω  = lub{RP↑n | n ∈ N} = RP↑2 
where ω = {0, 1, 2, ...} is the smallest limit ordinal (apart from 0). 

3.4   AFLP Fixpoint Semantics 
57
 
It is expected that RP↑ω and TP↑ω are respectively the minimal (i.e., least spe-
cific) r-model and g-model of P. To prove this, we first prove some preliminary 
results, which are similar to those for classical logic programs (Lloyd 1987) and 
annotated logic programs (Kifer and Subrahmanian 1992), as stated by Proposi-
tions 3.4.1 and 3.4.2 below. 
 
Proposition 3.4.1. RP and TP are monotonic, that is: 
1.  If I1 ≤ι I2 then RP(I1) ≤ι RP(I2), where I1, I2 are r-interpretations. 
2.  If I1 ≤ι I2 then TP(I1) ≤ι TP(I2), where I1, I2 are g-interpretations. 
 
Since RP↑0 = I⊥ is the least specific r-interpretation, one has RP↑0 ≤ι RP↑1, 
whence RP↑1 = RP(RP↑0) ≤ι RP(RP↑1) = RP↑2, due to the monotonicity of RP . By 
induction, one has RP↑n ≤ι RP↑(n + 1) for every n ∈ N. Similarly, one has TP↑n ≤ι 
TP↑(n + 1) for every n ∈ N. 
 
Proposition 3.4.2. Let  P  be  an  AFLP  and  Ir  and  Ig  be  an  r-interpretation 
 and  a g-interpretation, respectively. Then: 
1.  Ir is an r-model of P iff RP(Ir) ≤ι Ir . 
2.  Ig is a g-model of P iff TP(Ig) ≤ι Ig. 
 
Since the set of all r-interpretations and the set of all g-interpretations are com-
plete lattices (Definitions 3.3.3 and 3.3.4), Proposition 3.4.3 below is a corollary 
of Propositions 3.4.1 and 3.4.2. This is based on a result in Lloyd (1987) that, if L 
is a complete lattice under some partial order ≤L and F: L → L is a monotonic 
function, then lfp(F) = glb{x | F(x) = x} = glb{x | F(x) ≤L x} ∈ {x | F(x) ≤L x}, 
where lfp(F) is the least fixpoint of F. 
 
Proposition 3.4.3. Let P be an AFLP. Then: 
1.  lfp(RP) = glb{I | RP(I) = I} = glb{I | RP(I) ≤ι I} = MrP is P’s minimal r-
model. 
2.  lfp(TP) = glb{I | TP(I) = I} = glb{I | TP(I) ≤ι I} = MgP is P’s minimal g-model. 
 
That MrP is the minimal r-model of P means MrP is an r-model of P and MrP ≤ι I for 
every r-model I of P. Thus, a ground clause Obj: A is a logical consequence of P 
with respect to the restricted semantics iff MrP |= Obj: A, that is, A ≤ι MrP(Obj). 
Similarly, with respect to the general semantics, Obj: A is a logical consequence of 
P iff MgP |= Obj: A, that is, A ∈ MgP(Obj). To establish the expected equalities be-
tween RP↑ω and MrP and between TP↑ω and MgP , we prove the continuity of RP 
and TP as stated by Proposition 3.4.4 below. 
 
Proposition 3.4.4. RP and TP are continuous, that is: 
1. RP(lub{Ij}) = lub{RP(Ij)}, for all sequences I1 ≤ι I2 ≤ι ... of r-interpretations. 
2. TP(lub{Ij}) = lub{TP(Ij)}, for all sequences I1 ≤ι I2 ≤ι ... of g-interpretations. 
 
 

58 
3   Annotated Fuzzy Logic Programming
 
Then, the following theorem, which defines the fixpoint semantics of annotated 
fuzzy logic programs, comes from Proposition 3.4.3 and the continuity of TP and 
RP . This is based on a result in Lloyd (1987) that, if L is a complete lattice under 
some partial order ≤L and F: L → L is a continuous function, then F↑ω = lfp(F). 
 
Theorem 3.4.1. Let P be an AFLP. Then: 
1.  RP↑ω = lfp(RP) = MrP.  
2.  TP↑ω = lfp(TP) = MgP.  
 
The equalities RP↑ω = lfp(RP) and TP↑ω = lfp(TP) in Theorem 3.4.1 say that P has 
the fixpoint reachability property, as termed by Kifer and Subrahmanian (1992), 
for the restricted and the general semantics, respectively. The authors proved that, 
with respect to the general semantics, any annotated logic program defined therein 
had the fixpoint reachability property. However, with respect to the restricted se-
mantics, only the programs whose rule bodies contained only constants as annota-
tions or only variables as annotations had that property.  
Furthermore, as discussed in Van Emden (1986), for the completeness of a 
proof procedure, it is desirable not only that a program has the fixpoint reachabil-
ity, but also that the reachability is finite. For the restricted semantics of an AFLP 
P, the finite fixpoint reachability property means, if A ≤ι lfp(RP)(Obj), then there 
exists k∈N such that A ≤ι RP↑k(Obj). For the general semantics, it means, if 
A∈lfp(TP)(Obj), then there exists k∈N such that A∈TP↑k(Obj).  
The significance of Theorem 3.4.1 with the finite fixpoint reachability property 
of P, with respect to the restricted or the general semantics, is that it ensures a fi-
nite sound and complete mechanical proof procedure for P. Indeed, with respect to 
the 
restricted 
semantics, 
if 
A 
≤ι RP↑k(Obj) 
then 
A 
≤ι RP↑ω(Obj) 
= lfp(RP)(Obj) = MrP(Obj) ≤ι I(Obj) for every r-model I of P. This means Obj: A is 
a logical consequence of P, hence the soundness.  
On the other hand, if Obj: A is a logical consequence of P, then Obj: A must be 
satisfied by MrP as an r-model of P, i.e., A ≤ι MrP(Obj) = lfp(RP)(Obj), whence A 
≤ι RP↑k(Obj) for some k∈N, due to the finite fixpoint reachability property of P. 
This means Obj: A can be “reached” after a finite number of upward iterations of 
RP , hence the completeness. It is similar for the general semantics with TP . 
We recall that TP↑n(Obj) is an ideal, which is a set, and A∈lfp(TP)(Obj) 
= TP↑ω(Obj) = lub{TP↑n(Obj) | n∈N} can be rewritten as A ≤ι lub{TP↑n(Obj) | 
n∈N} with A being considered as a principal ideal defined by itself. Then, due to 
the property of principal ideals mentioned in Section 3.2 and TP↑0 ≤ι TP↑1 ≤ι ..., 
there must exist k∈N such that A ≤ι TP↑k(Obj), i.e., A∈TP↑k(Obj). But this is not 
the case for RP , because RP↑n(Obj) is not an ideal and thus A ≤ι lfp(RP)(Obj) 
= RP↑ω(Obj) = lub{RP↑n(Obj) | n ∈ N} does not entail A ≤ι RP↑k(Obj) for some 
k∈N. Intuitively, one has 1 = lub{n/(n + 1) | n∈N} with respect to ≤, but there is 
no k∈N such that 1 ≤ k/(k + 1).  
This explains why the proof procedure in Kifer and Subrahmanian (1992) was 
shown to be complete only with respect to the general semantics but, generally,  
 

3.5   AFLP Reductants and Constraints 
59
 
incomplete with respect to the restricted semantics. In Lu, Nerode and Subrahma-
nian (1996), which was based on the restricted semantics, the completeness result 
was also obtained only for programs that had the finite fixpoint reachability prop-
erty, but the authors did not specify in which cases a program had this property. 
Programs in Van Emden (1986), which were also based on the restricted seman-
tics and could be regarded as special cases of those in Kifer and Subrahmanian 
(1992), were proved to have the finite fixpoint reachability property. We have a 
similar result for restricted AFLPs. 
 
Proposition 3.4.5. If P is a restricted AFLP, then P has the finite fixpoint reach-
ability property with respect to the restricted semantics. 
 
Therefore, in the rest of this volume, we assume the general semantics, so that finite 
proofs of logical consequences of fuzzy set logic programs are guaranteed to exist. 
So far, we have required fuzzy set lattices to be complete (Definition 3.2.1) just to 
obtain the completeness of r-interpretation lattices (Definition 3.3.3). For the general 
semantics, this requirement can be obviated because g-interpretations are based on 
ideals, which always form a complete lattice from just an upper semi-lattice. 
3.5   AFLP Reductants and Constraints 
In SLD-resolution in classical logic programming (Lloyd 1987), a goal is resolved 
with one clause of a program at each resolution step. In annotated logic program-
ming, with lattice-based data, that is not adequate to obtain a complete backward 
chaining proof procedure, because derived lattice-based values have to be com-
bined to produce more specific ones. 
Indeed, let us suppose a program P containing two rules “y is H1 ← x is B” and 
“y is H2 ← x is B” and a fact “x is B”, where B, H1 and H2 are lattice-based values. 
By forward chaining, one obtains “y is H1” and “y is H2” and thus “y is lub{H1, 
H2}” as logical consequences of P. However, the goal “y is lub{H1, H2}” cannot 
be resolved with either of the two rules, because neither lub{H1, H2} ≤ι H1 nor 
lub{H1, H2} ≤ι H2 holds, in general. Thus, the two rules have to be combined into 
one rule as “y is lub{H1, H2} ← x is B”, for the goal to be resolvable with it. Such 
a combined rule is called a reductant of P (Kifer and Subrahmanian 1992). 
In the case of fuzzy rules, there is another issue due to their behaviour that a 
conclusion with some uncertainty degree can be inferred when there is a mis-
matching between a fact and the body of a rule. For example, with the currently 
applied fuzzy rule model, as presented in Section 3.3, if a program P contains a 
rule “y is H ← x is B” and a fact “x is B*”, then the conclusion “y is H+Δ(B | B*)” 
is inferred as a logical consequence of P. If the classical SLD-resolution mecha-
nism is applied, with H+Δ(B | B*) ≤ι H, then the resolvent of “y is H+Δ(B | B*)” 
and the rule is its body, which is “x is B”. This new goal, however, cannot be re-
solved further with the fact, because B ≤ι B* does not hold, in general. 
Actually, in this case, there is a tolerance degree of “y is H+Δ(B | B*)” and “y 
is H” of value Δ(B | B*). This tolerance degree should be propagated back to the 

60 
3   Annotated Fuzzy Logic Programming
 
body of the rule to produce the resolvent “x is B+Δ(B | B*)”, which is resolvable 
with the fact, because B+Δ(B | B*) ≤ι B* always holds as a corollary of Proposition 
3.5.2. Put in another way, the propagation of tolerance degrees can be integrated 
into a rule as “y is H+ε ← x is B+ε” as a reductant of P, where ε is a variable 
whose value is a real number in [0, 1]. Then the resolvent of “y is H+Δ(B | B*)” 
with this reductant is its body, which is “x is B+ε” with the constraint H+Δ(B | B*) 
≤ι H+ε, where a value for ε to satisfy the constraint is to be found. The further 
resolution of “x is B+ε” with the fact produces another constraint, which is B+ε 
≤ι B*. Thus, the accumulated constraint is (B+ε ≤ι B*) & (H+Δ(B | B*) ≤ι H+ε), 
whose solution is ε = Δ(B | B*). The existence of a solution for the constraint 
means that the goal is satisfied by P. The idea of resolution by solving constraints 
presented here is from generalized annotated logic programming (Kifer and 
Subrahmanian 1992), where annotations can contain variables and thus constraints 
are produced along with resolution steps. 
Therefore, in an SLD-resolution style proof procedure for annotated fuzzy logic 
programs, which we call AFLP resolution, reductants rather than clauses are  
selected in resolution steps and there are constraints to be solved. For this, we 
generalize the notion of annotations to be not only fuzzy set constants but also ex-
pressions containing variables, such as H+ε or B+ε in the reductant above. We call 
them AFLP annotation terms as in the following definition. In the definition, a 
function f is said to be computable iff there is a procedure that produces a value 
for every possible argument of f in a finite amount of time (cf. Hopcroft and Ull-
man 1979). Also, f is said to be monotonic iff f(τ1, τ2, ..., τm) ≤ι f(τ1*, τ2*, ..., τm*) 
when τi ≤ι τi* for every i from 1 to m. 
 
Definition 3.5.1. An AFLP annotation term is recursively defined to be of either 
of the following forms: 
1.  A fuzzy set constant, or 
2.  A+ξ, where A is a fuzzy set and ξ is a variable whose value is a real number 
in [0, 1], or 
3.  A variable whose value is a fuzzy set, or 
4.  f(τ1, τ2, ..., τm), where each τi (1 ≤ i ≤ m) is an AFLP annotation term and f 
is a computable and monotonic function from L1 × L2 × ... × Lm to L, with L 
and Li’s being fuzzy set lattices. 
Annotation terms of the first three forms are called simple AFLP annotation terms.  
 
We denote fuzzy set variables by X, Y, ..., and real number variables by ξ, ψ, .... 
These are called annotation variables to be distinguished from object variables of 
a first- order predicate logic vocabulary, which are denoted by x, y, ... . An expres-
sion without any annotation variable is called annotation variable-free. An ex-
pression without any object variable is called object variable-free. An expression 
without both annotation variables and object variables is called variable-free, or 
ground.  
We now define AFLP reductants, taking into account both the issues of lattice-
based logic programming and fuzzy rule tolerance degrees discussed above. In the 

3.5   AFLP Reductants and Constraints 
61
 
definition below, we apply the definition of most general unifiers (mgu) of predi-
cates and terms in Lloyd (1987). 
 
Definition 3.5.2. Let P be an AFLP and C1, C2, ..., Cm be different clauses in P. 
Suppose that no pair of Ci and Cj (i ≠ j) shares common variables, and each Ck (1 ≤ 
k ≤ m) is of the form: 
Objk: Hk ← Objk1: Bk1 & Objk2: Bk2 & ... & Objkn: Bkn 
Suppose further that Obj1, Obj2, ..., Objm are unifiable via a most general unifier θ. 
Then the clause: 
[Obj1: lub{H1+ξ1, H2+ξ2, ..., Hm+ξm}  
←  Obj11: B11+ξ1 & Obj12: B12+ξ1 & ... & Obj1n: B1n+ξ1 &  
Obj21: B21+ξ2 & Obj22: B22+ξ2 & ... & Obj2n: B2n+ξ2 & ... & 
Objm1: Bm1+ξm & Objm2: Bm2+ξm & ... & Objmn: Bmn+ξm 
]θ 
is called a reductant of P. 
 
In Definition 3.5.2, for Ck taking part in the reductant, with regard to forward 
chaining, the real number variable ξk represents an unknown mismatching degree 
of the body of Ck to some fact. Whereas, with regard to backward chaining, it 
represents an unknown tolerance degree of some goal to the head of Ck. If the 
body of Ck is empty then ξk = 0. Moreover, Objk: Hk+ξk ← Objk1: Bk1+ξk & Objk2: 
Bk2+ξk & ... & Objkn: Bkn+ξk is also a reductant, which is constructed from only Ck. 
In fact, given an AFLP of n clauses, the maximal number of its reductants 
(modulo renaming) is: 
C 1
n + C 2
n + … + C n
n  
where C i
n  (1 ≤ i ≤ n) is the number of combinations of n elements taken i at a 
time. 
 
Example 3.5.1. Let P be the following AFLP: 
price(x): not expensive ← demand(x): not high 
price(y): not cheap ← demand(y): not low 
demand(#36): normal 
quality(#36): quite good. 
The first rule says “If the demand on a product is not high, then its price is not 
expensive”. The second rule says “If the demand on a product is not low, then its 
price is not cheap”. The first fact says “The demand on product #36 is normal”. 
The second fact says “The quality of product #36 is quite good”. 
Suppose the relations between the fuzzy sets of linguistic labels not high, not 
low, normal, not expensive, not cheap and moderate are that normal = not 
high∩not low and moderate = not expensive∩not cheap, as in Figure 3.2.2. A re-
ductant of P with the most general unifier {x/y} is: 
price(y): lub{not expensive+ξ, not cheap+ψ}  
← demand(y): not high+ξ & demand(y): not low+ψ. 
 

62 
3   Annotated Fuzzy Logic Programming
 
The major drawback of the generalized annotated logic programs of Kifer and 
Subrahmanian (1992) is that the set of all reductants of a program may be infinite, 
even though the set of the program clauses is finite, as noted by the authors, and 
Lu, Nerode and Subrahmanian (1996). The reason is that a combination of several 
variable-renamed versions of the same clause of a program may produce an indis-
pensable reductant. The source of the problem is that, in generalized annotated 
logic programs, a variable or a function is allowed to be the annotation in the head 
of a rule.  
That is not the case for annotated fuzzy logic programs, because the annotations 
in the heads of AFLP rules are only fuzzy set constants. Although there are im-
plicit real number variables in AFLP rules for propagating mismatching degrees 
and tolerance degrees, as seen in the declarative semantics and the reductant con-
struction of annotated fuzzy logic programs, the real number interval [0, 1] is a 
one-wide lattice (Kifer and Subrahmanian 1992). It thus makes reductants con-
structed from different variable-renamed versions of the same AFLP clause re-
dundant.  
For example, a reductant constructed from two different variable-renamed ver-
sions of the first clause of P in Example 3.5.1 is: 
price(x): lub{not expensive+ξ, not expensive+ψ}  
← demand(x): not high+ξ & demand(x): not high+ψ 
which is equivalent to: 
price(x): not expensive+min{ξ, ψ} ← demand(x): not high+min{ξ, ψ} 
Since min{ξ, ψ} is either ξ or ψ, this reductant does not give any more informa-
tion than a reductant constructed from a single version of the clause does, i.e., it is 
redundant. For the same reason, in the case of restricted AFLPs, any reductant 
constructed from two or more program clauses is redundant, that is, in that case 
only reductants constructed from single program clauses are required in AFLP 
resolution. 
The following proposition states a logical relationship between an AFLP and its 
reductants, which is used to prove the soundness of AFLP resolution. 
 
Proposition 3.5.1. Let P be an AFLP, Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: 
Bn be an annotation variable-free instance of a reductant of P, and θ be a substitu-
tion for object variables in this reductant. If (Obj1: B1 & Obj2: B2 & ... & Objn: 
Bn)θ is a logical consequence of P, then so is (Obj: H)θ. 
 
As explained at the beginning of this section, a resolvent of a goal and a reductant 
of an AFLP may contain constraints, due to the occurrence of variables in the goal 
and/or the reductant. The remaining part of this section presents the formal defini-
tion of AFLP constraints and the result of their solvability. 
 
Definition 3.5.3. An AFLP constraint is defined to be of the form: 
σ1 ≤ι φ1 & σ2 ≤ι φ2 & ... & σm ≤ι φm 
where, for each i from 1 to m, σi and φi are two AFLP annotation terms evaluated 
to fuzzy sets on the same domain. The constraint is said to be normal iff, for  
 

3.6   AFLP Procedural Semantics 
63
 
each i from 1 to m, σi is a simple AFLP annotation term and if σi contains a vari-
able then this variable does not occur in φ1, φ2, ..., φi. 
 
Definition 3.5.4. A solution for an AFLP constraint C is a substitution ϕ for anno-
tation variables in C such that every ground instance of Cϕ holds. An AFLP  
constraint is said to be solvable iff there is an algorithm to decide whether the con-
straint has a solution or not, and to identify a solution if it exists.  
 
In Definition 3.5.3, the order of the inequalities σi ≤ι φi’s is significant with respect 
to the normality of the constraint. In Definition 3.5.4, ϕ does not necessarily con-
tain a binding for every annotation variable. Also, a constraint having a solution is 
not necessarily solvable, because there may not exist an algorithm to identify what 
a solution is. On the other hand, a solvable constraint may not have a solution. The 
following proposition states the solvability of normal AFLP constraints. 
 
Proposition 3.5.2. Any normal AFLP constraint is solvable. 
 
In the proof of Proposition 3.5.2, the algorithm for testing the satisfiability of 
normal AFLP constraints is adapted from Kifer and Subrahmanian (1992) for con-
straints on fuzzy set values. The role of the algorithm is mainly to prove the  
decidability of the satisfiability problem of normal AFLP constraints. Studying  
efficient ways to solve such constraints, which belongs to the general topic of con-
straint satisfaction, is beyond the scope of this volume. 
 
Example 3.5.2 The following AFLP constraint: 
(X ≤ι quite good) & (not high+ψ ≤ι normal) & (not low+ξ ≤ι normal) & 
(moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
is a normal AFLP constraint. The function lub on two fuzzy sets is their intersec-
tion, which is monotonic and computable. Applying the constraint solving algo-
rithm, one obtains X = quite good, ψ = Δ(not low | normal) = 0 and ξ = Δ(not high | 
normal) = 0, whence a solution for the constraint is {X/quite good, ψ/0, ξ/0}. 
3.6   AFLP Procedural Semantics 
In classical logic programming a goal is a conjunction of atoms. In annotated logic 
programming or annotated fuzzy logic programming a goal contains a conjunction 
of annotated atoms or annotated objects, respectively, which is called the query 
part. Moreover, it can have a conjunction of constraints on annotation variables 
occurring in its query part, which is called the constraint part. 
 
Definition 3.6.1. An AFLP goal G is defined to be of the form QG || CG, where QG 
is the query part which is of the form O1: σ1 & O2: σ2 & ... & Om: σm with σi’s be-
ing simple AFLP annotation terms, and CG is the constraint part which is  
an AFLP constraint. The goal is said to be normal iff CG is a normal AFLP  
constraint.  

64 
3   Annotated Fuzzy Logic Programming
 
Then, with respect to an AFLP, a goal is satisfied iff there is a correct answer for 
the object variables and annotation variables occurring in it, as defined below. In 
the definition, θ, as well as ϕ, does not necessarily contain a binding for every 
variable. Also, an annotation variable-free conjunction O1: σ1 & O2: σ2 & ... & Om: 
σm is a logical consequence of P iff every Oi: σi (1 ≤ i ≤ m) is a logical conse-
quence of P. 
 
Definition 3.6.2. Let P be an AFLP and G be an AFLP goal. An answer for G wrt 
P is a pair <θ, ϕ> where θ is a substitution for object variables in G, and ϕ is a 
substitution for annotation variables in G. The answer is said to be correct iff ϕ is 
a solution for CG and every annotation variable-free instance of QGθϕ is a logical 
consequence of P. 
 
As discussed before, at each AFLP resolution step, a goal is resolved with a reduc-
tant rather than a clause of a program, producing a resolvent as a new goal. The 
query part of the new goal comprises the body of the reductant and the remainder 
of the query part of the old goal, after the annotated object unified with the head of 
the reductant is deleted from it. The constraint part of the new goal comprises the 
constraint part of the old goal and the constraint produced by the unification of the 
deleted annotated object and the head of the reductant. 
 
Definition 3.6.3. Let G be a goal O1: σ1 & O2: σ2 & ... & Om: σm || CG and C be a 
reductant Obj: φ ← Obj1: φ1 & Obj2: φ2 & ... & Objr: φr of an AFLP (G and C have 
no variable in common). Suppose that Ok and Obj are unifiable via a most general 
unifier θ. The corresponding resolvent of G and C is a new AFLP goal, denoted by 
Rθ(G, C), and defined to be: 
[O1: σ1 & ... & Ok−1: σk−1 & (Obj1: φ1 & Obj2: φ2 & ... & Objr: φr) & Ok+1: σk+1 & 
... & Om: σm]θ || (σk ≤ι φ & CG). 
When θ is required to be a unifier but not necessarily a most general unifier, Rθ(G, 
C) is called an unrestricted resolvent. 
 
In the definition above, the order of σk ≤ι φ and CG is significant with respect to 
the normality of the constraint σk ≤ι φ & CG. A refutation of a goal and an AFLP is 
then defined as a finite sequence of resolution steps such that, the query part of the 
last goal is empty and its constraint part is solvable with a solution. 
 
Definition 3.6.4. Let P be an AFLP and G be an AFLP goal. A refutation of G 
and P is a finite sequence G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn such that: 
1.  For each i from 1 to n, Gi = Rθ(Gi−1, Ci), where G0 = G, and Ci is a reductant 
of P, and 
2.  QG is empty, and  
3.  CG is solvable and has a solution.  
When θi’s are required to be unifiers but not necessarily most general unifiers, the 
refutation is called an unrestricted refutation. 
 

3.6   AFLP Procedural Semantics 
65
 
Example 3.6.1. Let P be the program in Example 3.5.1 and G be the following 
query asking “Which product has a moderate price and what is its quality like?”: 
price(x): moderate & quality(x): X. 
Assuming the relations between the fuzzy sets of the linguistic labels in P and G 
as in Example 3.5.1, a refutation of G and P can be constructed as follows: 
C1 = price(y): lub{not expensive+ξ, not cheap+ψ}  
← demand(y): not high+ξ & demand(y): not low+ψ 
θ1 = {x/y} 
G1  = demand(y): not high+ξ & demand(y): not low+ψ & quality(y): X 
|| (moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
C2  = demand(#36): normal 
θ2 = {y/#36} 
G2  = demand(#36): not low+ψ & quality(#36): X 
|| (not high+ξ ≤ι normal) &  
 (moderate ≤ι lub{not expensive+ξ, not cheap+ψ})  
C3  = demand(#36): normal 
θ3  = {} 
G3  = quality(#36): X 
|| (not low+ψ ≤ι normal) & (not high+ξ ≤ι normal) & 
 (moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
C4  = quality(#36): quite good 
θ4  = {} 
G4  = ||  (X ≤ι quite good) & (not low+ψ ≤ι normal) &  
(not high+ξ ≤ι normal) & 
(moderate ≤ι lub{not expensive+ξ, not cheap+ψ}). 
As solved in Example 3.5.2, a solution for the constraint above is {X/quite good, 
ψ/0, ξ/0}, whence the corresponding answer for G wrt P is <{x/#36}, {X/quite 
good}>. We note that, if a clause rather than a reductant of P were used to resolve 
price(x): moderate, there would not be a refutation of G and P because, generally, 
neither moderate ≤ι not expensive nor moderate ≤ι not cheap holds. 
 
The following theorem states the soundness of the presented AFLP resolution 
proof procedure. 
 
Theorem 3.6.1. (AFLP Resolution Soundness) Let P be an AFLP and G be an 
AFLP goal. If G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn is a refutation of G and 
P, and ϕ is a solution for CG, then <θ1θ2 ... θn, ϕ> is a correct answer for G wrt P. 
 
Meanwhile, the completeness means that, if there is a correct answer for a goal 
with respect to an AFLP, then there exists a refutation of the goal and the pro-
gram. According to Definition 3.6.4, a refutation of a goal and a program requires 
the constraint part of the last goal, whose query part is already empty, to be solv-
able (with a solution). By Proposition 3.5.2, the solvability of an AFLP constraint 
is guaranteed if it is normal. The following proposition states that, if a goal is 

66 
3   Annotated Fuzzy Logic Programming
 
normal then its resolvent with a reductant is also a normal goal. Consequently, the 
normality of a goal ensures the normality and thus the solvability of the constraint 
part of the last goal in a refutation of the original goal and an AFLP. 
 
Proposition 3.6.1. Let G and C be respectively a goal and a reductant of an AFLP. 
If G is a normal AFLP goal, then any (unrestricted) resolvent of G and C is also a 
normal AFLP goal. 
 
The completeness of the presented AFLP proof procedure for normal goals is then 
obtained as stated in the following theorem. 
 
Theorem 3.6.2. (AFLP Resolution Completeness) Let P be an AFLP and G be a 
normal AFLP goal. If there exists a correct answer for G wrt P, then there exists a 
refutation of G and P. 
3.7   Order-Sorted AFLPs 
In order-sorted predicate logic, each term (possibly a variable or a constant) is ex-
plicitly declared to be of a type. For example, the following formula says “Every 
MAN is mortal”: 
∀x: MAN. mortal(x) 
where x is a variable of type MAN. As is well-known, order-sorted predicate logic 
can be reduced to unsorted predicate logic by using unary type predicates. For  
example, the above formula can be translated to: 
∀x (MAN(x) → mortal(x)) 
where MAN() is a type predicate. Due to the implication connective, it is not as 
close to the structure of the natural language sentence that it represents as the  
order-sorted formula is, and is thus less natural. 
However, type predicates are still useful to deal with dynamic types, when 
types of objects may change along with information gathered, as discussed in 
Beierle et al. (1992). An example of dynamic types taken from that work is the 
following rule expressing “For every HUMAN_BEING x, if x is hiking then x is a 
HIKER”: 
∀x: HUMAN_BEING. (hiking(x) → HIKER(x)) 
where x is declared to be a variable of type HUMAN_BEING and HIKER() is a type 
predicate, but the type of x changes to HIKER when the information hiking(x) is  
asserted.  
As such, the rule provides additional taxonomic information, which may even 
effect a type hierarchy of discourse. It is called close coupling between the axio-
matic and the taxonomic parts of a knowledge base, in contrast to loose coupling, 
which does not allow such a rule. In particular, a type hierarchy only says that an 
object belongs to all supertypes of its type, but close coupling allows one to  
express, in the axiomatic part of a knowledge base, rules stating when an object 
belongs to a subtype of its type. As exemplified by the authors, close coupling is 
particularly essential for natural language understanding systems, where types of  
 

3.7   Order-Sorted AFLPs 
67
 
objects described in a text may become more specific when more information is 
obtained during an analysis of the text. 
Further, type predicates can be annotated with fuzzy truth-values to represent 
uncertainty and/or partial truth about types. For example, the atomic formula 
RICH_MAN(John): more or less true says “It is more or less true that John is a 
RICH_MAN”. Since both type predicate symbols and fuzzy truth-values are com-
puted as lattice-based data, it is more convenient for both theoretical study and 
machinery computation to group a type predicate symbol and a fuzzy truth-value 
into a fuzzy type as formulated in Section 2.6.  
This can be done by introducing a reserved unary predicate type(), with which 
the above atomic formula can be rewritten as type(John): {(RICH_MAN, more or 
less true)}, using a conjunctive type, or type(John): (RICH_MAN, more or less 
true), for simplicity. This then gives a straight extension of the previously devel-
oped AFLP formalism to an order-sorted one by just adding the reserved predicate 
type() to its first-order predicate logic vocabulary and a conjunctive fuzzy type 
upper semi-lattice to its annotation base.  
An example of such an extended AFLP is the following program: 
buy(x, y): very true ← type(x): (RICH_MAN, very true) & 
type(y): CAR & like(x, y): more or less true 
type(John): (RICH_MAN, not false) 
type(#36): CAR 
like(John, #36): very true 
where we briefly write CAR for (CAR, absolutely true). The rule says “If it is very 
true that a person is a RICH_MAN and it is more or less true that he likes a car, then 
it is very true that he buys it”. The first fact says “It is not false that John is a 
RICH_MAN”. The second fact says “#36 is a CAR”. The third fact says “It is very 
true that John likes car #36”. 
As remarked after Propositions 2.6.8 and 2.6.9, conjunctive fuzzy type annota-
tions can be handled in the same way as fuzzy set ones. Also, by Proposition 2.6.3, 
conjunctive fuzzy types form an upper semi-lattice, on which a complete lattice of 
ideals can be defined. Thus, all the definitions and results for the general declara-
tive semantics and the proof procedure of AFLPs presented before can be general-
ized in a straightforward manner for those of AFLPs extended with fuzzy types, 
which we called order-sorted AFLPs. The remainder of this section formally 
elaborates on these ideas. Firstly, we formally define an order-sorted AFLP vo-
cabulary as follows.  
 
Definition 3.7.1. An order-sorted AFLP vocabulary consists of a first-order predi-
cate logic vocabulary with a reserved unary predicate type(), an annotation base of 
fuzzy sets and conjunctive fuzzy types, and an object-annotation conformity rela-
tion that maps type to the conjunctive fuzzy type upper semi-lattice and every 
other predicate or function symbol of the first-order predicate logic vocabulary to 
a fuzzy set lattice of the annotation base.  
 
Order-sorted AFLP annotated objects and clauses are then defined like those of 
AFLPs (Definitions 3.2.3 and 3.2.4), with only additional annotated objects of the 

68 
3   Annotated Fuzzy Logic Programming
 
form type(a): T or type(x): T, where a is an object constant, x is an object vari-
able, and T is an expression evaluated to a conjunctive fuzzy type. For example, 
the following order-sorted AFLP rule says “If a building has original architecture, 
then it is true that it is a building worth seeing”: 
type(x): (BUILDING_WORTH_SEEING, true) ← type(x): BUILDING &  
architecture(x): original. 
For the model-theoretic semantics, order-sorted AFLP interpretations are  
defined like g-interpretations of AFLPs (Definition 3.3.2), which also form a com-
plete lattice (Definition 3.3.4). The satisfaction relation of a program and an inter-
pretation is defined like that of AFLPs (Definition 3.3.6). Given an order-sorted 
AFLP P, the interpretation mapping TP is also defined and has the properties like 
that of an AFLP (Definition 3.4.2 and Propositions 3.4.1 to 3.4.4). Therefore, a 
fixpoint semantics theorem similar to that for AFLPs (Theorem 3.4.1) is obtained 
for order-sorted AFLPs as stated below, where MP is the minimal model of P. 
 
Theorem 3.7.1. Let P be an order-sorted AFLP. Then TP↑ω = lfp(TP) = MP. 
 
AFLP annotation terms (Definition 3.5.1) are now extended for order-sorted 
AFLPs with conjunctive fuzzy type constants and variables, as in the following 
definition. 
 
Definition 3.7.2. An order-sorted AFLP annotation term is recursively defined to 
be of either of the following forms: 
1.  A fuzzy value constant, which is a fuzzy set or a conjunctive fuzzy type, or 
2.  A+ξ, where A is a fuzzy value constant and ξ is a variable whose value is a real 
number in [0, 1], or 
3.  A variable whose value is a fuzzy set or a conjunctive fuzzy type, or 
4.  f(τ1, τ2, ..., τm), where each τi (1 ≤ i ≤ m) is an order-sorted AFLP annotation 
term and f is a computable and monotonic  function from L1 × L2 × ... × Lm to L, 
with L and Li’s being lattices of fuzzy sets or upper semi-lattices of conjunctive 
fuzzy types. 
Order-sorted AFLP annotation terms of the first three forms are called simple or-
der-sorted AFLP annotation terms.  
 
Order-sorted AFLP reductants are then defined like those of AFLPs (Definition 
3.5.2). For example, a reductant constructed from the rule given after Definition 
3.7.1 is:  
type(x): (BUILDING_WORTH_SEEING, true)+ε  
← type(x): BUILDING+ε & architecture(x): original+ε 
where ε is a real number variable. We recall that: 
(BUILDING_WORTH_SEEING, true)+ε  
= (BUILDING_WORTH_SEEING, true+ε) 
BUILDING+ε = (BUILDING, absolutely true+ε). 
 
The following proposition states a logical relationship between an order-sorted 
AFLP and its reductants, similar to Proposition 3.5.1 for an AFLP. 

3.7   Order-Sorted AFLPs 
69
 
Proposition 3.7.1. Let P be an order-sorted AFLP, Obj: H ← Obj1: B1 & Obj2: B2 
& ... & Objn: Bn be an annotation variable-free instance of a reductant of P, and θ 
be a substitution for object variables in this reductant. If (Obj1: B1 & Obj2: B2 & ... 
& Objn: Bn)θ is a logical consequence of P, then so is (Obj: H)θ. 
 
Order-sorted AFLP constraints and their solvability are defined like those of 
AFLPs (Definitions 3.5.3 and 3.5.4), with extended annotation terms as in Defini-
tion 3.7.2. However, the definition of constraint normality needs to be modified so 
that any normal order-sorted AFLP constraint is guaranteed to be solvable like a 
normal AFLP constraint. To see the reason and what should be done for this modi-
fication, let us look into the algorithm for testing the satisfiability of a normal 
AFLP constraint in the proof of Proposition 3.5.2. 
Firstly, in step 4(a), the mismatching degree function Δ may not be computable 
due to abnormal conjunctive fuzzy types, as discussed in Section 2.6. Secondly, in 
step 5(a), the value of glb for a set of conjunctive fuzzy types may not exist, as 
studied in Section 2.6. Therefore, to ensure the solvability of normal order-sorted 
AFLP constraints, we define their normality as follows, with additional conditions 
2 and 3 as compared with Definition 3.5.3.  
 
Definition 3.7.3. An order-sorted AFLP constraint σ1 ≤ι φ1 & σ2 ≤ι φ2 & ... & σm 
≤ι φm is said to be normal iff: 
1.  For each i from 1 to m, σi is a simple order-sorted AFLP annotation term 
and if σi contains a variable then this variable does not occur in φ1, φ2, ..., 
φi, and 
2.  For each i from 1 to m, if φi is evaluated to a conjunctive fuzzy type, then φi 
is of the form lub{T1+ξ1, T2+ξ2, ..., Tn+ξn} where Tj’s are conjunctive fuzzy 
type constants that are not abnormal, and ξj’s are constants or variables 
whose values are real numbers in [0, 1], and 
3.  No pair of σi and σj (i ≠ j) is the same conjunctive fuzzy type variable. 
 
As it is defined in Section 2.6, a fuzzy type (t, v) is abnormal iff v∉T and ∃v*∈T: 
v* ≤ι v, or v∉F and ∃v*∈F: v* ≤ι v, where T and F are respectively the TRUE-
characteristic and the FALSE-characteristic complete sublattices of a fuzzy truth-
value lattice of discourse. According to condition 3 in Definition 2.6.1, for any 
ε∈[0, 1], if v+ε ∉ T and ∃v*∈T: v* ≤ι v+ε then v∉T. Also, if ∃v*∈T: v* ≤ι v+ε 
then ∃v*∈T: v* ≤ι v, because v+ε ≤ι v. Similarly, if v+ε∉F and ∃v*∈F: v* ≤ι v+ε, 
then v∉F and ∃v*∈F: v* ≤ι v. Thus, if (t, v+ε) is abnormal, then so is (t, v) or, 
equivalently, if (t, v) is not abnormal, then neither is (t, v+ε).  
Therefore, in Definition 3.7.3, if Tj’s are not abnormal, then neither is 
lub{T1+ξ1, T2+ξ2, ..., Tn+ξn}, for any values in [0, 1] of ξj’s. Then, the solvability 
of normal order-sorted AFLP constraints can be stated as in Proposition 3.7.2 be-
low. The constraint satisfaction algorithm for them is literally the same as the  
one in the proof of Proposition 3.5.2 except that, at the beginning of step 4, if  
Ak and φk are conjunctive fuzzy types and Ak is not matchable to φk, then return 
unsatisfiable. 

70 
3   Annotated Fuzzy Logic Programming
 
Proposition 3.7.2. Any normal order-sorted AFLP constraint is solvable. 
 
The definitions of order-sorted AFLP goals and their answers are the same as 
those of AFLPs (Definitions 3.6.1 and 3.6.2). However, for the solvability of an 
order-sorted AFLP constraint produced in a resolution process, the definition of 
goal normality has one additional condition, which is condition 2 in the following 
definition. This condition is included to satisfy condition 3 in Definition 3.7.3. 
 
Definition 3.7.4 An order-sorted AFLP goal Q || C is said to be normal iff:  
1.  C is a normal order-sorted AFLP constraint, and   
2.  For a conjunctive fuzzy type variable X, there is at most one occurrence of 
X in Q or in an inequality X ≤ι φ in C. 
 
The definitions of AFLP resolvents and refutations (Definitions 3.6.3 and 3.6.4) 
are literally applicable to order-sorted AFLPs, and thus the soundness of this or-
der-sorted AFLP resolution proof procedure still holds, as stated in the following 
theorem. 
 
Theorem 3.7.2. (Order-Sorted AFLP Resolution Soundness) Let P be an order-
sorted AFLP and G be an order-sorted AFLP goal. If G <C1, θ1> G1 <C2, θ2> ... 
Gn−1 <Cn, θn> Gn is a refutation of G and P, and ϕ is a solution for CG, then <θ1θ2 
... θn, ϕ> is a correct answer for G wrt P. 
 
As in the case of AFLPs, the completeness of the order-sorted AFLP proof proce-
dure requires the solvability of the constraint part of the last goal in a refutation, 
which is guaranteed by the normality of the constraint (Proposition 3.7.2). While 
for AFLPs, by Proposition 3.6.1, the constraint of the last goal in a refutation is 
normal if the original goal is normal, for order-sorted AFLPs an additional condi-
tion is required. This is because, according to Definition 3.6.3, a unification of Ok: 
σk in a goal G and the head Obj: φ of a reductant produces the constraint σk ≤ι φ & 
CG. For the normality of this constraint, regarding condition 2 in Definition 3.7.3 
of order-sorted AFLP constraints, φ must not be evaluated to an abnormal con-
junctive fuzzy type.  
As in Definition 3.5.2 of AFLP reductants, φ has the form lub{H1+ξ1, H2+ξ2, ..., 
Hm+ξm}. Meanwhile, as noted after Definition 3.7.3, if Hj’s are not abnormal con-
junctive fuzzy types, then neither is lub{H1+ξ1, H2+ξ2, ..., Hm+ξm}, for any values 
in [0, 1] of ξj’s. Thus, given an order-sorted AFLP P, a sufficient condition for 
there being no reductant of P whose head Obj: φ has φ evaluated to an abnormal 
conjunctive fuzzy type is that there is no clause of P whose head Obj: H has H as 
an abnormal conjunctive fuzzy type. We call such an order-sorted AFLP a normal 
one, for which a proposition similar to Proposition 3.6.1 of AFLPs holds, as stated 
below. 
 
Proposition 3.7.3. Let G and C be respectively a goal and a reductant of a normal 
order-sorted AFLP. If G is a normal order-sorted AFLP goal, then any (unre-
stricted) resolvent of G and C is also a normal order-sorted AFLP goal. 

3.8   Generalized and Specialized AFLPs 
71
 
The completeness of the order-sorted AFLP resolution proof procedure is then ob-
tained, as stated in the following theorem.  
 
Theorem 3.7.3. (Order-Sorted AFLP Resolution Completeness) Let P be a normal 
order-sorted AFLP and G be a normal order-sorted AFLP goal. If there exists a 
correct answer for G wrt P, then there exists a refutation of G and P. 
 
As discussed above, to obtain the completeness of order-sorted AFLP resolution, 
additional conditions are imposed on constraints, goals and programs. However, 
these conditions are sufficient for generality, but not necessary. In particular, due 
to Propositions 2.6.4 and 2.6.5, with conjunctive fuzzy types constructed from the 
same basic type, or being all non-negative or non-positive, condition 3 in Defini-
tion 3.7.3 and condition 2 in Definition 3.7.4 can be obviated. Meanwhile, condi-
tion 2 in Definition 3.7.3 can also be obviated when, in practice, mismatching  
degrees of conjunctive fuzzy types to abnormal ones with diagrams defined by 
straight line segments can be computed. 
3.8   Generalized and Specialized AFLPs  
Above, fuzzy rules are assumed with certainty degree 1 only. In this section, we 
present a generalization of (order-sorted) annotated fuzzy logic programs with 
clauses weighted by certainty degrees in [0, 1], called generalized AFLPs. Then, 
we present specialized AFLPs where the only fuzzy set values involved in pro-
grams are special fuzzy truth-values that represent truth, possibility or necessity 
degrees. They are less expressive than generalized AFLPs but have simpler com-
putation and require less data storage. 
First, we present the generalization and modification of the syntax, declarative 
semantics and procedural semantics of annotated fuzzy logic programs for gener-
alized AFLPs. Then we present specialized AFLPs and compare them with partial 
truth-valued logic programs and possibilistic logic programs.  
Generalization 
In practice, an exact certainty degree of a proposition is rarely obtained, so its 
lower bounds or upper bounds are often considered instead. From the information 
ordering point of view, lower bounds of a certainty degree are more interesting 
than its upper bounds. This is because, the higher a lower bound of the certainty 
degree of a proposition is, the more certain it is that the proposition holds. 
Whereas an upper bound of the certainty degree of a proposition is not informative 
at all with respect to whether the proposition holds or not, because even a value of 
0 just means it is not certain that the proposition holds, but does not mean it is cer-
tain that the proposition does not hold. Therefore, here we consider only lower 
bounds of certainty degrees. That is, a weighted clause “y is H ← x is B [α]” 
means c(y is H ← x is B) ≥ α, where α∈[0, 1].  
The syntax of generalized AFLP clauses is now adapted from Definition 3.2.4 
as follows. 

72 
3   Annotated Fuzzy Logic Programming
 
Definition 3.8.1. A generalized AFLP clause is defined to be of the form: 
Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn [α] 
where α ∈ [0, 1] and H and Bi’s are fuzzy sets or conjunctive fuzzy types. A gen-
eralized AFLP is a finite set of generalized AFLP clauses. 
 
For the model-theoretic semantics, generalized AFLP interpretations are defined 
like g-interpretations of AFLPs (Definition 3.3.2), which also form a complete lat-
tice (Definition 3.3.4). The satisfaction relation of a program and an interpretation 
generalizes that of AFLPs (Definition 3.3.6) using the general Equation 2.5.6 as in 
the following definition. 
 
Definition 3.8.2. Let P be a generalized AFLP and I be a generalized AFLP inter-
pretation. Then: 
1.  I |= P iff I |= C, for every clause C in P, 
2.  I |= C iff I |= gC , for every ground instance gC of clause C, 
3.  I |= Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn [α] (a ground instance) 
iff H+⊕(1− α, maxi=1,n{Δ(Bi|Bi*)})∈I(Obj) where Bi*∈I(Obji) for every i 
from 1 to n. 
I is a model of P iff I |= P. 
 
Given a generalized AFLP P, the definition of the interpretation mapping TP gen-
eralizes that of an AFLP (Definition 3.4.2) as follows. 
 
Definition 3.8.3. Let I be a generalized AFLP interpretation and Obj∈BL. Then 
TP(I)(Obj) is defined to be the least ideal containing {H+⊕(1− α, ε) | Obj: H 
← Obj1: B1 & Obj2: B2 & ... & Objn: Bn [α] is a ground instance of a clause in P, 
and ε = maxi=1,n{Δ(Bi | Bi*)} where Bi*∈I(Obji) for every i from 1 to n}. 
 
As such, TP of a generalized AFLP P also has the properties like that of an AFLP 
(Propositions 3.4.1 to 3.4.4), whence a fixpoint semantics theorem similar to 
Theorems 3.4.1 and 3.7.1 for (order-sorted) AFLPs is obtained for generalized 
AFLPs as stated below, where MP is the minimal model of P. 
 
Theorem 3.8.1. Let P be a generalized AFLP. Then TP↑ω = lfp(TP) = MP. 
 
For additional expressions of the form A+⊕(δ, ε) as in Definitions 3.8.2 and 3.8.3, 
order-sorted AFLP annotation terms (Definition 3.7.2) are extended with ones of 
this form, where δ∈[0, 1] and ε is a variable whose value is in [0, 1], as non-simple 
generalized AFLP annotation terms. The definition of generalized AFLP reductants 
is then adapted from that of AFLPs (Definition 3.5.2) as presented below.  
 
Definition 3.8.4. Let P be a generalized AFLP and C1, C2, ..., Cm be different 
clauses in P. Suppose that no pair of Ci and Cj (i ≠ j) shares common variables, 
and each Ck (1 ≤ k ≤ m) is of the form: 
Objk: Hk ← Objk1: Bk1 & Objk2: Bk2 & ... & Objkn: Bkn [αk] 

3.8   Generalized and Specialized AFLPs 
73
 
Suppose further that Obj1, Obj2, ..., Objm are unifiable via a most general unifier θ. 
Then the clause: 
[Obj1: lub{H1+⊕(1− α1, ξ1), H2+⊕(1− α2, ξ2), ..., Hm+⊕(1− αm, ξm)}  
← Obj11: B11+ξ1 & Obj12: B12+ξ1 & ... & Obj1n: B1n+ξ1 &  
Obj21: B21+ξ2 & Obj22: B22+ξ2 & ... & Obj2n: B2n+ξ2 & ... & 
Objm1: Bm1+ξm & Objm2: Bm2+ξm & ... & Objmn: Bmn+ξm 
]θ 
is called a reductant of P. 
 
The following proposition states a logical relationship between a generalized 
AFLP and its reductants, which is similar to Propositions 3.5.1 and 3.7.1 for (or-
der-sorted) AFLPs. 
 
Proposition 3.8.1. Let P be a generalized AFLP, Obj: H ← Obj1: B1 & Obj2: B2 & 
... & Objn: Bn be an annotation variable-free instance of a reductant of P, and θ be 
a substitution for object variables in this reductant. If (Obj1: B1 & Obj2: B2 & ... & 
Objn: Bn)θ is a logical consequence of P, then so is (Obj: H)θ. 
 
Generalized AFLP constraints and solvability are defined like those of AFLPs 
(Definitions 3.5.3 and 3.5.4), with extended annotation terms as mentioned above 
(before Definition 3.8.4). Normal generalized AFLP constraints are defined like 
those of order-sorted AFLPs except that each Tj+ξj in condition 2 of Definition 
3.7.3 is replaced by Tj+⊕(δj, εj), where δj∈[0, 1] and εj is a constant or variable 
whose value is in [0, 1]. We note that added annotation terms are defined to be 
non-simple ones and thus do not occur on the left-hand side of inequalities in a 
normal constraint. As such, the constraint satisfaction algorithm for normal order-
sorted AFLP constraints is literally applicable to those of generalized AFLPs, 
whence the following proposition similar to Propositions 3.5.2 and 3.7.2 holds. 
 
Proposition 3.8.2. Any normal generalized AFLP constraint is solvable. 
 
The definitions of generalized AFLP goals and their answers are the same as those 
of AFLPs (Definitions 3.6.1 and 3.6.2) and the definition of goal normality is the 
same as that of order-sorted AFLPs (Definition 3.7.4). The definitions of AFLP 
resolvents and refutations (Definitions 3.6.3 and 3.6.4) are literally applicable to 
generalized AFLPs, and thus the soundness of this generalized AFLP resolution 
proof procedure still holds, as stated in the following theorem. 
 
Theorem 3.8.2. (Generalized AFLP Resolution Soundness) Let P be a generalized 
AFLP and G be a generalized AFLP goal. If G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, 
θn> Gn is a refutation of G and P, and ϕ is a solution for CG, then <θ1θ2 ... θn, ϕ> 
is a correct answer for G wrt P. 
 
Like an order-sorted AFLP, a generalized AFLP is said to be normal iff, for every 
clause head Obj: H in it, H is not an abnormal conjunctive fuzzy type. Then, the 
following proposition similar to Proposition 3.7.3 for order-sorted AFLPs holds. 

74 
3   Annotated Fuzzy Logic Programming
 
Proposition 3.8.3. Let G and C be respectively a goal and a reductant of a normal 
generalized AFLP. If G is a normal generalized AFLP goal, then any (unre-
stricted) resolvent of G and C is also a normal generalized AFLP goal. 
 
The completeness of the generalized AFLP resolution proof procedure is then ob-
tained, as stated in the following theorem.  
 
Theorem 3.8.3. (Generalized AFLP Resolution Completeness) Let P be a normal 
generalized AFLP and G be a normal generalized AFLP goal. If there exists a cor-
rect answer for G wrt P, then there exists a refutation of G and P. 
 
Specialization 
 
We now present a specialization of (generalized) AFLPs by considering only the 
special fuzzy truth-values that represent truth, possibility or necessity degrees to 
be fuzzy set values involved in programs. Dually to necessity degrees, upper 
bounds of the possibility degree of a proposition are more interesting than its 
lower bounds. Indeed, the lower an upper bound of the possibility degree of a 
proposition p is, the more certain it is that p does not hold, due to Π(p) = 1 − 
N(¬p) as introduced in Section 2.5. We recall from Section 2.6 that: 
1.  For truth degrees: 
(a)  A truth degree lower bound α∈(0, 1] can be represented by a fuzzy 
truth-value τα defined by ∀u∈[0, 1]: μτα(u) = 1 if u ≥ α or μτα(u) = 0 
otherwise. We denote this fuzzy truth-value by αT and define it as a 
TRUE-characteristic one. 
(b)  A truth degree upper bound α∈[0, 1) can be represented by a fuzzy 
truth-value τα defined by ∀u∈[0, 1]: μτα(u) = 1 if u ≤ α or μτα(u) = 0 
otherwise. We denote this fuzzy truth-value by αF and define it as a 
FALSE-characteristic one. 
2.  For uncertainty degrees: 
(a)  A necessity degree lower bound α∈(0, 1] can be represented by a 
fuzzy truth-value τα defined by: μτα(1) = 1 and μτα(u) = 1 − α for all 0 
≤ u < 1. We denote this fuzzy truth-value by αN and define it as a 
TRUE-characteristic one. 
(b)  A possibility degree upper bound α∈[0, 1) can be represented by a 
fuzzy truth-value τα defined by: μτα(1) = α and μτα(u) = 1 for all 0 ≤ u 
< 1. We denote this fuzzy truth-value by αΠ and define it as a FALSE-
characteristic one. 
We do not consider 0T, 1F, 0N and 1Π above because all of them are equal to the 
trivial fuzzy truth-value absolutely unknown. Regarding the fuzzy subtype rela-
tion, with the basic type hierarchy in Example 2.6.1 for example, one has: 
(TALL_MAN, 0.7T) ≤ι (HANDSOME_MAN, 0.9T).  
 
 

3.8   Generalized and Specialized AFLPs 
75
 
That is, if “It is true at least to degree 0.9 that John is a HANDSOME_MAN” then 
“It is true at least to degree 0.7 that John is a TALL_MAN”. Similarly, the following 
relations hold: 
(HANDSOME_MAN, 0.9F) ≤ι (TALL_MAN, 0.7F)  
(TALL_MAN, 0.7N) ≤ι (HANDSOME_MAN, 0.9N) 
(HANDSOME_MAN, 0.9Π) ≤ι (TALL_MAN, 0.7Π). 
The declarative and the procedural semantics of AFLPs are still applicable to 
specialized AFLPs with truth and uncertainty degrees, but simpler computation is 
gained and less data storage is required by the latter as compared to the former 
computing with arbitrary fuzzy set values. One operation of primary concern is 
computing the mismatching degree of a truth or an uncertainty degree to another. 
In particular, by Definition 2.2.5, one has: 
1.  For truth degrees: 
∀α, β∈(0, 1]: Δ(αT | βT) = 0 if β ≥ α or Δ(αT | βT) = 1 otherwise. 
∀α, β∈[0, 1): Δ(αF | βF) = 0 if β ≤ α or Δ(αF | βF) = 1 otherwise. 
∀α∈(0, 1] ∀β∈[0, 1): Δ(αT | βF) = Δ(βF | αT) = 1. 
2.  For uncertainty degrees: 
∀α, β∈(0, 1]: Δ(αN | βN) = max{α − β, 0}. 
∀α, β∈[0, 1): Δ(αΠ | βΠ) = max{β − α, 0}. 
∀α∈(0, 1] ∀β∈[0, 1): Δ(αN | βΠ) = α and Δ(βΠ | αN) = 1 − β. 
Here are some examples for computing the mismatching degree of a truth or an 
uncertainty degree to another: 
Δ(0.7T | 0.9T) = 0 
Δ(0.9T | 0.7T) = 1 
Δ(1N | 0.7N) = max{1 − 0.7, 0} = 0.3 
Δ(0Π | 0.4Π) = max{0.4 − 0, 0} = 0.4. 
Another operation of primary concern is computing v+δ where δ∈[0, 1] and v 
is a truth or an uncertainty degree, considered as a special fuzzy truth-value, for 
mismatching degree modification of the consequent of a fuzzy rule when it is 
fired. By Equation 2.5.4 in Section 2.5, one has: 
1.  For truth degrees: 
∀α∈(0, 1] ∀δ∈[0, 1]: αT+δ is defined by  
μα+δ(u) = 1 if u ≥ α or μα+δ(u) = δ if 0 ≤ u < α. 
∀α∈[0, 1) ∀δ∈[0, 1]: αF+δ is defined by 
 
μα+δ(u) = 1 if u ≤ α or μα+δ(u) = δ if α < u ≤ 1. 
2.  For uncertainty degrees: 
∀α∈(0, 1] ∀δ∈[0, 1]: αN+δ = (α − δ)N if α − δ > 0 or 
 αN+δ = absolutely unknown otherwise. 
∀α∈[0, 1) ∀δ∈[0, 1]: αΠ+δ = (α + δ)Π if α + δ < 1 or  
 αΠ+δ = absolutely unknown otherwise. 
Following is an example of a specialized AFLP to predict the certainty for a 
tennis player to be ranked No. 1 after a coming Grand Slam competition: 

76 
3   Annotated Fuzzy Logic Programming
 
rank(x, 1): 1N ← final(x): 1N ∧ current_rank(x, 1): 1N                                                            (1) 
rank(x, 1): 1N ← win(x): 1N ∧ current_rank(x, 2): 1N ∧  
final(y): 0Π ∧ current_rank(y, 1): 1N 
(2) 
win(x): 0.9N ← current_champion(x): 1N ∧ current_rank(x, 1): 1N 
                        (3) 
win(x): 0.7N ← current_champion(x): 1N ∧ current_rank(x, 2): 1N                   (4) 
final(x): 0.4Π ← injured(x): 1N ∧ current_rank(x, 1): 1N                                    (5) 
final(x): 0.2Π ← injured(x): 1N ∧ current_rank(x, 2): 1N                                    (6) 
current_rank(Lindsay, 1): 1N                                                                              (7) 
current_rank(Martina, 2): 1N                                                                              (8) 
current_champion(Martina): 1N                                                                          (9) 
injured(Lindsay): 1N                                                                                         (10) 
Here, the certainty degrees of all the clauses are assumed to be 1. Rule (2) says “A 
tennis player will be ranked No. 1 if he/she wins the competition and is currently 
ranked No. 2, and the tennis player who is currently ranked No. 1 does not enter 
the final match”. Rule (4) says “If a tennis player is the current champion and cur-
rently ranked No. 2, then it is certain at least to degree 0.7 that he/she will win the 
competition”. Rule (5) says “If a tennis player is injured and currently ranked No. 
1, then it is possible at most to degree 0.4 that he/she will enter the final match”.  
Then, from (10), (7) and (5), one infers: 
final(Lindsay): 0.4Π  
 
(11) 
From (9), (8) and (4), one infers:  
 
win(Martina): 0.7N  
 
(12) 
The mismatching degree of the body of (1) to (11) and (7) is: 
max{Δ(1N | 0.4Π), Δ(1N | 1N)} = max{1, 0} = 1 
whence, for 1N+1 = absolutely unknown, one obtains: 
rank(Lindsay, 1): absolutely unknown  
 
(13) 
The mismatching degree of the body of (2) to (12), (8), (11) and (7) is: 
max{Δ(1N | 0.7N), Δ(1N | 1N), Δ(0Π | 0.4Π), Δ(1N | 1N)}  
= max{0.3, 0.4} = 0.4 
whence, due to 1N+0.4 = 0.6N, one obtains: 
rank(Martina, 1): 0.6N  
 
(14) 
That is, from the given knowledge base, one has “It is not certain at all whether 
Lindsay will be ranked No. 1 after the competition” and “It is certain at least to 
degree 0.6 that Martina will be ranked No. 1 after the competition”. 
We now have a comparison between specialized AFLPs and partial truth-
valued logic programs, e.g. the ones by Kikuchi and Mukaidono (1994), and pos-
sibilistic logic programs, e.g. the ones by Dubois, Lang and Prade (1994). For this 
purpose, we call a specialized AFLP with only truth degrees a partial truth-valued 
AFLP, and a specialized AFLP with only possibility degrees and/or necessity de-
grees a possibilistic AFLP.  
In Kikuchi and Mukaidono (1994), for instance, the Gödel implication was ap-
plied, whence T(p) ≥ min(α, β) was inferred from T(p ← q) ≥ α and T(q) ≥ β, with 
T being the denotation function in partial truth-valued logic. Whereas, given par-
tial truth-valued AFLP clauses p: 1T ← q: 1T [α] and q: βT, one infers p: 

3.8   Generalized and Specialized AFLPs 
77
 
1T+⊕(1− α, Δ(1T | βT)). In particular, when α = 1 and β < 1, one obtains p: abso-
lutely unknown, in contrast to T(p) ≥ β in the case of partial truth-valued logic 
programs. We have the following remarks.  
Firstly, the meanings of α in the two cases are totally different. In the partial 
truth-valued logic program case, α is a truth degree lower bound of p ← q. Mean-
while, in the partial truth-valued AFLP case, it is a certainty degree lower bound 
of the rule. Secondly, the declarative semantics of a rule in the partial truth-valued 
logic program case is based on truth degree propagation. Meanwhile, in the partial 
truth-valued AFLP case, it is based on certainty degree propagation.  
Thirdly, however, the conclusion p: absolutely unknown, for instance, does not 
contradict the conclusion T(p) ≥ β. Indeed, p: absolutely unknown means “It is not 
certain at all whether p is absolutely true”, while T(p) ≥ β with β < 1 does not im-
ply any certainty degree for T(p) = 1 either. As such, partial truth-valued logic 
programs derive truth degrees of propositions, while partial truth-valued AFLPs 
derive certainty degrees about truth degrees of propositions. 
Meanwhile, in Dubois, Lang and Prade (1994), given possibilistic logic pro-
gram clauses  p ← q [α]  and  q [β], one inferred  p [min(α, β)], i.e., N(p) ≥ min(α, 
β), where α > 0 and β > 0. Correspondingly, given possibilistic AFLP clauses p: 
1N ← q: 1N [α] and q: βN, one infers p: 1N+⊕(1 − α, Δ(1N | βN)) = p: (⊗(α, β))N, 
where ⊕ and ⊗ are dual with respect to the standard fuzzy complement. With ⊗ 
being the min function, the two conclusions coincide. We have the following  
remarks. 
Firstly, although both instances of α in the two cases mean certainty degrees, 
their declarative semantics are slightly different. In the possibilistic logic program 
case, α is a certainty degree lower bound of p ← q interpreted as p ∨ ¬q, where p 
and q are classical logic propositions. Whereas, in the possibilistic AFLP case, 
stemming from generalized AFLPs where p and q are generally fuzzy proposi-
tions, α is a weight on the certainty degree of p given that of q, as defined above.  
Secondly, an interpretation of a possibilistic logic program is a possibility dis-
tribution on the set of classical logic possible worlds, which are {p, q}, {¬p, q}, 
{p, ¬q} and {¬p, ¬q} in this particular case of the example possibilistic logic 
program, with only two propositions p and q. Whereas an interpretation of the ex-
ample possibilistic AFLP maps p and q to certainty degree lower bounds or, more 
generally, fuzzy truth-values, as for generalized AFLPs. As noted in Section 3.3, 
the model-theoretic semantics approach of possibilistic logic programs cannot deal 
with local inconsistency. 
As shown above, partial truth-valued AFLPs and possibilistic AFLPs are com-
plementary to, but neither subsuming nor subsumed by, partial truth-valued logic 
programs or possibilistic logic programs, respectively. A notable point is that gen-
eralized AFLPs provide a common framework to treat truth, possibility and neces-
sity degrees together, by considering all of them as special fuzzy truth-values. 
Moreover, the framework of special fuzzy types with truth or uncertainty degrees 
here can be applied to extend partial truth-valued logic programs and possibilistic 
logic programs to order-sorted ones. 
 

78 
3   Annotated Fuzzy Logic Programming
 
3.9   Summary 
It is showed that annotated logic programming is an essential lattice-based reason-
ing framework, but the classical annotated logic programming formalism is not 
adequate for fuzzy set logic programming. It is extended to the AFLP formalism 
by considering both atoms and terms of predicate logic as objects, which all can 
be annotated, and using multiple annotation lattices, which are lattices of fuzzy 
sets on different domains. 
Inherited from annotated logic programming, the AFLP framework has two 
main advantages, as compared with other fuzzy set logic programming ap-
proaches. First, it can deal with local inconsistency, that is, a program containing 
local inconsistencies does not arbitrarily entail everything. Second, in annotated 
fuzzy logic programs, fuzzy set values as annotations are separated from symbolic 
objects, whence symbolic manipulation such as pattern matching and unification 
can be performed as in classical logic programming, while lattice-based deduction 
based on a particular computation model can be studied independently. In this vol-
ume, a meta-level fuzzy rule model is employed, but the framework is general for 
systems with other models to be studied and developed. 
Both the restricted and the general model-theoretic and fixpoint semantics of 
annotated fuzzy logic programs are studied, where the general semantics is based 
on the notion of ideals in lattice theory. It is showed that the existence of a finite 
sound and complete mechanical proof procedure with respect to the general se-
mantics is ensured for annotated fuzzy logic programs, but not with respect to the 
restricted semantics. Thus, for generality, the general semantics for fuzzy set logic 
programming is assumed. 
For AFLP procedural semantics, AFLP reductants and constraints are defined 
and their significance explained. AFLP reductants are to combine fuzzy set values 
as lattice-based data for the completeness of an SLD-resolution style proof proce-
dure, while AFLP constraints are to be produced in resolvents of goals and reduc-
tants and to support fuzzy set variables in queries. A sound and complete  
SLD-resolution style proof procedure is then developed for annotated fuzzy logic 
programs, which selects reductants rather than clauses in resolution steps and  
involves solving constraints on fuzzy set values. 
Furthermore, on one hand, since fuzzy types formulated in Section 2.6 have the 
same lattice and mismatching measure properties as fuzzy set values, the AFLP 
formalism is extended straightforwardly to the order-sorted AFLP one, where 
fuzzy types are used as annotations for object type predicates. On the other hand, 
(order-sorted) AFLPs are generalized to include program clauses whose certainty 
degrees are less than 1, and specialized for program clauses with only special and 
simple fuzzy truth-values representing truth, possibility and necessity degrees. 
In fact, annotated logic programming provides an abstract framework rather 
than a concrete language for studying lattice-based reasoning. That is, even though 
in a particular language lattice-based data may not be syntactically so clearly sepa-
rated, they still can be abstractly considered as annotations. In particular, concept 
and relation types in fuzzy conceptual graphs can be regarded as lattice-based an-
notations, whence FCG programming can be developed from the annotated logic 
programming point of view as presented in the next chapter. 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 79–103. 
springerlink.com                © Springer-Verlag Berlin Heidelberg 2010 
Chapter 4 
Fuzzy Conceptual Graph Programming 
4.1   Overview 
As logic programming made logic applicable to computer science as a program-
ming language, CG programming was studied and developed for CG-based auto-
mated reasoning systems. Fargues et al. (1986) was among the first works on the 
particular subset of conceptual graphs that corresponded to definite clauses in 
predicate logic (Lloyd 1987) and on implementation of a Prolog-like resolution 
method for it. The authors considered CG clauses of the form G ← G1, G2, ..., Gn, 
where G1, G2, ..., Gn and G were connected CGs, and defined a CG program 
(CGP) as a finite set of CG clauses.  
Recognizing that CG projection was not adequate for matching a goal with the 
head of a rule in a CGP resolution proof procedure, the authors introduced a 
matching operation based on the notion of compatible concepts. Like unification 
in predicate logic, that operation could match an individual concept in a goal and a 
generic concept in the head of a rule. It was then used to define an SLD-resolution 
style proof procedure for CG programs. Rao and Foo (1987) refined and extended 
that work with the introduction of modalities to CG programs. 
However, those two works lacked a formal account of the soundness and com-
pleteness of the proposed CGP resolution proof procedures. In fact, the procedures 
are not sound and not complete, as shown by examples in Ghosh and Wuwongse 
(1995). They are not complete because of requiring a whole connected CG in a 
goal to be resolved at once. They are not sound because of not distinguishing two 
different kinds of generic markers in the head of a CGP rule, one of which corre-
sponds to universally quantified variables and the other to existentially quantified 
variables in predicate logic. These two kinds of generic markers were respectively 
called VAR generic markers and NON-VAR generic markers in Cao, Creasy and 
Wuwongse (1997b).  
Ghosh and Wuwongse (1993) first studied a formal CG-based declarative se-
mantics, including the model-theoretic semantics and the fixpoint semantics, of 
definite CGPs. Then, in Ghosh and Wuwongse (1994), the authors developed two 
proof procedures called CG-resolution and CG-derivation and proved that they 
were sound with respect to the defined declarative semantics of CG programs. In 
Ghosh and Wuwongse (1995), recognizing that those two proof procedures were 
not complete due to using solely CG projection, the authors defined CG unification, 
taking into account the difference between VAR and NON-VAR generic markers, and 
used it to refine the CG-derivation proof procedure to make it complete. The CG-
resolution proof procedure was then also refined to be complete in Ghosh (1996). 

80 
4   Fuzzy Conceptual Graph Programming
 
In Ghosh and Wuwongse (1995) a goal was split into primitive subgraphs, as 
just single concepts or single relations with their neighbour concepts, to obtain the 
completeness of the proof procedure. As such, it gave up the possibility of resolv-
ing as large as possible subgraphs of a goal. Ghosh (1996), although lifted off that 
restriction, was still not aware of the case when the remainder of a goal, after a 
subgraph was erased from it, could never be resolved further, due to containing 
NON-VAR generic markers produced from a unification of the goal and the head of 
a rule. For efficiency, such a case should be pruned off early. 
It is the significance of the notion of pieces introduced by Salvat and Mugnier 
(1996) that the head of a rule is partitioned into subgraphs called pieces and, at a 
resolution step, only the subgraphs of a goal that are unified with those pieces can be 
erased without making the new goal unresolvable in further resolution steps. The au-
thors developed the piece resolution proof procedure and proved its soundness and 
completeness with respect to the predicate logic semantics of conceptual graphs.  
Piece resolution shows an advantage of conceptual graphs over predicates, that 
is, a conceptual graph groups together many primitive predicates into a single 
structure to be processed as a whole. In fact, that idea can be applied to other for-
malisms as well. For example, Coulondre and Salvat (1998) applied the results of 
CG programming with piece resolution to predicate logic programs that allow the 
head of a rule to be a conjunction of predicates. The authors showed by experi-
ments that, in comparison with the classical SLD-resolution, piece resolution ap-
plied to predicate logic programs considerably reduced the number of backtracks 
in a proof. 
For dealing with vague and imprecise knowledge, Cao and Creasy (1998) ex-
tended CG programs to FCG programs. The main syntactic difference between 
FCG programs and CG programs is only that the body or the head of a clause in a 
CGP is a simple CG, whereas in an FCGP it is a simple FCG. The framework of 
(order-sorted) AFLPs sheds light on development of FCG programming, in par-
ticular, introducing the notion of ideals for its declarative semantics and reductants 
for the procedural semantics. 
In the following, Section 4.2 discusses some pragmatic issues of definite CGPs 
and definite predicate logic programs, then defines FCGP clauses and definite 
FCGPs. Section 4.3 introduces the notion of ideal FCGs and defines their funda-
mental operations, then uses them to define FCGP model-theoretic semantics. Sec-
tion 4.4 studies the fixpoint semantics as a bridge between the declarative and the 
procedural semantics of FCG programs. In Section 4.5, general issues of (F)CG 
unification and (F)CGP resolution are discussed. Section 4.6 defines FCG unifica-
tion and FCGP reductants to be used in FCGP resolution. Then Section 4.7 devel-
ops an SLD-resolution style proof procedure for FCG programs and proves its 
soundness and completeness with respect to FCGP declarative semantics. Finally, 
Section 4.8 concludes the chapter. 
4.2   FCGP Syntax  
Like a definite predicate logic program (Lloyd 1987), a definite CGP (Ghosh 
1996; Salvat 1997) consists of Horn-like clauses, each of which has a body  
 

4.2   FCGP Syntax 
81
 
 
Fig. 4.2.1 An example CGP 
(i.e., antecedent) and a head (i.e., consequent). As usual, a clause is called a fact if 
its body is empty, or a rule otherwise. Since this volume is concerned only with 
definite CGPs, which correspond to definite predicate logic programs, we simply 
say a CGP or a predicate logic program, unless emphasizing that they are definite 
ones. Figure 4.2.1 shows an example CGP that consists of one rule saying “If a 
tennis player wins a Grand Slam, then he/she will be sponsored by some sports 
company”, and one fact saying “Martina wins a Grand Slam in 1998”. 
Ghosh (1996), formalizing a CG-based language of logic and developing defi-
nite CGPs, noted that the language was not intended to be an alternative but a sup-
plement to classical logic for problem solving. Meanwhile, Salvat and Mugnier 
(1996) remarked that variables that were exclusive in the head of a clause were 
universally quantified in a predicate logic program, but existentially quantified in 
a CG program. Also, a predicate logic program clause could be seen as a special 
CGP clause if it did not contain terms and all variables in its head occurred in  
its body.  
To explain and add to those comments, we translate the CGP above to predicate 
logic formulas by Φ, noting that a CGP rule is equivalent to a double negation CG 
(Sowa 1984). The translation of the rule is: 
¬(∃x ∃y (tennis_player(x) ∧ grand_slam(y) ∧ win(x, y) ∧ 
 ¬(∃z (tennis_player(x) ∧ sport_company(z) ∧ sponsor(x, z))) 
) 
 ) 
= ∀x∀y (¬( tennis_player(x) ∧ grand_slam(y) ∧ win(x, y)) ∨ 
∃z (tennis_player(x) ∧ sport_company(z) ∧ sponsor(x, z)) 
) 
= ∀x∀y (tennis_player(x) ∧ grand_slam(y) ∧ win(x, y)  
 → ∃z (sport_company(z) ∧ sponsor(x, z)) 
) 
The translation of the fact is: 
∃x (tennis_player(Martina) ∧ grand_slam(x) ∧ year(1998) ∧  
win(Martina, x) ∧ date(x, 1998) 
) 
As such, depending on occurrence positions, a generic marker may be mapped 
to a universally or existentially quantified variable in predicate logic. Specifically, 

82 
4   Fuzzy Conceptual Graph Programming
 
all generic markers in the body of a rule correspond to universally quantified vari-
ables, whereas those in a fact correspond to existentially quantified variables. For 
generic markers in the head of a rule, those whose concepts are coreferent with 
ones in the body of the rule correspond to universally quantified variables, and the 
others correspond to existentially quantified variables. Thus, CGP clauses cannot 
represent predicate logic program clauses having variables that are exclusive, and 
thus universally quantified, in their heads. 
On the other hand, all variables in a predicate logic program clause are univer-
sally quantified and a fact or the head of a rule can be only a single atom. Thus, 
existence has to be represented through Skolem functions or constants, and a con-
junctive fact or a rule with a conjunctive consequent has to be represented by a 
number of separated clauses. For example, a predicate logic program that  
represents the natural language expressions above can be obtained by Skolemizing 
the Φ translation of the CGP in Figure 4.2.1 and splitting the rule and the fact as 
follows: 
tennis_player(x) ∧ grand_slam(y) ∧ win(x, y) → sport_company(f(x, y)) 
tennis_player(x) ∧ grand_slam(y) ∧ win(x, y) → sponsor(x, f(x, y)) 
tennis_player(Martina) 
grand_slam(a) 
year(1998) 
win(Martina, a) 
date(a, 1998) 
where f() is a Skolem function and a is a Skolem constant.  
Apparently, from the knowledge representation point of view, f(x, y) and a are 
not so intuitive to represent “some sports company” and “a Grand Slam” as 
[SPORT_COMPANY: *] and [GRAND_SLAM: *] are, where a generic marker * means 
an unspecified entity and is naturally read as “some” or “a”. Also, in this example, 
there is a one to one correspondence between a natural language sentence and a 
CGP clause, but not a predicate logic program clause. Thus, CGPs represent exis-
tence, conjunctive facts, and rules with conjunctive consequents more naturally 
and more concisely than predicate logic programs.  
Meanwhile, terms in predicate logic can be represented by conceptual graphs 
with functional relations, but CG representation is less compact. Willems (1995) 
defined a feature term graph as a CG with all relations being binary and func-
tional. Here, we generally define the translation of a term f(t1, t2, ..., tn) to a CG re-
cursively to be a generic dependent concept of a functional relation whose type 
corresponds to f and whose determining concepts are the translations of the terms 
t1, t2, ... and tn, where the translation of a variable is a generic concept and the 
translation of a constant is an individual concept. For example, the term sub-
tract(1998, birth_year(x)) can be represented by the CG in Figure 4.2.2, where 
SUBTRACT and BIRTH_YEAR are functional relation types. 
Regarding FCG programs, the main syntactic difference between FCG pro-
grams and CG programs is only that the body or the head of a clause in a CGP is a 
simple CG, whereas in an FCGP it is a simple FCG. Figure 4.2.3 shows an exam-
ple FCGP consisting of one rule saying “If a building has original architecture,  
 

4.2   FCGP Syntax 
83
 
 
Fig. 4.2.2 CG representation of terms 
 
Fig. 4.2.3 An example FCGP 
then it is true that it is a building worth seeing and it is more or less true that its 
designer is proud of it” and one fact saying “Sydney Opera House is a building 
that has quite original architecture”. 
As already noted, crisp attribute-values, basic concept types and basic relation 
types can be considered as special fuzzy ones. Thus, except for concept referents, 
all attribute-values, concept types and relation types in an FCGP can be treated as 
fuzzy values. Then, as with an AFLP rule, when an FCGP rule is applied, mis-
matching degrees are computed for all matched vertex pairs of the body of the rule 
and an FCGP fact, and the combined mismatching degree is propagated as an un-
certainty degree to every vertex of the head of the rule for a conclusion.  
However, in practice, not all vertices in an FCGP rule are intended to expose 
fuzziness. For instance, the rule in the FCGP above appears to be applied to build-
ings only, but not other kinds of constructions. Thus, it may not be fired with a 
fact saying “There is a construction that has very original architecture, but it is not 
very true that it is a building”, represented by the following FCG: 
[{CONSTRUCTION, (BUILDING, not very true)}: *]→(ATTR) 
↓ 
[ARCHITECTURE: *@very original] 
because the construction may not be a building as required by the antecedent of 
the rule. Similarly, when the rule is fired with a fact, the mismatching degree of its 
antecedent to the fact actually implies an uncertainty degree only on whether a 
building is worth seeing and whether its designer is proud for its architectural 
originality, but not on whether its designer is a person or whether some person is 
its designer.  
In other words, by intention, the vertices [BUILDING: *], (ATTR), [PERSON: *], 
and (DESIGNER) in the rule above are assumed not to expose fuzziness. We call 
such vertices in an FCGP rule firm vertices. Their intended meaning is that firm 

84 
4   Fuzzy Conceptual Graph Programming
 
vertices in the body of a rule require full matching for the rule to be fired, while 
those in the head of the rule are not subject to change by a mismatching degree 
when the rule is fired. Definite FCGP clauses and definite FCGPs are now defined 
as follows. 
 
Definition 4.2.1. A definite FCGP clause is defined to be of the form if u then v, 
where u and v are finite simple FCGs, u can be empty, and there can be corefer-
ence links between generic concepts in u and those in v. Some concepts and/or re-
lations in u or v can be defined to be firm vertices. 
 
For the examples in this volume, we have a convention that, in an FCG rule, con-
cepts and relations without linguistic labels of fuzzy sets are firm vertices. Also, in 
the textual format, we use variables to denote coreference links, whereby generic 
concepts with the same variable written after the generic markers in them are as-
sumed to be coreferent. 
 
Definition 4.2.2. A definite FCGP is a finite set of definite FCGP clauses. 
 
For example, the FCGP in Figure 4.2.4 consists of one rule saying  “If a tomato is 
red, then it is ripe” and one fact saying “Tomato #78 is fairly red”, where 
[TOMATO: #78], [TOMATO: *], (ATTR1) and (ATTR2) are the only firm vertices in the 
rule, and ATTR1 and ATTR2 are functional relation types.  
 
Fig. 4.2.4 A definite FCGP 
From now on, for simplicity, we merely say an FCGP clause or an FCGP, 
unless emphasizing that they are definite ones. 
4.3   FCGP Model-Theoretic Semantics 
Corresponding to the CG-based and the predicate logic semantics of conceptual 
graphs are two approaches to the declarative semantics of CG programs. In one 
approach, Ghosh and Wuwongse (1993) developed a CG-based model theory for 
CG programs with the notions of interpretations, models, fixpoint semantics in 
parallel to those for predicate logic programs (Lloyd 1987), where interpretations 
were defined by CGs themselves. In another approach, Salvat and Mugnier (1996) 
defined the declarative semantics of CG programs through the operator Φ, just like 
the predicate logic semantics of conceptual graphs.  

4.3   FCGP Model-Theoretic Semantics 
85
 
The interest of the first approach is that it provides a model theory for CG pro-
grams using conceptual graphs themselves, including the fixpoint semantics, 
which is a bridge between the declarative and the procedural semantics of CG 
programs for proving the soundness and the completeness of a CGP proof proce-
dure. Whereas, the interest of the second approach is that it is based on, and thus 
can exploit results of, well-known and well-established predicate logic, particu-
larly for proofs of the soundness and the completeness of a CGP proof procedure. 
In this volume, we follow the first approach to study and provide an FCGP model 
theory that is based on conceptual graphs themselves. 
As discussed in Chapter 3, for annotated logic programs, the general declarative 
semantics, for which ideals instead of elements of lattices (or just upper semi-
lattices) are used for program interpretations, has to be applied to guarantee finite 
proofs of logical consequences of programs. Therefore, the notion of ideal FCGs 
is introduced for the general declarative semantics of FCG programs. Roughly, an 
ideal FCG is defined like a simple FCG except that each attribute-value is an ideal 
of a fuzzy attribute-value lattice and each type in a concept or a relation is an ideal 
of a conjunctive fuzzy concept or relation type upper semi-lattice. That is, each at-
tribute-value is a possibly infinite set of fuzzy attribute-values and each type in a 
concept or a relation is a possibly infinite set of conjunctive fuzzy concept or rela-
tion types. For a relation, only an ideal constructed from conjunctive fuzzy rela-
tion types of the same arity can be its type.  
In the following definition, for an upper semi-lattice L, we denote the set of all 
ideals of L by ideal(L). Also, for an ideal T of a conjunctive fuzzy relation type 
upper semi-lattice, we define arity(T) to be the arity of all conjunctive fuzzy rela-
tion types in T and, for every i from 1 to arity(T), arg_type(T, i) to be the least 
ideal containing {arg_type(t, i) | t∈T}, which is an ideal of a conjunctive basic 
concept type upper semi-lattice. 
 
Definition 4.3.1. An ideal FCG wrt an FCG signature (TC, TR, M, V, A) is a bi-
partite graph defined by a triple (VC, VR, E) where: 
1.  VC is a set of concept vertices, each of which is labelled by either: 
(i)  An ideal in ideal((TC×V)+) and a concept referent in M, for a fuzzy en-
tity concept, or 
(ii)  An ideal in ideal((TC×V)+), a concept referent in M, and an ideal in 
ideal(A), for a fuzzy attribute concept. 
The type and the referent of each concept c∈VC are denoted by type(c) and 
referent(c), respectively. If c is a fuzzy attribute concept, its attribute-value 
is denoted by aval(c). 
2.  VR is a set of relation vertices, each of which is labelled by an ideal in 
ideal((TR×V)+). The type of each relation r∈VR is denoted by type(r). 
3.  E is a set of edges, each of which connects a relation vertex to a concept 
vertex. The number of edges incident to a relation r is arity(type(r)) and the 
edges are labelled from 1 to arity(type(r)). For every i from 1 to ar-
ity(type(r)), the concept connected to r by the edge labelled i is denoted by 
neighbour(r, i). 
 

86 
4   Fuzzy Conceptual Graph Programming
 
The ideal FCG is said to be well-typed wrt the signature iff, for every r∈VR, 
arg_type(type(r), i) ≤ι type(neighbour(r, i)) for every i∈{1, 2, ..., arity(type(r))}, 
where each conjunctive basic concept type T∈TC
+
 in arg_type(type(r), i) is con-
sidered as a special conjunctive fuzzy concept type {(t, absolutely true) | t∈T}. 
 
For the notion of principal instances of an ideal FCG defined below, given an 
ideal S of an upper semi-lattice L and a∈S, we call {x∈L | x ≤ι a} a principal ideal 
from S. 
 
Definition 4.3.2. A principal instance of an ideal FCG G is an FCG derived from 
G by replacing each attribute-value or type in a concept or a relation in G, which 
is an ideal, by a principal ideal from the ideal. For each concept c in a principal in-
stance of G, we write origin(c) to denote the corresponding concept in G from 
which c is derived. 
 
Since each principal ideal is determined by the greatest element in it, one can view 
an FCG as an ideal FCG whose attribute-values or types in concepts or relations 
are principal ideals, and vice versa. Ideal FCG projection is defined like CG pro-
jection. The main difference is only that CG projection is based on the concept 
and the relation subtype orders, whereas ideal FCG projection is based on the or-
ders of ideals of conjunctive fuzzy concept and conjunctive fuzzy relation type 
upper semi-lattices. Given ideal FCGs G and H, we also write G ≤ι H to denote 
that G has a projection to H. However, unlike FCG projection, ideal FCG projec-
tion defines a full inclusion relation without a mismatching degree. 
 
Definition 4.3.3. Let G and H be two ideal FCGs. An ideal FCG projection from 
G to H is a mapping π: G → H such that: 
1.  ∀c∈VC: type(c) ≤ι type(πc) and referent(c) ≤ι referent(πc). 
2.  ∀r∈VR: type(r) ≤ι type(πr) and  
∀i∈{1, 2, ..., arity(type(r))}: neighbour(πr, i) = π neighbour(r, i). 
 
Like CG projection, ideal FCG projection defines an information preorder and an 
equivalence relation on ideal FCGs. Also, as normal CGs are used to define CG 
models (Sowa 1984; Ghosh 1996), normal ideal FCGs are used to define interpre-
tations of FCG programs here. Ideal FCG normal form is defined like FCG normal 
form. The difference is only that FCG normalization is based on upper semi-
lattices of conjunctive fuzzy concept types and conjunctive fuzzy relation types, 
whereas ideal FCG normalization is based on complete lattices of ideals of those 
upper semi-lattices. 
 
Definition 4.3.4. An ideal FCG G is said to be in ideal FCG normal form iff it sat-
isfies the following conditions: 
1.  No two or more concepts in G have the same individual marker, and 
2.  No two or more relations of the same arity in G have their respective 
neighbour concepts coinciding, and 
 

4.3   FCGP Model-Theoretic Semantics 
87
 
3.  There are no relations of types T1 and T2 in G such that: 
(i)  {(t, absolutely true)} ≤ι T1 and {(t, absolutely true)} ≤ι T2 for some ba-
sic functional relation type t, where {(t, absolutely true)} is considered 
as a principal ideal defined by itself, and 
(ii)  The two relations have their respective determining concepts (wrt t) co-
inciding. 
Then, G is said to be a normal ideal FCG. 
 
The normalization procedure of ideal FCGs is literally the same as that of FCGs 
presented in Section 2.7. The difference is only that operations are performed on 
ideals of conjunctive fuzzy concept and conjunctive fuzzy relation type upper 
semi-lattices, instead of conjunctive fuzzy concept types and conjunctive fuzzy re-
lation types as in FCG normalization. For an ideal FCG G, we also denote its 
normal form, if existing, by norm(G). As in CG normalization and FCG normali-
zation, norm(G) may not exist due to individual marker conflict in joining de-
pendent concepts of functional relations.  
Since ideal FCG projection has the same principle as CG projection, it has a 
property similar to CG projection that, given an ideal FCG G, if norm(G) exists, 
then it is the least specific normal ideal FCG that G has a projection to, as stated in 
the following proposition. Thus, for a set S of ideal FCGs, if norm(S) exists, then 
it is the least normal upper bound (modulo ideal FCG equivalence) of S with re-
spect to the ideal FCG projection preorder. The following proposition is similar to 
Proposition 2.4.1 for the CG case. 
 
Proposition 4.3.1. Let G be an ideal FCG such that norm(G) exists. Then: 
1.  G ≤ι norm(G). 
2.  If G ≤ι G* and G* is normal, then norm(G) ≤ι G*. 
 
Ideal FCGs are now used to define interpretations of FCG programs. Like a CG de-
fining a CG model in Sowa (1984) or a CGP interpretation in Ghosh (1996), an ideal 
FCG defining an FCGP interpretation is required to be normal. With functional rela-
tions, the normal form also rules out the inconsistency due to individual marker con-
flict between dependent concepts in an interpretation. However, as proved in Section 
2.7, an infinite CG or ideal FCG may not have an irredundant form equivalent to it. 
Thus, unlike Ghosh (1996) that assumed irredundancy of a CGP interpretation, we 
do not have that assumption here for an FCGP interpretation. 
 
Definition 4.3.5. An interpretation of an FCGP is a possibly infinite normal ideal 
FCG. 
 
Example 4.3.1. Two possible interpretations of the FCGP in Figure 4.2.4 are: 
I1 = [TOMATO: #78]→(ATTR1)→[COLOUR: *@very red] 
 →(ATTR2)→[RIPENESS: *@not ripe] 
I2 = [TOMATO: #78]→(ATTR1)→[COLOUR: *@fairly red] 
 →(ATTR2)→[RIPENESS: *@fairly ripe] 
where I1 and I2, appearing as FCGs, are special ideal FCGs with principal ideals as 
fuzzy values. 

88 
4   Fuzzy Conceptual Graph Programming
 
The satisfaction relation between an FCGP and an interpretation is based on the 
same fuzzy rule model that is applied to (order-sorted) AFLPs presented in Chap-
ter 3. In the following, we write coref(c, c*) to denote that two concepts c and c* 
are coreferent. 
 
Definition 4.3.6. Let P be an FCGP and I be an FCGP interpretation. The satisfac-
tion relation is defined as follows: 
1.  I |= P iff I |= C, for every clause C in P, 
2.  I |= if u then v iff the existence of an FCG projection π from u to a principal 
instance g of I implies the existence of an ideal FCG projection π* from 
v+επ to I such that: 
(i) 
The mismatching degree of each mapping from a firm vertex in u to a 
vertex in g is 0, and  
(ii)  v+επ is derived from v by adding επ to fuzzy values in all concepts and 
relations that are not firm vertices in v, and 
(iii)  For each c∈VC, c*∈VC, if coref(c, c*) then π*c* = origin(πc). 
I is a model of P iff I |= P. 
 
Condition 2(iii) in the definition above means that, if a concept c in u is mapped to 
a concept in I, then a concept c* in v that is coreferent with c must also be mapped 
to that concept in I. The necessity of this condition is explained in the following 
example. Let C be the rule: 
if [T: *x]→(p) then [T: *x]→(r) 
and I be the interpretation: 
{[T: a]→(p), [T: b]→(r)}.  
Here, u = [T: *x]→(p), v = [T: *x]→(r), c is the concept [T: *x] in u, c* is the con-
cept [T: *x] in v. Obviously, C is not satisfied by I. There is a projection π from u 
to [T: a]→(p) and a projection π* from v to [T: b]→(r) in I, but π*c* = [T: b] does 
not coincide with origin(πc) = πc = [T: a]. Thus, without condition 2(iii) above, C 
would be satisfied by I by definition, while it is actually not so. 
 
Example 4.3.2. Let us assume the relations between red, fairly red, ripe, fairly 
ripe, very red, and not ripe as in Example 3.3.3. Then, in Example 4.3.1, I2 is a 
model of the program, but I1 is not. 
 
As usual, an FCGP Q is said to be a logical consequence of an FCGP P iff, for 
every interpretation I, if I |= P then I |= Q. 
4.4   FCGP Fixpoint Semantics 
As for predicate logic programs (Lloyd 1987), CG programs (Ghosh 1996) and 
(order-sorted) annotated fuzzy logic programs presented in Chapter 3, each FCGP 

4.4   FCGP Fixpoint Semantics 
89
 
P is associated with an interpretation mapping TP , which links the declarative and 
the procedural semantics of P. 
 
Definition 4.4.1. Let P be an FCGP and I be a set of all interpretations. The inter-
pretation mapping TP: I → I is defined by TP(I) = norm(SP(I)∪I) where SP(I) = 
{v+επ | if u then v is a clause in P and π is an FCG projection from u to a principal 
instance g of I such that: (1) the mismatching degree of each mapping from a firm 
vertex in u to a vertex in g is 0; (2) v+επ is derived from v by adding επ to fuzzy 
values in all concepts and relations that are not firm vertices in v; and (3) for each 
c∈VCu, c*∈VCv, if coref(c, c*) then coref(c*, origin(πc)) in SP(I)∪I}. 
 
For example, let P be the FCGP in Figure 4.2.4 and I be the following interpretation: 
[TOMATO: #78]→(ATTR1)→[COLOUR: *@very red] 
then SP(I) is: 
[TOMATO: #78]→(ATTR1)→[COLOUR: *@fairly red] 
 →(ATTR2)→[RIPENESS: *@ripe] 
whence TP(I) is: 
[TOMATO: #78]→(ATTR1)→[COLOUR: *@very red] 
 →(ATTR2)→[RIPENESS: *@ripe] 
provided that fairly red ≤ι red ≤ι very red. 
As in Ghosh (1996), by the definition above, I is included in TP(I). This is a dif-
ference from the definition of TP of a predicate logic program or an (order-sorted) 
AFLP. The reason is that, in AFLPs as well as predicate logic programs, existen-
tially quantified variables are represented by Skolem functions or constants, while 
in (F)CGPs they are represented by generic markers. Thus, I is included in TP(I) to 
keep track of coreference links between I and a CG v derived from I and a rule if u 
then v. As such, one always has I ≤ι TP(I). 
As mentioned in Section 4.3, with functional relations, the normal form of an 
ideal FCG may not exist due to individual marker conflict between dependent 
concepts. Here, we consider only FCGPs P such that norm(SP(I)∪I) in Definition 
4.4.1 exists. In particular, P is such an FCGP when all dependent concepts in it are 
generic concepts and there are no coreference links incident to them. The upward 
iterations of TP are then defined with TP↑0 being the empty ideal FCG. 
 
Definition 4.4.2. Let P be an FCGP. The upward iterations of TP are defined as 
follows: 
TP↑0  = [] (empty ideal FCG),  
TP↑α  = TP(TP↑(α − 1)), if α is a successor ordinal, 
TP↑α  = norm{TP↑β | β < α}, if α is a limit ordinal. 
 
Unlike the definition of TP↑α for a predicate logic program, a CGP or an AFLP P, 
the definition of TP↑α for an FCGP P above uses the function norm instead of lub, 
when α is a limit ordinal. The reason is that, due to the possible redundancy of 
ideal FCGs defining interpretations, ideal FCG projection is not a partial order on 
them and thus a set of FCGP interpretations may have two or more equivalent 

90 
4   Fuzzy Conceptual Graph Programming
 
least normal upper bounds. Nevertheless, by Proposition 4.3.1, norm{TP↑β | 
β < α} is one of the least normal upper bounds of {TP↑β | β < α}. Also, we note 
that, for a CGP or FCGP P, in TP↑ω = norm{TP↑n | n∈N}, there are coreference 
links between concept vertices in TP↑n and the corresponding ones in the occur-
rence of TP↑n in TP↑(n + 1). 
For example, let P be the program in Figure 4.2.4 and assume the relations be-
tween red, fairly red, ripe, and fairly ripe as in Example 3.3.3. Then one has: 
TP↑0  = [] 
TP↑1  = [TOMATO: #78]→(ATTR1)→[COLOUR: *@fairly red] 
TP↑2  = [TOMATO: #78]→(ATTR1)→[COLOUR: *@fairly red] 
        →(ATTR2)→[RIPENESS: *@ripe + Δ(red | fairly red)] 
 
= [TOMATO: #78]→(ATTR1)→[COLOUR: *@fairly red] 
        →(ATTR2)→[RIPENESS: *@fairly ripe] 
TP↑3  = TP↑2  
... 
TP↑ω  = norm{TP↑n | n ∈ N} = TP↑2. 
 
As for annotated fuzzy logic programs, it is expected that TP↑ω is the minimal 
model (modulo ideal FCG equivalence) of an FCGP P. To prove this, we first 
prove Propositions 4.4.1 and 4.4.2 stated below, which are similar to Propositions 
3.4.1 and 3.4.2 for annotated fuzzy logic programs.  
 
Proposition 4.4.1. For any FCGP P, TP is monotonic, that is, if I1 ≤ι I2 then TP(I1) 
≤ι TP(I2). 
 
Proposition 4.4.2. Let P be an FCGP and I be an interpretation. Then I is a model 
of P iff TP(I) ≤ι I by an ideal FCG projection πI that maps the occurrence of I in 
TP(I) to I itself. 
 
The two propositions above are also similar to those for CG programs in Ghosh 
(1996). However, in contrast to the corresponding proposition in Ghosh (1996), 
Proposition 4.4.2 has a condition on a projection πI from TP(I) to I that, for every 
vertex e in I, the occurrence of e in TP(I) has to be mapped to e itself in I. This is 
because, as explained in Section 2.7, we do not assume I to be irredundant as in 
Ghosh (1996), whence one may have TP(I) ≤ι I but I is not a model of P, as shown 
in the following example. 
Let P be a program consisting of only one rule: 
if [T1: *x]→(p) then [T2: *x] 
where T1 <ι T2, and I be the interpretation: 
{[T1: *y]→(p), [T2: *z]→(p)}  
which is redundant due to [T1: *y]→(p) having a projection to [T2: *z]→(p). Here, 
I is not a model of P, because the body of the rule has a projection to [T1: *y]→(p), 
but its head does not.  
 

4.5   General Issues of CG Unification and Resolution 
91
 
Meanwhile, SP(I) is: 
{[T2: *y]→(p), [T2: *z]→(p)} 
whence TP(I) is: 
{[T2: *y]→(p), [T2: *z]→(p)}. 
As such, there is a projection πI from TP(I) to I, i.e., TP(I) ≤ι I, but the vertex [T2: 
*y] in TP(I) is mapped to [T2: *z] but not to [T1: *y] in I. Thus, without the condi-
tion on πI, Proposition 4.4.2 would conclude I to be a model of P, while it is actu-
ally not so. 
Further, since I ≤ι TP(I) always holds, as noted after Definition 4.4.1, TP(I) ≤ι I 
means I and TP(I) are equivalent with respect to ideal FCG projection. Thus, a 
model of P is a fixpoint (modulo ideal FCG equivalence) of TP . However, due to 
the condition on πI in Proposition 4.4.2, the inverse does not hold, that is, a fix-
point of TP is not necessarily a model of P, as exemplified above. Moreover, due 
to possible redundancy of FCGP interpretations, ideal FCG projection is not a par-
tial order on them whence, in general, they do not form a lattice. Therefore, in ob-
taining the following theorem, we do not apply the proof technique based on the 
least fixpoint of TP and the completeness of an interpretation lattice as in Lloyd 
(1987), which is applied to annotated fuzzy logic programs in Section 3.4. 
 
Theorem 4.4.1. For any FCGP P, TP↑ω is the minimal model (modulo ideal FCG 
equivalence) of P. 
 
Like the significance of Theorems 3.4.1 and 3.7.1 for (order-sorted) annotated 
fuzzy logic programs, the significance of Theorem 4.4.1 is that it ensures a finite 
sound and complete mechanical proof procedure for FCG programs. Indeed, if g is 
a finite FCG and g ≤ι TP↑k for some k∈N, then g ≤ι TP↑ω ≤ι I for every model I of 
P. This means g is a logical consequence of P, hence the soundness. On the other 
hand, if g is a logical consequence of P, then g must be satisfied by TP↑ω as a 
model of P, i.e., g ≤ι TP↑ω = norm{TP↑n | n∈N}, whence g ≤ι TP↑k for some k∈N. 
This means g can be “reached” after a finite number of upward iterations of TP , 
hence the completeness. 
4.5   General Issues of CG Unification and Resolution 
Ghosh and Wuwongse (1995) showed that CG projection was not sufficient to  
obtain a complete CGP resolution proof procedure and thus introduced CG unifi-
cation. Basically, a unification of two (F)CGs includes the unification of the re-
spective referents of their matched concepts. In referent unification, it is necessary 
to distinguish two kinds of generic markers in the head of a clause, as mentioned 
in Section 4.2, which are those whose concepts are coreferent with ones in the 
body of the clause, and the others whose concepts are not.  
In fact, generic markers of different kinds are treated differently in backward 
chaining: a generic marker of the former can be unified with an individual marker, 
i.e., treated as a variable, but the latter cannot. This explains why only concepts 
with generic markers of the former were defined to be cut points in Salvat and 

92 
4   Fuzzy Conceptual Graph Programming
 
Mugnier (1996). We call those of the former VAR generic markers and those of the 
latter NON-VAR generic markers. 
For example, let us reconsider the CGP in Figure 4.2.1 and suppose the two fol-
lowing queries G and H are given to the program: 
G = [TENNIS_PLAYER: Martina]→(SPONSOR)→[SPORT_COMPANY: *] 
H = [TENNIS_PLAYER: Martina]→(SPONSOR) 
↓ 
[SPORT_COMPANY: Nike] 
Here, the generic markers in [SPORT_COMPANY: *] in G and [TENNIS_PLAYER: *] 
in the head of the rule in the CGP are VAR ones, whereas the generic marker in 
[SPORT_COMPANY: *] in the head of the rule is a NON-VAR one. Thus, G can be 
unified with the head of the rule but H cannot, because [SPORT_COMPANY: Nike] 
cannot be unified with [SPORT_COMPANY: *] in the head of the rule. Intuitively, H 
is not a logical consequence of the program, because no individual concept of type 
SPORT_COMPANY can be derived by the rule, no matter what fact is applied to it. 
With functional relations, there is one more case of VAR generic markers occur-
ring in the head of a rule. That is when there is a relation of type t1 in the head and 
a relation of type t2 in the body of a CGP rule such that t ≤ι t1 and t ≤ι t2 for some 
functional relation type t, and the respective determining concepts of the two rela-
tions are coreferent. Then, their respective dependent concepts actually refer to the 
same entities due to the uniqueness constraint of t and, thus, are implicitly corefer-
ent, as in joining CGs containing functional relations. As such, the generic mark-
ers in those dependent concepts are actually VAR ones. 
Further, CG unification and CGP resolution are closely related to the way a 
type lattice is interpreted, which can be lattice-theoretic or order-theoretic, as in-
troduced in Section 2.3, and to the way the type hierarchy and the axiomatic part 
of a knowledge base are coupled, which can be loose or close, as introduced in 
Section 3.7. Another issue is early type resolution, which is necessary not only for 
the efficiency, but also for the completeness of a CGP resolution proof procedure.  
We recall that, with a lattice-theoretic interpretation, the least specific common 
subtype of two types is interpreted by the intersection of their interpretations 
whereas, with an order-theoretic interpretation, it is interpreted by only a subset of 
that intersection. In general, under a lattice-theoretic interpretation, the set of facts 
of a CGP has to be in CG normal form so that a backward chaining proof proce-
dure can be complete. In particular, it requires individual concepts with the same 
individual marker but different types to be joined into one concept. 
For example, let us take the type hierarchy of BUILDING, SIGHT and 
BUILDING_WORTH_SEEING in Section 2.3 with a lattice-theoretic interpretation and 
the example CGP and query in Figure 4.5.1. The query G can never be resolved by 
the program P, where G is actually a logical consequence of P. In Ghosh (1996), 
but not in Salvat (1997), the set of facts of a CGP was required to be in CG normal 
form for CGP resolution.  
From the annotated logic programming point of view, the normalization of 
CGP facts is to combine types as lattice-based data are combined in reductants for 
backward chaining, whereas such a combination is inherent in forward chaining  
 

4.5   General Issues of CG Unification and Resolution 
93
 
 
Fig. 4.5.1 A CGP to exemplify the effect of a type lattice interpretation in resolution 
(cf. Salvat and Mugnier 1996; Kerdiles and Salvat 1997). In contrast, if an order-
theoretic interpretation is applied then, in the example above, G is not a logical 
consequence of P and P cannot be normalized as: 
[BUILDING_WORTH_SEEING: Sydney_Opera_House]→(p) 
↓ 
 (r) 
With conjunctive types, since a conjunctive type upper semi-lattice actually has 
a lattice-theoretic interpretation, the set of facts of a CGP also has to be normal-
ized, in general, for the completeness of a CGP resolution proof procedure. For 
example, the query H = [{BUILDING, SIGHT}: *] can never be resolved by the CGP 
P above, by the usual CGP resolution. However, there are methods to obviate such 
a normalization. One method is to split every concept with a conjunctive type in a 
query into concepts with basic types. For example, H is split into [BUILDING: *x] 
and [SIGHT: *x].  
Another method is to modify the usual CGP resolution so that the number of 
elements in a conjunctive type of a concept is reduced along with a resolution 
process. 
For 
example, 
after 
being 
resolved 
with 
[BUILDING: 
Syd-
ney_Opera_House] in P, H becomes   [SIGHT: Sydney_Opera_House], which 
can be resolved further by [SIGHT: Sydney_Opera_House] in P.  
Nevertheless, for lattice-based data like fuzzy sets, the first alternative method 
is not feasible because, given a fuzzy set C, there is an infinite number of combi-
nations of A and B such that A∩B = C. Meanwhile, the second alternative method 
can be adapted for fuzzy sets as follows. Supposing that a goal “x is C” is first 
matched with and partially resolved by a fact “x is A”, the “remainder” to be satis-
fied of the goal is computed by a “subtraction” of A from C that is denoted by C\A 
and defined by: 
∀u∈U: μC\A(u) = 1 if μA(u) ≤ μC(u), or μC(u) otherwise 
where U is the domain of C and A.  
Then the new goal “x is C\A”, and thus the original goal “x is C”, is satisfied if 
there is another fact “x is B” such that B ⊆ C\A. Indeed, if B ⊆ C\A then A∩B ⊆ C, 
that is, “x is C” is a logical consequence of “x is A” and “x is B”. Otherwise, if B ⊆ 
C\A does not hold, then B is subtracted from C\A to produce the new goal “x is 
(C\A)\B”, and so on. This method as well as the first method, however, is not ap-
plicable when variables are involved, for any kind of lattice-based data, including 
conjunctive types and fuzzy sets. This is because, for instance, with C being a 
variable instead of a constant, neither looking for A and B such that A∩B = C nor 
subtracting A from C is relevant. Therefore, we do not apply the two alternative 
methods described above to FCG programs. 

94 
4   Fuzzy Conceptual Graph Programming
 
For the coupling between the taxonomic and the axiomatic parts of a knowl-
edge base, we recall that, with loose coupling, the entire taxonomic information is 
provided by the type hierarchy of the knowledge base, and no rules about relations 
between types are allowed in its axiomatic part, whereas there is no such restric-
tion with close coupling. In particular, close coupling allows rules that define 
changes of types of objects when the antecedents of the rules are satisfied, which 
realize the notion of dynamic types introduced in Section 3.7.  
Salvat (1997) implicitly assumed loose coupling, when requiring that every 
concept in the head of a rule had the same type as its coreferent concept, if any, in 
the body of the rule. Without this restriction, Ghosh (1996) and Reitsma (1998) 
assumed close coupling, as also shown by examples therein. The CGP in Figure 
4.5.2 is an example of close coupling, where the rule says “If a building has prop-
erty p, then it is a building worth seeing with property r”.  
 
Fig. 4.5.2 A CGP that realizes close coupling 
For CGPs containing close coupling rules, a CGP resolution proof procedure 
that uses the traditional CG unification as defined in Ghosh (1996) or Salvat 
(1997) is not complete. The main idea of the operation is that the unification of 
two concepts c1 and c2 produces a concept c with type(c) = lub{type(c1), type(c2)}. 
Then, the resolvent of a goal and a rule is a CG that comprises the body of the rule 
and the result of a unification of the goal and the head of the rule.  
For example, the result of a unification of G and the head of the rule in P in 
Figure 4.5.2 is [BUILDING_WORTH_SEEING: *]→(q), and the corresponding resol-
vent of G and the rule is: 
[BUILDING_WORTH_SEEING: *]→(p) 
↓ 
(q) 
This resolvent cannot be resolved further by the fact in P, although G is actually a 
logical consequence of P. In fact, the idea of the traditional CG unification de-
scribed above is reasonable only when every concept in the head of a rule and  
its coreferent concept, if any, in the body of the rule have the same type. Thus, 
with close coupling, for the completeness of a CGP resolution proof procedure, a 

4.5   General Issues of CG Unification and Resolution 
95
 
different CG unification has to be applied in conjunction with early type resolution 
presented below. 
Firstly, we note that, in a CGP goal, not only relations among referents of their 
neighbour concepts need to be satisfied, but also types of the referents. When a 
subgraph of a goal is resolved, it is erased from the goal. What needs to be consid-
ered is the common concepts in both the subgraph and the remainder of the goal. 
In fact, the types of the referents of these concepts are already resolved, only the 
relations involving these referents in the remainder of the goal are not. In Ghosh 
(1996) and Salvat (1997), the types of such connection concepts were kept un-
changed in goal remainders.  
By early type resolution we mean changing the types of connection concepts as 
early as possible. Specifically, it can be realized by “erasing” the type in a connec-
tion concept, indicating that only its referent needs to be matched in further resolu-
tion steps. Early type resolution is not only useful for the efficiency, but also  
necessary for the completeness of a CGP resolution proof procedure, when a goal 
is resolved by several resolution steps, raising the above-mentioned problem of 
types in connection concepts.  
The reason for the efficiency is that, in general, the less specific the type of a 
concept is, the easier the concept is matched and resolved. The reason for the 
completeness is exemplified below. For example, let H be the query: 
[BUILDING: *]→(p) 
↓ 
 (r) 
given to the program P in Figure 4.5.1. Clearly, H is a logical consequence of P. 
However, without early type resolution, the resolvent of H and the first fact is 
[BUILDING: Sydney_Opera_House]→(r) that can never be resolved. In contrast, 
with early type resolution, the resolvent of H and the first fact is [Syd-
ney_Opera_House]→(r) that can be resolved further by the second fact. 
For another example, in Figure 4.5.2, the subgraph [SIGHT: *]→(r) of G can be 
unified with the head of the rule in P and erased from G. Then, without early type 
resolution, the remainder of the goal is [SIGHT: *]→(q), and the corresponding re-
solvent of G and the rule consists of [BUILDING: *x]→(p) and [SIGHT: *x]→(q), 
where the latter cannot be resolved further. In contrast, with early type resolution, 
the remainder of the goal is [*]→(q), and the corresponding resolvent of G and the 
rule is: 
[BUILDING: *]→(p) 
↓ 
(q) 
which can be resolved by the fact in P. 
As analysed and shown above, with close coupling rules, the traditional CG 
unification cannot be used to obtain the completeness of a CGP resolution proof 
procedure. Therefore, in the light of annotated logic programming, we propose a 
CG unification that unifies only referents, but requires subsumption of types as 
well as other lattice-based data, for every pair of matched concepts. That is, when 
a CG G is unified with a CG H, referents of concepts in G and the corresponding 

96 
4   Fuzzy Conceptual Graph Programming
 
ones in H are unified, but types of concepts in H must be more specific than, or 
the same as, the corresponding ones in G.  
Meanwhile, for handling close coupling rules, Reitsma (1998) modified piece 
resolution (Salvat 1997) by computing the difference of the type of a concept in a 
goal from the type of a matched concept in the head of a rule. This is similar to the 
subtraction method we have presented in this section, when discussing the role of 
the normalization of CGP facts in CGP resolution. As we have noted there, such a 
method is not applicable when variables are involved. 
Moreover, from the annotated logic programming point of view, types in con-
ceptual graphs can be treated as lattice-based annotations, which can also be que-
ried about like other lattice-based annotations. For example, the following CG 
query asks “What is John and what is John’s relation with Mary?”: 
[X: John]→(Y)→[PERSON: Mary]  
where X is a concept type variable and Y is a relation type variable. 
Although exemplified by CG programs, the issues of CG unification and CGP 
resolution discussed above are common for both CG programming and FCG pro-
gramming. In fact, CGPs are special FCGPs with attribute-values, concept types 
and relation types as special fuzzy ones. In this volume, for FCG programs, we as-
sume close coupling of a type hierarchy and a program, and an order-theoretic in-
terpretation of basic type lattices or, more generally, just partially ordered sets of 
basic types. Early type resolution is also applied to FCG unification and FCGP 
resolution. Details as well as issues relating to fuzziness and fuzzy reasoning of 
FCG programs are presented in the following sections. 
4.6   FCG Unification and FCGP Reductants 
The framework of annotated fuzzy logic programs presented in Chapter 3 sheds 
light on the procedural semantics of fuzzy conceptual graph programs. Firstly, 
FCG unification as the main operation for FCGP resolution is defined. Basically, a 
unification of an FCG G with an FCG H is a unification of the respective referents 
of their matched concepts with the constraint that each fuzzy value in H must be 
more specific than, or the same as, the corresponding one in G. As mentioned in 
Section 4.5, in referent unification, it is necessary to distinguish VAR and NON-VAR 
generic markers, as summarized in the following definition. In the definition, we 
use the term query for original goal to distinguish it from intermediate goal cre-
ated during a resolution process. When such a distinction is not needed, we use the 
term goal to mean either an original or intermediate goal. 
 
Definition 4.6.1. A generic marker is defined to be either a VAR generic marker or 
a NON-VAR generic marker as follows: 
1.  It is a VAR generic marker iff it occurs in: 
(i)  
A concept in a query, or  
(ii)  A concept in the body of a rule, or  
(iii)  A concept in the head of a rule that is coreferent with a concept in the 
body of the rule, or 

4.6   FCG Unification and FCGP Reductants 
97
 
(iv)  A dependent concept of a relation of type T1 in the head of a rule such 
that: (a) there are a relation of type T2 in the body of the rule and a ba-
sic functional relation type t with {(t, absolutely true)} ≤ι T1 and {(t, 
absolutely true)} ≤ι T2; and (b) the respective determining concepts 
(wrt t) of the two relations are coreferent. 
2.  It is a NON-VAR generic marker iff it occurs in: 
(i)  
A concept in a fact, or 
(ii)  A concept in the head of a rule that is not coreferent with any concept 
in the body of the rule, except for case 1(iv) above. 
The attribute of a generic marker in an intermediate goal depends on whether it is 
bound to a VAR generic marker or a NON-VAR one through unification during a 
resolution process. 
Therefore, in backward chaining, there are three kinds of concept referents dis-
tinguished: individual markers, VAR generic markers, and NON-VAR generic mark-
ers. Only a VAR generic marker can be unified with any other concept referents. 
Two concept referents are said to be unifiable iff they are the same individual 
marker or one of them is a VAR generic marker as defined below. 
 
Definition 4.6.2. Let G and H be finite normal FCGs. An FCG unification from G 
to H is a mapping θ: G → H such that: 
1.  ∀c∈VC: referent(c) and referent(θc) are unifiable, and 
2.  ∀r∈VR: neighbour(θr, i) = θneighbour(r, i) for every i ∈ {1, 2, ..., arity(r) 
= arity(θr)}, and 
3.  No VAR generic marker is unified with different individual markers or sepa-
rated NON-VAR generic markers. 
The constraint produced by θ is denoted by Cθ and defined by the set {aval(c) 
≤ι aval(θc) | c∈VC and c is a fuzzy attribute concept}∪{type(c) ≤ι type(θc) | 
c∈VC}∪{type(r) ≤ι type(θr) | r∈VR}. 
 
We note that, in Definition 4.6.2, if aval(c) is of the form lub{σ1, σ2, ..., σm}, then 
the constraint lub{σ1, σ2, ..., σm} ≤ι aval(θc) is equivalent to the constraint σ1 ≤ι φ 
& σ2 ≤ι φ & ... & σm ≤ι φ where φ = aval(θc). This also applies to type(c) and 
type(r). 
In implementation, the satisfiability of some constraints in Cθ can be deter-
mined right in the matching process to decide whether G can be unified with H by 
θ or not. For instance, if there is a fuzzy attribute concept c in G such that aval(c) 
and aval(θc) are two fuzzy set constants and aval(c) ≤ι aval(θc) does not hold, 
then θ can be pruned off in the search for a unification of G and H. Also, the con-
ditions for the matchability of a (conjunctive) fuzzy type to another (Definitions 
2.6.6 and 2.6.8) can be exploited for early verification of the satisfiability of con-
straints on fuzzy types. 
Each FCG unification θ has two related operators, namely, referent specializa-
tion and coreference partition, respectively denoted by ρθ and ϖθ. If a VAR generic 
marker in a concept is unified with an individual marker, then ρθ binds the  
 

98 
4   Fuzzy Conceptual Graph Programming
 
 
 
Fig. 4.6.1 An FCGP reductant 
individual marker to that concept. If two generic markers in two concepts are uni-
fied, ϖθ groups the two concepts in the same coreference partition. When a VAR 
generic marker occurs in a coreference partition with a NON-VAR generic marker, 
it becomes a NON-VAR one.  
These two operators are then applied to combine the body of a rule and the re-
mainder of a goal after a unification with the head of the rule, producing a resolvent 
of the goal and the rule. For an FCG G, ρθϖθG is derived from G by joining corefer-
ent generic concepts as defined by ϖθ into one concept as in FCG normalization, 
then replacing generic markers in ϖθG by individual markers as defined by ρθ. 
We now present the notion of FCGP reductants that are similar to, and have the 
same significance, as AFLP reductants, regarding the completeness of a backward 
chaining proof procedure. As for (order-sorted) annotated fuzzy logic programs, 
we denote fuzzy value variables by X, Y, ..., and real number variables by ξ, ψ, ..., 
which all are called annotation variables to be distinguished from individual vari-
ables denoted by x, y, ... . An expression without annotation variables is called an-
notation variable-free. 
 
Definition 4.6.3. Let P be an FCGP and C1, C2, ..., Cm be different clauses in P, 
where each Ck (1 ≤ k ≤ m) is of the form if uk then vk. Suppose that some concepts 

4.7   FCGP Procedural Semantics 
99
 
whose referents are VAR generic markers or individual markers in v1, v2, ..., vm can 
be joined by a coreference partition ϖ. Then the clause: 
if ϖ[u1+ξ1   u2+ξ2   ...   um+ξm] then ϖ[v1+ξ1   v2+ξ2   ...   vm+ξm] 
is called a reductant of P, where each uk+ξk (respectively vk+ξk) is derived from uk 
(respectively vk) by adding ξk to fuzzy values in all concepts and relations that are 
not firm vertices in uk (respectively vk). 
In Definition 4.6.3, if the body of Ck is empty then ξk = 0. Also, if ϖ(uk+ξk) 
then ϖ(vk+ξk) is also an FCGP reductant, which is constructed from only Ck. In 
this case, ϖ corresponds to a coreference partitioning in Salvat and Mugnier 
(1996) on cut-point concept vertices of vk in a unification with a goal. 
For example, Figure 4.6.1 illustrates a reductant constructed from the two rules 
of the given FCGP P, where the head and the body of the reductant are normal-
ized. This FCGP is a CG version of the AFLP in Example 3.5.1. The first rule says 
“If the demand on a product is not high, then its price is not expensive”. The sec-
ond rule says “If the demand on a product is not low, then its price is not cheap”. 
The fact says “The demand on product #36 is normal and its quality is quite 
good”. 
The following proposition states a logical relationship between an FCGP and 
its reductants, which is similar to Propositions 3.5.1 and 3.7.1 for (order-sorted) 
AFLPs. 
 
Proposition 4.6.1. Let P be an FCGP, if u then v be an annotation variable-free 
instance of a reductant of P, and ρ and ϖ be respectively a referent specialization 
and a coreference partition on concepts with VAR generic markers in this reduc-
tant. If ρϖu is a logical consequence of P, then so is ρϖv. 
4.7   FCGP Procedural Semantics 
An FCGP goal is defined like an (order-sorted) AFLP goal with a query part and a 
constraint part. The difference is only that the query part of an FCGP goal is an 
FCG. In the following definition, FCGP annotation terms and constraints on them 
are the same as order-sorted AFLP ones defined in Section 3.7. 
 
Definition 4.7.1. An FCGP goal G is defined to be of the form QG || CG, where 
QG is the query part which is a finite simple FCG whose fuzzy values are simple 
FCGP annotation terms or of the form lub{σ1, σ2, ..., σm} where σi’s are simple 
FCGP annotation terms, and  CG  is the  constraint part which is an FCGP con-
straint. The goal is said to be normal  iff  (1) CG is a normal  FCGP constraint; and 
 (2)  for a  conjunctive fuzzy type variable X, there is at most one occurrence of X 
in QG or in an inequality X ≤ι φ in CG. 
 
Condition 2 is due to the same reason as explained for normal order-sorted AFLPs 
(Definition 3.7.4). Corresponding to object variables in an (order-sorted) AFLP 
goal are generic markers as individual variables in an FCGP goal. While an an-
swer to object variables is their substitution with constants, an answer to generic 

100 
4   Fuzzy Conceptual Graph Programming
 
markers includes their specialization to individual markers and/or a coreference 
partition on them, as defined below. 
 
Definition 4.7.2. Let P be an FCGP and G be an FCGP goal. An answer for G wrt 
P is a triple <ρ, ϖ, ϕ> where ρ and ϖ are respectively a referent specialization and 
a coreference partition on G, and ϕ is a substitution for annotation variables in G. 
The answer is said to be correct iff ϕ is a solution for CG and every annotation 
variable-free instance of ρϖϕQG is a logical consequence of P. 
 
For piece resolution, Salvat (1997) appeared to miss the case that a piece could be 
a single concept, to resolve the type for the referent of the concept only. Without 
taking this case into account, the proof procedure is not complete, as for example 
when the query [BUILDING: *]→(r) is given to the program P in Figure 4.5.1. 
Moreover, a resolvable subgraph as a single concept can only be realized with 
early type resolution, which was not applied therein.  
In the following definition of a resolvent of an FCGP goal and an FCGP reduc-
tant, a resolvable part of an FCGP goal could be a subgraph which is as large as 
possible, where a resolvable subgraph could be a single concept. For efficiency, 
the definition have conditions to prevent the occurrence in FCGP resolvents of 
NON-VAR generic markers, which would never be resolvable further.  
 
Definition 4.7.3.  Let  G  be  an  FCGP  goal  QG || CG   and  C  be  an  FCGP  re-
ductant if u then v  (G and C have no variable in common). Suppose that there ex-
ists an FCG unification θ from a normalized subgraph g of QG to norm(v) such 
that no VAR generic marker in a common concept between g and the remainder 
without g of QG is bound to a NON-VAR generic marker. The corresponding resol-
vent of G and C is a new FCGP goal denoted by Rθ(G, C) and defined to be 
ρθϖθ[δθQG  u] || Cθ & CG, where δθ deletes g from QG. 
 
In the Definition 4.7.3, the order of the inequalities in Cθ is not significant, but the 
order of Cθ and CG is, with respect to the normality of the constraint Cθ & CG. 
Also, when δθ deletes g from QG, early type resolution is applied, indicating that 
the types of the common concepts of g and the remainder of QG do not matter in 
matching in further resolution steps.  
The following proposition states that the condition on θ in Definition 4.7.3 is 
necessary and sufficient to prevent the occurrence of NON-VAR generic markers in 
FCGP resolvents. As such, a resolvable subgraph of an FCGP goal corresponds to 
a set of pieces defined in Salvat and Mugnier (1996). 
 
Proposition 4.7.1. The condition on θ in Definition 4.7.3 is necessary and suffi-
cient so that NON-VAR generic markers do not occur in FCGP resolvents. 
 
FCGP refutation is then defined like those of AFLPs and order-sorted AFLPs as 
follows. 
 

4.7   FCGP Procedural Semantics 
101
 
Definition 4.7.4. Let P be an FCGP and G be an FCGP goal. A refutation of G 
and P is a finite sequence G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn such that: 
1.  For each i from 1 to n, Gi = Rθ(Gi−1, Ci), where G0 = G, and Ci is a reductant 
of P, and 
2.  QG is empty, and  
3.  CG is solvable and has a solution.  
 
For example, let P be the program in Figure 4.6.1 and G be the following query 
asking “Which product has a moderate price and what is its quality like?” (cf. Ex-
ample 3.6.1): 
[PRODUCT: *x]→(ATTR2)→[PRICE: *@moderate] 
  →(ATTR3)→[QUALITY: *@X]. 
Assuming the relations between the fuzzy sets of the linguistic labels in P and G 
as in Examples 3.5.1 and 3.6.1, a refutation of G and P can be constructed as fol-
lows: 
g0 = [PRODUCT: *x]→(ATTR2)→[PRICE: *@moderate]   
(a subgraph of QG) 
C1= if [PRODUCT: *y]→(ATTR1) 
↓ 
[DEMAND: *@lub{not high+ξ, not low+ψ}]  
(u) 
then [PRODUCT: *y]→(ATTR2) 
↓ 
[PRICE: *@lub{not expensive+ξ, not cheap+ψ}]  
(v) 
θ1: g0 → v, ρθ = {}, ϖθ= {{[PRODUCT: *x], [PRODUCT: *y]}} 
G1 = [PRODUCT: *y]→(ATTR3)→[QUALITY: *@X] 
↓ 
 (ATTR1) 
↓ 
[DEMAND: *@lub{not high+ξ, not low+ψ}]  
|| (moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
g1 = [PRODUCT: *y]→(ATTR1) 
↓ 
[DEMAND: *@lub{not high+ξ, not low+ψ}]  
(a subgraph of QG) 
C2 = [PRODUCT: #36]→(ATTR1)→[DEMAND: *@normal] 
↓ 
 (ATTR3)→[QUALITY: *@quite good]  
θ2: g1 → C2, ρθ= {([PRODUCT: *y], #36)}, ϖθ= {} 
G2  = [#36]→(ATTR3)→[QUALITY: *@X] 
 || (lub{not high+ξ, not low+ψ} ≤ι normal) & 
 (moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
C3  
= C2  
θ3: QG → C3, ρθ = {}, ϖθ = {} 
 

102 
4   Fuzzy Conceptual Graph Programming
 
G3 = || (X ≤ι quite good) & (lub{not high+ξ, not low+ψ} ≤ι normal) & 
(moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
= || (X ≤ι quite good) & (not high+ξ ≤ι normal) & 
(not low+ψ ≤ι normal) &  
(moderate ≤ι lub{not expensive+ξ, not cheap+ψ}) 
As solved in Example 3.5.2, a solution for the constraint above is {X/quite good, 
ψ/0, ξ/0}, whence the corresponding answer for G wrt P is <{([PRODUCT: *x], 
#36)}, {}, {X/ quite good}>. We note that, if a clause rather than a reductant of P 
were used to resolve g0, there would not be a refutation of G and P because, gen-
erally, neither moderate ≤ι not expensive nor moderate ≤ι not cheap holds. Also, 
early type resolution is applied when g1 is deleted from QG. 
 
The following theorem states the soundness of the presented FCGP resolution 
proof procedure. 
 
Theorem 4.7.1. (FCGP Resolution Soundness) Let P be an FCGP and G be an 
FCGP goal. If G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn is a refutation of G and 
P, and ϕ is a solution for CG, then <ρθρθ ... ρθ, ϖθϖθ ... ϖθ, ϕ> is a correct answer 
for G wrt P. 
 
As in the case of order-sorted AFLPs, for generality, the completeness of the 
FCGP resolution proof procedure requires the normality the FCGPs involved. We 
also define a normal FCGP to be one that has no clause whose head is with an ab-
normal conjunctive fuzzy type. Then, the following proposition, which is similar 
to Propositions 3.6.1 and 3.7.3 for (order-sorted) AFLPs, is obtained. 
 
Proposition 4.7.2. Let G and C be respectively a goal and a reductant of a normal 
FCGP. If G is a normal FCGP goal, then any resolvent of G and C is also a normal 
FCGP goal. 
 
The completeness of the FCGP resolution proof procedure is then obtained as 
stated in the following theorem. 
 
Theorem 4.7.2. (FCGP Resolution Completeness) Let P be a normal FCGP and G 
be a normal FCGP goal. If there exists a correct answer for G wrt P, then there ex-
ists a refutation of G and P. 
 
As noted for order-sorted AFLPs at the end of Section 3.7, to obtain the complete-
ness of FCGP resolution, the additional conditions imposed on constraints, goals 
and programs are sufficient, for generality, but not necessary. They can be obvi-
ated, in particular, when conjunctive fuzzy types constructed from the same basic 
type or being all non-negative or non-positive are used, and mismatching degrees 
of conjunctive fuzzy types to abnormal ones with diagrams defined by straight line 
segments can be computed.  

4.8   Summary 
103
 
4.8   Summary 
Some pragmatic issues in the syntax of definite CGPs and definite predicate logic 
programs are discussed. CG programs represent existence, conjunctive facts, and 
rules with conjunctive consequents more naturally and more concisely than predi-
cate logic programs, but CGP clauses cannot represent predicate logic program 
clauses having variables that are exclusive, and thus universally quantified, in 
their heads. With functional relation types, CG programs can represent terms in 
predicate logic programs, although less compactly. 
The defined definite FCGPs are a generalization, with fuzzy types and fuzzy at-
tribute-values, of definite CGPs. General issues of (F)CG unification and (F)CGP 
resolution are analyzed. Firstly, with functional relation types, there is one more 
case of VAR generic markers occurring in the head of a rule. Secondly, with close 
coupling rules, the traditional CG unification is not adequate to obtain a complete 
CGP resolution proof procedure. Thirdly, early type resolution is not only useful 
for the efficiency, but also necessary for the completeness of a CGP resolution 
proof procedure, when a goal is resolved by several resolution steps. 
From the annotated logic programming point of view and the results of (order-
sorted) annotated fuzzy logic programs, the notion of ideal FCGs is introduced to 
define FCGP general model-theoretic semantics. Ideal FCGs are defined like sim-
ple FCGs except that each attribute-value is an ideal of a fuzzy attribute-value  
lattice and each type in a concept or a relation is an ideal of a conjunctive fuzzy 
concept or relation type upper semi-lattice. FCGP fixpoint semantics is then stud-
ied and a sound and complete SLD-style proof procedure is developed, with 
FCGP reductants and constraints, for FCG programs. 
The significance of the presented sound and complete FCGP system is as fol-
lows. Firstly, FCG programs are an extension of CG programs to deal with the 
pervasive vagueness and imprecision of the real world reflected in natural lan-
guage. Secondly, FCG programs as well as order-sorted AFLPs, which are respec-
tively in the CG and the predicate logic notations and thus complementary to each 
other, lay a foundation for order-sorted fuzzy set logic programming with the fun-
damentals of a theorem prover. Thirdly, in the framework of annotated logic pro-
gramming, the results are applicable to CG programs as special FCG programs 
and useful for extending conceptual graphs with lattice-based annotations to en-
hance their knowledge representation and reasoning power. 
So far, only the existential quantifier represented by the generic marker is con-
sidered in fuzzy conceptual graphs. Meanwhile, as one of its advantages, the CG 
formalism can accommodate well the universal quantifier and other generalized 
quantifiers. Moreover, quantifiers used in natural language are often vague that 
could be modeled by fuzzy sets. The next chapter presents modeling and reason-
ing with generally quantified statements in fuzzy conceptual graphs. 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 105–125. 
springerlink.com                  © Springer-Verlag Berlin Heidelberg 2010 
Chapter 5 
Modelling and Computing with Generally 
Quantified Statements 
5.1   Overview 
Fuzzy conceptual graphs and their logic programming foundations presented in 
the previous chapters deal with only fuzzy attributes.  The object of natural lan-
guage (specifically English) that this chapter is focused on is one of generalized 
quantifiers, which can be classified into absolute quantifiers and relative quantifi-
ers, where the quantities expressed by the latter are relative to the cardinality of a 
set. Examples of absolute quantifiers are only one, few, or several, while ones of 
relative quantifiers are about 9%, half, or most. In practice, there are quantifying 
words, e.g. few and many, that may be used with either meaning depending on the 
context. For instance, few in “Few people in this conference are from Asia” may 
mean a small number of people, while few in “Few people in the United Kingdom 
are from Asia” may mean a small percentage of population. 
Classical predicate logic with only the existential quantifier, equivalent to the 
absolute quantifier at least 1, and the universal quantifier, equivalent to the rela-
tive quantifier all or every, cannot deal with general quantification in natural lan-
guage. In fact, the logic of generalized quantifiers has been the quest and focus of 
significant research effort. 
In Peterson (1979), for instance, the semantics of generally quantified state-
ments were defined relatively to each other, e.g., “Few A’s are B’s” if and only if 
“Not many A’s are B’s”. As such, that work does not define the primary meaning 
of generalized quantifiers, which is the quantity that they express, and thus is not 
adequate for quantitative reasoning with them. A path-breaking work in formaliz-
ing generally quantified statements was Barwise and Cooper (1981), where a gen-
erally quantified set was interpreted as a set of sets of individuals. For example, 
“only N A’s” was interpreted as the set {X ⊆ U | |X∩A| = N}, where U is a universe 
of discourse and |S| denotes the cardinality of S, whence “Only N A’s are B’s” 
means B∈{X ⊆ U | |X∩A| = N}. Still, no definition was given for words express-
ing imprecise quantities, like several or most; only some semantic postulates stat-
ing their relations to each other were suggested as in Peterson (1979). 
Meanwhile, with the emergence of the fuzzy computing paradigm, fuzzy arith-
metic and probability has provided a basis for defining and computing with gener-
alized quantifiers, e.g. Zadeh (1978), Liu and Kerre (1998), and Lawry (2000), 
where they are treated in a unified way as fuzzy numbers, which are fuzzy sets on 

106 
5   Modelling and Computing with Generally Quantified Statements
 
the set of real numbers. A relative quantifier Q in a statement “Q A’s are B’s” can 
be interpreted as the proportion of objects of type A that belong to type B, i.e., Q = 
|A∩B|/|A|, which is a fuzzy number. A recent extensive research work on fuzzy 
quantifiers was carried out by Glöckner (2006).  
As discussed in Lawry (2000), a relative quantifier can be interpreted as the 
fuzzy conditional probability, which is a fuzzy number on [0, 1], of B(x) being 
true given A(x) being true for an object x picked at random uniformly. Although 
the interpretation of relative quantifiers as fuzzy probabilities was also mentioned 
in Zadeh (1983), the cardinality-based interpretation was used instead for deriving 
inference rules on relatively quantified statements. The probability-based interpre-
tation lends a new perspective on reasoning with generalized quantifiers as prob-
abilistic logic programming. For instance, on the basis of Jeffrey’s rule (Jeffrey 
1965), it allows one to have an answer as a fuzzy probability to a question like 
“How likely is it that John is not fat?” given that “Most people who are tall are not 
fat” and “John is fairly tall”. 
Regarding the aspect of logical structures close to those of generally quantified 
statements in natural language, conceptual graphs as an order-sorted logic provide 
a natural form to accommodate generalized quantifiers in its concept vertices. 
Meanwhile, with predicate logic, there is distortion in mapping a generally quanti-
fied statement to a logical formula. That is, for instance, the statement “All men 
are mortal” is mapped to ∀x (man(x) → mortal(x)), which introduces the implica-
tion connective that does not appear in the original natural language statement. 
Sowa (1991) showed that natural language expressions with generalized quanti-
fiers could be smoothly represented in conceptual graphs but not in predicate 
logic, yet did not adequately formalize them. A substantial effort that has been 
made in formalizing generally quantified CGs was Tjan, Gardiner, and Slagle 
(1990; 1992). Therein, the authors extended predicate logic with equality by add-
ing to it numerical quantifiers, then used it to define semantics and inference rules 
for conceptual graphs with numerical quantifiers. However, limited by classical 
arithmetic, vague quantifiers like few, many, or most were not considered in  
that work. 
In Wuwongse and Manzano (1993), while extending fuzzy conceptual graphs 
with fuzzy conceptual relations, the authors also introduced generalized quantifi-
ers into them. However, that work actually just adapted inference rules in Zadeh 
(1983) to the conceptual graph notation, without formally defining the semantics 
of fuzzy conceptual graphs with generalized quantifiers. In Cao (2003), the prob-
ability-based interpretation was used to expand generally quantified FCGs into 
probabilistic FCG rules, formally defining their semantics in terms of simple 
FCGs without generalized quantifiers. Then, on the basis of this semantics, infer-
ence rules performed directly on FCGs with either relative quantifiers or absolute 
quantifiers were derived.  
In the sequel, Section 5.2 and Section 5.3 respectively summarize the basic no-
tions of fuzzy arithmetic and fuzzy conditional probability. Section 5.4 presents 
the expansion rule that formally defines the semantics of universally quantified 
CGs in terms of CG rules, and then direct operations on those CGs with universal 
quantifiers. Section 5.5 defines the semantics of a generally quantified FCG as a 
fuzzy conditional probability on simple FCGs. Then Section 5.6 derives inference 

5.2   Fuzzy Arithmetic 
107
 
rules for relative quantifiers and absolute quantifiers, and Jeffrey’s rule on gener-
ally quantified FCGs. Finally, Section 5.7 concludes the chapter. 
5.2   Fuzzy Arithmetic 
As a special category of fuzzy sets, fuzzy numbers defined as fuzzy sets on the set 
R of real numbers are to represent imprecise numeric values. Formally speaking, a 
fuzzy number A is a normal and convex fuzzy set on R such that its support A
0+ is 
bounded and, for every α∈(0, 1], its α-cut Aα is a closed interval (Klir and Yuan 
1995). Figure 5.2.1 illustrates typical forms of fuzzy numbers, namely, triangular, 
trapezoidal, and bell-shaped ones. As such, the diagram of a fuzzy number typi-
cally has an increasing part on the left, a flat part with membership grades 1 in the 
middle, and a decreasing part on the right. 
 
Fig. 5.2.1 Typical forms of fuzzy numbers 
Using fuzzy numbers is one step further than intervals in representing imprecise 
numeric values, whereby a crisp interval [a, b] can be considered as a special 
fuzzy number I defined by μI(x) = 1 if x∈[a, b], or μI(x) = 0 otherwise. In particu-
lar, for a real number x, the notion “at least x” is represented by the interval [x, 
+∞), which includes all the real numbers y such that x ≤ y. Similarly, “at most x” is 
represented by (−∞, x]. In this volume, for representing and computing with im-
precision of such lower and upper bounds, we relax the boundedness condition on 
the support of a fuzzy number. 
For arithmetic operations on fuzzy numbers, there are two common methods. 
One is based on the extension principle (Zadeh 1975b) and the other on α-cuts and 
interval arithmetic (Moore 1966). We apply both of them for computing with 
fuzzy quantifiers and our propositions stated in this chapter hold for both cases. 
According to the extension principle, any function f: U1×U2× ... ×Un → V in-
duces a function g: X1×X2× ... ×Xn → Y where X1, X2, ..., Xn and Y are respectively 
sets of fuzzy sets on U1, U2, ..., Un and V and, for every (A1, A2, ..., An)∈X1×X2× ... 
×Xn, g(A1, A2, ..., An)∈Y is defined by: 
∀v∈V: μg(A1, A2, ..., An)(v) =  sup{min{μA1(u1), μA2(u2), ..., μAn(un)} | 
(u1, u2, ..., un)∈U1×U2× ... ×Un and  
v = f(u1, u2, ..., un)}. 

108 
5   Modelling and Computing with Generally Quantified Statements
 
From now on, for simplicity, we use the same notation for a real number function 
(e.g. f above) and its fuzzy extension (e.g. g above).  
For example, using this method, the product of two fuzzy numbers A and B is 
the fuzzy number denoted by A×B and defined as follows:  
∀z∈R: μA×B(z) = sup{min{μA(x), μB(y)} | (x, y)∈R×R and z = x × y}. 
Figure 5.2.2 illustrates a resulting membership diagram of this multiplication op-
eration on fuzzy numbers. 
 
Fig. 5.2.2 Fuzzy multiplication by the extension principle 
Similarly, the method can be applied to extend min and max, which are func-
tions from R×R to R, for fuzzy numbers as defined below: 
∀z∈R: μmin{A, B}(z) = sup{min{μA(x), μB(y)} | (x, y)∈R×R and  
 z = min{x, y}} 
∀z∈R: μmax{A, B}(z) = sup{min{μA(x), μB(y)} | (x, y)∈R×R and  
 z = max{x, y}}. 
A fuzzy version of the less-than-or-equal-to relation ≤ on real numbers can then 
be defined for fuzzy numbers such that A ≤ B iff min{A, B} = A or, equivalently, 
max{A, B} = B. However, we note that, while ≤ is a total order on real numbers, 
its fuzzy version is just a partial order on fuzzy numbers, because min{A, B} and 
max{A, B} may equal to neither A nor B. For illustration, Figure 5.2.3 shows two 
comparable fuzzy numbers and two incomparable ones with respect to ≤. 
Meanwhile, with a function f and its fuzzy counterpart function g described 
above, the interval arithmetic-based method assume that, for every tuple of fuzzy 
 
 
Fig. 5.2.3 Comparable and incomparable fuzzy numbers 

5.2   Fuzzy Arithmetic 
109
 
sets (A1, A2, ..., An), the α-cut of g(A1, A2, ..., An) is the image of f on the α-cuts of 
A1, A2, ..., and An as defined below: 
∀α∈[0, 1]: g(A1, A2, ..., An)α = f(A1
α, A2
α, ..., An
α)  
That is, since fuzzy number α-cuts are closed intervals, computation on fuzzy 
numbers reduces to that on real number intervals. The resulting fuzzy numbers are 
not necessarily the same as those obtained by applying the extension principle. 
In particular, the value of a two-argument function f on two real number inter-
vals [a, b] and [c, d] is the set define by: 
f([a, b], [c, d]) = {f(x, y) | x∈[a, b] and y∈[c, d]} 
For the addition, subtraction, multiplication, and division operations, such a result-
ing set is actually a closed interval as follows: 
[a, b] + [c, d] = [a + c, b + d] 
[a, b] − [c, d] = [a − d, b − c] 
[a, b] × [c, d] = [min(a×c, a×d, b×c, b×d),  max(a×c, a×d, b×c, b×d)] 
[a, b] / [c, d] = [min(a/c, a/d, b/c, b/d),  max(a/c, a/d, b/c, b/d)] 
where [c, d] is assumed not to contain 0 for the division. 
For example, given the fuzzy numbers about 2 and about 3 in Figure 5.2.2, one 
has: 
(about 2)α = [α + 1, 3 − α] 
(about 3)α = [α + 2, 4 − α] 
(about 2)α × (about 3)α = [α2 + 3α + 2, α2 − 7α + 12]. 
So, the diagram of the resulting fuzzy number is as depicted in Figure 5.2.4. 
 
Fig. 5.2.4 Fuzzy multiplication by the α-cut and interval arithmetic method 
The min and max functions are extended likewise for real number intervals, 
whereby: 
min([a, b], [c, d])  
= {min(x, y) | x∈[a, b] and y∈[c, d]} = [min(a, c), min(b, d)] 
max([a, b], [c, d])  
= {max(x, y) | x∈[a, b] and y∈[c, d]} = [max(a, c), max(b, d)] 
Therefore, for the extended relation ≤ on real number intervals, [a, b] ≤ [c, d] (i.e., 
min([a, b], [c, d]) = [a, b] or, equivalently, max([a, b], [c, d]) = [c, d]) iff a ≤ c and 
b ≤ d. As such, like that relation on fuzzy numbers, it is just a partial order. 
Reasoning with generalized quantifiers may also involve computation of the 
lower bound “at least” and the upper bound “at most” of an imprecise quantity, 

110 
5   Modelling and Computing with Generally Quantified Statements
 
which are mentioned at the beginning of this section. Since these two notions are 
actually functions of real numbers, they can be extended for fuzzy numbers on the 
basis of the extension principle or the α-cut and interval arithmetic one, as defined 
below. 
 
Definition 5.2.1. For a fuzzy number A, applying the extension principle, at least 
A and at most A are defined by: 
∀x∈R: μat least A(x) = sup{μA(y) | y∈R and y ≤ x} 
∀x∈R: μat most A(x) = sup{μA(y) | y∈R and x ≤ y}. 
 
Definition 5.2.2. For a fuzzy number A, applying the α-cut and interval arithmetic 
method, at least A and at most A are defined by: 
∀α∈[0, 1]: (at least A)α = at least Aα 
∀α∈[0, 1]: (at most A)α = at most Aα. 
 
In Definition 5.2.2, the notions of “at least” and “at most” of a real number inter-
val are given by: 
at least([a, b]) = {at least(x) | x∈[a, b]} = [a, +∞) 
at most([a, b]) = {at most(x) | x∈[a, b]} = (−∞, a]. 
Figure 5.2.5 illustrates the lower bound and upper bound of a fuzzy number. 
 
Fig. 5.2.5 Fuzzy number lower bound and upper bound 
The following proposition states that, for any fuzzy number A, at least A is the 
least specific fuzzy number that is greater than or equal to A, and at most A is the 
least specific fuzzy number that is less than or equal to A. 
 
Proposition 5.2.1. For any fuzzy number A: 
1. A ≤ at least A and B ⊆ at least A for every B such that A ≤ B, and 
2. at most A ≤  A and B ⊆ at most A for every B such that B ≤ A. 
 
We call a fuzzy number whose membership function is non-decreasing a non-
decreasing fuzzy number, and a fuzzy number whose membership function is non-
increasing a non-increasing fuzzy number. Then the following property holds. 
 
 

5.3   Fuzzy Conditional Probability 
111
 
Proposition 5.2.2. For any fuzzy number A: 
1. at least A = A if A is a non-decreasing fuzzy number, and  
2. at most A = A if A is a non-increasing fuzzy number. 
 
The following property also holds, where A/B denotes the fuzzy division of A by 
B, and B is said to be positive iff μB(x) = 0 for every x ≤ 0. 
 
Proposition 5.2.3. For any fuzzy number A and positive fuzzy number B: 
1. at least (A/B) = (at least A) / B, and  
2. at most (A/B) = (at most A) / B. 
5.3   Fuzzy Conditional Probability 
An alternative interpretation of fuzzy sets is by the voting model proposed by 
Gaines (1978). That is, given a fuzzy set A on a domain U, each voter has a subset 
of U as his/her own crisp definition of the concept that A represents. For example, 
a voter may have the interval [0, 35] representing human ages from 0 to 35 years 
as his/her definition of the concept young, while another voter may have [0, 25] 
instead.  
The membership function value μA(u) is then the proportion of voters whose 
crisp definitions include u. This model defines a mass assignment (i.e., probability 
distribution) on the power set of U, where the mass (i.e., probability value) as-
signed to a subset of U is the proportion of voters who have that subset as a crisp 
definition for the fuzzy concept A. As such, this mass assignment corresponds to a 
family of probability distributions on U.  
For the Dice example in Baldwin, Martin and Pilsworth (1995), given the dice 
values from the set {1, 2, 3, 4, 5, 6}, suppose that a score high is defined by the 
discrete fuzzy set {3: 0.2, 4: 0.5, 5: 0.9, 6: 1}, i.e., the membership of value 3 is 
0.2, and so on. The voting pattern of a group of 10 persons for this score could be 
as in Table 5.3.1. 
Table 5.3.1 Voting pattern for high dice values 
 
 

112 
5   Modelling and Computing with Generally Quantified Statements
 
That is, all voters, P1 to P10, vote for value 6 as a high score, while only two of 
them, P1 and P2, vote for 3 as a high score, and so on. In other words, the crisp 
definition of P10 for the high score is {6}, while that of P1 and P2 is {3, 4, 5, 6}, 
for instance. An assumption made in this voting model is that any person who ac-
cepts a value as a high score also accepts all values that have higher membership 
grades in the fuzzy set high. This model defines the following mass assignment on 
the power set of {1, 2, 3, 4, 5, 6}:  
{6}: 0.1 {5, 6}: 0.4 {4, 5, 6}: 0.3 {3, 4, 5, 6}: 0.2.  
Using the voting model, given two fuzzy sets A and B on a domain U, the  
fuzzy conditional probability Pr(A | B) is defined in Baldwin, Lawry and Martin 
(1996) by: 
Pr(A | B)  =  ∑
⊆U
T,
S
Pr(u∈S | u∈T).mA(S).mB(T)                  (Eq. 5.3.1) 
where mA(S) and mB(T) are the masses of subsets S and T of U, respectively. The 
intuitive meaning of Pr(A | B) is that it is the probability for a fuzzy proposition 
x∈A being true given x∈B being true. In other words, it is the fuzzy conditional 
probability of x∈A given x∈B. The above definition can also be adapted for fuzzy 
sets on continuous domains, using α-cuts and integration instead of addition as 
follows: 
∫∫
∫∫
∩
=
∩
=
1
0
1
0
1
0
1
0
dxdy
B
B
A
dxdy
B
Pr
B
A
Pr
)
B
|
A
Pr(
x
y
x
x
y
x
)
(
)
(
 
For example, suppose that the dice value about 5 is defined by the fuzzy set {6: 
0.3, 5: 1, 4: 0.3}, whose mass assignment is: 
{5}: 0.7 {4, 5, 6}: 0.3.  
Then, one has: 
Pr(high | about 5)  
 
=  Pr(u∈{5} | u∈{6}).mhigh({6}).mabout_5({5}) 
+ Pr(u∈{5} | u∈{5, 6}).mhigh({5, 6}).mabout_5({5})  
+ Pr(u∈{5} | u∈{4, 5, 6}).mhigh({4, 5, 6}).mabout_5({5}) 
+ Pr(u∈{5} | u∈{3, 4, 5, 6}).mhigh({3, 4, 5, 6}).mabout_5({5}) 
+ Pr(u∈{4, 5, 6} | u∈{6}).mhigh({6}).mabout_5({4, 5, 6}) 
+ Pr(u∈{4, 5, 6} | u∈{5, 6}).mhigh({5, 6}).mabout_5({4, 5, 6}) + 
+ Pr(u∈{4, 5, 6} | u∈{4, 5, 6}).mhigh({4, 5, 6}).mabout_5({4, 5, 6}) 
+ Pr(u∈{4, 5, 6} | u∈{3, 4, 5, 6}).mhigh({3, 4, 5, 6}).mabout_5({4, 5, 6}) 
= 0.53.  
5.4   Universally Quantified Conceptual Graphs 
Predicate logic uses both existential and universal quantifiers. However, one prob-
lem is that a universally quantified statement in natural language is not smoothly  
 

5.4   Universally Quantified Conceptual Graphs 
113
 
mapped to a predicate logic formula with a universal quantifier. For example, the 
statement “Every student likes every course” is mapped to the following formula: 
∀x∀y (student(x) ∧ course(y) → like(x, y)) 
The point is that the statement does not have the implication connective, but the 
formula does. Many sorted or typed logic avoids this problem by quantification 
over types as follows: 
∀x∈STUDENT∀y∈COURSE: like(x, y) 
Still, the structure of the formula, in which the quantified subject and object are 
moved to the left, does not match to that of the statement, where the predicate is in 
between them. 
The structure of CGs is close to that of natural language and smoothly accom-
modates universal as well as generalized quantifiers in concept vertices. More-
over, CGs themselves are logical formulas and reasoning can be performed on 
them as logical operations. For example, given two CGs, one can determine 
whether one subsumes the other by a CG projection performed directly on the two 
CGs. However, founded on Peirce’s existential graphs, the basic CG presented in 
Section 2.2 uses only existentially quantified concepts. In this section, CG nota-
tion is extended with the universal marker to represent universally quantified 
statements. Then we define the universal projection and universal join as direct 
reasoning operations on those extended CGs. 
 
 
Fig. 5.4.1 A universal CG and its defining expansion 
The universal marker was early introduced in Sowa (1984).  We call a concept 
with the universal marker ∀ a universal concept, and a concept with the generic 
marker * or an individual marker an existential concept. A plain CG is one that 
does not have any nested context, but is not necessarily connected and may have 

114 
5   Modelling and Computing with Generally Quantified Statements
 
coreference links. A plain CG is called a universal CG if it contains universal con-
cepts, or an existential CG otherwise. 
A universal CG G with n universal concepts c1, c2, ... , cn is defined by its ex-
pansion Ge = ¬[ c∃1 c∃2 ... c∃n ¬[G∃]], where each c∃i is the concept derived from ci 
by replacing the universal marker by the generic marker, G∃ is derived from G by 
replacing every ci by c∃i, and every c∃i is coreference-linked to its copy in G∃. (cf. 
Sowa 1984). For illustration, Figure 5.4.1 shows a universal CG and its defining 
expansion, saying “Every course is offered by a lecturer who assigns a PhD stu-
dent to be its tutor”. 
 
Universal CG Projection 
 
As introduced in Section 2.2, if an existential CG G has a projection to an existen-
tial CG H, then by definition G subsumes H, and on the other hand, G is a logical 
consequence of H. Such a projection operation can also be defined on universal 
CGs. First, we extend the subsumption preorder on existential concepts for both 
existential and universal concepts. We use the same notation of information order-
ing ≤ι to denote this preorder. Also, we say that a type is not absurd when its ex-
tension is not empty. 
 
Definition 5.4.1. A concept a: [Ta: referent(a)] is said to be subsumed by a con-
cept b: [Tb: referent(b)], denoted by b ≤ι a, iff either of the following holds: 
1.  referent(a) and referent(b) are identical individual markers, and Tb ≤ι Ta 
2.  referent(a) is either an individual marker or *, referent(b) is *, and Tb ≤ι Ta  
3.  referent(a) and referent(b) are both ∀, and Ta ≤ι Tb 
4.  referent(a) is ∀ and referent(b) is *, and the least specific common subtype 
Ta∩Tb is not absurd. 
 
The first two cases are the same as defined for basic CGs. It is clear that case 3 
also satisfies the intended meaning of the subsumption relation, where Ta ≤ι Tb is 
the condition instead of Tb ≤ι Ta. Here, the intuition is, for example, the CG [Tb: 
∀]→(p), saying “Every instance of Tb has property p”, is a logical consequence of 
the CG [Ta:∀]→(p), saying “Every instance of Ta has property p”, given Ta ≤ι Tb. 
Meanwhile, for case 4, [Ta: ∀]→(p) implies [Tb: ∗]→(p) when Ta∩Tb is not  
absurd. 
Definition 5.4.2 below is an extension of the definition of the existential CG 
projection, for both existential and universal CGs. However, not as in existential 
CG projections, in a universal CG projection Π: G → H, one concept in G can be 
mapped to one or more universal concepts in H. Those universal concepts in H 
that a common concept in G is mapped to are said to be coreferent after projec-
tion, which is an equivalence relation (i.e., a reflexive, symmetric and transitive 
one). In the definition, we write VCG,  VC∃G, VC∀G, and VRG to respectively denote 
the sets of all concepts, existential concepts, universal concepts, and conceptual 
relations in a CG G (VC∃G∪VC∀G = VCG). A concept variable with the subscript ∀ 
or ∃ denotes a universal or existential concept, respectively. Also, for each set S of 

5.4   Universally Quantified Conceptual Graphs 
115
 
concepts in H, we write Π-1S to denote the set of those concepts in G that are 
mapped to some concepts in S, i.e., Π-1S = {c∈VCG | ∃c’∈S: c’∈Πc}. 
 
Definition 5.4.2. Let G and H be two plain CGs with no coreference links. Then, 
G is said to have a projection to H, denoted by G ≤ι H, iff there exists a mapping 
Π: G → H, such that: 
1.  ∀r∈VRG: r ≤ι Πr, and  
∀i∈{1, 2, ... , degree(r)}: neighbour(Πr, i)∈Πneighbour(r, i),  
2.  ∀c∈VC∃G:  
(i)   Πc = {only one c’ | c’∈VC∃H and c ≤ι c’} or 
(ii)  Πc = {c’ | c’∈VC∀H and c ≤ι c’}, 
3.  ∀c∈VC∀G: Πc = {c’ | c’∈VC∀H and c ≤ι c’}, and 
4.  For each partition S of universal concepts in H that are coreferent after pro-
jection: 
(i)  Π-1S = {c∀0, c∃1, c∃2, ..., c∃m} and type(c∃i) ≤ι type(c∀0) for every 1 ≤ i ≤ 
m, or 
(ii)  Π-1S 
= 
{c∃1, 
c∃2, 
..., 
c∃m} 
and 
the 
type 
intersection 
(∩c’∈Stype(c’))∩(∩i=1,mtype(c∃i)) is not absurd.  
 
Condition 1 is the same as for the existential CG projection. Condition 2 means 
that each existential concept in G can be mapped to only one existential concept or 
some universal concepts in H. Condition 3 means that each universal concept in G 
can be mapped to only universal concepts in H. Meanwhile, condition 4 constrains 
mappings to those universal concepts that are coreferent after projection. Intui-
tively, those universal concepts are considered as being unified into a single con-
cept via the projection, which explains 4(i) and 4(ii) depending on whether there is 
a universal concept in G mapped to that unifying concept in H or not. It also im-
plies that different universal concepts in G cannot be mapped to the same univer-
sal concept in H. For example, Figure 5.4.2 shows a projection from the CG  
expressing “Every student has a name” to the CG expressing “Every person has a 
name and age”. 
 
Fig. 5.4.2 A universal CG projection 
Theorem 5.4.1 states the soundness of the universal CG projection with respect 
to the subsumption relation. That is, if G has a projection to H, then G subsumes H 
or, in other words, G is a logical consequence of H. 

116 
5   Modelling and Computing with Generally Quantified Statements
 
Theorem 5.4.1. Let G and H be two plain CGs with no coreference links. If G ≤ι 
H, then G is a logical consequence of H. 
 
Figure 5.4.3 shows subsumption relations between some example universal CGs, 
on the basis of Definition 5.4.2 and Theorem 5.4.1. 
 
Fig. 5.4.3 Subsumption relations between universal CGs 
Using the universal CG projection, we can determine subsumption relations 
between universal CGs directly on these CGs, without the need to expand them to 
less concise and more complicated existential CGs with nested negations. This 
subsumption relation can also be exploited to organize universally quantified 
facts in hierarchies, which help to speed up searching and retrieval operations, as 
it was done for existential CGs (Ellis and Lehmann 1994). Since the universal 
CG projection is also based on the CG structure and concept and relation partial 
orders, efficient matching techniques of the existential CG projection could be 
applied to it. 
 
Universal Concept Join 
 
For existential CGs, only coreferent concepts can be joined so that their semantics 
are still preserved. For universal CGs, universal concepts in a CG can be joined 
with concepts in another CG to infer a new CG, under the conditions in the fol-
lowing definition. 
 
Definition 5.4.3. Let G be a universal CG and H be any plain CG, with no corefer-
ence links in G and H. One or more universal concepts in G can be joined with 
concepts in H as follows: a concept a: [Ta: ∀] in G can be joined with a concept b: 
[Tb: referent(b)] in H, where Ta ≤ι Tb, into the concept [Tb: referent(b)]. We denote 
the resulting CG by J∀(G, H). 
 

5.5   Generally Quantified Conceptual Graphs 
117
 
Note that, in Definition 5.4.3, G can be joined with H at several universal concepts 
in G in one operation, and the order of the two arguments of J∀() is significant. 
After a join, duplicate conceptual relations in the resulting CG can be eliminated.  
 
Theorem 5.4.2. Let G be a universal CG and H be any plain CG, with no corefer-
ence links in G and H. Then, any J∀(G, H) is a logical consequence of {G, H}. 
 
For example, in Figure 5.4.4, G says “For every man and every woman, there is a 
color that he likes but she hates”, and H says “Every American man loves some 
woman”. Applying Theorem 5.4.2, we can derive the shown J∀(G, H) from G and H 
by joining [MAN: ∀] with [AMERICAN-MAN: ∀] and [WOMAN: ∀] with [WOMAN: *]. 
 
Fig. 5.4.4 A universal concept join 
One could see that the universal concept join is actually a realization of the 
universal instantiation and inheritance rules, which are performed simultaneously 
in one graph operation. Also, although the defined universal projection and join 
are for crisp CGs, they can be straightforwardly extended for FCGs using the in-
formation ordering and operations on fuzzy attribute values. 
5.5   Generally Quantified Conceptual Graphs 
Quantification as Conditional Probability 
 
Firstly, there are two types of quantifiers that need to be distinguished because in-
ferences from them are not the same. An absolute quantifier expresses a number 
of objects having some properties. In contrast, a relative quantifier expresses a 
proportion of a set of objects that has some properties. Examples of absolute quan-
tifiers are only one, few, or several, while ones of relative quantifiers are about 
9%, half, or most.  
Without imprecision, absolute quantifiers are defined by natural numbers, while 
relative quantifiers are defined by non-negative rational numbers that are not 
greater than 1, where 0 means 0% and 1 means 100%. Correspondingly, in the case 
of imprecise quantification, absolute quantifiers can be defined by fuzzy sets on the 
set N of natural numbers, i.e., fuzzy numbers whose domain is restricted to N, and 

118 
5   Modelling and Computing with Generally Quantified Statements
 
relative quantifiers by fuzzy numbers whose domain is restricted to the set of ra-
tional numbers in [0, 1]. However, for simplicity of representation and computation 
of imprecise quantifiers, we define fuzzy absolute quantifiers generally as fuzzy 
numbers on [0, +∞) and fuzzy relative quantifiers as fuzzy numbers on [0, 1]. 
The existential quantifier in classical logic corresponds to at least 1 in natural 
language, which is an absolute quantifier whose membership function is defined 
by μat least 1(x) = 1 if x ≥ 1, or μat least 1(x) = 0 otherwise. Meanwhile, the universal 
quantifier, which corresponds to all or every in natural language, is a relative 
quantifier and its membership function is defined by μall(1) = 1 and μall(x) = 0 for 
every 0 ≤ x < 1. 
Arithmetic operations for fuzzy numbers as presented in Section 5.2 are appli-
cable to absolute quantifiers with [0, +∞) being used in place of R, and to relative 
quantifiers with [0, 1] being used instead. Also, each absolute quantifier Q on a 
type T whose denotation set in a universe of discourse has the cardinality |T| corre-
sponds to the relative quantifier QT = Q/|T|. 
A relative quantifier Q in a statement “Q A’s are B’s” can be interpreted as the 
conditional probability of B(x) being true given A(x) being true for an object x 
picked at random uniformly. That is, it can be represented by the probabilistic 
logic rule B(x) ← A(x) [Q] where Q = Pr(B(x) | A(x)). For example, “Most Swedes 
are tall” can be represented by tall(x) ← Swede(x) [most] where most = Pr(tall(x) | 
Swede(x)). 
In general, A(x) or B(x) can be represented in conceptual graphs or any other 
logical formalism. Simple FCGs with fuzzy attribute values are already presented 
in Section 2.7. We now formulate generally quantified FCGs as logical expressions 
that smoothly match with generally quantified statements in natural language. 
 
Generally Quantified FCGs 
 
In Sowa (1984), set referents and numeric quantifiers were introduced into con-
cepts to represent plural noun phrases and quantification in natural language, 
where the semantics of such an extended CG was defined by its expansion into a 
CG without numeric quantifiers.  For example, Figure 5.5.1 shows an extended 
CG G and its defining expansion E, which literally says “There exists a set of two 
persons who see John”.  
 
Fig. 5.5.1 A CG with a numeric quantifier and its defining expansion 
However, that defining expansion does not capture the actual meaning of gen-
eralized quantifiers, because a quantifier on a type does not simply mean that there 
exists a set of objects of that type that have some property, and the cardinality of 

5.5   Generally Quantified Conceptual Graphs 
119
 
the set is defined by the quantifier. Rather, a quantifier on a type constrains the 
number of objects of that type that can have some property. For example, “Only 
one person is the President of the United States” means not only “There exists a 
set of only one person who is the President of the United States”, but also “There 
is no more than one person who is the President of the United States”, as the for-
mer alone does not exclude “There are two different sets each of which has only 
one person who is the President of the United States”. 
Here we apply the conditional probability interpretation of relative quantifiers 
presented above to define an FCG with a relative quantifier as a probabilistic FCG 
rule, where the quantifier is the conditional probability of the head given the body 
of the rule, which are both represented by simple FCGs. Meanwhile, an FCG with 
an absolute quantifier is semantically equivalent to the one with the relative quan-
tifier converted from that absolute quantifier as noted above.  
In this volume, we consider FCGs that contain only one generally quantified con-
cept, excluding ones with the generic referent *, whose quantifiers are implicitly the 
existential quantifier. For example, Figure 5.5.2 shows a generally quantified FCG 
G and its defining expansion E, expressing “Most Swedes are tall”, where most and 
tall are linguistic labels of fuzzy sets. We note that this defining expansion rule can 
be seen as a generalization of the one for universally quantified CGs presented in 
Section 5.4, as the universal quantifier is a special relative quantifier. 
Furthermore, the type in a generally quantified concept can be represented by a 
simple FCG as a lambda expression defining that type, as for CGs (Sowa 1999). 
We call such a simple FCG a lambda FCG. It is like a simple FCG except that it 
has one concept, called a lambda concept, whose referent is denoted by λ to be 
distinguished from the generic and individual referents. For example, Figure 5.5.3 
illustrates a generally quantified FCG G and its defining expansion E, expressing  
 
 
Fig. 5.5.2 A generally quantified FCG and its defining expansion 
 
Fig. 5.5.3 Quantification on a type defined by a lambda FCG  

120 
5   Modelling and Computing with Generally Quantified Statements
 
“Most people who are tall are not fat”. As such, a lambda FCG corresponds to a 
relative clause in natural language. 
We now formally define generally quantified FCGs and the expansion rule for 
their semantics as exemplified above. Since a generally quantified concept 
[T:{*}Q] is semantically equivalent to [[T: λ]:{*}Q], where [T: λ] is a special 
lambda FCG with only the lambda concept, one can always assume the type of a 
generally quantified concept to be represented by a lambda FCG. 
 
Definition 5.5.1. A generally quantified concept is defined by a triple of a concept 
type represented by a lambda FCG, the set referent {*}, and a generalized quanti-
fier. A generally quantified FCG is a simple FCG with one generally quantified 
concept. It is said to be a relatively quantified or an absolutely quantified FCG if 
the generalized quantifier in it is a relative quantifier or an absolute quantifier, re-
spectively. 
 
Definition 5.5.2. The defining expansion of a relatively quantified FCG G is the 
probabilistic FCG rule if F then H [Q] where: 
1.  F is obtained from the lambda FCG in G by replacing its lambda concept 
[T: λ] with [T: *], H is obtained from G by replacing its generally quantified 
concept with [T: *], and there is a coreference link between these two con-
cepts [T: *] of F and H. 
2. Q is the relative quantifier in G and Pr(H | F) = Q. 
5.6   Computing with Linguistic Quantifiers 
For the inference rules presented below, generalizing an FCG means replacing its 
concept or relation types and concept referents with less specific ones, as for a 
CG, and its fuzzy attribute values with ones whose defining fuzzy sets are fuzzy 
supersets of those defining the former. It is dually similar for specializing. Also, 
reasoning on relative quantifiers and absolute quantifiers are different. 
 
Inference Rules for Relative Quantifiers 
 
Proposition 5.6.1. A generally quantified FCG G with a relative quantifier Q en-
tails a generally quantified FCG G* obtained from G by generalizing it except for 
its generally quantified concept, and replacing Q with at least Q. 
 
Fig. 5.6.1 Generalization inference rule for relative quantifiers 

5.6   Computing with Linguistic Quantifiers 
121
 
For example, in Figure 5.6.1, G expressing “Most people who are tall are not fat” 
entails G* expressing “Most people who are tall are not very fat”, provided that 
not fat ⊆ not very fat, and most is a non-decreasing fuzzy number whereby at least 
most = most as noted in Section 5.2. 
 
Proposition 5.6.2. A generally quantified FCG G with a relative quantifier Q en-
tails a generally quantified FCG G* obtained from G by specializing it except for 
its generally quantified concept, and replacing Q with at most Q. 
 
For example, in Figure 5.6.2, G expressing “About 9% people who are tall are fat” 
entails G* expressing “At most about 9% people who are tall are very fat”, pro-
vided that very fat ⊆ fat. 
 
Fig. 5.6.2 Specialization inference rule for relative quantifiers  
Proposition 5.6.3 A universally quantified FCG G entails a universally quantified 
FCG G* obtained from G by specializing its lambda FCG. 
 
For example, in Figure 5.6.3, G expressing “All people who are tall are not fat” 
entails G* expressing “All males who are very tall are not fat”, provided that very 
tall ⊆ tall.  
 
Fig. 5.6.3 Inference rule for the universal quantifier 
In Section 5.4, the universal CG projection defines the entailment relation be-
tween two universally quantified CGs, where each CG could have more than one 
universally quantified concept but quantification is only on concept type labels. 

122 
5   Modelling and Computing with Generally Quantified Statements
 
Here a universally quantified FCG is assumed to have only one universally quanti-
fied concept, but its concept type can be a lambda FCG though. Proposition 5.6.3 
above is in agreement with the defined universal CG projection, with respect to 
the entailment relation between two involved CGs or FCGs. 
 
Inference Rules for Absolute Quantifiers 
 
The following propositions are obtained on the basis noted in Section 5.5 that an 
absolutely quantified FCG is semantically equivalent to a relatively quantified one 
with the corresponding relative quantifier, whose defining expansion is given by 
Definition 5.5.2.  
 
Proposition 5.6.4. A generally quantified FCG G with an absolute quantifier Q 
entails a generally quantified FCG G* obtained from G by generalizing it, includ-
ing its lambda FCG, and replacing Q with at least Q. 
 
For example, in Figure 5.6.4, G expressing “Few people who are tall are fat” en-
tails G* expressing “At least few people who are fairly tall are fairly fat”, provided 
that tall ⊆ fairly tall, fat ⊆ fairly fat, and few is used as an absolute quantifier. 
 
Fig. 5.6.4 Generalization inference rule for absolute quantifiers 
Proposition 5.6.5. A generally quantified FCG G with an absolute quantifier Q 
entails a generally quantified FCG G* obtained from G by specializing it, includ-
ing its lambda FCG, and replacing Q with at most Q. 
 
For example, in Figure 5.6.5, G expressing “Few people who are tall are fat” en-
tails G* expressing “At most few people who are very tall are very fat”, provided 
that very tall ⊆ tall, very fat ⊆ fat, and few is also used as an absolute quantifier. 
 
Jeffrey’s Rule 
 
In practice, it is often the case that a condition probability v = Pr(B(x) | A(x)) is ob-
tained from statistical data meaning that, if an object x is randomly picked up  
such that A(x) is true, then the probability for B(x) being true is v. As such, that  
 

5.6   Computing with Linguistic Quantifiers 
123
 
 
Fig. 5.6.5 Specialization inference rule for absolute quantifiers 
conditional probability value may not be applicable to a specific object in a uni-
verse of discourse. For example, one may have Pr(fly(x) | bird(x)) = 0.9 express-
ing that 90% of birds can fly, but the probability for a penguin, a specific bird,  
being able to fly is 0.  
Therefore, for decision making, Jeffrey (1965) introduced a rule assuming such 
a conditional probability like Pr(B(x) | A(x)) or Pr(B(x) | ¬A(x)) to be applicable to 
any specific object o or, in other words, Pr(B(o) | A(o)) = Pr(B(x) | A(x)) and 
Pr(B(o) | ¬A(o)) = Pr(B(x) | ¬A(x)), when only the probability for A(o) being true 
is known. Then, on the basis of the total probability theorem, the probability for 
B(o) being true could be obtained as follows: 
Pr(B(o))  
 
= Pr(B(o) | A(o)).Pr(A(o)) + Pr(B(o) | ¬A(o)).Pr(¬A(o)) 
= Pr(B(x) | A(x)).Pr(A(o)) + Pr(B(x) | ¬A(x)).Pr(¬A(o)). 
 
As defined in Section 2.7, FCG projection matches a simple FCG with another 
and computes the relative necessity degree of the former given the later. Here, for 
applying Jeffrey’s rule to reasoning with generally quantified FCGs, we introduce 
probabilistic FCG projection that computes the conditional probability of a simple 
FCG given another one. For its definition, we apply the definition of conditional 
probability of fuzzy events in Section 5.3, which is generally treated here as a 
fuzzy number on [0, 1].  
 
Definition 5.6.1. Let G and H be two simple FCGs. A probabilistic FCG projec-
tion from G to H is a mapping π: G → H such that: 
1.  ∀c∈VCG: referent(c) ≤ι referent(πc) and type(c) ≤ι  type(πc).  
2.  ∀r∈VRG: neighbour(πr, i) = πneighbour(r, i) for every i ∈ {1, 2, ..., ar-
ity(type(r))}, and type(r) ≤ι  type(πr). 
Then επ = Pr(G | πG) is defined to be the product of the conditional probabilities 
of all fuzzy attribute values pairs in π. 
 
For example, Figure 5.6.6 shows a probabilistic FCG projection from G express-
ing “Some person is tall” to H expressing “John is fairly tall”, where Pr(G | H) = 
Pr(G | πG) = Pr(tall | fairly tall). 

124 
5   Modelling and Computing with Generally Quantified Statements
 
 
Fig. 5.6.6 A probabilistic FCG projection 
In the following proposition, for a probabilistic FCG projection from a lambda 
FCG to a simple FCG, we assume the referent λ in the lambda concept to be re-
placed with the generic referent *. 
 
Proposition 5.6.6. Let G be a generally quantified FCG with a relative quantifier 
Q, and G* be a simple FCG such that there is a probabilistic FCG projection π 
from the lambda FCG in G to G*. Then Jeffrey’s rule derives the simple FCG H* 
with the probability (at least (Q.επ))∩(at most (Q.επ + (1 − επ))) where H* is ob-
tained from G by replacing its generally quantified concept with its lambda con-
cept c whose referent λ is replaced with referent(πc). 
 
Fig. 5.6.7 Jeffrey’s rule on generally quantified FCGs 
For example, in Figure 5.6.7, G expresses “Most people who are tall are not 
fat” and G* expresses “John is fairly tall”. Then H* expressing “John is not fat” 
can be derived with the probability p = (at least (most.επ))∩(at most (most.επ + (1 
− επ))), where επ = Pr(tall | fairly tall), as an answer to the query “How likely is it 
that John is not fat?”. 
5.7   Summary 
Generalized quantifiers are defined by fuzzy numbers to capture their vagueness 
and imprecision often encountered in natural language. For computing and reason-
ing with them, fuzzy arithmetic is revisited with the introduction of fuzzy number 
lower and upper bounds and some of their properties proved. Both of the exten-
sion principle and the α-cut and interval arithmetic-based method are considered 

5.7   Summary 
125
 
for fuzzy number operations. The notion of fuzzy conditional probability is also 
recalled for the probabilistic interpretation of relative quantifiers. 
Initially, for representing universally quantified statements in natural language, 
the universal quantifier is introduced into conceptual graphs as the universal 
marker placed in concept vertices. A universal CG is semantically equivalent and 
expanded to a CG rule on existential CGs. Universal CG projection and join are 
defined and proved to be sound inference operations that are performed directly on 
universal CGs. 
Then, a generally quantified FCG with a relative quantifier, defined by a fuzzy 
number on [0, 1], is interpreted as a probabilistic FCG rule with that relative quan-
tifier as the conditional probability of the head given the body of the rule. Mean-
while, an absolutely quantified FCG is semantically equivalent to a relatively 
quantified one with the corresponding relative quantifier. On the basis of this se-
mantics, generalization, specialization, and Jeffrey’s inference rules are derived to 
perform directly on generally quantified FCGs.  
This is a step in formally integrating generalized quantifiers into conceptual 
graphs. The presented inference rules are not meant to be complete, but to show 
how some basic patterns of human reasoning on generally quantified statements in 
natural language could be performed as machine operations on corresponding 
generally quantified FCGs. In the general case, one could apply the proposed 
probabilistic interpretation of generally quantified FCGs to study complete infer-
ence rules on them in the framework of probabilistic logic programming.  
We however believe that human reasoning is more heuristic and plausible than 
sound and complete. That is because one often has to make additional assumptions 
on given information in order to infer useful new information, and thus the infer-
ence is actually not sound with respect to the given information. Meanwhile the 
high complexity of a problem makes complete inference impractical. Therefore, as 
the theme of this work is to combine fuzzy logic and conceptual graphs, both of 
which emphasize the target of natural language, into a logical formalism for Arti-
ficial Intelligence approaching human expression and reasoning, it also concerns 
heuristic and plausible inference rules on FCGs. The next chapter presents another 
application of fuzzy conceptual graphs for approximate knowledge retrieval. 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 127–144. 
springerlink.com                  © Springer-Verlag Berlin Heidelberg 2010 
Chapter 6 
Approximate Knowledge Retrieval 
6.1   Overview 
The explosion of information on the World Wide Web and its moving to the next 
generation, so called Semantic Web (Berners-Lee, Hendler and Lassila 2001), is 
challenging the conventional relational database model at least in two aspects. 
Firstly, such information is no longer as simple as to be easily and naturally repre-
sented in relational tables. Secondly, exact answers are hardly obtained when 
searching for information on the Web.     
For solving the first problem, fuzzy conceptual graphs have two advantages. 
Firstly, as a graph language, they are suitable for representation of weakly struc-
tured information on the Web. Secondly, in a graphical form, they are more  
flexible than fixed textbox patterns to describe queried objects in a system user in-
terface. For readable Web data languages, after comparing the CG and the RDF, 
Berners-Lee (2001) concluded that the CG could be easily integrated with the Se-
mantic Web. As shown later in details in Yao and Etzkorn (2004), there is a close 
mapping between the CG and the RDF, which has become a common and stan-
dard model for data interchange on the Web.  
Meanwhile, the second problem is mainly concerned with the semantic distance 
between concepts, relations, names, and attributes in knowledge graphs, which has 
attracted significant research effort. For semantic distance between concept and 
relation types, previous methods can be classified into two main approaches, 
namely, corpus-based and ontology-based. In the former approach, the semantic 
distance between words representing concepts or relations is determined on the 
basis of their contexts of occurrence in a linguistic corpus. In the latter approach, it 
is determined on the basis of the semantic nets involving the words. However, 
such methods do not work for un-interpreted type labels in a hierarchy, because a 
word representing a type maybe just a dummy identifier for the type, not necessar-
ily attached to any linguistic corpus nor having any meaning. 
For matching knowledge graphs with concept and relation types defined in an on-
tology, Cao and Huynh (2006) proposed to use occurrence probabilities of entities 
and entity tuples of those concept and relation types based on their populations in 
the ontology of discourse. The rational of that proposal is that the semantic distance 
between two concepts depends on their populated instances in a particular context. 
For example, since in Viet Nam there are many motorcycles used, the semantic  
distance between the concept “motorcycle” is closer to the concept “vehicle” than 
their semantic distance in the USA. Cao and Huynh (2007) followed that popula-
tion-based approach to define matching degrees for entity names represented by  

128 
6   Approximate Knowledge Retrieval
 
character strings. Actually, it is often that, when querying, users do not remember or 
type in exactly names of entities to be searched for, which produces mismatching 
between a query and an answer. For fuzzy attribute values, fuzzy conditional prob-
abilities were applied to measure their differences. 
Another issue to be addressed is that, while symmetric measures like similarity 
have been discussed much in literature and commonly used in commercial search 
engines like Google, asymmetric measures appear to be less popular. In particular, 
in practice one may want to measure how much a query graph subsumes an an-
swer graph. Applying fuzzy set theory to information retrieval, Miyamoto (1990) 
introduced the related term relation and the narrower term relation respectively as 
symmetric and unsymmetric ones. A short survey of soft information retrieval ap-
proaches was presented in Crestani and Pasi (1999).  In Andreasen, Bulskov and 
Knappe (2003), although using the term “similarity”, which is presumably a sym-
metric measure, the authors argued that it should not be symmetric.  
Regarding the system implementation aspect, realizing an approximate retrieval 
system of knowledge graphs from scratch is a formidable task. Meanwhile, there 
are new technologies for management of Web knowledge and information devel-
oped. For example, Sesame (Kampman, Harmelen and Broekstra 2002) with its 
query language SeRQL is for storing and querying RDF graphs. Those are open 
sources and have been used in many large-scale systems. They can be employed 
for approximate search using the query modification approach. That is, a query 
graph is first generalized to retrieve stored knowledge graphs by the exact match-
ing mechanism of those tools. The retrieved graphs, which are subsumed by the 
generalized query graph, are then matched to the original query graph to give their 
similarity and subsumption degrees. 
Since a formal language like SeRQL, with various syntactic symbols for  
machinery processing, is still difficult for non-experts to use, in this chapter we 
present conceptual graphs as an alternative graph-based language for query ex-
pressions at the interface layer. Query conceptual graphs are then automatically 
converted to SeRQL queries to be executed by the Sesame query engine. 
The rest of the chapter is organized as follows. Section 6.2 reviews previous 
definitions of similarity measures for words, and proposes ontology-based similar-
ity and subsumption measures for entity concept types, relation types, names, and 
fuzzy attribute values. Section 6.3 presents the use of Sesame, SeRQL, and con-
ceptual graphs for storing and querying knowledge graphs. Section 6.4 develops a 
query modification method and a CG-SeRQL mapping algorithm for approximate 
knowledge graph retrieval. Section 6.5 presents application of the defined meas-
ures and methods to development of our knowledge and information management 
system VN-KIM. Finally, Section 6.6 concludes the chapter. 
6.2   Matching Measures for Entity Types, Names, and 
Attributes 
Similarity between Words 
The similarity between expressions, such as words or concepts, measures  
how close their semantics or meanings are. Previous methods for words could be 

6.2   Matching Measures for Entity Types, Names, and Attributes 
129
 
classified into corpus-based and ontology-based approaches, which are also called 
knowledge-poor and knowledge-rich ones, respectively. 
In the corpus-based approach, relations between words from a linguistic corpus 
are investigated. Its main assumption is that similar words are used in similar con-
texts, and similar contexts use similar words. So, a distribution of co-occurrences 
of words within different contexts could be used to calculate the similarity be-
tween the words (Church and Hanks 1989; Gauch, Wang and Rachakonda 1999). 
The advantage of this approach is that it does not require domain knowledge. As 
such, however, it misses the semantic relations, in particular one of inheritance, 
between words in natural language. 
Meanwhile, in the ontology-based approach, predefined semantics, in particular 
taxonomy, of concepts is taken into account, where lexical resources are built into 
a network or directed graph. The similarity between concepts is then calculated 
based on the properties of the paths connecting them. So, the approach is intuitive 
and easy to understand. It is also classified further into the dictionary-based and 
taxonomy-based approaches. 
In dictionary-based methods, a monolingual dictionary is turned into a network 
by creating a node for every headword, and edges for relations between a head-
word and the words in its definition. The similarity between words is then calcu-
lated by spreading activation on this network (Ho and Cédirick 2004; Kozima and 
Ito 1997). 
In contrast, the simplest taxonomy-based method computes the similarity be-
tween two concepts on the basis of the number of edges on the shortest path be-
tween them in a hierarchy such as the one defined in WordNet (Leacock and 
Chodorow 1998; Wu and Palmer 1994). As suggested in Hirst and St-Onge 
(1998), a concept is close in semantics to another if the path connecting them is 
not too long and does not change its direction too often. 
Unlike those edge-based methods, the node-based method in Resnik (1995) 
combines ontology-based and corpus-based approaches to measure the similarity 
between a pair of concepts c1 and c2 as the extent to which they share common in-
formation. That shared information is determined by the information content of 
the least common super-concept c1∨c2 given by an ontology of discourse: 
SimR(c1, c2) = − logPr(c1∨c2)                             (Eq. 6.2.1) 
where Pr(c) is the occurrence probability of the word representing a concept c in a 
corpus of discourse. The drawback of this method is that many pairs of concepts 
may have the same similarity degree if they have the same least common super-
concept. 
In order to overcome that drawback, Jiang and Conrath (1997) used both edge-
based and node-based measures. Its assumption is that the semantic distance of the 
link connecting a child concept c to its parent concept Par(c) is the information 
content of c that is not in Par(c). Formally, one has: 
                                                                             Pr(c∧Par(c)) 
 
DistJC(c, Par(c)) = − logPr(c | Par(c)) =  − log ⎯⎯⎯⎯⎯⎯           (Eq. 6.2.2)  
                                                                                   Pr(Par(c)) 
 
 

130 
6   Approximate Knowledge Retrieval
 
Since c∧Par(c) = c, one obtains:  
   Pr(c)  
DistJC(c, Par(c)) = −log ⎯⎯⎯⎯ = − logPr(c) + logPr(Par(c))       (Eq. 6.2.3) 
   Pr(Par(c)) 
where −logPr(c) represents the information content of a concept c. The semantic 
distance between two concepts c1 and c2 is then defined as the sum of their seman-
tic distances to their least common super-concept: 
                      DistJC(c1, c2)   
 
                       =  DistJC(c1, c1∨c2) + DistJC(c2, c1∨c2) 
=  − (logPr(c1) + logPr(c2)) + 2logPr(c1∨c2)                   (Eq. 6.2.4) 
The measure proposed in Lin (1998) used the same elements as in DistJC(), but 
in a different formula. However, as evaluated in Budanitsky and Hirst (2001), the 
Jiang-Conrath method is overall the best among the above-mentioned methods. 
 
Similarity and Subsumption between Entity Types 
 
The methods reviewed above measure similarity between actual words. In the  
Jiang-Conrath method, for instance, the information content of a concept is calcu-
lated via the occurrence probability of the word representing that concept in a  
corpus. However, usually a word labeling a type in a hierarchy is just a dummy 
identifier for the type, not necessarily attached to any linguistic corpus nor having 
any meaning. So, instead of relying on the occurrence probabilities of type labels, 
we propose to use those of type entities. That is, we define: 
Pr(t) = Pop(t)/N                                           (Eq. 6.2.5) 
where Pop(t) is the number of entities of a type t and N is the total number of enti-
ties in a knowledge base of discourse. Adapting Equation 6.2.4, one obtains: 
          Dist(t1, t2)  
 
               =  − (log(Pop(t1)/N) + log(Pop(t2)/N)) + 2log(Pop(t1∨t2)/N) 
   =  − (logPop(t1) + logPop(t2)) + 2log(Pop(t1∨t2))                        (Eq. 6.2.6) 
The similarity degree between two concept types can be defined as the inverse 
of their semantic distance, and scaled into [0, 1], as follows: 
                       1 
Sim(t1, t2) = ⎯⎯⎯⎯⎯⎯⎯                                    (Eq. 6.2.7) 
                         1 + Dist(t1, t2) 
This population-based measure can also be applied to the semantic distance be-
tween two relation types in a hierarchy, where the population of a relation type is 
the total number of entity tuples that are involved in relations of that type. 
One can notice that the above-mentioned measures are symmetric, for both 
words and entity types, as they should be with respect to the notion of similarity. 
For example, the similarity degree between a vehicle in the query “Find a vehicle” 
and a car in the answer “A certain car” is the same as the similarity between a car 

6.2   Matching Measures for Entity Types, Names, and Attributes 
131
 
in the query “Find a car” and a vehicle in the answer “A certain vehicle”, which is 
the similarity degree between the entity types “vehicle” and “car”.  
However, in practice, looking at the subsumption relation, one may consider 
the answer in the former case as an exact answer, because every car is a vehicle, 
while the answer in the latter case is just an approximate one, with respect to  
the queries. In general, one may want to evaluate how much a query subsumes an 
answer. 
As such, unlike similarity functions, which are symmetric, subsumption func-
tions are asymmetric. In other words, similarity is based on non-directed semantic 
distances, while subsumption is based on directed semantic distances. Equation 
6.2.2 above gives an idea to define a subsumption distance from a type t1 to a type 
t2 as follows: 
    Pr(t1 ∧t2) 
 
DistS(t1 → t2) = − logPr(t1 | t2) =  − log ⎯⎯⎯⎯⎯                   (Eq. 6.2.8) 
      Pr(t2) 
where t1∧t2 denotes the greatest common subtype of t1 and t2, and Pr(t) is defined 
as in Equation 6.2.5 for a type t. 
Then the subsumption degree of a type to another can be defined as the inverse 
of the directed semantic distance from t1 to t2, and scaled into [0, 1], as follows: 
                1 
Sub(t1 → t2)  =   ⎯⎯⎯⎯⎯⎯⎯⎯                                (Eq. 6.2.9) 
                  1 + DistS(t1 → t2) 
This definition satisfies intuition in the following special cases: 
- 
If t1 is a supertype of t2, i.e., t1∧t2 = t2, then Sub(t1 → t2) = 1 while Sub(t2 → 
t1) < 1. 
- 
If t1 and t2 are disjoint, i.e., t1∧t2 = ∅, then Sub(t1 → t2) = Sub(t2 → t1) = 0. 
Figure 6.2.1 illustrates the difference between similarity and subsumption 
measures. 
 
Fig. 6.2.1 Subsumption versus similarity 

132 
6   Approximate Knowledge Retrieval
 
Similarity and Subsumption between Entity Names 
 
Since entity names are represented as character strings, matching measures on 
strings can be used for name matching. Previous string matching methods could 
be classified into character-based and token-based ones. In character-based meth-
ods, the distance between two strings is defined as the minimal cost to convert one 
string to the other using edit operations such as copying, insertion, replacing, and 
deletion. Different methods define different weights for those operations. Leven-
shtein’s measure was a simple one in which the cost of insertion, replacing, and 
deletion was defined to be 1, while that of copying was 0 (Levenshtein 1966). In 
Monge and  Elkan (1996) the authors considered matching of two strings that 
could be recursively structured into fields and subfields. Meanwhile, Jaro’s meas-
ure was based on the number and position of the common characters between two 
strings (Jaro 1995). Winkler (1999) modified Jaro’s measure by taking into ac-
count the common prefix between matched strings. As discussed in Cohen, Ravi-
kumar and Fienberg (2003), Jaro’s and Jaro-Winkler’s measures are good for short 
strings. 
In contrast, for token-based measures, the order of tokens in a string is not im-
portant. For example, “Huynh Tan Dat” and “Dat Tan Huynh” are considered to 
be the same. That is, the measures were based on the number of common tokens 
between two strings. One simple method of this approach was given in Jaccard 
(1912), where the similarity between two strings was defined to be the ratio be-
tween the number of common tokens and the total number of tokens in the strings. 
As proposed in Bilenko et al. (2003), a string could be considered as a docu-
ment consisting of terms or tokens and, thus, from the information retrieval point 
of view, matching two strings became matching two documents.  In the vector 
space model (Salton 1989), a document is represented by a vector over an index 
term set of discourse, where the index term weight corresponding to each dimen-
sion of the vector is a value in [0, 1]. Let the vector representing a document d be 
(w1d, w2d,…, wtd) and that representing a document q be (w1q, w2q,…, wtq). Then the 
similarity of d to q is defined by the cosine of the angle between these two vectors, 
that is: 
                              ∑
i=1,twid × wiq 
sim(d, q) =  ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯                        (Eq. 6.2.10) 
                        (∑
i=1,twid
2 × ∑
i=1,twiq
2)
1/2 
Index term weights are derived as follows. Let N be the total number of docu-
ments in the system, ni be the number of documents where the index term ki oc-
curs, and freqid be ki’s raw frequency, i.e., the number of times ki occurs in d. The 
normalized frequency of ki in d is defined by: 
tfid = log(freqid  + 1)                                    (Eq. 6.2.11) 
The inverse document frequency for ki is defined by: 
idfi = log(N / ni)                                      (Eq. 6.2.12) 

6.2   Matching Measures for Entity Types, Names, and Attributes 
133
 
While tfid quantifies the occurrence degree of ki in d, idfi measures the significance 
of the occurrence of ki in a document; the more the number of documents where ki 
occurs is, the less significant the occurrence of ki is. So the weight of ki to d is de-
fined by: 
wid = tfid × idfi                                                                                     (Eq. 6.2.13) 
According to Bilenko et al. (2003), TF-IDF is the best token-based measure for 
string matching. 
However, all above-mentioned measures are similarity ones and thus symmet-
ric. Meanwhile, as discussed for entity type matching, one may also need an 
asymmetric measure for entity name matching. For example, if one wants to look 
for a person named “John” and in a knowledge base of discourse there is a person 
named “John Smith”, then “John Smith” should be returned as a satisfactory an-
swer. However, if a query is “John Smith” and in the knowledge base there is 
“John”, then the latter should be an approximate answer only. That is, being a 
query or a fact makes difference. 
Therefore, in Bilenko et al. (2003), the authors modified the TF-IDF method as 
follows. Let S be a query string and T be a fact string, and CLOSE(θ, S, T) = {u∈S 
| ∃v∈T: sim'(u, v) > θ}, where sim'(u, v) is a secondary similarity measure between 
u and v. For each u∈CLOSE(θ, S, T), let N(u, T) = maxv∈T sim'(u, v). Then, the Soft 
TF-IDF matching degree, or the subsumption degree, from S to T is defined by: 
        ∑ki∈CLOSE(θ, S, T) wiS × wiT × N(ki, T) 
Sub(S → T) = ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯                  (Eq. 6.2.14) 
        (∑
i=1,twid
2 × ∑
i=1,twiq
2)
1/2 
Intuitively, only those terms in S that are similar enough to a term in T are con-
sidered and, for such a term ki, its vector weights for S and T are adjusted by N(ki, 
T). We note that, if every token in S is in T, then CLOSE(θ, S, T) = S and N(u, T) = 
1 for every u in S. That is the case when Sub(S, T) is “maximal”, which is equal to 
sim(S, T) as defined in Equation 6.2.10 of the conventional TF-IDF model. As 
shown by the experiments therein, using Jaro-Winkler’s measure for sim'() and 
chosing θ = 0.9, this Soft TF-IDF measure is better than Jaro-Winkler’s and TF-
IDF measures in name matching. It is also clear that Soft TF-IDF is not symmetric. 
Still, Soft TF-IDF did not take into account the class (or type) of entities to be 
searched for. That is, all entity names irrespective of their classes were used for 
calculating inverse document frequencies. Meanwhile, occurrence of a term may 
be significant with respect to names of entities in one class, but not in another. 
For example, suppose that one wants to look for a person named “John Soft” and 
in a knowledge base of discourse there is a person named “John Smith” and  
another named “Bill Soft”. Then the latter should be a more expected answer,  
because “John” is more popular than “Soft” in person names and thus the occur-
rence of “Soft” is more significant. So, in this work, we adapt the Soft TF-IDF 
method for entity name matching but, given the class of entities to be searched 
for, only names of entities in that class are used for calculating inverse document 
frequencies. 

134 
6   Approximate Knowledge Retrieval
 
Similarity and Subsumption between Entity Attributes 
 
Since fuzzy attribute values were introduced into knowledge and data bases, a 
measure of similarity between fuzzy sets has become a natural demand. Several 
measures have been proposed for different purposes (Klawonn and Castro 1995). 
For in stance, in Mitaim and Kosko (1998) for object matching, the similarity de-
gree between two fuzzy sets A and B on a domain U was defined by: 
                          Card(A ∩ B) 
e(A, B)  =   ⎯⎯⎯⎯⎯⎯⎯                                (Eq. 6.2.15) 
                           Card(A ∪ B) 
where Card(C) was the cardinality of a fuzzy set C. Meanwhile, in Vertan and 
Boujemaa (2000) for image retrieval, the fuzzy distance between A and B was de-
fined as follows: 
d(A, B)  = ∑ μ(A\B)∪(B\A)(u) = ∑ |μA(u) − μB(u)|               (Eq. 6.2.16) 
                       u∈U        u∈U 
assuming that U was a discrete domain. For the continuous case of U, integration 
was used instead of addition. 
In this volume, our matching measures for fuzzy sets are defined on the same 
statistical basis of those for entity types and names as presented above, so that 
they can be combined in an integrated matching measure between knowledge 
graphs. As presented in Section 2.5, the set of all fuzzy sets on a domain U also 
forms a lattice with the fuzzy subset relation as the partial order, as compared to 
entity type lattices. In particular, for two fuzzy sets A and B on U, their least 
common fuzzy super-set is A∪B, and their greatest common fuzzy subset is A∩B. 
Therefore, Equation 6.2.4 can be adapted to define the similarity distance between 
fuzzy sets as follows: 
                 Dist(A, B)   
                  = − (logPr(A) + logPr(B)) + 2logPr(A ∪ B)  
= − logPr(A | A ∪ B) − logPr(B | A ∪ B)                           (Eq. 6.2.17) 
Meanwhile, the subsumption distance from A to B is adapted from Equation 6.2.8 
to be defined by:   
DistS(A → B) = − logPr(A | B)                            (Eq. 6.2.18) 
The proposed measures employ the definition of fuzzy conditional probability in-
troduced in Section 5.3. 
6.3   Storing and Querying Knowledge Graphs 
Sesame 
 
In order to effectively manage and exploit knowledge and information represented 
in RDF and RDFS, a system for efficient storage and expressive queries of large  
 

6.3   Storing and Querying Knowledge Graphs 
135
 
 
Fig. 6.3.1 Sesame architecture 
quantities of RDF and RDFS statements is a demand. Sesame is such an open 
framework meeting that need. The most essential design principle of Sesame is to 
make it extendable and adaptable to different operating environments. That idea 
has been realized in a generic modular architecture that enables Sesame to be in-
stalled on different database management systems (DBMS) and accessed via vari-
ous communication protocols, as shown in Figure 6.3.1 (Kampman, Harmelen and 
Broekstra 2002). 
For achieving it, Sesame’s developers have introduced storage and inference 
layers (SAIL) between upper modules and lower data repositories. They provide a 
set of basic methods for storing, querying, and manipulating RDF data provided, 
while optimized implementation of those methods is handled by a particular 
DBMS in use. In addition to memory and file storage mechanisms, Sesame cur-
rently supports PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 
databases. Moreover, SAILs can also be stacked on top of each other, whence the 
developers can add in new SAILs for supporting further operations such as 
caching, concurrency handling, or inference. 
Since clients can be on very different operational environments such as a Web 
server or a standalone application, Sesame offers a flexible communication 
mechanism. By placing all common communication methods at the module Request 
Router and putting all protocol-specific methods at the protocol handlers, Sesame 
can support different communication protocols such as HTTP, RMI, and SOAP. 
Besides the above-mentioned essential features for storage and communication, 
Sesame also provides modules for querying, administration, security and 
versioning. In brief, it is a generic architecture that can be installed on a variety of 

136 
6   Approximate Knowledge Retrieval
 
different DBMSs, and a good candidate for storing, managing, and retrieving 
large-scale knowledge bases on the Web.   
 
SeRQL 
 
Along with the emergence of the RDF/RDFS standard, several RDF/RDFS query 
languages have been proposed, such as RQL and RDQL. However, they still lack 
a strong path expression ability to simplify query formulation. Sesame provides 
SeRQL (Sesame RDF Query Language) as an RDF/RDFS query language that in-
herits the best features of RQL and RDQL, and equipped with some new features. 
SeRQL also supports subsumption, where a concept or relation type in a query can 
match with its subtypes in a knowledge base. 
The basic building blocks of SeRQL are universal resource identifiers (URI), 
literals, and variables. An URI in Sesame can be written in two formats, either as a 
full URI, e.g., <http://www.cse.hcmut.edu.vn/vnkim/ vnkimkb.rdf#Country_1>, or 
an abbreviated URI, e.g., <vnkimkb_rdf: Country_1>. In this case, the prefix 
vnkimkb_rdf will be mapped to the full string http://www.cse.hcmut.edu.vn/ 
vnkim/vnkimkb.rdf by the Sesame query engine. RDF literals represent properties 
of objects and can be optionally attached with language and data type tags. Vari-
ables are those URIs or properties that are wanted, and identified in queries by 
names. 
All RDF statements in a repository can be regarded as a graph, and searching 
can be performed by matching a query graph, consisting of path expressions, to 
that RDF graph. One outperforming feature of SeRQL as compared to other 
RDF/RDFS query languages is that it allows path expressions of arbitrary length. 
For example, path expressions of length 1 in SeRQL for the query “Find all cities 
in Vietnam” could be as follows:  
 
The second and the fourth path expressions, for instance, can be combined and 
rewritten as the following path expression of length 2: 
{City} vnkimo_rdfs:locatedIn {Country} rdfs:label {“Vietnam”} 
In SeRQL, the nodes and edges in path expressions can be variables, URIs, and 
literals. In this example, City and Country are variables, “Vietnam” is a literal, 
and <vnkimo_rdfs:City> and <vnkimo_rdfs:Country> are URIs. This SeRQL 
query can be illustrated as a graph as shown in Figure 6.3.2. 
 
Fig. 6.3.2 Graph representation of a SeRQL query 
{City} rdf:type {<vnkimo_rdfs:City>}, 
{City} vnkimo_rdfs:locatedIn {Country}, 
{Country} rdf:type {<vnkimo_rdfs:Country>}, 
{Country} rdfs:label {“Vietnam”} 

6.3   Storing and Querying Knowledge Graphs 
137
 
A SeRQL selection query is built up from the four main clauses SELECT, 
FROM, WHERE, and USING NAMESPACE. The SELECT clause is used to de-
termine what variables must be returned and in what order. The FROM clause 
contains path expressions. The WHERE clause expresses constraints on the values 
of variables. Finally, the USING NAMESPACE clause declares namespaces that 
are used for the mapping of abbreviated URIs. 
For example, the full SeRQL query for “Find all cities in Vietnam whose popu-
lation is over one million” is: 
 
SeRQL also provides some short cuts to simplify query formulation. One of 
those short cuts is the notation for branches in path expressions. That is useful for 
the case when one subject has several relations with other objects. Instead of re-
peating the subject for each path expression, those path expressions can share the 
common subject by using a semi-colon. For example, the above path expressions 
could be shortened as follows: 
{City} rdf:type {<vnkimo_rdfs:City>}; vnkimo_rdfs:locatedIn {Country}, 
{Country} rdf:type {<vnkimo_rdfs:Country>}; rdfs:label {“Vietnam”} 
Another useful short cut is for reified statements, where a node is itself a state-
ment. For example, one can have a statement in the form below: 
{ {reifiedSubj} reifiedPred {reifiedObj} } pred {obj} 
This would be equivalent to the following set of path expressions: 
{reifiedStatement} rdf:type {rdf:Statement}, 
{reifiedStatement} rdf:subject {reifiedSubj}, 
{reifiedStatement} rdf:predicate {reifiedPredicate}, 
{reifiedStatement} rdf:object {reifiedObj}, 
{reifiedStatement} pred {obj} 
Finally, it is worth mentioning that property constraints can be combined using 
the logical not, and, or operators in the WHERE clause. That makes SeRQL be an 
expressive query language for RDF knowledge bases, as SQL for relational  
databases. 
SELECT City 
FROM  
{City} rdf:type {<vnkimo_rdfs:City>}, 
{City} vnkimo_rdfs:locatedIn {Country}, 
{City} vnkimo_rdfs:hasPopulation {Population}, 
{Country} rdf:type {<vnkimo_rdfs:Country>}, 
{Country} rdfs:label {“Vietnam”} 
WHERE 
Population > "1000000"^^ <xsd:positiveInteger> 
USING NAMSPACE 
rdf = <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
rdfs = <http://www.w3.org/2000/01/rdf-schema#> 
vnkimo_rdfs = <http://www.cse.hcmut.edu.vn/vnkim/vnkimo-rdf-
schema#>

138 
6   Approximate Knowledge Retrieval
 
6.4   Approximate Knowledge Graph Matching 
Query modification 
As shown above, SeRQL is a powerful query language for RDF graphs, but it is 
still at a low level of abstraction from the RDF syntax, which is rather cumber-
some to non-expert users due to its structure of primitive statement triples and ma-
chine syntactic symbols. Meanwhile, with the graphical knowledge representation 
and smooth mapping with natural language, conceptual graphs are more flexible 
and readable. Therefore, we propose to use non-nested CGs extended with the 
queried referent at the interface layer but, in order to exploit the Sesame infra-
structure, map them to SeRQL for knowledge querying.  
We define a query CG as a non-nested CG whose concept referents can be ei-
ther an individual referent, the generic referent *, or the queried referent denoted 
by ?. The generic referent means that it does not care about a matched individual 
referent. The queried referent represents the referent of an entity in question. Each 
query CG is associated with value constraints on the properties of its concepts. 
As mentioned in the introduction of this chapter, a query CG is first generalized 
by replacing its concept and relation types with their immediate supertypes. This 
generalized query is mapped to an equivalent SeRQL query to retrieve the knowl-
edge graphs that it subsumes, using the Sesame exact matching engine. However, 
such a generalization must conform to the signatures of involved relation types. 
We recall that, if a CG [C1]→(R)→[C2] is well-typed, then so is [C1]→(R')→[C2] for 
any supertype R' of R. 
From this observation, given a query CG, all of its relation types can be re-
placed by their immediate supertypes first. Then for each new relation, its 
neighbor concept types can be replaced by their immediate supertypes iff the re-
sulting CG is still well-typed. However, we note that, if the referent of a concept is 
an individual referent, then its concept type is not changed. For an example, sup-
pose that one wants to find all public companies that are registered in a country of 
North America and have their stock exchange names beginning with “AB”. This 
query can be posed by the query CG G in Figure 6.4.1, which also shows its  
generalized CG G*, where COMPANY, LOCATED-IN, and POLITICAL-REGION are 
immediate supertypes of PUBLIC-COMPANY, REGISTERED-IN, and COUNTRY, re-
spectively. The constraint on stock exchange names is not shown here. 
 
Fig. 6.4.1 A query CG and its generalization 
For attribute values in a query CG, they are first replaced by ? to retrieve corre-
sponding attribute values in answer graphs. Then both entity types and attribute 
values in those answer graphs are matched with the corresponding ones in the 
original query, giving overall matching degrees between the graphs. 

6.4   Approximate Knowledge Graph Matching 
139
 
CG-SeRQL mapping 
The generalized query CG in Figure 6.4.1 can be mapped to the SeRQL query in 
Figure 6.4.2. In this example, the queried concept [COMPANY: ?] is translated into  
the pair of variables (x1, z1) in the SELECT clause of the SeQRL query, where x1 
 
Fig. 6.4.2 An example SeRQL query 
 
Fig. 6.4.3 CG-to-SeQRL pseudocode 

140 
6   Approximate Knowledge Retrieval
 
represents the identifier and z1 represents the label of a result entity. The generic 
concept [POLITICAL-REGION: *] is translated into the variable y1. The individual 
concept referent North America is translated into its identifier. The relations,  
including the implicit properties like label, type, and stockExchangeIndex, in the 
query CG, are translated into RDF statements in the FROM clause. The constraint 
on the stock exchange names is specified in the WHERE clause. Figure 6.4.3 
shows pseudocode of our algorithm to generalize and translate a query CG into its 
equivalent SeRQL clauses. 
Graph matching 
The answer knowledge graphs for a generalized query CG are those that are sub-
sumed by it. They are then matched to the original query CG to compute their 
matching degrees, using the similarity and subsumption measures defined above. 
The similarity/subsumption degree between two knowledge graphs is the average 
of the similarity/subsumption degrees between their matched concepts, relations, 
and attribute values.  
For example, suppose that an answer CG for the generalized query CG in Fig-
ure 6.4.1 is as depicted in Figure 6.4.4, and Pop(PUBLIC-COMPANY) = 5,069,  
Pop(COMPANY) = 7,861, Pop(RIGISTER-IN) = 10,816, Pop(LOCATED-IN) = 14,545. 
Then the similarity degree between the original query CG and the answer CG is 
computed as follows: 
Dist(PUBLIC-COMPANY, COMPANY)  
= − log(Pop(PUBLIC-COMPANY)/Pop(COMPANY)) 
Dist(REGISTERED-IN, LOCATED-IN)  
= − log(Pop(RIGISTERED-IN)/Pop(LOCATED-IN))  
 
SimDegree  
= (Sim(PUBLIC-COMPANY, COMPANY) +  
 Sim(REGISTERED-IN, LOCATED-IN) + 1 + 1 + 1)/5 
 = (0.612 + 0.701 + 1 + 1 + 1)/5 
 = 0.863 
Meanwhile, for the subsumption degree of the original query CG to the answer 
CG, one has: 
DistS(PUBLIC-COMPANY → COMPANY)  
= − log(Pop(PUBLIC-COMPANY)/Pop(COMPANY)) 
DistS(REGISTERED-IN → LOCATED-IN)  
= − log(Pop(RIGISTERED-IN)/Pop(LOCATED-IN))  
 
SubDegree   
= (Sub(PUBLIC-COMPANY → COMPANY) +  
 Sub(REGISTERED-IN → LOCATED-IN) + 1 + 1 + 1)/5 
= (0.612 + 0.701 + 1 + 1 + 1)/5 
= 0.863 
 
 
Fig. 6.4.4 An approximate answer CG 

6.5   Knowledge Management in VN-KIM 
141
 
One can observe that, when t1 is a subtype of t2, then Dist(t1, t2) = DistS(t1 → 
t2), and thus Sim(t1, t2) = Sub(t1 → t2). Now, as shown in Figure 6.4.5, suppose a 
query CG similar to the answer CG in Figure 6.4.3 and an answer CG similar to 
the query CG in Figure 6.4.1, where the concept types COMPANY and PUBLIC-
COMPANY in the query and answer CGs are swapped. Then the similarity between 
the two graphs is still the same as in the above example, but the subsumption de-
gree from the query graph to the answer graph is 1. 
 
Fig. 6.4.5 Another example of query and answer CGs 
6.5   Knowledge Management in VN-KIM  
Ontology and Knowledge Base 
 
In the envisioned Semantic Web not only humans can read and understand web 
pages, but computers can also understand and process them automatically. A clear 
disadvantage of the current Web can be seen in search engines such as Google, 
which often return many useless documents that have nothing to do with what a 
user wants to find. The main reason is that no machine-understandable semantics 
is given to words in documents and queries.  
KIM (Kiryakov et al. 2005) is a platform for Semantic Web. It is firstly a 
knowledge-based system of popular named entities in the world. It can automati-
cally extract the class of a named entity in a web page and annotate that informa-
tion in the web page. Those semantics-enhanced web pages are then stored for  
efficient searching using entity names and their classes. For example, one can 
search for documents about “Washington” as a person, while current search en-
gines may return any document that contains “Washington” though it is the name 
of a press or a university.  
Classes in KIM ontology are grouped into the three upper-level concepts  
Entity, EntitySource, and LexicalResource. Among them, Entity is the most 
important concept and specialized into Object (for people, locations, …),  Hap-
pening (for events, situations, …), and Abstract (for addresses, professions, …). 
The ontology also includes relation types, such as subRegionOf for the class Lo-
cation or hasPosition for the class Person. KIM knowledge base contains de-
scriptions of general important entities such as people, cities, and organizations in 
the world. For storing and managing the ontology and knowledge base, KIM em-
ploys Sesame. Annotated documents are indexed and retrieved using Lucene  
(Gospodnetic 2003), by entity names and classes rather than keywords. KIM in-
formation extraction engine is based on GATE (Cunningham et al. 2002), an  
architecture for developing natural language processing applications. 

142 
6   Approximate Knowledge Retrieval
 
One of the shortcomings of KIM is its usage of fixed patterns for knowledge 
querying. For example, Figure 6.5.1 shows such a pattern to express a query in-
volving three entities, namely X, Y, and Z. In this pattern, one can express a rela-
tion between X and Y, and a relation between Y and Z, and the name and one 
property value restriction for each of the three entities, but no more. 
While KIM query patterns are simple for usage and helpful in some cases, they 
are not sufficient and flexible enough for more expressive queries with an arbi-
trary number of entities involved, multiple relations between them, and several 
property value constraints. On the other hand, SeRQL is much more expressive 
but not easy to use for end-users, who are not familiar to the language syntax.  
 
Fig. 6.5.1 A fixed query pattern in KIM 
We have developed a similar system as KIM, named VN-KIM, but for Viet-
namese language and domain. Currently VN-KIM ontology consists of about 370 
classes and 115 relations. The knowledge base contains more than 210,000 se-
lected named entities in Vietnam and the world. VN-KIM employs CGs for ex-
pressive and user-friendly knowledge querying at the user-interface. Below, we 
present VN-KIM query editor and answering mechanism. 
 
Query Editor 
 
VN-KIM query editor allows a user to pose queries in fixed patterns, CGs, or 
SeRQL clauses. It provides drawing tools for editing query CGs with respect to its 
ontology and knowledge base. Concept editing is assisted by browsing the concept 
type hierarchy and existing entities of a particular concept type. The relation type 
hierarchy can also be browsed for relation editing, and consistency of a relation  
 

6.5   Knowledge Management in VN-KIM 
143
 
 
Fig. 6.5.2 Editing a query CG 
 
Fig. 6.5.3 Generated SeRQL clauses and query results 
and its neighbouring concepts in a CG is checked after the CG is drawn. Condi-
tions on properties values of an entity can be expressed using the constraint  
relations of the value domains as specified in the ontology. Query CGs are  
then mapped into SeRQL clauses as presented above for knowledge and document 
retrieval. 
The query editor is also equipped with functions for saving a query CG to an 
XML file, and loading a query CG from an XML file. The XML file contains both 
the logical and graphical information of each element in the query graph. The 
logical properties of one element are its category (i.e., concept, relation, or edge) 

144 
6   Approximate Knowledge Retrieval
 
and other specific properties (e.g. the type and referent of a concept element). The 
graphical properties such as positions and colours are used for displaying the 
graph.  
For instance, the example query in Figure 6.4.1 can be posed by the CG edited 
using VN-KIM query editor as shown in Figure 6.5.2, together with assisting 
commands and information. The equivalent SeRQL clauses and results of the gen-
eralized query are presented in Figure 6.5.3. Their matching degrees with the 
original query are evaluated using the defined similarity and subsumption meas-
ures. For readability, we have run the example on KIM ontology and knowledge 
base, which uses English terms. 
6.6   Summary 
Previous definitions of semantic distance are for words on the basis of their actual 
occurrence or semantics, and thus do not work for un-interpreted concept and rela-
tion type labels. In this chapter, a population-based measure is proposed as a solu-
tion, whereby the occurrence probability of a type label is computed as that of its 
entities in a knowledge base of discourse. For fuzzy set-based attribute values, 
fuzzy conditional probability is used instead. The Jiang-Conrath method is 
adapted accordingly for measuring the similarity between two knowledge graphs. 
In contrast to those similarity measures, which are symmetric, an asymmetric 
subsumption measure for both entity types and attribute values is additionally de-
fined, also in the probabilistic framework of Jiang-Conrath’s semantic distance. 
This way provides a basis to combine subsumption degrees between entity types 
and attribute values of two knowledge graphs, defining an overall subsumption 
degree between the graphs that measures how much the query graph subsumes the 
answer graph. 
In realization of an approximate knowledge graph retrieval system, the exact 
query engine of Sesame with its query language SeRQL is employed. A query 
graph is first generalized by replacing its concept and relation types with their 
immediate supertypes, conforming to the signatures of the relation types. The an-
swer graphs that are subsumed by the generalized query graph are then matched to 
the original query graph to measure their similarity and subsumption degrees. For 
a user-friendly query interface, conceptual graphs are used for query expressions 
and automatically mapped to SeRQL clauses to be executed on the Sesame  
platform. 
Still, for non-expert end-users, conceptual graphs are not as easy to use as natural 
language to input queries. The next chapter presents a robust ontology-based method 
to understand and convert natural language queries to conceptual graphs, which are 
used as an interlingua that can be mapped to other formal representations. 

T.H. Cao: Conceptual Graphs and Fuzzy Logic, SCI 306, pp. 145–166. 
springerlink.com                  © Springer-Verlag Berlin Heidelberg 2010 
Chapter 7 
Natural Language Query Understanding 
7.1   Overview 
A natural language interface is always desirable for question answering and in-
formation retrieval systems (Ogden and Bernick 1997). Using a controlled lan-
guage for the interface could ease the problem but still tights users to a restricted 
grammar (Nyberg and Mitamura 1996; Nelken and Francez 2000). Although per-
formance of machine natural language understanding for the general case appears 
to be saturated after many years of research, limiting the domain of discourse to 
only questions and querying phrases can make a difference.  
In particular, users often want to search for documents about named entities 
(NE), i.e., those that are referred to by names (Sekine 2004), such as people, or-
ganizations, and locations. An example query is to search for documents about 
“economic growth of countries in East Asia”, where “countries in East Asia” 
represents named entities while “economic” and “growth” are keywords. Relevant 
answer documents include those about economic growth in certain countries like 
China, Japan, and Korea. Searching purely based on keywords fails to find such 
documents, because it does not recognize the named entities implied in the query. 
For answering queries containing named entity phrases, a system needs to convert 
those human language phrases to more formal representations, in order to extract 
such latent semantics from an ontology of discourse. There are different ap-
proaches to query conversion regarding the two following issues.  
First, it is about whether rigorous syntactic parsing is applied to a query expres-
sion before it is mapped to a target language sentence. The disadvantages of the 
parsing approach are time consuming and requiring grammatically correct inputs, 
which is thus not robust to ill-formed queries. It is also not practical to require a 
user to always input a question without grammatical errors. Moreover, it may still 
face to the problem of syntactic ambiguity, i.e., one sentence having more than 
one applicable syntax tree.  
Second, it is about whether an ontology is employed in the mapping. For  
example, with the query “What county is Modesto, California in?”, given no  
ontology, Modesto and California can be tagged only as proper nouns and thus the 
implicit relation expressed by the comma between them cannot be interpreted. In 
contrast, with an ontology, they can be recognized as named entities of the types 
(or classes) City and Province, respectively, whence the relation can be mapped to 
one being a sub-region of the other. 
For instance, Lei, Uren and Motta (2006) implemented an ontology-based 
search system whose queries were lists of classes and instances and converted into 

146 
7   Natural Language Query Understanding
 
expressions of SeRQL. They were better than lists of normal keywords, but not as 
natural as human expressions.  Meanwhile, accepting natural language queries, 
Cimiano, Haase and Heizmann (2007) followed the rigorous parsing approach us-
ing lambda calculus as an intermediate formal language for the conversion. How-
ever, the focus of that work was on efficient porting interfaces between different 
domains rather on the language conversion itself.  
The approach in Kaufmann, Bernstein and Fischer (2007) could be considered 
as closer to the syntax-free one. It used pattern matching of a natural language 
query to subject-property-object triples in a knowledge base, before converting the 
query to one of SPARQL. For the example query therein “What is a restaurant in 
San Francisco that serves good French food?”, it first searched for those triples 
whose subjects, properties, and objects could match with “restaurant”, “in”, and 
“San Francisco”. That method thus could not produce a mapping if the ontology 
did not contain such a triple for the named entity San Francisco, which existed in 
the ontology though. Recently, Tablan, Damljanovic and Bontcheva (2008) also 
followed the syntax-free approach to convert natural language queries into SeRQL 
expressions.  
Since the root of the difficulty of machine natural language understanding is the 
big gap between natural language and a machine executable one, using a higher 
level language like SeRQL or CGs as an intermediate is a way to ease the prob-
lem. However, SeRQL is still far from natural language due to its RDF primitive 
triple structure, which breaks knowledge representation into too small granules. 
We choose CGs because they could be mapped smoothly to and from natural lan-
guage, and used as an interlingua for conversion to and from other formal lan-
guages (Sowa 1997). There was research on automatic generation of CGs from 
natural language texts in a specific domain, e.g. the machine learning-based one in 
Zhang and Yu (2001) and the rule-based method in Hensman and Dunnion (2004). 
However, both of the works required syntactic parsing of input sentences and were 
evaluated mainly on semantic roles rather than whole sentences.  
This chapter presents the method for mapping natural language queries to con-
ceptual graphs initially proposed in Cao, Cao and Tran (2008) for simple queries 
and extended in Cao and Anh (2010) for complex queries. It does not require and 
rely on a strict grammar of querying phrases or sentences, but does use an ontol-
ogy for the conversion. Firstly, Section 7.2 introduces the adapted vector space 
models developed in Cao, Le and Ngo (2008) for ontology-based information re-
trieval. Section 7.3 defines nested query CGs to represent connective, superlative, 
and counting queries. Section 7.4 presents in detail the proposed ontology-based 
method for converting queries in natural language to conceptual graphs. Section 
7.5 presents VN-KIM search engine using the developed ontology-based informa-
tion retrieval models and query processing method. Finally, Section 7.6 concludes 
the chapter.  
7.2   Ontology-Based Information Retrieval 
Despite having known disadvantages, the Vector Space Model (VSM) is still  
a popular model and a basis to develop other models for information retrieval,  

7.2   Ontology-Based Information Retrieval 
147
 
because it is simple, fast, and its ranking method is in general as good as a large 
variety of alternatives (Baeza-Yates and Ribeiro-Neto 1999; Manning, Raghavan 
and Schütze 2008). We recall that, in the keyword-based VSM, each document is 
represented by a vector over the space of keywords of discourse. Conventionally, 
as presented in Section 6.2, the weight corresponding to a term dimension of the 
vector is a function of the occurrence frequency of that term in the document, 
called tf, and the inverse occurrence frequency of the term across all the existing 
documents, called idf. The similarity degree between a document and a query is 
then defined as the cosine of their representing vectors. 
As a matter of fact, with terms being only keywords, the traditional VSM can-
not satisfactorily represent the semantics of texts with respect to the named entities 
they contain, such as for the following queries: 
Q1: Search for documents about Georgia. 
Q2: Search for documents about companies. 
Q3: Search for documents about locations named Washington. 
Q4: Search for documents about Moscow, Russia. 
Query Q1 is to search for documents about any entity named Georgia, and cor-
rect answers include those about the state Georgia of the USA or the country 
Georgia next to Russia. However, documents about Gruzia are also relevant  
because Gruzia is another name of the country Georgia, which simple keyword-
matching search engines miss. For query Q2, a target document does not necessar-
ily contain the keyword company, but only some named entities of the class  
Company, i.e., real commercial organizations in the world. For query Q3, correct 
answers are documents about the state Washington or the capital Washington  
of the USA, which are locations, but not those about people like President  
Washington. Meanwhile, query Q4 targets at documents about a precisely identi-
fied named entity, i.e., the capital Moscow of Russia, not other cities also named 
Moscow elsewhere.  
For formally representing documents (and queries) by named entity features, 
we define the triple (N, C, I) where N, C, and I are respectively the sets of names, 
classes, and identifiers of named entities in the ontology of discourse. Then: 
1. Each document d is modeled as a subset of (N∪{*})×(C∪{*})× (I∪{*}), 
where * denotes an unspecified name, class, or identifier of a named entity 
in d, and 
2. d is represented by the quadruple (
N
d
G
, 
C
d
G
, 
NC
d
G
, 
Id
G
), where 
N
d
G
, 
C
d
G
, 
NC
d
G
, 
and 
Id
G
are respectively vectors over N, C, N×C, and I.
 
A feature of a named entity could be unspecified due to the user intention ex-
pressed in a query, the incomplete information about that named entity in a docu-
ment, or the inability of an employed NE recognition engine to fully recognize it. 
Each of the four component vectors introduced above for a document is defined as 
a vector with the TF-IDF weighting scheme, on the corresponding space of entity 
names, classes, name-class pairs, or identifiers, instead of keywords.  However, 
there are two following important differences with those ontological features of 
named entities in calculation of their frequencies: 

148 
7   Natural Language Query Understanding
 
1. The frequency of a name also counts identical entity aliases. That is, if a 
document contains an entity having an alias identical to that name, then it is 
assumed as if the name occurred in the document. For example, if a docu-
ment refers to the country Georgia, then each occurrence of that entity in 
the document is counted as one occurrence of the name Gruzia, because it 
is an alias of Georgia. Named entity aliases are specified in the knowledge 
base of discourse. 
2. The frequency of a class also counts occurrences of its subclasses. That is, 
if a document contains an entity whose class is a subclass of that class, then 
it is assumed as if the class occurred in the document. For example, if a 
document refers to Washington DC, then each occurrence of that entity in 
the document is counted as one occurrence of the class Location, because 
City is a subclass of Location. The class subsumption is defined by the class 
hierarchy of the ontology of discourse. 
The similarity degree of a document d and a query q is then defined to be, 
where wN + wC + wNC + wI = 1:  
        sim(d
G
,qG )  
= wN.cosine(
N
d
G
,
N
qG ) + wC.cosine(
C
d
G
,
C
qG ) + wNC.cosine(
NC
d
G
,
NC
qG
) + 
wI.cosine(
Id
G
,
IqG )                                                                        (Eq. 7.2.1) 
We deliberately leave the weights in the sum unspecified, to be flexibly ad-
justed in applications, depending on user-defined relative significances of the four 
ontological features. We note that the join of 
N
d
G
 and 
C
d
G
 cannot replace 
NC
d
G
 be-
cause the latter is concerned with entities of certain name-class pairs. Meanwhile, 
NC
d
G
 cannot replace 
Id
G
 because there may be different entities of the same name 
and class (e.g. there are different cities named Moscow in the world). Also, since 
names and classes of an entity are derivable from its identifier, products of I with 
N or C are not included.  
In brief, here we generalize the notion of terms being keywords in the tradi-
tional VSM to be entity names, classes, name-class pairs, or identifiers, and use 
four vectors on those spaces to represent a document or a query for text retrieval. 
Figure 7.2.1 shows a query in the TIME test collection available with Buckley 
(1985) and its corresponding set of ontological terms, where InternationalOrgani-
zation_T.17 is the identifier of United Nations in the knowledge base of discourse. 
Clearly, named entities alone are not adequate to represent a text. For example, 
in the query in Figure 7.2.1, joined is a keyword to be taken into account, and so 
are Countries and United Nations, which can be concurrently treated as both key-
words and named entities. Therefore, a document can be represented by one vector 
on keywords and four vectors on ontological terms. The similarity degree of a 
document d and a query q is then defined as follows, where wN + wC + wNC + wI = 
1, α∈[0, 1], and
KW
d
G
 and
KW
qG
 are respectively the vectors representing the keyword 
features of d and q: 
 

7.2   Ontology-Based Information Retrieval 
149
 
sim(d
G
,qG )  
= α.[wN.cosine(
N
d
G
,
N
qG ) + wC.cosine(
C
d
G
,
C
qG ) + wNC.cosine(
NC
d
G
,
NC
qG
) +  
 wI.cosine(
Id
G
,
IqG )] + (1 – α).cosine(
KW
d
G
,
KW
qG
)                           
(Eq. 7.2.2) 
 
Fig. 7.2.1 Ontological terms extracted from a query 
Furthermore, we explore another adapted VSM that combines keywords and 
named entities. That is we unify and treat all of them as generalized terms, where 
a term is counted either as a keyword or a named entity but not both. Each docu-
ment is then represented by a single vector over that generalized term space. 
Document vector representation and ranking are performed as in the traditional 
VSM, except for taking into account entity aliases and class subsumption as pre-
sented above. Figure 7.2.2 shows another query in the TIME test collection and its 
corresponding key term sets for the multi-vector model and the generalized term 
model. 
 
Fig. 7.2.2 Keywords, ontological terms, and generalized terms extracted from a query 
The architecture of an ontology-based text retrieval system is shown in Figure 
7.2.3. It contains an ontology and knowledge base of named entities in a world of 
discourse. The NE Recognition module extracts and embeds information about 
named entities in a raw text, before it is indexed by both named entities and key-
words and stored in the NE-Annotated Text Repository. Users can search for 
documents about named entities of interest via the Ontology-Based Text Retrieval 
module. 
We have implemented the above-adapted VSMs by employing and modifying 
Lucene (Gospodnetic 2003), a general open source for storing, indexing and  
 

150 
7   Natural Language Query Understanding
 
 
Fig. 7.2.3 System architecture for ontology-based text retrieval 
searching documents. In fact, Lucene uses the VSM with a tweak on the document 
magnitude term in the cosine similarity formula for a query and a document. In 
Lucene, a term is a character string and term occurrence frequency is computed by 
exact string matching, after keyword stemming and stop-word removal. Here are 
our modifications for what we call S-Lucene: 
1. Indexing documents over the four ontological spaces corresponding to N, 
C, N×C, and I, and the generalized term space, besides the ordinary key-
word space, to support the new models. 
2. Modifying Lucene codes to compute dimensional weights for the vectors rep-
resenting a document or a query, in accordance to each of the new models. 
3. Modifying Lucene codes to compute the similarity degree between a docu-
ment and a query, in accordance to each of the new models. 
Each document is automatically processed, annotated, and indexed as follows: 
1. Stop-words in the document are removed using a built-in function in Lu-
cene. 
2. The document is annotated with the named entities recognized by an em-
ployed NE recognition engine. For the multi-vector model, recognized 
entity names are also counted as keywords, but not for the generalized term 
model. 
3. Taking into account entity aliases and class subsumption, a document is ex-
tended with respect to each entity named n possibly with class c and identi-
fier id in the document as follows: 
- 
For the multi-vector model, the values n, c, (n, c), alias(n), super(c), (n, 
super(c)), (alias(n), c), (alias(n), super(c)), and id are added for the 
document. 
- 
For the generalized term model, the triples (n/*/*), (*/c/*), (n/c/*), 
(alias(n)/*/*), (*/super(c)/*), (n/super(c)/*), (alias(n)/c/*), (alias(n)/ 
super(c)/*), and (*/*/id) are added for the document. 
4. The extracted keywords, named entity values and triples in the document 
are indexed using S-Lucene. 

7.3   Nested Query Conceptual Graphs 
151
 
Here alias(n) and super(c) respectively denote any alias of n and any super class 
of c in the ontology and knowledge base of discourse. For super(c), we exclude 
the top-level classes, e.g. Entity, Object, Happening, Abstract, because they are 
too general and could match to many named entities. 
For each query, after stop-word removal and NE recognition and annotation, it 
is processed further by the following steps: 
1. Each recognized entity named n possible with class c and identifier id is 
represented by one or more named entity triples as follows: 
- 
For the multi-vector model, the most specific named entity annotation 
is used. We note that id is more specific than (n, c), which is more 
specific than both c and n. 
- 
For the generalized term model, the most specific and available triple 
among (n/*/*), (*/c/*), (n/c/*), and (*/*/id) is used for the query. 
2. The interrogative word Who, What, Which, When, Where, or How, if exists 
in the query, is mapped to an unspecified named entity of an appropriate 
class. For example, in the query “What state does Charles Robb repre-
sent?”, What state is counted as a named entity of the class Province that 
can match to named entities of the same class or its subclasses in a  
document 
 
The experiments carried out in Cao, Le and Ngo (2008) show that the multi-
vector and generalized term models outperform the purely keyword-based and 
NE-based models. On one hand, the generalized term model is straightforward and 
simple, unifying keywords and named entities as generalized terms. On the other 
hand, the multi-vector model is useful for clustering documents into a hierarchy 
via top-down phases each of which uses one of the four NE-based vectors or the 
keyword-based vector presented above (Cao et al. 2008). For example, given a set 
of geographical documents, one can first cluster them into groups of documents 
about rivers and mountains, i.e., clustering with respect to entity classes. Then, the 
documents in the river group can be clustered further into subgroups each of 
which is about a particular river, i.e., clustering with respect to entity identifiers. 
As another example of combination of clustering objectives, one can first make a 
group of documents about entities named Saigon, by clustering them with respect 
to entity names. Then, the documents within this group can be clustered further 
into subgroups for Saigon City, Saigon River, and Saigon Market, for instance, by 
clustering them with respect to entity classes. Another advantage of splitting 
document representation into multi-component vectors is that, searching and 
matching need to be performed only for those components that are relevant to a 
certain query. 
7.3   Nested Query Conceptual Graphs 
Nested conceptual graphs were early introduced in Sowa (1984) as mentioned in 
Section 2.2. However, research on formalizing and using nested CGs for querying 
databases or knowledge bases appears sporadic. In CoGITaNT (Genest and Salvat 
1998) and CGWorld (Dobrev and Toutanova 2002), nested CGs were used for 

152 
7   Natural Language Query Understanding
 
representing nested properties of queried entities, rather than subqueries as in 
SQL. Meanwhile, based on concept graphs, a variation of conceptual graphs, Dau 
and Correia (2003) formulated nested concept graphs to be as expressive as SQL. 
Basically, each record of a relational database table was represented by a relation 
vertex whose label is the name of the table, each attribute value of the record was 
represented by a neighbor concept vertex of that relation vertex, and the edge con-
necting that relation vertex and that neighbor concept vertex was labeled by the 
name of the corresponding attribute. 
In contrast, here we define nested conventional conceptual graphs for querying 
knowledge bases that correspond to ones like SQL subqueries for querying rela-
tional databases with aggregation functions, e.g. COUNT, MAX and MIN, and Boo-
lean operators, e.g. AND and OR. A query can be seen as expressing constraints in 
terms of relations between the queried entities and the known ones. In Section 6.3, 
using CGs for knowledge retrieval, besides individual referents and the generic 
referent *, we already extend them with the queried referent ?, representing the 
named entities to be searched for. The generic referent in a query CG means that it 
does not care about a matched entity. Next is a further extension with nested CGs 
for representing more complex queries in natural language. 
 
Representing connective queries  
 
In the extended CG query language, a natural language connective like “and” or 
“or” in a query is represented by a meta-relation, labeled by AND or OR respec-
tively, connecting the nested query CGs that represent enclosed elementary que-
ries. For example, Figure 7.3.1 is the query CG for “What international leaders 
sent or gave congratulations?”, where the dashed line is a coreference link denot-
ing that the two linked concepts refer to the same entity. They correspond to sub-
queries with Boolean operators in SQL. 
 
Fig. 7.3.1 The nested CG for a connective query 
Representing superlative queries 
 
There are queries that search for entities with the highest or lowest degree of a 
particular property, e.g. “What’s the tallest building in New York City?”. For such  
 

7.3   Nested Query Conceptual Graphs 
153
 
 
Fig. 7.3.2 The nested CG for a superlative query 
a query, the trivial case is that the tallest building is explicitly identified in the 
knowledge base of discourse. However, it is often that only the height of each 
building is recorded. Therefore, answering such a query actually requires search-
ing for all the entities that satisfy the constraints in the query, and then selecting 
the one with the highest or lowest degree of the specified property. 
In the extended CG query language, such a query is represented by a meta-
relation, labeled by MAX or MIN depending on the highest or lowest objective, at-
tached to the nested CG representing the query constraints. Figure 7.3.2 illustrates 
the nested CG for this example query. The double line specifies the concept repre-
senting the property to be with the highest or lowest degree. They correspond to 
SQL subqueries using the aggregation MAX and MIN functions. 
 
Representing counting queries 
 
Answering to a query “How many” may require counting the number of entities 
that satisfy the constraints specified in the query, when the sum is not trivially re-
corded in the knowledge base of discourse. In the extended CG query language, 
such a query is represented by a meta-relation, labeled by COUNT, attached to the 
nested CG representing the query constraints. Figure 7.3.3 illustrates the nested 
CG for the query “How many languages has “Harry Potter and the Goblet of 
Fire” been translated to?”. The double line specifies the concept representing the 
entities to be counted. They correspond to subqueries using the aggregation 
COUNT function in SQL. 
Generated (nested) query CGs can then be executed to retrieve knowledge di-
rectly on a CG knowledge base management system whose instances are stored as 
plain CGs. Alternatively, for RDF knowledge bases, they can be automatically 
converted to clauses of a query language like SeRQL to be executed on Sesame 
for instance. 
 
 
Fig. 7.3.3 The nested CG for a counting query 

154 
7   Natural Language Query Understanding
 
7.4   Ontology-Based Query Understanding 
Our method views a query as a sequence of entities and relations. The problem is 
then to determine which relation R links which entities E’s, as illustrated in Figure 
7.4.1. Valid relations between entities are actually constrained by an ontology of 
discourse. So the linking task does not depend much on the relative positions of 
the relations and entities in a query, and thus can accept ill-formed queries.  
 
Fig. 7.4.1 A syntax-free view of a natural language query 
Therefore, the main focus is only to correctly recognize entities and determine 
their relations expressed by a query. The method composes of the following 
twelve steps as depicted in Figure 7.4.2. Details of these steps are presented next. 
 
Recognizing specified entities 
 
This step recognizes entities specified by names in a query. For instance, in the 
query “What is the capital of Mongolia?”, Mongolia is a specified entity. There 
are various tools with respective ontologies and KBs that can be used for NE rec-
ognition, such as GATE, KIM, SemTag (Dill et al. 2003), ESPotter (Zhu, Uren 
and Motta 2005). Obviously, the performance of any system relying on named 
entities to solve a particular problem incurs errors of the NE recognition tool  
employed. However, in research for models or methods, the two problems  
should be separated. This work is not about NE recognition and we use GATE’s 
semantic annotation tool OCAT and KIM’s PROTON ontology and World KB 
for experiments. 
 
Recognizing unspecified entities 
 
Unspecified entities are those that are not expressed by names, but only by words 
expressing their types. For instance, in the example query “How many counties 
are in Indiana?”, “counties” represents unspecified entities of the type COUNTY. 
For recognizing unspecified entities, we employ the ANNIE tool of GATE for this 
task by building a gazetteer of phrases and their corresponding entity types in the 
ontology of discourse.   
 

7.4   Ontology-Based Query Understanding 
155
 
 
Fig. 7.4.2 The twelve steps for ontology-based query understanding 
Extracting relational phrases 
 
This step finds out the phrases that represent relations between the entities in a 
query. For example, in the query “What state is Niagara Falls located in?”, “lo-
cated in” is a phrase representing a relation between Niagara Falls and a state, 
which is the queried entity. Words or phrases expressing relations between entities 
are propositional and verbal ones like “in”, “on”, “of”, “born”, “has”, “is”, “lo-
cated in”, etc. They can also be extracted by ANNIE based on a gazetteer of 
phrases and their possible corresponding relation types in the ontology of dis-
course. For example, “publish” in a question can be mapped to the relation type  
 
1. Recognizing specified entities 
2. Recognizing unspecified entities 
3. Extracting relational phrases 
4. Extracting adjectives 
5. Splitting a connective query 
6. Determining the type of queried entities 
7. Unifying identical entities 
8. Discovering implicit relations 
9. Determining the types of relations 
10. Removing improper relations 
11. Modifying concepts with adjectives 
12. Constructing the final CG 
Natural language query 
Query conceptual graph 

156 
7   Natural Language Query Understanding
 
DATEPUBLISH or HASPUBLISHER, and the suitable one depends on whether the 
question is about time (e.g. “When was the first Wall Street Journal published?”) 
or not (e.g. “What company published Jasper Fforde’s first book?”).  
 
Extracting adjectives 
 
This step recognizes adjectives (e.g. “famous”, “beautiful”, “high”, “long”, …) 
and their superlative forms (e.g. “most famous”, “most beautiful”, “highest”, 
“longest”, …) in a query. Those adjectives modify the unspecified entities they are 
associated with. The adjective associated with the noun representing an unspeci-
fied entity describes either a property of the entity or a more specific type for that 
entity than the type expressed by the noun. For example, Figure 7.4.3 shows these 
two ways of representation of the query “What famous model was married to Billy 
Joel?” in CGs. In the first CG G, “famous model” is mapped to the property 
HASFAME whose domain type is MODEL and range type is FAMOUSNESS, where 
famous is linguistic label that could be defined by a fuzzy set. In the second CG H, 
it is mapped to the concept of the type FAMOUSMODEL, which is a subtype of 
MODEL, defining the class of models who are considered as famous.  
 
 
Fig. 7.4.3 Alternative representations of adjectives modifying unspecified entities 
The first way would involve matching and computation with linguistic labels 
later on. Meanwhile the second way would create various subtypes for different 
degrees on the adjective scale. A choice depends on a consistent design of the 
whole ontology right at the beginning. In general, one can build a gazetteer of ad-
jectives and their corresponding properties or entity types, and employ ANNIE to 
extract them from a query. 
 
Splitting a connective query 
 
In the spirit of the syntax-free approach, our assumption here is that users do not 
pose too complicated queries that are even obscure to human understanding. In 
particular, normally users do not use natural language connectives like “and” and 
“or” with arbitrary possible structures as for logical connectives. So, in our 
method, splitting a connective query is based on the normal patterns and their 
elementary queries shown in Table 7.4.1, where Ei’s and Rj’s represent entities and 
relations, respectively. The remaining steps below are applied to each elementary 
query. 

7.4   Ontology-Based Query Understanding 
157
 
Table 7.4.1 Normal connective query patterns and their elementary queries 
Query Patterns 
Elementary Queries  
E0 R1 E1  and/or  R2 E2 
E0 R1 E1  and/or  E0 R2 E2 
E1  and/or  E2 R0 E3 
E1 R0 E3  and/or  E2 R0 E3 
E1 R0 E2  and/or  E3 
E1 R0 E2  and/or  E1 R0 E3 
E1 R1  and/or  R2 E2 
E1 R1 E2  and/or  E1 R2 E2 
 
Determining the type of queried entities 
 
The type of the entity represented by the interrogative word What (or Which) is 
determined by the following rules: 
1.  If What is followed by an entity type, then the type of the queried entity is 
that entity type. For example, in the query “What province is Montreal in?”, 
the word “province” specifies that the type of the queried entity is PROVINCE 
in the ontology of discourse. 
2. Otherwise, the type is determined by the first NE after What and the rela-
tional phrase at the end of the query. For example, in the query “What  
does Knight Ridder publish?”, Knight Ridder is recognized as a company 
and the word “publish” entails that the queried entity is of the type 
PUBLISHEDMATERIAL. 
The interrogative word Who may represent either a person or an organization. 
For example, in the query “Who wrote the book Huckleberry Finn?”, it represents 
a person. However, in the query “Who provides telephone service in Orange 
County, California?”, it means an organization. The appropriate entity type is de-
termined on the basis of the involved relational phrases (e.g. “wrote” or “pro-
vides” in these examples) and the types of the entities after them (e.g. the book 
“Huckleberry Finn” or the service “telephone”). 
Questions with the interrogative word How has three typical patterns: 
1.  The first one is with an adjective to ask about a certain property of an entity. 
An example query of this pattern is “How tall is the Sears Building?”. Val-
ues of such properties are often represented by strings of the type STRING in 
an ontology like PROTON. In this example, the adjective is mapped to the 
corresponding property type HASHEIGHT. 
2. The second pattern is “How much” followed by an entity type, e.g. “How 
much oil was spilled by the Exxon tanker Valdez?”, or with “cost” at the end of 
the query, e.g. “How much does an American Girl doll cost?”. For the first 
case, “How much oil” is mapped to the oil spilling property and, for the second 
case, “How much” is mapped to the cost property of the mentioned entity. 
3. The third pattern is “How many” followed by an entity type, e.g. “How many 
counties are in Indiana?”. Such a query is mapped to a nested CG with the 
meta-relation COUNT as presented in Section 2. One exception is queries ask-
ing about the population of a country, e.g. “How many people live in 
Chile?”, which is mapped to the property type POPULATIONCOUNT. 

158 
7   Natural Language Query Understanding
 
Time is also often represented by strings in databases and knowledge bases. So, 
the interrogative word When in a query is mapped to a concept of the type STRING. 
For example, the signature of the relation type ESTABLISHMENTDATE is 
(ORGANIZATION, STRING). 
 
Unifying identical entities 
 
Two entities are considered as identical and unified under the following condi-
tions: 
1.  One of them is an unspecified entity, and 
2. The type of the unspecified entity is the same as, or a super-type of, the other 
entity, and 
3. Between the two entities is the verb “be” in a particular form and tense such 
as “is”, “are”, “was”, “were”, etc. 
For example, in the query “Who is the president of Bolivia?”, Who represents 
an unspecified entity of the type PERSON and “president” represents an entity of 
the type PRESIDENT, which is a subtype of PERSON. There is the relational word 
“is” between the two entities, so they are identical and can be unified. 
 
Discovering implicit relations 
 
If two entities are next to each other or separated by a comma, then there is an im-
plicit relation between them. That relation is determined by the types of the enti-
ties and the relation types permitted for those two entity types in the ontology of 
discourse. For example, in the query “In which US states has Barack Obama 
lived?”, the type of US is COUNTRY and that of the unspecified entities represented 
by “states” is PROVINCE. Therefore, the appropriate type of the implicit relation 
between them is SUBREGIONOF. 
 
Determining the types of relations 
 
After the previous steps, the specified entities, unspecified entities, and relational 
phrases in a query are already recognized. The remaining task is to determine 
which relational phrase is between which two of the entities and what is the type 
of that relation. First, we present our approach to determine the appropriate rela-
tion type for a certain relational phrase in a query, with respect to the ontology of 
discourse. Let PR be the relational phrase representing the relation between two en-
tities of the types C1 and C2, and S1 and S2 be the original strings representing the 
two entities. We define the following sets of possible relation types: 
1. R1 is the set of possible relation types that correspond to PR in the built-in 
gazetteer of relational phrases. For example, if PR = “publish”, then R1 in-
cludes DATEPUBLISH and HASPUBLISHER. 

7.4   Ontology-Based Query Understanding 
159
 
2. R2 is the set of possible relation types between the entity types C1 and C2 as 
given in the ontology of discourse. For example, if C1 = ORGANIZATION and 
C2 = PERSON, then R2 includes HASEMPLOYEE and HASFOUNDER. 
3. R3 is the set of possible relation types with respect to S1 and PR. For example, 
in the query “Who is the founder of the Wal-Mart stores?”, S1 = “founder” 
and PR = “of”, which derives HASFOUNDER as a possible relation type be-
tween Wal-Mart stores and the queried entity. 
4. R4 is the set of possible relation types with respect to PR and S2. For example, 
in the query “Who was Charles Lindbergh’s wife?”, PR = “’s” and S2 = 
“wife”, which derives HASWIFE as a possible relation type between Charles 
Lindbergh and the queried entity.  
The suitable relation types are then constrained within R1∩R2∩R3∩R4. For effi-
ciency, we incorporate and encode all of these constraints into rules mapping rela-
tional phrases to suitable relation types in the ontology of discourse. 
Second, we note that the phrase representing the relation between two entities 
can stand in different positions relative to those of the entities: 
1.  In the middle: for example, in the query “Where is the location of the Or-
ange Bowl?”, the relational word “of” is in the middle of the two entities 
represented by “location” and “Orange Bowl”.  
2. After: for example, in the query “What state is the Filenes store located in?”, 
the relational word “located in” is after the second entity represented by “Fi-
lenes store”.  
3. Before: for example, in the query “In what country is Angkor Wat?”, the re-
lational word “in” is before the first entity represented by “country”.  
Therefore, for each pair of entities in a query, it is first checked if the relational 
phrase in the middle forms a proper relation between the two entities. If not, the 
relational phrases after and before the two entities are further checked.  
 
Removing improper relations 
 
Let E1, E2, …, and EN be the entities occurring in the left-to-right order in a query. 
We propose the following heuristic rules to remove improper relations extracted in 
the previous steps: 
1.  If Ei and Ei+1 (1 ≤ i ≤ N−1) are next to each other, then Ei has only a relation 
with Ei+1, and all relations if assigned to Ei and other entities will be re-
moved. For example, in the query “In which US states has Barack Obama 
lived?” (E1 = “US”, E2 = “states”, E3 = “Barack Obama”), there are three fol-
lowing possible relations extracted in the previous steps:  
[PROVINCE: ?x]→(SUBREGIONOF)→[COUNTRY: US] 
[PERSON: Barack Obama]→(LIVEIN)→[PROVINCE: ?x] 
[PERSON: Barack Obama]→(LIVEIN)→[COUNTRY: US] 
but the last one is to be removed. 

160 
7   Natural Language Query Understanding
 
2.  If Ei and Ei+1 (1 ≤ i ≤ N−1) are separated by a comma, then Ei+1 has only a re-
lation with Ei, and all relations if assigned to Ei+1 and other entities will be 
removed. For example, in the query “Who provides telephone service in Or-
ange County, California?” (E1 = “Who”, E2 = “telephone service”, E3 = “Or-
ange County”, E4 = “California”), there are four following possible relations 
extracted in the previous steps:  
[COUNTY: Orange]→(SUBREGIONOF)→[PROVINCE: California]  
[TELEPHONESERVICE: *x]→(HASPROVIDER)→[COMPANY: ?] 
[TELEPHONESERVICE: *x]→(LOCATEDIN)→[COUNTY: Orange] 
[TELEPHONESERVICE: *x]→(LOCATEDIN)→[PROVINCE: California]  
but the last one is to be removed. 
3. If there is the relational symbol “’s” between Ei and Ei+1 (1 ≤ i ≤ N−1), then 
Ei has only a relation with Ei+1, and all relations if assigned to Ei and other 
entities will be removed. For example, in the query “What is the name of 
Neil Armstrong’s wife?” (E1 = “name”, E2 = “Neil Armstrong”, E3 = “wife”), 
there are three following possible relations extracted in the previous steps:   
[MAN: Armstrong]→(HASWIFE)→[WOMAN: *x] 
[WOMAN: *x]→(HASALIAS)→[ALIAS: ?y]    
[MAN: Armstrong]→(HASALIAS)→[ALIAS: ?y] 
but the last one is to be removed. 
4. If an entity is assigned relations to more than one entity standing before it, 
then only the relation with the nearest unspecified entity is retained. For ex-
ample, in the query “What city in Florida is Sea World in?” (E1 = “city”, E2 = 
“Florida”, E3 = “Sea World”), there are three following possible relations  
extracted in the previous steps:  
[CITY: ?x]→(SUBREGIONOF)→[PROVINCE: Florida] 
[COMPANY: Sea World]→(LOCATEDIN)→[CITY: ?x] 
[COMPANY: Sea World]→(LOCATEDIN)→[PROVINCE: Florida]   
However, since the entity Florida is already identified, the entity Sea World 
actually modifies the identity of the queried city, rather than Florida. There-
fore, the last relation above is redundant and to be removed. 
 
Modifying concepts with adjectives 
 
An adjective modifying an entity can be in either of the following positions: 
1.  Right before the entity, or 
2. After the entity and with the verb “be” in between. 
An example of the first case is the query “What is the longest suspension bridge in 
the U.S.?”, and one of the second case is “Name a tiger that is extinct.”. 
In this work we distinguish quantifiable properties whose values are real num-
bers from non-quantifiable ones. Examples of quantifiable properties are the 
height of a building or the length of a bridge, while examples of non-quantifiable 
ones are the fame of a model or the extinction of an animal. With a superlative ad-
jective on a quantifiable property of an entity, the modified entity is represented  
 

7.5   Evaluation Experiments 
161
 
by a nested CG with the corresponding meta-relation MAX or MIN as presented in 
Section 7.3. Meanwhile, with the other adjectives, it is represented by a concept 
whose type is the corresponding subtype of the original entity type, e.g. 
[EXTINCT_TIGER: *] here. 
7.5   Evaluation Experiments 
We test the proposed translation method on the QA datasets of TREC 2002 and 
TREC 2007 with 440 and 445 queries, respectively. The test uses KIM PROTON 
ontology with about 300 classes and 100 relations, and KIM World KB with over 
77,000 named entities. The correctness of each generated CG is justified by hu-
mans, with respect to the employed ontology and knowledge base and the actual 
meaning of the corresponding query in natural language.  
Queries are categorized into those with connectives, superlative adjectives, or 
different interrogative words. The type Other is for those queries that do not start 
with interrogative words, e.g. “Name an art gallery in New York.” or “WWE 
evolved from what earlier organization?”. Although some of the query categories 
are not mutually exclusive, each query is counted in only one category. Transla-
tion errors may occur due to one of the following causes: 
1. The employed NE recognition engine like GATE’s does not recognize all the 
named entities in a query precisely and completely. We call this an R-error. 
2. The ontology and KB of discourse lack certain entity types, relation types, or 
named entities mentioned in a query. We call this an O-error. 
3. The current CG query language is not expressive enough to represent certain 
queries. We call this a Q-error. 
4. The proposed method itself does not generate a correct CG. We call this an 
M-error. 
Table 7.5.1 Performance of the proposed method on TREC 2002 
Query Type 
Number of 
Queries 
Correct 
CGs 
M-errors 
O-errors 
Q-errors 
Connective 
1 
1 
0 
0 
0 
Superlative adjective 
35 
16 
0 
19 
0 
How many 
17 
13 
1 
2 
1 
What 
184 
170 
3 
11 
0 
Which 
3 
3 
0 
0 
0 
Where 
62 
61 
0 
1 
0 
Who 
57 
54 
0 
3 
0 
When 
38 
33 
0 
5 
0 
How 
22 
20 
0 
1 
1 
Other  
21 
18 
0 
2 
1 
Total 
440 
(100%) 
389 
(88.41%) 
4 
(0.91%) 
44 
(10%) 
3 
(0.68%) 
 

162 
7   Natural Language Query Understanding
 
Table 7.5.2 Performance of the proposed method on TREC 2007 
Query Type 
Number of 
Queries 
Correct 
CGs 
M-errors 
O-errors 
Q-errors 
Connective 
11 
6 
0 
3 
2 
Superlative adjective 
21 
4 
0 
17 
0 
How many 
49 
31 
2 
16 
0 
What 
217 
177 
2 
30 
8 
Which 
23 
18 
0 
4 
1 
Where 
13 
11 
0 
2 
0 
Who 
56 
45 
0 
9 
2 
When 
12 
10 
0 
2 
0 
How 
15 
10 
0 
5 
0 
Other  
28 
25 
0 
1 
2 
Total 
445 
(100%) 
337 
(75.73%) 
4 
(0.90%) 
89 
(20%) 
15 
(3.37%) 
In order to test the actual accuracy of the proposed translation method alone, 
we manually correct the wrongly recognized NEs due to GATE, and supplement 
KIM PROTON and World KB with missing entity types, property types, and 
named entities with respect to the testing queries.  Table 7.5.1 shows the number 
and percentage of each error type on the TREC 2002 dataset by the method, re-
sulting in the overall accuracy of 88.41%. Table 7.5.2 presents the results on the 
TREC 2007 dataset with the overall accuracy of 75.73%. There are more O-errors 
and Q-errors on TREC 2007 as compared with TREC 2002. However, the transla-
tion method itself is still robust with only a few M-errors. If not counting queries 
with O-errors and Q-errors, then the translation accuracies are 389/(389+4) = 
98.98% and 337/(337+4) = 98.83% for the TREC 2002 and TREC 2007 datasets, 
respectively. 
On the basis of the experimental results, we now analyze and discuss on the 
above mentioned four types of translation errors and how they can be overcome. 
Firstly, R-errors solely depend on the accuracy of an employed NE recognition 
engine, whose improvement is a separate problem. Whereas, the proposed method 
is robust to the test datasets, so the small number of M-errors is not of primary 
concern now. The others, O-errors and Q-errors, are addressed below. 
 
Non-binary relations 
 
In practice, there are relations with arities greater than two. An example is the 
query “What year did the U.S. buy Alaska?”, where “buy” actually is a 3-ary rela-
tion of U.S., Alaska, and the queried year. However, in ontology and knowledge 
base languages, such as RDF and OWL, only binary relations are directly sup-
ported. All the encountered O-errors with TREC 2002 and TREC 2007 are due to 
non-binary relation types, which are not modelled in the used ontology.  
 In order to represent an n-ary relation, one way is to define a reified relation 
type, which is an entity type that has n binary relation types with n entity types of 

7.6   VN-KIM Search 
163
 
that relation1. Then, for instance, this example query can be represented by the fol-
lowing query CG: 
[COUNTRY:U.S.]←(SUBJECT)←[BUY:*]→(OBJECT)→[PROVINCE:Alaska] 
↓ 
(TIME) 
↓ 
[YEAR: ?] 
Correspondingly, the proposed method would need to be extended to recognize if 
a relation in a query should be reified or not.  
 
Queries about relations 
 
Among the Q-errors with TREC 2002 and TREC 2007, there is one query in each 
dataset about relations instead of entities. For example, one of the queries is “How 
was Teddy Roosevelt related to FDR?”, where FDR stands for Franklin D. Roose-
velt. If this query were converted into a CG, the question mark would be in a rela-
tion node instead of a concept node as follows: 
[PERSON: Teddy Roosevelt]→(?)→[PERSON: FDR] 
So, in order to deal with queries about relations, the CG query language and the 
translation method would need to be extended for queried relations. 
 
Temporal and other complicated queries 
 
There is also one Q-error in each dataset for queries about time. For example, one 
of the queries is “At Christmas time, what is the traditional thing to do under the 
mistletoe?”. For representing such a temporal query, one would need to extend the 
CG query language with meta-relations about time to be attached to a nested CG. 
Besides, in TREC 2007, there are two context-dependent queries, such as “What 
was the previous world record time?”, whose representation requires knowing the 
current world record time as the reference for the previous one. 
7.6   VN-KIM Search 
We have employed VN-KIM ontology and knowledge base, introduced in Section 
6.5, and the ontology-based information retrieval software library S-Lucene, pre-
sented in Section 7.2, to develop VN-KIM Search as a semantic search engine for 
annotated Vietnamese web pages with the following essential features: 
1. Its query syntax is designed to be similar to, and as expressive as, the 
Google’s one. 
2. However, being more powerful than a purely keyword-based search engine, 
its terms include both keywords and phrases representing named entities, 
which are all called and uniformly treated as generalized terms.  
 
                                                           
1 http://www.w3.org/TR/swbp-n-aryRelations/ 

164 
7   Natural Language Query Understanding
 
3. Moreover, it accepts named entity phrases that are not only simple entity 
names, but also constraints identifying named entities or ontological fea-
tures of user interest. 
4. Besides, resulting web pages can be clustered with respect to the keywords 
and named entities that they contain.  
Figure 7.6.1 presents part of VN-KIM Search query syntax. NE phrases are 
automatically processed and mapped to respective ontological features before be-
ing sent to S-Lucene to retrieve documents. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Fig. 7.6.1 Basic syntax of VN-KIM Search queries 
 
For example, the following query in Vietnamese consisting of two terms is to 
search for documents about pollution in country capitals, where the terms are un-
derlined with their English meanings for readability: 
"ô nhiễm"  (thủ đô) 
  pollution    captital 
In this example, "ô nhiễm" is a quoted phrase of keywords and (thủ đô) is a NE 
phrase, which is mapped to the NE triple (*/Thủ_đô/*) representing unspecified 
named entities of the type country capital. 
For another example, the following query is to search for documents about 
flights from Saigon City to cities in Europe: 
"chuyến bay"  "từ (thành phố Saigon) đến (các thành phố ở Châu Âu)"  
       flight          from       city                       to            cities          in   Europe 
Here, the simple NE phrase (thành phố Saigon) is mapped to the NE triple 
(*/*/Thành_phố_41), where Thành_phố_41 is the identifier of Saigon City in  
VN-KIM knowledge base.  
<query> → <term list> 
<term list> → <term list> <required term> | <required term> 
<required term> → <required term> OR <opterm> | <opterm> 
<opterm> → <operator> <term> 
<operator> → - | null 
<term> → <generalized term> | <quoted phrase>  
<generalized term> → <keyword> | <NE phrase> 
<g-term list> → <generalized term> | <generalized term> <g-term list> 
<keyword> → <token> 
<NE phrase> → ( <token list> )  
<quoted phrase>  → "<g-term list>" <distance> 
<distance> →~Integer | null  

7.6   VN-KIM Search 
165
 
Meanwhile, the complex NE phrase (các thành phố ở Châu Âu) is first con-
verted to the conceptual graph shown in Figure 7.6.2, using the method presented 
in Section 7.5, to retrieve the right named entities in the knowledge base of dis-
course. We note that this named entities retrieval step is not required for simple 
NE phrases, which convey only entity names and their types. The identifiers of 
matched entities are then represented by the NE triples of the form (*/*/id) to re-
trieve documents in VN-KIM repository of annotated web pages. 
 
Fig. 7.6.2 The conceptual graph converted from a query NE phrase in VN-KIM Search 
As such, a NE phrase is not simply treated as a list of plain keywords, but as 
one containing ontological information expressing user interest in a search. There-
fore VN-KIM Search is actually a proper generalization of, i.e., subsuming, a 
purely keyword-based search engine like Google, allowing semantic searching in 
regards of named entities. Figure 7.6.3 is a screen shot of VN-KIM Search show-
ing a query, its generated conceptual graph, and search result window on the right. 
The window on the left shows the hierarchy of resulting documents clustered by 
named entity features using the multi-vector model introduced in Section 7.2. VN-
KIM Search can be modified for a knowledge base and annotated documents in 
another language such as English. 
 
Fig. 7.6.3 A screen shot of VN-KIM Search  

166 
7   Natural Language Query Understanding
 
7.7   Summary 
Semantic search requires an ontology of concepts, in particular one of named enti-
ties, representing their own properties and relations with others. Two adapted  
vector space models, namely, the multi-vector and the generalized term ones, are 
presented, taking into account both conventional keywords and named entities in 
vector representations of documents and queries. While the generalized term 
model is uniform, the multi-vector model is useful for document searching and 
clustering on individual ontological features, i.e., entity names, classes, joint 
names and classes, and identifiers. 
For a desirable natural language interface of a search system, a query needs to 
be converted to a formal representation to retrieve the knowledge or named enti-
ties in question, which are possibly used for further retrieving documents about 
them, in particular with the two presented ontology-based information retrieval 
models. A nested CG language is proposed for formal representations of natural 
language queries, using meta-relations to represent connective, superlative, and 
counting queries. They correspond to subqueries with Boolean operators and ag-
gregate functions of a relational database query language like SQL.  
With smooth mapping to and from natural language, conceptual graphs sim-
plify the rules to convert natural language queries to them. As an interlingua, con-
ceptual graphs can also be further converted to other formal query languages. The 
proposed method for mapping natural language queries to conceptual graphs does 
not require grammatically correct querying phrases or sentences, and exploits an 
ontology to identify entities and their respective relations in a query. Since the on-
tology constraints valid relation types between certain entity types, it makes the 
method robust to ill-formed queries, not too dependent on relative positions of re-
lations and entities.  
The experimental statistics show that the method is robust to diverse structures 
and contents of questions in the TREC test datasets, provided that the ontology 
and knowledge base of discourse cover well entities and relations in the domain. 
VN-KIM Search is introduced as a demonstration system that employs the pre-
sented ontology-based information retrieval models and the natural language 
query understanding method for semantic search of annotated documents. 
 

 
Appendices 
A.1   Proofs for Chapter 2 
Proposition 2.4.1. Let G be a simple CG such that norm(G) exists. Then: 
1.  G ≤ι norm(G). 
2.  If G ≤ι G* and G* is normal, then norm(G) ≤ι G*. 
Proof 
1.  According to CG normalization, if S is a set of vertices in G that are joined into 
a vertex e in norm(G), then the conjunctive concept or relation type in e is the 
least upper bound of all the corresponding conjunctive concept or relation 
types of the vertices in S. So, there exists a CG projection π from G to norm(G) 
that maps the vertices in such a set S in G to the corresponding vertex e in 
norm(G), and the other vertices in G to themselves in norm(G), whence G ≤ι 
norm(G) by π. 
2.  Let G* be normal and G ≤ι G* by π*. Since G* is normal, all the vertices in a 
set S in G that are joined into a vertex e in norm(G) have to be mapped to one 
vertex e* in G* by π*, where the conjunctive concept or relation type in e* is 
an upper bound of all the corresponding conjunctive concept or relation types 
of the vertices in S and, thus, a subtype of the conjunctive concept or relation 
type in e. So, there exists a CG projection π0 from norm(G) to G* that maps 
such a vertex e in norm(G) to the corresponding e* in G*, and the other verti-
ces in norm(G) to the same vertices in G* that their identical ones in G are 
mapped to by π*, whence norm(G) ≤ι G* by π0. 
Proposition 2.5.1. For every fuzzy set A and α∈[0, 1], A+(1 − α) is the least spe-
cific solution for A* such that N(A | A*) ≥ α.  
Proof 
Let U be the domain of A and A*. Firstly, from Definition 2.5.4 and Equation 
2.5.4, one has: 
N(A | A+(1 − α))  
= 1 − supu∈U{max{0, μA+(1 − α)(u) − μA(u)}} 
= 1 − supu∈U{max{0, min{1,μA(u)+(1 − α)} − μA(u)}} 
= 1 − supu∈U{min{1, μA(u) + (1 − α)} − μA(u)} 
= 1 − supu∈U{min{1 − μA(u), 1 − α}} 
= infu∈U{max{μA(u), α}} 
= max{infu∈U{μA(u)}, α} 
≥ α. 

168 
Appendices
 
One has  N(A | A+(1 − α)) = α  iff   infu∈U{μA(u)} ≤ α. In particular, this occurs 
when ∃u∈U: μA(u) < α, that is, A+(1 − α) ≠ ⊥. 
We now prove that, if N(A | A*) ≥ α then A* ⊆ A+(1 − α). From Definition 
2.5.4, one has: 
N(A | A*)  = 1 − supu∈U{max{0, μA*(u) − μA(u)}} 
 
= infu∈U{min{1, 1 − μA*(u) + μA(u)}}. 
Thus, if N(A | A*) ≥ α then ∀u∈U: min{1, 1 − μA*(u) + μA(u)} ≥ α, 
whence ∀u∈U: μA*(u) ≤ min{1, μA(u)+(1 − α)}, that is, A* ⊆ A+(1 − α). 
Proposition 2.5.2. Let A, A*, A1 and A2 be fuzzy sets on the same domain. Then 
the following properties hold:  
1. Δ(A | A*) = 0 iff A ≤ι A*, i.e., A* ⊆ A.  
2. If A1 ≤ι A2 then Δ(A | A2) ≤ Δ(A | A1). 
3. A+ε ≤ι A* iff Δ(A | A*) ≤ ε, for every ε∈[0, 1]. 
Proof 
Properties 1 and 2 are straightforward from Definition 2.5.5.  
For property 3, by Proposition 2.5.1, if Δ(A | A*) ≤ ε then A+ε ≤ι A*. On the 
other hand, if A+ε ≤ι A* then, by property 2, Δ(A | A*) ≤ Δ(A | A+ε). Since Δ(A | 
A+ε) ≤ ε by Proposition 2.5.1, one has Δ(A | A*) ≤ ε. 
 
Proposition 2.6.1. The fuzzy subtype relation is a partial order. 
Proof 
1.  Reflexivity: it is obvious that the relation is reflexive (case 1 of Definition 
2.6.3). 
2. Transitivity: from Definition 2.6.3, if (t1, v1) ≤ι (t2, v2) then v1 ≤ι v2. Thus, sup-
posing that (t1, v1) ≤ι (t2, v2) ≤ι (t3, v3), one has v1 ≤ι v2 ≤ι v3. Regarding the ba-
sic subtype relations between t1 and t2 and between t2 and t3, there are nine 
cases in total. We now prove that (t1, v1) ≤ι (t3, v3) by considering them case by 
case: 
(a)  t1 = t2: 
•  t2 = t3: one has (t1, v1) ≤ι (t3, v3) by case 1 of Definition 2.6.3. 
•  t2 <ι t3 and v2 ≤ι lub{v∈T | v ≤ι v3}: one has t1 <ι t3 and v1 ≤ι v2 ≤ι 
lub{v∈T | v ≤ι v3}, whence (t1, v1) ≤ι (t3, v3) by case 2 of Definition 
2.6.3. 
•  t2 >ι t3 and v2 ≤ι lub{v∈F | v ≤ι v3}: one has t3 <ι t1 and v1 ≤ι v2 ≤ι 
lub{v∈F | v ≤ι v3}, whence (t1, v1) ≤ι (t3, v3) by case 3 of Definition 
2.6.3. 
(b)  t1 <ι t2 and v1 ≤ι lub{v ∈ T | v ≤ι v2}: 
•  t2 = t3: one has t1 <ι t3 and v1 ≤ι lub{v∈T | v ≤ι v2} ≤ι lub{v∈T | v ≤ι v3}, 
whence (t1, v1) ≤ι (t3, v3) by case 2 of Definition 2.6.3. 
•  t2 <ι t3 and v2 ≤ι lub{v∈T | v ≤ι v3}: one has t1 <ι t3 and v1 ≤ι lub{v∈T | v 
≤ι v2} ≤ι lub{v∈T | v ≤ι v3}, whence (t1, v1) ≤ι (t3, v3) by case 2 of Defini-
tion 2.6.3. 

A.1   Proofs for Chapter 2 
169
 
•  t2 >ι t3 and v2 ≤ι lub{v∈F | v ≤ι v3}: this case does not occur because it 
would lead to lub{v∈T | v ≤ι v2} ≤ι v2 ≤ι lub{v∈F | v ≤ι v3}, which would 
violate Definition 2.6.1 requiring that a TRUE-characteristic fuzzy truth-
value and a FALSE-characteristic one are not comparable. 
(c)  t2 <ι t1 and v1 ≤ι lub{v∈F | v ≤ι v2}: 
•  t2 = t3: one has t3 <ι t1 and v1 ≤ι lub{v∈F | v ≤ι v2} ≤ι lub{v∈F | v ≤ι v3}, 
whence (t1, v1) ≤ι (t3, v3) by case 3 of Definition 2.6.3. 
•  t2 <ι t3 and v2 ≤ι lub{v∈T | v ≤ι v3}: this case does not occur because it 
would lead to lub{v∈F | v ≤ι v2} ≤ι v2 ≤ι lub{v∈T | v ≤ι v3}, which would 
violate Definition 2.6.1 of a fuzzy truth-value lattice. 
•  t2 >ι t3 and v2 ≤ι lub{v∈F | v ≤ι v3}: one has t3 <ι t1 and v1 ≤ι lub{v∈F | v 
≤ι v2} ≤ι lub{v∈F | v ≤ι v3}, whence (t1, v1) ≤ι (t3, v3) by case 3 of Defini-
tion 2.6.3. 
3.  Anti-symmetry: supposing that (t1, v1) ≤ι (t2, v2) and (t2, v2) ≤ι (t1, v1), one has 
v1 ≤ι v2 and v2 ≤ι v1, whence v1 = v2. Furthermore: 
(a)  if t1 <ι t2 then v1 = v2 ≤ι lub{v∈T | v ≤ι v2} due to (t1, v1) ≤ι (t2, v2), and v1 
= v2 ≤ι lub{v∈F | v ≤ι v1} due to (t2, v2) ≤ι (t1, v1), whence v1 = v2 
= lub{v∈T | v ≤ι v2} = lub{v∈F | v ≤ι v1}, which would violate Definition 
2.6.1. 
(b) if t1 >ι t2 then v1 = v2 ≤ι lub{v∈F | v ≤ι v2} due to (t1, v1) ≤ι (t2, v2), and v1 
= v2 ≤ι lub{v∈T | v ≤ι v1} due to (t2, v2) ≤ι (t1, v1), whence v1 = v2 
= lub{v∈F | v ≤ι v2} = lub{v∈T | v ≤ι v1}, which would also violate Defini-
tion 2.6.1. 
Thus, t1 = t2, whence (t1, v1) = (t2, v2). 
 
Proposition 2.6.2. The conjunctive fuzzy subtype relation is a partial order. 
Proof 
1.  Reflexivity: it is obvious that the relation is reflexive. 
2.  Transitivity: Supposing that T1 ≤ι T2 ≤ι T3, one has ∀τ1∈T1 ∃τ2∈T2: τ1 ≤ι τ2 and 
∀τ2∈T2 ∃τ3∈T3: τ2 ≤ι τ3, whence ∀τ1∈T1 ∃τ3∈T3: τ1 ≤ι τ3, which means T1 ≤ι T3. 
3.  Anti-symmetry: supposing that T1 ≤ι T2 and T2 ≤ι T1, one has ∀τ1∈T1 ∃τ2∈T2: 
(τ1 ≤ι τ2 and ∃τ1*∈T1: τ2 ≤ι τ1*), where τ1 = τ1* and thus τ1 = τ2, because oth-
erwise 
τ1 
<ι τ1*, 
which 
would 
violate 
Definition 
2.6.4. 
Thus, 
∀τ1 ∈ T1 ∃τ2 ∈ T2: τ1 = τ2, which means T1 ⊆ T2. Similarly, one has T2 ⊆ T1, 
whence T1 = T2. 
 
Proposition 2.6.3. The set of all conjunctive fuzzy types, defined over a partially 
ordered set of basic types and a fuzzy truth-value lattice, forms an upper semi-
lattice under the conjunctive fuzzy subtype relation where, for two conjunctive 
fuzzy types T1 and T2, lub{T1, T2} = con(T1∪T2). 
Proof 
As it is described, con(T1∪T2) is constructed from T1∪T2 by just removing the 
elements that are less specific than others in T1∪T2. Thus, for every element τ in 

170 
Appendices
 
T1 or in T2, there is an element τ* in con(T1∪T2) such that τ ≤ι τ*, whence 
con(T1∪T2) is an upper bound of {T1, T2}.  
On the other hand, every element in con(T1∪T2) is an element in T1 or in T2. 
Thus, if T is an upper bound of {T1, T2}, then for every element τ in con(T1∪T2) 
there is an element τ* in T such that τ ≤ι τ*, whence con(T1∪T2) ≤ι T. Therefore, 
con(T1∪T2) is the least upper bound of {T1, T2}. 
 
Proposition 2.6.4. Let T1 and T2 be two conjunctive fuzzy types such that 
∀τ1∈T1 ∀τ2∈T2: glb{τ1, τ2} exists if τ1 and τ2 have a common lower bound. Then, 
glb{T1, T2} = con{glb{τ1, τ2} | τ1∈T1, τ2∈T2 and glb{τ1, τ2} exists} if T1 and T2 
have a common lower bound. 
Proof  
Let T0 = con{glb{τ1, τ2} | τ1∈T1, τ2∈T2 and glb{τ1, τ2} exists}. It is obvious that T0 
≤ι T1 and T0 ≤ι T2. Also, if T is a lower bound of {T1, T2}, then 
∀τ∈T ∃τ1∈T1 ∃τ2∈T2: τ ≤ι τ1 and τ ≤ι τ2. Thus, ∀τ∈T ∃τ1∈T1 ∃τ2∈T2: glb{τ1, τ2} 
exists and τ ≤ι glb{τ1, τ2}, whence T ≤ι T0. Therefore, glb{T1, T2} = T0. 
 
Proposition 2.6.5. Let τ1 and τ2 be two fuzzy types, defined over a basic type lat-
tice and a fuzzy truth-value lattice, such that both are either: 
1. Constructed from the same basic type, or 
2. Non-negative, or 
3. Non-positive 
Then glb{τ1, τ2} exists if τ1 and τ2 have a common lower bound. 
Proof  
1.  Let (t, v1) and (t, v2) be two fuzzy types constructed from the same basic type t. 
It is obvious that (t, glb{v1, v2}) is a lower bound of {(t, v1), (t, v2)}. We now 
prove that for any lower bound (t0, v0) of {(t, v1), (t, v2)}, one has (t0, v0) ≤ι (t, 
glb{v1, v2}): 
(a)  t0 = t: one has v0 ≤ι v1 and v0 ≤ι v2, whence v0 ≤ι glb{v1, v2} and thus (t0, v0) 
≤ι (t, glb{v1, v2}). 
(b)  t0 <ι t: one has v0 ≤ι lub{v∈T | v ≤ι v1} ≤ι v1 and v0 ≤ι lub{v∈T | v ≤ι v2} 
≤ι v2, whence v0 ≤ι glb{lub{v∈T | v ≤ι v1}, lub{v∈T | v ≤ι v2}} ≤ι glb{v1, 
v2}. Since glb{lub{v∈T | v ≤ι v1}, lub{v∈T | v ≤ι v2}} ∈ T, one has v0 
≤ι lub{v∈T | v ≤ι glb{v1, v2}} and thus (t0, v0) ≤ι (t, glb{v1, v2}). 
(c) t0 >ι t: one has v0 ≤ι lub{v∈F | v ≤ι v1} ≤ι v1 and v0 ≤ι lub{v∈F | v ≤ι v2} 
≤ι v2, whence v0 ≤ι glb{lub{v∈F | v ≤ι v1}, lub{v∈F | v ≤ι v2}} ≤ι glb{v1, 
v2}. Since glb{lub{v∈F | v ≤ι v1}, lub{v∈F | v ≤ι v2}} ∈ F, one has v0 
≤ι lub{v∈F | v ≤ι glb{v1, v2}} and thus (t0, v0) ≤ι (t, glb{v1, v2}). 
Therefore, glb{(t, v1), (t, v2)} = (t, glb{v1, v2}). 
2.  Let (t0, v0) be a lower bound of {(t1, v1), (t2, v2)}. Regarding the basic subtype 
relations between t0 and t1 and between t0 and t2, there are totally nine cases: 
(a)  t0 = t1 = t2 and v0 ≤ι v1 and v0 ≤ι v2. 
(b)  t0 = t1 <ι t2 and v0 ≤ι v1 and v0 ≤ι lub{v∈T | v ≤ι v2}. 

A.1   Proofs for Chapter 2 
171
 
(c)  t0 = t1 >ι t2 and v0 ≤ι v1 and v0 ≤ι lub{v∈F | v ≤ι v2}. 
(d)  t0 = t2 <ι t1 and v0 ≤ι lub{v∈T | v ≤ι v1} and v0 ≤ι v2. 
(e)  t0 = t2 >ι t1 and v0 ≤ι lub{v∈F | v ≤ι v1} and v0 ≤ι v2. 
(f)  t0 <ι t1 and t0 <ι t2 and v0 ≤ι lub{v∈T | v ≤ι v1} and v0 ≤ι lub{v∈T | v ≤ι v2}. 
(g)  t0 >ι t1 and t0 >ι t2 and v0 ≤ι lub{v∈F | v ≤ι v1} and v0 ≤ι lub{v∈F | v ≤ι v2}. 
(h)  t1 <ι t0 <ι t2 and v0 ≤ι lub{v∈F | v ≤ι v1} and v0 ≤ι lub{v∈T | v ≤ι v2}. 
(i)   t1 >ι t0 >ι t2 and v0 ≤ι lub{v∈T | v ≤ι v1} and v0 ≤ι lub{v∈F | v ≤ι v2}. 
With (t1, v1) and (t2, v2) being non-negative fuzzy types, cases (c), (e), (g), (h) 
and (i) do not occur, so glb{(t1, v1), (t2, v2)} is defined as follows: 
•  t1 = t2:   only cases (a) and (f) are involved, whence glb{(t1, v1), (t2, v2)} 
= (t1, glb{v1, v2}) = (t2, glb{v1, v2}), or else 
•  t1 <ι t2:  only cases (b) and (f) are involved, whence glb{(t1, v1), (t2, v2)} 
= (t1, glb{v1, lub{v∈T | v ≤ι v2}}), or else 
•  t1 >ι t2:  only cases (d) and (f) are involved, whence glb{(t1, v1), (t2, v2)} 
= (t2, glb{lub{v∈T | v ≤ι v1}, v2}), or else 
•  t1 and t2 are not comparable:   only case (f) is involved, whence glb{(t1, 
v1), (t2, v2)} = (glb{t1, t2}, glb{lub{v∈T | v ≤ι v1}, lub{v∈T | v ≤ι v2}}). 
Similarly, with (t1, v1) and (t2, v2) being non-positive fuzzy types, glb{(t1, v1), 
(t2, v2)} is defined as follows: 
•  t1 = t2:   glb{(t1, v1), (t2, v2)} = (t1, glb{v1, v2}) = (t2, glb{v1, v2}), or else 
•  t1 <ι t2:  glb{(t1, v1), (t2, v2)} = (t2, glb{lub{v∈F | v ≤ι v1}, v2}),   or else 
•  t1 >ι t2:  glb{(t1, v1), (t2, v2)} = (t1, glb{v1, lub{v∈F | v ≤ι v2}}),    or else 
•  t1 and t2 are not comparable:  glb{(t1, v1), (t2, v2)} = (lub{t1, t2}, 
glb{lub{v∈F | v ≤ι v1}, lub{v∈F | v ≤ι v2}}). 
 
Proposition 2.6.6. For every fuzzy type τ1 and ε∈[0, 1], τ1+ε is the least specific 
solution for τ2 such that Δ(τ1 | τ2) ≤ ε. 
Proof 
Firstly, one has Δ(τ1 | τ1+ε) = Δ(v1 | v1+ε). By Proposition 2.5.2, Δ(v1 | v1+ε) ≤ ε, 
whence Δ(τ1 | τ1+ε) ≤ ε, for every ε∈[0, 1].  
We now prove that, if Δ(τ1 | τ2) ≤ ε then τ1+ε ≤ι τ2. Let τ1 = (t1, v1) and τ2 = (t2, v2). 
By Definition 2.6.7, there are three cases: 
1.  t1 = t2:  one has Δ(τ1 | τ2) = Δ(v1 | v2) ≤ ε, whence v1+ε ≤ι v2 (Proposition 2.5.2) 
and thus τ1+ε ≤ι τ2 by case 1 of Definition 2.6.3. 
2.  t1 <ι t2 and ∃v∈T: v ≤ι v2:  one has Δ(τ1 | τ2) = Δ(v1 | lub{v∈T | v ≤ι v2}) ≤ ε, 
whence v1+ε ≤ι lub{v∈T | v ≤ι v2} and thus τ1+ε ≤ι τ2 by case 2 of Definition 
2.6.3. 
3.  t1 >ι t2 and ∃v∈F: v ≤ι v2:   one has Δ(τ1 | τ2) = Δ(v1 | lub{v∈F | v ≤ι v2}) ≤ ε, 
whence v1+ε ≤ι lub{v∈F | v ≤ι v2} and thus τ1+ε ≤ι τ2 by case 3 of Definition 
2.6.3. 
 
Proposition 2.6.7. Let τ1, τ2 and τ3 be fuzzy types, defined over a partially ordered 
set of basic types and a fuzzy truth-value lattice, such that τ1 is matchable to τ2. 
Then the following properties hold:  

172 
Appendices
 
1.  Δ(τ1 | τ2) = 0 iff τ1 ≤ι τ2.  
2.  If τ2 ≤ι τ3, then τ1 is matchable to τ3 and Δ(τ1 | τ3) ≤ Δ(τ1 | τ2). 
3.  τ1+ε ≤ι τ2 iff Δ(τ1 | τ2) ≤ ε, for every ε∈[0, 1]. 
Proof 
1. This property is straightforward from Definition 2.6.3 and Definition 2.6.7. 
2. Let τ1 = (t1, v1), τ2 = (t2, v2), τ3 = (t3, v3) and τ2 ≤ι τ3. Regarding the basic subtype 
relations between t1 and t2 and between t2 and t3, there are nine cases in total. 
We now prove that Δ(τ1 | τ3) ≤ Δ(τ1 | τ2) by considering them case by case: 
(a)  t1 = t2: one has Δ(τ1 | τ2) = Δ(v1 | v2) 
•  t2 = t3 and v2 ≤ι v3:  one has Δ(τ1 | τ3) = Δ(v1 | v3) ≤ Δ(v1 | v2) = Δ(τ1 | τ2).  
•  t2 <ι t3 and v2 ≤ι lub{v ∈ T | v ≤ι v3}:  one has Δ(τ1 | τ3) = Δ(v1 | 
lub{v∈T | v ≤ι v3}) ≤ Δ(v1 | v2) = Δ(τ1 | τ2). 
•  t2 >ι t3 and v2 ≤ι lub{v∈F | v ≤ι v3}:  one has Δ(τ1 | τ3) = Δ(v1 | lub{v∈F | 
v ≤ι v3}) ≤ Δ(v1 | v2) = Δ(τ1 | τ2). 
(b)  t1 <ι t2 and ∃v∈T: v ≤ι v2: 
•  t2 = t3 and v2 ≤ι v3:  one has Δ(τ1 | τ2) = Δ(v1 | lub{v∈T | v ≤ι v2}) ≥ Δ(v1 
| lub{v∈T | v ≤ι v3}) = Δ(τ1 | τ3). 
•  t2 <ι t3 and v2 ≤ι lub{v∈T | v ≤ι v3}: one has Δ(τ1 | τ2) = Δ(v1 | lub{v∈T | 
v ≤ι v2}) ≥ Δ(v1 | lub{v∈T | v ≤ι v3}) = Δ(τ1 | τ3). 
•  t2 >ι t3 and v2 ≤ι lub{v∈F | v ≤ι v3}: this case does not occur because it 
would lead to ∃v∈T: v ≤ι v2  
≤ι lub{v∈F | v ≤ι v3} ∈ F, which 
would violate Definition 2.6.1 of a fuzzy truth-value lattice. 
(c)  t1 >ι t2 and ∃v∈F: v ≤ι v2: 
•  t2 = t3 and v2 ≤ι v3:  one has Δ(τ1 | τ2) = Δ(v1 | lub{v∈F | v ≤ι v2}) ≥ Δ(v1 | 
lub{v∈F | v ≤ι v3}) = Δ(τ1 | τ3). 
•  t2 <ι t3 and v2 ≤ι lub{v∈T | v ≤ι v3}:  this case does not occur because it 
would lead to ∃v∈F: v ≤ι v2  
≤ι lub{v∈T | v ≤ι v3} ∈ T, which 
would violate Definition 2.6.1 of a fuzzy truth-value lattice. 
•  t2 >ι t3 and v2 ≤ι lub{v∈F | v ≤ι v3}:  one has Δ(τ1 | τ2) = Δ(v1 | lub{v∈F | 
v ≤ι v2}) ≥ Δ(v1 | lub{v∈F | v ≤ι v3}) = Δ(τ1 | τ3). 
3.  By Proposition 2.6.4, if Δ(τ1 | τ2) ≤ ε then τ1+ε ≤ι τ2. On the other hand, if τ1+ε 
≤ι τ2 then, by property 2 above, Δ(τ1 | τ2) ≤ Δ(τ1 | τ1+ε). Since Δ(τ1 | τ1+ε) ≤ ε 
by Proposition 2.6.6, one has Δ(τ1 | τ2) ≤ ε. 
 
Proposition 2.6.8. For every conjunctive fuzzy type T1 and ε∈[0, 1], T1+ε is the 
least specific solution for T2 such that Δ(T1 | T2) ≤ ε. 
Proof 
Let S = {τ1+ε | τ1∈T1}. By Definition 2.6.9, one has Δ(T1 | T1+ε) = maxτ∈T 
minτ∈T+ε{Δ(τ1 | τ2)}. Since T1+ε = con(S) is obtained from S by just removing the 
elements that are less specific than others in S, one has ∀τ2*∈S ∃ τ2∈T1+ε: τ2* ≤ι 
τ2. By property 2 in Proposition 2.6.7, for any τ1, if τ1 is matchable to τ2*, then τ1  
 
 

A.1   Proofs for Chapter 2 
173
 
is matchable to τ2 and Δ(τ1 | τ2) ≤ Δ(τ1 | τ2*). Thus, for every τ1∈T1, minτ∈T+ε{Δ(τ1 | 
τ2)} = minτ*∈S{Δ(τ1 | τ2*)} ≤ Δ(τ1 | τ1+ε) ≤ ε, whence Δ(T1 | T1+ε) = maxτ∈T 
minτ∈T+ε{Δ(τ1 | τ2)} ≤ ε. 
We now prove that, if Δ(T1 | T2) ≤ ε then T1+ε ≤ι T2. One has Δ(T1 | T2) = maxτ∈T 
minτ∈T{Δ(τ1 | τ2)} ≤ ε whence ∀τ1∈T1: minτ∈T{Δ(τ1 | τ2)} ≤ ε. Thus, ∀τ1∈T1 
∃τ2∈T2: Δ(τ1 | τ2) ≤ ε whence τ1+ε ≤ι τ2, which means T1+ε ≤ι T2. 
 
Proposition 2.6.9. Let T1, T2 and T3 be conjunctive fuzzy types, defined over a 
partially ordered set of basic types and a fuzzy truth-value lattice, such that T1 is 
matchable to T2. Then the following properties hold:  
1.  Δ(T1 | T2) = 0 iff T1 ≤ι T2.  
2.  If T2 ≤ι T3, then T1 is matchable to T3 and Δ(T1 | T3) ≤ Δ(T1 | T2). 
3.  T1 + ε ≤ι T2 iff Δ(T1 | T2) ≤ ε, for every ε∈[0, 1]. 
Proof 
1.  Δ(T1 | T2) = 0 iff maxτ∈Tminτ∈T{Δ(τ1 | τ2)} = 0 iff ∀τ1∈T1: minτ∈T{Δ(τ1 | τ2)} = 0 
iff ∀τ1∈T1 ∃τ2∈T2: Δ(τ1 | τ2) = 0 iff ∀τ1∈T1 ∃τ2∈T2: τ1 ≤ι τ2 iff T1 ≤ι T2. 
2.  If T2 ≤ι T3 then ∀τ2∈T2 ∃τ3∈T3: τ2 ≤ι τ3 whence, by property 2 in Proposition 
2.6.7, Δ(τ1 | τ3) ≤ Δ(τ1 | τ2) for any τ1 that is matchable to τ2. Thus, ∀τ1∈T1: 
minτ∈T{Δ(τ1 | τ3)} ≤ minτ∈T{Δ(τ1 | τ2)}, whence Δ(T1 | T3) = maxτ∈Tminτ∈T{Δ(τ1 | 
τ3)} ≤ maxτ∈T minτ∈T{Δ(τ1 | τ2)} = Δ(T1 | T2). 
3. By Proposition 2.6.8, if Δ(T1 | T2) ≤ ε then T1+ε ≤ι T2. On the other hand, if 
T1+ε ≤ι T2 then, by property 2 above, Δ(T1 | T2) ≤ Δ(T1 | T1+ε). Since Δ(T1 | 
T1+ε) ≤ ε by Proposition 2.6.8, one has Δ(T1 | T2) ≤ ε. 
 
Proposition 2.7.1. There exists an infinite CG such that there is no irredundant 
CG that is equivalent to it. 
Proof 
We prove this property by proving that the infinite CG G in Figure 2.7.6 is redun-
dant and there is no irredundant CG that is equivalent to it.  
It is obvious that G is redundant, because there is a projection from G to its 
strict subgraph g, for instance, that is obtained from G by deleting the first concept 
and the first relation. 
Let H be a CG that is equivalent to G and π be a projection from G to H. If any 
two concepts in G were mapped to one concept in H, then H would have a closed 
path. Since H also has a projection to G, it would entail that G also had a closed 
path, which is not the case. Thus, no two concepts in G are mapped to one concept 
in H, i.e., π is injective. Further, in πG all the concept labels must be the same as 
(T, *) and all the relation labels the same as R, because they are so in G, whence G 
and πG are identical. Therefore, H is redundant, because either πG is a strict sub-
graph of H or otherwise G and H are identical. 
 
Proposition 2.7.2. There exist two irredundant infinite CGs that are equivalent but 
are not identical. 

174 
Appendices
 
Proof 
Assuming an infinite type lattice that contains the infinite chain {Tz/2 | z∈Z and 
Tp ≤ι Tq iff q ≤ p}, we prove the property by proving that the two infinite CGs G 
and H in Figure 2.7.7, which are obviously not identical, are equivalent and irre-
dundant.  
The two CGs are equivalent because there are projections from one to the other, 
as shown in the figure. 
On the other hand, the least reduction of H is obtained by deleting a relation 
vertex in it, as shown in the figure, for instance, producing h1 and h2. For a projec-
tion from H to [h1 h2] as a disconnected CG, if the concept [T1/2: *] in H were  
projected to a concept in h1, then there would be no path in [h1 h2] that could cor-
respond to the right part of H from [T1/2: *], due to the disconnection of h1 and h2. 
Similarly, if the concept [T1/2: *] in H were projected to a concept in h2, then there 
would be no path in [h1 h2] that could correspond to the left part of H from  
[T1/2: *]. 
Thus, there cannot be a projection from H to [h1 h2], that is, H is irredundant. 
Similarly, G is also irredundant. 
A.2   Proofs for Chapter 3 
Proposition 3.4.1. RP and TP are monotonic, that is: 
1. If I1 ≤ι I2 then RP(I1) ≤ι RP(I2), where I1, I2 are r-interpretations. 
2. If I1 ≤ι I2 then TP(I1) ≤ι TP(I2), where I1, I2 are g-interpretations. 
Proof 
1.  See Definition 3.4.1. Let S1 and S2 be the sets {H+ε | ...} corresponding to I1 
and I2. Since I1 ≤ι I2, one has I1(Obji) ≤ι I2(Obji) whence, by property 2 in 
Proposition 2.5.3, one has Δ(Bi | I2(Obji)) ≤ Δ(Bi | I1(Obji)). Thus, if H+ε1 ∈ S1 
then there exists H+ε2 ∈ S2 with ε2 ≤ ε1, i.e., H+ε1 ≤ι H+ε2, whence RP(I1) 
≤ι RP(I2). 
2.  See Definition 3.4.2. Let S1 and S2 be the sets {H+ε | ...} corresponding to I1 
and I2. Since I1 ≤ι I2, if Bi*∈I1(Obji) then Bi*∈I2(Obji). Thus, if H+ε ∈ S1 then 
H+ε ∈ S2, whence TP(I1) ≤ι TP(I2). 
 
Proposition 3.4.2.   Let  P  be  an  AFLP  and  Ir  and  Ig  be  an  r-interpretation 
 and  a g-interpretation, respectively. Then: 
1. Ir is an r-model of P iff RP(Ir) ≤ι Ir . 
2. Ig is a g-model of P iff TP(Ig) ≤ι Ig. 
Proof 
1.  See Definition 3.4.1. Let Sr be the set {H+ε | ...} corresponding to Ir and 
Obj∈BL. If Ir is an r-model of P then, by Definition 3.3.5, for every H+ε ∈ Sr , 
one has H+ε ≤ι Ir(Obj), whence lub(Sr) ≤ι Ir(Obj) and thus RP(Ir) ≤ι Ir . On the 
other hand, if RP(Ir) ≤ι Ir then lub(Sr) ≤ι Ir(Obj), whence Ir satisfies every 
ground instance of every clause in P, i.e., Ir is an r-model of P. 

A.2   Proofs for Chapter 3 
175
 
2.  See Definition 3.4.2. Let Sg be the set {H+ε | ...} corresponding to Ig and 
Obj∈BL. If Ig is a g-model of P then, by Definition 3.3.6, for every H+ε ∈ Sg, 
one has H+ε ∈ Ig(Obj), i.e., Sg ⊆ Ig(Obj), whence TP(Ig) ≤ι Ig. On the other 
hand, if TP(Ig) ≤ι Ig then Sg ⊆ Ig(Obj), whence Ig satisfies every ground instance 
of every clause in P, i.e., Ig is a g-model of P. 
 
Proposition 3.4.4. RP and TP are continuous, that is: 
1. RP(lub{Ij}) = lub{RP(Ij)}, for all sequences I1 ≤ι I2 ≤ι ... of r-interpretations. 
2. TP(lub{Ij}) = lub{TP(Ij)}, for all sequences I1 ≤ι I2 ≤ι ... of g-interpretations. 
Proof 
1.  Let us use α to enumerate the ground instances of clauses in P having Obj 
∈ BL in their heads. We denote the α-th such ground instance by Obj: Hα 
← Objα1: Bα1 & Objα2: Bα2 & ... & Objαn: Bαn. 
Then, the expression in Definition 3.4.1 can be rewritten as follows: 
RP(I)(Obj) = lubα{Hα+maxi=1,n{Δ(Bαi | I(Objαi))}} 
whence 
RP(lub{Ij})(Obj) = lubα{Hα+maxi=1,n{Δ(Bαi | lub{Ij}(Objαi))}} 
Since I1 ≤ι I2 ≤ι ..., for each α and each i from 1 to nα, one has Δ(Bαi | I1(Objαi)) 
≥ Δ(Bαi | I2(Objαi)) ≥ ... (Property 2 in Proposition 2.5.3), and the following 
holds: 
Δ(Bαi | lub{Ij}(Objαi)) = infj{Δ(Bαi | Ij(Objαi))} 
and then 
maxi=1,n{Δ(Bαi | lub{Ij}(Objαi))}  
= maxi=1,ninfj{Δ(Bαi | Ij(Objαi))} 
= infj maxi=1,n{Δ(Bαi | Ij(Objαi))} 
whence 
RP(lub{Ij})(Obj)  = lubα{Hα+infj maxi=1,n{Δ(Bαi | Ij(Objαi))}} 
= lubαlubj{Hα+maxi=1,n{Δ(Bαi | Ij(Objαi))}} 
Similarly, one has: 
lub{RP(Ij)}(Obj)  = lub{RP(Ij)(Obj)} 
= lubjlubα{Hα+maxi=1,n{Δ(Bαi | Ij(Objαi))}} 
Thus RP(lub{Ij}) = lub{RP(Ij)}. 
2.  Let S and Sj be the sets {H+ε | ...} in Definition 3.4.2 corresponding to 
TP(lub{Ij})(Obj) and TP(Ij)(Obj):  
S = { H+ε | Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn is a ground in-
stance of a clause in P, and ε = maxi=1,n{Δ(Bi | Bi*)} where 
Bi*∈lub{Ij}(Obji) for every i from 1 to n}, 
Sj = { H+ε | Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: Bn is a ground in-
stance of a clause in P, and ε = maxi=1,n{Δ(Bi | Bi*)} where 
Bi*∈Ij(Obji) for every i from 1 to n} 
It is sufficient to prove that S = ∪Sj. It is obvious that ∪Sj ⊆ S. We now prove 
that S ⊆ ∪Sj. Since I1 ≤ι I2 ≤ι ..., for each i from 1 to n, if Bi*∈lub{Ij}(Obji), 
then there exists ki∈N such that Bi*∈Ik(Obji). With k = maxi=1,n{ki}, one has 
Bi*∈Ik(Obji) for every i from 1 to n. Thus, if H+ε ∈ S then H+ε ∈ Sk for some 
k∈N, that is, S ⊆ ∪Sj. 

176 
Appendices
 
Proposition 3.4.5. If P is a restricted AFLP, then P has the finite fixpoint reach-
ability property with respect to the restricted semantics. 
Proof 
We prove that, if A ≤ι lfp(RP)(Obj) = lub{RP↑n(Obj) | n∈N} then ∃k∈N: A 
≤ι RP↑k(Obj).  
If A = ⊥, then A ≤ι RP↑k(Obj) is easily satisfied with k = 0. Thus, only cases 
with ⊥ <ι A need to be considered.  
If A ≤ι lub{RP↑n(Obj) | n∈N}, then A ≤ι lub{RP↑n(Obj) | n∈N and A* ≤ι 
RP↑n(Obj)} for any A* such that ⊥ ≤ι A* <ι A. It is sufficient to prove that the set 
{RP↑n(Obj) | n∈N and A* ≤ι RP↑n(Obj)}, where ⊥ ≤ι A* <ι A, is finite. 
Firstly, we define a set E of fuzzy set mismatching degrees as follows: 
1.  If Obj: B is in the body of a clause in P, then Δ(B | ⊥)∈E. 
2.  If Obj1: B is in the body of a clause and Obj2: H is the head of a clause in P, 
and Obj1 and Obj2 are unifiable, then Δ(B | H)∈E. 
3. If Obj1: H1 and Obj2: H2 are the heads of two clauses in P, Obj1 and Obj2 
are unifiable, where H1 = H2+ε or H2 = H1+ε, then ε∈E. 
It is clear that E is finite, because P is finite. 
Secondly, for every Obj∈BL, let HObj be the greatest annotation value such that 
Obj: HObj is the head of a ground instance of a clause in P. That is, for any H such 
that Obj: H is the head of a ground instance of a clause in P, H = HObj+ε for some 
ε∈[0, 1]. 
As noted after Proposition 2.5.2, if A+ε ≠ ⊥, then Δ(A | A+ε) = ε. Thus, one has 
RP↑n(Obj) = HObj+(ε1 + ε2 + ... + εm) with εi∈E (1 ≤ i ≤ m). Since E is finite, the 
number of values of HObj+(ε1 + ε2 + ... + εm) such that ⊥ ≤ι A* ≤ι HObj+(ε1 + ε2 + ... + 
εm) is also finite. That is, the set {RP↑n(Obj) | n∈N and A* ≤ι RP↑n(Obj)} is finite. 
 
Proposition 3.5.1. Let P be an AFLP, Obj: H ← Obj1: B1 & Obj2: B2 & ... & Objn: 
Bn be an annotation variable-free instance of a reductant of P, and θ be a substitu-
tion for object variables in this reductant. If (Obj1: B1 & Obj2: B2 & ... & Objn: 
Bn)θ is a logical consequence of P, then so is (Obj: H)θ. 
Proof 
It is sufficient to prove that, for every ground (i.e., both annotation variable-free 
and object variable-free) instance C of a reductant of P, if the body of C is a logi-
cal consequence of P, then so is its head. 
Let C be the following ground instance of a reductant of P: 
Obj: lub{H1+ξ1, H2+ξ2, ..., Hm+ξm}  
← Obj11: B11+ξ1 & Obj12: B12+ξ1 & ... & Obj1n: B1n+ξ1 &  
Obj21: B21+ξ2 & Obj22: B22+ξ2 & ... & Obj2n: B2n+ξ2 & ... & 
Objm1: Bm1+ξm & Objm2: Bm2+ξm & ... & Objmn: Bmn+ξm. 
where ξk∈[0, 1] and Obj: Hk ← Objk1: Bk1 & Objk2: Bk2 & ... & Objkn: Bkn is a 
ground instance of a clause in P (1 ≤ k ≤ m). 
Let I be a g-model of P. If the body of C is a logical consequence of P then, by 
Definition 3.3.6, Bki+ξk ∈ I(Objki) (1 ≤ k ≤ m, 1 ≤ i ≤ nk). Since Obj: Hk ← Objk1: 

A.2   Proofs for Chapter 3 
177
 
Bk1 & Objk2: Bk2 & ... & Objkn: Bkn is a ground instance of a clause in P, also by 
Definition 3.3.6, one has Hk+maxi=1,n{Δ(Bki | Bki+ξk)} ∈ I(Obj) (1 ≤ k ≤ m). 
By Proposition 2.5.2, Δ(Bki | Bki+ξk) ≤ ξk, whence maxi=1,n{Δ(Bki | Bki+ξk)} ≤ ξk 
and thus Hk+ξk ≤ι Hk+maxi=1,n{Δ(Bki | Bki+ξk)}. Since I(Obj) as an ideal is down-
ward closed, one has Hk+ξk ∈ I(Obj) (1 ≤ k ≤ m). Also as an ideal, I(Obj) is closed 
under finite least upper bounds, whence lub{H1+ξ1, H2+ξ2, ..., H +ξm} ∈ I(Obj), 
that is, Obj: lub{H1+ξ1, H2+ξ2, ..., Hm+ξm} is satisfied by I. 
Since I is an arbitrary g-model of P, this means Obj: lub{H1+ξ1, H2+ξ2, ..., 
Hm+ξm} is a logical consequence of P. 
 
Proposition 3.5.2. Any normal AFLP constraint is solvable. 
Proof 
Let C = σ1 ≤ι φ1 & σ2 ≤ι φ2 & ... & σm ≤ι φm be a normal AFLP constraint. One can 
assume that, if σi and σj (i < j) have the same variable then, for every k from i to j, 
σk also has this variable. This can be achieved by the re-grouping operation pre-
sented in Kifer and Subrahmanian (1992), which preserves the normality of con-
straints. The following algorithm for testing the satisfiability of C is adapted from 
that work for constraints on fuzzy set values: 
1.  If C is empty, then return satisfiable. 
2.  Let j0 be the maximal integer such that all σk’s, for k from 1 to j0, are either 
constants or have the same variable. Substitute 0 for each real number vari-
able and  for each fuzzy set variable occurring φ1, φ2, ..., φj. This substitu-
tion is applied throughout C. After this step, all φ1, φ2, ..., φj are ground. 
3.  If σk’s are constants (k from 1 to j0): 
(a) If σ1 ≤ι φ1 & ... & σj ≤ι φj, then set C to σj+1 ≤ι φj+1 & ... & σm ≤ι φm. Re-
index σi’s and φi’s so that their indexes will start with 1. Go back to 
step 1. 
(b)  Otherwise, return unsatisfiable. 
4.  If σk = Ak+ξ (k from 1 to j0): 
(a) Set ξ to maxk=1, j{Δ(Ak | φk)} (this setting is applied throughout C), then 
(b) Set C to σj+1 ≤ι φj+1 & ... & σm ≤ι φm. Re-index σi’s and φi’s so that their 
indexes will start with 1. Go back to step 1. 
5.  If σk = X (k from 1 to j0): 
(a) Set X to glbk=1, j{φk} (this setting is applied throughout C), then 
(b) Set C to σj+1 ≤ι φj+1 & ... & σm ≤ι φm. Re-index σi’s and φi’s so that their 
indexes will start with 1. Go back to step 1. 
The correctness of the substitution in step 2 and the termination of the algorithm 
are respectively due to the monotonicity and the computability of functions, if any, 
in φi’s. The correctness of the calculation of ξ in step 4(a) is due to property 3 in 
Proposition 2.5.3. 
 
Theorem 3.6.1. (AFLP Resolution Soundness) Let P be an AFLP and G be an 
AFLP goal. If G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn is a refutation of G and 
P, and ϕ is a solution for CG, then <θ1θ2 ... θn, ϕ> is a correct answer for G wrt P. 

178 
Appendices
 
Proof 
We prove the theorem by induction on refutation lengths. 
1.  n = 1: QG must have only one annotated object, namely O1: σ1, and C1 is a 
reductant Obj: φ, where φ is ground, such that θ1 is a most general unifier of 
O1 and Obj, and ϕ is a solution for CG = σ1 ≤ι φ & CG. 
By Proposition 3.5.1, Obj: φ is a logical consequence of P, whence 
Objθ1: φ is a logical consequence of P. Since θ1 is a most general unifier of 
O1 and Obj, and ϕ is a solution for σ1 ≤ι φ, every annotation variable-free 
instance of Objθ1: σ1ϕ = (O1: σ1)θ1ϕ = QGθ1ϕ is a logical consequence of 
P. Thus, <θ1, ϕ> is a correct answer for G wrt P. 
2.  Induction hypothesis: Suppose that it holds in the case of refutation length n 
− 1. 
3.  Let G = O1: σ1 & O2: σ2 & ... & Om: σm || CG and C1 = Obj: φ ← Obj1: φ1 & 
Obj2: φ2 & ... & Objr: φr , and suppose that  Ok: σk  is resolved by C1. Then 
G1 = [O1: σ1 & ... & Ok−1: σk−1 & (Obj1: φ1 & Obj2: φ2 & ... & Objr: φr) & 
Ok+1: σk+1 & ... & Om: σm]θ1 || (σk ≤ι φ & CG).  
On the basis of the induction hypothesis, <θ2 ... θn, ϕ> is a correct an-
swer for G1 wrt P. That is, every annotation variable-free instance of [O1: 
σ1 & ... & Ok−1: σk−1 & (Obj1: φ1 & Obj2: φ2 & ... & Objr: φr) & Ok+1: σk+1 & 
... & Om: σm]θ1θ2 ... θnϕ is a logical consequence of P, and ϕ is a solution 
for σk ≤ι φ & CG. 
Then, by Proposition 3.5.1, every annotation variable-free instance of 
(Obj: φ)θ1θ2 ... θnϕ is a logical consequence of P. Since θ1 is a most general 
unifier of Obj and Ok, and ϕ is a solution for σk ≤ι φ, one has that every an-
notation variable-free instance of (Ok: σk)θ1θ2 ... θnϕ and thus every one of 
QGθ1θ2 ... θnϕ are logical consequences of P. Therefore, <θ1θ2 ... θn, ϕ> is a 
correct answer for G wrt P. 
 
Proposition 3.6.1. Let G and C be respectively a goal and a reductant of an AFLP. 
If G is a normal AFLP goal, then any (unrestricted) resolvent of G and C is also a 
normal AFLP goal. 
Proof 
The proof is similar to the corresponding proof in Kifer and Subrahmanian (1992).  
See Definition 3.6.3. Since G and C have no variable in common, if σk contains 
a variable then this variable does not occur in φ. By the same reason, any variable 
on the left-hand side of inequalities in CG does not occur in φ. Thus, if CG is nor-
mal (i.e., G is normal) then σk ≤ι φ & CG is also normal. Here, the order of σk ≤ι φ 
and CG is significant, as noted after Definition 3.6.3. 
 
Lemma 3.6.1. (AFLP Mgu Lemma) Let P be an AFLP and G be an AFLP goal. If 
there exists an unrestricted refutation of G and P, then there exists a refutation of 
G and P. 
 
 

A.2   Proofs for Chapter 3 
179
 
Proof 
Let G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn be an unrestricted refutation of G 
and P. From the proof of the  Mgu lemma  in Lloyd (1987), there also exists  the 
derivation G <C1, θ1*> G1* <C2, θ2*> ... Gn−1* <Cn, θn*> Gn* where, for each i 
from 1 to n, θi* is a most general unifier, Gi* = Rθ*(Gi−1*, Ci) (G0* = G), and Gi = 
Gi*ρi with ρi being a substitution for object variables. Here, QG* = QG which is 
empty, and CG* = CG which is solvable and has a solution, whence G <C1, θ1*> 
G1* <C2, θ2*> ... Gn−1* <Cn, θn*> Gn* is a refutation of G and P. 
 
Lemma 3.6.2. (AFLP Lifting Lemma) Let P be an AFLP, G be a normal AFLP 
goal, and <θ, ϕ> be an answer for G wrt P. If there exists a refutation of Gθϕ and 
P, then there exists a refutation of G and P. 
Proof 
Let Gθϕ <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn be a refutation of Gθϕ and P. 
Then there exists the derivation Gθ <C1, θ1> G1* <C2, θ2> ... Gn−1* <Cn, θn> Gn* 
where, for each i from 1 to n, Gi* = Rθ(Gi−1*, Ci) (G0* = Gθ) and Gi = Gi*ϕ. Here, 
QG* = QG which is empty and CG = CG*ϕ, whence CG* has a solution, because CG 
does. It is also solvable, because Gn* is a normal AFLP goal due to the normality 
of G and Proposition 3.6.1. Thus, Gθ <C1, θ1> G1* <C2, θ2> ... Gn−1* <Cn, θn> Gn* 
is a refutation of Gθ and P. 
Further, from the proof of the Lifting lemma in Lloyd (1987), one obtains G 
<C1, θθ1> G1* <C2, θ2> ... Gn−1* <Cn, θn> Gn* as an unrestricted refutation of G 
and P, whence there exists a refutation of G and P, on the basis of the AFLP Mgu 
lemma. 
 
Theorem 3.6.2. (AFLP Resolution Completeness) Let P be an AFLP and G be a 
normal AFLP goal. If there exists a correct answer for G wrt P, then there exists a 
refutation of G and P. 
Proof 
In the proof, we apply the Mgu and Lifting lemmas for annotated fuzzy logic pro-
grams presented above (Lemmas 3.6.1 and 3.6.2), as in proving the completeness 
of SLD-resolution style proof procedures for classical logic programs and anno-
tated logic programs. 
Since there exists a correct answer for G wrt P, there also exists a ground cor-
rect answer, i.e., ground substitutions θ and ϕ such that Gθϕ is variable-free and 
<θ, ϕ> is a correct answer for G wrt P. Firstly, we prove that there exists an unre-
stricted refutation of Gθϕ and P. 
Let QG = O1: σ1 ∧ O2: σ2 ∧ ... ∧ Om: σm. Since QGθϕ is a logical consequence of 
P, there exists n ≥ 1 such that σiϕ ∈ TP↑n(Oiθ) for every i from 1 to m, on the ba-
sis of Theorem 3.4.1 and the finite fixpoint reachability of AFLPs with respect to 
the general semantics. We prove that there exists an unrestricted refutation of Gθϕ 
and P by induction on such a number of upward iterations of TP : 
1.  n = 1: one has σiϕ ∈TP↑1(Oiθ), for every i from 1 to m. Hence, there must ex-
ist reductants Obji: φi’s of P, where φi’s  are  ground, and  unifiers θi’s  such 

180 
Appendices
 
 that, for every i  from 1  to m, Objiθi = Oiθ and σiϕ ≤ι φi. Then the following 
unrestricted refutation of Gθϕ and P can be constructed: 
Gθϕ <C1, θ1> G1 <C2, θ2> ... Gm−1 <Cm, θm> Gm 
where Ci = Obji: φi (1 ≤ i ≤ m), Gi = Oi+1θ: σi+1ϕ & ... & Omθ: σmϕ || σiϕ ≤ι φi & ... 
& σ1ϕ ≤ι φ1 & CGϕ (1 ≤ i ≤ m − 1), QG is empty, and CG = σmϕ ≤ι φm & ... & σ1ϕ 
≤ι φ1 & CGϕ is ground and holds. 
2.  Induction hypothesis: Suppose that it holds in the case of n − 1 upward itera-
tions of TP . 
3.  One has σiϕ ∈TP↑n(Oiθ), for every i from 1 to m. Thus, there must exist reduc-
tants Obji: φi ← Obji1: φi1 & Obji2: φi2 & ... & Objir: φir of P, unifiers θi’s and 
substitutions ϕi’s such that, for every i from 1 to m: (1) Objiθi = Oiθ, φiϕi is 
ground and σiϕ ≤ι φiϕi; and (2) for every j from 1 to ri, Objijθi: φijϕi is ground 
and φijϕi ∈TP↑(n − 1)(Objijθi). After m sequential resolution steps on O1θ: σ1ϕ, 
..., Omθ: σmϕ, one obtains the following unrestricted resolvent: 
G* = [(Obj11: φ11 & Obj12: φ12 & ... & Obj1r: φ1r) & ... & (Objm1: φm1 & Objm2: 
φm2 & ... & Objmr: φmr)]θ1 ... θm || σmϕ ≤ι φm & ... & σ1ϕ ≤ι φ1 & CGϕ. 
On the basis of the induction hypothesis, there exists an unrestricted refutation of 
G*ϕ1ϕ2 ... ϕm and P. Applying the AFLP Mgu lemma and then the AFLP Lifting 
lemma, one has the result that there exists a refutation of G* and P. Thus, there 
exists an unrestricted refutation of Gθϕ and P.  
Finally, applying the AFLP Mgu lemma and then the AFLP Lifting lemma 
again, one has the result that there exists a refutation of G and P. 
 
Proposition 3.8.1. Let P be a generalized AFLP, Obj: H ← Obj1: B1 & Obj2: B2 & 
... & Objn: Bn be an annotation variable-free instance of a reductant of P, and θ be 
a substitution for object variables in this reductant. If (Obj1: B1 & Obj2: B2 & ... & 
Objn: Bn)θ is a logical consequence of P, then so is (Obj: H)θ. 
Proof 
It is sufficient to prove that, for every ground (i.e., both annotation variable-free 
and object variable-free) instance C of a reductant of P, if the body of C is a logi-
cal consequence of P, then so is its head. 
Let C be the following ground instance of a reductant of P: 
Obj: lub{H1+⊕(1− α1, ξ1), H2+⊕(1− α2, ξ2), ..., Hm+⊕(1− αm, ξm)}  
← Obj11: B11+ξ1 & Obj12: B12+ξ1 & ... & Obj1n: B1n+ξ1 &  
Obj21: B21+ξ2 & Obj22: B22+ξ2 & ... & Obj2n: B2n+ξ2 & ... & 
Objm1: Bm1+ξm & Objm2: Bm2+ξm & ... & Objmn: Bmn+ξm 
where ξk∈[0, 1] and Obj: Hk ← Objk1: Bk1 & Objk2: Bk2 & ... & Objkn: Bkn [αk] is a 
ground instance of a clause in P (1 ≤ k ≤ m). 
Let I be a model of P. If the body of C is a logical consequence of P then, by 
Definition 3.8.2, Bki+ξk ∈ I(Objki) (1 ≤ k ≤ m, 1 ≤ i ≤ nk). Since Obj: Hk ← Objk1: 
Bk1 & Objk2: Bk2 & ... & Objkn: Bkn [αk] is a ground instance of a clause in P, also 
by Definition 3.8.2, one has Hk+⊕(1− αk, maxi=1,n{Δ(Bki | Bki + ξk)}) ∈ I(Obj) (1 ≤ 
k ≤ m). 

A.3   Proofs for Chapter 4 
181
 
By Propositions 2.5.2, 2.6.6 and 2.6.8, Δ(Bki | Bki+ξk) ≤ ξk, whence maxi=1,n{Δ(Bki 
| Bki+ξk)} ≤ ξk. Then, due to the monotonicity of the t-conorm ⊕, 
⊕(1− αk, maxi=1,n{Δ(Bki | Bki+ξk)}) ≤ ⊕(1− αk, ξk), whence Hk + ⊕(1− αk, ξk) 
≤ι Hk+⊕(1− αk, maxi=1,n{Δ(Bki 
| 
Bki+ξk)}). 
Since I(Obj) 
as an 
ideal 
is  
downward closed, one has Hk+⊕(1− αk, ξk) ∈ I(Obj) (1 ≤ k ≤ m). Also  
as an ideal, I(Obj) is closed under finite least upper bounds, whence 
lub{H1+⊕(1− α1, ξ1), H2+⊕(1− α2, ξ2), ..., Hm+⊕(1− αm, ξm)}∈ I(Obj), that is, Obj: 
lub{H1+⊕(1− α1, ξ1), H2+⊕(1− α2, ξ2), ..., Hm+⊕(1− αm, ξm)} is satisfied by I. 
Since I is an arbitrary model of P, this means Obj: lub{H1+⊕(1− α1, ξ1), 
H2+⊕(1− α2, ξ2), ..., Hm+⊕(1− αm, ξm)} is a logical consequence of P. 
A.3   Proofs for Chapter 4 
Proposition 4.4.1. For any FCGP P, TP is monotonic, that is, if I1 ≤ι I2 then TP(I1) 
≤ι TP(I2). 
Proof 
See Definition 4.4.1. Let if u then v be a clause in P and π12 be an ideal FCG pro-
jection from I1 to I2. Suppose that v+επ ∈ SP(I1) where π1 is an FCG projection 
from u to a principal instance g1 of I1. Since I1 ≤ι I2, there must exist a principal in-
stance g2 of I2 such that a fuzzy value in each vertex in g1 is the same as that in the 
corresponding vertex in g2 and g1 ≤ι g2 by π12. Thus, there exists π2 = π12°π1 as an 
FCG projection from u to g2 where επ = επ, whence v+επ = v+επ ∈ SP(I2).  
Furthermore, if c∈VC, c*∈VC and coref(c, c*), then coref(c*, origin(π1c)) in 
SP(I1)∪I1, and coref(c*, origin(π12××°π1c)) in SP(I2)∪I2. Thus, SP(I1)∪I1 ≤ι SP(I2)∪I2 
by π12∪π0 where π0 is an ideal FCG projection that maps each v+επ ∈ SP(I1) to the 
corresponding v+επ ∈ SP(I2), whence TP(I1) ≤ι TP(I2). 
 
Proposition 4.4.2. Let P be an FCGP and I be an interpretation. Then I is a model 
of P iff TP(I) ≤ι I by an ideal FCG projection πI that maps the occurrence of I in 
TP(I) to I itself. 
Proof 
Let if u then v be a clause in P and π be an FCG projection from u to a principal 
instance of I. From Definition 4.3.6 and Definition 4.4.1, if I is a model of P, then 
there is an ideal FCG projection π* from v+επ ∈ SP(I) to I. Moreover, if c∈VC, 
c*∈VC and coref(c, c*), then coref(c*, origin(πc)) in SP(I)∪I by Definition 4.4.1, 
and π*c* = origin(πc) by Definition 4.3.6. Thus, there is an ideal FCG projection 
πI from TP(I) = norm(SP(I)∪I) to I that comprises those π*’s and maps the occur-
rence of I in TP(I) to I itself. 
On the other hand, let πI be an ideal FCG projection from TP(I) to I that maps 
the occurrence of I in TP(I) to I itself. If c∈VC, c*∈VC and coref(c, c*), then 
coref(c*, origin(πc)) in SP(I)∪I by Definition 4.4.1, whence πIc* = origin(πc) by 
the property of πI. Thus, by Definition 4.3.6, I satisfies if u then v as an arbitrary 
clause in P, whence I is a model of P. 

182 
Appendices
 
Theorem 4.4.1. For any FCGP P, TP↑ω is the minimal model (modulo ideal FCG 
equivalence) of P. 
Proof 
We recall that TP↑0 ≤ι TP↑1 ≤ι ... and, in TP↑ω = norm{TP↑n | n∈N}, there are 
coreference links between concept vertices in TP↑n and corresponding ones in the 
occurrence of TP↑n in TP↑(n + 1).  
Firstly, we prove that TP↑ω is a model of P. Let if u then v be a clause in P and 
π be an FCG projection from u to a principal instance of TP↑ω = norm{TP↑n | 
n∈N}. Since u is finite and all fuzzy values in u are principal ideals, there must 
exist an FCG projection πk from u to a principal instance of some TP↑k with 
επ = επ. Thus, SP(norm{TP↑n})∪norm{TP↑n} ≤ι norm((∪SP(TP↑n))∪norm{TP↑n}) 
by an ideal FCG projection that maps norm{TP↑n} to itself and each v + επ 
∈ SP(norm{TP↑n}) to the corresponding v + επ ∈ SP(TP↑k) for some k ∈ N. Con-
sequently, one has: 
TP(norm{TP↑n})  
=  norm(SP(norm{TP↑n})∪norm{TP↑n})  
≤ι  norm((∪SP(TP↑n))∪norm{TP↑n})  
(by an ideal FCG projection that maps the occurrence of norm{TP↑n} in 
TP(norm{TP↑n}) to itself) 
=  norm{SP(TP↑n)∪TP↑n}  
=  norm{TP(TP↑n)}  
=  norm{TP↑(n + 1)}  
=  norm{TP↑n}  
That is, TP(TP↑ω) ≤ι TP↑ω by an ideal FCG projection that maps the occurrence of 
TP↑ω in TP(TP↑ω) to itself. Thus, by Proposition 4.4.2, TP↑ω is a model of P. 
We now prove that TP↑ω is the minimal model (modulo ideal FCG equiva-
lence) of P. Let I be a model of P. It is obvious that TP↑0 = []  ≤ι  I. Supposing that 
TP↑n  ≤ι  I, one has TP↑(n + 1) = TP(TP↑n) ≤ι TP(I), because TP is monotonic. 
Since I is a model of P, by Proposition 4.4.2, one has TP(I) ≤ι I, whence TP↑(n + 1) 
≤ι I. Thus, by induction, TP↑n ≤ι I for every n∈N. Therefore, TP↑ω = norm{TP↑n} 
≤ι I, whence TP↑ω is the minimal model (modulo ideal FCG equivalence) of P. 
 
Proposition 4.6.1. Let P be an FCGP, if u then v be an annotation variable-free 
instance of a reductant of P, and ρ and ϖ be respectively a referent specialization 
and a coreference partition on concepts with VAR generic markers in this reduc-
tant. If ρϖu is a logical consequence of P, then so is ρϖv. 
Proof 
The main concern is fuzzy values and real number variables in an FCGP reduc-
tant. They have the same declarative semantics as those in an AFLP reductant or 
order-sorted AFLP reductant, on the basis of the same fuzzy rule model. Thus, the 
proof, as well as that of Proposition 3.7.1 for order-sorted AFLP reductants, is 
similar to the proof of Proposition 3.5.1 for AFLP reductants. 

A.3   Proofs for Chapter 4 
183
 
Suppose the following annotation variable-free instance of a reductant of P: 
if ϖ0[u1+ξ1   u2+ξ2   ...   um+ξm] then ϖ0[v1+ξ1   v2+ξ2   ...   vm+ξm] 
where ξk∈[0, 1] and if uk then vk is a clause in P (1 ≤ k ≤ m). 
Let I be a model of P. If ρϖϖ0[u1+ξ1   u2+ξ2   ...   um+ξm] is a logical conse-
quence of P then, by Definition 4.3.6, ρϖϖ0(uk + ξk) ≤ι I by some ideal FCG pro-
jection πk (1 ≤ k ≤ m). Since I is an ideal FCG, there exists a principal instance gk 
of I such that each fuzzy value in gk is the same as the corresponding one (wrt πk) 
in ρϖϖ0(uk + ξk). Thus, πk also defines an FCG projection from ρϖϖ0uk to gk with 
mismatching degree επ where, on the basis of Propositions 2.5.2, 2.6.6 and 2.6.8, 
επ ≤ ξk..  
Since if uk then vk is a clause in P, also by Definition 4.3.6, one has 
ρϖϖ0(vk+επ) ≤ι I, whence ρϖϖ0(vk+ξk) ≤ι I (1 ≤ k ≤ m) and thus ρϖϖ0[v1+ξ1   
v2+ξ2   ...   vm+ξm] is satisfied by I. This means ρϖϖ0[v1+ ξ1   v2+ξ2   ...   vm+ξm] is a 
logical consequence of P, because I is an arbitrary model of P. 
 
Proposition 4.7.1. The condition on θ in Definition 4.7.3 is necessary and suffi-
cient so that NON-VAR generic markers do not occur in FCGP resolvents. 
Proof  
Necessary: if the condition does not hold, then NON-VAR generic markers will oc-
cur in ρθϖθδθG. 
Sufficient: The condition guarantees that NON-VAR generic markers do not oc-
cur in ρθϖθδθG, if they do not occur in G before (e.g. when G is a query, i.e., an 
original goal). By Definition 4.6.3, for a reductant if u then v, no VAR generic 
marker in v is bound to a NON-VAR one. This guarantees that NON-VAR generic 
markers do not occur in ρθϖθu.  
 
Theorem 4.7.1. (FCGP Resolution Soundness) Let P be an FCGP and G be an 
FCGP goal. If G <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn is a refutation of G and 
P, and ϕ is a solution for CG, then <ρθρθ ... ρθ, ϖθϖθ ... ϖθ, ϕ> is a correct answer 
for G wrt P. 
Proof 
We prove by induction on refutation lengths that ϕ is a solution for CG and every 
annotation variable-free instance of ρθρθ ... ρθϖθϖθ ... ϖθϕQG is a logical conse-
quence of P: 
1.  n = 1: QG is empty, CG= Cθ & CG is satisfied by ϕ, whence ϕ is a solution for 
CG, and C1 must have no body, whence all generic markers in C1 are NON-VAR 
ones (Definition 4.6.1). Thus, θ1 also defines an FCG projection with mis-
matching degree 0 from each annotation variable-free instance of ρθϖθϕQG to 
norm(C1). By Proposition 4.6.1, C1 is a logical consequence of P, whence 
every annotation variable-free instance of ρθϖθϕQG is also a logical conse-
quence of P. Thus, <ρθ, ϖθ, ϕ> is a correct answer for G wrt P. 
2.  Induction hypothesis: Suppose that it holds in the case of refutation length  
n − 1. 

184 
Appendices
 
3.  Let G = QG || CG, C1 = if u then v, ρ = ρθρθ ... ρθ and ϖ = ϖθϖθ ... ϖθ. On the 
basis of the induction hypothesis, ϕ is a solution for Cθ & CG, whence for CG, 
and   every   annotation   variable-free   instance   of    ρϖϕ[δθQG  u] is a logi-
cal consequence of P, whence every one of ρϖϕu is also a logical consequence 
of P. By Proposition 4.6.1, every annotation variable-free instance of ρϖϕv is a 
logical consequence of P, whence every one of ρϖϕ[δθQG  v] is also a logical 
consequence of P. 
 
    What remains is to prove that every annotation variable-free instance of 
ρϖϕQG has an FCG projection with mismatching degree 0 to the correspond-
ing annotation variable-free instance of norm(ρϖϕ[δθQG  v]). In fact, the verti-
ces in ρϖϕQG that remain after the first step of the refutation can be projected 
to themselves in ρϖϕδθQG, with mismatching degree 0. Meanwhile, those that 
are deleted by δθ can be projected to the vertices in norm(ρϖϕv) that they are 
unified with by θ1. The mismatching degrees of these projections are also 0, 
because ϕ is a solution for Cθ. Thus, every annotation variable-free instance of 
ρϖϕQG is a logical consequence of P, whence <ρ, ϖ, ϕ> is a correct answer 
for G wrt P. 
 
Lemma 4.7.1. (FCGP Lifting Lemma) Let P be a normal FCGP, G be a normal 
FCGP goal, and <ρ, ϖ, ϕ> be an answer for G wrt P. If there exists a refutation of 
ρϖϕG and P, then there exists a refutation of G and P. 
Proof 
Let ρϖϕG <C1, θ1> G1 <C2, θ2> ... Gn−1 <Cn, θn> Gn be a refutation of ρϖϕG and 
P. Then there exists the derivation G <C1, θ1> G1* <C2, θ2> ... Gn−1* <Cn, θn> Gn* 
where, for each i from 1 to n, Gi* = Rθ(Gi−1*, Ci) (G0* = G), QG = ρϖϕQG* and CG 
= ϕCG*. Here, QG* = QG which is empty, and CG = ϕCG* whence CG* has a solu-
tion, because CG does, and is solvable, because CG is a normal FCGP constraint 
due to the normality of G and P and Proposition 4.7.2. Thus, G <C1, θ1> G1* <C2, 
θ2> ... Gn−1* <Cn, θn> Gn* is a refutation of G and P. 
 
Theorem 4.7.2. (FCGP Resolution Completeness) Let P be a normal FCGP and G 
be a normal FCGP goal. If there exists a correct answer for G wrt P, then there ex-
ists a refutation of G and P. 
Proof 
In the proof, we apply the Lifting lemma for FCG programs presented above 
(Lemma 4.7.1). 
Since there exists a correct answer for G wrt P, there also exists an annotation 
variable-free correct answer, i.e., an answer <ρ, ϖ, ϕ> such that ρϖϕG is annota-
tion variable-free, ϕCG holds and ρϖϕQG is a logical consequence of P. First, we 
prove that there exists a refutation of ρϖϕG and P.  
Since ρϖϕQG is a logical consequence of P, there exists n ≥ 1 such that ρϖϕQG 
≤ι TP↑n, on the basis of Theorem 4.4.1. We now prove that there exists a refuta-
tion of ρϖϕG and P by induction on such a number of upward iterations of TP: 

A.4   Proofs for Chapter 5 
185
 
1.  n = 1: ρϖϕQG ≤ι TP↑1. Thus, there must exist reductants C1, C2, ..., Cm of P 
which have no bodies and are annotation variable-free such that ρϖϕQG 
≤ι norm([C1 C2 ... Cm]) by an FCG projection π (with mismatching degree 0). 
For every i from 1 to m, let θi be the unification with norm(Ci) of the normal-
ized subgraph of ρϖϕQG that is projected to norm(Ci) by π, where Cθ holds. 
Then, the following refutation of ρϖϕG and P can be constructed: 
ρϖϕG <C1, θ1> G1 <C2, θ2> ... Gm−1 <Cm, θm> Gm 
where QG is empty, and CG= Cθ & Cθ & ... & Cθ & ϕCG is annotation variable-
free and holds. 
2.  Induction hypothesis: Suppose that it holds in the case of n − 1 upward itera-
tions of TP . 
3.  Assume ρϖϕQG ≤ι TP↑n. Then, there must exist reductants Ci = if ui then vi of 
P (1 ≤ i ≤ m), a referent specialization ρ* and a coreference partition ϖ* on 
concepts with VAR generic markers in Ci’s, and a substitution ϕ* for annota-
tion variables in Ci’s such that: (1) ϕ*Ci’s are annotation variable-free and 
ρϖϕQG ≤ι norm(ρ*ϖ*ϕ*[v1 v2 ... vm]) by an FCG projection π (with mismatch-
ing degree 0); and (2) norm(ρ*ϖ*ϕ*[u1 u2 ... um]) ≤ι TP↑(n − 1). 
For every i from 1 to m, let θi be the unification with norm(vi) of the normalized 
subgraph of ρϖϕQG that is projected to norm(ρ*ϖ*ϕ*vi) by π, where ϕ*Cθ holds.  
Let ρ’ and ϖ’ respectively denote ρθρθ ... ρθ and ϖθϖθ ... ϖθ. If ρ’ binds an in-
dividual marker in ρϖϕQG to a concept with a VAR generic marker in vi’s, then ρ* 
must also bind this individual marker to the concept, because ρϖϕQG ≤ι 
norm(ρ*ϖ*ϕ*[v1 v2 ... vm]). By the same reason, if ϖ’ groups two concepts in vi’s 
in one coreference partition, then ϖ* must also group the two concepts in one 
coreference partition. Therefore, one has ρ’ϖ’ϕ*[v1 v2 ... vm] ≤ι norm(ρ*ϖ*ϕ*[v1 
v2 ... vm]), whence ρ’ϖ’ϕ*[u1 u2 ... um] ≤ι norm(ρ*ϖ*ϕ*[u1 u2 ... um]). 
After m sequential resolution steps on C1, C2, ..., Cm, one obtains the resolvent: 
G* = ρ’ϖ’[u1 u2 ... um] || Cθ & Cθ & ... & Cθ & ϕCG. 
Here, ϕ*G* is annotation variable-free. Also, ϕ*QG* = ρ’ϖ’ϕ*[u1 u2 ... um] ≤ι 
norm(ρ*ϖ*ϕ*[u1 u2 ... um]) ≤ι TP↑(n − 1) and ϕ*CG* = ϕ*(Cθ & Cθ & ... & Cθ & 
ϕCG) holds. Thus, on the basis of the induction hypothesis, there exists a refuta-
tion of ϕ*G* and P. Then, by the FCGP Lifting lemma, there exists a refutation of 
G* and P, whence there exists a refutation of ρϖϕG and P.  
Finally, applying the FCGP Lifting lemma again, one has the result that there 
exists a refutation of G and P. 
A.4   Proofs for Chapter 5 
Proposition 5.2.1. For any fuzzy number A: 
1. A ≤ at least A and B ⊆ at least A for every B such that A ≤ B, and 
2. at most A ≤  A and B ⊆ at most A for every B such that B ≤ A. 

186 
Appendices
 
Proof 
1.  (a)  Suppose the extension principle is applied for fuzzy arithmetic. 
According to Definition 5.2.1, one has: 
∀z∈R: μat least A(z) = sup{μA(y) | y ≤ z} ≥ μA(z) 
Meanwhile, for every z∈R:  
μmin{A, at least A}(z) = sup{min{μA(x), μat least A(y)} | z = min{x, y}} 
= max{sup{min{μA(z), μat least A(y)} | z ≤ y}, 
sup{min{μA(x), μat least A(z)} | z ≤ x}} 
= max{μA(z), 
sup{min{μA(x), μat least A(z)} | z ≤ x}} 
For every point (z, μA(z)) in the non-decreasing part of μA(), 
sup{min{μA(x), μat least A(z)} | z ≤ x} = μat least A(z) = μA(z). For every other 
point (z, μA(z)) in the decreasing part of μA(), sup{min{μA(x), μat least A(z)} | 
z ≤ x} = μA(z). Therefore ∀z∈R: μmin{A, at least A}(z) = μA(z), i.e., min{A, at 
least A} = A or  A ≤ at least A. 
    We now prove that, if B ⊆ at least A does not hold, then neither does  
A ≤ B. If ∃z∈R: B(z) > at least A(z), then the point (z, μA(z)) must be in the 
non-decreasing part of μA(), because at least A(z) = 1 otherwise. One has: 
μmin{A, B}(z)  = sup{min{μA(x), μB(y)} | z = min{x, y}} 
= max{sup{min{μA(z), μB(y)} | z ≤ y}, 
sup{min{μA(x), μB(z)} | z ≤ x}} 
≥ sup{min{μA(x), μB(z)} | z ≤ x} 
= μB(z) 
> μA(z) 
and thus min{A, B} ≠ A, i.e., A ≤ B does not hold. 
 
(b) If the α-cut interval arithmetic method is applied and Aα = [a, b], then: 
min{A, at least A}α = min{Aα, at least Aα}  
= min{[a, b], {[a, +∞)} = [a, b] = Aα, 
whence min{A, at least A} = A, i.e., A ≤ at least A. 
Meanwhile, if A ≤ B, Aα = [a, b], and Bα  = [c, d], then Aα ≤ Bα. Therefore 
a ≤ c and thus Bα ⊆ at least Aα, whence B ⊆ at least A. 
2.  The proof is similar. 
 
Proposition 5.2.2. For any fuzzy number A: 
1. at least A = A if A is a non-decreasing fuzzy number, and  
2. at most A = A if A is a non-increasing fuzzy number. 
Proof 
1.  (a)  Suppose the extension principle is applied for fuzzy arithmetic. 
 
According to Definition 5.2.1, one has: 
∀x∈R: μat least A(x) = sup{μA(y) | y∈R and y ≤ x} = μA(x) 
because A is a non-decreasing fuzzy number. Thus at least A = A. 
 
 

A.4   Proofs for Chapter 5 
187
 
(c) If the α-cut interval arithmetic method is applied, then: 
(at least A)α = at least Aα = [a, +∞) = Aα 
because A is a non-decreasing fuzzy number.   
2.  The proof is similar. 
 
Proposition 5.2.3. For any fuzzy number A and positive fuzzy number B: 
1. at least (A/B) = (at least A) / B, and  
2. at most (A/B) = (at most A) / B. 
Proof 
1.  (a)  Suppose the extension principle is applied for fuzzy arithmetic. 
 
Since B is positive, only μB(y) where y > 0 need to be counted in the fol-
lowing:  
∀t∈R: μat least (A/B)(t) = sup{μA/B(z) | z ≤ t} = sup{sup{min{μA(x), μB(y)} 
| z =  x/y} | z ≤ t} = sup{min{μA(x), μB(y)} | x/y ≤ t} = 
sup{sup{min{μA(z), μB(y)} | z ≤ x} | t = x/y} = sup{min{sup{μA(z) | z ≤ 
x}, μB(y)} | t = x/y} = sup{min{μat least A(x), μB(y)} | t = x/y} = μat least A / 
B(t), whence at least (A/B) = at least A / B. 
 
(b)  If the α-cut interval arithmetic method is applied, then let Aα = [a, b] and 
Bα = [c, d]. Then one has: 
(at least (A/B))α = at least (Aα/Bα) = at least ([a, b]/[c, d]) = at least 
([a/d, b/c]) = [a/d, +∞) = [a, +∞)/[c, d] = (at least Aα) / Bα = (at least 
A)α / B α.   
2.  The proof is similar. 
 
Theorem 5.4.1. Let G and H be two plain CGs with no coreference links. If G ≤ι 
H, then G is a logical consequence of H. 
Proof 
It is proved by showing that the expansion of G can be derived from the expansion 
of H using the direct inference rules on CGs given in Sowa (1984). 
1. If both G and H are existential CGs, then the theorem holds on the basis of 
Theorem 4.3.7 in Sowa (1984). Note that, when CGs are existentially quanti-
fied, the universal CG projection performs as the existential one.  
2. Otherwise, in general, let Ge and He be respectively the defining expansions of 
G and H, where the negative context could be empty (i.e., in the case of an ex-
istential CG):  
Ge = ¬[ c∃1 c∃2 ... c∃m ¬[G∃]]    He = ¬[ c’∃1 c’∃2 ... c’∃m ... c’∃n ¬[H∃]] 
According to Definition 5.4.2, one has n ≥ m, each universal concepts ci in G 
can be projected to one or more universal concepts c’j in H, and some existen-
tial concepts in G can be projected to some universal concepts c’j in H. For 
each partition S of universal concepts in H that are coreferent after projection: 
 

188 
Appendices
 
(i)  If Π-1S contains a universal concept in G, then the corresponding subset of 
S in {c’∃1, c’∃2, ... , c’∃m, ..., c’∃n} is unified and type-restricted into one ex-
istential concept whose type is equal to that of the universal concept in  
Π-1S, or 
(ii) If Π-1S contains only existential concepts in G, then the corresponding 
subset of S in {c’∃1, c’∃2, ... , c’∃m, ..., c’∃n} is unified and type-restricted 
into one existential concept whose type is equal to the intersection of the 
types of the concepts S and the types of the existential concepts in G. 
Since that type intersection is not absure, the resulting concept can be 
erased from the negative context of He.  
Then the coreferent concepts in He are joined and type-restricted accordingly, 
deriving ¬[ c∃1 c∃2 ... c∃m ¬[H’∃]] where H’∃ ≤ G∃, which entails ¬[ c1∃ c2∃ ... 
cm∃ ¬[G∃]] = Ge with coreference links attached to concepts in H’∃ are trans-
ferred to the corresponding concepts in G∃. 
 
Lemma 5.4.1. If ¬[u ¬[v]] is true, where u and v are existential CGs and there 
may be coreference links between them, then the following inference rules are 
sound: 
1.  In a positive (i.e., evenly enclosed context), u is replaced by v and corefer-
ence links attached to concepts in u are transferred to the corresponding 
concepts in v. 
2.  In a negative (i.e., oddly enclosed context), v is replaced by u and corefer-
ence links attached to concepts in v are transferred to the corresponding 
concepts in u. 
Proof  
1.  The proof is similar to that of a case in Theorem 4.3.7 in Sowa (1984).  
2.  This is dual to case 1. 
 
Theorem 5.4.2. Let G be a universal CG and H be any plain CG, with no corefer-
ence links in G and H. Then, any J∀(G, H) is a logical consequence of {G, H}. 
Proof  
Assume that H is also a universal CG. The proof is similar otherwise. Let Ge and 
He be respectively the defining expansions of G and H: 
Ge = ¬[ c∃1 ... c∃i c∃i+1 ... c∃j c∃j+1 ... c∃n ¬[G∃]]    
He = ¬[ c’∃1 ... c’∃ i ... c’∃ m ¬[H∃]] 
supposing that c1, ... , ci are the universal concepts in G that are joined with the 
universal concepts c’1, ... , c’i in H, and ci+1, ... , cj are the universal concepts in G 
that are joined with existential concepts in H. So, the defining expansion of  
J∀(G, H) is: 
J∀(G, H)e = ¬[ c’∃1 ... c’∃ i ... c’∃m c∃j+1 ... c∃n ¬[J∃(G∃, H∃)]] 
where J∃(G∃, H∃) is the conventional join of G∃ and H∃ that corresponds to  
J∀(G, H). 

A.4   Proofs for Chapter 5 
189
 
Then J∀(G, H)e is provable from Ge and He by the CG inference rules as  
follows: 
{Ge, He} 
⇒ ¬[H∃ c∃1 ... c∃i c∃i+1 ... c∃j c∃j+1 ... c∃n ¬[G∃]]    
(Insertion) 
H∃ is inserted into the negative context of Ge 
⇒ ¬[H∃  c∃1 ... c∃i c∃i+1 ... c∃j c∃j+1 ... c∃n ¬[G∃ H∃]]    
(Iteration) 
H∃ is copied into ¬[G∃] 
⇒ ¬[H∃ c∃j+1 ... c∃n ¬[G’∃ H∃]]    
(Coreferent Join) 
c∃1, ..., c∃i are type-restricted to and joined with c’∃1 ... c’∃i in H∃, 
c∃i+1, ..., c∃j are type-restricted to and joined with the corresponding existential 
concepts in H∃, then G∃ is type-restricted accordingly to become G’∃  
⇒ ¬[H∃ c∃j+1 ... c∃n ¬[J∃(G∃, H∃)]]    
(Coreferent Join) 
G’∃ and H∃ are coreferent-joined accordingly 
⇒ ¬[c’∃1 ... c’∃i ... c’∃m c∃j+1 ... c∃n ¬[J∃(G∃, H∃)]]  
(Lemma 5.4.1) 
≡ J∀(G, H)e     
H∃ is replaced by c’∃1 ... c’∃i ... c’∃m, and coreference links 
attached to concepts in v∃ are transferred accordingly to c’∃1, ..., c’∃i, ..., c’∃m. 
 
Proposition 5.6.1. A generally quantified FCG G with a relative quantifier Q en-
tails a generally quantified FCG G* obtained from G by generalizing it except for 
its generally quantified concept, and replacing Q with at least Q. 
Proof 
Let the expansion of G be if F then H [Q]. Then the expansion of G* is if F then 
H* [at least Q], where H* is a generalization of H. One has Pr(H* | F) ≥  Pr(H | 
F), whence Pr(H | F) = Q entails Pr(H* | F) =  at least Q. Thus if F then H [Q] 
entails if F then H* [at least Q], i.e., G entails G*. 
 
Proposition 5.6.2. A generally quantified FCG G with a relative quantifier Q en-
tails a generally quantified FCG G* obtained from G by specializing it except for 
its generally quantified concept, and replacing Q with at most Q. 
Proof 
Let the expansion of G be if F then H [Q]. Then the expansion of G* is if F then 
H* [at most Q], where H* is a specialization of H. One has Pr(H* | F) ≤  Pr(H | 
F), whence Pr(H | F) = Q entails Pr(H* | F) =  at most Q. Thus if F then H [Q] 
entails if F then H* [at most Q], i.e., G entails G*. 
 
Proposition 5.6.3. A universally quantified FCG G entails a universally quantified 
FCG G* obtained from G by specializing its lambda FCG. 
Proof  
Let the expansion of G be if F then H [1]. Then the expansion of G* is if F* then 
H* [1], where F* and H* are specializations of F and H, respectively, with their 

190 
Appendices
 
two coreferent concepts corresponding to the lambda concept in G. More pre-
cisely, if the type of the lambda concept in G is specialized in G*, then H* is only 
different from H in that type specialization; otherwise, H* and H are identical. As 
such, H*∧F* is semantically equivalent to H∧F*, whence Pr(H* | F*) = 
Pr(H*∧F*)/Pr(F*) = Pr(H∧F*)/Pr(F*) = (Pr(F*) − Pr(¬H∧F*))/Pr(F*). Fur-
thermore, one has Pr(¬H∧F*) ≤  Pr(¬H∧F) = Pr(¬H | F).Pr(F) =  (1 − Pr(H | 
F)).Pr(F) = 0, as  Pr(H | F) = 1,whence Pr(H* | F*) = 1. That is, Pr(H | F) = 1 en-
tails Pr(H* | F*) = 1 or, in other words, if F then H [1] entails if F* then H* [1], 
i.e., G entails G*. 
 
Proposition 5.6.4. A generally quantified FCG G with an absolute quantifier Q 
entails a generally quantified FCG G* obtained from G by generalizing it, includ-
ing its lambda FCG, and replacing Q with at least Q. 
Proof  
Let the expansion of G be if F then H [QF], where F corresponds to G’s lambda 
FCG, and QF = Q/|F| with |F| being the cardinality of the denotation set in a uni-
verse of discourse of the type that F represents, as noted in Section 5.5. Then the 
expansion of G* is if F* then H* [at least Q / |F*|], where F* and H* are respec-
tively generalizations of F and H. One has Pr(H* | F*) = Pr(H*∧F*)/Pr(F*) ≥ 
Pr(H∧F)/Pr(F*) = (Pr(H | F).Pr(F))/Pr(F*) = ((Q/|F|).Pr(F))/Pr(F*), and Pr(F) 
= Pr(F∧F*) = Pr(F | F*).Pr(F*) = (|F|/|F*|).Pr(F*), whence Pr(H* | F*) ≥ Q/|F*|. 
Thus Pr(H | F) = Q/|F| entails Pr(H* | F*) = at least (Q/|F*|). According to Propo-
sition 5.2.3, at least (Q/|F*|) = at least Q / |F*|, whence if F then H [Q/|F|] entails 
if F* then H* [at least Q / |F*|], i.e., G entails G*. 
 
Proposition 5.6.5. A generally quantified FCG G with an absolute quantifier Q 
entails a generally quantified FCG G* obtained from G by specializing it, includ-
ing its lambda FCG, and replacing Q with at most Q. 
Proof 
Let the expansion of G be if F then H [Q/|F|], where F corresponds to G’s lambda 
FCG, and |F| is the cardinality of the denotation set in a universe of discourse of 
the type that F represents. Then the expansion of G* is if F* then H* [at most Q / 
|F*|], where F* and H* are respectively specializations of F and H. One has Pr(H* 
| F*) = Pr(H*∧F*)/Pr(F*) ≤ Pr(H∧F)/Pr(F*) = (Pr(H | F).Pr(F))/Pr(F*) 
= ((Q/|F|) .Pr(F))/Pr(F*), and Pr(F*) = Pr(F*∧F) 
= Pr(F* 
| F).Pr(F) 
= (|F*|/|F|).Pr(F), whence Pr(H* | F*) ≤ Q/|F*|. Thus Pr(H | F) = Q/|F| entails 
Pr(H* | F*) = at most (Q/|F*|). According to Proposition 5.2.3, at most (Q/|F*|) = 
at most Q / |F*|, whence if F then H [Q/|F|] entails if F* then H* [at most Q / 
|F*|], i.e., G entails G*. 
 
Proposition 5.6.6. Let G be a generally quantified FCG with a relative quantifier 
Q, and G* be a simple FCG such that there is a probabilistic FCG projection π 
from the lambda FCG in G to G*. Then Jeffrey’s rule derives the simple FCG H* 
with the probability (at least (Q.επ))∩(at most (Q.επ + (1 − επ))) where H* is  

A.4   Proofs for Chapter 5 
191
 
obtained from G by replacing its generally quantified concept with its lambda con-
cept c whose referent λ is replaced with referent(πc). 
Proof  
Let the expansion of G be if F then H [Q], where F corresponds to G’s lambda 
FCG. Let F* be the simple FCG obtained from G’s lambda FCG by replacing the 
referent of its lambda concept c with referent(πc). As such, F and F* are different 
only in that referent, whence πF* = πF and Pr(F* | πF*) = Pr(F | πF) = επ. Jef-
frey’s rule gives Pr(H*) = Pr(H|F).Pr(F*) + Pr(H|¬F).Pr(¬F*), from which one 
has Pr(H|F).Pr(F*) ≤ Pr(H*) ≤ Pr(H|F).Pr(F*) + (1 − Pr(F*)), assuming that 
Pr(H|¬F) is totally unknown, i.e., only 0 ≤ Pr(H|¬F) ≤ 1 is known. Here Pr(H | F) 
= Q, and Pr(F*) = Pr(F*|πF*) = επ as Pr(πF*) = Pr(G*) = 1. Thus  Pr(H*) is at 
least (Q.επ) and at most (Q.επ + (1 − επ)), whence Pr(H*) = (at least (Q.επ))∩(at 
most (Q.επ + (1 − επ))) on the basis of the principle of minimum specificity. 
 
 

References 
1. Aït-Kaci, H., Nasr, R.: LOGIN: a logic programming language with built-in inheri-
tance. Journal of Logic Programming 3, 185–215 (1986) 
2. Andreasen, T., Bulskov, H., Knappe, R.: Similarity for conceptual querying. In: 
Yazici, A., Sener, C. (eds.) ISCIS 2003. LNCS, vol. 2869, pp. 268–275. Springer, 
Heidelberg (2003) 
3. Atanassov, K., Georgiev, C.: Intuitionistic fuzzy Prolog. International Journal for 
Fuzzy Sets and Systems 53, 121–128 (1993) 
4. Baeza-Yates, R., Ribeiro-Neto, B.: Modern Information Retrieval. Addison-Wesley, 
Reading (1999) 
5. Baget, J.F.: Simple conceptual graphs revisited: hypergraphs and conjunctive types 
for efficient projection algorithms. In: Ganter, B., de Moor, A., Lex, W. (eds.) ICCS 
2003. LNCS, vol. 2746, pp. 229–242. Springer, Heidelberg (2003) 
6. Baldwin, J.M., Lawry, J., Martin, T.P.: A note on probability/possibility consistency 
for fuzzy events. In: Proceedings of the 6th International Conference on Information 
Processing and Management of Uncertainty in Knowledge-Based Systems, pp. 521–
525 (1996) 
7. Baldwin, J.F., Martin, T.P., Pilsworth, B.W.: Fril - Fuzzy and Evidential Reasoning in 
Artificial Intelligence. Research Studies Press, New York (1995) 
8. Barwise, J., Cooper, R.: Generalized quantifiers and natural language. Linguistics and 
Philosophy 4, 159–219 (1981) 
9. Beierle, C., Hedtstuck, U., Pletat, U., Schmitt, P.H., Siekmann, J.: An order-sorted 
logic for knowledge representation systems. Journal of Artificial Intelligence 55, 
149–191 (1992) 
10. Belnap, N.D.: A useful four-valued logic. In: Dunn, J.M., Epstein, G. (eds.) Modern 
Uses of Multiple-Valued Logic, pp. 9–37. D. Reidel Publishing Company, Dordrecht 
(1977) 
11. Berners-Lee, T. (2001), Reflections on web architecture, 
http://www.w3.org/DesignIssues/CG.html 
12. Berners-Lee, T., Hendler, J., Lassila, O.: The Semantic Web. Scientific American 
Magazine (May 2001) 
13. Bilenko, M., et al.: Adaptive name matching in information integration. IEEE Intelli-
gent Systems 18, 16–23 (2003) 
14. Buckley, C.: Implementation of the SMART information retrieval system. Technical 
Report 85-686, Cornell University (1985) 
15. Budanitsky, A., Hirst, G.: Semantic distance in WordNet: an experimental, applica-
tion-oriented evaluation of five measures. In: Proceedings of the Workshop on 
WordNet and Other Lexical Resources, 2nd Meeting of the North American Chapter 
of the Association for Computational Linguistics (2001) 

194 
References
 
16. Cao, T.H.: Annotated fuzzy logic programs for soft computing. In: Selvaraj, H., 
Verma, B. (eds.) Proceedings of the 2nd International Conference on Computational 
Intelligence and Multimedia Applications, pp. 459–464. World Scientific, Singapore 
(1998) 
17. Cao, T.H.: Annotated fuzzy logic programs. International Journal for Fuzzy Sets and 
Systems 113(2), 277–298 (2000) 
18. Cao, T.H.: A formalism for representing and reasoning with linguistic information. 
International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems 10(3), 
281–307 (2002) 
19. Cao, T.H.: Conceptual graphs for modelling and computing with generallized quanti-
fied statements. In: Lawry, J., Shanahan, J., Ralescu, A. (eds.) Modelling with Words. 
LNCS, vol. 2873, pp. 80–101. Springer, Heidelberg (2003) 
20. Cao, T.H.: A note on the model-theoretic semantics of fuzzy logic programming for 
dealing with inconsistency. International Journal of Fuzzy Sets and Systems 144, 93–
104 (2004) 
21. Cao, T.H., Anh, M.H.: Ontology-based understanding of natural language queries us-
ing nested conceptual graphs. In: Proceedings of the 18th International Conference on 
Conceptual Structures. Springer, Heidelberg (to appear, 2010) 
22. Cao, T.H., Cao, T.D., Tran, T.L.: A robust ontology-based method for translating 
natural language queries to conceptual graphs. In: Domingue, J., Anutariya, C. (eds.) 
ASWC 2008. LNCS, vol. 5367, pp. 479–492. Springer, Heidelberg (2008) 
23. Cao, T.H., Creasy, P.N.: Fuzzy order-sorted logic programming in conceptual graphs 
with a sound and complete proof procedure. In: Mugnier, M.-L., Chein, M. (eds.) 
ICCS 1998. LNCS (LNAI), vol. 1453, pp. 270–284. Springer, Heidelberg (1998) 
24. Cao, T.H., Creasy, P.N.: Fuzzy types: a framework for handling uncertainty about 
types of objects. International Journal of Approximate Reasoning 25(3), 217–253 
(2000) 
25. Cao, T.H., Creasy, P.N., Wuwongse, V.: Fuzzy types and their lattices. In: Proceed-
ings of the 6th IEEE International Conference on Fuzzy Systems, pp. 805–812 
(1997a) 
26. Cao, T.H., Creasy, P.N., Wuwongse, V.: Fuzzy unification and resolution proof pro-
cedure for fuzzy conceptual graph programs. In: Delugach, H.S., Keeler, M.A., 
Searle, L., Lukose, D., Sowa, J.F. (eds.) ICCS 1997. LNCS (LNAI), vol. 1257, pp. 
386–400. Springer, Heidelberg (1997b) 
27. Cao, T.H., Do, H.T., Hong, D.T., Quan, T.T.: Fuzzy named entity-based document 
clustering. In: Proceedings of the 17th IEEE International Conference on Fuzzy Sys-
tems, pp. 2028–2034 (2008) 
28. Cao, T.H., Huynh, D.T.: Approximate knowledge graph retrieval: measures and reali-
zation. In: Sanchez, E. (ed.) Fuzzy Logic and the Semantic Web, Capturing Intelli-
gence, pp. 283–304. Elsevier Science, Amsterdam (2006) 
29. Cao, T.H., Huynh, D.T.: Subsumption degrees between entity types and names for 
approximate knowledge retrieval. International Journal of Uncertainty, Fuzziness and 
Knowledge-Based Systems 15(1), 21–42 (2007) 
30. Cao, T.H., Le, K.C., Ngo, V.M.: Exploring combinations of ontological features and 
keywords for text retrieval. In: Ho, T.-B., Zhou, Z.-H. (eds.) PRICAI 2008. LNCS 
(LNAI), vol. 5351, pp. 603–613. Springer, Heidelberg (2008) 
31. Cao, T.H., Noi, N.V.: A Framework for linguistic logic programming. International 
Journal of Intelligent Systems 25(6), 559–580 (2010) 

References 
195 
 
32. Carpenter, B.: The Logic of Typed Feature Structures with Applications to Unifica-
tion Grammars, Logic Programs and Constraint Resolution. Cambridge University 
Press, Cambridge (1992) 
33. Chein, M., Mugnier, M.L.: Conceptual graphs: fundamental notions. Revue 
d’Intelligence Artificielle 6(4), 365–406 (1992) 
34. Chein, M., Mugnier, M.L.: Conceptual graphs are also graphs. Research Report No. 
95003, Laboratoire d’Informatique, de Robotique et de Micro-électronique de Mont-
pellier (1995) 
35. Chein, M., Mugnier, M.L.: Graph-based Knowledge Representation and Reasoning: 
Computational Foundations of Conceptual Graphs. Springer, London (2008) 
36. Chortaras, A., Stamou, G.B., Stafylopatis, A.: Definition and adaptation of weighted 
fuzzy logic programs. International Journal of Uncertainty, Fuzziness and Knowl-
edge-Based Systems 17(1), 85–135 (2009) 
37. Church, K.W., Hanks, P.: Word association norms, mutual information, and lexicog-
raphy. In: Proceedings of the 27th Annual Meeting of the Association for Computa-
tional Linguistics, pp. 76–83 (1989) 
38. Cimiano, P., Haase, P., Heizmann, J.: Porting natural language interfaces between 
domains – an experimental user study with the ORAKEL system. In: Proceedings of 
the 12th ACM International Conference on Intelligent User Interfaces, pp. 180–189 
(2007) 
39. Cohen, W.W., Ravikumar, P., Fienberg, S.E.: A comparison of string distance metrics 
for name-matching tasks. In: Proceedings of the 18th IJCAI Workshop on Informa-
tion Integration on the Web (2003) 
40. Coulondre, S., Salvat, E.: Piece resolution: towards larger perspectives. In: Mugnier, 
M.-L., Chein, M. (eds.) ICCS 1998. LNCS (LNAI), vol. 1453, pp. 179–193. Springer, 
Heidelberg (1998) 
41. Crestani, F., Pasi, G.: Soft information retrieval: applications of fuzzy set theory and 
neural networks. In: Kasabov, N., Kozma, R. (eds.) Neuro-Fuzzy Techniques for In-
telligent Information Systems, pp. 287–315. Physica Verlag, Heidelberg (1999) 
42. Cunningham, H., Maynard, D., Bontcheva, K., Tablan, V.: GATE: a framework and 
graphical development environment for robust NLP tools and applications. In: Pro-
ceedings of the 40th Anniversary Meeting of the Association for Computational Lin-
guistics (2002) 
43. Dau, F., Correia, J.H.: Nested concept graphs: mathematical foundations and applica-
tions for databases. In: Ganter, B., de Moor, A. (eds.) Using Conceptual Structures. 
Shaker Verlag, Aachen (2003) 
44. Davis, M.: First order logic. In: Gabbay, D.M., et al. (eds.) Handbook of Logic in Ar-
tificial Intelligence and Logic Programming, vol. 1, pp. 31–67. Oxford University 
Press, New York (1994) 
45. Davis, R., Shrobe, H., Szolovits, P.: What is a knowledge representation? AI Maga-
zine 14(1), 17–33 (1993) 
46. Dill, S., et al.: SemTag and Seeker: Bootstrapping the Semantic Web via automated 
semantic annotation. In: Proceedings of the 12th International Conference on the 
World Wide Web, pp. 178–186 (2003) 
47. Dobrev, P., Toutanova, K.: CGWorld – Architecture and features. In: Priss, U., Cor-
bett, D., Angelova, G. (eds.) ICCS 2002. LNCS (LNAI), vol. 2393, pp. 261–270. 
Springer, Heidelberg (2002) 

196 
References
 
48. Dubois, D., Lang, J., Prade, H.: Fuzzy sets in approximate reasoning, Part 2: logical 
approaches. International Journal for Fuzzy Sets and Systems, the 25th Anniversary 
Memorial Volume 40, 203–244 (1991) 
49. Dubois, D., Lang, J., Prade, H.: Possibilistic logic. In: Gabbay, D.M., et al. (eds.) 
Handbook of Logic in Artificial Intelligence and Logic Programming, vol. 3, pp. 
439–514. Oxford University Press, New York (1994) 
50. Dubois, D., Prade, H.: Fuzzy Sets and Systems: Theory and Applications. Academic 
Press, New York (1980) 
51. Dubois, D., Prade, H.: The principle of minimum specificity as a basis for evidential 
reasoning. In: Bouchon, B., Yager, R.R. (eds.) Uncertainty in Knowledge-Based Sys-
tems. LNCS, vol. 286, pp. 75–84. Springer, Heidelberg (1987) 
52. Dubois, D., Prade, H.: An introduction to possibilistic and fuzzy logics. In: Smets, P., 
et al. (eds.) Non-Standard Logics for Automated Reasoning, pp. 287–315. Academic 
Press, London (1988); Reprinted in Shafer, G. and Pearl, J. (eds), Readings in Uncer-
tain Reasoning. Morgan Kaufmann Publishers, San Mateo, pp. 742–761 (1990) 
53. Ellis, G., Lehmann, F.: Exploiting the induced order on type-labelled graphs for fast 
knowledge retrieval. In: Tepfenhart, W.M., Dick, J.P., Sowa, J. (eds.) ICCS 1994. 
LNCS (LNAI), vol. 835, pp. 293–310. Springer, Heidelberg (1994) 
54. Esteva, F., Garcia-Calvés, P., Godo, L.: Relating and extending semantical ap-
proaches to possibilistic reasoning. International Journal of Approximate Reason-
ing 10, 311–344 (1994) 
55. Fargues, J., Landau, M.C., Dugourd, A., Catach, L.: Conceptual graphs for semantics 
and knowledge processing. IBM Journal of Research and Development 30(1), 70–79 
(1986) 
56. Gaines, B.R.: Fuzzy and probability uncertainty logics. Journal of Information and 
Control 38, 154–169 (1978) 
57. Gauch, S., Wang, J., Rachakonda, S.M.: A corpus analysis approach for automatic 
query expansion and its extension to multiple databases. ACM Transactions on In-
formation Systems 17(3), 250–269 (1999) 
58. Genest, D., Salvat, E.: A platform allowing typed nested graphs: how CoGITo be-
came CoGITaNT. In: Mugnier, M.-L., Chein, M. (eds.) ICCS 1998. LNCS (LNAI), 
vol. 1453, pp. 154–161. Springer, Heidelberg (1998) 
59. Ghosh, B.C.: Conceptual graph language - a language of logic and information in 
conceptual structures. PhD thesis, Asian Institute of Technology (1996) 
60. Ghosh, B.C., Wuwongse, V.: Declarative semantics of conceptual graph programs. 
In: Proceedings of the 2nd Workshop on Peirce, in Conjunction with the 1st Interna-
tional Conference on Conceptual Structures (1993) 
61. Ghosh, B.C., Wuwongse, V.: Inference systems for conceptual graph programs. In: 
Tepfenhart, W.M., Dick, J.P., Sowa, J.F. (eds.) ICCS 1994. LNCS, vol. 835, pp. 214–
229. Springer, Heidelberg (1994) 
62. Ghosh, B.C., Wuwongse, V.: A direct proof procedure for definite conceptual graph 
programs. In: Ellis, G., et al. (eds.) ICCS 1995. LNCS (LNAI), vol. 954, pp. 158–
172. Springer, Heidelberg (1995) 
63. Glöckner, I.: Fuzzy Quantifiers: A Computational Theory. In: Studies in Fuzziness 
and Soft Computing, vol. 193. Springer, Heidelberg (2006) 
64. Godo, L., Vila, L.: Possibilistic temporal reasoning based on fuzzy temporal con-
straints. In: Proceedings of the 14th International Joint Conference on Artificial Intel-
ligence, pp. 1916–1922 (1995) 

References 
197 
 
65. Goguen, J.A.: L-fuzzy sets. Journal of Mathematical Analysis and Application 18, 
145–174 (1967) 
66. Goguen, J.A., Meseguer, J.: Equality, types, modules and (why not?) generics for 
logic programming. Journal of Logic Programming 1(2), 179–210 (1984) 
67. Gospodnetic, O.: Parsing, indexing, and searching XML with Digester and Lucene. 
IBM DeveloperWorks (2003) 
68. Grätzer, G.: General Lattice Theory. Academic Press, New York (1978) 
69. Haemmerlé, O., Buche, P., Thomopoulos, R.: The MIEL system: uniform interroga-
tion of structured and weakly-structured imprecise data. Journal of Intelligent Infor-
mation Systems 29, 279–304 (2007) 
70. Hájek, P.: Fuzzy logic from the logical point of view. In: Bartosek, M., Staudek, J., 
Wiedermann, J. (eds.) SOFSEM 1995. LNCS, vol. 1012, pp. 31–49. Springer, Hei-
delberg (1995) 
71. Hensman, S., Dunnion, J.: Using linguistic resources to construct conceptual graph 
representation of texts. In: Sojka, P., Kopeček, I., Pala, K. (eds.) TSD 2004. LNCS 
(LNAI), vol. 3206, pp. 81–88. Springer, Heidelberg (2004) 
72. Hinde, C.J.: Fuzzy Prolog. International Journal of Man-Machine Studies 24, 569–
595 (1986) 
73. Hirst, G., St-Onge, D.: Lexical chains as representations of context for the detection 
and correction of malapropisms. In: Fellbaum, C. (ed.) WordNet: An Electronic Lexi-
cal Database, pp. 305–332. MIT Press, Cambridge (1998) 
74. Ho, N.D., Cédirick, F.: Lexical similarity based on quantity of information exchanged 
- synonym extraction. In: Proceedings of the 2nd International Conference of Viet-
nam & Francophone Informatics Research, pp. 193–198 (2004) 
75. Honderich, T. (ed.): The Oxford Companion to Philosophy. Oxford University Press, 
Oxford (1995) 
76. Hopcroft, J.E., Ullman, J.D.: Introduction to Automata Theory, Languages, and 
Computation. Addison-Wesley Publishing Company, Massachusetts (1979) 
77. Ishizuka, M., Kanai, N.: Prolog-ELF incorporating fuzzy logic. In: Proceedings of the 
9th International Joint Conference on Artificial Intelligence, pp. 701–703 (1985) 
78. Jaccard, P.: The distribution of the flora of the alpine zone. New Phytologist 11, 37–
50 (1912) 
79. Jaro, M.A.: Probabilistic linkage of large public health data file. Statistics in Medi-
cine 14, 491–498 (1995) 
80. Jeffrey, R.: The Logic of Decision. McGraw-Hill, New York (1965) 
81. Jiang, J., Conrath, D.W.: Semantic similarity based on corpus statistics and lexical 
taxonomy. In: Proceedings of the International Conference on Research in Computa-
tional Linguistics, pp. 19–33 (1997) 
82. Kampman, A., Harmelen, F., Broekstra, J.: Sesame: A generic architecture for storing 
and querying RDF and RDF schema. In: Horrocks, I., Hendler, J. (eds.) ISWC 2002. 
LNCS, vol. 2342, pp. 54–68. Springer, Heidelberg (2002) 
83. Kaufmann, E., Bernstein, A., Fischer, L.: NLP-reduce: a “naïve” but domain-
independent natural language interface for querying ontologies. In: Demo-Paper at 
the 4th European Semantic Web Conference, pp. 1–2 (2007) 
84. Kerdiles, G., Salvat, E.: A sound and complete CG proof procedure combining pro-
jections with analytic tableaux. In: Lukose, D., et al. (eds.) ICCS 1997. LNCS 
(LNAI), vol. 1257, pp. 371–385. Springer, Heidelberg (1997) 
85. Kifer, M., Lozinskii, E.L.: A logic for reasoning with inconsistency. Journal of 
Automated Reasoning 9, 179–215 (1992) 

198 
References
 
86. Kifer, M., Subrahmanian, V.S.: Theory of generalized annotated logic programming 
and its applications. Journal of Logic Programming 12, 335–367 (1992) 
87. Kikuchi, H., Mukaidono, M.: Linear resolution for fuzzy logic program. Japanese 
Journal of Fuzzy Theory and Systems 6, 151–165 (1994) 
88. Kiryakov, A., Popov, B., Terziev, I., Manov, D., Ognyanoff, D.: Semantic annotation, 
indexing, and retrieval. Journal of Web Semantics 2, 49–79 (2004) 
89. Klawonn, F.: Prolog extensions to many-valued logics. In: Höhle, U., Klement, E.P. 
(eds.) Non-Classical Logics and their Applications to Fuzzy Subsets, pp. 271–289. 
Kluwer Academic Publishers, Dordrecht (1995) 
90. Klawonn, F., Castro, J.L.: Similarity in fuzzy reasoning. Mathware Soft Computing 3, 
197–228 (1995) 
91. Klir, G.J., Yuan, B.: Fuzzy Sets and Fuzzy Logic Theory and Applications. Prentice 
Hall, Englewood Cliffs (1995) 
92. Kozima, H., Ito, A.: Context-sensitive word distance by adaptive scaling of a seman-
tic space. In: Mitkov, R., Nicolov, N. (eds.) Recent Advances in Natural Language 
Processing, pp. 111–124. John Benjamins Publishing Company, Amsterdam (1997) 
93. Kullmann, P., Sandri, S.: Possibilistic logic as an annotated logic. In: Proceedings of 
the 8th IEEE International Conference on Fuzzy Systems, pp. 210–215 (2000) 
94. Lawry, J.: An alternative interpretation of linguistic variables and computing with 
words. In: Proceedings of the 8th International Conference on Information Processing 
and Management of Uncertainty in Knowledge-Based Systems, pp. 1743–1750 
(2000) 
95. Lawry, J.: Modelling and Reasoning with Vague Concepts. SCI, vol. 12. Springer, 
Heidelberg (2006) 
96. Leacock, C., Chodorow, M.: Combining local context and WordNet similarity for 
word sense identification. In: Fellbaum, C. (ed.) WordNet: An Electronic Lexical Da-
tabase, pp. 265–284. MIT Press, Cambridge (1998) 
97. Lee, R.C.T.: Fuzzy logic and the resolution principle. Journal of ACM 19, 109–119 
(1972) 
98. Lei, Y., Uren, V., Motta, E.: Semsearch: a search engine for the Semantic Web. In: 
Staab, S., Svátek, V. (eds.) EKAW 2006. LNCS (LNAI), vol. 4248, pp. 238–245. 
Springer, Heidelberg (2006) 
99. Levenshtein, V.I.: Binary codes capable of correcting deletions, insertions, and rever-
sals. Soviet Physics-Doklady 10, 707–710 (1966) 
100. Li, D., Liu, D.: A Fuzzy Prolog Database System. Research Studies Press, London 
(1990) 
101. Lin, D.: An information-theoretic definition of similarity. In: Proceedings of the 15th 
International Conference on Machine Learning, pp. 296–304 (1998) 
102. Liu, Y., Kerre, E.: An overview of fuzzy quantifiers - (I) Interpretations (II) Reason-
ing and applications. International Journal for Fuzzy Sets and Systems 95, 1–21, 135–
146 (1998) 
103. Lloyd, J.W.: Foundations of Logic Programming, 2nd extended edn. Springer, Berlin 
(1987) 
104. Lopez de Mantaras, R., Godo, L.: From intervals to fuzzy truth-values: adding flexi-
bility to reasoning under uncertainty. International Journal of Uncertainty, Fuzziness 
and Knowledge-Based Systems 5(3), 251–260 (1997) 
105. Lu, J.J., Nerode, A., Subrahmanian, V.S.: Hybrid knowledge bases. IEEE Transac-
tions on Knowledge and Data Engineering 8, 773–785 (1996) 

References 
199 
 
106. Magrez, P., Smets, P.: Fuzzy modus ponens: a new model suitable for applications in 
knowledge-based systems. International Journal of Intelligent Systems 4, 181–200 
(1989) 
107. Manning, C.D., Raghavan, P., Schütze, H.: Introduction to Information Retrieval. 
Cambridge University Press, New York (2008) 
108. Meinke, K., Tucker, J.V. (eds.): Many-Sorted Logic and its Applications. John Wiley 
& Sons, Chichester (1993) 
109. Mendel, J.M., Zadeh, L.A., Trillas, E., Yager, R., Lawry, J., Hagras, H., Guadarrama, 
S.: What computing with words means to me. In: IEEE Computational Intelligence 
Magazine (2010) 
110. Mitaim, S., Kosko, B.: Neural fuzzy agents for profile learning and adaptive object 
matching. Presence 7, 617–637 (1998) 
111. Miyamoto, S.: Fuzzy Sets in Information Retrieval and Cluster Analysis. Kluwer 
Academic Publishers, Dordrecht (1990) 
112. Monge, A.E., Elkan, C.P.: The field-matching problem: algorithm and applications. 
In: Proceedings of the 2nd International Conference on Knowledge Discovery and 
Data Mining, pp. 267–270. AAAI Press, Menlo Park (1996) 
113. Moore, R.E.: Interval Analysis. Prentice Hall, Englewood Cliffs (1966) 
114. Morton, S.K.: Conceptual graphs and fuzziness in artificial intelligence. PhD Thesis, 
University of Bristol (1987) 
115. Mugnier, M.L.: On generalization/specialization for conceptual graphs. Journal of 
Experimental and Theoretical Artificial Intelligence 7, 325–344 (1995) 
116. Mukaidono, M., Shen, Z., Ding, L.: Fundamentals of fuzzy Prolog. International 
Journal of Approximate Reasoning 3, 179–194 (1989) 
117. Mulhem, P., Leow, W.K., Lee, Y.K.: Fuzzy conceptual graphs for matching images 
of natural scenes. In: Proceedings of the 17th International Joint Conference on Arti-
ficial Intelligence, pp. 1397–1402 (2001) 
118. Muñoz-Hernández, S., Vaucheret, C.: Extending Prolog with incomplete fuzzy in-
formation. In: Proceedings of the 15th International Workshop on Logic-Based 
Methods in Programming Environments, pp. 77–93 (2005) 
119. Nelken, R., Francez, N.: Querying temporal databases using controlled natural lan-
guage. In: Proceedings of the 18th Conference on Computational Linguistics, pp. 
1076–1080 (2000) 
120. Nguyen, H.T., Walker, E.A.: A First Course in Fuzzy Logic, 3rd edn. Chapman and 
Hall/CRC (2005) 
121. Novák, V.: First-order fuzzy logic. Studia Logica XLVI, 87–109 (1987) 
122. Nyberg, E.H., Mitamura, T.: Controlled language and knowledge-based machine 
translation: principles and practice. In: Proceedings of the 1st International Workshop 
on Controlled Language Applications, pp. 74–83 (1996) 
123. Ogden, W.C., Bernick, P.: Using natural language interfaces. In: Helander, M., Lan-
dauer, T.K., Prabhu, P. (eds.) Handbook of Human-Computer Interaction, pp. 137–
162. Elsevier Science, Amsterdam (1997) 
124. Pavelka, J.: On fuzzy logic. Zeitschrift fur Mathematik Logik und Grundlagen der 
Mathematic Part I, 25, 45–72, Part II, 119–134, Part III, 447–464 (1979) 
125. Peterson, P.L.: On the logic of Few, Many and Most. Notre Dame Journal of Formal 
Logic XX, 155–179 (1979) 
126. Pfenning, F. (ed.): Types in Logic Programming. MIT Press, Cambridge (1992) 

200 
References
 
127. Rao, A.S., Foo, N.Y.: CONGRES: conceptual graph reasoning system. In: Proceed-
ings of the 3rd Conference on Artificial Intelligence Applications, pp. 87–92. IEEE 
Computer Society Press, Los Alamitos (1987) 
128. Reitsma, E.: From requirements to implementation; Applying conceptual graphs to 
intelligent networks. PhD Thesis, University of Twente (1998) 
129. Rescher, N.: Many-valued Logic. McGraw-Hill, New York (1969) 
130. Resnik, P.: Using information content to evaluate semantic similarity in taxonomy. 
In: Proceedings of the 14th International Joint Conference on Artificial Intelligence, 
pp. 448–453 (1995) 
131. Salton, G. (ed.): Automatic Text Processing. Addison-Wesley, Reading (1989) 
132. Salvat, E.: Raisonner avec des opération de graphes: graphes conceptuels et règles 
d’inférence. PhD Thesis, Université Montpellier II (1997) 
133. Salvat, E., Mugnier, M.L.: Sound and complete forward and backward chainings of 
graph rules. In: Eklund, P., Mann, G.A., Ellis, G. (eds.) ICCS 1996. LNCS (LNAI), 
vol. 1115, pp. 248–262. Springer, Heidelberg (1996) 
134. Sekine, S.: Named entity: history and future. Proteus Project Report (2004) 
135. Sheth, A., Ramakrishnan, C., Thomas, C.: Semantics for the Semantic Web: The Im-
plicit, the Formal and the Powerful. International Journal on Semantic Web & Infor-
mation Systems 1(1), 1–18 (2005) 
136. Sowa, J.F.: Conceptual graphs for a data base interface. IBM Journal of Research and 
Development 20(4), 336–357 (1976) 
137. Sowa, J.F.: Conceptual Structures - Information Processing in Mind and Machine. 
Addison-Wesley Publishing Company, Massachusetts (1984) 
138. Sowa, J.F.: Towards the expressive power of natural language. In: Sowa, J.F. (ed.) 
Principles of Semantic Networks - Explorations in the Representation of Knowledge, 
pp. 157–189. Morgan Kaufmann Publishers, San Francisco (1991) 
139. Sowa, J.F.: Matching logical structure to linguistic structure. In: Houser, N., Roberts, 
D.D., Van Evra, J. (eds.) Studies in the Logic of Charles Sanders Peirce, pp. 418–444. 
Indiana University Press, Bloomington (1997) 
140. Sowa, J.F.: Conceptual graphs: draft proposed American national standard. In: 
Tepfenhart, W., Cyre, W. (eds.) ICCS 1999. LNCS (LNAI), vol. 1640, pp. 1–65. 
Springer, Heidelberg (1999) 
141. Sowa, J.F.: Conceptual graphs. In: van Harmelen, F., Lifschitz, V., Porter, B. (eds.) 
Handbook of Knowledge Representation, pp. 213–237. Elsevier, Amsterdam (2008) 
142. Straccia, U.: Fuzzy description logic programs. In: Bouchon-Meunier, B., Yager, 
R.R., Marsala, C., Rifqi, M. (eds.) Uncertainty and Intelligent Information Systems, 
pp. 405–416. World Scientific, Singapore (2008) 
143. Subrahmanian, V.S.: On the semantics of quantitative logic programs. In: Proceed-
ings of the 4th IEEE Symposium on Logic Programming, pp. 173–182. IEEE Com-
puter Society Press, Washington (1987) 
144. Tablan, V., Damljanovic, D., Bontcheva, K.: A natural language query interface to 
structured information 2008. In: Bechhofer, S., Hauswirth, M., Hoffmann, J., Kouba-
rakis, M. (eds.) ESWC 2008. LNCS (LNAI), vol. 5021, pp. 361–375. Springer, Hei-
delberg (2008) 
145. Tjan, B.S., Gardiner, D.A., Slagle, J.R.: Direct inference rules for conceptual graphs 
with extended notation. In: Proceedings of the 5th Annual Workshop on Conceptual 
Structures (1990) 

References 
201 
 
146. Tjan, B.S., Gardiner, D.A., Slagle, J.R.: Representing and reasoning with set referents 
and numerical quantifiers. In: Nagle, T.E., et al. (eds.) Conceptual Structures - Cur-
rent Research and Practice. Ellis Horwood, pp. 53–66 (1992) 
147. Umano, M.: Fuzzy set Prolog. In: Preprints of the 2nd International Fuzzy Systems 
Association Congress, pp. 750–753 (1987) 
148. Van Emden, M.H.: Quantitative deduction and its fixpoint theory. Journal of Logic 
Programming 1, 37–53 (1986) 
149. Vertan, C., Boujemaa, N.: Using fuzzy histograms and distances for color image re-
trieval. In: Proceedings of Conference on Challenges of Image Retrieval, pp. 1–6 
(2000) 
150. Virtanen, H.E.: Lukasiewicz logic programming based on fuzzy equality. In: Proceed-
ings of the 4th European Congress on Intelligent Techniques and Soft Computing, pp. 
646–650 (1996) 
151. Wang, H.: Logic of many-sorted theories. Journal of Symbolic Logic 17(2), 105–116 
(1952) 
152. Wermelinger, M., Lopes, J.G.: Basic conceptual structures theory. In: Tepfenhart, 
W.M., Dick, J.P., Sowa, J.F. (eds.) ICCS 1994. LNCS (LNAI), vol. 835, pp. 144–
159. Springer, Heidelberg (1994) 
153. Willems, M.: Projection and unification for conceptual graphs. In: Ellis, G., et al. 
(eds.) ICCS 1995. LNCS (LNAI), vol. 954, pp. 278–292. Springer, Heidelberg (1995) 
154. Wilson, R.J., Beineke, L.W.: Applications of Graph Theory. Academic Press, London 
(1979) 
155. Winkler, W.E.: The state of record linkage and current research problems. Technical 
Report Statistical Research Report Series RR99/04, US Bureau of the Census, Wash-
ington, D.C. (1999) 
156. Wu, Z., Palmer, M.: Verb semantics and lexical selection. In: Proceedings of the 32nd 
Annual Meeting of the Association for Computational Linguistics, pp. 133–138 
(1994) 
157. Wuwongse, V., Cao, T.H.: Towards fuzzy conceptual graph programs. In: Eklund, 
P.W., et al. (eds.) ICCS 1996. LNCS (LNAI), vol. 1115, pp. 263–276. Springer, Hei-
delberg (1996) 
158. Wuwongse, V., Manzano, M.: Fuzzy conceptual graphs. In: Mineau, G.W., Moulin, 
B., Sowa, J.F. (eds.) ICCS 1993. LNCS (LNAI), vol. 699, pp. 430–449. Springer, 
Heidelberg (1993) 
159. Yao, H., Etzkorn, L.: Conversion from the Conceptual Graph (CG) model to the Re-
source Description Framework (RDF) model. In: Wolff, K.E., Pfeiffer, H.D., 
Delugach, H.S. (eds.) ICCS 2004. LNCS (LNAI), vol. 3127, pp. 98–114. Springer, 
Heidelberg (2004) 
160. Zadeh, L.A.: Fuzzy sets. Journal of Information and Control 8, 338–353 (1965) 
161. Zadeh, L.A.: Fuzzy logic and approximate reasoning (In memory of Grigore Moisil). 
Synthese 30, 407–428 (1975a) 
162. Zadeh, L.A.: The concepts of a linguistic variable and its application to approximate 
reasoning I, II, III. Information Sciences 8, 199–251, 301–357; 9, 43–80 (1975b) 
163. Zadeh, L.A.: Fuzzy sets as a basis for a theory of possibility theory. International 
Journal for Fuzzy Sets and Systems 1, 3–28 (1978a) 
164. Zadeh, L.A.: PRUF - a meaning representation language for natural languages. Inter-
national Journal of Man-Machine Studies 10, 395–460 (1978b) 
165. Zadeh, L.A.: A theory of approximate reasoning. Machine Intelligence 9, 149–194 
(1979) 

202 
References
 
166. Zadeh, L.A.: A fuzzy-set-theoretic approach to fuzzy quantifiers in natural languages. 
Computers and Mathematics with Applications 9, 149–184 (1983) 
167. Zadeh, L.A.: Fuzzy logic = computing with words. IEEE Transactions on Fuzzy Sys-
tems 4, 103–111 (1996) 
168. Zadeh, L.A.: Towards a theory of fuzzy information granulation and its centrality in 
human reasoning and fuzzy logic. Fuzzy Sets and Systems 90(2), 111–127 (1997) 
169. Zhang, L., Yu, Y.: Learning to generate CGs for domain specific sentences. In: 
Delugach, H., Stumme, G. (eds.) ICCS 2001. LNCS (LNAI), vol. 2120, pp. 44–57. 
Springer, Heidelberg (2001) 
170. Zhu, J., Uren, V., Motta, E.: ESpotter: Adaptive named entity recognition for Web 
browsing. In: Althoff, K.-D., Dengel, A., Bergmann, R., Nick, M. (eds.) WM 2005. 
LNCS (LNAI), vol. 3782, pp. 518–529. Springer, Heidelberg (2005) 

