
Mathematical Structures  
for Computer Science

This page intentionally left blank 

Mathematical Structures  
for Computer Science
7
Edition
Discrete Mathematics and Its Applications
Judith L. Gersting
Indiana University-Purdue University at Indianapolis
W. H. Freeman and Company
A Macmillan Higher Education Company

To my 01102 favorite 
discrete structures:
(Adam ` Francine),  
(Jason ` Cathryn) S  
(Sammie ` Johnny)
Senior Publisher: Ruth Baruth
Executive Editor: Terri Ward
Senior Editor: Roland Cheyney
Assistant Editor: Liam Ferguson
Marketing Manager: Steve Thomas
Media Editor: Laura Judge
Senior Project Editor: Georgia Lee Hadler
Copy Editor: Penelope Hull
Production Coordinator: Susan Wein
Text Designer: Patrice Sheridan 
Cover Designer: Victoria Tomaselli
Illustrations: Network Graphics
Composition: codeMantra
Printing and Binding: RR Donnelley
Library of Congress Control Number: 2013951442
ISBN-13: 978-1-4292-1510-7
ISBN-10: 1-4292-1510-0
© 2014, 2007, 2003, 1999, 1993, 1987, 1982 by W. H. Freeman and Company
All rights reserved
Printed in the United States of America
First printing
W. H. Freeman and Company
41 Madison Avenue, New York, NY 10010
Houndmills, Basingstoke RG21 6XS, England
www.whfreeman.com

Contents in Brief
Preface	
xiii
Note to the Student	
xvi
CHAPTEr 1	 Formal Logic	
001
Chapter 2	 Proofs, Induction, and Number Theory	
097
Chapter 3	 Recursion, Recurrence Relations, and Analysis of  
Algorithms	
157
Chapter 4	 Sets, Combinatorics, and Probability	
221
Chapter 5	 Relations, Functions, and Matrices	
327
Chapter 6	 Graphs and Trees	
475
Chapter 7	 Graph Algorithms	
553
Chapter 8	 Boolean Algebra and Computer Logic	
617
Chapter 9	 Modeling Arithmetic, Computation, and Languages	
685
Appendix A	 Derivation Rules for Propositional and Predicate Logic	
803
Appendix B	 Summation and Product Notation	
805
Appendix C	 The Logarithm Function	
809
Answers to Practice Problems	
813
Answers to Odd-Numbered Exercises	
851
Answers to Self-Tests	
949
Index	
959

This page intentionally left blank 

Contents
Chapter 1	
Formal Logic	
1
1.1	
Statements, Symbolic  
Representation, and  
Tautologies	
2
Connectives and Truth Values	
2
Tautologies	
8
Logical Connectives in the  
Real World	
10
An Algorithm	
12
Special Interest Page 
Can “And” Ever Be “Or”?	
15
Section 1.1	 Review	
16
Exercises 1.1	
16
1.2	
Propositional Logic	
25
Valid Arguments	
25
Derivation Rules for  
Propositional Logic	
28
Deduction Method and Other Rules	 32
Verbal Arguments	
33
Section 1.2	 Review	
35
Exercises 1.2	
35
1.3	
Quantifiers, Predicates, and  
Validity	
39
Quantifiers and Predicates	
39
Translation	
42
Validity	
48
Section 1.3	 Review	
50
Exercises 1.3	
50
1.4	
Predicate Logic	
58
Derivation Rules for Predicate Logic	58
Universal Instantiation	
59
Existential Instantiation	
60
Universal Generalization	
61
Existential Generalization	
62
More Work with Rules	
62
Verbal Arguments	
67
Conclusion	
68
Section 1.4	 Review	
69
Exercises 1.4	
69
 1.5	 Logic Programming	
73
Prolog	
73
Horn Clauses and Resolution	
75
Recursion	
79
Expert Systems	
81
Section 1.5	 Review	
82
Exercises 1.5	
82
1.6	
Proof of Correctness	
84
Assertions	
85
Assignment Rule	
87
Conditional Rule	
90
Section 1.6	 Review	
92
Exercises 1.6	
92
Chapter 1	Review 	
95
On the Computer	
96
Chapter 2	
Proofs, Induction, and  
Number Theory	
97
2.1	
Proof Techniques	
98
Theorems and Informal Proofs	
98
To Prove or Not to Prove	
99
Exhaustive Proof	
100
Direct Proof	
101
Contraposition	
103
Contradiction	
104

Serendipity	
106
Common Definitions	
107
Section 2.1	 Review	
107
Exercises 2.1	
107
2.2	
Induction	
110
First Principle of Induction	
110
Proofs by Mathematical  
Induction	
112
Second Principle of Induction	
118
Section 2.2	 Review	
122
Exercises 2.2	
122
2.3	
More on Proof of  
Correctness	
129
Loop Rule	
129
Euclidean Algorithm	
133
Special Interest Page 
Making Safer Software	
136
Section 2.3	 Review	
137
Exercises 2.3	
137
2.4	
Number Theory	
143
The Fundamental Theorem  
of Arithmetic	
144
More on Prime Numbers	
148
Euler Phi Function	
149
Section 2.4	 Review	
152
Exercises 2.4	
152
Chapter 2	Review	
155
On the Computer	
156
Chapter 3	
Recursion, Recurrence  
Relations, and Analysis  
of Algorithms	
157
3.1	
Recursive Definitions	
158
Recursively Defined Sequences	
158
Recursively Defined Sets	
162
Recursively Defined Operations	
165
Recursively Defined Algorithms	
166
Section 3.1	 Review	
171
Exercises 3.1	
171
3.2	
Recurrence Relations	
180
Linear First-Order Recurrence  
Relations	
180
Expand, Guess, and Verify	
180 
A Solution Formula	
182
Linear Second-Order  
Recurrence Relations	
188
Divide-and-Conquer  
Recurrence Relations	
193
Section 3.2	 Review	
197
Exercises 3.2	
197
3.3	
Analysis of Algorithms 	
203
The General Idea	
203
Analysis Using Recurrence  
Relations	
206
Upper Bound  
(Euclidean Algorithm)	
210
Special Interest Page 
Of Trees % and Pancakes	
211
Section 3.3	 Review	
212
Exercises 3.3	
212
Chapter 3	Review	
217
	
On the Computer	
218
Chapter 4	
Sets, Combinatorics,  
and Probability	
221
4.1	
Sets	
222
Notation	
222
Relationships Between Sets	
224
Sets of Sets	
227
Binary and Unary Operations	
228
Operations on Sets	
230
Set Identities	
233
Countable and Uncountable Sets	
236
Section 4.1	 Review	
239
Exercises 4.1	
239
4.2	
Counting	
252
Multiplication Principle	
252
Addition Principle	
254
Using the Principles Together	
255
Decision Trees	
257
viii	
Contents

Contents	
ix
Section 4.2	 Review	
258
Exercises 4.2	
259
4.3	
Principle of Inclusion and  
Exclusion; Pigeonhole  
Principle	
263
Principle of Inclusion and  
Exclusion	
264
Pigeonhole Principle	
269
Section 4.3	 Review	
269
Exercises 4.3	
270
4.4	
Permutations and  
Combinations	
272
Permutations	
272
Combinations	
274
Eliminating Duplicates	
277
Permutations and Combinations  
with Repetitions	
279
Generating Permutations  
and Combinations	
280
Special Interest Page 
Archimedes and the Stomachion	
286
Section 4.4	 Review	
288
Exercises 4.4	
288
4.5	
Binomial Theorem	
294
Pascal’s Triangle	
294
Binomial Theorem and Its Proof	
296
Applying the Binomial Theorem	
298
Section 4.5	 Review	
299
Exercises 4.5	
299
4.6	
Probability	
301
Introduction to Finite  
Probability	
301
Probability Distributions	
304
Conditional Probability	
306
Bayes’ Theorem	
308
Expected Value	
310
Binomial Distributions	
313
Average Case Analysis of  
Algorithms	
314
Section 4.6	 Review	
315
Exercises 4.6	
315
Chapter 4	Review	
323
	
On the Computer	
324
Chapter 5	
Relations, Functions,  
and Matrices	
327
5.1	
Relations	
328
Binary Relations	
328
Properties of Relations	
332
Closures of Relations	
334
Partial Orderings	
336
Equivalence Relations	
339
Section 5.1	 Review	
344
Exercises 5.1	
345
5.2	
Topological Sorting	
356
Section 5.2	 Review	
361
Exercises 5.2	
362
5.3	
Relations and Databases	
365
Entity-Relationship Model	
365
Relational Model	
366
Operations on Relations	
369
Null Values and Three-valued Logic	373
Database Integrity	
375
Section 5.3	 Review	
376
Exercises 5.3	
376
5.4	
Functions	
381
Definition	
381
Properties of Functions	
388
Onto Functions	
388
One-to-One Functions	
389
Bijections	
390
Composition of Functions	
390
Inverse Functions	
392
Permutation Functions	
394
How Many Functions	
397
Equivalent Sets	
401
Section 5.4	 Review	
402
Exercises 5.4	
402

x	
Contents
5.5	
Order of Magnitude	
412
Function Growth	
412
More on Analysis of Algorithms	
415
The Master Theorem	
417
Proof of the Master Theorem	
419
Section 5.5	 Review	
421
Exercises 5.5	
421
5.6	
The Mighty Mod Function	
423
Hashing	
424
Computer Security	
427
Cryptography	
427
Hashing for Password 	
 
Encryption	
433
Miscellaneous Applications	
435
Identification Codes	
435
Generating and Decomposing	
Integers	
437
Modular Arithmetic Designs	 438
Section 5.6	 Review	
440
Exercises 5.6	
440
5.7	
Matrices	
446
Terminology	
446
Matrix Operations	
448
Gaussian Elimination	
453
Boolean Matrices	
458
Special Interest Page 
Solve Millions of Equations, Faster than Gauss	
460
Section 5.7	 Review	
461
Exercises 5.7	
461
Chapter 5	Review	
470
	
On the Computer	
472
Chapter 6	
Graphs and Trees	
475
6.1	
Graphs and their  
Representations	
476
Definitions of a Graph	
476
Applications of Graphs	
479
Graph Terminology	
481
Isomorphic Graphs	
484
Planar Graphs	
487
Computer Representation  
of Graphs	
492
Adjacency Matrix	
492
Adjacency List	
494
Special Interest Page 
Isomorphic Protein Graphs	
497
Section 6.1	 Review	
498
Exercises 6.1	
498
6.2	
Trees and Their  
Representations	
509
Tree Terminology	
509
Applications of Trees	
511
Binary Tree Representation	
513
Tree Traversal Algorithms	
514
Results about Trees	
519
Section 6.2	 Review	
521
Exercises 6.2	
521
6.3	
Decision Trees	
529
Searching	
529
Lower Bounds on Searching	 532
Binary Tree Search	
533
Sorting	
535
Section 6.3	 Review	
536
Exercises 6.3	
536
6.4	
Huffman Codes	
539
Problem and Trial Solution	
539
Huffman Encoding Algorithm	
542
Justification	
544
Application of Huffman Codes	
546
Section 6.4	 Review	
547
Exercises 6.4	
548
Chapter 6	Review	
551
	
On the Computer	
552
Chapter 7	
Graph Algorithms	
553
7.1	
Directed Graphs and Binary  
Relations; Warshall’s  
Algorithm 	
554
Directed Graphs and  
Binary Relations	
555
Reachability	
557
Warshall’s Algorithm	
562

Contents	
xi
Section 7.1	 Review	
566
Exercises 7.1	
566
7.2	
Euler Path and Hamiltonian  
Circuit	
571
Euler Path Problem	
571
Hamiltonian Circuit Problem	
576
Section 7.2	 Review	
577
Exercises 7.2	
577
7.3	
Shortest Path and Minimal  
Spanning Tree	
581
Shortest-Path Problem	
581
Minimal Spanning Tree Problem	
587
Special Interest Page 
Pathfinding	
589
Section 7.3	 Review	
591
Exercises 7.3	
591
7.4	
Traversal Algorithms	
596
Depth-First Search	
596
Breadth-First Search	
598
Analysis	
601
Applications	
601
Section 7.4	 Review	
604
Exercises 7.4	
604
7.5	
Articulation Points and  
Computer Networks	
607
The Problem Statement	
607
The Idea behind the Algorithm	
608
The Algorithm Itself	
610
Section 7.5	 Review	
612
Exercises 7.5	
612
Chapter 7	Review	
614
	
On the Computer	
615
Chapter 8	
Boolean Algebra and  
Computer Logic	
617
8.1	
Boolean Algebra Structure	
618
Models or Abstractions	
619
Definition and Properties	
620
Isomorphic Boolean Algebras	
626
What is Isomorphism?	
626
Isomorphism as Applied 	
 
to Boolean Algebra	
628
Section 8.1	 Review	
631
Exercises 8.1	
631
8.2	
Logic Networks	
638
Combinational Networks	
638
Basic Logic Elements	
638
Boolean Expressions	
639
Truth Functions	
640
Networks and Expressions	
641
Canonical Form	
642
Minimization	
645
Programmable Logic 	
 
Devices	
647
A Useful Network	
648
Other Logic Elements	
650
Constructing Truth Functions	
652
Special Interest Page 
Pruning Chips and Programs	
654
Section 8.2	 Review	
655
Exercises 8.2	
655
8.3	
Minimization	
663
Minimization Process	
663
Karnaugh Map	
665
Maps for Three and 	
 
Four Variables	
666
Using the Karnaugh Map	
668
Quine–McCluskey Procedure	
673
Section 8.3	 Review	
677
Exercises 8.3	
678
Chapter 8	Review	
683
	
On the Computer	
684
Chapter 9	
Modeling Arithmetic,  
Computation, and  
Languages	
685
9.1	
Algebraic Structures	
686
Definitions and Examples	
686
Basic Results about Groups	
695
Subgroups	
698
Isomorphic Groups	
702

xii	
Contents
Section 9.1	 Review	
708
Exercises 9.1	
708
9.2	
Coding Theory	
714
Introduction	
714
Background: Homomorphisms  
and Cosets	
715
Generating Group Codes	
717
Decoding Group Codes	
723
Section 9.2	 Review	
727
Exercises 9.2	
727
9.3	
Finite-State Machines	
728
Definition	
729
Examples of Finite-State Machines	 729
Recognition	
733
Regular Sets and Kleene’s Theorem	 735
Machine Minimization	
737
Unreachable States	
737
Minimization Procedure	
739 
Sequential Networks and  
Finite-State Machines	
744
Special Interest Page 
FSMs Behind the Game	
749
Section 9.3	 Review	
750
Exercises 9.3	
750
9.4	
Turing Machines	
759
Definition	
760
Turing Machines as Set  
Recognizers	
764
Turing Machines as Function  
Computers	
767
Church–Turing Thesis	
769
Decision Problems and  
Uncomputability	
771
Examples of Decision 	
 
Problems	
772
Halting Problem	
773
Computational Complexity	
776
Section 9.4	 Review	
778
Exercises 9.4	
779
9.5	
Formal Languages	
782
Classes of Grammars	
789
Formal Languages and  
Computational Devices	
792
Context-Free Grammars	
793
Section 9.5	 Review	
795
Exercises 9.5	
795
Chapter 9	Review	
799
	
On the Computer	
800
Appendix A	
Derivation Rules for  
Propositional and Predicate  
Logic	
803
Appendix B	
Summation and Product  
Notation	
805
Appendix C	
The Logarithm Function	
809	
	
	
Answers to Practice Problems	
813
	
	
Answers to Odd-Numbered  
Exercises	
851
	
	
Answers to Self-Tests	
949
 	 	
Index	
959

Preface
A course in discrete structures (discrete mathematics) played an important role 
in Curriculum 68, the very first ACM Computer Science Curriculum Guide: 
“This course introduces the student to those fundamental algebraic, logical, and 
combinatoric concepts from mathematics needed in the subsequent computer 
science courses and shows the applications of these concepts to various areas 
of computer science.”1 Fast forward 45 years or so (through mobile comput-
ing, wireless networks, robotics, virtual reality, 3-D graphics, the Internet …)  
to the joint ACM/IEEE-CS Computer Science Curricula 2013, where—still—
discrete structures are of fundamental importance. “The material in discrete 
structures is pervasive in the areas of data structures and algorithms but ap-
pears elsewhere in computer science as well. For example, an ability to create 
and understand a proof—either a formal symbolic proof or a less formal but 
still mathematically rigorous argument—is important in virtually every area of 
computer science, including (to name just a few) formal specification, verifica-
tion, databases, and cryptography. Graph theory concepts are used in networks, 
operating systems, and compilers. Set theory concepts are used in software 
engineering and in databases. Probability theory is used in intelligent systems, 
networking, and a number of computing applications.”2
This Seventh Edition was guided by Curricula 2013, and virtually all of the 
Core Tier 1 and Tier 2 topics for discrete structures from that document are includ-
ed. Covering all those topics can fill a one-semester course, but there is certainly 
enough material in this edition to make for a very respectable two-semester course.
However much we as instructors may see the value in this foundational 
course, it is a difficult experience for many students, who often view it as a series 
of unconnected topics with little or no application to the rest of their chosen field 
of study. In the big picture, these topics are bound together by themes of
•	 importance of logical thinking
•	 power of mathematical notation
•	 usefulness of abstractions
but such themes are best appreciated in hindsight. Telling students, “You will 
need ideas from this course in many of your future computer science courses,” 
is also of little motivation. That’s why it is important to carve out time in your 
course syllabus (for either a one-semester or two-semester course) for some of 
the applications of this material. Here are topics in this edition that you may 
1Communications of the ACM, Vol. 11, Issue 3 (March 1968), pp. 151–197.	
2Computer Science Curricula 2013, Pre-release version, http://cs2013.com

xiv	
Preface
choose from, according to your interests and the interests of your students. Yes, 
students will probably see most of these topics in more detail in later computer 
science courses, but a quick introduction now can keep their interest and make 
your claim of relevance more credible.
Section 1.5	
Logic programming
Sections 1.6 and 2.3	
Proof of correctness
Section 3.3	
Analysis of algorithms
Section 5.3	
Relations and databases
Section 5.6	
The mighty mod function
Section 6.4	
Huffman codes
Section 8.2	
Logic networks
Section 9.2	
Coding theory
In addition, there is a Special Interest Page in each chapter that highlights 
interesting applications culled from “the real world.”
New in the Se venth Edition
•	 The former Chapters 2 and 3 have been reorganized as Chapters 2, 3, and 
4 for better clarity and sequencing
•	 New sections or subsections have been added:
Probability
•	 Bayes’ Theorem
•	 Binomial Distribution
Order of Magnitude (new section)
•	 The Master Theorem
•	 Proof of the Master Theorem
Matrices
•	 Gaussian Elimination
Coding Theory (new section)
•	 Introduction
•	 Background: Homomorphisms and Cosets
•	 Generating Group Codes
•	 Decoding Group Codes
•	 “Special interest pages”—one per chapter—have been introduced to add 
relevance and interest to the material being presented.
•	 Answers to all odd-numbered exercises, as opposed to answers to fewer, 
selected exercises, appear in the back of the book. When an exercise asks 

Preface	
xv
for a proof, the complete proof is given. Otherwise, the answer is just 
the answer, not necessarily the solution. A Student Solutions Manual with 
solutions for odd-numbered exercises from the book is available from the 
Web site at www.whfreeman.com/gersting. The student manual also in-
cludes two sample tests per chapter. A complete Solutions Manual is avail-
able to instructors from the publisher.
•	 Many new exercises have been added, particularly with an eye toward 
pairing odd-numbered exercises with similar even-numbered exercises.
•	 Of course, student learning aids such as chapter objectives, practice prob-
lems, reminders, section reviews, and chapter reviews remain.
Web Site
Online Study Guide
A Web site for the book may be found at www.whfreeman.com/gersting. The Web 
pages contain representative new example problems (not contained in the text) for 
many of the end-of-section Techniques. Each Technique that has a corresponding 
Web page example is marked with the icon W .
Each example on the Web first states the problem. Then succeeding pages 
develop the solution, much as the student would be expected to write it. As the stu-
dent navigates the pages, the solution unfolds step-by-step. A compressed audio 
file is also part of each Web page after the initial problem statement. The audio file 
contains a first-person stream-of-consciousness thought process about that step of 
the solution—why it occurred to the narrator to try this, why it looked promising, 
what knowledge was being called on to suggest that this step should come next, 
and so on. The point is, students see perfect and complete worked-out proofs in 
the textbook and often see them performed by the instructor. Yet when a student 
goes home and tries to produce such a solution by himself or herself, he or she is 
unsure where to start or how to think about the problem or how to see any pat-
tern to enable a guess as to what to do next. Consequently the student gives up in 
frustration. The purpose of the audio narration is to share the “secret picture” that 
mathematicians use to solve problems.
To access the problems, after you go to www.whfreeman.com/gersting, select 
a chapter section, then select a sample problem and follow its step-by-step process 
with the “Next” button.
PowerPoint Slides
Instructors who visit the web site will also have access to PowerPoint slides 
­accompanying each section of the text.

xvi	
Preface
Acknowledgments
My thanks to the reviewers of this addition, as well to reviewers of earlier edi-
tions, all of whose help is greatly appreciated.
Elizabeth Adams, James Madison University
Kemal Akkaya, Southern Illinois University
Charles Ashbacher, Mount Mercy College
Barnabas Bede, DigiPen Institute of Technology
Terry J. Bridgeman, Colorado School of Mines
David Casperson, University of Northern British Columbia
Adrienne Decker, SUNY Buffalo
Steve Donaldson, Samford University
Mordechai S. Goodman, Dominican University
Michael A. Gray, American University
Jerrold R. Griggs, University of South Carolina
Joseph Hobart, Okanagan College
Mark Jacobson, University of Northern Iowa
Lisa A. Jamba, University of Northern Florida
Tim Lin, Cal Poly
David Lugenbuhl, Western Carolina University
Damian Lyons, Fordham University
Mariana Maris, Arizona State University
Mikel D. Petty, University of Alabama in Huntsville
Amar Raheja, Cal Poly
J. Ben Schafer, University of Northern Iowa
Ali Shaykhian, Florida Institute of Technology
Shunichi Toida, Old Dominion University
William J. Weber, Southeast Missouri State University
Eric Westlund, Luther University
Hua Yan, Borough of Manhattan Community College
Yu Zhang, Texas A&M Corpus Christi
The folks at W.H. Freeman were very helpful in shepherding this edition 
to completion, especially Penny Hull (veteran of many previous editions), Terri 
Ward, Roland Cheyney, Liam Ferguson, Georgia Lee Hadler, and Vicki Tomaselli.
Thanks to Russell Kackley for the audio files on the Web site.
My deepest thanks go to my husband, John, ever my most ardent supporter 
and dearest friend.
Note to the Student
As you go through this book, you’ll encounter many new terms and new ideas. 
Try reading with pencil and paper at hand and work the Practice problems as you 
encounter them. They are intended to reinforce or clarify some new terminology 
or method just introduced; answers are given at the back of the book. Pay atten-
tion also to the Reminders that point out common pitfalls or provide helpful hints. 
Be sure to visit the Web site at www.whfreeman.com/gersting for detailed, 
worked-out solutions to additional example problems tied to the Techniques in 
each section. The Web site solutions are accompanied by audio files that explain 
each step. A Student Solutions Manual with solutions for odd-numbered exercises 
from the book is available from the Web site. The student manual also includes two 
sample tests per chapter.
You may find at first that the thought processes required to solve the exercises 
in the book are new and difficult. Your biggest attribute for success will be persever-
ance. Here’s what I tell my students: “If you do not see at first how to solve a problem, 
don’t give up, think about it some more; be sure you understand all the terminology 
used in the problem, play with some ideas. If no approach presents itself, let it be 
and think about it again later. Repeat this process for days on end. When you finally 
wake up in the middle of the night with an idea, you’ll know you are putting in the 
right amount of effort for this course.” Mathematical results don’t spring fully formed 
from the foreheads of mathematical geniuses; well, maybe from mathematical ge-
niuses, but for the rest of us, it takes work, patience, false starts, and perseverance.
Enjoy the experience!

Chapter Objectives
After studying this chapter, you will be able to:
•	 Use the formal symbols of propositional logic.
•	 Find the truth value of an expression in propositional logic.
•	 Construct formal proofs in propositional logic, and use such proofs to deter-
mine the validity of English language arguments.
•	 Use the formal symbols of predicate logic.
•	 Find the truth value in some interpretation of an expression in predicate logic.
•	 Use predicate logic to represent English language sentences.
•	 Construct formal proofs in predicate logic, and use such proofs to determine 
the validity of English language arguments.
•	 Understand how the programming language Prolog is built on predicate logic.
•	 Mathematically prove the correctness of programs that use assignment state-
ments and conditional statements.
You have been selected to serve on jury duty for a criminal case. The attorney for the 
defense argues as follows: 
If my client is guilty, then the knife was in the drawer. Either the knife was not in the 
drawer or Jason Pritchard saw the knife. If the knife was not there on October 10, 
it follows that Jason Pritchard did not see the knife. Furthermore, if the knife was 
there on October 10, then the knife was in the drawer and also the hammer was in 
the barn. But we all know that the hammer was not in the barn. Therefore, ladies 
and gentlemen of the jury, my client is innocent.
	
Question: 	
Is the attorney’s argument sound? How should you vote?
It’s much easier to answer this question if the argument is recast in the notation 
of formal logic. Formal logic strips away confusing verbiage and allows us to 
concentrate on the underlying reasoning being applied. In fact, formal logic—the 
subject of this chapter—provides the foundation for the organized, careful method 
of thinking that characterizes any reasoned activity—a criminal investigation, a 
scientific experiment, a sociological study. In addition, formal logic has direct 
applications in computer science. The last two sections of this chapter explore 
a programming language based on logic and the use of formal logic to verify 
the correctness of computer programs. Also, circuit logic (the logic governing 
1
Formal Logic
Chapter

2	
Formal Logic
computer circuitry) is a direct analog of the statement logic of this chapter. We 
will study circuit logic in Chapter 8.
	
S e c t i o n  1 .1 	 Statements, Symbolic Representation, 
and Tautologies
Formal logic can represent the statements we use in English to communicate facts 
or information. A statement (or proposition) is a sentence that is either true or 
false.
	
EXAMPLE 1	
Consider the following:
	
a.	 Ten is less than seven.
	
b.	 Cheyenne is the capital of Wyoming.
	
c.	 She is very talented.
	
d.	 There are life forms on other planets in the universe.
Sentence (a) is a statement because it is false. Sentence (b) is a statement because 
it is true. Sentence (c) is neither true nor false because “she” is not specified; there-
fore (c) is not a statement. Sentence (d) is a statement because it is either true or 
false; we do not have to be able to decide which.
Connectives and Truth Values
In English, simple statements are combined with connecting words like and to 
make more interesting compound statements. The truth value of a compound 
statement depends on the truth values of its components and which connecting 
words are used. If we combine the two true statement, “Elephants are big,” and, 
“Baseballs are round,” we would consider the resulting statement, “Elephants are 
big and baseballs are round,” to be true. In this book, as in many logic books, 
capital letters near the beginning of the alphabet, such as A, B, and C, are used to 
represent statements and are called statement letters; the symbol ` is a logical 
connective representing and. We agree, then, that if A is true and B is true, A ` B 
(read “A and B”) should be considered true.
PRACTICE 1	
1
a.	 If A is true and B is false, what truth value would you assign to A ` B?
b.	If A is false and B is true, what truth value would you assign to A ` B?
c.	 If A and B are both false, what truth value would you assign to A ` B?
The expression A ` B is called the conjunction of A and B, and A and B are 
called the conjuncts of this expression. Table 1.1 summarizes the truth value of 
A ` B for all possible truth values of the conjuncts A and B. Each row of the table 
1Answers to practice problems are in the back of the text.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
3
represents a particular truth value assignment to the statement let-
ters, and the resulting truth value for the compound expression is 
shown.
Another connective is the word or, denoted by the symbol ~. The 
expression A ~ B (read “A or B”) is called the disjunction of A and B, 
and A and B are called the disjuncts of this expression. If A and B are 
both true, then A ~ B would be considered true, giving the first line 
of the truth table for disjunction (Table 1.2).
Table 1.2
A
B
A ~ B
T
T
T
T
F
F
T
F
F
Table 1.1
A
B
A ` B
T
T
T
T
F
F
F
T
F
F
F
F
PRACTICE 2	 Use your understanding of the word or to complete the truth table for disjunction,  
Table 1.2.
Statements may be combined in the form “if statement 1, then statement 2.” If 
A denotes statement 1 and B denotes statement 2, the compound statement would 
be denoted by A S B (read “A implies B”). The logical connective here is implica-
tion, and it conveys the meaning that the truth of A implies or leads to the truth of 
B. In the implication A S B, A stands for the antecedent statement and B stands 
for the consequent statement. 
The truth table for implication is less obvious than that for conjunction or 
disjunction. To understand its definition, let’s suppose your friend remarks, “If I 
pass my economics test, then I’ll go to the movie Friday.” If your friend passes the 
test and goes to the movie, the remark was true. If your friend passes the test but 
doesn’t go to the movie, the remark was false. If your friend doesn’t pass the test, 
then—whether he or she goes to the movie or not—you could not claim that the 
remark was false. You would probably want to give the benefit of the doubt and say 
that the statement was true. By convention, A S B is considered true if A is false, 
regardless of the truth value of B.
PRACTICE 3	 Summarize this discussion by writing the truth table for A S B.
Table 1.3
A
B
A S B
B S A
(A S B) ` (B S A)
T
T
T
T
T
T
F
F
T
F
F
T
T
F
F
F
F
T
T
T
The equivalence connective is symbolized by 4. Unlike conjunction, 
disjunction, and implication, the equivalence connective is not really a funda-
mental connective but a convenient shortcut. The expression A 4 B stands for 
(A S B) ` (B S A). We can write the truth table for equivalence by constructing, 
one piece at a time, a table for (A S B) ` (B S A), as in Table 1.3. From this truth 
table, A 4 B is true exactly when A and B have the same truth value.
The connectives we’ve seen so far are called binary connectives because 
they join two expressions together to produce a third expression. Now let’s consider 
a unary connective, a connective acting on one expression to produce a second 

4	
Formal Logic
expression. Negation is a unary connective. The negation of A—­symbolized by 
A′—is read “not A.”
Practice 4	 Write the truth table for A′. (It will require only two rows.)
Table 1.4 summarizes the truth values for all of the logical connectives. This 
information is critical to an understanding of logical reasoning.
Table 1.4
A
B
A ` B
A ~ B
A S B
A 4 B
A′
T
T
T
T
T
T
F
T
F
F
T
F
F
F
T
F
T
T
F
T
F
F
F
F
T
T
Reminder
A only if B means
A S B
Because of the richness of the English language, words that have differ-
ent shades of meaning are nonetheless represented by the same logical connec-
tive. Table 1.5 shows the common English words associated with various logical 
connectives.
Table 1.5
English Word
Logical Connective
Logical Expression
and; but; also; in addition; 
moreover
Conjunction
A ` B
or
Disjunction
A ~ B
If A, then B. 
A implies B. 
A, therefore B.
A only if B. 
B follows from A. 
A is a sufficient condition 
for B.
B is a necessary condition 
for A.
Implication
A S B
A if and only if B.
A is necessary and 
­sufficient for B.
Equivalence
A 4 B
not A
It is false that A ...
It is not true that A ...
Negation
A′
Suppose that A S B is true. Then, according to the truth table for implication, 
the consequent, B, can be true even though the antecedent, A, is false. So while 
the truth of A leads to (implies) the truth of B, the truth of B does not imply the 
truth of A. The phrase “B is a necessary condition for A” to describe A S B simply 

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
5
Table 1.6
Statement
Correct Negation
Incorrect Negation
It will rain tomorrow.
It is false that it will rain 
­tomorrow.
It will not rain tomorrow.
Peter is tall and thin.
It is false that Peter is tall 
and thin.
Peter is not tall or he is 
not thin.
Peter is short or fat.
Peter is short and fat.
Too strong a statement. 
Peter fails to have both 
properties (tallness and 
thinness) but may still 
have one property.
The river is shallow or 
­polluted.
It is false that the river is 
shallow or polluted.
The river is neither shallow 
nor polluted.
The river is deep and 
­unpolluted.
The river is not shallow or 
not polluted.
Too weak a statement. 
The river fails to have 
­either property, not just 
fails to have one property.
means that if A is true, then B is necessarily true, as well. “A only if B” describes 
the same thing, that A implies B.
	
EXAMPLE 2	
The statement, “Fire is a necessary condition for smoke,” can be restated, “If there 
is smoke, then there is fire.” The antecedent is “there is smoke,” and the conse-
quent is “there is fire.”
PRACTICE 5	 Name the antecedent and consequent in each of the following statements. (Hint: Rewrite 
each statement in if-then form.)
a.	 If the rain continues, then the river will flood.
b.	A sufficient condition for network failure is that the central switch goes down.
c. 	The avocados are ripe only if they are dark and soft.
d.	A good diet is a necessary condition for a healthy cat.
	
EXAMPLE 3	
Expressing the negation of a statement must be done with care, especially for a 
compound statement. Table 1.6 gives some examples.
PRACTICE 6	 Which of the following represents A′ if A is the statement “Julie likes butter but hates 
cream”?
a.	 Julie hates butter and cream.
b.	Julie does not like butter or cream.
c.	 Julie dislikes butter but loves cream.
d.	Julie hates butter or likes cream.

6	
Formal Logic
We can string statement letters, connectives, and parentheses (or brackets) 
together to form new expressions, as in 
(A S B) ` (B S A)
Of course, just as in a computer programming language, certain syntax rules 
(rules on which strings are legitimate) prevail; for example,
A )) `` S BC 
would not be considered a legitimate string. An expression that is a legitimate 
string is called a well-formed formula, or wff. To reduce the number of parenthe-
ses required in a wff, we stipulate an order in which connectives are applied. This 
order of precedence is
	
1.	 connectives within parentheses, innermost parentheses first
	
2.	 ′
	
3.	 `, ~
	
4.	 S
	
5.	 4
This means that the expression A ~ B′ stands for A ~ (B′), not (A ~ B)′. Similarly, 
A ~ B S C means (A ~ B) S C, not A ~ (B S C ). However, we often use paren-
theses anyway, just to be sure that there is no confusion.
In a wff with a number of connectives, the connective to be applied last is the 
main connective. In
A ` (B S C )′
the main connective is `. In
((A ~ B) ` C ) S (B ~ C′)
the main connective is S. Capital letters near the end of the alphabet, such as P, Q, 
R, and S, are used to represent wffs. Thus P could represent a single statement let-
ter, which is the simplest kind of wff, or a more complex wff. We might represent 
((A ~ B) ` C ) S (B ~ C′)
as
P S Q
if we want to hide some of the details for the moment and only concentrate on the 
main connective.
Wffs composed of statement letters and connectives have truth values that 
depend on the truth values assigned to their statement letters. We write the 
truth table for any wff by building up the component parts, just as we did for 
(A S B) ` (B S A). The main connective is addressed in the last column of the 
table.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
7
Table 1.7
A
B
B′
A ~ B′
A ~ B
( A ~ B)′
A ~ B′ S ( A ~ B)′
T
T
F
T
T
F
F
T
F
T
T
T
F
F
F
T
F
F
T
F
T
F
F
T
T
F
T
T
If we are making a truth table for a wff that contains n different statement 
letters, how many rows will the truth table have? From truth tables done so far, 
we know that a wff with only one statement letter has two rows in its truth table, 
and a wff with two statement letters has four rows. The number of rows equals the 
number of true-false combinations possible among the statement letters. The first 
statement letter has two possibilities, T and F. For each of these possibilities, the 
second statement letter has two possible values. Figure 1.1a pictures this as a two-
level “tree” with four branches showing the four possible combinations of T and F 
for two statement letters. For n statement letters, we extend the tree to n levels, as 
in Figure 1.1b. The total number of branches then equals 2n. The total number of 
rows in a truth table for n statement letters is also 2n.
	
EXAMPLE 4	
The truth table for the wff A ~ B′ S (A ~ B)′ is given in Table 1.7. The main con-
nective, according to the rules of precedence, is implication.
T
F
T
F
T
F
F
F
T
F
T
T
T
F
Statement letters
1
2
Choices
2 = 21 branches
4 = 22 branches
(a)
T
F
T
F
T
F
T
F
T
F
T
F
T
F
Statement letters
1
2
Choices
2 = 21 branches
4 = 22 branches
3
…
…
…
8 = 23 branches
n
2n branches
(b)
Figure 1.1

8	
Formal Logic
This tree structure also tells us how to enumerate all the T–F com-
binations among the n statement letters when setting up a truth table. If 
we read each level of the tree from bottom to top, it says that the T–F 
values for statement letter n (which will compose the last column of the 
truth table) alternate, those for statement letter n − 1 alternate every 
two values, those for statement letter n − 2 alternate every four values, 
and so forth. Thus a truth table for three statement letters would begin 
as shown in Table 1.8. The values for statement letter C alternate, those 
for statement letter B alternate in groups of two, and those for state-
ment letter A alternate in groups of four, resulting in something like a 
sideways version of the tree. (Reading the rows from the bottom up and 
using 1 for T and 0 for F shows that we are simply counting up from zero 
in binary numbers.)
Table 1.8
A
B
C
T
T
T
T
T
F
T
F
T
T
F
F
F
T
T
F
T
F
F
F
T
F
F
F
PRACTICE 7	 Construct truth tables for the following wffs.
a.	 (A S B) 4 (B S A) (Remember that C 4 D is true precisely when C and D have the same  
truth value.)
b.	(A ~ A′) S (B ` B′)
c.	 [(A ` B′) S C′]′
d.	(A S B) 4 (B′S A′)	
Tautologies
A wff-like item (d) of Practice 7, whose truth values are always true, is called a 
tautology. A tautology is “intrinsically true” by its very structure; it is true no 
matter what truth values are assigned to its statement letters. A simpler example 
of a tautology is A ~ A′; consider, for example, the statement “Today the sun will 
shine or today the sun will not shine,” which must always be true because one 
or the other of these must happen. A wff like item (b) of Practice 7, whose truth 
values are always false, is called a contradiction. A contradiction is “intrinsically 
false” by its very structure. A simpler example of a contradiction is A ` A′; con-
sider “Today is Tuesday and today is not Tuesday,” which is false no matter what 
day of the week it is.
Suppose that P and Q represent two wffs, and it happens that the wff 
P 4 Q is a tautology. If we did a truth table using the statement letters in P 
and Q, then the truth values of the wffs P and Q would agree for every row of 
the truth table. In this case, P and Q are said to be equivalent wffs, denoted by 
P 3 Q. Thus P 3 Q states a fact, namely, that the particular wff P 4 Q is a 
tautology. Practice 7(d) has the form P 4 Q , where P is the wff (A S B) and 
Q is the wff (B′ S A′), and P 4 Q was shown to be a tautology. Therefore, 
(A S B) 3 (B′ S A′).
We will list some basic equivalences, prove one or two of them by construct-
ing truth tables, and leave the rest as exercises. We represent any contradiction by 
0 and any tautology by 1.
REMINDER
A, B, C stand for single 
statement letters; P, Q, 
R, S stand for wffs.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
9
Some Tautological Equivalences
1a.  A ~ B 3 B ~ A	
1b.  A ` B 3 B ` A	
(commutative properties)
2a.  (A ~ B) ~ C 3 A ~ (B ~ C )	
2b.  (A ` B) ` C 3 A ` (B ` C )	
(associative properties)
3a.  A ~ (B ` C ) 3	
3b.  A ` (B ~ C ) 3	
(distributive properties) 
     (A ~ B) ` (A ~ C )	
    (A ` B) ~ (A ` C )
4a.  A ~ 0 3 A	
4b.  A ` 1 3 A	
(identity properties)
5a.  A ~ A′ 3 1	
5b.  A ` A′ 3 0	
(complement properties)
Note that 2a allows us to write A ~ B ~ C with no need for parentheses because 
the grouping doesn’t matter; similarly, 2b allows us to write A ` B ` C.
	
EXAMPLE 5	
The truth table in Table 1.9a verifies equivalence 1a, the commutative property for 
disjunction, and that in Table 1.9b verifies 4b, the identity property for conjunc-
tion. Note that only two rows are needed for Table 1.9b because 1 (a tautology) 
cannot take on false truth values.
The equivalences in the list are grouped into five pairs. In each pair, one 
equivalence can be obtained from the other by replacing ` with ~, ~ with `, 0 
with 1, or 1 with 0. Each equivalence in a pair is called the dual of the other. Thus, 
1a and 1b (commutativity of disjunction and commutativity of conjunction) are 
duals of each other. This list of equivalences appears in a more general setting in 
Chapter 8.
Two additional equivalences that are very useful are De Morgan’s laws, 
named for the nineteenth-century British mathematician Augustus De Morgan, 
who first stated them. This theorem is easy to prove (see Exercises 26e and 26f).
A
1
A ` 1
A ` 1 4 A
T
T
T
T
F
T
F
T
Table 1.9
A
B
A ~ B
B ~ A
A ~ B 4 B ~ A
T
T
T
T
T
T
F
T
T
T
F
T
T
T
T
F
F
F
F
T
(a)
(b)
PRACTICE 8	 Verify equivalence 5a.

10	
Formal Logic
Each is the dual of the other. De Morgan’s laws help in expressing the negation of 
a compound statement, as in Practice 6.
Think of these tautological equivalences as patterns; in order to use one 
of them, you must match its pattern exactly. For example, you can’t say that 
(A ` B) ~ C 3 A ` (B ~ C ) by either of the associative properties because nei-
ther of these properties uses both conjunction and disjunction.
Suppose that P and Q are equivalent wffs. Then in any wff where P appears, P 
can be replaced by Q with no change in the overall truth values. It’s like replacing 
a $20 bill in your wallet with two $10 bills—the total value of your money hasn’t 
changed.
	
theorem	
De Morgan’s Laws
	
(A ~ B)′ 3 A′ ` B′         and         (A ` B)′ 3 A′ ~ B′
Logical Connectives in the Real World
Web search engines allow exploration of the vast resources available on the Web, 
but a little care in your search query can help focus the results more quickly. For 
example, if you enter
used cars
in a Web search engine, you may get back references to any Web site containing 
either the word used or the word cars; this could include sites for antique dealers 
and sites for the latest auto racing results. Entering the phrase
“used cars”
in quotes restricts the search, on most search engines, to Web sites containing this 
exact phrase. Most search engines also allow you to enter an expression using log-
ical connectives as your search query, which can help make the query even more 
specific. To further narrow your used car search, for example, you could enter
	
EXAMPLE 6	
From Practice 7(d), A S B is equivalent to B′ S A′. The wff (A S B) S B should 
therefore be equivalent to (B′ S A′) S B. This equivalence is verified by Tables 
1.10a and 1.10b.
A
B
A′
B′
B′ S A′
(B′ S A′) S B
T
T
F
F
T
T
T
F
F
T
F
T
F
T
T
F
T
T
F
F
T
T
T
F
A
B
A S B
(A S B) S B)
T
T
T
T
T
F
F
T
F
T
T
T
F
F
T
F
(a)
(b)
Table 1.10

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
11
“used cars” AND (Ford OR Buick) 
This would tend to limit your search to sites that mention only particular brands 
of used cars, although you could still wind up with a link to Jim Bob Ford’s Loan 
Shark Agency, which will lend you money for any used car. The query
“used cars” AND (Ford OR Buick) AND NOT trucks
would eliminate sites mentioning trucks. Many search engines use + (a plus sign) 
in place of AND, and − (a minus sign) in place of AND NOT.
The logical connectives AND, OR, and NOT are also available in many pro-
gramming languages, as well as on programmable graphing calculators. These 
connectives, in accordance with the truth tables we have defined, act on com-
binations of true or false expressions to produce an overall truth value. Such 
truth values provide the decision-making capabilities fundamental to the flow of 
control in computer programs. Thus, at a conditional branch in a program, if the 
truth value of the conditional expression is true, the program will next execute 
one section of code; if the value is false, the program will next execute a different 
section of code. If the conditional expression is replaced by a simpler, equivalent 
expression, the truth value of the expression and hence the flow of control of 
the program is not affected, but the new code is easier to understand and may 
execute faster.
	
EXAMPLE 7	
Consider a statement in a computer program that has the form
if ((outflow > inflow) and not ((outflow > inflow) and (pressure < 1000)))
do something;
else
do something else;
Here the conditional expression has the form
A ` (A ` B)′
where A is “outflow > inflow” and B is “pressure <1000.” This expression can be 
simplified by replacing some wffs with equivalent wffs.
A ` (A ` B)′ 3 A ` (A′ ~ B′)	
(De Morgan’s laws)
	
3 (A ` A′) ~ (A ` B′)	
(tautology 3b) 
	
3 0 ~ (A ` B′)	
(tautology 5b)
	
3 (A ` B′) ~ 0	
(tautology 1a)
	
3 A ` B′	
(tautology 4a)
The statement form can therefore be written
if ((outflow > inflow) and not (pressure < 1000))
do something;
else
do something else;

12	
Formal Logic
Finally, the truth tables for conjunction, disjunction, and negation are implemented 
by electronic devices called “gates” (AND gate, OR gate, inverter, respectively) 
that are fundamental building blocks in computer circuitry. We’ll see in Chapter 
8 (Boolean Algebra and Computer Logic) how to combine these gates into more 
complex logic networks to carry out specific tasks.
An Algorithm
To test whether a wff is a tautology, we can always write its truth table. For n 
statement letters, 2n rows will be needed for the truth table. Suppose, however, 
that the wff has implication as its main connective, so that it has the form P S Q 
where P and Q are themselves wffs. Then we can use a quicker procedure than 
constructing a truth table to determine whether P S Q is a tautology. We assume 
that P S Q is not a tautology, and we see whether this leads to some impossible 
situation. If it does, then the assumption that P S Q is not a tautology is also im-
possible, and P S Q must be a tautology after all.
To assume that P S Q is not a tautology is to say that it can take on false 
values, and, by the truth table for implication, P S Q is false only when P is 
true and Q false. By assigning P true and Q false, we determine possible truth 
values for the wffs making up P and Q. We continue assigning the truth values so 
determined until all occurrences of statement letters have a truth value. If some 
statement letter is assigned both true and false values by this process, we have an 
impossible situation, so the wff P S Q must be a tautology. Otherwise, we have 
found a way to make P S Q false, and it is not a tautology.
What we have described is a set of instructions—a procedure—for carry-
ing out the task of determining whether P S Q is a tautology. This procedure 
can be executed by mechanically following the instructions; in a finite amount 
of time, we will have the answer. In computer science terms, the procedure is an 
algorithm.
	
Definition	
Algorithm
An algorithm is a set of instructions that can be mechanically executed in a finite 
amount of time in order to solve some problem.
Algorithms constitute the very heart of computer science, and we will have 
much to say about them throughout this book. You are probably already aware that 
the major task in writing a computer program for solving a problem consists of 
devising an algorithm (a procedure) to produce the problem solution.
Algorithms are often described in a form that is a middle ground between 
a purely verbal description in paragraph form (as we gave for deciding whether 
P S Q is a tautology) and a computer program (that, if executed, would actu-
ally carry out the steps of the algorithm) written in a programming language. 
This compromise form to describe algorithms is called pseudocode. An algorithm 
written in pseudocode should not be hard to understand even if you know nothing 
about computer programming. The only thing to note about the pseudocode used 
in this book is that lines preceded by double slashes (//) are explanatory com-
ments, not part of the algorithm itself.
Following is a pseudocode form of the algorithm to determine whether P S Q 
is a tautology.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
13
The algorithm first assigns the truth values “true” to P and “false” to Q, con-
sistent with the assumption that P S Q is not a tautology. The algorithm then 
enters a loop, where a sequence of steps is repeated until some condition is met. 
Within the loop, truth assignments continue to be made to smaller and smaller 
components of the original P and Q until all occurrences of individual statement 
letters have truth values. Then the algorithm tests whether a contradiction has 
­occurred, and writes out the information about whether P S Q is a tautology.
	
Algorithm 	 TautologyTest
TautologyTest (wff P; wff Q)
//Given wffs P and Q, decides whether the wff P S Q is a tautology.
//Assume P S Q is not a tautology
P = true	 	
//assign T to P
Q = false	 	
//assign F to Q
repeat
for each compound wff already assigned a truth value,
  assign the truth values determined for its components
until all occurrences of statements letters have truth values
if some letter has two truth values
then  //contradiction, assumption false
	
write (“P S Q is a tautology.”)
else  //found a way to make P S Q false
write (“P S Q is not a tautology.”)
end if
end TautologyTest
	
EXAMPLE 8	
Consider the wff (A S B) S (B′ S A′). This matches the pattern needed in or-
der to use algorithm TautologyTest, namely P S Q, where P is A S B and Q is  
B′ S A′. Following the algorithm, we first assign truth values
A S B true and B′ S A′ false
Moving on to the loop, the assignment of false to the compound statement B′ S A′ 
determines the further assignments
B′ true and A′ false
or
B false and A true
Now working with P, A true and A S B true determines the assignment
B true

14	
Formal Logic
At this point all occurrences of statement letters have truth values, as follows:
	
A–T  B–T	
B–F  A–T
	
(A S B)	
S	
(B′ S A′)
	
T	
F
This terminates the loop. In the final step of the algorithm, B now has an as-
signment of both T and F, so the algorithm decides that (A S B) S (B′ S A′) 
is a tautology. Actually, we learned this earlier (in Practice 7(d)) by building a 
truth table.
Algorithm TautologyTest decides whether wffs of a certain form, namely, 
those where the main logical connective is S, are tautologies. However, the pro-
cess of building a truth table and then examining all the truth values in the final 
column constitutes an algorithm to decide whether an arbitrary wff is a tautology. 
This second algorithm is therefore more powerful because it solves a more general 
problem, but algorithm TautologyTest is usually faster for those wffs to which it 
applies.
REMINDER
Algorithm TautologyTest 
applies only when the 
main connective is S.

Special Interest Page
Can “And” Ever Be “Or”?
In 2003, OfficeMax sued the United States government 
(the Internal Revenue Service) for a return of excise 
tax that OfficeMax had paid for telephone service. 
This was not a trivial financial matter–OfficeMax had 
paid over $380,000.00 in telephone excise tax. To un-
derstand the nature of the argument, we need a brief 
history of the federal tax on telephone service.
The first telephone tax was enacted by Congress in 
1898 (22 years after the invention of the telephone by 
­Alexander Graham Bell). The tax was intended to help 
pay the federal debt incurred by the Spanish-American 
War, and it was repealed, as planned, in 1902. Over sub-
sequent years, the telephone tax came and went with 
fluctuating rates as the government incurred debt. Res-
urrected again in 1932, the tax, in one form or another, 
has been in effect ever since. In 1965, Congress defined 
local phone service and “toll telephone service” (long-
distance calls) as two categories of taxable service, and it 
set the tax rate at 3%. Of interest to this discussion is the 
definition Congress gave at this time of “toll telephone 
service,” which states in part that it is “a telephonic qual-
ity communication for which there is a toll charge which 
varies in amount with the distance and elapsed transmis-
sion time of each individual communication.” Keep in 
mind that in 1965, there was essentially only a single 
telephone service provider in the United States, namely 
AT&T, and at that time AT&T charges were based on both 
the duration and the distance of each call. By the 1990s, 
AT&T had been broken up and there were a number of 
competitive telephone companies. In addition, telephone 
companies began to charge a flat rate per minute for na-
tionwide long-distance calls. The phone companies col-
lected the federal excise tax from their customers and 
passed the tax on to the federal government.
OfficeMax used MCI as its phone service provider 
from 1999 to 2002, during which time MCI collected the 
excise tax from OfficeMax. In 2003, OfficeMax sued the 
federal government for a refund of the excise taxes MCI 
had collected on the basis that MCI was not providing 
“toll telephone service” as defined by Congress in 1965 
because MCI was charging a rate based not on time and 
distance but only on time. Here is the issue: What exact-
ly is the meaning of the word “and” in “varies in amount 
with the distance and elapsed transmission time”?
OfficeMax argument: “And” means the conjunc-
tive “and,” as the truth table for “and” is defined in 
formal logic. For the tax to apply, the phone company 
had to charge its customers a rate based on both time 
and distance.
Internal Revenue Service argument: Elsewhere 
in this same legislation, Congress did use “and” in a 
disjunctive sense when it defined “communication ser-
vices” as “local telephone service, toll telephone ser-
vice, and teletypewriter exchange service.” Because 
these three are mutually exclusive, “and” here could 
not have a conjunctive meaning.
The majority opinion of the United States Court 
of Appeals for the Sixth Circuit, in 2005, agreed with 
OfficeMax. Its reasoning was (1) dictionary defini-
tions, legal usage guides, and case law assert that “and” 
is generally conjunctive, (2) the conjunctive usage is 
consistent with the billing mechanism used by the only 
telephone company in existence at the time the law was 
written, (3) the disjunctive interpretation would allow 
the possibility of a telephone charge based solely on dis-
tance, which is a ridiculous idea that Congress surely 
did not intend, and (4) lower courts had found in favor of  
OfficeMax. In short, the IRS lost this case and a num-
ber of similar cases, and in 2006 it announced that 
phone service that is charged on time and not distance 
is not taxable. (The 3% excise tax on local telephone 
service is still in effect.)
One must, however, appreciate the humor of the 
dissenting opinion in the OfficeMax case: “A host sep-
arately asked two prospective guests what they liked to 
drink. One said, “I like bourbon and water.” The other 
said, “I like beer and wine.” When the second guest 
arrived at the event, the host served the guest a glass of 
beer mixed with wine. “What′s that awful drink?” said 
the guest, to which the host answered, “You said you 
liked beer and wine.” Sometimes we apparently do use 
“and” in a disjunctive sense. So here is a legal—and 
financial—case that hinged on the truth table for the 
logical connective AND. How cool is that?!
OFFICEMAX, INC., Plaintiff-Appellee, v. UNITED 
STATES of America, Defendant-Appellant,  
No. 04-4009, United States Court of Appeals,  
Sixth Circuit, Argued: July 29, 2005, Decided and 
Filed: November 2, 2005, 428 F.3d 583. Online at 
http://law.justia.com/cases/federal/appellate-courts/
F3/428/583/565375/
Chapter 1

16	
Formal Logic
S e c t i o n  1 .1 	
Review
Techniques
•	 Construct truth tables for compound wffs.
•	 Recognize tautologies and contradictions.
Main Ideas
•	 Wffs are symbolic representations of statements.
•	 Truth values for compound wffs depend on the 
truth values of their components and the types of 
connectives used.
•	 Tautologies are “intrinsically true” wffs—true for 
all truth values.
W
W
Exercises 1.1
	 1.	 Which of the following sentences are statements?
	
a.	 The moon is made of green cheese.
	
b.	He is certainly a tall man.
	
c.	 Two is a prime number.
	
d.	The game will be over by 4:00.
	
e.	 Next year interest rates will rise.
	
f.	 Next year interest rates will fall.
	
g.	x2 − 4 = 0
	 2.	 What is the truth value of each of the following statements?
	
a.	 8 is even or 6 is odd.
	
b.	8 is even and 6 is odd.
	
c.	 8 is odd or 6 is odd. 
	
d.	8 is odd and 6 is odd.
	
e.	 If 8 is odd, then 6 is odd.
	
f.	 If 8 is even, then 6 is odd.
	
g.	If 8 is odd, then 6 is even.
	
h.	If 8 is odd and 6 is even, then 8 < 6.
	 3.	 Given the truth values A true, B false, and C true, what is the truth value of each of the following wffs?
	
a.	 A ` (B ~ C )	
c.	 (A ` B)′ ~ C
	
b.	(A ` B) ~ C	
d.	A′ ~ (B′ ` C )′
	 4.	 Given the truth values A false, B true, and C true, what is the truth value of each of the following wffs?
	
a.	 A S (B ~ C )	
c.	 C S (A′ ` B′)
	
b.	(A ~ B) S C	
d.	A ~ (B′ S C )
	 5.	 Rewrite each of the following statements in the form “If A, then B.”
	
a.	 Healthy plant growth follows from sufficient water.
	
b.	Increased availability of information is a necessary condition for further technological advances.
	
c.	 Errors were introduced only if there was a modification of the program.
	
d.	Fuel savings implies good insulation or storm windows throughout.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
17
	 6.	 Rewrite each of the following statements in the form “If A, then B.”
	
a.	 Candidate Lu winning the election will be a sufficient condition for property taxes to increase.
	
b.	The user clicks Pause only if the game level changes.
	
c.	 The components are scarce, therefore the price increases.
	
d.	Healthy hair is a necessary condition for good shampoo.
	 7.	 Common English has many ways to describe logical connectives. Write a wff for each of the following 
expressions.
	
a.	 Either A or B	
b.	Neither A nor B
	 8.	 Common English has many ways to describe logical connectives. Write a wff for each of the following 
expressions.
	
a.	 B whenever A	
c.	 A indicates B
	
b.	A is derived from B	
d.	A exactly when B
	 9.	 Several forms of negation are given for each of the following statements. Which are correct?
	
a.	 The answer is either 2 or 3.
	
	
1.	Neither 2 nor 3 is the answer.
	
	
2.	The answer is not 2 or not 3.
	
	
3.	The answer is not 2 and it is not 3.
	
b.	Cucumbers are green and seedy.
	
	
1.	Cucumbers are not green and not seedy.
	
	
2.	Cucumbers are not green or not seedy.
	
	
3.	Cucumbers are green and not seedy.
	
c.	 2 < 7 and 3 is odd.
	
	
1.	2 > 7 and 3 is even.	
3.	2 ≥ 7 or 3 is odd.
	
	
2.	2 ≥ 7 and 3 is even. 	
4.	2 ≥ 7 or 3 is even.
	 10.	Several forms of negation are given for each of the following statements. Which are correct?
	
a.	 The carton is sealed or the milk is sour.
	
	
1.	The milk is not sour or the carton is not sealed.
	
	
2.	The carton is not sealed and also the milk is not sour.
	
	
3.	If the carton is not sealed, then the milk will be sour.
	
b.	Flowers will bloom only if it rains.
	
	
1.	The flowers will bloom but it will not rain.
	
	
2.	The flowers will not bloom and it will not rain.
	
	
3.	The flowers will not bloom or else it will not rain.
	
c.	 If you build it, they will come.
	
	
1.	If you build it, then they won’t come.
	
	
2.	You don’t build it, but they do come.
	
	
3.	You build it, but they don’t come.
	 11.	Write the negation of each statement.
	
a.	 If the food is good, then the service is excellent.
	
b.	Either the food is good or the service is excellent.

18	
Formal Logic
	
c.	 Either the food is good and the service is excellent, or else the price is high.
	
d.	Neither the food is good nor the service excellent.
	
e.	 If the price is high, then the food is good and the service is excellent.
	 12.	Write the negation of each statement.
	
a.	 The processor is fast but the printer is slow.
	
b.	The processor is fast or else the printer is slow.
	
c.	 If the processor is fast, then the printer is slow.
	
d.	Either the processor is fast and the printer is slow, or else the file is damaged.
	
e.	 If the file is not damaged and the processor is fast, then the printer is slow.
	
f.	 The printer is slow only if the file is damaged.
	 13.	Using the letters indicated for the component statements, translate the following compound statements 
into symbolic notation.
	
a.	 A: prices go up; B: housing will be plentiful; C: housing will be expensive
	
	
If prices go up, then housing will be plentiful and expensive; but if housing is not expensive, then it will 
still be plentiful.
	
b.	A: going to bed; B: going swimming; C: changing clothes
	
	
Either going to bed or going swimming is a sufficient condition for changing clothes; however, chang-
ing clothes does not mean going swimming.
	
c.	 A: it will rain; B: it will snow
	
	
Either it will rain or it will snow but not both.
	
d.	A: Janet wins; B: Janet loses; C: Janet will be tired
	
	
If Janet wins or if she loses, she will be tired.
	
e.	 A: Janet wins; B: Janet loses; C: Janet will be tired
	
	
Either Janet will win or, if she loses, she will be tired.
	 14.	Using the letters indicated for the component statements, translate the following compound statements 
into symbolic notation.
	
a.	 A: the tractor wins; B: the truck wins; C: the race will be exciting.
	
	
Whether the tractor wins or the truck wins, the race will be exciting
	
b.	A: snow; B: rain; C: yesterday was cloudy 
	
	
Yesterday was cloudy but there was neither snow nor rain.
	
c.	 A: Koalas will be saved; B: climate change is addressed; C: rising water levels
	
	
Koalas will be saved only if climate change is addressed; furthermore, failure to address climate change 
will cause rising water levels.
	
d.	A: the city’s economy will improve; B: a strong school system
	
	
The city’s economy will improve conditional upon a strong school system.
	
e.	 A: the city’s economy will improve; B: a strong school system
	
	
A strong school system is a necessary condition for the city’s economy to improve.
	 15.	Let A, B, and C be the following statements:
	
A	  Roses are red.
	
B	  Violets are blue.
	
C	  Sugar is sweet.
	
	 Translate the following compound statements into symbolic notation.
	
a.	 Roses are red and violets are blue.
	
b.	Roses are red, and either violets are blue or sugar is sweet.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
19
	
c.	 Whenever violets are blue, roses are red and sugar is sweet.
	
d.	Roses are red only if violets aren’t blue or sugar is sour.
	
e.	 Roses are red and, if sugar is sour, then either violets aren’t blue or sugar is sweet.
	 16.	Let A, B, and C, and D be the following statements:
	
A	 The villain is French.
	
B	 The hero is American.
	
C	 The heroine is British.
	
D	 The movie is good.
	
	 Translate the following compound statements into symbolic notation.
	
a.	 The hero is American and the movie is good.
	
b.	Athough the villain is French, the movie is good.
	
c.	 If the movie is good, then either the hero is American or the heroine is British.
	
d.	The hero is not American, but the villain is French.
	
e.	 A British heroine is a necessary condition for the movie to be good.
	 17.	Use A, B, and C as defined in Exercise 15 to translate the following statements into English.
	
a.	 B ~ C′	
e.	 (B ` C′)′ S A
	
b.	B′ ~ (A S C )	
f.	 A ~ (B ` C′)
	
c.	 (C ` A′) 4 B	
g.	(A ~ B) ` C′
	
d.	C ` (A′ 4 B) 
	 18.	Use A, B, and C as defined in Exercise 16 to translate the following statements into English.
	
a.	 B S A′	
e.	 A 4 (B ~ C )
	
b.	B ` C ` D′	
f.	 D′ S (A ~ C )′
	
c.	 B S (C ~ A) 	
g.	(C S D) ` (A S B′)
	
d.	(A ~ C ) S B′
	 19.	Using letters H, K, A for the component statements, translate the following compound statements into 
symbolic notation.
	
a.	 If the horse is fresh, then the knight will win.
	
b.	The knight will win only if the horse is fresh and the armor is strong.
	
c.	 A fresh horse is a necessary condition for the knight to win.
	
d.	The knight will win if and only if the armor is strong.
	
e.	 A sufficient condition for the knight to win is that the armor is strong or the horse is fresh.
	 20.	Using letters A, T, E for the component statements, translate the following compound statements into 
symbolic notation.
	
a.	 If Anita wins the election, then tax rates will be reduced.
	
b.	Tax rates will be reduced only if Anita wins the election and the economy remains strong.
	
c.	 Tax rates will be reduced if the economy remains strong.
	
d.	A strong economy will follow from Anita winning the election.
	
e.	 The economy will remain strong if and only if Anita wins the election or tax rates are reduced.
	 21.	Using letters F, B, S for the component statements, translate the following compound statements into 
symbolic notation.
	
a.	 Plentiful fish are a sufficient condition for bears to be happy.
	
b.	Bears are happy only if there are plentiful fish.

20	
Formal Logic
	
c.	 Unhappy bears means that the fish are not plentiful and also that there is heavy snow.
	
d.	Unhappy bears are a necessary condition for heavy snow.
	
e.	 The snow is heavy if and only if the fish are not plentiful.
	 22.	Using letters P, C, B, L for the component statements, translate the following compound statements into 
symbolic notation.
	
a.	 If the project is finished soon, then the client will be happy and the bills will be paid.
	
b.	If the bills are not paid, then the lights will go out.
	
c.	 The project will be finished soon only if the lights do not go out.
	
d.	If the bills are not paid and the lights go out, then the client will not be happy.
	
e.	 The bills will be paid if and only if the project is finished soon, or else the lights go out.
	
f.	 The bills will be paid if and only if either the project is finished soon or the lights go out.
	 23.	Construct truth tables for the following wffs. Note any tautologies or contradictions.
	
a.	 (A S B) 4 A′ ~ B	
	
	
d.	A ` B S A′
	
b.	(A ` B) ~ C S A ` (B ~ C )		
	
e.	 (A S B) S [(A ~ C ) S (B ~ C )]
	
c.	 A ` (A′ ~ B′)′
	 24.	Construct truth tables for the following wffs. Note any tautologies or contradictions.
	
a.	 A S (B S A)	
d.	[(A ~ B) ` C′] S A′ ~ C
	
b.	A ` B 4 B′ ~ A′	
e.	 A′ S (B ~ C′)
	
c.	 (A ~ B′) ` (A ` B)′
	 25.	Verify the equivalences in the list on page 9 by constructing truth tables. (We have already verified  
1a, 4b, and 5a.)
	 26.	Verify by constructing truth tables that the following wffs are tautologies. Note that the tautologies in parts 
b, e, f, and g produce equivalences such as (A′)′ 3 A.
	
a.	 A ~ A′	
e.	 (A ~ B)′ 4 A′ ` B′  (De Morgan’s law)
	
b.	(A′)′ 4 A	
f.	 (A ` B)′ 4 A′ ~ B′  (De Morgan’s law)
	
c.	 A ` B S B 	
g.	A ~ A 4 A
	
d. A S A ~ B
	 27.	Prove the following tautologies by starting with the left side and finding a series of equivalent wffs that 
will convert the left side into the right side. You may use any of the equivalencies in the list on page 9 or 
the equivalencies from Exercise 26.
	
a.	 (A ` B′) ` C 4 (A ` C ) ` B′
	
b.	(A ~ B) ` (A ~ B′) 4 A
	
c.	 A ~ (B ` A′) 4 A ~ B
	 28.	Prove the following tautologies by starting with the left side and finding a series of equivalent wffs that 
will convert the left side into the right side. You may use any of the equivalencies in the list on page 9 or 
the equivalencies from Exercise 26. 
	
a.	 (A ` B′)′ ~ B 4 A′ ~ B
	
b.	A ` (A ` B′)′ 4 A ` B 
	
c.	 (A ` B)′ ` (A ~ B′) 4 B′
	 29.	We mentioned that (A ` B) ~ C cannot be proved equivalent to A ` (B ~ C ) using either of the ­associative 
tautological equivalences, but perhaps it can be proved some other way. Are these two wffs equivalent? 
Prove or disprove.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
21
	 30.	Let P be the wff A S B. Prove or disprove whether P is equivalent to any of the following related wffs.
	
a.	 the converse of P, B S A
	
b.	the inverse of P, A′ S B′
	
c.	 the contrapositive of P, B′ S A′
	 31.	Write a logical expression for a Web search engine to find sites pertaining to dogs that are not retrievers.
	 32.	Write a logical expression for a Web search engine to find sites pertaining to oil paintings by Van Gogh or 
Rembrandt but not Vermeer.
	 33.	Write a logical expression for a Web search engine to find sites pertaining to novels or plays about AIDS.
	 34.	Write a logical expression for a Web search engine to find sites pertaining to coastal wetlands in Louisiana 
but not in Alabama.
	 35.	Consider the following pseudocode.
repeat
	
i = 1
	
read a value for x 
	
if ((x < 5.0) and (2x < 10.7)) or ("5x > 5.1) then
	
	
write the value of x
	
end if
	
increase i by 1
until i > 5
	
	 The input values for x are 1.0, 5.1, 2.4, 7.2, and 5.3. What are the output values?
	 36.	Suppose that A, B, and C represent conditions that will be true or false when a certain computer program 
is executed. Suppose further that you want the program to carry out a certain task only when A or B is true 
(but not both) and C is false. Using A, B, and C and the connectives AND, OR, and NOT, write a statement 
that will be true only under these conditions.
	 37.	Rewrite the following statement form with a simplified conditional expression, where the function odd(n) 
returns true if n is odd.
if not((Value1 < Value2) or odd(Number)) 
or (not(Value1 < Value2) and odd(Number)) then
	
statement1
else
	
statement2
end if
	 38.	You want your program to execute statement 1 when A is false, B is false, and C is true, and to execute 
statement 2 otherwise. You wrote
if not(A and B) and C then
	
statement 1
else
	
statement 2
end if
	
	 Does this do what you want?
	 39.	Verify that A S B is equivalent to A′ ~ B.
	 40.	a.	 Using Exercise 39 and other equivalences, prove that the negation of A S B is equivalent to 
A ` B′
	
b.	Write the negation of the statement “If Sam passed his bar exam, then he will get the job.”

22	
Formal Logic
	 41.	Use algorithm TautologyTest to prove that the following expressions are tautologies.
	
a.	 [B′ ` (A S B)] S A′
	
b.	[(A S B) ` A] S B
	
c.	 (A ~ B) ` A′ S B
	 42.	Use algorithm TautologyTest to prove that the following expressions are tautologies.
	
a.	 (A ` B) ` B′ S A
	
b.	(A ` B′) S (A S B)′
	
c.	 (A ` B)′ ~ B′ S A′ ~ B′
	 43.	A memory chip from a digital camera has 25 bistable (ON-OFF) memory elements. What is the total num-
ber of ON-OFF configurations?
	 44.	In each case, construct compound wffs P and Q so that the given statement is a tautology.
	
a.	 P ` Q
	
b.	P S P′
	
c.	 P ` (Q S P′)
	 45.	From the truth table for A ~ B, the value of A ~ B is true if A is true, if B is true, or if both are true. This 
use of the word “or,” where the result is true if both components are true, is called the inclusive or. It is 
the inclusive or that is understood in the sentence, “We may have rain or drizzle tomorrow,” which might 
also be expressed as, “We may have rain or drizzle or both tomorrow.” Another use of the word “or” in 
the English language is the exclusive or, sometimes written XOR, in which the result is false when both 
components are true. The exclusive or is understood in the sentence, “At the intersection, you should turn 
north or south,” (but obviously not both). Exclusive or is symbolized by A ! B. Write the truth table for 
the exclusive or.
	 46.	Prove that A ! B 4 (A 4 B)′ is a tautology. Explain why this makes sense. 
Exercises 47–50 show that defining four basic logical connectives (conjunction, disjunction, implication, and 
negation) is a convenience rather than a necessity because certain pairs of connectives are enough to express 
any wff. Exercises 51–52 show that a single connective, properly defined, is sufficient.
	 47.	Every compound statement is equivalent to a statement using only the connectives of conjunction and ne-
gation. To see this, we need to find equivalent wffs for A ~ B and for A S B that use only ` and ′. These 
new statements can replace, respectively, any occurrences of A ~ B and A S B. (The connective 4 was 
defined in terms of other connectives, so we already know that it can be replaced by a statement using 
these other connectives.)
	
a.	 Show that A ~ B is equivalent to (A′ ` B′)′
	
b.	Show that A S B is equivalent to (A ` B′)′
	 48.	Show that every compound wff is equivalent to a wff using only the connectives of ~ and ′. (Hint: See 
Exercise 47.)
	 49.	Show that every compound wff is equivalent to a wff using only the connectives of S and ′. (Hint: See 
Exercise 47.)
	 50.	Prove that there are compound statements that are not equivalent to any statement using only the 
­connectives S and ~.
	 51.	The binary connective 0 is called the Sheffer stroke, named for the American logic professor Henry Shef-
fer, who proved in 1913 that this single connective is the only one needed. The truth table for 0 is given 
here. Sheffer also coined the term “Boolean algebra,” the topic of Chapter 8, where we will see that this 
truth table represents the NAND gate.

	
	
Section 1.1   Statements, Symbolic Representation, and Tautologies	
23
A
B
A 0 B
T
T
F
T
F
T
F
T
T
F
F
T
	 52.	The binary connective T is called the Peirce arrow, named for American philosopher Charles Peirce (not 
for the antique automobile). The truth table for T is given here. In Chapter 8 we will see that this truth table 
represents the NOR gate
A
B
A  T  B
T
T
F
T
F
F
F
T
F
F
F
T
	 53.	Propositional wffs and truth tables belong to a system of two-valued logic because everything has one of 
two values, False or True. Three-valued logic allows a third value of Null or “unknown” (Section 5.3 dis-
cusses the implications of three-valued logic on databases). The truth tables for this three-valued system 
follow.
A
B
A ` B
A
B
A ~ B
A
A′
T
T
T
T
T
T
T
F
T
F
F
T
F
T
F
T
T
N
N
T
N
T
N
N
F
T
F
F
T
T
F
F
F
F
F
F
F
N
F
F
N
N
N
T
N
N
T
T
N
F
F
N
F
N
N
N
N
N
N
N
	
a.	 Viewing N as “unknown”, explain why it is reasonable to define T ` N = N, F ~ N = N, and 
N′ = N.
	
Suppose the statement, “Flight 237 is on time,” is true, the statement, “Runway conditions are icy,” is 
false, and the truth value of the statement, “Flight 51 is on time,” is unknown. Find the truth values of the 
following statements.
	
b.	Runway conditions are not icy and flight 51 is on time.
	
c.	 Flight 51 is on time and flight 237 is not.
	
d.	Flight 51 is not on time or runway conditions are not icy.
	 54.	Propositional wffs and truth tables belong to a system of two-valued logic because everything has one of 
two values, F or T, which we can think of as 0 or 1. In fuzzy logic, or many-valued logic, statement letters 
are assigned values in a range between 0 and 1 to reflect some “probability” to which they are false or 
true. A statement letter with a truth value of 0.9 is “mostly true” or “has a high probability of being true” 
while a statement letter with a truth value of 0.05 “has a very high probability of being false.” Fuzzy logic 
	
	 Show that every compound wff is equivalent to a wff using only the 
connective 0. (Hint: Use Exercise 47 and find equivalent statements 
for A ` B and A′ in terms of 0.)
	
	 Show that every compound statement is equivalent to a statement 
using only the connective T. (Hint: See Exercise 51.)

24	
Formal Logic
is used to manage decisions in many imprecise situations such as robotics, manufacturing, or instrument 
control. Truth values for compound statements are determined as follows.
	
	 A′ has the truth value 1 − A.
	
	 A ` B has the truth value that is the minimum of the values of A and of B.
	
	 A ~ B has the truth value that is the maximum of the values of A and B.
	
a.	 Explain why these are reasonable assignments for the truth values of A′, A ` B, and A ~ B.
	
Suppose the statement, “Flight 237 is on time,” is estimated to have a truth value of 0.84 and the ­state- 
ment, “Runway conditions are icy,” is estimated to have a truth value of 0.12. Find the truth values of the  
following statements.
	
b.	Runway conditions are not icy.
	
c.	 Runway conditions are icy and flight 237 is on time.
	
d.	Runway conditions are icy or flight 237 is not on time.
	 55.	In a three-valued logic system as described in Exercise 53, how many rows are needed for a truth table 
with n statement letters?
	 56.	In 2003, then U.S. Secretary of Defense Donald Rumsfeld won Britain’s Plain English Campaign 2003 
Golden Bull Award for this statement: “Reports that say that something hasn’t happened are always inter-
esting to me, because as we know, there are known knowns, there are things we know we know. We also 
know there are known unknowns; that is to say we know there are some things we do not know. But there 
are also unknown unknowns—the ones we don’t know we don’t know.”
	
	 What possibility did Secretary Rumsfeld omit?
	 57.	Four machines, A, B, C, and D, are connected on a computer network. It is feared that a computer virus 
may have infected the network. Your security team makes the following statements:
	
a.	 If D is infected, then so is C.
	
b.	If C is infected, then so is A.
	
c.	 If D is clean, then B is clean but C is infected.
	
d.	If A is infected, then either B is infected or C is clean.
	
	 Assuming that these statements are all true, what can you conclude? Explain your reasoning.
	 58.	The Dillies have five teenaged children, two boys named Ollie and Rollie, and three girls named Mellie, 
Nellie, and Pollie. Each is a different number of years old, from 13 to 17. There are three bedrooms for the 
children in the Dillie house, so two share the yellow room, two share the white room, and one alone has 
the smaller green room. Can you match each one’s name and age, and tell who sleeps where?
	
a.	 No one shares a room with a sibling of the opposite sex.
	
b.	Pollie is exactly one year older than Mellie.
	
c.	 The two teenagers who share the yellow room are two years apart in age.
	
d.	The two who share the white room are three years apart in age.
	
e.	 Rollie is somewhat older than Ollie but somewhat younger than the sibling who has the green room. 2
	
	 Determine who sleeps in each room and what their ages are. Explain your reasoning.
	 59.	An advertisement for a restaurant at an exclusive club in Honolulu says, “Members and nonmembers 
only.” Give two possible interpretations of this statement.
	 60.	The following newspaper headline was printed during a murder trial:
“I am a liar” says murder defendant!
	
	 Can the jury reach any conclusion from this statement?
2Scott Marley, Dell Logic Puzzles, April, 1998

	
	
Section 1.2   Propositional Logic	
25
3For more puzzles about “knights” and “knaves,” see What Is the Name of This Book? by the logician—and magician—Raymond Smullyan 
(Prentice-Hall, 1978).
In Exercises 61–64, you are traveling in a certain country where every inhabitant is either a truthteller who 
always tells the truth or a liar who always lies.3
	 61.	You meet two of the inhabitants of this country, Percival and Llewellyn. Percival says, “At least one of us 
is a liar.” Is Percival a liar or a truth teller? What about Llewellyn? Explain your answer.
	 62.	Traveling on, you meet Merlin and Meredith. Merlin says, “If I am a truth teller, then Meredith is a truth 
teller.” Is Merlin a liar or a truth teller? What about Meredith? Explain your answer.
	 63.	Next, you meet Rothwold and Grymlin. Rothwold says, “Either I am a liar or Grymlin is a truth teller.” Is 
Rothwold a liar or a truth teller? What about Grymlin? Explain your answer.
	 64.	Finally, you meet Gwendolyn and Merrilaine. Gwendolin says, “I am a liar but Merrilaine is not.” Is 
Gwendolyn a liar or a truth teller? What about Merrilaine?
	
S e c t i o n  1 . 2 	 Propositional Logic
The argument of the defense attorney at the beginning of this chapter made a 
number of (supposedly true) statements and then asked the jury to draw a specific 
conclusion based on those statements. In Section 1.1, we used the notation of for-
mal logic to represent statements in symbolic form as wffs; because statements 
are sometimes called propositions, these wffs are also called propositional wffs. 
Now we want to use tools from formal logic to see how to reach logical conclu-
sions based on given statements. The formal system that uses propositional wffs 
is called propositional logic, statement logic, or propositional calculus. (The 
word calculus is used here in the more general sense of “calculation” or “reason-
ing,” not “differentiating” or “integrating.”) 
Valid Arguments
An argument can be represented in symbolic form as
P1 ` P2 ` P3 ` … ` Pn S Q
where P1, P2, … , Pn are the given statements, called the hypotheses, of the argu-
ment, and Q is the conclusion of the argument. As usual, the P’s and the Q rep-
resent wffs, not merely statement letters. When should this be considered a valid 
argument? This question can be stated in several equivalent ways:
•	 When can Q be logically deduced from P1, … , Pn?
•	 When is Q a logical conclusion from P1, … , Pn?
•	 When does P1, … , Pn logically imply Q?
•	 When does Q follow logically from P1, … , Pn?
and so forth.

26	
Formal Logic
An informal answer is that Q is a logical conclusion from P1, … , Pn whenever 
the truth of P1, … , Pn implies the truth of Q. In other words, when the implication
P1 ` P2 ` P3 ` … ` Pn S Q
is true. (Of course, this implication is true if any of the hypotheses is false, but 
in an argument we usually care about what happens when all the hypotheses are 
true.) Furthermore, this implication should be true based on the relationship of the 
conclusion to the hypotheses, not on any incidental knowledge we may happen to 
have about Q.
	
Example 9	
Consider the following argument:
George Washington was the first president of the United States. Thomas 
­Jefferson wrote the Declaration of Independence. Therefore, every day has 
24 hours.
This argument has the two hypotheses
	
1.	 George Washington was the first president of the United States.
	
2.	 Thomas Jefferson wrote the Declaration of Independence.
and the conclusion
Every day has 24 hours.
Even though each of the individual hypotheses, as well as the conclusion, is a true 
statement, we would not consider this argument valid. The conclusion is merely an 
isolated true fact, not at all related to or “following from” the hypotheses.
A valid argument should therefore be true based entirely on its internal struc-
ture; it should be “intrinsically true.” Therefore we make the following formal 
definition.
	
Definition	
Valid argument
The propositional wff
P1 ` P2 ` P3 ` … ` Pn S Q
is a valid argument when it is a tautology.
The argument in Example 9 would be symbolized as
A ` B S C
which is clearly not a tautology.
	
Example 10	
Consider the following argument. If George Washington was the first president of 
the United States, then John Adams was the first vice president. George Washing-
ton was the first president of the United States. Therefore John Adams was the first 
vice president.

	
	
Section 1.2   Propositional Logic	
27
This argument has the two hypotheses:
 
1. If George Washington was the first president of the United States, then 
John Adams was the first vice president.
 
2. George Washington was the first president of the United States.
and the conclusion
John Adams was the first vice president.
A symbolic representation of this argument has the form
(A S B) ` A S B
A truth table or algorithm TautologyTest establishes that this argument is a tautol-
ogy. The argument is valid; its form is such that the conclusion follows inevitably 
from the hypotheses. In fact, this form of argument, known by its Latin name of 
modus ponens (“method of assertion”), is one of the rules of reasoning we will use 
to build propositional logic.
To test whether a wff P1 ` P2 ` P3 ` … ` Pn S Q is a tautology, we could 
build a truth table or use algorithm TautologyTest. Instead, we will turn to formal 
logic, which uses a system of derivation rules that manipulate wffs in a truth-
preserving manner. You begin with the hypotheses P1, … , Pn (assumed true) and 
attempt to apply the manipulation rules in such a way as to end up with the conclu-
sion Q (which must then also be true because truth is preserved under the rules).
	
Definition	
Proof sequence
A proof sequence is a sequence of wffs in which each wff is either a hypothesis 
or the result of applying one of the formal system’s derivation rules to earlier 
wffs in the sequence.
Using formal logic to prove that Q is a valid conclusion from P1, … , Pn, we 
must produce a proof sequence of the form
P1	
(hypothesis)
P2	
(hypothesis)
	
(
Pn	
(hypothesis)
wff1 
(obtained by applying a derivation rule to earlier wffs)
wff2 
(obtained by applying a derivation rule to earlier wffs)
	
(
Q 
(obtained by applying a derivation rule to earlier wffs)
The derivation rules for a formal system must be carefully chosen. If they 
are too powerful, then they won’t be truth preserving and we’ll be able to deduce 
anything at all from a given set of hypotheses. If they are too weak, there will 
be logical conclusions that we won’t be able to prove from given hypotheses. We 
want a formal logic system that is correct (only valid arguments should be prov-
able) and complete (every valid argument should be provable). In addition, the 

28	
Formal Logic
derivation rules should be kept to a minimum in order to make the formal system 
manageable. We would like the system to have the smallest set of rules that still 
allows it to be complete.
Derivation Rules for Propositional Logic
The derivation rules for propositional logic fall into two categories, equivalence 
rules and inference rules. Equivalence rules allow individual wffs to be rewrit-
ten, while inference rules allow new wffs to be derived from previous wffs in the 
proof sequence.
Equivalence rules state that certain pairs of wffs R and S are equivalent. 
Remember from Section 1.1 that R 3 S means that R 4 S is a tautology and 
that S can be substituted for R in any wff with no change to the truth value of that 
wff. Equivalence rules are therefore truth-preserving; a true wff remains true if 
such a substitution is done within it.
Table 1.11 lists the equivalence rules we will use in our formal system for 
propositional logic. (Additional rules could be formulated based on other tautolo-
gies, but we are trying to keep our rule set to a minimum.) Each is given a name 
to make it easier to identify its use in a proof sequence. We saw the commutative 
and associative rules, as well as De Morgan’s laws, in Section 1.1. There they were 
given for statement letters only, here they are given for any wffs P, Q, R, but they 
are still tautologies.
Practice 9	 Prove the implication rule.
That is, prove that
(P S Q) 4 (P′ ~ Q)
is a tautology.
Table 1.11
Equivalence Rules
Expression
Equivalent to
Name/Abbreviation for Rule
P ~ Q
P ` Q
Q ~ P
Q ` P
Commutative—comm
(P ~ Q) ~ R
(P ` Q) ` R
P ~ (Q ~ R)
P ` (Q ` R)
Associative—ass
(P ~ Q)′
(P ` Q)′
P′ ` Q′
P′ ~ Q′
De Morgan’s Laws—De 
­Morgan
P S Q
P′ ~ Q
Implication—imp
P
(P′)′
Double negation—dn
P 4 Q
(P S Q) ` (Q S P)
Definition of equivalence—equ
	
Example 11 	
Suppose that one hypothesis of a propositional argument can be symbolized as
(A′ ~ B′) ~ C

	
	
Section 1.2   Propositional Logic	
29
Then a proof sequence for the argument could begin with the following steps:
1.  (A′ ~ B′) ~ C	
hyp (hypothesis)
2.  (A ` B)′ ~ C	
1, De Morgan
3.  (A ` B) S C	
2, imp
The justification given for each step is not a required part of the proof sequence, 
but it does confirm that the step is a legitimate one. Step 1 is a hypothesis. Step 2 is 
derived from step 1 by applying one of De Morgan’s Laws. Step 3 is derived from 
step 2 by using the implication rule that P S Q is equivalent to P′ ~ Q, where P is 
the wff A ` B, and Q is the wff C.
The equivalence rules allow substitution in either direction. That is, in Ex-
ample 11 we replaced A′ ~ B′ with (A ` B)′, but in some other proof sequence, 
using the same rule, we might replace (A ` B)′ with A′ ~ B′.
Inference rules say that if one or more wffs that match the first part of the 
rule pattern are already part of the proof sequence, we can add to the proof se-
quence a new wff that matches the last part of the rule pattern. Table 1.12 shows 
the propositional inference rules we will use, again along with their identifying 
names.
Table 1.12
Inference Rules
From
Can Derive 
Name/Abbreviation for Rule
P, P S Q
Q
Modus ponens—mp
P S Q, Q′
P′
Modus tollens—mt
P, Q
P ` Q
Conjunction—con
P ` Q
P, Q
Simplification—sim
P
P ~ Q
Addition—add
Unlike equivalence rules, inference rules do not work in both directions. We 
cannot “reverse” the addition rule in Table 1.12; from P ~ Q, we cannot infer 
either P or Q.
	
Example 12	
Suppose that A S (B ` C ) and A are two hypotheses of an argument. A proof se-
quence for the argument could begin with the following steps:
1.  A S (B ` C )  hyp
2.  A	
hyp
3.  B ` C 	
1, 2, mp
The justification at step 3 is that steps 1 and 2 exactly match the pattern required 
for modus ponens, where P is A and Q is B ` C. Modus ponens says that Q can be 
derived from P and P S Q. 

30	
Formal Logic
The inference rules are also truth-preserving. For example, suppose that P 
and P S Q are both true wffs in a proof sequence. Then Q is deducible from these 
two wffs by modus ponens. If P and P S Q are both true, then—by the truth table 
for implication—Q is also true.
The derivation rules, like the tautological equivalencies of Section 1.1, repre-
sent recipes or patterns for transforming wffs. A rule can be applied only when the 
wffs exactly match the pattern.
Practice 10	 Give a next step and a justification for a proof sequence that begins
1.	
(A ` B′) S C  hyp
2.	
C′	
hyp
REMINDER
To use a derivation rule, 
wffs must exactly match 
the rule pattern.
	
Example 13	
Suppose that (A S B) ~ C and A are two hypotheses of an argument. A proof 
­sequence for the argument could begin with the following steps:
1.  (A S B) ~ C	
hyp
2.  A 	
hyp
Unlike Example 12, however, nothing further can be done. Modus ponens requires 
the presence of wffs matching the pattern P and P S Q. In P S Q, the main con-
nective is an implication. The wff (A S B) ~ C has disjunction, not implication, as 
its main connective. Modus ponens does not apply, nor does anything else. 
Now we are ready to work our way through a complete proof of an argument.
	
Example 14 	
Using propositional logic, prove that the argument
A ` (B S C ) ` [(A ` B) S (D ~ C′)] ` B S D
is valid.
We must produce a proof sequence that begins with the hypotheses and ends 
with the conclusion. There are four hypotheses, so this gives us lots of “ammuni-
tion” to use in the proof. The beginning of the proof is easy enough because it just 
involves listing the hypotheses:
1.  A 	
hyp
2.  B S C 	
hyp
3.  (A ` B) S (D ` C′)	
hyp
4.  B 	
hyp
Our final goal is to arrive at D, the conclusion. But without even looking ahead, 
there are a couple of fairly obvious steps we can take that may or may not be helpful.
5.  C 	
2, 4, mp
6.  A ` B 	
1, 4, con
7.  D ~ C ′	
3, 6, mp
At least at this point we have introduced D, but it’s not by itself. Note that from 
step 5 we have C, which we haven’t made use of. If only we had C S D, we’d be 

	
	
Section 1.2   Propositional Logic	
31
home free. Ah, look at the form of step 7; it’s a disjunction, and the implication rule 
says that we can transform a disjunction of a certain form into an implication. The 
disjunction must have a negated wff on the left. We can do that:
8.  C′ ~ D  7, comm
9.  C S D 	 8, imp
so
10.  D  5, 9, mp 
As in Example 14, proof sequences involve a certain amount of rewriting just 
because you can and a certain amount of keeping an eye on the desired goal and 
what it would take to get there. Although not as mechanical as constructing a truth 
table, the strict rules of the game nevertheless provide a more or less mechanical 
way to construct the proof sequence. There are only a certain number of legitimate 
things that can be done at any one point in the sequence. If one choice seems to 
lead down a blind alley, go back and make another. Also, there may be more than 
one correct proof sequence; as a relatively trivial instance, steps 6 and 7 could 
have been done before step 5 in Example 14.
An analogy with programming, if not taken too literally, may be helpful. In 
traditional programming, you have known input, a desired output, and you write 
code to transform the given input into the desired output. You figure out the se-
quence of statements that will accomplish this transformation, and each program 
statement in that sequence must conform to the exact syntax rules of the program-
ming language you are using, be it C++, Java, Python, or whatever. In proposi-
tional logic, you have known “input” (the hypotheses), a desired “output” (the 
conclusion), and you write “code statements” (a sequence of wffs) to transform 
the hypotheses into the conclusion. The sequence of code statements, or at least 
their justification, must conform to the exact syntax of the derivation rules for 
propositional logic.
Practice 11	 Using propositional logic, prove the validity of the argument.
[(A ~ B′) S C] ` (C S D) ` A S D
Table 1.13
Derivation Hints
1.  Modus ponens is probably the most intuitive inference rule. Think often about 
trying to use it.
2.  Wffs of the form (P ` Q)′ or (P ~ Q)′ are seldom helpful in a proof sequence. Try 
using De Morgan’s laws to convert them into P′ ~ Q′ and P′ ` Q′, respectively, 
which breaks out the individual components.
3.  Wffs of the form P ~ Q are also seldom helpful in a proof sequence because 
they do not imply either P or Q. Try using double negation to convert P ~ Q to 
(P′)′ ~ Q, and then using implication to convert to P′ S Q.

32	
Formal Logic
Deduction Method and Other Rules
Suppose the argument we seek to prove has the form
P1 ` P2 ` P3 ` … ` Pn S (R S S)
where the conclusion is itself an implication. Instead of using P1, … , Pn as the hy-
potheses and deriving R S S, the deduction method lets us add R as an additional 
hypothesis and then derive S. In other words, we can instead prove
P1 ` P2 ` P3 ` … ` Pn ` R S S
This change is to our advantage because it gives us one more hypothesis, i.e., 
­additional ammunition for the proof, and it simplifies the desired conclusion.
The deduction method approach agrees with our understanding of implica-
tion, but Exercise 55 at the end of this section provides a formal justification.
REMINDER
Use the deduction ­method 
when the ­conclusion of 
what you want to prove is 
an implication.
	
EXAMPLE 15	
Use propositional logic to prove
[A S (A S B)] S (A S B)
Using the deduction method, we get two hypotheses instead of one, and we want 
to derive B.
1.  A S (A S B)	 hyp
2.  A	
hyp
3.  A S B	
1, 2, mp
4.  B	
2, 3, mp
Practice 12	 Use propositional logic to prove
(A S B) ` (B S C ) S (A S C )
The formal system we have described is correct and complete. Every argu-
ment we can prove is a tautology (the system is correct), and every implication that 
is a tautology is provable (the system is complete). We can easily argue for correct-
ness because each of the derivation rules is truth-preserving. Completeness would 
be more difficult to prove, and we will not do so.
Correctness and completeness say that the set of derivation rules we have 
used is exactly right—not too strong, not too weak. Nonetheless, many formal 
systems for propositional logic use additional truth-preserving inference rules. 
We can prove these additional rules using our original rule set. Once such a 
rule is proved, it can be used as justification in a proof sequence because, if 
required, the single step invoking this rule could be replaced with the proof 
sequence for the rule. Nothing more can be proved by the addition of these 
rules, but the proof sequences might be shorter. (See Exercises 1.2 for a list of 
additional rules.)

	
	
Section 1.2   Propositional Logic	
33
	
EXAMPLE 16	
The rule of hypothetical syllogism (hs) is
From P S Q and Q S R, one can derive P S R.
This rule is making the claim that
(P S Q) ` (Q S R) S (P S R)
is a valid argument. The proof sequence for this argument looks just like that for 
Practice 12. Because it is a legitimate derivation rule, hypothetical syllogism can 
be used to justify a step in a proof sequence.
	
EXAMPLE 17	
Use propositional logic to prove
(A′ ~ B) ` (B S C ) S (A S C )
The following proof sequence will do.
1.  A′ ~ B	
hyp
2.  B S C	
hyp
3.  A S B	
1, imp
4.  A S C	
2, 3, hs
Without use of the new rule, we could still have produced a proof sequence by 
­essentially proving the new rule as part of this proof:
1.  A′ ~ B	
hyp
2.  B S C	
hyp
3.  A S B	
1, imp
4.  A	
hyp
5.  B	
3, 4, mp
6.  C	
2, 5, mp
Additional rules thus can shorten proof sequences but at the expense of having to 
remember additional rules!
Practice 13	 Prove
(A S B) ` (C′ ~ A) ` C S B
Verbal Arguments
An argument in English (an attorney’s trial summary, an advertisement, or a 
­political speech) that consists of simple statements can be tested for validity by a 
two-step process:
	
1.	 Symbolize the argument using propositional wffs.
	
2.	 Prove that the argument is valid by constructing a proof sequence for it 
using the derivation rules for propositional logic.

34	
Formal Logic
The first step, translating the argument from verbal to symbolic form, is often 
the most difficult. Look for keys in the verbal representation of the argument. 
“If… then” and “either… or” indicate implication and disjunction, respectively. A 
period (or sometimes a semicolon) signifies the end of a hypothesis. The separate 
hypotheses are joined by conjunctions. “Therefore” is a big key word; it indicates 
the end of the hypotheses and announces that the conclusion is about to be stated.
	
EXAMPLE 18	
Consider the argument, “If interest rates drop, the housing market will improve. 
Either the federal discount rate will drop or the housing market will not improve. 
Interest rates will drop. Therefore the federal discount rate will drop.” Using
I	
Interest rates drop.
H	 The housing market will improve.
F	
The federal discount rate will drop.
the argument is
(I S H) ` (F ~ H′) ` I S F
A proof sequence to establish validity is
1.  I S H	
hyp
2.  F ~ H′	
hyp
3.  I	
hyp
4.  H′ ~ F	
2, comm
5.  H S F	
4, imp
6.  I S F	
1, 5, hs
7.  F	
3, 6, mp
	
EXAMPLE 19	
Is the following argument valid? “My client is left-handed, but if the diary is not 
missing, then my client is not left-handed; therefore, the diary is missing.” There 
are only two simple statements involved here, so we symbolize them as follows:
L   My client is left-handed.
D  The diary is missing.
The argument is then
L ` (D′ S L′) S D
The validity of the argument is established by the following proof sequence.
1.  L	
hyp
2.  D′ S L′	
hyp
3.  (D′)′ ~ L′	
2, imp
4.  D ~ L′	
3, dn
5.  L′ ~ D	
4, comm
6.  L S D	
5, imp
7.  D	
1, 6, mp

	
	
Section 1.2   Propositional Logic	
35
Formal logic is not necessary to prove the validity of propositional arguments. A 
valid argument is represented by a tautology, and truth tables provide a mechanical 
test for whether a wff is a tautology. So, what was the point of all of this? In the next 
section we will see that propositional wffs are not sufficient to represent everything 
we would like to say, and we will devise new wffs called predicate wffs. There is no 
mechanical test for the predicate wff analogue of tautology, and in the absence of such 
a test, we will have to rely on formal logic to justify arguments. We have developed 
formal logic for propositional arguments as a sort of dry run for the predicate case.
In addition, the sort of reasoning we have used in propositional logic carries 
over into everyday life. It is the foundation for logical thinking in computer science, 
mathematics, the courtroom, the marketplace, and the laboratory. Although we have 
approached logic as a mechanical system of applying rules, enough practice should 
ingrain this way of thinking so that you no longer need to consult tables of rules, but 
can draw logical conclusions and recognize invalid arguments on your own.
The argument says that if the hypotheses are true, then the conclusion will be true. 
The validity of the argument is a function only of its logical form and has nothing 
to do with the actual truth of any of its components. We still have no idea about 
whether the diary is really missing. Furthermore, the argument “Skooses are pink, 
but if Gingoos does not like perskees, then skooses are not pink; therefore Gingoos 
does like perskees,” which has the same logical form, is also valid, even though it 
does not make sense.
S e c t i o n  1 . 2 	
Review
Techniques
•	 Apply derivation rules for propositional logic.
•	 Use propositional logic to prove the validity of a 
verbal argument.
Main Ideas
•	 A valid argument can be represented by a wff of 
the form P1 ` P2 ` P3 ` … ` Pn S Q that is a 
­tautology.
•	 A proof sequence in a formal logic system is a se-
quence of wffs that are either hypotheses or derived 
from earlier wffs in the sequence by the derivation 
rules of the system.
•	 The propositional logic system is complete and 
correct; valid arguments and only valid arguments 
are provable.
W
W
Exercises 1.2
For Exercises 1–4, what inference rule is illustrated by the argument given?
	 1.	 If Martina is the author, then the book is fiction. But the book is nonfiction. Therefore Martina is not the 
author.
	 2.	 If the business declares bankruptcy, then all assets must be confiscated. The business declared bankruptcy. 
It follows that all assets must be confiscated.
Practice 14	 Use propositional logic to prove that the following argument is valid. Use statement letters 
S, R, and B. 
If security is a problem, then regulation will be increased. If security is not a problem, then business on the Web 
will grow. Therefore if regulation is not increased, then business on the Web will grow.

36	
Formal Logic
	 3.	 The dog has a shiny coat and loves to bark. Consequently, the dog loves to bark.
	 4.	 If Paul is a good swimmer, then he is a good runner. If Paul is a good runner, then he is a good biker. 
Therefore if Paul is a good swimmer, then he is a good biker.
For Exercises 5–8, decide what conclusion, if any, can be reached from the given hypotheses and justify your 
answer.
	 5.	 If the car was involved in the hit-and-run, then the paint would be chipped. But the paint is not chipped.
	 6.	 Either the weather will turn bad or we will leave on time. If the weather turns bad, then the flight will be 
canceled.
	 7.	 If the bill was sent today, then you will be paid tomorrow. You will be paid tomorrow.
	 8.	 The grass needs mowing and the trees need trimming. If the grass needs mowing, then we need to rake the 
leaves.
	 9.	 Justify each step in the proof sequence of 
	
A ` (B S C ) S (B S (A ` C ))
	
1.	A	 	
4.	C
	
2.	B S C	
5.	A ` C
	
3.	B
	 10.	Justify each step in the proof sequence of
	
B ` [(B ` C ) S A′] ` (B S C ) S A′
	
1.	B	 	
4.	C
	
2.	(B ` C ) S A′	
5.	B ` C
	
3.	B S C	
6.	A′
	 11.	Justify each step in the proof sequence of
	
[A S (B ~ C )] ` B′ ` C′ S A′
	
1.	A S (B ~ C )	
4.	B′ ` C′
	
2.	B′		
5.	(B ~ C )′
	
3.	C′		
6.	A′
	 12.	Justify each step in the proof sequence of
	
A′ ` B ` [B S (A ~ C )] S C
	
1.	A′		
5.	(A′)′ ~ C
	
2.	B 		
6.	A′ S C
	
3.	B S (A ~ C )	
7.	C
	
4.	A ~ C
In Exercises 13–24, use propositional logic to prove that the argument is valid.
	 13.	(A ~ B′)′ ` (B S C ) S (A′ ` C )
	 14.	A′ ` (B S A) S B′
	 15.	(A S B) ` [A S (B S C )] S (A S C )
	 16.	[(C S D) S C] S [(C S D) S D]
	 17.	A′ ` (A ~ B) S B

	
	
Section 1.2   Propositional Logic	
37
	 18.	[A S (B S C )] ` (A ~ D′) ` B S (D S C )
	 19.	(A′ S B′) ` B ` (A S C ) S C
	 20.	(A S B) ` [B S (C S D)] ` [A S (B S C )] S (A S D)
	 21.	[A S (B S C )] S [B S (A S C )]
	 22.	(A ` B) S (A S B′)′
	 23.	(A S C ) ` (C S B′) ` B S A′
	 24.	[A S (B ~ C )] ` C′ S (A S B)
Use propositional logic to prove the validity of the arguments in Exercises 25–33. These will become additional 
derivation rules for propositional logic, summarized in Table 1.14.
	 25.	(P ~ Q) ` P′ S Q
	 26.	(P S Q) S (Q′ S P′)
	 27.	(Q′ S P′) S (P S Q)
	 28.	P S P ` P
	 29.	P ~ P S P (Hint: Instead of assuming the hypothesis, begin with a version of Exercise 28; also make use 
of Exercise 27.)
	 30.	[(P ` Q) S R] S [P S (Q S R)]
	 31.	P ` P′ S Q
	 32.	P ` (Q ~ R) S (P ` Q) ~ (P ` R) (Hint: First rewrite the conclusion.)
	 33.	P ~ (Q ` R) S (P ~ Q) ` (P ~ R) (Hint: Prove both P ~ (Q ` R) S (P ~ Q) and P ~ (Q ` R) S 
(P ~ R); for each proof, first rewrite the conclusion.)
Table 1.14
More Inference Rules
From
Can Derive 
Name/Abbreviation for Rule
P S Q, Q S R
P S R [Example 16]
Hypothetical syllogism—hs
P ~ Q, P′
Q [Exercise 25]
Disjunctive syllogism—ds
P S Q
Q′ S P′ [Exercise 26]
Contraposition—cont
Q′ S P′
P S Q [Exercise 27]
Contraposition—cont
P
P ` P [Exercise 28]
Self-reference—self
P ~ P
P [Exercise 29]
Self-reference—self
(P ` Q) S R
P S (Q S R) [Exercise 30]
Exportation—exp
P, P′
Q [Exercise 31]
Inconsistency—inc
P ` (Q ~ R)
(P ` Q) ~ (P ` R) [Exercise 32]
Distributive—dist
P ~ (Q ` R)
(P ~ Q) ` (P ~ R) [Exercise 33]
Distributive—dist
For Exercises 34–42, use propositional logic to prove the arguments valid; you may use any of the rules in Table 
1.14 or any previously proved exercise.
	 34.	A′ S (A S B)

38	
Formal Logic
	 35.	(P S Q) ` (P′ S Q) S Q 
	 36.	(A′ S B′) ` (A S C ) S (B S C )
	 37.	(A′ S B) ` (B S C ) ` (C S D) S (A′ S D)
	 38.	(A ~ B) ` (A S C ) ` (B S C ) S C
	 39.	(Y S Z′) ` (X′ S Y) ` [Y S (X S W)] ` (Y S Z) S (Y S W)
	 40.	(A ` B) ` (B S A′) S (C ` B′)
	 41.	(A ` B)′ ` (C′ ` A)′ ` (C ` B′)′ S A′ 
	 42.	(P ~ (Q ` R)) ` (R′ ~ S) ` (S S T′) S (T S P)
In Exercises 43–54, write the argument using propositional wffs (use the statement letters shown). Then, using 
propositional logic, including the rules in Table 1.14, prove that the argument is valid.
	 43.	If the program is efficient, it executes quickly. Either the program is efficient, or it has a bug. However, the 
program does not execute quickly. Therefore, it has a bug. E, Q, B
	 44.	If Jane is more popular, then she will be elected. If Jane is more popular, then Craig will resign. Therefore, 
if Jane is more popular, she will be elected and Craig will resign. J, E, C
	 45.	If chicken is on the menu, then don’t order fish, but you should have either fish or salad. So, if chicken is 
on the menu, have salad. C, F, S
	 46.	The crop is good, but there is not enough water. If there is a lot of rain or not a lot of sun, then there is 
enough water. Therefore, the crop is good and there is a lot of sun. C, W, R, S
	 47.	If the ad is successful, then the sales volume will go up. Either the ad is successful or the store will close. 
The sales volume will not go up. Therefore, the store will close. A, S, C
	 48.	If DeWayne is not tall then Jayden is not DeWayne’s brother. If DeWayne is tall then Trevor is DeWayne’s 
brother. Therefore, if Jayden is DeWayne’s brother, then Trevor is DeWayne’s brother. D, J, T
	 49.	Russia was a superior power, and either France was not strong or Napoleon made an error. Napoleon did 
not make an error, but if the army did not fail, then France was strong. Hence, the army failed and Russia 
was a superior power. R, F, N, A
	 50.	It is not the case that if electric rates go up, then usage will go down, nor is it true that either new power plants 
will be built or bills will not be late. Therefore, usage will not go down and bills will be late. R, U, P, B
	 51.	If Jose took the jewelry or Mrs. Krasov lied, then a crime was committed. Mr. Krasov was not in town. If 
a crime was committed, then Mr. Krasov was in town. Therefore, Jose did not take the jewelry. J, L, C, T
	 52.	If the birds are flying south and the leaves are turning, then it must be fall. Fall brings cold weather. The 
leaves are turning but the weather is not cold. Therefore, the birds are not flying south. B, L, F, C
	 53.	If a Democrat is elected then taxes will go up. Either a Democrat will be elected or the bill will pass. 
Therefore, if taxes do not go up, then the bill will pass. D, T, B
	 54.	Either Emily was not home or if Pat did not leave the tomatoes, then Sophie was ill. Also, if Emily was not 
home, then Olivia left the peppers. But it is not true that either Sophie was ill or Olivia left the peppers. 
Therefore, Pat left the tomatoes and Olivia did not leave the peppers. E, P, S, O
	 55.	a.	 Use a truth table to verify that A S (B S C ) 4 (A ` B) S C is a tautology.
	
	 b.	 Prove that A S (B S C ) 3 (A ` B) S C by using a series of equivalences.
	
	 c.	 Explain how this equivalence justifies the deduction method that says: to prove  
P1 ` P2 ` … ` Pn S (R S S ), deduce S from P1, P2, … , Pn, and R.
	 56.	The argument of the defense attorney at the beginning of this chapter was
If my client is guilty, then the knife was in the drawer. Either the knife was not in the drawer or ­Jason 
Pritchard saw the knife. If the knife was not there on October 10, it follows that Jason Pritchard 

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
39
didn’t see the knife. Furthermore, if the knife was there on October 10, then the knife was in the 
drawer and also the hammer was in the barn. But we all know that the hammer was not in the barn. 
Therefore, ladies and gentlemen of the jury, my client is innocent.
	
	 Use propositional logic to prove that this is a valid argument.
	
S e c t i o n  1 . 3 	 Quantifiers, Predicates, and Validity
Quantifiers and Predicates
Propositional wffs have rather limited expressive power. For example, we would 
consider the sentence “For every x, x > 0” to be a true statement about the 
positive integers, yet it cannot be adequately symbolized using only statement 
letters, parentheses, and logical connectives. It contains two new features, a 
quantifier and a predicate. Quantifiers are phrases such as “for every” or “for 
each” or “for some” that tell in some sense how many objects have a certain 
property. The universal quantifier is symbolized by an upside down A, 4, and 
is read “for all,” “for every,” “for each,” or “for any.” Thus the example sentence 
can be symbolized by
(4x)(x > 0)
A quantifier and its named variable are always placed in parentheses. The second 
set of parentheses shows that the quantifier acts on the enclosed expression, which 
in this case is “x > 0.”
The phrase “x > 0” describes a property of the variable x, that of being posi-
tive. A property is also called a predicate; the notation P(x) is used to represent 
some unspecified predicate or property that x may have. Thus, our original sen-
tence is an example of the more general form
(4x)P(x)
The truth value of the expression (4x)(x > 0) depends on the domain of ob-
jects in which we are “interpreting” this expression, that is, the collection of ob-
jects from which x may be chosen. This collection of objects is called the domain 
of interpretation. We have already agreed that if the domain of interpretation con-
sists of the positive integers, the expression has the truth value true because every 
possible value for x has the required property of being greater than zero. If the 
domain of interpretation consists of all the integers, the expression has the truth 
value false, because not every x has the required property. We impose the condi-
tion that the domain of interpretation contain at least one object so that we are not 
talking about a trivial case.
An interpretation of the expression (4x)P(x) would consist of not only the col-
lection of objects from which x could take its value but also the particular property 
that P(x) represents in this domain. Thus an interpretation for (4x)P(x) could be 
the following: The domain consists of all the books in your local library, and P(x) 
is the property that x has a red cover. In this interpretation, (4x)P(x) says that ev-
ery book in your local library has a red cover. The truth value of this expression, 
in this interpretation, is undoubtedly false.

40	
Formal Logic
The predicates we have seen so far, involving properties of a single variable, 
are unary predicates. Predicates can be binary, involving properties of two vari-
ables, ternary, involving properties of three variables, or, more generally, n-ary, 
involving properties of n variables.
The existential quantifier is symbolized by a backward E, E, and is read 
“there exists one,” “for at least one,” or “for some.” Thus the expression
(E x)(x > 0)
is read “there exists an x such that x is greater than zero.”
Again, the truth value of this expression depends on the interpretation. If the 
domain of interpretation contains a positive number, the expression has the value 
true; otherwise, it has the value false. The truth value of (E x)P(x), if the domain 
consists of all the books in your local library and P(x) is the property that x has a 
red cover, is true if there is at least one book in the library with a red cover.
REMINDER
all, every, each, any—use 4
some, one, at least one—
use E
Practice 16	
a.	 Construct an interpretation (i.e., give the domain and the meaning of P(x)) in which (4x)P(x) 
has the value true.
b.	Construct an interpretation in which (4x)P(x) has the value false.
c.	 Can you find one interpretation in which both (4x)P(x) is true and (E x)P(x) is false?
d.	Can you find one interpretation in which both (4x)P(x) is false and (E x)P(x) is true?
	
Example 20	
The expression (4x)(E y)Q(x, y) is read “for every x there exists a y such that 
Q(x, y).” Note that there are two quantifiers for the two variables of the binary 
property. In the interpretation where the domain consists of the integers and Q(x, y) 
is the property that x < y, this just says that for any integer, there is a larger integer. 
The truth value of the expression is true. In the same interpretation, the expression 
(E y)(4x)Q(x, y) says that there is a single integer y that is larger than any integer x. 
The truth value here is false.
PRACTICE 15	 What is the truth value of the expression (5x)P(x) in each of the following interpretations?
a.	 P(x) is the property that x is yellow, and the domain of interpretation is the collection of  
all daffodils.
b.	P(x) is the property that x is yellow, and the domain of interpretation is the collection of all flowers.
c.	 P(x) is the property that x is a plant, and the domain of interpretation is the collection of all  
flowers.
d.	P(x) is the property that x is either positive or negative, and the domain of interpretation consists 
of the integers.
Example 20 illustrates that the order in which the quantifiers appear is 
important.

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
41
In expressions such as (4x)P(x) or (E x)P(x), x is a dummy variable; that is, the 
truth values of the expressions remain the same in a given interpretation if they 
are written, say, as (4y)P( y) or (E z)P(z), respectively. Similarly, the truth value 
of (4x)(E y)Q(x, y) is the same as that of (4z)(E w)Q(z, w) in any interpretation. 
However, (4x)(E x)Q(x, x) says something quite different. In the interpretation of 
Example 20, for instance, (4x)(E x)Q(x, x) says that for every integer x, there is an 
integer x such that x < x. This statement is false, even though (4x)(E y)Q(x, y) was 
true in this interpretation. We cannot collapse separate variables together into one 
without changing the nature of the expression we obtain.
Constants are also allowed in expressions. A constant symbol (a, b, c, 0, 1, 2, 
etc.) is interpreted as some specific object in the domain. This specification is part 
of the interpretation. For example, the expression (4x)Q(x, a) is false in the inter-
pretation where the domain consists of the integers, Q(x, y) is the property x < y, 
and a is assigned the value 7; it is not the case that every integer is less than 7.
Now we can sum up what is required in an interpretation.
	
Definition	
Interpretation
An interpretation for an expression involving predicates consists of the following:
a.	 A collection of objects, called the domain of the interpretation, which must 
include at least one object
b.	An assignment of a property of the objects in the domain to each predicate in 
the expression
c.	 An assignment of a particular object in the domain to each constant symbol in 
the expression
Expressions can be built by combining predicates with quantifiers, grouping 
symbols (parentheses or brackets), and the logical connectives of Section 1.1. As 
before, an expression must obey rules of syntax to be considered a well-formed 
formula. Well-formed formulas containing predicates and quantifiers are called 
predicate wffs to distinguish them from propositional wffs, which contain only 
statement letters and logical connectives.
The expression P(x)(4x) `)E y is not a well-formed formula. Examples of 
predicate wffs are
	 P(x) ~ Q( y)
(1)
	
(4x)[P(x) S Q(x)]
(2)
	
(4x)((E y)[P(x, y) ` Q(x, y)] S R(x))
(3)
and
	
(E x)S(x) ~ (4y)T( y)
(4)
“Grouping symbols” such as parentheses and brackets identify the scope of a 
quantifier, the section of the wff to which the quantifier applies. (This is analo-
gous to the scope of an identifier in a computer program as the section of the 
program in which that identifier has meaning.) There are no quantifiers in wff (1). 
In (2), the scope of the quantifier (4x) is P(x) S Q(x). In (3), the scope of (E y) is 
P(x, y) ` Q(x, y), while the scope of (4x) is the entire expression in parentheses 

42	
Formal Logic
following it. In (4), the scope of (E x) is S(x) and the scope of (4y) is T( y); paren-
theses or brackets can be eliminated when the scope is clear.
If a variable occurs somewhere in a wff where it is not part of a quantifier and 
is not within the scope of a quantifier involving that variable, it is called a free 
variable. For example, y is a free variable in 
(4x)[Q(x, y) S (E y)R(x, y)]
because of the first occurrence of y, which is neither the variable of a quantifier nor 
within the scope of a quantifier using y. A wff with free variables may not have a 
truth value at all in a given interpretation. For example, in the interpretation where 
the domain is all of the integers, the predicate P(x) means “x > 0”, and 5 means (of 
course) the integer 5, the wff
P( y) ` P(5)
has no truth value because we don’t know which element of the domain y refers to. 
Some elements of the domain are positive and others are not. The wff
P( y) ~ P(5)
is true in this interpretation even though we don’t know what y refers to because 
P(5) is true. In both of these wffs y is a free variable.
	
Example 21	
In the wff
(4x)(E y)[S(x, y) ` L( y, a)]
the scope of (E y) is all of S(x, y) ` L( y, a). The scope of (4x) is (E y)[S(x, y) ` L( y, a)]. 
Consider the interpretation where the domain consists of all the cities in the United 
States, S(x, y) is the property “x and y are in the same state,” L( y, z) is the property 
“y’s name begins with the same letter as z’s name,” and a is assigned the value Albu-
querque. So the interpretation of the entire wff is that for any city x there is a city y in 
the same state that begins with the letter A. The wff is true in this interpretation. (At 
least it is true if every state has a city beginning with the letter A.) 
Translation
Many English language statements can be expressed as predicate wffs. For ex-
ample, “Every parrot is ugly,” is really saying, “For any thing, if it is a parrot, 
Practice 17	 What is the truth value of the wff
(E x)(A(x) ` (4y)[B(x, y) S C( y)])
in the interpretation where the domain consists of all integers, A(x) is “x > 0,” B(x, y) is “x > y,” and 
C( y) is “y ≤ 0”? Construct another interpretation with the same domain in which the statement has the 
opposite truth value.

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
43
then it is ugly.” Letting P(x) denote “x is a parrot” and U(x) denote “x is ugly,” the 
statement can be symbolized as
(4x)[P(x) S U(x)]
Other English language variations that take the same symbolic form are, “All par-
rots are ugly,” and, “Each parrot is ugly.” Notice that the quantifier is the univer-
sal quantifier and the logical connective is implication; 4 and S almost always 
belong together. The wff (4x)[P(x) ` U(x)] is an incorrect translation because it 
says that everything in the domain—understood here to be the whole world—
is an ugly parrot. This says something much stronger than the original English 
statement.
Similarly, “There is an ugly parrot,” is really saying, “There exists something 
that is both a parrot and ugly.” In symbolic form,
(E x)[P(x) ` U(x)]
Variations are, “Some parrots are ugly,” and, “There are ugly parrots.” Here the 
quantifier is the existential quantifier and the logical connective is conjunction; E 
and ` almost always belong together. The wff (E x)[P(x) S U(x)] is an incorrect 
translation. This wff is true as long as there is anything, call it x, in the domain 
(the whole world) that is not a parrot, because then P(x) is false and the implication 
is true. Indeed, this wff is true if there are no parrots in the world at all!
To translate an English statement into a wff, it may help to first write an in-
termediate English language statement and then symbolize that statement. We did 
this with the parrot examples.
The word “only” seems particularly troublesome in translations because its 
placement in a sentence can completely change the meaning. For example, the 
English statements
	
1.	 John loves only Mary.
	
2.	 Only John loves Mary
	
3.	 John only loves Mary.
say three entirely different things. Using the predicate symbols J(x) for “x is John,” 
M(x) for “x is Mary,” and L(x, y) for “x loves y,” they can be rewritten as
	
1.	 If John loves any thing, then that thing is Mary.
or
	
1.	 For any thing, if it is John then, if it loves anything, that thing is Mary.
(4x)(J(x) S (4y)(L(x, y) S M( y))
	
2.	 If any thing loves Mary, then that thing is John.
or
	
2.	 For any thing, if it is Mary then, if anything loves it, that thing is John.
(4x)(M(x) S (4y)(L( y, x) S J( y))
	
3.	 If John does any thing to Mary, then that thing is love.
or
REMINDER
Think
4 S
and
E `

44	
Formal Logic
	
3.	 For any thing, if it is John then, for any other thing, if that thing is Mary, 
then John loves it.
(4x)(J(x) S (4y)(M( y) S L(x, y))
In each case, the consequent of the implication is the word following “only” in the 
original English statement.
	
Example 22	
Given the predicate symbols
D(x) is “x is a dog”
R(x) is “x is a rabbit”
C(x, y) is “x chases y”
Table 1.15 shows examples of an English statement, an intermediate English state-
ment, and a wff translation. Note that in wff 2, the connective associated with E 
is ` and the connective associated with 4 is S. In wff 3, the first version shows 
two implications associated with the two 4 quantifiers. The second version is 
equivalent because of the tautology [A ` B S C ] 4 [A S (B S C )]. This ver-
sion may appear to violate the rule that universal quantifiers should be used with 
implication, not conjunction, but this tautology provides another way to write two 
implications. The second version also shows more clearly that “dogs,” the word 
following “only,” is the conclusion.
Table 1.15
English Statement
Intermediate Statement
Wff
1.  All dogs chase 
all rabbits.
For any thing, if it is a dog, 
then for any other thing, if 
that thing is a rabbit, then 
the dog chases it.
(4x)[D(x) S (4y)(R( y) S C(x,y))]
2.  Some dogs 
chase all rabbits.
There is some thing that 
is a dog and, for any other 
thing, if that thing is a rab-
bit, then the dog chases it.
(E x)[D(x) ` (4y)(R( y) S C(x,y))]
3.  Only dogs chase 
rabbits.
For any thing, if it is a ­rabbit 
then, if anything chases it, 
that thing is a dog.
For any two things, if one is 
a rabbit and the other chas-
es it, then the other is a dog.
(4y)[R( y) S (4x)(C(x,y) S D(x))]
(4y)(4x)[R( y) ` C(x,y) S D(x)]
Often more than one wff exists that is a correct representation of an English state-
ment, as seen with statement (3) in Table 1.15. Also wff (2) is equivalent to
(E x)[D(x) ` (4y)([R( y)]′ ~ C(x, y))]
because of the implication equivalence rule that says (R S C ) 4 (R′ ~ C ), even 
though here R and C are predicates instead of just statement letters.

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
45
In addition, it is legitimate to “slide” a quantifier over a predicate that does not 
involve the variable of that quantifier. Because D(x) does not involve y, we could 
slide the universal quantifier in wff (2) to the front (but not past the existential 
quantifier), giving the equivalent wff
	
(E x)(4y)[D(x) ` (R( y) S C(x, y))]	
(a)
In wff (a), we still have grouping symbols around R( y) S C(x,y). Without the 
grouping symbols, this wff becomes 
	
(E x)(4y)[D(x) ` R( y) S C(x, y)]	
(b)
which, according to the order of precedence of connectives, is equivalent to
(E x)(4y)[(D(x) ` R( y)) S C(x, y)]
A quick truth table exercise shows that D ` (R S C ) is not equivalent to  
(D ` R) S C, so wff (b) is not equivalent to wff (a) and thus does not represent 
statement (2) in the table.
Translation from an English statement into a predicate wff is a little harder 
than translation into a propositional wff, partly because of the added expressive-
ness of the verbal form and partly because there can be multiple correct predicate 
wffs. Here is a summary of translation tips:
•	 Look for the key words that signify the type of quantifier:
	
for all, for every, for any, for each: use a universal quantifier
	
for some, there exists: use an existential quantifier.
•	 English sometimes uses “understood” universal quantifiers. For example, 
“Dogs chase rabbits,” is understood to mean, “All dogs chase all rabbits.” 
•	 If you use a universal quantifier, the connective that goes with it is almost 
always implication.
•	 If you use an existential quantifier, the connective that goes with it is 
­almost always conjunction.
•	 Whatever comes after the word “only” is the conclusion of an implication; 
that is, it comes after “then” in an “if–then” statement.
•	 You are most apt to arrive at a correct translation if you follow the order 
of the English words.
	
Example 23	
Let’s do a couple of examples in great detail. The first is
All giraffes are tall.
The property of being a giraffe and the property of being tall are unary predicates. 
We’ll use G(x) for “x is a giraffe” and T(x) for “x is tall”. Following the sentence 
structure, we first see “All,” which tells us that there’s a universal quantifier, so the 
wff begins with
(4x)( … )

46	
Formal Logic
All what? All giraffes, so
(4x)(G(x) … )
Because of the universal quantifier, we expect to use the implication connective, 
so now we have
(4x)(G(x) S … )
Thinking of the implication as an “if–then,” we have “if a giraffe, then … .” Then 
what? Then it's tall. The final wff is
(4x)(G(x) S T(x))
The second example is
Only giraffes are taller than elephants.
The property of being a giraffe and the property of being an elephant are unary 
predicates, and we’ll use G(x) and E(x) to represent them. But “taller than” is a 
property that compares two things, so it’s a binary predicate; T(x, y) will mean “x 
is taller than y”. There are no obvious quantifier key words, so we understand that 
we are talking about all giraffes and all elephants (universal quantifiers). The word 
“giraffes” follows the word “only,” so the property of being a giraffe is going to 
be the conclusion of an implication and the overall form will be “if xxx, then a 
giraffe.” Indeed, if something is taller than an elephant, then it’s a giraffe. Putting 
in the universal quantifiers, “if any thing is taller than any elephant, then that thing 
is a giraffe,” or (even more tortured English), “for any thing, if it is an elephant, 
then for any other thing, if it’s taller than the elephant, then it’s a giraffe.” Now we 
can pretty much translate directly into a wff. “For any thing, if it is an elephant, 
then” becomes
(4x)(E(x) S … )
and, “for any other thing, if it's taller than the elephant, then,” adds a second im-
plication to the wff:
(4x)(E(x) S (4y)(T( y, x) S … ))
Notice that we introduced y here, a second variable, because we’ve already given 
x the elephant property. Also, we’ve written T( y, x), not T(x, y), because we want 
this new thing to be taller than the elephant, and our definition of the taller predi-
cate was that the first variable was taller than the second. We are ready for the final 
conclusion—this new thing is a giraffe.
(4x)(E(x) S (4y)(T( y, x) S G( y)))
As in Table 1.15(3), a tautology allows us to also write this wff as
(4x)(4y)(E(x) ` T( y, x) S G( y))
“For any two things, if one is an elephant and the other is taller than the elephant, 
then the other thing is a giraffe.”
With some practice, you won’t have to go quite this slowly! 

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
47
PRACTICE 19	 Using the predicate symbols F(x) for “x is a fruit,” V(x) for “x is a vegetable,” and S(x,y) for 
“x is sweeter than y,” write wffs that express the following statements. (The domain is the 
whole world.)
a.	 Some vegetable is sweeter than all fruits.
b.	Every fruit is sweeter than all vegetables.
c.	 Every fruit is sweeter than some vegetable.
d.	Only fruits are sweeter than vegetables.
Negating statements with quantifiers, as in negating compound statements, 
requires care. The negation of the statement, “Everything is beautiful,” is, “It is 
false that everything is beautiful,” or, “Something is nonbeautiful.” Symbolically,
[(4x)A(x)]′ is equivalent to (E x)[A(x)]′
Note that, “Everything is nonbeautiful,” or (4x)[A(x)]′, says something stronger 
than the negation of the original statement.
The negation of, “Something is beautiful,” is, “Nothing is beautiful,” or, 
“­Everything fails to be beautiful.” Symbolically,
[(E x)A(x)]′ is equivalent to (4x)[A(x)]′
In English, the statement, “Everything is not beautiful,” would often be misinter-
preted as, “Not everything is beautiful,” or, “There is something nonbeautiful.” 
However, this misinterpretation, symbolized by (E x)[A(x)]′, is not as strong as the 
negation of the original statement.
Practice 20	 Which of the following statements expresses the negation of, “Everybody loves ­somebody 
sometime”?
a.	 Everybody hates somebody sometime.
b.	Somebody loves everybody all the time.
c.	 Everybody hates everybody all the time.
d.	Somebody hates everybody all the time.
Practice 18	 Using the predicate symbols S(x) for “x is a student,” I(x) for “x is intelligent,” and M(x) 
for “x likes music,” write wffs that express the following statements. (The domain is the 
­collection of all people.)
a.	 All students are intelligent.
b.	Some intelligent students like music.
c.	 Everyone who likes music is a stupid student.
d.	Only intelligent students like music.

48	
Formal Logic
Validity
The truth value of a propositional wff depends on the truth values assigned to the 
statement letters. The truth value of a predicate wff depends on the interpretation. 
Choosing an interpretation for a predicate wff is thus analogous to choosing truth 
values in a propositional wff. However, there are an infinite number of possible 
interpretations for a predicate wff and only 2n possible rows in the truth table for 
a propositional wff with n statement letters.
A tautology is a propositional wff that is true for all rows of the truth table. 
The analogue to tautology for predicate wffs is validity—a predicate wff is valid 
if it is true in all possible interpretations. The validity of a wff must be derived 
from the form of the wff itself, since validity is independent of any particular in-
terpretation; a valid wff is “intrinsically true.”
An algorithm exists to decide whether a propositional wff is a tautology—
construct the truth table and examine all possible truth assignments. How can we 
go about deciding validity for predicate wffs? We clearly cannot look at all pos-
sible interpretations, because there are an infinite number of them. As it turns out, 
no algorithm to decide validity for any wff exists. (This does not mean simply that 
no algorithm has yet been found—it means that it has been proved that there is no 
such algorithm.) We must simply use reasoning to determine whether the form of 
a particular wff makes the wff true in all interpretations. Of course, if we can find 
a single interpretation in which the wff has the truth value false or has no truth 
value at all, then the wff is not valid.
Table 1.16 compares propositional and predicate wffs.
Table 1.16
Propositional Wffs
Predicate Wffs
Truth values
True or false, depending on 
truth value assignments to 
statement letters
True, false, or perhaps (if the 
wff has a free variable) neither, 
depending on interpretation
“Intrinsic truth”
Tautology—true for all truth 
value assignments
Valid wff—true for all 
­interpretations
Methodology
Algorithm (truth table) to 
determine whether wff is a 
­tautology
No algorithm to determine 
whether wff is valid
Now let’s try our hand at determining validity for specific wffs.
	
Example 24	
a.  The wff
(4x)P(x) S (E x)P(x)
is valid. In any interpretation, if every element of the domain has a certain prop-
erty, then there exists an element of the domain that has that property. (Remember 
that the domain of any interpretation must have at least one object in it.) ­Therefore, 

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
49
whenever the antecedent is true, so is the consequent, and the implication is there-
fore true.
b.  The wff
(4x)P(x) S P(a)
is valid because in any interpretation, a is a particular member of the domain and 
therefore has the property that is shared by all members of the domain.
c.  The wff
(4x)[P(x) ` Q(x)] 4 (4x)P(x) ` (4x)Q(x)
is valid. If both P and Q are true for all the elements of the domain, then P is true 
for all elements and Q is true for all elements, and vice versa.
d.  The wff
P(x) S [Q(x) S P(x)] 
is valid, even though it contains a free variable. To see this, consider any inter-
pretation, and let x be any member of the domain. Then x either does or does not 
have property P. If x does not have property P, then P(x) is false; because P(x) 
is the antecedent of the main implication, this implication is true. If x does have 
property P, then P(x) is true; regardless of the truth value of Q(x), the implication  
Q (x) S P(x) is true, and so the main implication is also true.
e.  The wff
(E x)P(x) S (4x)P(x)
is not valid. For example, in the interpretation where the domain consists of the 
integers and P(x) means that x is even, it is true that there exists an integer that is 
even, but it is false that every integer is even. The antecedent of the implication is 
true and the consequent is false, so the value of the implication is false.
We do not necessarily have to go to a mathematical context to construct an 
interpretation in which a wff is false, but it is frequently easier to do so because 
the relationships among objects are relatively clear.
Practice 21	 Is the wff valid or invalid? Explain.
(4x)[P(x) ~ Q(x)] S (4x)P(x) ~ (4x)Q(x)

50	
Formal Logic
S e c t i o n  1 . 3 	
Review
Techniques
•	 Determine the truth value of a predicate wff in a 
given interpretation.
•	 Translate English language statements into predi-
cate wffs, and vice versa.
•	 Recognize a valid wff and explain why it is valid.
•	 Recognize a nonvalid wff and construct an inter-
pretation in which it is false or has no truth value.
Main Ideas
•	 The truth value of predicate wffs depends on the 
interpretation considered.
•	 Valid predicate wffs are “intrinsically true”—true 
in all interpretations.
W
W
W
Exercises 1.3
	 1.	 What is the truth value of each of the following wffs in the interpretation where the domain consists of the 
integers, O(x) is “x is odd,” L(x) is “x < 10,” and G(x) is “x > 9”?
	
a.	 (E x)O(x)	
c.	 (E x)[L(x) ` G(x)]
	
b.	(4x)[L(x) S O(x)]	
d.	(4x)[L(x) ~ G(x)]
	 2.	 What is the truth value of each of the following wffs in the interpretation where the domain consists of the 
integers, A(x) is “x < 5” and B(x) is “x < 7”?
	
a.	 (E x)A(x)	
c.	 (4x)[A(x) S B(x)]
	
b.	(E x)[A(x) ` B(x)]	
d.	(4x)[B(x) S A(x)]
	 3.	 What is the truth value of each of the following wffs in the interpretation where the domain consists of the 
integers?
	
a.	 (4x)(E y)(x + y = x)	
e.	 (4x)(4y)(x < y ~ y < x)
	
b.	(E y)(4x)(x + y = x)	
f.	 (4x)[x < 0 S (E y)( y > 0 ` x + y = 0)]
	
c.	 (4x)(E y)(x + y = 0)	
g.	(E x)(E y)(x2 = y)
	
d.	(E y)(4x)(x + y = 0)	
h.	(4x)(x2 > 0)
	 4.	 What is the truth value of each of the following wffs in the interpretation where the domain consists of the 
real numbers?
	
a.	 (4x)(E y)(x = y2)	
c.	 (E x)(4y)(x = y2)
	
b.	(4x)(4y)(x = y2)	
d.	(E x)(E y)(x = y2)
	 5.	 Give the truth value of each of the following wffs in the interpretation where the domain consists of  
the states of the United States, Q(x, y) is “x is north of y,” P(x) is “x starts with the letter M,” and a is 
“Massachusetts.”
	
a.	 (4x)P(x)
	
b.	(4x)(4y)(4z)[Q(x, y) ` Q( y, z) S Q(x, z)]
	
c.	 (E y)(E x)Q( y, x)
	
d.	(4x)(E y)[P( y) ` Q(x, y)]
	
e.	 (E y)Q(a, y)
	
f.	 (E x)[P(x) ` Q(x, a)]
	 6.	 Give the truth value of each of the following wffs in the interpretation where the domain consists of 
people, M(x, y) is “x is the mother of y”, F(x) is “x is female”, M(x) is “x is male.”
	
a.	 (4x)(E y)(M( y, x)) 	
d.	(E x)(E y)(M(x, y) ` M( y))
	
b.	(E x)(4y)(M(x, y)) 	
e.	 (E x)(4y)(M(x, y) S F( y))
	
c.	 (4x)(4y)(M(x, y) S M( y))

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
51
	 7.	 For each wff, find an interpretation in which it is true and one in which it is false.
	
a.	 (4x)([A(x) ~ B(x)] ` [A(x) ` B(x)]′)
	
b.	(4x)(4y)[P(x, y) S P( y, x)]
	
c.	 (4x)[P(x) S (E y)Q(x, y)]
	 8.	 For each wff, find an interpretation in which it is true and one in which it is false.
	
a.	 (E x)[A(x) ` (4y)B(x, y)]
	
b.	[(4x)A(x) S (4x)B(x)] S (4x)[A(x) S B(x)]
	
c.	 (E x)[P(x) ~ Q(x)] ` (4x)[P(x) S Q(x)]
	 9.	 Identify the scope of each of the quantifiers in the following wffs and indicate any free variables.
	
a.	 (4x)[P(x) S Q( y)]	
c.	 (E x)[(4y)P(x, y) ` Q(x, y)]
	
b.	(E x)[A(x) ` (4y)B( y)]	
d.	(E x)(E y)[A(x, y) ` B( y, z) S A(a, z)]
	 10.	Explain why each of the following expressions is written incorrectly.
	
a.	 (E )(Q(x) ` P(x)
	
b.	(4y)(Q( y) P( y))
	
c.	 (4x)(4y)Q(x) S P( y)
	 11.	Which of the following sentences are equivalent to the statement
	
All circles are round.
	
a.	 If it’s round, it’s a circle.
	
b.	Roundness is a necessary property of circles.
	
c.	 Something that isn’t round can’t be a circle.
	
d.	Some round things are circles.
	 12.	Which of the following sentences are equivalent to the statement
	
Cats are smarter than dogs.
	
a.	 Some cats are smarter than some dogs.
	
b.	There is a cat that is smarter than all dogs.
	
c.	 All cats are smarter than all dogs.
	
d.	Only cats are smarter than dogs.
	
e.	 All cats are smarter than any dog.
	 13.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 D(x): x is a day
	
	 S(x): x is sunny
	
	 R(x): x is rainy
	
	 M: Monday
	
	 T: Tuesday
	
a.	 All days are sunny.
	
b.	Some days are not rainy.
	
c.	 Every day that is sunny is not rainy.
	
d.	Some days are sunny and rainy.

52	
Formal Logic
	
e.	 No day is both sunny and rainy.
	
f.	 It is always a sunny day only if it is a rainy day.
	
g.	No day is sunny.
	
h.	Monday was sunny; therefore, every day will be sunny.
	
i.	 It rained both Monday and Tuesday.
	
j.	 If some day is rainy, then every day will be sunny.
	 14.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 B(x): x is a ball
	
	 R(x): x is round
	
	 S(x): x is a soccer ball
	
a.	 All balls are round.
	
b.	Not all balls are soccer balls.
	
c.	 All soccer balls are round.
	
d.	Some balls are not round.
	
e.	 Some balls are round but soccer balls are not.
	
f.	 Every round ball is a soccer ball.
	
g.	Only soccer balls are round balls.
	
h.	If soccer balls are round, then all balls are round.
	 15.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 M(x): x is a man
	
	 W(x): x is a woman
	
	 T(x): x is tall
	
a.	 All men are tall.
	
b.	Some women are tall.
	
c.	 All men are tall but no woman is tall.
	
d.	Only women are tall
	
e.	 No man is tall.
	
f.	 If every man is tall, then every woman is tall.
	
g.	Some woman is not tall.
	
h.	If no man is tall, then some woman is not tall.
	 16.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 A(x): x is an animal
	
	 B(x): x is a bear
	
	 H(x): x is hungry
	
	 W(x): x is a wolf
	
a.	 Bears are animals.
	
b.	No wolf is a bear.

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
53
	
c.	 Only bears are hungry.
	
d.	If all wolves are hungry, so are bears.
	
e.	 Some animals are hungry bears.
	
f.	 Bears are hungry but some wolves are not.
	
g.	If wolves and bears are hungry, so are all animals.
	
h.	Some wolves are hungry but not every animal is hungry.
	 17.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 P(x): x is a person
	
	 T(x): x is a time
	
	 F(x, y): x is fooled at y
	
a.	 You can fool some of the people all of the time.
	
b.	You can fool all of the people some of the time.
	
c.	 You can’t fool all of the people all of the time.
	 18.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 L(x): x is a lion
	
	 R(x): x roars
	
	 P(x): x is a predator
	
	 Z(x): x is a zebra
	
	 E(x, y): x eats y
	
a.	 All lions are predators.
	
b.	Some lions roar.
	
c.	 Only lions roar.
	
d.	Some lions eat all zebras.
	
e.	 All lions eat all zebras.
	 19.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 G(x): x is a game
	
	 M(x): x is a movie
	
	 F(x, y): x is more fun than y
	
a.	 Any movie is more fun than any game.
	
b.	No game is more fun than every movie.
	
c.	 Only games are more fun than movies.
	
d.	All games are more fun than some movie.
	 20.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 C(x): x is a child
	
	 T(x): x is a toy

54	
Formal Logic
	
	 V(x): x is a vegetable
	
	 W(x, y): x wants y
	
a.	 Every child wants toys.
	
b.	Only children want toys.
	
c.	 Some child wants only toys.
	
d.	No child wants vegetables.
	 21.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 J(x): x is a judge 
	
	 L(x): x is a lawyer 
	
	 W(x): x is a woman
	
	 C(x): x is a chemist 
	
	 A(x, y): x admires y
	
a.	 There are some women lawyers who are chemists.
	
b.	No woman is both a lawyer and a chemist.
	
c.	 Some lawyers admire only judges.
	
d.	All judges admire only judges.
	
e.	 Only judges admire judges.
	
f.	 All women lawyers admire some judge.
	
g.	Some women admire no lawyer.
	 22.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 C(x): x is a Corvette
	
	 F(x): x is a Ferrari
	
	 P(x): x is a Porsche
	
	 S(x, y): x is slower than y
	
a.	 Nothing is both a Corvette and a Ferrari.
	
b.	Some Porsches are slower than only Ferraris.
	
c.	 Only Corvettes are slower than Porsches.
	
d.	All Ferraris are slower than some Corvettes.
	
e.	 Some Porsches are slower than no Corvette.
	
f.	 If there is a Corvette that is slower than a Ferrari, then all Corvettes are slower than all Ferraris.
	 23.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 B(x):x is a bee
	
	 F(x): x is a flower
	
	 L(x, y): x loves y
	
a.	 All bees love all flowers.	
d.	Every bee hates only flowers. 
	
b.	Some bees love all flowers.	
e.	 Only bees love flowers.
	
c.	 All bees love some flowers. 	
f.	 Every bee loves only flowers.

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
55
	
g.	No bee loves only flowers.	
j.	 Every bee hates some flowers.
	
h.	Some bees love some flowers. 	
k.	Every bee hates all flowers.
	
i.	 Some bees love only flowers. 	
l.	 No bee hates all flowers.
	 24.	Using the predicate symbols shown and appropriate quantifiers, write each English language statement as 
a predicate wff. (The domain is the whole world.)
	
	 S(x): x is a spy novel
	
	 L(x): x is long
	
	 M(x): x is a mystery
	
	 B(x, y): x is better than y
	
a.	 All spy novels are long.
	
b.	Not every mystery is a spy novel.
	
c.	 Only mysteries are long.
	
d.	Some spy novels are mysteries.
	
e.	 Spy novels are better than mysteries.
	
f.	 Some mysteries are better than all spy novels.
	
g.	Only spy novels are better than mysteries.
	 25.	Give English language translations of the following wffs if
	
	 L(x, y): x loves y
	
	 H(x): x is handsome
	
	 M(x): x is a man
	
	 P(x): x is pretty
	
	 W(x): x is a woman
	
	 j: John
	
	 k: Kathy
	
	 L(x, y): x loves y
	
a.	 H( j) ` L(k, j)
	
b.	(4x)[M(x) S H(x)]
	
c.	 (4x)(W(x) S (4y)[L(x, y) S M( y) ` H( y)])
	
d.	(E x)[M(x) ` H(x) ` L(x, k)]
	
e.	 (E x)(W(x) ` P(x) ` (4y)[L(x, y) S H( y) ` M( y)])
	
f.	 (4x)[W(x) ` P(x) S L( j, x)]
	 26.	Give English language translations of the following wffs if
	
	 M(x): x is a man
	
	 W(x): x is a woman
	
	 i: Ivan
	
	 p: Peter
	
	 W(x, y): x works for y
	
a.	 (E x)(W(x) ` (4y)(M( y) S [W(x, y)]′))
	
b.	(4x)[M(x) S (E y)(W( y) ` W(x, y))]
	
c.	 (4x)[M(x) S (4y)(W(x, y) S W( y))]

56	
Formal Logic
	
d.	(4x)(4y)(M(x) ` W( y, x) S W( y))
	
e.	 W(i, p) ` (4x)[W( p, x) S (W(x))′])
	
f.	 (4x)[W(x, i) S (W(x))′]
	 27.	Three forms of negation are given for each statement. Which is correct?
	
a.	 Some people like mathematics.
	
	
1.	Some people dislike mathematics.
	
	
2.	Everybody dislikes mathematics.
	
	
3.	Everybody likes mathematics.
	
b.	Everyone loves ice cream.
	
	
1.	No one loves ice cream.
	
	
2.	Everyone dislikes ice cream.
	
	
3.	Someone doesn’t love ice cream.
	
c.	 All people are tall and thin.
	
	
1.	Someone is short and fat.
	
	
2.	No one is tall and thin.
	
	
3.	Someone is short or fat.
	
	 d. Some pictures are old or faded.
	
	
1.	Every picture is neither old nor faded.
	
	
2.	Some pictures are not old or faded.
	
	
3.	All pictures are not old or not faded.
	 28.	Three forms of negation are given for each statement. Which is correct?
	
a.	 Nobody is perfect.
	
	
1.	Everyone is imperfect.
	
	
2.	Everyone is perfect.
	
	
3.	Someone is perfect.
	
b.	All swimmers are tall.
	
	
1.	Some swimmer is not tall.
	
	
2.	There are no tall swimmers.
	
	
3.	Every swimmer is short.
	
c.	 Every planet is cold and lifeless.
	
	
1.	No planet is cold and lifeless.
	
	
2.	Some planet is not cold and not lifeless.
	
	
3.	Some planet is not cold or not lifeless.
	
d.	No bears are hungry.
	
	
1.	Only bears are hungy.
	
	
2.	All bears are hungry.
	
	
3.	There is a hungry bear.
	 29.	Write the negation of each of the following statements.
	
a.	 Some Web sites feature audio.
	
b.	Every Web site has both audio and video.
	
c.	 Every Web site has either audio or video.

	
	
Section 1.3   Quantifiers, Predicates, and Validity	
57
	
d.	Some Web sites have neither audio nor video.
	
e.	 Every Web site either has text or else has both audio and video.
	 30.	Write the negation of each of the following statements.
	
a.	 Only students eat pizza.
	
b.	Every student eats pizza
	
c.	 Some students eat only pizza.
	 31.	Write the negation of each of the following statements.
	
a.	 Some farmer grows only corn.
	
b.	All farmers grow corn.
	
c.	 Corn is grown only by farmers.
	 32.	Write the negation of each of the following statements
	
a.	 Some child fears all clowns.
	
b.	Some children fear only clowns.
	
c.	 No clown fears any child.
	 33.	Explain why each wff is valid.
	
a.	 (4x)(4y)A(x, y) 4 (4y)(4x)A(x, y)
	
b.	(E x)(E y)A(x, y) 4 (E y)(E x)A(x, y)
	
c.	 (E x)(4y)P(x, y) S (4y)(E x)P(x, y)
	
d.	A(a) S (E x)A(x)
	
e.	 (4x)[A(x) S B(x)] S [(4x)A(x) S (4x)B(x)]
	 34.	Give interpretations to prove that each of the following wffs is not valid:
	
a.	 (E x)A(x) ` (E x)B(x) S (E x)[A(x) ` B(x)]
	
b.	(4x)(E y)P(x, y) S (E x)(4y)P(x, y)
	
c.	 (4x)[P(x) S Q(x)] S [(E x)P(x) S (4x)Q(x)]
	
d.	(4x)[A(x)]′ 4 [(4x)A(x)]′
	 35.	Decide whether each of the following wffs is valid or invalid. Justify your answer.
	
a.	 (E x)A(x) 4 ((4x)[A(x)]′)′
	
b.	(4x)P(x) ~ (E x)Q(x) S (4x)[P(x) ~ Q(x)]
	 36.	Decide whether each of the following wffs is valid or invalid. Justify your answer.
	
a.	 (4x)A(x) S ((E x)[A(x)]′)′
	
b.	(4x)[P(x) S Q(x)] ` (E x)[P(x) ~ Q(x)] S (E x)[P(x) ` Q(x)]
	
c.	 (4x)[P(x) ~ Q(x)] S (4x)P(x) ~ (E y)Q( y)
	 37.	From Example 24c, we know that (4x)[P(x) ` Q(x)] 4 (4x)P(x) ` (4x)Q(x) is valid. From Prac-
tice 21, we know that (4x)[P(x) ~ Q(x)] 4 (4x)P(x) ~ (4x)Q(x) is not valid. From Exercise 34a, we 
know that (E x)[P(x) ` Q(x)] 4 (E x)P(x) ` (E x)Q(x) is not valid. Explain why (E x)[P(x) ~ Q(x)] 4 
(E x)P(x) ~ (E x)Q(x) is valid.
	 38.	A predicate wff is in prenex normal form if all the quantifiers appear at the front of the wff. Write each of 
the following expressions as an equivalent wff in prenex normal form.
	
a.	 (4x)P(x) ` (4y)Q( y)
	
b.	(4x)(P(x) S (4y)[Q( y) S W(x, y)])
	
c.	 (E x)P(x) ` (E x)Q(x)

58	
Formal Logic
	
S e c t i o n  1 . 4 	 Predicate Logic
We can imagine arguments of the form
P1 ` P2 ` P3 ` … ` Pn S Q
where the wffs are built from predicates and quantifiers as well as logical connec-
tives and grouping symbols. For a valid argument, Q must follow logically from 
P1, … , Pn based solely on the internal structure of the argument, not on the truth 
or falsity of Q in any particular interpretation. In other words, the wff
P1 ` P2 ` P3 ` … ` Pn S Q
must be valid—true in all possible interpretations. No equivalent of the truth table 
exists to easily prove validity, so we turn to a formal logic system called predicate 
logic. We again use a system of derivation rules to build a proof sequence lead-
ing from the hypotheses to the conclusion. The rules should once more be truth-
preserving, so that if in some interpretation, all the hypotheses are true, then the 
conclusion will also be true in that interpretation. The system will then be correct  
(only valid arguments will be provable). We also want the system to be complete 
(every valid argument should be provable), yet at the same time the rule set should 
be minimal.
Derivation Rules for Predicate Logic4
The equivalence rules and inference rules of propositional logic are still part of 
predicate logic. An argument of the form
P ` (P S Q) S Q
is still valid by modus ponens, even if the wffs involved are predicate wffs.
	
EXAMPLE 25	
Use predicate logic to prove the validity of the argument
(4x)R(x) ` [(4x)R(x) S (4x)S(x)] S (4x)S(x)
A proof sequence is
	
1.	 (4x)R(x)	
hyp
	
2.	 (4x)R(x) S (4x)S(x)	 hyp
	
3.	 (4x)S(x) 	
1, 2, mp
However, there are many arguments with predicate wffs that are not tautolo-
gies but are still valid because of their structure and the meaning of the univer-
sal and existential quantifiers (see Example 24). The overall approach to proving 
these arguments is to strip off the quantifiers, manipulate the unquantified wffs, 
4A complete list of derivation rules for propositional and predicate logic is given in Appendix A.

	
	
Section 1.4   Predicate Logic	
59
and then put the quantifiers back in. The new rules of inference provide mecha-
nisms to strip off and insert quantifiers. Hence there are four new rules—one each 
to strip off the universal and existential quantifier, respectively, and one each to 
insert the universal and existential quantifier, respectively. The four rules are given 
in Table 1.17; their details will be explained shortly. In Table 1.17, the notation P(x) 
does not imply that P is a unary predicate with x as its only variable; it simply 
means that x is one of the variables in the predicate P. Thus P(x) might actually be 
something like (E y)(4z)Q(x, y, z).
Table 1.17
Inference Rules
From
Can Derive
Name/Abbreviation for Rule
Restrictions on Use
(4x)P(x)
P(t), where t is a variable or 
constant symbol
Universal instantiation—ui
If t is a variable, it must not fall 
within the scope of a quantifier 
for t.
(E x)P(x)
P(a) where a is a constant 
symbol not previously used 
in proof sequence
Existential instantiation—ei
Must be the first rule used that 
introduces a.
P(x)
(4x)P(x)
Universal generalization—ug
P(x) has not been deduced from 
any hypotheses in which x is a 
free variable nor has P(x) been 
deduced by ei from any wff in 
which x is a free variable.
P(x) or P(a) 
where a is 
a constant 
symbol
(E x)P(x)
Existential generalization—eg
To go from P(a) to (E x)P(x), x must 
not appear in P(a).
Now let’s examine these rules more closely, particularly the necessity for their 
restrictions.
Universal Instantiation
The universal instantiation rule says that from (4x)P(x) we can derive P(x), 
P( y), P(z), P(a), and so on, thus stripping off a universal quantifier. The justifica-
tion is that if P is true for every element of the domain, we can name such an ele-
ment by an arbitrary variable name like x, y, or z, or we can specify a particular 
constant in the domain, and P is still true for all of these things.
	
EXAMPLE 26	
Universal instantiation can be used to prove one of the classical “syllogisms” of 
the Greek philosopher and scientist Aristotle, who lived from 384 to 322 b.c.e. and 
who first developed a system of formal logic.
The argument has the form, “All humans are mortal. Socrates is human. There-
fore Socrates is mortal.” Using the notation
H(x) is “x is human.”
s is a constant symbol (Socrates)
M(x) is “x is mortal.”

60	
Formal Logic
Practice 22	 Prove the argument 
(4x)[P(x) S R(x)] ` [R( y)]′S [P( y)]′
Existential Instantiation
The existential instantiation rule allows us to strip off an existential quantifier. 
It says that from (E x)P(x) we can derive P(a) or P(b) or P(c ) provided that these 
are new constant symbols. The justification is that if P is true for some element 
of the domain, we can give that element a specific name, but we cannot assume 
anything else about it.
Without the restriction on universal instantiation, a hypothesis of the form 
(4x)(E y)P(x, y) could lead to the wff (E y)P( y, y); here y has been substituted for x 
within the scope of a quantifier on y. This would be invalid. For example, in the 
domain of the integers, if P(x, y) means “y > x,” then (4x)(E y)P(x, y) is true (for 
every integer there is a bigger integer) but (E y)P( y, y) is false (no integer has the 
property that it is bigger than itself).
the argument is
(4x)[H(x) S M(x)] ` H(s) S M(s)
and a proof sequence is
(4x)(H(x) S M(x))	
hyp
H(s)	
hyp
H(s) S M(s)	
1, ui
M(s)	
2, 3, mp
In step 3, a constant symbol has been substituted for x throughout the scope of the 
universal quantifier, as allowed by universal instantiation.
	
EXAMPLE 27	
The following expressions would be legitimate steps in a proof sequence:
	 1.	(4x)[P(x) S Q(x)]	 hyp
	 2.	(E y)P( y)	
hyp
	 3.	P(a)	
2, ei
	 4.	P(a) S Q(a)	
1, ui
	 5.	Q(a)	
3, 4, mp
In step 3, the specific element with property P was given the name a. In step 4, 
ui was then used to say that an implication that is universally true in the domain 
is certainly true for this a. Steps 3 and 4 cannot be reversed. If ui is first used on 
hypothesis 1 to name a constant a, there is then no reason to assume that this par-
ticular a is the one that is guaranteed by hypothesis 2 to have property P.

	
	
Section 1.4   Predicate Logic	
61
The effect of the restriction on  existential instantiation is that you should look 
at all your hypotheses and, if you plan to use ei on any of them, do it first.
Universal Generalization
Universal generalization allows a universal quantifier to be inserted. This must 
be done pretty carefully, however. If we know that P(x) is true and that the x is 
absolutely arbitrary, i.e., that x could be any element of the domain, then we can 
conclude (4x)P(x). But if x is supposed to represent some specific element of the 
domain that has property P, then we can’t generalize that every element of the 
domain has property P.
There are two restrictions on universal generalization. Without the first re-
striction, the sequence
	
1.	P(x)	
hyp
	
2. 	(4x)P(x)	 1, incorrect ug; x was free in the hypothesis.
would be a proof of the wff P(x) S (4x)P(x), but this is not a valid wff. Element x 
of the domain may have property P, but that does not mean that every element of 
the domain has property P. In the hypothesis, x is naming some fixed if unspeci-
fied element of the domain. For instance, in the interpretation where the domain 
consists of automobiles and P(x) means “x is yellow,” some particular car may be 
yellow but it is certainly not true that all cars are yellow.
Without the second restriction, the sequence
	
1.	(4x)(E y)Q(x, y)	
hyp
	2.	(E y)Q(x, y)	
1, ui
	3.	Q(x, a)	
2, ei
	4.	(4x)Q(x, a)	
3, incorrect ug; Q(x, a) was deduced by ei from the wff  
in step 2, in which x is free.
	
EXAMPLE 28	
Use predicate logic to prove
(4x)[P(x) S Q(x)] ` (4x)P(x) S (4x)Q(x)
Here is a proof sequence.
	 1.  (4x)[P(x) S Q(x)]	
hyp
	 2.  (4x)P(x)	
hyp
	 3.  P(x) S Q(x)	
1, ui
	 4.  P(x)	
2, ui Note that there is no restriction on ui about 
­reusing a name.
	 5  Q(x)	
3, 4, mp
	 6.  (4x)Q(x)	
5, ug
The use of universal generalization at step 6 is legitimate because x was not a 
free variable in any hypothesis nor was ei used anywhere in the proof. The vari-
able x in steps 3 and 4 is just an arbitrary name, representative of any element 
in the domain.
REMINDER
Use existential instan-
tiation early in the proof 
sequence.

62	
Formal Logic
would be a proof of the wff (4x)(E y)Q(x, y) S (4x)Q(x, a). This is also not a valid 
wff. For instance, in the interpretation where the domain consists of the integers 
and Q(x, y) means that x + y = 0, then it is the case that for every integer x there 
is an integer y (the negative of x) such that x + y = 0. However, if a is a particular 
fixed element in the domain, then it will not be true that adding that same integer 
a to every x will always produce zero.
Practice 23	 Prove the argument
(4x)[P(x) ` Q(x)] S (4x)[Q(x) ` P(x)].
Existential Generalization
The last rule allows insertion of an existential quantifier. From P(x) or P(a) we can 
derive (E x)P(x); something has been named as having property P, so we can say 
that there exists something that has property P.
	
EXAMPLE  29	
Prove the argument (4x)P(x) S (E x)P(x).
Here is a proof sequence.
	 1.	 (4x)P(x)	
hyp
	 2.	 P(x)	
1, ui
	 3.	 (E x)P(x)	
2, eg
Without the restriction on existential generalization, from P(a, y) one could 
derive (E y)P( y, y); here the quantified variable y, which replaced the constant sym-
bol a, already appeared in the wff to which existential generalization was applied. 
But the argument P(a, y) S (E y)P( y, y) is not valid. In the domain of integers, if 
P(x, y) means “y > x” and a stands for 0, then if y > 0, this does not mean that 
there is an integer y that is greater than itself.
More Work with Rules
As is the case with propositional logic rules, predicate logic rules can be applied 
only when the exact pattern of the rule is matched (and, of course, when no 
restrictions on use of the rule are violated). In particular, notice that the instan-
tiation rules strip off a quantifier from the front of an entire wff that is in the 
scope of that quantifier. Both of the following would be illegal uses of existential 
instantiation:
	
1.	 (E x)P(x) ~ (E x)Q(x)	 hyp
	
2.	 P(a) ~ Q(a)
1, incorrect ei. The scope of the first existential quan-
tifier in step 1 does not extend to the whole rest of 
the wff.

	
	
Section 1.4   Predicate Logic	
63
	
1.	 (4x)(E y)Q(x, y)	
hyp
2.	(4x)Q(x, a)	
1, incorrect ei. The existential quantifier in step 1 is not at 
the front.
Similarly, the rules to insert a quantifier put the quantifier in the front of a wff that 
is then entirely within its scope.
The new derivation rules all have restrictions, but in practice, you are most 
likely to violate the ei restriction. Pay special attention to this restriction and be 
sure that when you substitute a constant using ei, it’s not a previously used constant.
Even though we have added only four new derivation rules, the rule set is 
complete and correct. We can prove every valid argument and only valid argu-
ments using these rules. Application of the rules, as in the case of propositional 
logic, is somewhat mechanical because there are only a limited number of options 
at each step. Again, the general plan of attack is usually as follows:
•	 Strip off the quantifiers.
•	 Work with the separate wffs.
•	 Insert quantifiers as necessary.
	
EXAMPLE 30	
Using predicate logic, prove the argument
(4x)[P(x) ` Q(x)] S (4x)P(x) ` (4x)Q(x)
In Example 24(c ) we noted that this wff is valid, so if all valid arguments are prov-
able, we should be able to find a proof sequence. As usual, the hypothesis gives us 
a starting point.
	1.	(4x)[P(x) ` Q(x)]  hyp
Stripping off the universal quantifier that appears in step 1 will yield access to  
P(x) ` Q(x), which can then be separated. The universal quantifier can then be 
inserted separately on each of those two wffs using universal generalization. The 
conclusion (4x)P(x) ` (4x)Q(x) will follow. A proof sequence is
	1.	(4x)[P(x) ` Q(x)]	
hyp
	2.	P(x) ` Q(x)	
1, ui
	3.	P(x)	
2, sim
	4.	Q(x)	
2, sim
	5.	(4x)P(x)	
3, ug
	6.	(4x)Q(x)	
4, ug
	7.	(4x)P(x) ` (4x)Q(x)	
5, 6, con
Neither restriction on universal generalization has been violated because x is not 
free in the hypothesis and existential instantiation has not been used.
Practice 24	 Using predicate logic, prove the following argument. (Hint: The deduction  
method still applies.)
(4y)[P(x) S Q(x, y)] S [P(x) S (4y)Q(x, y)]

64	
Formal Logic
As an extension to the deduction method, we can insert a “temporary” 
­hypothesis into a proof. If some wff T is introduced into a proof sequence as a 
temporary hypothesis, and eventually a wff W is deduced from T and other hy-
potheses, then the wff T S W has been deduced from the other hypotheses and 
can be inserted in the proof sequence.
	
EXAMPLE 31	
The argument
[P(x) S (4y)Q(x, y)] S (4y)[P(x) S Q(x, y)]
is valid. In the following proof sequence, P(x) is introduced at step 2 as a tempo-
rary hypothesis, which allows us to deduce Q(x, y) at step 4. The indented steps 
show that these wffs depend on the temporary hypothesis. At step 5, the temporary 
hypothesis is “discharged,” as the dependency of Q(x, y) on the temporary hy-
pothesis is explicitly acknowledged as an implication. Of course, the entire wff at 
step 5, P(x) S Q(x, y), still depends on the hypothesis of step 1. At step 6, neither 
restriction on universal generalization is violated because y is not a free variable 
in step 1 (the only hypothesis at this point) and existential instantiation is not used 
in the proof.
	1.	P(x) S (4y)Q(x, y)	
hyp
	2.	P(x)	
temporary hyp
	3.  (4y)Q(x, y)	
1, 2, mp
	4.  Q(x, y)	
3, ui
	5.	P(x) S Q(x, y)	
temp. hyp discharged
	6.	(4y)[P(x) S Q(x, y)]	 5, ug
Notice how the temporary hypothesis gives us enough ammunition to make some-
thing happen. Without this technique, it would be difficult to know what to do after 
step 1.
The technique of introducing a temporary hypothesis is seldom needed. 
Again, think of this as an extension to the deduction method. If the desired con-
clusion is of the form P S Q, the deduction method says we can assume P as a 
­hypothesis and deduce Q as the conclusion. If the desired conclusion is of the form  
(4x)(P(x) S Q(x)) or (E x)(P(x) S Q(x)), then the deduction method does not apply, 
but P(x) can be used as a temporary hypothesis.
Practice 24 and Example 31 show that the wff
(4y)[P(x) S Q(x, y)] 4 [P(x) S (4y)Q(x, y)]
is valid. It says that the universal quantifier can “slide over” subwffs that do not 
contain the quantified variable; in this case, (4y) is passed over P(x). A similar 
result holds for the existential quantifier. We noted this feature in Example 22, and 
here is the formal justification. This is one reason why there may be two or more 
equivalent ways of expressing English language sentences as predicate wffs, as in 
Exercises 13 through 24 of Section 1.3. 

	
	
Section 1.4   Predicate Logic	
65
The proofs of Example 32 are rather difficult because they require con-
siderably more imagination than most and an unexpected use of a temporary 
Practice 25	 Prove the argument
(4x)[(B(x) ~ C(x)) S A(x)] S (4x)[B(x) S A(x)]
In Section 1.3 we observed that, based on our understanding of negation and 
the meaning of the quantifiers, [(E x)A(x)]′ is equivalent to (4x)[A(x)]′. We should 
be able to formally prove that
[(E x)A(x)]′ 4 (4x)[A(x)]′
is a valid wff. 
	
EXAMPLE 32	
Prove that 
[(E x)A(x)]′ 4 (4x)[A(x)]′
is valid. We must prove the implication in each direction.
	
a.	 [(E x)A(x)]′ 4 (4x)[A(x)]′
The hypothesis alone gives us little to work with, so we introduce a (somewhat 
surprising) temporary hypothesis. A proof sequence is
	1.	[(E x)A(x)]′	
hyp
	2.	A(x)	
temporary hyp
	3.	  (E x)A(x)	
2, eg
	4.	A(x) S (E x)A(x)	
temporary hyp discharged
	5.	[A(x)]′	
1, 4, mt
	6.	(4x)[A(x)]′	
5, ug
	
b.	 (4x)[A(x)]′ S [(E x)A(x)]′
This proof also requires a temporary hypothesis. It is even more surprising than 
case (a) because we assume the exact opposite of the conclusion we are trying to 
reach.
	1.	(4x)[A(x)]′	
hyp
	2.	(E x)A(x)	
temporary hyp
	3.	  A(a)	
2, ei
	4.	  [A(a)]′	
1, ui
	5.	  [(4x)[A(x)]′]′	
3, 4, inc
	6.	(E x)A(x) S [(4x)[A(x)]′]′	
temporary hyp discharged
	7.	[((4x)[A(x)]′)′]′	
1, dn
	8.	[(E x)A(x)]′	
6, 7, mt

66	
Formal Logic
hypothesis. As a result, however, we do have the following equivalence, to which 
we’ve given a name:
[(E x)A(x)]′ 4 (4x)[A(x)]′  (Negation—neg)
This equivalence might be useful in a proof sequence. As an extension of the 
equivalence rules, whenever P 4 Q is valid, Q can be substituted for P within an 
expression in a proof sequence.
	
EXAMPLE 34	
Is the wff 
(E x)P(x) ` (E x)Q(x) S (E x)[P(x) ` Q(x)]
a valid argument? Prove or disprove.
If something in a domain has property P and something has property Q, that 
does not mean that some one thing has both property P and Q. For example, in the 
domain of integers, if P(x) means “x is even” and Q(x) means “x is odd,” then the 
hypotheses are true, but the conclusion is false because there is no single integer 
that is both even and odd. One interpretation in which the wff is false is enough to 
disprove it.
	
EXAMPLE 33	
Is the wff
(4x)[P(x) ~ Q(x)] S (E x)P(x) ~ (4x)Q(x)
a valid argument? Prove or disprove.
Let’s first consider whether the wff seems valid. If so, we should try to find a 
proof sequence for it; if not, we should try to find an interpretation in which it is 
not true. This wff says that if every element of the domain has either property P 
or property Q, then at least one element must have property P or else all elements 
have property Q. This seems very reasonable, so we’ll try to find a proof.
First we’ll use an equivalence to rewrite the conclusion in a more useful form. 
Changing the ~ to an implication will allow use of the deduction method. Thus we 
want to prove
(4x)[P(x) ~ Q(x)] S [ [(E x)P(x)]′ S (4x)Q(x)]
A proof sequence is
1.	(4x)[P(x) ~ Q(x)]	
hyp
2.	[(E x)P(x)]′	
hyp
3.	(4x)[P(x)]′	
2, neg
4.	[P(x)]′	
3, ui
5.	P(x) ~ Q(x)	
1, ui
6.	Q(x)	
4, 5, ds
7.	(4x)Q(x)	
6, ug

	
	
Section 1.4   Predicate Logic	
67
Verbal Arguments
To prove the validity of a verbal argument, we proceed much as before. We cast 
the argument in symbolic form and show that the conclusion can be deduced from 
the hypotheses. If the argument involves predicate wffs, then the derivation rules 
of predicate logic are available.
It is useful, however, to see where a potential proof sequence goes wrong. We 
begin with the two hypotheses and then remove one of the existential quantifiers.
1.	(E x)P(x)	
hyp
2.	(E x)Q(x)	 hyp
3.	P(a)	
1, ei
Now here’s the problem. The next step would be to remove the existential quan-
tifier from the wff at step 2, but, according to the rules for ei, we have to name the 
object that has property Q by some different name, not a. So we could eventually 
get to a wff in the proof sequence that looks like
P(a) ` Q(b)
but this does us no good. Existential generalization could not be used to replace 
both constant symbols with a single variable. At best, we could arrive at
(E y)(E x)[P(x) ` Q( y)]
which is not what we want.
	
EXAMPLE 35	
Show that the following argument is valid: “Every laptop has an internal disk 
drive. Some laptops have a DVD drive. Therefore some laptops have both an in-
ternal disk drive and a DVD drive.” Using
L(x) is “x is a laptop.”
I(x) is “x has an internal disk drive.”
D(x) is “x has a DVD drive.”
the argument is
(4x)[L(x) S I(x)] ` (E x)[L(x) ` D(x)] S (E x)[L(x) ` I(x) ` D(x)]
Practice 26	 Is the wff a valid argument? Prove or disprove.
(E x)R(x) ` [(E x)[R(x) ` S(x)] ]′ S (E x)[S(x)]′

68	
Formal Logic
Note that if we attempt to symbolize this argument in propositional logic, we get 
A ` B S C, which is not a valid argument. Propositional logic is simply not ex-
pressive enough to capture the interrelationships among the parts of this argument 
that serve to make it valid.
A proof sequence is
	1.	 (4x)[L(x) S I(x)]	
hyp
	2.	 (E x)[L(x) ` D(x)]	
hyp
	3.	 L(a) ` D(a)	
2, ei
	4.	 L(a) S I(a)	
1, ui
	5.	 L(a)	
3, sim
	6.	 I(a)	
4, 5, mp
	7.	 L(a) ` D(a) ` I(a)	
3, 6, con
	8.	 L(a) ` I(a) ` D(a)	
7, comm
	9.	 (E x)[L(x) ` I(x) ` D(x)]	
8, eg
Once again, it is the form of the argument that matters, not the content.
Practice 27	 Show that the following argument is valid: “All rock music is loud music. Some rock music 
exists, therefore some loud music exists.” Use predicates R(x) and L(x).
Conclusion
We’ve now finished our study of formal logic. What has been accomplished? 
The goal of formal logic, often called symbolic logic, is to make arguments as 
meaningless as possible! The symbolic notation of propositional and predicate 
logic allows us to symbolize arguments. An argument cast in symbolic notation 
removes any possibility that we will be swayed by our opinions or our external 
knowledge about the topic of the argument, and we can concentrate solely on its 
structure to determine its logical validity. Furthermore, the derivation rules allow 
the proof of an argument’s validity to be produced by symbol manipulation. A 
proof requires no external knowledge, only a careful adherence to the forms and 
restrictions of the rules. In theory, then, producing a proof sequence should be 
almost mechanical. Again, one objective of practice with this mechanical process 
of applying rules is that it will ultimately transform into a habit of logical thinking 
in everyday life.
Nonetheless, you may still feel that it is difficult to produce a proof sequence. 
Practice does make the process easier, because after a while, you become familiar 
with the various forms an argument might take and you recognize which rules 
you should try to apply. At any rate, you should at least find it easy at this point to 
check whether a proposed proof sequence is logically correct.
Philosophers through the ages believed logical thinking to be one of the high-
est achievements of human existence. One additional example, however, will 
show how even the most careful application of logic can be frustrated.

	
	
Section 1.4   Predicate Logic	
69
In addition to logical thinking in its pure sense, the notions of formal rules of 
inference have two very direct applications to computer science. An entire system 
of programming, and some programming languages, are based on applying rules 
of inference. We will see such a language in Section 1.5. Similarly, rules of infer-
ence can be applied to formally prove program correctness, leading to increased 
confidence that code is error-free. We’ll look at some of the inference rules for 
program correctness in Section 1.6.
	
EXAMPLE 36	
The hunting grounds of a medieval king were forbidden to commoners, and any-
one caught poaching the royal deer was subject to death. The hapless poacher was, 
however, granted a means to choose the manner of death. He (or she) was allowed 
to make a final statement. If the statement were judged to be true, death would be 
by beheading with a sword; if false, death would come by arrow shot from the 
bow of the best royal marksman. One day a particularly clever poacher was ap-
prehended and allowed the usual final statement. The poacher said, “I will be shot 
to death by an arrow.”
The king’s court faced a conundrum. If the poacher were shot to death by an 
arrow, then the statement he made would prove to be true, in which case he should 
have been beheaded. But if he were beheaded, then the statement he made would 
be false, in which case he should have been shot by an arrow. Unable to decide the 
manner of death, the court appointed the clever poacher to the post of king’s press 
secretary, where he served happily for many years.
This sort of paradox—a riddle with no solution—has to be carefully constructed, 
and we will not spend any more time reflecting on the potential shortcomings of 
classical logic systems that it may reveal.
S e c t i o n  1 . 4 	
Review
Techniques
•	 Apply derivation rules for predicate logic.
•	 	Use predicate logic to prove the validity of a ver-
bal argument.
Main Idea
•	 The predicate logic system is correct and com-
plete; valid arguments and only valid arguments 
are provable.
W
W
Exercises 1.4
For Exercises 1–6, decide what conclusion, if any, can be reached from the given hypotheses and justify your 
answer.
	 1.	 All flowers are plants. Pansies are flowers.
	 2.	 All flowers are plants. Pansies are plants.
	 3.	 All flowers are red or purple. Pansies are flowers. Pansies are not purple.
	 4.	 Some flowers are purple. All purple flowers are small.
	
5	 Some flowers are red. Some flowers are purple. Pansies are flowers.
	 6.	 Some flowers are pink and have thorns. All thorny flowers smell bad. Every flower that smells bad is a 
weed.

70	
Formal Logic
	 7.	 Justify each step in the following proof sequence of
(E x)[P(x) S Q(x)] S [(4x)P(x) S (E x)Q(x)]
	
1.	(E x)[P(x) S Q(x)] 
	
2.	P(a) S Q(a)
	
3.	(4x)P(x)
	
4.	P(a)
	
5.	Q(a)
	
6.	(E x)Q(x)
	 8.	 Justify each step in the following proof sequence of
(E x)P(x) ` (4x)(P(x) S Q(x)) S (E x)Q(x)
	
1.	(E x)P(x) 
	
2.	(4x)(P(x) S Q(x))
	
3.	P(a) 
	
4.	P(a) S Q(a)
	
5.	Q(a)
	
6.	(E x)Q(x)
	 9.	 Consider the wff
(4x)[(E y)P(x, y) ` (E y)Q(x, y)] S (4x)(E y)[P(x, y) ` Q(x, y)]
	
	 a. Find an interpretation to prove that this wff is not valid.
	
	 b. Find the flaw in the following “proof” of this wff.
	
	
1.	(4x)[(E y)P(x, y) ` (E y)Q(x, y)]	
hyp
	
	
2.	(4x)[P(x, a) ` Q(x, a)]	
1, ei
	
	
3.	(4x)(E y)[P(x, y) ` Q(x, y)]	
2, eg
	 10.	Consider the wff
(4y)(E x)Q(x, y) S (E x)(4y)Q(x, y)
	
	 a. Find an interpretation to prove that this wff is not valid.
	
	 b. Find the flaw in the following “proof” of this wff.
	
	
1.	(4y)(E x)Q(x, y)	 hyp
	
	
2.	(E x)Q(x, y)	
1, ui
	
	
3.	Q(a, y)	
2, ei
	
	
4.	(4y)Q(a, y)	
3, ug
	
	
5.	(E x)(4y)Q(x, y)	 4, eg
In Exercises 11–16, prove that each wff is a valid argument.
	 11.	(4x)P(x) S (4x)[P(x) ~ Q(x)]
	 12.	(4x)P(x) ` (E x)Q(x) S (E x)[P(x) ` Q(x)] 
	 13.	(E x)(E y)P(x, y) S (E y)(E x)P(x, y)
	 14.	(4x)(4y)Q(x, y) S (4y)(4x)Q(x, y)

	
	
Section 1.4   Predicate Logic	
71
	 15.	(4x)P(x) ` (E x)[P(x)]′ S (E x)Q(x)
	 16.	(4x)[S(x) S (E y)(P(x,y) ` T( y))] ` (E x)(C(x) ` S(x)) S (E x)(E y)(C(x) ` T( y) ` P(x, y))
In Exercises 17–30, either prove that the wff is a valid argument or give an interpretation in which it is false.
	 17.	(E x)[A(x) ` B(x)] S (E x)A(x) ` (E x)B(x)
	 18.	(E x)[R(x) ~ S(x)] S (E x)R(x) ~ (E x)S(x)
	 19.	(E x)P(x) ` (E x)(E y)Q(x, y) S (E x)(E y)[P(x) ` Q(x, y)]
	 20.	(4x)[P(x) S Q(x)] S [(4x)P(x) S (4x)Q(x)]
	 21.	(4x)(P(x))′ S (4x)(P(x) S Q(x))
	 22.	[(4x)P(x) S (4x)Q(x)] S (4x)[P(x) S Q(x)]
	 23.	(E x)(4y)Q(x, y) S (4y)(E x)Q(x, y)
	 24.	(4x)P(x) ~ (E x)Q(x) S (4x)[P(x) ~ Q(x)]
	 25.	(4x)[A(x) S B(x)] S [(E x)A(x) S (E x)B(x)]
	 26.	(4y)[Q(x, y) S P(x)] S [(E y)Q(x, y) S P(x)]
	 27.	[P(x) S (E y)Q(x, y)] S (E y)[P(x) S Q(x, y)]
	 28.	(4x)(P(x) ~ Q(x)) ` (E x)Q(x) S (E x)P(x)
	 29.	(E x)[P(x) ` Q(x)] ` (4y)[Q( y) S R( y)] S (E x)[P(x) ` R(x)]
	 30.	(4x)(4y)[(P(x) ` S(x, y)) S Q( y)] ` (E x)B(x) ` (4x)(B(x) S P(x)) ` (4x)(E y)S(x, y) S (E x)Q(x)
	 31.	The Greek philosopher Aristotle (384–322 b.c.e.) studied under Plato and tutored Alexander the Great. His 
studies of logic influenced philosophers for hundreds of years. His four “perfect” syllogisms are identified 
by the names given them by medieval scholars. For each, formulate the argument in predicate logic nota-
tion and then provide a proof.
	
a.	 “Barbara”
All M are P
All S are M
Therefore all S are P
	
b.	“Celarent”
No M are P
All S are M
Therefore no S are P
	
c.	 “Darii”
All M are P
Some S are M
Therefore some S are P
	
d.	“Ferio”
No M are P
Some S are M
Therefore some S are not P
Using predicate logic, prove that each argument in Exercises 32–42 is valid. Use the predicate symbols 
shown.
	 32.	Some plants are flowers. All flowers smell sweet. Therefore, some plants smell sweet. P(x), F(x), S(x) 

72	
Formal Logic
	 33.	Every crocodile is bigger than every alligator. Sam is a crocodile. But there is a snake, and Sam isn’t 
­bigger than the snake. Therefore, something is not an alligator. C(x), A(x), B(x, y), s, S(x)
	 34.	There is an astronomer who is not nearsighted. Everyone who wears glasses is nearsighted. Furthermore, 
everyone either wears glasses or wears contact lenses. Therefore, some astronomer wears contact lenses. 
A(x), N(x), G(x), C(x)
	 35.	Every member of the board comes from industry or government. Everyone from government who has a 
law degree is in favor of the motion. John is not from industry, but he does have a law degree. Therefore, 
if John is a member of the board, he is in favor of the motion. M(x), I(x), G(x), L(x), F(x), j
	 36.	There is some movie star who is richer than everyone. Anyone who is richer than anyone else pays more 
taxes than anyone else does. Therefore, there is a movie star who pays more taxes than anyone. M(x), 
R(x, y), T(x, y)
	 37.	Everyone with red hair has freckles. Someone has red hair and big feet. Everybody who doesn’t 
have green eyes doesn’t have big feet. Therefore someone has green eyes and freckles. R(x), F(x), 
B(x), G(x) 
	 38.	Cats eat only animals. Something fuzzy exists. Everything that’s fuzzy is a cat. And everything eats some-
thing. So animals exist. C(x), E(x, y), A(x), F(x) 
	 39.	Every computer science student works harder than somebody, and everyone who works harder than any 
other person gets less sleep than that person. Maria is a computer science student. Therefore, Maria gets 
less sleep than someone else. C(x), W(x, y), S(x, y), m
	 40.	Every ambassador speaks only to diplomats, and some ambassador speaks to someone. Therefore, there is 
a diplomat. A(x), S(x, y), D(x)
	 41.	Some elephants are afraid of all mice. Some mice are small. Therefore there is an elephant that is afraid of 
something small. E(x), M(x), A(x, y), S(x)
	 42.	Every farmer owns a cow. No dentist owns a cow. Therefore no dentist is a farmer. F(x), C(x), O(x, y), D(x)
	 43.	Prove that
[(4x)A(x)]′ 4 (E x)[A(x)]′
	
	 is valid. (Hint: Instead of a proof sequence, use Example 32 and substitute equivalent expressions.)
	 44.	The equivalence of Exercise 43 says that if it is false that every element of the domain has property A, 
then some element of the domain fails to have property A, and vice versa. The element that fails to have 
property A is called a counterexample to the assertion that every element has property A. Thus a counter-
example to the assertion
(4x)(x is odd)
	
	 in the domain of integers is the number 10, an even integer. (Of course, there are lots of other counterex-
amples to this assertion.) Find counterexamples in the domain of integers to the following assertions. (An 
integer x > 1 is prime if the only factors of x are 1 and x.)
	
a.	 (4x)(x is negative)
	
b.	(4x)(x is the sum of even integers)
	
c.	 (4x)(x is prime S x is odd)
	
d.	(4x)(x prime S (−1)x = −1)
	
e.	 (4x)(x prime S 2x − 1 is prime)

	
	
Section 1.5   Logic Programming	
73
	
S e c t i o n  1 . 5 	 Logic Programming
The programming languages with which you are probably familiar, such as C++ 
or Java, are known as procedural languages. Much of the content of a program 
written in a procedural language consists of instructions to carry out the algo-
rithm the programmer believes will solve the problem at hand. The program-
mer, therefore, is telling the computer how to solve the problem in a step-by-step 
fashion.
Some programming languages, rather than being procedural, are declarative 
languages or descriptive languages. A declarative language is based on predi-
cate logic; such a language comes equipped with its own rules of inference. A 
program written in a declarative language consists only of ­statements—­actually 
predicate wffs—that are declared as hypotheses. Execution of a declarative pro-
gram allows the user to pose queries, asking for information about possible 
conclusions that can be derived from the hypotheses. After obtaining the user’s 
query, the language turns on its “inference engine” and applies its rules of in-
ference to the hypotheses to see which conclusions fit the user’s query. The 
program, remember, contains only the hypotheses, not any explicit instructions 
as to what steps to perform in what order. The inference engine of the language 
acts behind the scenes, so to speak, to construct a proof sequence. It is the me-
chanical nature of applying inference rules that makes this “automated theorem 
proving” possible.
Prolog
The programming language Prolog, which stands for PROgramming in LOGic, 
is a declarative programming language. The set of declarations that constitutes 
a Prolog program is also known as a Prolog database. Items in a Prolog data-
base take on one of two forms, known in Prolog as facts and rules. (Prolog rules, 
however, are just another kind of fact and should not be confused with a rule of 
inference.)
Prolog facts allow predicates to be defined by stating which items in some 
domain of interpretation satisfy the predicates. As an example, suppose we wish to 
create a Prolog program that describes food chains in a given ecological region. We 
might begin with a binary predicate eat. We then describe the predicate by giving 
the pairs of elements in the domain that make eat true. Thus we might have the facts
eat(bear, fish)
eat(bear, fox)
eat(deer, grass)
in our database. (The exact details of Prolog statements vary from one Prolog 
implementation to another, so in this section we are only giving the spirit of the 
language by using a Prolog-like pseudocode.) Here “bear,” “fish,” “fox,” “deer,” 
and “grass” are constants because they represent specific elements in the domain. 
Because the domain itself is never specified except by describing predicates, at 
this point we may take the domain to consist of “bear,” “fish,” “fox,” “deer,” and 

74	
Formal Logic
“grass.” It is up to the user to maintain a consistent understanding and use of the 
predicates in a Prolog program. Thus
eat(bear, fish)
can be used either to represent the fact that bears eat fish or the fact that fish eat 
bears!
We impose the convention that eat(X, Y ) means “X eats Y.” We could add 
descriptions of two unary predicates, animal and plant, to the database by adding 
the facts
animal(bear)
animal(fish)
animal(fox)
animal(deer)
plant(grass)
Armed with this Prolog program (database), we can pose some simple queries.
	
EXAMPLE 37	
The query
?animal(bear)
merely asks if the fact animal(bear) is in the database. Because this fact is in the 
database, Prolog would respond to the query by answering yes. (This is a one-step 
proof sequence—no rules of inference are required). Further dialogue with Prolog 
could include
?eat(deer, grass)
yes
?eat(bear, rabbit)
no
Queries may include variables, as shown in the next example.
	
EXAMPLE 38	
The query
?eat(bear, X)
produces
fish
fox
as a response. Prolog has answered the query by searching the database for all 
facts that match the pattern eat(bear, X ), where X is a variable. The answer “fish” 
is given first because the rules are searched in order from top to bottom.

	
	
Section 1.5   Logic Programming	
75
Queries may contain the logical connectives and, or, and not.
Practice 28	 Given the database
eat(bear, fish)
eat(bear, fox)
eat(deer, grass)
animal(bear)
animal(fish)
animal(fox)
animal(deer)
plant(grass)
what will be Prolog’s response to the query
?eat(X, Y ) and plant(Y )
The second type of item in a Prolog database is a Prolog rule. A rule is a de-
scription of a predicate by means of an implication (the implication arrow in the rule 
goes from right to left). For example, we might use a rule to define a predicate of prey:
prey(X ) <= eat(Y, X ) and animal(X )
This statement says that X is a prey if it is an animal that is eaten. If we add this 
rule to our database, then in response to the query
?prey(X )
we would get
fish
fox
Horn Clauses and Resolution
How do Prolog facts and rules relate to more formal predicate logic? We can de-
scribe the facts in our database as wffs:
E(b, fi)
E(b, fo)
E(d, g)
A(b)
A( fi)
A( fo)
A(d)
P(g)
and the rule by the wff
E( y, x) ` A(x) S Pr(x)

76	
Formal Logic
Universal quantifiers are not explicitly part of the rule as it appears in a Prolog 
program, but Prolog treats the rule as being universally quantified
(4y)(4x)[E( y, x) ` A(x) S Pr(x)]
and repeatedly uses universal instantiation to strip off the universal quantifiers 
and allow the variables to assume in turn each value of the domain.
Both facts and rules are examples of Horn clauses. A Horn clause is a wff 
composed of predicates or the negations of predicates (with either variables or 
constants as arguments) joined by disjunctions, where at most one predicate is 
unnegated. Thus the fact
E(d, g)
is an example of a Horn clause because it consists of a single unnegated predicate.
The wff
[E( y, x)]′ ~ [A(x)]′ ~ Pr(x)
is an example of a Horn clause because it consists of three predicates joined by 
disjunction where only Pr(x) is unnegated. By De Morgan’s law, it is equivalent to
[E( y, x) ` A(x)]′ ~ Pr(x)
which in turn is equivalent to
E( y, x) ` A(x) S Pr(x)
and therefore represents the rule in our Prolog program.
The single rule of inference used by Prolog is called resolution. Two Horn 
clauses in a Prolog database are resolved into a single new Horn clause if one 
contains an unnegated predicate that matches a negated predicate in the other 
clause. The new clause eliminates the matching term and is then available to use 
in answering the query. For example,
	
A(a)
[A(a)]′ ~ B(b)
resolves to B(b). This says that from
A(a), [A(a)]′ ~ B(b)
which is equivalent to
A(a), A(a) S B(b)
Prolog infers
B(b)
REMINDER 
Prolog’s resolution rule 
looks for a term and its 
negation to infer one Horn 
clause from two.

	
	
Section 1.5   Logic Programming	
77
which is just an application of modus ponens. Therefore Prolog’s rule of inference 
includes modus ponens as a special case.
In applying the resolution rule, variables are considered to “match” any 
constant symbol. (This is the repeated application of universal instantiation.) In 
any resulting new clause, the variables are replaced with their associated con-
stants in a consistent manner. Thus in response to the query ?prey(X ), Prolog 
searches the database for a rule with the desired predicate Pr(x) as the conse-
quent. It finds
[E( y, x)]′ ~ [A(x)]′ ~ Pr(x)
It then proceeds through the database looking for other clauses that can be re-
solved with this clause. The first such clause is the fact E(b, fi). These two clauses 
resolve into
[A( fi)]′ ~ Pr( fi)
(Note that the constant fi has replaced x everywhere.) Using this new clause, it 
can be resolved with the fact A( fi) to conclude Pr( fi). Having reached all conclu-
sions possible from resolution with the fact E(b, fi), Prolog backtracks to search 
for another clause to resolve with the rule clause; this time around it would find 
E(b, fo).
As a more complex example of resolution, suppose we add the rule
hunted(X ) <= prey(X )
to the database. This rule in symbolic form is
[Pr(x)] S H(x)
or, as a Horn clause,
[Pr(x)]′ ~ H(x)
It resolves with the rule defining prey
[E( y, x)]′ ~ [A(x)]′ ~ Pr(x)
to give the new rule
[E( y, x)]′ ~ [A(x)]′ ~ H(x)
The query
?hunted(X )
will use this new rule to conclude
fish
fox

78	
Formal Logic
	
EXAMPLE 39	
Suppose that a Prolog database contains the following entries:
eat(bear, fish)
eat(fish, littlefish)
eat(littlefish, algae)
eat(raccoon, fish)
eat(bear, raccoon)
eat(bear, fox)
eat(fox, rabbit)
eat(rabbit, grass)
eat(bear, deer)
eat(deer, grass)
eat(wildcat, deer)
animal(bear)
animal(fish)
animal(littlefish)
animal(raccoon)
animal(fox)
animal(rabbit)
animal(deer)
animal(wildcat)
plant(grass)
plant(algae)
prey(X ) <= eat(Y, X ) and animal(X )
Then the following dialog with Prolog could take place:
?animal(rabbit)
yes
?eat(wildcat, grass)
no
?eat(X, fish)
bear
raccoon
?eat(X, Y ) and plant(Y )
littlefish	
algae
rabbit	
grass
deer		
grass
?prey(X )
fish
littlefish
fish

	
	
Section 1.5   Logic Programming	
79
raccoon
fox
rabbit
deer
deer
Note that fish is listed twice as satisfying the last query because fish are eaten by 
bear (fact 1) and by raccoon (fact 3). Similarly, deer are eaten by both bear and 
wildcat.
Practice 29	
a.	 Formulate a Prolog rule that defines the predicate predator.
b.	Adding this rule to the database of Example 39, what would be the response to the query
?predator(X )
Recursion
Prolog rules are implications. Their antecedents (remember that these will appear 
on the right side of the rules) may depend on facts, as in
prey(X ) <= eat(Y, X) and animal(X )
or on other rules, as in
hunted(X ) <= prey(X )
The antecedent of a rule may also depend on that rule itself, in which case the rule 
is defined in terms of itself. A definition in which the item being defined is itself 
part of the definition is called a recursive definition.
As an example, suppose we wish to use the ecology database of Example 39 to 
study food chains. We can then define a binary relation infoodchain(X, Y ), mean-
ing “Y is in X’s food chain.” This, in turn, means one of two things:
	
1.	 X eats Y directly
or
	
2.	 X eats something that eats something that eats something … that eats Y.
Case 2 can be rewritten as follows:
	
2′.	 X eats Z and Y is in Z’s food chain.
Case 1 is simple to test from our existing facts, but without (2′), infoodchain 
means nothing different from eat. On the other hand, (2′) without (1) sends us 

80	
Formal Logic
down an infinite path of something eating something eating something and so on, 
with nothing telling us when to stop. Recursive definitions always need a stopping 
point that consists of specific information.
The Prolog rule for infoodchain incorporates (1) and (2′):
infoodchain(X, Y ) <= eat(X, Y )
infoodchain(X, Y ) <= eat(X, Z ) and infoodchain(Z, Y )
It is a recursive rule because it defines the predicate infoodchain in terms of 
infoodchain.
A recursive rule is necessary when the predicate being described is passed on 
from one object to the next. The predicate infoodchain has this property:
infoodchain(X, Y ) ` infoodchain(Y, Z ) S infoodchain(X, Z )
 	
EXAMPLE 40	
After the infoodchain rule is added to the database of Example 39, the following 
query is made:
?infoodchain(bear, Y )
The response follows (numbers are added for reference purposes):
	
1.	 fish	
  7.	fish
	
2.	 raccoon	
  8.	littlefish
	
3.	 fox	
  9.	algae
	
4.	 deer	
10.	rabbit
	
5.	 littlefish	
11.	 grass
	
6.	 algae	
12.	grass
Prolog applies the simple case of
infoodchain(bear, Y ) <= eat(bear, Y )
first, obtaining answers 1 through 4 directly from the facts eat(bear, fish), eat(bear, 
raccoon), and so on. Moving to the recursive case,
infoodchain(bear, Y ) <= eat(bear, Z) and infoodchain(Z, Y )
a match of eat(bear, Z) occurs with Z equal to “fish.” Prolog then looks for all 
solutions to the relation infoodchain(fish, Y ). Using first the simple case of infood-
chain, a match occurs with the fact eat(fish, littlefish). This results in response 5, 
littlefish. There are no other facts of the form eat(fish, Y ), so the next thing to try 
is the recursive case of infoodchain(fish, Y ):
infoodchain(fish, Y ) <= eat(fish, Z) and infoodchain(Z, Y )
A match of eat(fish, Z) occurs with Z equal to “littlefish.” Prolog then looks for 
all solutions to the relation infoodchain(littlefish, Y ). Using the simple case of 

	
	
Section 1.5   Logic Programming	
81
­infoodchain, a match occurs with the fact eat(littlefish, algae). This results in re-
sponse 6, algae. There are no other facts of the form eat(littlefish, Y ), so the next 
thing to try is the recursive case of infoodchain(littlefish, Y ):
infoodchain(littlefish, Y ) <= eat(littlefish, Z ) and infoodchain(Z, Y )
A match of eat(littlefish, Z ) occurs with Z equal to “algae.” Prolog then looks for 
all solutions to the relation infoodchain(algae, Y ). A search of the entire database 
reveals no facts of the form eat(algae, Y ) (or eat(algae, Z )), so neither the simple 
case nor the recursive case of infoodchain(algae, Y ) can be pursued further.
bear
bear
bear
bear
bear
fish
raccoon
fox
deer
fish
fish
 littlefish
 littlefish      algae
Figure 1.2 shows the situation at this point. Prolog has reached a dead-end with 
infoodchain(algae, Y ) and will backtrack up the path. Because there are no other 
facts of the form eat(littlefish, Z ), the search for solutions to infoodchain(littlefish, 
Y ) terminates. Then, because there are no other facts of the form eat(fish, Z), the 
search for solutions to infoodchain(fish, Y ) terminates. Backing up still further, 
there is another match of eat(bear, Z ) with Z equal to “raccoon” that will generate 
another search path.
Figure 1.2
In Example 40, once Prolog began to investigate infoodchain(fish, Y ), all que-
ry answers that could be obtained from exploring this path (responses 5 and 6) 
were generated before other answers (responses 7–12). Exploring as far as possible 
down a given path and then backtracking up that path before exploring other paths 
is called a depth-first search strategy.
Practice 30	 Trace the execution of the Prolog program of Example 40 and explain  why responses 7–12 
occur.
Expert Systems
Many interesting applications programs have been developed, in Prolog and sim-
ilar logic programming languages, that gather a database of facts and rules about 
some domain and then use the database to draw conclusions. Such programs are 
known as expert systems, knowledge-based systems, or rule-based systems. 

82	
Formal Logic
The database in an expert system attempts to capture the knowledge (“elicit 
the expertise”) of a human expert in a particular field, including both the facts 
known to the expert and the expert’s reasoning path in reaching conclusions 
from those facts. The completed expert system not only simulates the human 
expert’s actions but can be questioned to reveal why it made certain choices and 
not others.
Expert systems have been built that simulate a medical specialist’s diagnosis 
from a patient’s symptoms, a factory manager’s decisions regarding valve control 
in a chemical plant based on sensor readings, the decisions of a fashion buyer for a 
retail store based on market research, the choices made by a consultant specifying 
a computer system configuration based on customer needs, and many more. The 
challenging part of building an expert system lies in extracting all pertinent facts 
and rules from the human expert.
S e c t i o n  1 . 5 	
Review
Techniques
•	 Formulate Prolog-like facts and rules.
•	 Formulate Prolog-like queries.
•	 Determine the answer(s) to a query using a Prolog 
database.
Main Idea
•	 A declarative language incorporates predicate wffs 
and rules of inference to draw conclusions from 
hypotheses. The elements of such a language are 
based on predicate logic rather than instructions 
that carry out an algorithm.
W
W
Exercises 1.5
Exercises 1–8 refer to the database of Example 39; find the results of the query in each case.
	 1.	 ?animal(wildcat)
	 2.	 ?plant(raccoon)
	 3.	 ?eat(bear, littlefish)
	 4.	 ?eat(fox, rabbit)
	 5.	 ?eat(raccoon, X )
	 6.	 ?eat(X, grass)
	 7.	 ?eat(bear, X ) and eat(X, rabbit)
	 8.	 ?prey(X ) and not eat(fox, X )
	 9.	 Formulate a Prolog rule that defines “herbivore” to add to the database of Example 39.
	 10.	If the rule of Exercise 9 is included in the database of Example 39, what is the response to the query
?herbivore(X )
	 11.	After infoodchain is added to the database of Example 39, add the facts eat(wolf, fox) and eat(wolf, deer). 
What is the result of the query
?eat(wolf, X ) and not eat(X, grass)
	 12.	After the modifications in Exercise 11, what is the result of the query
?infoodchain(wolf, X )

	
	
Section 1.5   Logic Programming	
83
	 13.	A Prolog database contains the following, where boss(X, Y ) means “X is Y’s boss” and supervisor(X, Y ) 
means “X is Y’s supervisor”:
	
	 boss(mike, joan)
	
	 boss( judith, mike)
	
	 boss(anita, judith)
	
	 boss( judith, kim)
	
	 boss(kim, enrique)
	
	 boss(anita, sam)
	
	 boss(enrique, jefferson)
	
	 boss(mike, hamal)
	
	 supervisor(X, Y ) 6= boss(X, Y )
	
	 supervisor(X, Y ) 6= boss(X, Z ) and supervisor (Z, Y )
	
Find the results of the following queries:
	
a.	 ?boss(X, sam)
	
b.	?boss( judith, X )
	
c.	 ?supervisor(anita, X )
	 14.	Using the Prolog database from Exercise 13, what are the results of the following queries?
	
a.	 ?boss(hamal, X )
	
b.	?supervisor(X, kim) 
	 15.	Suppose a Prolog database exists that gives information about authors and the books they have written. 
Books are classified as fiction, biography, or reference.
	
a.	 Write a query to ask whether Mark Twain wrote Hound of the Baskervilles.
	
b.	Write a query to find all books written by William Faulkner.
	
c.	 Formulate a rule to define nonfiction authors.
	
d.	Write a query to find all nonfiction authors.
	 16.	Suppose a Prolog database exists that gives information about states and capital cities. Some cities are big, 
others small. Some states are eastern, others are western.
	
a.	 Write a query to find all the small capital cities.
	
b.	Write a query to find all the states with small capital cities.
	
c.	 Write a query to find all the eastern states with big capital cities.
	
d.	Formulate a rule to define cosmopolitan cities as big capitals of western states.
	
e.	 Write a query to find all the cosmopolitan cities.
	 17.	Suppose a Prolog database exists that gives information about a family. Predicates of male, female, and 
parentof are included.
	
a.	 Formulate a rule to define fatherof.
	
b.	Formulate a rule to define daughterof.
	
c.	 Formulate a recursive rule to define ancestorof.
	 18.	Suppose a Prolog database exists that gives information about the parts in an automobile engine. ­Predicates 
of big, small, and partof are included.
	
a.	 Write a query to find all small items that are part of other items.
	
b.	Write a query to find all big items that have small subitems.
	
c.	 Formulate a recursive rule to define componentof.

84	
Formal Logic
	 19.	Suppose a Prolog database exists that gives information about the ingredients in the menu items of a res-
taurant. Predicates of dry, liquid, perishable, and ingredientof are included.
	
a.	 Write a query to find all the dry ingredients of other ingredients.
	
b.	Write a query to find all perishable ingredients that contain liquid subingredients.
	
c.	 Formulate a recursive rule to define foundin.
	 20.	Suppose a Prolog database exists that gives information about flights for AA (Always Airborne) airline. 
Predicates of city and flight are included. Here flight(X, Y ) means that AA has a direct (nonstop) flight 
from city X to city Y.
	
a.	 Write a query to find all cities you can get to on a direct flight from Indianapolis.
	
b.	Write a query to find all cities that have direct flights to San Francisco.
	
c.	 Formulate a recursive rule to define route where route(X, Y ) means that you can get from city X to city 
Y using AA but it might not be a direct flight.
Exercises 21–22 refer to a “Toy Prolog interpreter” that can be found online at http://www.csse.monash.edu.
au/~lloyd/tildeLogic/Prolog.toy. The syntax used in this section matches that of this online version except that 
in the online version each statement and query must end with a period. Here is a shortened version of Example 
39 as entered into the code window, followed by the response to the query:
	
	 eat(bear, fish).
	
	 eat(fish, littlefish).
	
	 eat(littlefish, algae).
	
	 eat(raccoon, fish).
	
	 eat(bear, raccoon).
	
	 eat(bear, fox).
	
	 animal(bear).
	
	 animal(fish).
	
	 animal(littlefish).
	
	 animal(raccoon).
	
	 animal(fox).
	
	 prey(X) <= eat(Y, X) and animal(X).
	
	 ?prey(X).
	
	 --- running --- 
	
	 prey(fish) yes
	
	 prey(littlefish) yes
	
	 prey(fish) yes
	
	 prey(raccoon) yes
	
	 prey(fox) yes
In addition, you can look at and run the online sample program to be sure you understand the syntax rules.
	 21.	Using the online Toy Prolog program, enter the Prolog database of Exercise 13. Run the queries from 
Exercises 13 and 14 and compare the results with your previous answers.
	 22.	Using the online Toy Prolog program, create a database for Exercise 20. Run the queries from Exercise 
20. Also run a query using the route predicate.
	
S e c t i o n  1 . 6 	 Proof of Correctness
As our society becomes ever more dependent on computers, it is more and 
more  important that the programs computers run are reliable and error-free. 
Program verification attempts to ensure that a computer program is correct. 

	
	
Section 1.6   Proof of Correctness	
85
“Correctness” has a narrower definition here than in everyday usage. A pro-
gram is correct if it behaves in accordance with its specifications. However, this 
does not necessarily mean that the program solves the problem that it was in-
tended to solve; the ­program’s specifications may be at odds with or not address 
all aspects of a client’s requirements. Program validation, which we won’t 
discuss further, attempts to ensure that the program indeed meets the client’s 
original requirements. In a large program development project “program V & 
V” or “software quality assurance” is considered so important that a group of 
people separate from the programmers is often designated to carry out the as-
sociated tasks.
Program verification may be approached both through program testing and 
through proof of correctness. Program testing seeks to show that particular 
input values produce acceptable output values. Program testing is a major part 
of any software development effort, but it is well-known folklore that “testing 
can prove the presence of errors but never their absence.” If a test run under a 
certain set of conditions with a certain set of input data reveals a “bug” in the 
code, then the bug can be corrected. But except for rather simple programs, 
multiple tests that reveal no bugs do not guarantee that the code is bug-free, 
that there is not some error lurking in the code waiting to strike under the right 
circumstances.
As a complement to testing, computer scientists have developed a more math-
ematical approach to “prove” that a program is correct. Proof of correctness uses 
the techniques of a formal logic system to prove that if the input variables satisfy 
certain specified predicates or properties, the output variables produced by ex-
ecuting the program satisfy other specified properties.
To distinguish between proof of correctness and program testing, consider 
a program to compute the length c of the hypotenuse of a right triangle, given 
positive values a and b for the lengths of the legs. Proving the program correct 
would establish that whenever a and b satisfy the predicates a > 0 and b > 0, 
then after the program is executed, the predicate a2 + b2 = c2 is satisfied. Test-
ing such a program would require taking various specific values for a and b, 
computing the resulting c, and checking that a2 + b2 equals c2 in each case. 
However, only representative values for a and b can be tested, not all possible 
values.
Again, testing and proof of correctness are complementary aspects of pro-
gram verification. All programs undergo program testing; they may or may not 
undergo proof of correctness as well. Proof of correctness is labor-intensive, hence 
expensive; it generally is applied only to small and critical sections of code rather 
than to the entire program.
Assertions
Describing proof of correctness more formally, let us denote by X an arbitrary 
collection of input values to some program or program segment P. The actions 
of P transform X into a corresponding group of output values Y; the notation 
Y = P(X ) suggests that the Y values depend on the X values through the actions 
of program P.
A predicate Q(X ) describes conditions that the input values are supposed to 
satisfy. For example, if a program is supposed to find the square root of a posi-
tive number, then X consists of one input value, x, and Q(x) might be “x > 0.”  

86	
Formal Logic
A predicate R describes conditions that the output values are supposed to satisfy. 
These conditions will often involve the input values as well, so R has the form 
R(X, Y ) or R[X, P(X )]. In our square root case, if y is the single output value, then 
y is supposed to be the square root of x, so R(x, y) would be “y2 = x.” Program P 
is correct if the implication
	
(4X )(Q(X ) S R[X, P(X )])
(1)
is valid. In other words, whenever Q is true about the input values, R should be 
true about the input and output values. For the square root case, (1) is
(4x)(x > 0 S [P(x)]2 = x )
The implication (1) is standard predicate wff notation, but the traditional program 
correctness notation for (1) is
	
{Q}P{R}
(2)
{Q}P{R} is called a Hoare triple, named for the British computer scientist 
­Anthony Hoare. Condition Q is called the precondition for program P, and condi-
tion R is the postcondition. In the Hoare notation, the universal quantifier does 
not explicitly appear; it is understood.
Rather than simply having an initial predicate and a final predicate, a program 
or program segment is broken down into individual statements si, with predicates 
inserted between statements as well as at the beginning and end. These predicates 
are also called assertions because they assert what is supposed to be true about 
the program variables at that point in the program. Thus we have
	
{Q}
	
s0
	
{R1}
	
s1
	
{R2}
	
(
	
sn−1
	
{R}
where Q, R1, R2, … , Rn = R are assertions. The intermediate assertions are often 
obtained by working backward from the output assertion R.
P is provably correct if each of the following implications holds:
	
{Q}s0{Rl}
	
{Rl}sl{R2}
	
{R2}s2{R3}
	
(
	
{Rn−1}sn−1 {R}
A proof of correctness for P consists of producing this sequence of valid 
implications, that is, producing a proof sequence of predicate wffs. Some new 
rules of inference can be used, based on the nature of the program statement si.

	
	
Section 1.6   Proof of Correctness	
87
Assignment Rule
Suppose that statement si is an assignment statement of the form x = e, that is, the 
variable x takes on the value of e, where e is some expression. The Hoare triple to 
prove correctness of this one statement has the form
{Ri} x = e {Ri+l}
For this triple to be valid, the assertions Ri and Ri+1 must be related in a particular way.
	
Example 41 	
Consider the following assignment statement together with the given precondition 
and postcondition:
{x – 1 > 0}
 x = x – 1
{x > 0}
For every x, if x – 1 > 0 before the statement is executed (note that this says that 
x > 1), then after the value of x is reduced by 1, it will be the case that x > 0. 
Therefore,
{x – 1 > 0} x = x – 1 {x > 0}
is valid.
In Example 41, we just reasoned our way through the validity of the wff represented 
by the Hoare triple. The point of predicate logic is to allow us to determine validity 
in a more mechanical fashion by the application of rules of inference. (After all, 
we don’t want to just “reason our way through” the entire program to convince 
ourselves of its correctness; the programmer already did that when the program 
was written!)
The appropriate rule of inference for assignment statements is the assignment 
rule, given in Table 1.18. It says that if the precondition and postcondition are 
appropriately related, the Hoare triple can be inserted at any time in a proof sequence 
without having to be inferred from something earlier in the proof sequence. This 
makes the Hoare triple for an assignment statement akin to a hypothesis in our 
previous proofs. And what is the relationship? In the postcondition, locate all 
instances of the variable to which an assignment is being made in the assignment 
statement right above the postcondition. For each of those instances, substitute the 
expression being assigned. The result will be the precondition.
Table 1.18
From
Can Derive
Name of Rule
Restrictions on Use
{Ri}si{Ri+l}
assignment
1.  si has the form x = e.
2.  Ri is Ri+1 with e substituted  
everywhere for x.

88	
Formal Logic
	
Example 42 	
For the case of Example 41,
{x − 1 > 0}
 x = x − 1
{x > 0}
the triple
{x − 1 > 0} x = x − 1 {x > 0}
is valid by the assignment rule. The postcondition is
x > 0
Substituting x − 1 for x throughout the postcondition results in
x − 1 > 0  or   x > 1
which is the precondition. Here we didn’t have to think at all; we just checked that 
the assignment rule had been followed.
Certainly Example 41 seems easier than Example 42, and for such a trivial 
case you may be tempted to skip use of the assignment inference rule and just 
talk your way through the code. Resist this temptation. For one thing, real-world 
usage isn’t this trivial. But more to the point, just as in our previous formal logic 
systems, you want to rely on the rules of inference instead of on some ­possibly 
flawed thought process.
Practice 31	 According to the assignment rule, what should be the precondition in the following  
program segment?
{precondition}
x = x − 2
{x = y}
Because the assignment rule tells us what a precondition should look like 
based on what a postcondition looks like, a proof of correctness often begins with 
the final desired postcondition and works its way back up through what the earlier 
assertions should look like according to the assignment rule. Once it has been 
determined what the topmost assertion must be, a check is done to see that this 
assertion is really true.
REMINDER
To use the assignment 
rule, work from the bottom 
to the top.
	
Example 43 	
Verify the correctness of the following program segment to exchange the values of 
x and y:
temp = x
x = y
y = temp

	
	
Section 1.6   Proof of Correctness	
89
At the beginning of this program segment, x and y have certain values. Thus 
we may express the actual precondition as x = a and y = b. The desired postcondi-
tion is then x = b and y = a. Using the assignment rule, we can work backward 
from the postcondition to find the earlier assertions (read the following from the 
bottom to the top).
{y = b, x = a}
temp = x
{y = b, temp = a}
x = y
{x = b, temp = a}
y = temp
{x = b, y = a}
The first assertion agrees with the precondition; the assignment rule, applied 
repeatedly, assures us that the program segment is correct.
Practice 32	 Verify the correctness of the following program segment with the precondition and post-
condition shown:
hx = 3}
y = 4
z = x + y
hz = 7j
Sometimes the necessary precondition is trivially true, as shown in the next 
example.
	
Example 44 	
Verify the correctness of the following program segment to compute y = x − 4.
y = x
y = y − 4
Here the desired postcondition is y = x − 4. Using the assignment rule to work 
backward from the postcondition, we get (again, read bottom to top)
{x − 4 = x − 4}
y = x
{y − 4 = x − 4}
y = y − 4
{y = x − 4}
The precondition is always true; therefore, by the assignment rule, each successive 
assertion, including the postcondition, is true.

90	
Formal Logic
Conditional Rule
A conditional statement is a program statement of the form
if condition B then
P1
else
P2
end if
When this statement is executed, a condition B that is either true or false is 
­evaluated. If B is true, program segment P1 is executed, but if B is false, program 
segment P2 is executed.
A conditional rule of inference, shown in Table 1.19, determines when a 
Hoare triple
{Q}si{R}
can be inserted in a proof sequence if si is a conditional statement. The Hoare 
triple is inferred from two other Hoare triples. One of these says that if Q is true 
and B is true and program segment P1 is executed, then R holds; the other says that 
if Q is true and B is false and program segment P2 is executed, then R holds. This 
simply says that each branch of the conditional statement must be proved correct.
Table 1.19
From
Can Derive
Name of Rule
Restrictions on Use
{Q ` B} P1 {R}, 
{Q ` B9} P2 {R}
{Q}si{R }
conditional
si has the form 
if condition B then 
P1
else
P2
end if
	
Example 45 	
Verify the correctness of the following program segment with the precondition and 
postcondition shown.
{n = 5}
if n >= 10 then
y = 100
else
y = n + 1
end if
{y = 6}
Here the precondition is n = 5, and the condition B to be evaluated is n >= 10. In 
order to apply the conditional rule, we must first prove that
{Q ` B} P1 {R}

	
	
Section 1.6   Proof of Correctness	
91
or
{n = 5 and n ≥ 10} y = 100 {y = 6}
holds. Remember that this stands for an implication, which will be true because its 
antecedent, n = 5 and n ≥ 10, is false. We must also show that
{Q ` B′} P2 {R}
or
{n = 5 and n < 10} y = n + 1 {y = 6}
holds. Working back from the postcondition, using the assignment rule, we get
{n + 1 = 6 or n = 5}
y = n + 1
{y = 6}
Thus
{n = 5} y = n + 1 {y = 6}
is true by the assignment rule and therefore
{n = 5 and n < 10} y = n + 1 {y = 6}
is also true because the condition n < 10 adds nothing new to the assertion. The 
conditional rule allows us to conclude that the program segment is correct.
Practice 33	 Verify the correctness of the following program segment with the precondition and 
postcondition shown.
{x = 4}
if x < 5 then
y = x − 1
else
y = 7
end if
{y = 3} 
	
Example 46 	
Verify the correctness of the following program segment to compute max(x, y), the 
maximum of two distinct values x and y.
{x ∙ y}
if x >= y then
max = x
else
max = y
end if

92	
Formal Logic
The desired postcondition reflects the definition of the maximum, (x > y and  
max = x) or (x < y and max = y). The two implications to prove are
{x ∙ y and x ≥ y} max = x {(x > y and max = x) or (x < y and max = y)}
and
{x ∙ y and x < y} max = y {(x > y and max = x) or (x < y and max = y)}
Using the assignment rule on the first case (substituting x for max in the postcondi-
tion) would give the precondition
(x > y ` x = x) ~ (x < y ` x = y)
Since the second disjunct is always false, this is equivalent to
(x > y ` x = x)
which in turn is equivalent to
x > y     or     x ∙ y and x ≥ y
The second implication is proved similarly.
In Chapter 2, we will see how to verify correctness for a loop statement, 
where a section of code can be repeated many times.
As we have seen, proof of correctness involves a lot of detailed work. It is a 
difficult tool to apply to large programs that already exist. It is generally easier 
to prove correctness while the program is being developed. Indeed, the list of 
assertions from beginning to end specifies the intended behavior of the program 
and can be used early in its design. In addition, the assertions serve as valuable 
documentation after the program is complete.
S e c t i o n  1 . 6 	
Review
Techniques
•	 Verify the correctness of a program segment that 
includes assignment statements.
•	 Verify the correctness of a program segment that 
includes conditional statements.
Main Idea
•	 A formal system of rules of inference can be used 
to prove the correctness of program segments.
W
W
Exercises 1.6
In the following exercises, * denotes multiplication.
	 1.	 According to the assignment rule, what is the precondition in the following program segment?
	
{precondition}
	
x = x + 1
	
{x = y − l}

	
	
Section 1.6   Proof of Correctness	
93
	 2.	 According to the assignment rule, what is the precondition in the following program segment?
	
	 {precondition}
	
x = 2 * x
	
	 {x > y}
	 3.	 According to the assignment rule, what is the precondition in the following program segment? 
	
	 {precondition}
	
x = 3 * x − 1
	
	 {x = 2 * y − 1}
	 4.	 According to the assignment rule, what is the precondition in the following program segment?
	
	 {precondition}
	
y = 3x + 7
	
	 {y = x + 1}
	 5.	 Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {x = 1}
	
y = x + 3
	
y = 2 * y
	
	 {y = 8}
	 6.	 Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {x > 0}
	
y = x + 2
	
z = y + 1
	
	 {z > 3}
	 7.	 Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {x = 0}
	
z = 2 * x + 1
	
y = z − 1
	
	 {y = 0}
	 8.	 Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {x < 8}
	
z = x − 1
	
y = z – 5
	
	 {y < 2}
	 9.	 Verify the correctness of the following program segment to compute y = x(x − 1).
	
	 y = x − 1
	
	 y = x * y
	 10.	Verify the correctness of the following program segment to compute y = 2x + 1.
	
	 y = x
	
	 y = y + y
	
	 y = y + 1
	 11.	Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {y = 0}
	
if y < 5 then
	
y = y + 1
	
else
	
y = 5
	
end if
	
	 {y = 1}

94	
Formal Logic
	 12.	Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {x = 7}
	
if x <= 0 then
	
y = x
	
else
	
y = 2 * x
	
end if
	
	 {y = 14}
	 13.	Verify the correctness of the following program segment with the precondition and postcondition shown.
	
	 {x ≠ 0}
	
if x > 0 then
	
y = 2 * x
	
else
	
y = (−2) * x
	
end if
	
	 {y > 0}
	 14.	Verify the correctness of the following program segment to compute min(x, y), the minimum of two dis-
tinct values x and y.
	
	 {x ≠ y}
	
if x <= y then
	
min = x
	
else
	
min = y
	
end if
	 15.	Verify the correctness of the following program segment to compute |x|, the absolute value of x, for a 
nonzero number x.
	
	 {x ≠ 0}
	
if x >= 0 then
	
abs = x
	
else
	
abs = −x
	
end if
	 16.	Verify the correctness of the following program segment with the assertions shown.
	
	 {z = 3}
	
x = z + 1
	
y = x + 2
	
	 {y = 6}
	
if y > 0 then
	
z = y + 1
	
else
	
z = 2 * y
	
end if
	
	 {z = 7}

	
	
Chapter 1   Review	
95
algorithm (p. 12)
antecedent (p. 3)
assertion (p. 86)
assignment rule (p. 87)
binary connective (p. 3)
binary predicate (p. 40)
complete formal logic system  
(p. 27)
conclusion (p. 25)
conditional rule of inference  
(p. 90)
conditional statement (p. 90)
conjunct (p. 2)
conjunction (p. 2)
consequent (p. 3)
contradiction (p. 8)
correct formal logic system  
(p. 27)
correct program (p. 85)
De Morgan’s laws (p. 10)
declarative language (p. 73)
depth-first search (p. 81)
derivation rule (p. 27)
descriptive language (p. 73)
disjunct (p. 3)
disjunction (p. 3)
domain (p. 41)
dual of an equivalence (p. 9)
equivalence (p. 3)
equivalence rule (p. 28)
equivalent wffs (p. 8)
existential generalization (p. 62)
existential instantiation (p. 60)
existential quantifier (p. 40)
expert system (p. 81)
free variable (p. 42)
Hoare triple (p. 86)
Horn clause (p. 76)
hypothesis (p. 25)
implication (p. 3)
inference rule (p. 29)
interpretation (p. 41)
knowledge-based system (p. 81)
logical connective (p. 2)
main connective (p. 6)
n-ary predicate (p. 40)
negation (p. 4) 
postcondition (p. 86)
precondition (p. 86)
predicate (p. 39)
predicate logic (p. 58)
predicate wff (p. 41)
procedural language (p. 73)
program testing (p. 85)
program validation (p. 85)
program verification (p. 84)
Prolog database (p. 73)
Prolog fact (p. 73)
Prolog rule (p. 75)
proof of correctness (p. 85)
proof sequence (p. 27)
proposition (p. 2)
propositional calculus (p. 25)
propositional logic (p. 25)
propositional wff (p. 25)
pseudocode (p. 12)
recursive definition (p. 79)
resolution (p. 76)
rule-based system (p. 81)
scope (p. 41)
statement (p. 2)
statement letter (p. 2)
statement logic (p. 25)
tautology (p. 8)
ternary predicate (p. 40)
unary connective (p. 3)
unary predicate (p. 40)
universal generalization (p. 61)
universal instantiation (p. 59)
universal quantifier (p. 39)
valid argument (p. 26, 58)
valid predicate wff (p. 48)
well-formed formula (wff) (p. 6)
C h a p t e r  1 	
Review 
Terminology
Self Test
Answer the following true–false questions without looking back in the chapter. 
Section 1.1
1.	A contradiction is any propositional wff that is not 
a tautology.
2.	The disjunction of any propositional wff with a tau-
tology has the truth value true.
3.	Algorithm TautologyTest determines whether any 
propositional wff is a tautology.
4.	Equivalent propositional wffs have the same truth 
values for every truth value assignment to the 
­components.
5.	One of De Morgan’s laws states that the negation of 
a disjunction is the disjunction of the negations (of 
the disjuncts).
Section 1.2
1.	An equivalence rule allows one wff to be substi-
tuted for another in a proof sequence.
2.	If a propositional wff can be derived using modus 
ponens, then its negation can be derived using mo-
dus tollens. 
3.	Propositional logic is complete because every tau-
tology is provable.
4.	A valid argument is one in which the conclusion is 
always true.
5.	The deduction method applies when the conclusion 
is an implication.

96	
Formal Logic
O n  t h e  C o m p u t e r
For Exercises 1–5, write a computer program that pro-
duces the desired output from the given input.
1.	 Input: Truth values for two statement letters A and B
	
Output: Corresponding truth values (appropriately 
labeled, of course) for
A ` B, A ~ B, A S B, A 4 B, A′
2.	 Input: Truth values for two statement letters A and B
	
Output: Corresponding truth values for the wffs
A S B′ and B′ ` [A ~ (A ` B)]
3.	Input: Truth values for three statement letters A, B, 
and C
	
Output: Corresponding truth values for the wffs
A ~ (B ` C′) S B′ and A ~ C′ 4 (A ~ C )′
4.	Input: Truth values for three statement letters 
A, B, and C, and a representation of a simple 
­propositional wff. Special symbols can be used for 
the logical connectives, and postfix notation can be 
used; for example,
A B ` C ~ for (A ` B) ~ C
	
or
A′ B ` for A′` B
	
Output: Corresponding truth value of the wff
5.	Input: Representation of a simple propositional wff 
as in the previous exercise
	
Output: Decision on whether the wff is a tautology
6.	 Using the online Toy Prolog program that can be 
found at http://www.csse.monash.edu.au/~lloyd/
tildeLogic/Prolog.toy, enter the Prolog database of 
Example 39 and perform the queries there. Note 
that each database entry requires a period. Also add 
the recursive rule for infoodchain and perform the 
query
?infoodchain(bear, Y )
Section 1.3
1.	A predicate wff that begins with a universal 
­quantifier is universally true, that is, true in all in-
terpretations.
2.	In the predicate wff (4x)P(x, y), y is a free variable.
3.	An existential quantifier is usually found with the 
conjunction connective.
4.	The domain of an interpretation consists of the 
values for which the predicate wff defined on that 
­interpretation is true.
5.	A valid predicate wff has no interpretation in which 
it is false.
Section 1.4
1.	The inference rules of predicate logic allow ex-
istential and universal quantifiers to be added or 
­removed during a proof sequence.
2.	Existential instantiation should be used only after 
universal instantiation.
3. 	P(x) ` (E x)Q(x) can be deduced from (4x)
[P(x) ` (E y)Q( y)] using universal instantiation.
4.	Every provable wff of propositional logic is also 
provable in predicate logic.
5.	A predicate wff that is not valid cannot be proved 
using predicate logic.
Section 1.5
1.	A Prolog rule describes a predicate.
2.	Horn clauses are wffs consisting of single negated 
predicates.
3.	Modus ponens is a special case of Prolog resolu-
tion.
4.	A Prolog recursive rule is a rule of inference that is 
used more than once.
5.	A Prolog inference engine applies its rule of infer-
ence without guidance from either the programmer 
or the user.
Section 1.6
1.	A provably correct program always gives the right 
answers to a given problem.
2.	If an assertion after an assignment statement is  
y > 4, then the precondition must be y ≥ 4.
3.	Proof of correctness involves careful development 
of test data sets.
4.	Using the conditional rule of inference in proof 
of correctness involves proving that two different 
Hoare triples are valid.
5.	The assertions used in proof of correctness can also 
be used as a program design aid before the program 
is written, and as program documentation.

Chapter Objectives
After studying this chapter, you will be able to:
•	 Attack the proofs of conjectures using the techniques of direct proof, proof by 
contraposition, and proof by contradiction.
•	 Recognize when a proof by induction is appropriate and carry out such a proof 
using either the first or second principle of induction.
•	 Mathematically prove the correctness of programs that use loop statements.
•	 Test whether a given positive integer is prime; if not, find its prime ­factorization.
•	 Work with number theoretic ideas of prime factorization, greatest common 
divisor, and the Euler phi function.
The nonprofit organization at which you volunteer has received donations of 792 bars 
of soap and 400 bottles of shampoo. You want to create packages to distribute to 
homeless shelters such that each package contains the same number of shampoo 
bottles and each package contains the same number of bars of soap.
	
Question:	
How many packages can you create?
This problem is solvable by trial and error, but it’s much easier to use an ancient 
algorithm that is discussed in this chapter.
First, however, we consider how to prove “real-world” arguments as ­opposed 
to the formal arguments of Chapter 1. It is helpful to have an arsenal of ­techniques 
for attacking a proof. Direct proof, proof by contraposition, and proof by 
­contradiction are examined in Section 2.1. Many of the proofs given in this section 
are simple “number theory” results, that is, results about integers, such as “The 
product of two even integers is even.”
Section 2.2 concentrates on mathematical induction, a proof technique with 
particularly wide application in computer science. In Section 2.3 we see how, 
­using induction, proof of correctness can be extended to cover looping statements. 
Finally, Section 2.4 explores some further number theory results, particularly 
­concerning prime numbers.
2
Proofs, Induction, and  
Number Theory
Chapter
97

98	
Proofs, Induction, and Number Theory 
	
S e c t i o n  2 .1 	 Proof Techniques
Theorems and Informal Proofs
The formal arguments of Chapter 1 have the form P S Q, where P and Q may 
represent compound statements. The point there was to prove that an argument 
is valid—true in all interpretations by nature of its internal form or structure, 
not because of its content or the meaning of its component parts. However, we 
often want to prove arguments that are not universally true but just true within 
some context. Meaning becomes important because we are discussing a particular 
subject—graph algorithms, or Boolean algebra, or compiler theory, or whatever—
and we want to prove that if P is true in this context, then so is Q. If we can do 
this, then P S Q becomes a theorem about that subject. To prove a theorem about 
subject XXX, we can introduce facts about XXX into the proof; these facts act 
like additional hypotheses. Note that as we add more hypotheses, the universe of 
discourse shrinks; we are no longer considering universally valid arguments, only 
arguments that are true within the context in which the hypotheses hold.1
It may not be easy to recognize which subject-specific facts will be helpful or 
to arrange a sequence of steps that will logically lead from P to Q. Unfortunately, 
there is no formula for constructing proofs and no practical general algorithm or 
computer program for proving theorems. Experience is helpful, not only because 
you get better with practice, but also because a proof that works for one theorem 
can sometimes be modified to work for a new but similar theorem.
Theorems are often stated and proved in a somewhat less formal way than 
the propositional and predicate arguments of Chapter 1. For example, a theorem 
may express the fact that every object in the domain of interpretation (the ­subject 
­matter under discussion) having property P also has property Q. The formal 
­statement of the theorem would be (4x)[P(x) S Q(x)]. But the theorem would be 
informally stated as P(x) S Q(x). If we can prove P(x) S Q(x) where x is treated 
as an arbitrary element of the domain, universal generalization would then give 
(4x)[P(x) S Q(x)].
As another example, we may know that all objects in the domain have some 
property; that is, something of the form (4x)P(x) can be considered as a subject-
specific fact. An informal proof might proceed by saying, “Let x be any element 
of the domain. Then x has property P.” (Formally, we are making use of universal 
instantiation to get P(x) from (4x)P(x).)
Similarly, proofs are usually not written a step at a time with formal justifica-
tions for each step. Instead, the important steps and their rationale are ­outlined 
in narrative form. Such a narrative, however, can be translated into a formal 
proof if required. In fact, the value of a formal proof is that it serves as a sort of 
­insurance—if a narrative proof cannot be translated into a formal proof, it should 
be viewed with great suspicion.
1In the world of “pure predicate logic,” which is a correct and complete formal system, every true (valid) 
argument is provable. But in these more restrictive contexts, not everything that is “true” is necessarily 
provable, no matter how clever we are in adding additional hypotheses or “axioms.” In other words, these 
systems may not be complete. At the age of 25, the German logician Kurt Gödel proved in 1931 that, using 
reasonable hypotheses, even elementary arithmetic is an incomplete system. This result shocked the math-
ematical community of the time, which had been depending on axiomatic systems since the days of Euclid.

	
	
Section 2.1   Proof Techniques	
99
To Prove or Not to Prove
A textbook will often say, “Prove the following theorem,” and the reader will 
know that the theorem is true; furthermore, it is probably stated in its most pol-
ished form. But suppose you are doing research in some subject. You observe a 
number of cases in which whenever P is true, Q is also true. On the basis of these 
experiences, you may formulate a conjecture: P S Q. The more cases you find 
where Q follows from P, the more confident you are in your conjecture. This pro-
cess illustrates inductive reasoning, drawing a conclusion based on experience.
No matter how reasonable the conjecture sounds, however, you will not be 
satisfied until you have applied deductive reasoning to it as well. In this pro-
cess, you try to verify the truth or falsity of your conjecture. You produce a proof 
of P S Q (thus making it a theorem), or else you find a counterexample that 
­disproves the conjecture, a case in which P is true but Q is false. (We were using 
deductive reasoning in predicate logic when we either proved that a wff was valid 
or found an interpretation in which the wff was false.)
If you are simply presented with a conjecture, it may be difficult to decide 
which of the two approaches you should try—to prove the conjecture or to dis-
prove it! A single counterexample to a conjecture is sufficient to disprove it. Of 
course, merely hunting for a counterexample and being unsuccessful does not 
constitute a proof that the conjecture is true.
REMINDER
One counterexample is 
enough to disprove a 
conjecture.
PRACTICE 1	 Provide counterexamples to the following conjectures.
a.	 All animals living in the ocean are fish.
b.	Every integer less than 10 is bigger than 5.
■
	
EXAMPLE 1	
For a positive integer n, n factorial is defined as n(n − 1)(n − 2) c1, and is denoted 
by n!. Prove or disprove the conjecture, “For every positive integer n, n! ≤ n2.”
Let’s begin by testing some cases:
n
n!
n2
n! ≤ n2
1
1
1
yes
2
2
4
yes
3
6
9
yes
So far, this conjecture seems to be looking good. But for the next case,
n
n!
n2
n! ≤ n2
4
24
16
no
we have found a counterexample. The fact that the conjecture is true for n = 1, 2, 
and 3 does nothing to prove the conjecture, but the single case n = 4 is enough to 
disprove it.

100	
Proofs, Induction, and Number Theory 
If a counterexample is not forthcoming, perhaps the conjecture is true and we 
should try to prove it. What techniques can we use to try to do this? For the rest of 
this section, we’ll examine various methods of attacking a proof.
Exhaustive Proof
While “disproof by counterexample” always works, “proof by example” seldom 
does. The one exception to this situation occurs when the conjecture is an asser-
tion about a finite collection. In this case, the conjecture can be proved true by 
showing that it is true for each member of the collection. Proof by exhaustion 
means that all possible cases have been exhausted, although it often means that 
the person doing the proof is exhausted as well!
Table 2.1
Number
Divisible by 6
Divisible by 3
  1
no
  2
no
  3
no
  4
no
  5
no
  6
yes: 6 = 1 × 6
yes: 6 = 2 × 3
  7
no
  8
no
  9
no
10
no
11
no
12
yes: 12 = 2 × 6
yes: 12 = 4 × 3
13
no
14
no
15
no
16
no
17
no
18
yes: 18 = 3 × 6
yes: 18 = 6 × 3
19
no
20
no
	
Example 2	
Prove the conjecture, “If an integer between 1 and 20 is divisible by 6, then it is 
also divisible by 3.” (“Divisible by 6,” means, “evenly divisible by 6,” that is, the 
number is an integral multiple of 6.)
Because there is only a finite number of cases, the conjecture can be proved 
by simply showing it to be true for all the integers between 1 and 20. Table 2.1 is 
the proof.

	
	
Section 2.1   Proof Techniques	
101
Direct Proof
In general (where exhaustive proof won’t work), how can you prove that P S Q 
is true? The obvious approach is the direct proof—assume the hypothesis P and 
deduce the conclusion Q. A formal proof would require a proof sequence leading 
from P to Q.
Example 4 shows a formal proof that if two numbers are even (that’s the 
­hypothesis P), then their product is even (that’s the conclusion Q). Recall that an 
even ­number is a number that is an integral multiple of 2, for example, 18 is even 
because 18 = 2(9). An odd number is 1 more than an integral multiple of 2, for 
example, 19 = 2(9) + 1.
Practice 2	
a.	 Prove the conjecture “For any positive integer less than or equal to 5, the square of the ­integer 
is less than or equal to the sum of 10 plus 5 times the integer.”
b.	Disprove the conjecture “For any positive integer, the square of the integer is less than or equal 
to the sum of 10 plus 5 times the integer.”
	
EXAMPLE 3	
Prove the conjecture, “It is not possible to trace all the lines in Figure 2.1 without 
lifting your pencil and without retracing any lines.”
There is only a finite number of different ways to trace 
the lines in the figure. By careful bookkeeping, each of the 
possibilities can be attempted, and each will fail. In Chap-
ter 7, we will learn a much less tedious way to solve this 
problem than proof by exhaustion.
Figure 2.1
■
	
Example 4	
Consider the conjecture
x is an even integer ` y is an even integer S the product xy is an even integer
A complete formal proof sequence might look like the following:
  1.  x is an even integer ` y is an even integer	
hyp
  2.  (4x)[x is even integer S	
number fact (­definition 
	
   (Ek)(k an integer ` x = 2k)]	
   of even integer)
  3.  x is even integer S (Ek)(k an integer ` x = 2k)	
2, ui
  4.  y is even integer S (Ek)(k an integer ` y = 2k)	
2, ui
  5.  x is an even integer	
1, sim
  6.  (Ek)(k is an integer ` x = 2k)	
3, 5, mp
  7.  m is an integer ` x = 2m	
6, ei
  8.  y is an even integer	
1, sim
  9.  (Ek)(k an integer ` y = 2k)	
4, 8, mp
10.  n is an integer and y = 2n	
9, ei
11.  x = 2m	
7, sim
12.  y = 2n	
10, sim

102	
Proofs, Induction, and Number Theory 
We’ll never again do a proof like the one in Example 4, and you won’t have 
to either! A much more informal proof would be perfectly acceptable in most 
circumstances.
13.  xy = (2m)(2n)	
11, 12, substitution of equals
14.  xy = 2(2mn)	
13, multiplication fact
15.  m is an integer	
7, sim
16.  n is an integer	
10, sim
17.  2mn is an integer	
15, 16, number fact
18.  xy = 2(2mn) ` 2mn is an integer	
14, 17, con
19.  (Ek)(k an integer ` xy = 2k)	
18, eg
20.  (4x)((Ek)(k an integer ` x = 2k) S	
number fact (definition 		
	
	   x is even integer)	
   of even integer)
21.  (Ek)(k an integer ` xy = 2k) S	
20, ui		
	
	
	
	   xy is even integer
22.  xy is an even integer	
19, 21, mp
It is understood that x and y are arbitrary, but this could be stated by expressing the 
conjecture as
(4x)(4y)(x is an even integer ` y is an even integer S 
the product xy is an even integer)
Universal generalization can be applied twice to the result we already have in order 
to put the universal quantifiers on the front.
The proof in Example 5 does not explicitly state the hypothesis (that x and 
y are even), and it makes implicit use of the definition of an even integer. Even 
in informal proofs, however, it is important to identify the hypothesis and the 
­conclusion, not just what they are in words but what they really mean, by apply-
ing appropriate definitions. If we do not clearly understand what we have (the 
­hypothesis) or what we want (the conclusion), we cannot hope to build a bridge 
from one to the other. That’s why it is important to know definitions.
	
Example 5	
Following is an informal direct proof that the product of two even integers is even. 
Let x = 2m and y = 2n, where m and n are integers. Then xy = (2m)(2n) =  
2(2mn), where 2mn is an integer. Thus xy has the form 2k, where k is an ­integer, and 
xy is therefore even.
Notice that we set x = 2m for some integer m (the definition of an even 
number), but we set y = 2n. In the formal proof of Example 4, the restriction 
on the use of ei required that we use a different multiple of 2 for y than we used 
for x. Informally, if we were also to set y = 2m, we would be saying that x and 
y are the same integers, which is a very special case.

	
	
Section 2.1   Proof Techniques	
103
Contraposition
If you have tried diligently but failed to produce a direct proof of your conjecture 
P S Q, and you still feel that the conjecture is true, you might try some variants 
on the direct proof technique. If you can prove the theorem Q′ S P′, you can 
conclude P S Q by making use of the tautology (Q′ S P′) S (P S Q). Q′ S P′ 
is the contrapositive of P S Q, and the technique of proving P S Q by doing a 
direct proof of Q′ S P′ is called proof by contraposition. (The contraposition 
rule of inference in propositional logic (Table 1.14) says that P S Q can be derived 
from Q′ S P′.)
	
Example 6	
Prove that if the square of an integer is odd, then the integer must be odd.
The conjecture is n2 odd S n odd. We do a proof by contraposition, and prove 
n even S n2 even. Let n be even. Then n2 = n(n) is even by Example 5.
	
Example 7	
Prove that if n + 1 separate passwords are issued to n students, then some student 
gets ≥ 2 passwords.
Here the conclusion Q has the form (Ex)R(x), so Q′ is [(Ex)R(x)]′, which is 
equivalent to (4x)[R(x)]′. The contrapositive Q′ S P′ is, “If every student gets 
< 2 passwords, then it is false that n + 1 passwords were issued.” Suppose every 
student has < 2 passwords; then every one of the n students has at most 1 pass-
word. The total number of passwords issued is at most n, not n + 1, so it is false 
that n + 1 passwords were issued.
Example 7 is an illustration of the pigeonhole principle, which we will see in 
Chapter 4.
Practice 7 of Chapter 1 showed that the wffs A S B and B S A are not 
­equivalent. B S A is the converse of A S B. If an implication is true, its converse 
may be true or false. Therefore, you cannot prove P S Q by looking at Q S P.
Practice 4	 Write the contrapositive of each statement in Practice 5 of Chapter 1.
■
	
Example 8	
The implication “If a > 5, then a > 2” is true, but its converse, “If a > 2, then  
a > 5,” is false.
Practice 3	 Give a direct proof (informal) of the theorem “If an integer is divisible by 6, then twice 
that integer is divisible by 4.”
■

104	
Proofs, Induction, and Number Theory 
Theorems are often stated in the form “P if and only if Q,” meaning P if Q 
and P only if Q, or Q S P and P S Q. To prove such a theorem, you must prove 
both an implication and its converse. Again, the truth of one does not imply the 
truth of the other.
Practice 5	 Write the converse of each statement in Practice 5 of Chapter 1.
REMINDER
“If and only if” requires 
two proofs, one in each 
direction.
The second part of the proof of Example 9 uses proof by cases, a form of 
exhaustive proof. It involves identifying all the possible cases consistent with the 
given information and then proving each case separately.
Contradiction
In addition to direct proof and proof by contraposition, you might use the tech-
nique of proof by contradiction. (Proof by contradiction is sometimes called 
indirect proof, but this term more properly means any argument that is not a direct 
proof.) As we did in Chapter 1, we will let 0 stand for any contradiction, that is, 
any wff whose truth value is always false. (A ` A′ would be such a wff.) Once 
■
 
	
Example 9	
Prove that the product x y is odd if and only if both x and y are odd integers.
We first prove that if x and y are odd, so is xy. A direct proof will work. ­Suppose 
that both x and y are odd. Then x = 2n + 1 and y = 2m + 1, where m and n are inte-
gers. Then xy = (2n + 1)(2m + 1) = 4nm + 2m + 2n + 1 = 2(2nm + m + n) + 1. 
This has the form 2k + 1, where k is an integer, so xy is odd.
Next we prove that if xy is odd, both x and y must be odd, or
xy odd S x odd and y odd
A direct proof would begin with the hypothesis that xy is odd, which leaves us little 
more to say. A proof by contraposition works well because we’ll get more useful 
information as hypotheses. So we will prove
(x odd and y odd)′ S (xy odd)′
By De Morgan’s law (A ` B)′ 3 A′ ~ B′, we see that this can be written as
	
x even or y even S xy even	
(1)
The hypothesis “x even or y even” breaks down into three cases. We consider each 
case in turn.
	
1.	 x even, y odd: Here x = 2m, y = 2n + 1, and then xy = (2m)(2n + 1) =  
2(2mn + m), which is even.
	
2.	 x odd, y even: This works just like case 1.
	
3.	 x even, y even: Then xy is even by Example 5.
This completes the proof of (1) and thus of the theorem.

	
	
Section 2.1   Proof Techniques	
105
more, suppose you are trying to prove P S Q. By constructing a truth table, we 
see that
(P ` Q′ S 0) S (P S Q)
is a tautology, so to prove the theorem P S Q, it is sufficient to prove P ` Q′ S 0. 
Therefore, in a proof by contradiction you assume that both the hypothesis and 
the negation of the conclusion are true and then try to deduce some contradiction 
from these assumptions.
	
Example 10 	
Let’s use proof by contradiction on the statement, “If a number added to itself 
gives itself, then the number is 0.” Let x represent any number. The hypothesis 
is x + x = x and the conclusion is x = 0. To do a proof by contradiction, assume 
x + x = x and x ∙0. Then 2x = x and x ∙0. Because x ∙0, we can divide 
both sides of the equation 2x = x by x and arrive at the contradiction 2 = 1. Hence,  
(x + x = x) S (x = 0).
	
Example 11	
A well-known proof by contradiction shows that !2 is not a rational number. 
Recall that a rational number is one that can be written in the form p/q where p 
and q are integers, q ∙0, and p and q have no common factors (other than ± 1).
Let us assume that !2 is rational. Then !2 = p/q, and 2 = p2/q2, or  2q2 = p2. 
Then 2 divides p2, so—because 2 is itself indivisible—2 must divide p. This means 
that 2 is a factor of p; hence 4 is a factor of p2 , and the equation 2q2 = p2 can be 
written as 2q2 = 4x, or q2 = 2x. We see from this equation that 2 divides q2 and 
hence 2 divides q. At this point, 2 is a factor of q and a factor of p, which con-
tradicts the statement that p and q have no common factors. Therefore !2 is not 
rational.
Example 10 notwithstanding, a proof by contradiction most immediately 
comes to mind when you want to prove that something is not true. It’s hard to 
prove that something is not true; it’s much easier to assume it is true and obtain 
a contradiction.
REMINDER
To prove that something 
is not true, try proof by 
contradiction.
The proof of Example 11 involves more than just algebraic manipulations. It 
is often necessary to use lots of words in a proof.
Proof by contradiction can be a valuable technique, but it is easy to think we 
have done a proof by contradiction when we really haven’t. For example, suppose 
we assume P ` Q′ and are able to deduce Q without using the assumption Q′. Then 
we assert Q ` Q′ as a contradiction. What really happened here is a direct proof 
of P S Q, and the proof should be rewritten in this form. Thus in Example 10, 
we could assume x + x = x and x ∙ 0, as before. Then we could argue that from 
PRACTICE 6	 Prove by contradiction that the product of odd integers is not even. (We did a direct 
proof of an equivalent statement in Example 9.)
■

106	
Proofs, Induction, and Number Theory 
x + x = x we get 2x = x and, after subtracting x from both sides, x = 0. We then 
have x = 0 and x ∙ 0, a contradiction. However, in this argument we never made 
use of the assumption x ∙ 0; we actually proved directly that x + x = x implies 
x = 0.
Another misleading claim of proof by contradiction occurs when we assume 
P ` Q′ and are able to deduce P′ without using the assumption P. Then we assert 
P ` P′ as a contradiction. What really happened here is a direct proof of Q′ S P′, 
and we have constructed a proof by contraposition, not a proof by contradiction. 
In both this case and the previous one, it is not that the proofs are wrong, just that 
they are not proofs by contradiction.
Table 2.2 summarizes useful proof techniques we have discussed so far.
Table 2.2
Proof Technique
Approach to Prove P S Q
Remarks
Exhaustive proof
Demonstrate P S Q for all 
possible cases.
May be used only to prove 
a finite number of cases.
Direct proof
Assume P, deduce Q.
The standard approach—
usually the thing to try.
Proof by contraposition
Assume Q′, deduce P′.
Use this if Q′ as a hypoth-
esis seems to give more 
ammunition than P would.
Proof by contradiction
Assume P ` Q′, deduce a 
contradiction.
Use this when Q says 
something is not true.
Serendipity
Serendipity means a fortuitous happening, or good luck. While this isn’t really 
a general proof technique, some of the most interesting proofs come from clever 
observations that we can admire, even if we would never have thought of them 
ourselves. We’ll look at two such proofs, just for fun.
	
Example 12	
A tennis tournament has 342 players. A single match involves 2 players. The win-
ner of a match plays the winner of a match in the next round, while losers are 
eliminated from the tournament. The 2 players who have won all previous rounds 
play in the final game, and the winner wins the tournament. Prove that the total 
number of matches to be played is 341.
The hard way to prove this result is to compute 342/2 = 171 to get the num-
ber of matches in the first round, resulting in 171 winners to go on to the second 
round. For the second round, 171/2 = 85 plus 1 left over; there are 85 matches 
and 85 winners, plus the 1 left over, to go on to the third round. The third round 
has 86/2 = 43 matches, and so forth. The total number of matches is the sum of 
171 + 85 + 43 + c.
The clever observation is to note that each match results in exactly 1 loser, so 
there must be the same number of matches as losers in the tournament. Because 
there is only 1 winner, there are 341 losers and therefore 341 matches.

	
	
Section 2.1   Proof Techniques	
107
	
Example 13	
A standard 64-square checkerboard is arranged in 8 rows of 8 squares each. Adja-
cent squares are alternating colors of red and black. A set of 32 1 × 2 tiles, each 
covering 2 squares, will cover the board completely (4 tiles per row, 8 rows). Prove 
that if the squares at diagonally opposite corners of the checkerboard are removed, 
the remaining board cannot be covered with 31 tiles.
The hard way to prove this result is to try all possibilities with 31 tiles and see 
that they all fail. The clever observation is to note that opposing corners are the 
same color, so the checkerboard with the corners removed has two less squares of 
one color than of the other. Each tile covers one square of each color, so any set 
of tiles must cover an equal number of squares of each color and cannot cover the 
board with the corners removed.
S e c t i o n  2 .1 	
Review
Techniques
•	 Look for a counterexample.
•	 Construct direct proofs, proofs by contraposition, 
and proofs by contradiction.
Main Ideas
•	 Inductive reasoning is used to formulate a con-
jecture based on experience. Deductive reasoning 
is used either to refute a conjecture by finding a 
­counterexample or to prove a conjecture.
•	 In proving a conjecture about some subject, facts 
about that subject can be used.
•	 Under the right circumstances, proof by ­contra- 
position or contradiction may work better than a 
direct proof.
W
Exercises 2.1
	 1.	 Write the contrapositive of each statement in Exercise 5 of Section 1.1.
	 2.	 Write the converse of each statement in Exercise 5 of Section 1.1.
Common Definitions
Many of the examples in this section and many of the exercises that follow involve 
elementary number theory, that is, results about integers. It’s useful to work in 
number theory when first starting to construct proofs because many properties of 
integers, such as what it means to be an even number, are already familiar. The 
following definitions may be helpful in working some of these exercises.
•	 A perfect square is an integer n such that n = k 2 for some integer k.
•	 A prime number is an integer n > 1 such that n is not divisible by any 
integers other than 1 and n.
•	 A composite number n is a nonprime integer; that is, n = ab where a and 
b are integers with 1 < a < n and 1 < b < n.
•	 For two numbers x and y, x < y means y − x > 0.
•	 For two integers n and m, n divides m, n 0 m, means that m is divisible by 
n—that is, m = k(n) for some integer k.
•	 The absolute value of a number x, 0 x 0, is x if x ≥ 0 and is −x if x < 0.

108	
Proofs, Induction, and Number Theory 
	 3.	 Provide counterexamples to the following statements.
	
a.	 Every geometric figure with four right angles is a square.
	
b.	If a real number is not positive, then it must be negative.
	
c.	 All people with red hair have green eyes or are tall.
	
d.	All people with red hair have green eyes and are tall.
	 4.	 Provide counterexamples to the following statements.
	
a.	 If a and b are integers where a 0 b and b 0 a, then a = b.
	
b.	If n2 > 0 then n > 0.
	
c.	 If n is an even number, then n2 + 1 is prime.
	
d.	If n is a positive integer, then n3 > n!.
	 5.	 Provide a counterexample to the following statement: The number n is an odd integer if and only if  
3n + 5 is an even integer.
	 6.	 Provide a counterexample to the following statement: The number n is an even integer if and only if  
3n + 2 is an even integer.
	 7.	 a.	 Find two even integers whose sum is not a multiple of 4.
	
	 b.	 What is wrong with the following “proof” that the sum of two even numbers is a multiple of 4?
	
	 Let x and y be even numbers. Then x = 2m and y = 2m, where m is an integer, so x + y = 2m + 2m = 4m, 
which is an integral multiple of 4.
	 8.	 a. Find an example of an odd number x and an even number y such that x − y = 7.
	
	 b. What is wrong with the following “proof” that an odd number minus an even number is always 1?
	
	 Let x be odd and y be even. Then x = 2m + 1, y = 2m, where m is an integer, and x − y = 2m + 1 − 2m = 1.
For Exercises 9–46, prove the given statement.
	 9.	 If n = 25, 100, or 169, then n is a perfect square and is a sum of two perfect squares.
	 10.	If n is an even integer, 4 ≤ n ≤ 12, then n is a sum of two prime numbers.
	 11.	For any positive integer n less than or equal to 3, n! < 2n.
	 12.	For 2 ≤ n ≤ 4, n2 ≥ 2n.
	 13.	The sum of two even integers is even (do a direct proof).
	 14.	The sum of two even integers is even (do a proof by contradiction).
	 15.	The sum of two odd integers is even.
	 16.	The sum of an even integer and an odd integer is odd.
	 17.	An odd integer minus an even integer is odd.
	 18.	If n is an even integer, then n2 − 1 is odd.
	 19.	The product of any two consecutive integers is even.
	 20.	The sum of an integer and its square is even.
	 21.	The square of an even number is divisible by 4.
	 22.	For every integer n, the number 3(n2 + 2n + 3) − 2n2 is a perfect square.
	 23.	If a number x is positive, so is x + 1 (do a proof by contraposition).
	 24.	If n is an odd integer, then it is the difference of two perfect squares.
	 25.	The number n is an odd integer if and only if 3n + 5 = 6k + 8 for some integer k.
	 26.	The number n is an even integer if and only if 3n + 2 = 6k + 2 for some integer k. 

	
	
Section 2.1   Proof Techniques	
109
	 27.	For x and y positive numbers, x < y if and only if x2 < y2.
	 28.	If x2 + 2x − 3 = 0, then x ∙ 2.
	 29.	If n is an even prime number, then n = 2.
	 30.	The sum of three consecutive integers is divisible by 3.
	 31.	If two integers are each divisible by some integer n, then their sum is divisible by n.
	 32.	If the product of two integers is not divisible by an integer n, then neither integer is divisible by n.
	 33.	If n, m, and p are integers and n 0 m and m 0 p, then n 0 p.
	 34.	If n, m, p, and q are integers and n 0 p and m 0 q, then nm 0 pq.
	 35.	The square of an odd integer equals 8k + 1 for some integer k.
	 36.	The sum of the squares of two odd integers cannot be a perfect square. (Hint: Use Exercise 35.)
	 37.	The product of the squares of two integers is a perfect square.
	 38.	The difference of two consecutive cubes is odd.
	 39.	For any two numbers x and y, 0 x + y 0 ≤ 0 x 0 + 0  y 0.
	 40.	For any two numbers x and y, 0 xy 0 = 0 x 0 0  y 0.
	 41.	The value A is the average of the n numbers x1, x2, … , xn. Prove that at least one of x1, x2, … , xn is greater 
than or equal to A.
	 42.	Suppose you were to use the steps of Example 11 to attempt to prove that "4 is not a rational number. At 
what point would the proof not be valid?
	 43.	Prove that "3 is not a rational number.
	 44.	Prove that "5 is not a rational number.
	 45.	Prove that "
3 2 is not a rational number.
	 46.	Prove that log2 5 is not a rational number (log2 5 = x means 2x = 5).
For Exercises 47–72, prove or disprove the given statement.
	 47.	0 is an even number.
	 48.	91 is a composite number.
	 49.	297 is a composite number.
	 50.	83 is a composite number.
	 51.	The difference between two odd integers is odd.
	 52.	The difference between two even integers is even.
	 53.	The product of any three consecutive integers is even.
	 54.	The sum of any three consecutive integers is even.
	 55.	The sum of an integer and its cube is even.
	 56.	The number n is an even integer if and only if n3 + 13 is odd.
	 57.	The product of an integer and its square is even.
	 58.	Any positive integer can be written as the sum of the squares of two integers.
	 59.	The sum of the square of an odd integer and the square of an even integer is odd.
	 60.	If n is a positive integer that is a perfect square, then n + 2 is not a perfect square.
	 61.	For a positive integer n, n + 1
n ≥ 2.

110	
Proofs, Induction, and Number Theory 
	 62.	If n, m, and p are integers and n 0 mp, then n 0 m or n 0 p.
	 63.	For every prime number n, n + 4 is prime.
	 64.	For every positive integer n, n2 + n + 3 is not prime.
	 65.	For n a positive integer, n > 2, n2 − 1 is not prime.
	 66.	For every positive integer n, 2n + 1 is prime. 
	 67.	For every positive integer n, n2 + n + 1 is prime.
	 68.	For n an even integer, n > 2, 2n − 1 is not prime.
	 69.	The sum of two rational numbers is rational.
	 70.	The product of two rational numbers is rational.
	 71.	The product of two irrational numbers is irrational.
	 72.	The sum of a rational number and an irrational number is irrational.
For Exercises 73–75, use the following facts from geometry and the accompanying figure.
	
•	 The interior angles of a triangle sum to 180°.
	
•	 Vertical angles (opposite angles formed when two lines intersect) are the same size. 
	
•	 A straight angle is 180°. 
	
•	 A right angle is 90°.
1
2
3
4
6
5
	 73.	Prove that the measure of angle 5 plus the measure of angle 3 is 90°.
	 74.	Prove that the measure of angle 4 is the sum of the measures of angles 1 and 2.
	 75.	If angle 1 and angle 5 are the same size, then angle 2 is a right angle.
	 76.	Prove that the sum of the integers from 1 through 100 is 5050. (Hint: Instead of actually adding all the 
numbers, try to make the same clever observation that the German mathematician Karl Friederick Gauss 
[1777–1855] made as a schoolchild: Group the numbers into pairs, using 1 and 100, 2 and 99, etc.)
	
S e c t i o n  2 . 2 	 Induction
First Principle of Induction
There is one final proof technique especially useful in computer science. To 
illustrate how the technique works, imagine that you are climbing an infinitely 
high ladder. How do you know whether you will be able to reach an arbitrarily 
high rung? Suppose we make the following two assertions about your climbing 
abilities:
	
1.	 You can reach the first rung.
	
2.	 Once you get to a rung, you can always climb to the next one up. (Notice 
that this assertion is an implication.)

	
	
Section 2.2   Induction	
111
If both statement 1 and the implication of statement 2 are true, then by 
statement 1 you can get to the first rung and therefore by statement 2 you can 
get to the second; by statement 2 again, you can get to the third rung; by state-
ment 2 again you can get to the fourth; and so on. You can climb as high as you 
wish. Both assertions here are necessary. If only statement 1 is true, you have 
no guarantee of getting beyond the first rung, and if only statement 2 is true, 
you may never be able to get started. Let’s assume that the rungs of the ladder 
are numbered by positive integers—1, 2, 3, and so on.
Now think of a specific property a number might have. Instead of “reach-
ing an arbitrarily high rung,” we can talk about an arbitrary, positive integer 
having that property. We use the shorthand notation P(n) to mean that the posi-
tive integer n has the property P. How can we use the ladder-climbing tech-
nique to prove that for all positive integers n, we have P(n)? The two assertions 
we need to prove are
	
1.	 P(1)	
	 	
	
	
	
(1 has property P.)
	
2.	 For any positive integer k, P(k) S P(k + 1).	
(If any ­number has 
property P, so does the 
next number.)
If we can prove both assertions 1 and 2, then P(n) holds for any positive inte-
ger n, just as you could climb to an arbitrary rung on the ladder.
The foundation for arguments of this type is the first principle of mathemati-
cal induction.
REMINDER
To prove something true 
for all n ≥ some value, 
think induction.
The first principle of mathematical induction is an implication. The con-
clusion is a statement of the form, “P(n) is true for all positive integers n.” 
Therefore, whenever we want to prove that something is true for every positive 
integer n, it is a good bet that mathematical induction is an appropriate proof 
technique to use.
To know that the conclusion of this implication is true, we show that the two 
hypotheses, statements 1 and 2, are true. To prove statement 1, we need only show 
that property P holds for the number 1, usually a trivial task. Statement 2 is also 
an implication that must hold for all k. To prove this implication, we assume for 
an arbitrary positive integer k that P(k) is true and show, based on this assump-
tion, that P(k + 1) is true. Therefore P(k) S P(k + 1) and, using universal gener-
alization, (4k)[P(k) S P(k + 1)]. You should convince yourself that assuming that 
property P holds for the number k is not the same as assuming what we ultimately 
want to prove (a frequent source of confusion when one first encounters proofs of 
this kind). It is merely the way to proceed with a direct proof that the implication 
P(k) S P(k + 1) is true.
In doing a proof by induction, establishing the truth of statement 1, P(1), is 
called the basis, or basis step, for the inductive proof. Establishing the truth of 
P(k) S P(k + 1) is called the inductive step. When we assume P(k) to be true 
f  S P(n) true for all positive integers n
	
Principle	
First Principle of Mathematical Induction
1.	P(1) is true 
2.	(4k)[P(k) true S P(k + 1) true] 

112	
Proofs, Induction, and Number Theory 
so as to prove the inductive step, P(k) is called the inductive assumption, or 
­inductive hypothesis.
All the proof methods we have talked about in this chapter are techniques 
for deductive reasoning—ways to prove a conjecture that perhaps was for-
mulated by inductive reasoning. Mathematical induction is also a deductive 
technique, not a method for inductive reasoning (don’t get confused by the ter-
minology here). For the other proof techniques, we can begin with a hypothesis 
and string facts ­together until we more or less stumble on a conclusion. In fact, 
even if our ­conjecture is slightly incorrect, we might see what the correct con-
clusion is in the course of doing the proof. In mathematical induction, however, 
we must know right at the outset the exact form of the property P(n) that we 
are trying to establish. ­Mathematical induction, therefore, is not an exploratory 
proof technique—it can only confirm a correct conjecture.
Proofs by Mathematical Induction
Suppose that the ancestral progenitor Smith married and had two children. Let’s 
call these two children generation 1. Now suppose each of those two children had 
two children; then in generation 2, there were four offspring. This trend contin-
ued from generation unto generation. The Smith family tree therefore looks like 
­Figure 2.2. (This figure looks exactly like Figure 1.1b, where we looked at the 
­possible T–F values for n statement letters.)
Generation
1
2
Offspring
2 = 21
4 = 22
3
…
…
…
8 = 23
Figure 2.2
It appears that generation n contains 2n offspring. More formally, if we let P(n) 
denote the number of offspring at generation n, then we guess that
P(n) = 2n
We can use induction to prove that our guess for P(n) is correct.
The basis step is to establish P(1), which is the equation
 P(1) = 21 = 2
This is true because we are told that Smith had two children. We now assume that 
our guess is correct for an arbitrary generation k, k ≥ 1; that is, we assume
P(k) = 2k 
and try to show that
P(k + 1) = 2k+1

	
	
Section 2.2   Induction	
113
In this family, each offspring has two children; thus the number of offspring at 
generation k + 1 will be twice the number at generation k, or P(k + 1) = 2P(k). 
By the inductive assumption, P(k) = 2k, so
P(k + 1) = 2P(k) = 2(2k) = 2k+1
and so indeed
P(k + 1) = 2k+1
This completes our proof. Now that we have set our mind at ease about the 
Smith clan, we can apply the inductive proof technique to less obvious ­problems.
	
Example 14 	
Prove that the equation
	
1 + 3 + 5 + c+ (2n −1) = n2	
(1)
is true for any positive integer n. Here the property P(n) is equation (1). (Notice 
that P(n) is a property of n, or—in language from Chapter 1—a unary predicate. It 
is a statement about n, expressed here as an equation. Thus it is incorrect to write 
something like P(n) = 1 + 3 + 5 + g+ (2n − 1).) 
The left side of this equation is the sum of all the odd integers from 1 to 
2n − 1. The right side is a formula for the value of this sum. Although we can 
verify the truth of this equation for any particular value of n by substituting that 
value for n, we cannot substitute all possible positive integer values. Thus a proof 
by exhaustion does not work. A proof by mathematical induction is appropriate.
The basis step is to establish P(1), which is equation (1) when n has the value 
1. When we substitute 1 for n in the left side of equation (1), we get the sum of all 
the odd integers starting at 1 and ending at 2(1) − 1 = 1. The sum of all the odd 
numbers from 1 to 1 equals 1. When we substitute 1 for n in the formula on the 
right side of this equation, we get (1)2. Therefore
P(1):   1 = 12
This is certainly true. For the inductive hypothesis, we assume P(k) for an arbitrary 
positive integer k, which is equation (1) when n has the value k, or
	
P(k):  1 + 3 + 5 + c+ (2k −1) = k2	
(2) 
(Note that P(k) is not the equation (2k − 1) = k2, which is true only for k = 1.) 
Using the inductive hypothesis, we want to show P(k + 1), which is equation (1) 
when n has the value k + 1, or
	
P(k + 1):   1 + 3 + 5 + c+ 32(k + 1) −14 0 (k + 1)2	
(3)
(The question mark over the equals sign is to remind us that this is the fact we want 
to prove, as opposed to something we already know.)

114	
Proofs, Induction, and Number Theory 
The key to an inductive proof is to find a way to relate what we want to show—
P(k + 1), equation (3)—to what we have assumed—P(k), equation (2). The left 
side of P(k + 1) can be rewritten to show the next-to-last term:
1 + 3 + 5 + c+ (2k −1) + 32(k + 1) −14
This expression contains the left side of equation (2) as a subexpression. Because 
we have assumed P(k) to be true, we can substitute the right side of equation (2) 
for this subexpression. Thus,
1 + 3 + 5 + c+ 32(k + 1) −14
 = 1 + 3 + 5 + c+ (2k −1) + 32(k + 1) −14
= k2 + 32(k + 1) −14
= k2 + 32k + 2 −14 
= k2 + 2k + 1
= (k + 1)2
Therefore,
1 + 3 + 5 + c+ 32(k + 1) −14 = (k + 1)2
which verifies P(k + 1) and proves that equation (1) is true for any positive 
integer n.
Table 2.3 summarizes the three steps necessary for a proof using the first 
principle of induction.
Any “summation” induction problem works exactly the same way. Write the summa-
tion including the next-to-last term, and you will find the left side of the P(k) equation 
and can use the inductive hypothesis. After that, it’s just a question of algebra.
	
Example 15	
Prove that
1 + 2 + 22 + c+ 2n = 2n+1 −1
for any n ≥1.
Again, induction is appropriate. P(1) is the equation
	
1 + 2 = 21+1 −1	
or	
3 = 22 −1
Table 2.3
To Prove by First Principle of Induction
Step 1
Prove base case.
Step 2
Assume P(k).
Step 3
Prove P(k + 1).

	
	
Section 2.2   Induction	
115
The following summation formula is the most important one because it oc-
curs so often in the analysis of algorithms. If you don’t remember anything else, 
you should remember this formula for the sum of the first n positive ­integers.
Not all proofs by induction involve formulas with sums. Other algebraic iden-
tities about the positive integers, as well as nonalgebraic assertions like the num-
ber of offspring in generation n of the Smith family, can be proved by induction.
PRACTICE 7	 Prove that for any positive integer n,
1 + 2 + 3 + c+ n = n(n+1)
2
■
REMINDER
To prove
P(k) S P(k + 1), you have 
to discover the P(k) case 
within the P(k + 1) case.
which is true. We take P(k)
1 + 2 + 22 + c+ 2k = 2k+1 −1
as the inductive hypothesis and try to establish P(k + 1):
1 + 2 + 22 + c+ 2k+1 0 2k+1+1 −1
Rewriting the sum on the left side of P(k + 1) reveals how the inductive as-
sumption can be used:
1 + 2 + 22 + c+ 2k+1
 = 1 + 2 + 22 + c+ 2k + 2k+1
= 2k+1 −1 + 2k+1     (from the inductive hypothesis P(k))
= 2(2k+1) −1           (adding like terms)
= 2k+1+1 −1
Therefore,
1 + 2 + 22 + c+ 2k+1 = 2k+1+1 −1
which verifies P(k + 1) and completes the proof.
	
EXAMPLE 16	
Prove that for any positive integer n, 2n > n.
P(1) is the assertion 21 > 1, which is surely true. Now we assume P(k), 2k > k, 
and try to conclude P(k + 1), 2k+1 > k + 1. Now, where is P(k) hidden in here? 
Aha—we can write the left side of P(k + 1), 2k+1, as 2k # 2, and there’s the left side 
of P(k). Using the inductive hypothesis 2k > k and multiplying both sides of this 
inequality by 2, we get 2k # 2 > k # 2. We complete the argument
2k+1 = 2k # 2 > k # 2 = k + k ≥k + 1 (because k ≥ 1)
or
2k+1 > k + 1

116	
Proofs, Induction, and Number Theory 
For the first step of the induction process, it may be appropriate to begin at 0 
or at 2 or 3 instead of at 1. The same principle applies, no matter where you first 
hop on the ladder.
	
EXAMPLE 17	
Prove that n2 > 3n for n ≥ 4.
Here we should use induction and begin with a basis step of P(4). (Testing 
values of n = 1, 2, and 3 shows that the inequality does not hold for these values.) 
P(4) is the inequality 42 > 3(4), or 16 > 12, which is true. The inductive hypoth-
esis is that k2 > 3k and that k ≥ 4, and we want to show that (k + 1)2 > 3(k + 1).
 (k + 1)2 = k2 + 2k + 1
 > 3k + 2k + 1     (by the inductive hypothesis)
 ≥3k + 8 + 1       (because k ≥4)
 = 3k + 9
 > 3k + 3            (because 9 > 3)  
 = 3(k + 1)
In this proof we used the fact that 3k + 9 > 3k + 3. Of course, 3k + 9 is 
greater than lots of things, but 3k + 3 is what gives us what we want. In an induc-
tion proof, because we know exactly what we want as the result, we can let that 
guide us as we manipulate algebraic expressions.
PRACTICE 8	 Prove that for all n > 1,
2n+1 < 3n
■
	
Example 18	
Prove that for any positive integer n, the number 22n – 1 is divisible by 3.
The basis step is to show P(1), that 22(1) −1 = 4 −1 = 3 is divisible by 3. 
Clearly this is true.
We assume that 22k – 1 is divisible by 3, which means that 22k – 1 = 3m for 
some integer m, or 22k = 3m + 1 (this little rewriting trick is the key to these 
“­divisibility” problems). We want to show that 22(k+1) – 1 is divisible by 3.
 22(k+1) −1 = 22k+2 −1
 = 22 # 22k −1
 = 22(3m + 1) −1     (by the inductive hypothesis)
 = 12m + 4 −1
 = 12m + 3
 = 3(4m + 1)          where 4m + 1 is an integer
Thus 22(k+1) −1 is divisible by 3.
Misleading claims of proof by induction are also possible. When we prove 
the truth of P(k + 1) without relying on the truth of P(k), we have done a di-
rect proof of P(k + 1) where k + 1 is arbitrary. The proof is not invalid, but it 

	
	
Section 2.2   Induction	
117
should be rewritten to show that it is a direct proof of P(n) for any n, not a proof 
by induction.
An inductive proof may be called for when its application is not as obvious as 
in the above examples. The problem statement may not directly say “prove some-
thing about nonnegative integers.” Instead, there is some quantity in the statement 
to be proved that can take on arbitrary nonnegative integer values.
	
EXAMPLE 19	
A programming language might be designed with the following convention re-
garding multiplication: A single factor requires no parentheses, but the product “a 
times b” must be written as (a)b. So the product
a # b # c # d # e # f # g
could be written in this language as
((((((a)b)c)d )e) f )g
or, for example,
((a)b)(((c)d )(e) f )g
depending on the order in which the products are formed. The result is the same 
in either case.
We want to show that any product of factors can be written with an even number 
of parentheses. The proof is by induction on the number of factors (this is where the 
nonnegative integer comes in—it represents the number of factors in any product of 
factors). For a single factor, there are 0 parentheses, an even number. Assume that 
for any product of k factors there is an even number of parentheses. Now consider 
a product P of k + 1 factors. P can be thought of as r times s where r has k factors 
and s is a single factor. By the inductive hypothesis, r has an even number of pa-
rentheses. Then we write r times s as (r)s. This adds 2 more parentheses to the even 
number of parentheses in r, giving P an even number of parentheses.
Here’s an important observation about the proof in Example 19: There are no 
algebraic expressions! The entire proof is a verbal argument. For some proofs, we 
can’t rely on just the crutch of nonverbal mathematical manipulations; we have to 
use words.
	
EXAMPLE 20	
A “tiling” problem gives a nice illustration of induction in a geometric setting. 
An angle iron is an L-shaped piece that can cover 3 squares on a checkerboard 
(Figure 2.3a). The problem is to show that for any positive integer n, a 2n × 2n 
­checkerboard with one square removed can be tiled—completely covered—by 
angle irons.
The base case is n = 1, which gives a 2 × 2 checkerboard. ­Figure 2.3b shows the 
solution to this case if the upper right corner is removed. Removing any of the other 
three corners works the same way.­ Assume that any 2k × 2k checkerboard with one 
square removed can be tiled ­using angle irons. Now consider a checkerboard with 

118	
Proofs, Induction, and Number Theory 
Second Principle of Induction
In addition to the first principle of induction, which we have been using,
	
1.	 P(1) is true 
	
2.	 (4k)[P(k) true S P(k + 1) true] 
there is a second principle of induction.
f  S P(n) true for all positive integers n
	
Principle	
Second Principle of Mathematical Induction
	
1′.	 P(1) is true 
	
2′.	 (4k)[P(r) true for all r, 
1 ≤ r ≤ k S P(k + 1) true]
¶  S P(n) true for all positive integers n
dimensions 2k+1 × 2k+1. We need to show that it can be tiled when one square is re-
moved. To relate the k + 1 case to the inductive hypothesis, divide the 2k+1 × 2k+1 
checkerboard into four quarters. Each quarter will be a 2k × 2k checkerboard, and 
one will have a missing square (Figure 2.3c). By the inductive hypothesis, this 
checkerboard can be tiled. Remove a corner from each of the other three checker-
boards, as in Figure 2.3d. By the inductive hypothesis, the three boards with the holes 
removed can be tiled, and one angle iron can tile the three holes. Hence the original  
2k+1 × 2k+1 board with its one hole can be tiled.
(d)
(c)
(b)
(a)
Figure 2.3
These two induction principles differ in statements 2 and 2′. In statement 2, 
we must be able to prove for an arbitrary positive integer k that P(k + 1) is true 
based only on the assumption that P(k) is true. In statement 2′, we can assume 
that P(r) is true for all integers r between 1 and an arbitrary positive integer k in 
order to prove that P(k + 1) is true. This seems to give us a great deal more “am-
munition,” so we might sometimes be able to prove the implication in 2′ when we 
cannot prove the implication in 2.
What allows us to deduce (4n)P(n) in either case? We will see that the two in-
duction principles themselves, that is, the two methods of proof, are equivalent. In 
other words, if we accept the first principle of induction as valid, then the second 
principle of induction is valid, and conversely. In order to prove the equivalence 
of the two induction principles, we’ll introduce another principle, which seems so 
obvious as to be unarguable.

	
	
Section 2.2   Induction	
119
	
Principle	
Principle of Well-Ordering
Every collection of positive integers that contains any members at all has a 
­smallest member.
We will see that the following implications are true:
second principle of induction S first principle of induction
first principle of induction S well-ordering
well-ordering S second principle of induction
As a consequence, all three principles are equivalent, and accepting any one of 
them as true means accepting the other two as well.
To prove that the second principle of induction implies the first principle of 
induction, suppose we accept the second principle as valid reasoning. We then 
want to show that the first principle is valid; that is, that we can conclude P(n) for 
all n from statements 1 and 2. If statement 1 is true, so is statement 1′. If statement 
2 is true, then so is statement 2′, because we can say that we concluded P(k + 1) 
from P(r) for all r between 1 and k, even though we used only the single condi-
tion P(k). (More precisely, statement 2′ requires that we prove P(l) ` P(2) ` g 
` P(k) S P(k + 1), but P(l) ` P(2) ` g` P(k) S P(k), and from statement 2, 
P(k) S P(k + 1), so P(1) ` P(2) ` g` P(k) S P(k + 1).) By the second prin-
ciple of induction, we conclude P(n) for all n. The proofs that the first principle 
of ­induction implies well-ordering and that well-ordering implies the second 
­principle of induction are left as exercises in Section 4.1.
To distinguish between a proof by the first principle of induction and a proof 
by the second principle of induction, let’s look at a rather picturesque example that 
can be proved both ways.
	
EXAMPLE 21	
Prove that a straight fence with n fence posts has n – 1 sections for any n ≥ 1 (as 
in Figure 2.4a).
Fence with 4 fenceposts, 3 sections
Fence with 1 fencepost, 0 sections
(a)
(b)
Fence with last post and
last section removed
Fence with 1 section removed
(c)
(d)
Figure 2.4

120	
Proofs, Induction, and Number Theory 
Example 21 allowed for either form of inductive proof because we could  
either reduce the fence at one end or split it at an arbitrary point. The problem of 
Example 19 is similar.
Let P(n) be the statement that a fence with n fence posts has n – 1 sections, and 
prove P(n) true for all n ≥ 1.
We’ll start with the first principle of induction. For the basis step, P(1) says that 
a fence with only 1 fence post has 0 sections, which is clearly true (Figure 2.4b). 
­Assume that P(k) is true:
a fence with k fence posts has k – 1 sections
and try to prove P(k + 1):
(?) a fence with k + 1 fence posts has k sections
Given a fence with k + 1 fence posts, how can we relate that to a fence with  
k fence posts so that we can make use of the inductive hypothesis? We can chop 
off the last post and the last section (Figure 2.4c). The remaining fence has k fence 
posts and, by the inductive hypothesis, k – 1 sections. Therefore the original fence 
had k sections.
Now we’ll prove the same result using the second principle of induction. The 
basis step is the same as before. For the inductive hypothesis, we assume
for all r, 1 ≤ r ≤ k, a fence with r fence posts has r – 1 sections
and try to prove P(k + 1):
(?) a fence with k + 1 fence posts has k sections
For a fence with k + 1 fence posts, split the fence into two parts by removing 
one section (Figure 2.4d). The 2 parts of the fence have r1 and r2 fence posts, where 
1 ≤ r1 ≤ k, 1 ≤ r2 ≤ k, and r1 + r2 = k + 1. By the inductive hypothesis, the 2 
parts have, respectively, r1 – 1 and r2 – 1 sections, so the original fence has
(r1 −1) + (r2 −1) + 1 sections
(The extra 1 is for the one that we removed.) Simple arithmetic then yields
r1 + r2 −1 = (k + 1) −1 = k sections
This proves that a fence with k + 1 fence posts has k sections, which verifies 
P(k + 1) and completes the proof using the second principle of induction.
	
EXAMPLE 22	
We again want to show that any product of factors can be written in this program-
ming language with an even number of parentheses, this time using the second prin-
ciple of induction. The base case is the same as in Example 19: A single factor has 
0 parentheses, an even number. Assume that any product of r factors, 1 ≤ r ≤ k, 
can be written with an even number of parentheses. Then consider a product  

	
	
Section 2.2   Induction	
121
Most problems do not work equally well with either form of induction; the 
fence post and the programming language problem were somewhat artificial. 
Generally, the second principle of induction is called for when the problem 
“splits” most naturally in the middle instead of growing from the end.
P with k + 1 factors. P can be written as (S )T, a product of two factors S and T, 
where S has r1 factors and T has r2 factors. Then 1 ≤ r1 ≤ k and 1 ≤ r2 ≤ k, with 
r1 + r2 = k + 1. By the inductive hypothesis, S and T each have an even number 
of parentheses, and therefore so does (S )T = P.	
	
EXAMPLE 23	
Prove that for every integer n ≥ 2, n is a prime number or a product of prime numbers.
We will postpone the decision of whether to use the first or the second prin-
ciple of induction; the basis step is the same in each case and need not start with 
1. Obviously here we should start with 2. P(2) is the statement that 2 is a prime 
number or a product of primes. Because 2 is a prime number, P(2) is true. Jumping 
ahead, for either principle we will be considering the number k + 1. If k + 1 is 
prime, we are done. If k + 1 is not prime, then it is a composite number and can be 
written as k + 1 = ab. Here k + 1 has been split into two factors. Maybe neither 
of these factors has the value k, so an assumption only about P(k) isn’t enough. 
Hence, we’ll use the second principle of induction.
So let’s start again. We assume that for all r, 2 ≤ r ≤ k, P(r) is true—r is 
prime or the product of primes. Now consider the number k + 1. If k + 1 is 
prime, we are done. If k + 1 is not prime, then it is a composite number and 
can be written as k + 1 = ab, where 1 < a < k + l and 1 < b < k + l. (This 
is a nontrivial factorization, so neither factor can be 1 or k + 1.) Therefore  
2 ≤ a ≤ k and 2 ≤ b ≤ k. The inductive hypothesis applies to both a and b, so a 
and b are either prime or the product of primes. Thus, k + 1 = ab is the product 
of prime numbers. This verifies P(k + 1) and completes the proof by the second 
principle of induction.
The proof in Example 23 is an existence proof rather than a constructive 
proof. Knowing that every nonprime number has a factorization as a product 
of primes does not make it easy to find such a factorization. (We will see in 
­Section 2.4 that there is, except for the order of the factors, only one such 
factorization.) Some encryption systems for passing information in a secure 
fashion on the Web depend on the difficulty of factoring large numbers into 
their prime factors (see the discussion on public-key encryption in Section 5.6).
	
EXAMPLE 24	
Prove that any amount of postage greater than or equal to 8 cents can be built using 
only 3-cent and 5-cent stamps.
Here we let P(n) be the statement that only 3-cent and 5-cent stamps are need-
ed to build n cents worth of postage, and prove that P(n) is true for all n ≥ 8. The 
basis step is to establish P(8), which is done by the equation
8 = 3 + 5

122	
Proofs, Induction, and Number Theory 
REMINDER
Use the second principle 
of induction when the 
k + 1 case depends on 
results farther back than k.
As a general rule, the first principle of mathematical induction applies 
when information about “one position back” is enough, that is, when the truth 
of P(k) is enough to prove the truth of P(k + 1). The second principle applies 
when information about “one position back” isn’t good enough; that is, you 
can’t prove that P(k + 1) is true just because you know P(k) is true, but you can 
prove P(k + 1) true if you know that P(r) is true for one or more values of r that 
are “farther back” than k.
S e c t i o n  2 . 2 	 Review
Techniques
•	 Use the first principle of induction in proofs.
•	 Use the second principle of induction in proofs.
Main Ideas
•	 Mathematical induction is a technique to prove 
properties of positive integers.
•	 An inductive proof need not begin with 1. 
•	 Induction can be used to prove statements about 
quantities whose values are arbitrary nonnegative 
integers. 
•	 The first and second principles of induction each 
prove the same conclusion, but one approach may 
be easier to use than the other in a given situation.
W
W
For reasons that will be clear momentarily, we’ll also establish two additional 
cases, P(9) and P(10), by the equations
 9 = 3 + 3 + 3
10 = 5 + 5
Now we assume that P(r) is true, that is, r can be written as a sum of 3s and 5s, for 
any r, 8 ≤ r ≤ k, and consider P(k + 1). We may assume that k + 1 is at least 11, 
because we have already proved P(r) true for r = 8, 9, and 10. If k + 1 ≥ 11, then 
(k + 1) – 3 = k – 2 ≥ 8. Thus k – 2 is a legitimate r value, and by the inductive 
hypothesis, P(k – 2) is true. Therefore k – 2 can be written as a sum of 3s and 5s, 
and adding an additional 3 gives us k + 1 as a sum of 3s and 5s. This verifies that 
P(k + 1) is true and completes the proof.
PRACTICE 9	
a.	 Why are the additional cases P(9) and P(10) proved separately in Example 24?
b.	Why can’t the first principle of induction be used in the proof of Example 24?	
■
Exercises 2.2
	 1.	 For all positive integers, let P(n) be the equation
2 + 6 + 10 + c+ (4n −2) = 2n2 
	
a.	 Write the equation for the base case P(1) and verify that it is true.
	
b.	Write the inductive hypothesis P(k).
	
c.	 Write the equation for P(k + 1).
	
d.	Prove that P(k + 1) is true.

	
	
Section 2.2   Induction	
123
	 2.	 For all positive integers, let P(n) be the equation
2 + 4 + 6 + c+ 2n = n(n + 1)
	
a.	 Write the equation for the base case P(1) and verify that it is true.
	
b.	Write the inductive hypothesis P(k).
	
c.	 Write the equation for P(k + 1).
	
d.	Prove that P(k + 1) is true.
In Exercises 3–26, use mathematical induction to prove that the statements are true for every positive integer n. 
[Hint: In the algebra part of the proof, if the final expression you want has factors and you can pull those factors 
out early, do that instead of multiplying everything out and getting some humongous expression.]
	 3.	 1 + 5 + 9 + c+ (4n −3) = n(2n −1)
	 4.	 1 + 3 + 6 + c+ n(n + 1)
2
= n(n + 1)(n + 2)
6
 
	 5.	 4 + 10 + 16 + c+ (6n −2) =  n(3n + 1)
	 6.	 5 + 10 + 15 + c+ 5n = 5n(n + 1)
2
	 7.	 12 + 22 + c+ n2 = n(n + 1)(2n + 1)
6
	 8.	 13 + 23 + c+ n3 = n2(n + 1)2
4
	 9.	 12 + 32 + c+ (2n −1)2 = n(2n −1)(2n + 1)
3
	 10.	14 + 24 + c+  n4 = n(n + 1)(2n + 1)(3n2 + 3n −1)
30
	 11.	1 # 3 + 2 # 4 + 3 # 5 + c+ n(n + 2) = n(n + 1)(2n + 7)
6
	 12.	1 + a + a2 + c+ an−1 = an −1
a −1   for a ∙ 0, a ∙ 1
	 13.	 1
1 # 2 +
1
2 # 3 +
1
3 # 4 + c+
1
n(n + 1) =
n
n + 1
	 14.	 1
1 # 3 +
1
3 # 5 +
1
5 # 7 + c+
1
(2n −1)(2n + 1) =
n
2n + 1
	 15.	12 −22 + 32 −42 + c+ (−1)n+1n2 = (−1)n+1(n)(n + 1)
2
	 16.	2 + 6 + 18 + c+ 2 # 3n−1 = 3n −1
	 17.	22 + 42 + c+ (2n)2 = 2n(n + 1)(2n + 1)
3
	 18.	1 # 21 + 2 # 22 + 3 # 23 + c+ n # 2n = (n −1)2n+1 + 2
	 19.	1 # 2 + 2 # 3 + 3 # 4 + c+ n(n + 1) = n(n + 1)(n + 2)
3

124	
Proofs, Induction, and Number Theory 
	 20.	1 # 2 # 3 + 2 # 3 # 4 + c+ n(n + 1)(n + 2) = n(n + 1)(n + 2)(n + 3)
4
	 21.	 1
1 # 4 +
1
4 # 7 +
1
7 # 10 + c+
1
(3n −2)(3n + 1) =
n
3n + 1
	 22.	1 # 1! + 2 # 2! + 3 # 3! + c+ n # n! = (n + 1)! −1 where n! is the product of the positive integers 
from 1 to n.
	 23.	1 + 4 + 42 + c+ 4n = 4n+1 −1
3
	 24.	1 + x + x2 + c+ xn = xn+1 −1
x −1  where x is any integer > 1
	
25.	1 + 4 + 7 + 10 + c+ (3n −2) = n(3n −1)
2
	
26.	1 + 3x # 2 −(x −1)4 + 3x # 3 −(x −1)4 + c+ 3x # n −(x −1)4 = n3xn −(x −2)4
2
 	
 
where x is any integer ≥ 1
	 27.	A geometric progression (geometric sequence) is a sequence of terms where there is an initial term a and 
each succeeding term is obtained by multiplying the previous term by a common ratio r. Prove the formula 
for the sum of the first n (n ≥ 1) terms of a geometric sequence where r ∙ 1:
a + ar + ar2 + c+ arn−1 = a −arn
1 −r
	 28.	An arithmetic progression (arithmetic sequence) is a sequence of terms where there is an initial term a and 
each succeeding term is obtained by adding a common difference d to the previous term. Prove the formula 
for the sum of the first n (n ≥ 1) terms of an arithmetic sequence:
a + (a + d) + (a + 2d) + c+ 3a + (n −1)d4 = n
232a + (n −1)d4
	 29.	Using Exercises 27 and 28, find an expression for the value of the following sums.
	
a.	 2 + 2 # 5 + 2 # 52 + c+ 2 # 59
	
b.	  4 # 7 + 4 # 72 + 4 # 73 + c+ 4 # 712
	
c.	 1 + 7 + 13 + c+ 49
	
d.	 12 + 17 + 22 + 27 + c+ 92
	 30.	Prove that
(−2)0 + (−2)1 + (−2)2 + c+ (−2)n = 1 −2n+1
3
	
	 for every positive odd integer n.
	 31.	Prove that n2 > n + 1 for n ≥2.
	 32.	Prove that n2 ≥2n + 3 for n ≥3.
	 33.	Prove that n2 > 5n + 10 for n > 6.
	 34.	Prove that 2n > n2 for n ≥5.
In Exercises 35–40, n! is the product of the positive integers from 1 to n.
	 35.	Prove that n! > n2 for n ≥4.

	
	
Section 2.2   Induction	
125
	 36.	Prove that n! > n3 for n ≥6.
	 37.	Prove that n! > 2n for  n ≥4.
	 38.	Prove that n! > 3n for  n ≥7.
	 39.	Prove that n! ≥2n−1 for n ≥1.
	 40.	Prove that n! < nn for n ≥2.
	 41.	Prove that (1 + x)n > 1 + xn for n > 1, x > 0.
	 42.	Prove that aa
bb
n+1
< aa
bb
n
for n ≥1 and 0 < a < b.
	 43.	Prove that 1 + 2 + c+ n < n2 for n > 1.
	 44.	Prove that 1 + 1
4 + 1
9 + c+ 1
n2 < 2 −1
n      for n ≥2
	 45.	a.	Try to use induction to prove that
1 + 1
2 + 1
4 + c+ 1
2n < 2     for n ≥1
	
	
What goes wrong?
	
b.	Prove that
1 + 1
2 + 1
4 + c+ 1
2n = 2 −1
2n     for n ≥1
	
	
thus showing that
1 + 1
2 + 1
4 + c+ 1
2n < 2     for n ≥1
	 46.	Prove that
1 + 1
2 + 1
3 + c+ 1
2n ≥1 + n
2    for  n ≥1 
	
	 (Note that the denominators increase by 1, not by powers of 2.)
For Exercises 47–58, prove that the statements are true for every positive integer.
	 47.	23n −1 is divisible by 7.
	 48.	32n + 7 is divisible by 8.
	 49.	7n −2n is divisible by 5.
	 50.	13n −6n is divisible by 7.
	 51.	2n + (−1)n+1 is divisible by 3.
	 52.	25n+1 + 5n+2 is divisible by 27.
	 53.	34n+2 + 52n+1 is divisible by 14.
	 54.	72n + 16n −1 is divisible by 64.
	 55.	10n + 3 # 4n+2 + 5 is divisible by 9.
	 56.	n3 −n is divisible by 3.
	 57.	n3 + 2n is divisible by 3.
	 58.	xn −1 is divisible by x − 1 for x ∙ 1.

126	
Proofs, Induction, and Number Theory 
	 59.	Prove DeMoivre’s Theorem:
(cos θ + i sin θ)n = cos nθ + i sin nθ
	
	 for all n ≥ 1. Hint: Recall the addition formulas from trigonometry:
cos(α + β) = cos α cos β −sin α sin β
sin(α + β) = sin α cos β + cos α sin β
	 60.	Prove that
sin θ + sin 3θ + c+ sin(2n −1)θ = sin2 nθ
sin θ
	
	 for all n ≥ 1 and all θ for which sin θ ∙ 0.
	 61.	Use induction to prove that the product of any three consecutive positive integers is divisible by 3.
	 62.	Suppose that exponentiation is defined by the equation
x j # x = x j+1
	
	 for any j ≥ 1. Use induction to prove that xn # xm = xn+m for n ≥ 1, m ≥ 1.  
(Hint: Do induction on m for a fixed, arbitrary value of n.)
	 63.	According to Example 20, it is possible to use angle irons to tile a 4 × 4 checkerboard with the upper right 
corner removed.Sketch such a tiling.
	 64.	Example 20 does not cover the case of checkerboards that are not sized by powers of 2. Determine whether 
it is possible to tile a 3 × 3 checkerboard.
	 65.	Prove that it is possible to use angle irons to tile a 5 × 5 checkerboard with the upper left corner removed.
	 66.	Find a configuration for a 5 × 5 checkerboard with one square removed that is not possible to tile; explain 
why this is not possible.
	 67.	Consider n infinitely long straight lines, none of which are parallel and no three of which have a common 
point of intersection. Show that for n ≥ 1, the lines divide the plane into (n2 + n + 2)∙2 separate regions.
	 68.	A string of 0s and 1s is to be processed and converted to an even-parity string by adding a parity bit to the 
end of the string.(For an explanation of the use of parity bits, see Example 30 in Chapter 9.) The parity 
bit is initially 0. When a 0 character is processed, the parity bit remains unchanged. When a 1 character 
is processed, the parity bit is switched from 0 to 1 or from 1 to 0. Prove that the number of 1s in the final 
string, that is, including the parity bit, is always even. (Hint: Consider various cases.)
	 69.	What is wrong with the following “proof” by mathematical induction? We will prove that for any positive 
integer n, n is equal to 1 more than n. Assume that P(k) is true.
k = k + 1
	
	 Adding 1 to both sides of this equation, we get
k + 1 = k + 2
	
	 Thus,
P(k + 1) is true
	 70.	What is wrong with the following “proof” by mathematical induction?
We will prove that all computers are built by the same manufacturer. In particular, we will prove 
that in any collection of n computers where n is a positive integer, all the computers are built by the 
same manufacturer. We first prove P(1), a trivial process, because in any collection consisting of 

	
	
Section 2.2   Induction	
127
one computer, there is only one manufacturer. Now we assume P(k); that is, in any collection of k 
computers, all the computers were built by the same manufacturer. To prove P(k + 1), we consider 
any collection of k + 1 computers. Pull one of these k + 1 computers (call it HAL) out of the col-
lection. By our assumption, the remaining k computers all have the same manufacturer. Let HAL 
change places with one of these k computers. In the new group of k computers, all have the same 
manufacturer. Thus, HAL’s manufacturer is the same one that produced all the other computers, and 
all k + 1 computers have the same manufacturer.
	 71.	An obscure tribe has only three words in its language, moon, noon, and soon. New words are composed by 
juxtaposing these words in any order, as in soonnoonmoonnoon. Any such juxtaposition is a legal word.
	
a.	 Use the first principle of induction (on the number of subwords in the word) to prove that any word in 
this language has an even number of o’s.
	
b.	Use the second principle of induction (on the number of subwords in the word) to prove that any word 
in this language has an even number of o’s.
	 72.	A simple closed polygon consists of n points in the plane joined in pairs by n line segments; each point is 
the endpoint of exactly 2 line segments. Following are two examples.
	
a.	 Use the first principle of induction to prove that the sum of the interior angles of an n-sided simple 
closed polygon is (n − 2)180° for all n ≥ 3.
	
b.	Use the second principle of induction to prove that the sum of the interior angles of an n-sided simple 
closed polygon is (n − 2)180° for all n ≥ 3.
	 73.	The Computer Science club is sponsoring a jigsaw puzzle contest. Jigsaw puzzles are assembled by fitting 
2 pieces together to form a small block, adding a single piece to a block to form a bigger block, or fitting 
2 blocks together. Each of these moves is considered a step in the solution. Use the second principle of 
induction to prove that the number of steps required to assemble an n-piece jigsaw puzzle is n − 1.
	 74.	OurWay Pizza makes only two kinds of pizza, pepperoni and vegetarian. Any pizza of either kind comes 
with an even number of breadsticks (not necessarily the same even number for both kinds). Any order of 2 
or more pizzas must include at least 1 of each kind. When the delivery driver goes to deliver an order, he 
or she puts the completed order together by combining 2 suborders—picking up all the pepperoni pizzas 
from 1 window and all the vegetarian pizzas from another window. Prove that for a delivery of n pizzas, 
n ≥ 1, there are an even number of breadsticks included.
	 75.	Consider propositional wffs that contain only the connectives `, ~, and S (no negation) and where wffs 
must be parenthesized when joined by a logical connective. Count each statement letter, connective, or 
parenthesis as one symbol. For example, ((A) ` (B)) ~ ((C) ` (D)) is such a wff, with 19 symbols. Prove 
that any such wff has an odd number of symbols.
	 76.	In any group of k people, k ≥ 1, each person is to shake hands with every other person. Find a formula for 
the number of handshakes, and prove the formula using induction.

128	
Proofs, Induction, and Number Theory 
	 77.	Prove that any amount of postage greater than or equal to 2 cents can be built using only 2-cent and 3-cent 
stamps.
	 78.	Prove that any amount of postage greater than or equal to 12 cents can be built using only 4-cent and 
5-cent stamps.
	 79.	Prove that any amount of postage greater than or equal to 14 cents can be built using only 3-cent and 
8-cent stamps.
	 80.	Prove that any amount of postage greater than or equal to 42 cents can be built using only 4-cent and  
15-cent stamps.
	 81.	Prove that any amount of postage greater than or equal to 64 cents can be built using only 5-cent and  
17-cent stamps.
	 82.	Your bank ATM delivers cash using only $20 and $50 bills. Prove that you can collect, in addition to $20, 
any multiple of $10 that is $40 or greater.
Exercises 83–84 require familiarity with ideas from calculus. Exercises 1–26 give exact formulas for the sum 
of terms in a sequence that can be expressed as ∙
n
m=1
f   (m). Sometimes it is difficult to find an exact expression 
for this summation, but if the value of f(m) increases monotonically, integration can be used to find upper and 
lower bounds on the value of the summation. Specifically,
3
n
0
f (x)dx ≤∙
n
m=1
f (m) ≤3
n+1
1
f (x)dx
Using the following figure, we can see (on the left) that 3
n
0
f (x)dx underestimates the value of the summation 
while (on the right) 3
n+1
1
f (x)dx overestimates it.
0
1
2
3
4
f(1)
f(2)
f(3)
f(4)
f(x)
         
1
2
3
4
5
f(1)
f(2)
f(3)
f(4)
f(x)
	 83.	Show that 3
n
0
2x dx ≤∙
n
m=1
2m ≤3
n+1
1
2x dx (see Exercise 2).
	 84.	Show that 3
n
0
x2dx ≤∙
n
m=1
m2 ≤3
n+1
1
x2dx (see Exercise 7).

	
	
Section 2.3   More on Proof of Correctness	
129
	
S e c t i o n  2 . 3 	 More on Proof of Correctness
In Section 1.6, we explained the use of a formal logic system to prove mathemati-
cally the correctness of a program. Assertions or predicates involving the program 
­variables are inserted at the beginning, at the end, and at intermediate points between 
the program statements. Then proving the correctness of any particular program 
statement si involves proving that the implication represented by the Hoare triple
	
{Q} si {R}	
(1)
is true.Here Q and R are assertions known, respectively, as the precondition and 
postcondition for the statement. The program is provably correct if all such impli-
cations for the statements in the program are true.
In Chapter 1, we discussed rules of inference that give conditions under 
which implication (1) is true when si is an assignment statement and when si is a 
­conditional statement. Now we will use a rule of inference that gives conditions 
under which implication (1) is true when si is a loop statement. We have deferred 
consideration of loop statements until now because mathematical induction is 
used in applying this rule of inference.
Loop Rule
Suppose that si is a loop statement in the form
while condition B do
P
end while
where B is a condition that is either true or false and P is a program segment. 
When this statement is executed, condition B is evaluated. If B is true, program 
segment P is executed and then B is evaluated again. If B is still true, program 
segment P is executed again, then B is evaluated again, and so forth. If condition 
B ever evaluates to false, the loop terminates.
The form of implication (1) that can be used when si is a loop statement 
­imposes (like the assignment rule did) a relationship between the precondition and 
the postcondition. The precondition Q holds before the loop is entered; strangely 
enough, one requirement is that Q must continue to hold after the loop terminates 
(which means that we should look for a Q that we want to be true when the loop 
terminates). In addition, B′—the condition for loop termination—must be true 
then as well. Thus (1) will have the form
	
{Q} si {Q ` B′}	
(2)
	
Example 25	
Consider the following pseudocode function, which is supposed to return the value 
x * y for nonnegative integers x and y.

130	
Proofs, Induction, and Number Theory 
Assertion Q must be true before the loop is entered. If implication (2) is to 
hold, Q must remain true after the loop terminates. Because it may not be known 
exactly when the loop will terminate, Q must remain true after each iteration 
through the loop, which will include the final iteration. Q represents a predicate, 
or relation, among the values of the program variables. If this relation holds among 
the values of the program variables before a loop iteration executes and holds 
among the values after the iteration executes, then the relation among these vari-
ables is unaffected by the action of the loop iteration, even though the values 
themselves may be changed. Such a relation is called a loop invariant.
Product (nonnegative integer x; nonnegative integer y)
Local variables:
integers i, j
i = 0
j = 0
while i ∙ x do
	
j = j + y
	
i = i + 1
end while
//j now has the value x * y
return j
end function Product
This function contains a loop; the condition B for continued loop execution is 
i ∙ x. The condition B′ for loop termination is therefore i = x. When the loop 
terminates, it is claimed in the comment that j has the value x * y. Thus, on loop 
termination, we want
Q ` B′ = Q ` ( i = x )
and we also want
j = x * y
To have both
Q ` (i = x) and  j = x * y
Q must be the assertion
j = i * y
(Notice that Q is a predicate, that is, it states a relationship between variables in 
the program. It is never part of an equation such as Q = j.) To match the form of 
(2), the assertion j = i * y would have to be true before the loop statement. This is 
indeed the case because right before the loop statement, i = j = 0.
It would seem that for this example we have a candidate assertion Q for impli-
cation (2), but we do not yet have the rule of inference that allows us to say when 
(2) is a true implication. (Remember that we discovered our Q by “wishful think-
ing” about the correct operation of the function code.)

	
	
Section 2.3   More on Proof of Correctness	
131
The loop rule of inference allows the truth of (2) to be inferred from an im-
plication stating that Q is a loop invariant. Again, for Q to be a loop invariant it 
must be the case that if Q is true and condition B is true, so that another loop itera-
tion is executed, then Q remains true after that iteration, which can be expressed 
by the Hoare triple {Q ` B} P {Q}. The rule is formally stated in Table 2.4.
To use this rule of inference, we must find a useful loop invariant Q—one that 
asserts what we want and expect to have happen—and then prove the implication
5Q ` B6 P 5Q6
Here is where induction comes into play. We denote by Q(n) the statement that 
a proposed loop invariant Q is true after n iterations of the loop. Because we do 
not necessarily know how many iterations the loop may execute (that is, how long 
condition B remains true), we want to show that Q(n) is true for all n ≥0. (The 
value of n = 0 corresponds to the assertion upon entering the loop, after zero loop 
iterations.)
	
Example 26	
Consider again the pseudocode function of Example 25. In that example, we 
guessed that Q is the relation
j = i * y
To use the loop rule of inference, we must prove that Q is a loop invariant.
The quantities x and y remain unchanged throughout the function, but values 
of i and j change within the loop. We let in and jn denote the values of i and j, 
respectively, after n iterations of the loop. Then Q(n) is the statement jn = in * y.
We prove by induction that Q(n) holds for all n ≥0. Q(0) is the statement
j0 = i0 * y
which, as we noted in Example 25, is true, because after zero iterations of the loop, 
when we first get to the loop statement, both i and j have been assigned the value 
0. (Formally, the assignment rule could be used to prove that these conditions on i 
and j hold at this point.)
Assume Q(k):   jk = ik * y
Show Q(k + 1): jk+1 = ik+1 * y
Table 2.4
From
Can Derive
Name of Rule
Restrictions on Use
{Q ` B} P {Q}
{Q} si {Q ` B′}
loop
si has the form 
while condition B do 
P
end while

132	
Proofs, Induction, and Number Theory 
Between the time j and i have the values jk and ik and the time they have the values 
jk+1 and ik+1, one iteration of the loop takes place. In that iteration, j is changed by 
adding y to the previous value, and i is changed by adding 1. Thus,
	
jk+1 = jk  +  y
(3)
	
 ik+1  =  ik  +  1
(4)
Then
	
jk+1 = jk + y	
(by (3))	
= ik * y + y	 (by the inductive hypothesis)	
= (ik + 1)y	
= ik+1 * y	
(by (4))	
We have proved that Q is a loop invariant.
The loop rule of inference allows us to infer that after the loop statement is 
exited, the condition Q ` B′ holds, which in this case becomes
j = i * y ` i = x
Therefore at this point the statement
j = x * y
is true, which is exactly what the function is intended to compute.
Example 26 illustrates that loop invariants say something stronger about the 
program than we actually want to show; what we want to show is the special case 
of the loop invariant on termination of the loop. Finding the appropriate loop in-
variant requires working backward from the desired conclusion, as in Example 25.
We did not, in fact, prove that the loop in this example actually does ter-
minate. What we proved was partial correctness—the program produces the 
correct answer, given that execution does terminate. Because x is a nonnegative 
integer and i is an integer that starts at 0 and is then incremented by 1 at each pass 
through the loop, we know that eventually i = x will become true.
Practice 10	 Show that the following function returns the value x + y for nonnegative integers x and y 
by proving the loop invariant Q: j = x + i and evaluating Q when the loop terminates.
Sum (nonnegative integer x; nonnegative integer y)
Local variables:
integers i, j
i = 0
j = x
while i ≠ y do
j = j + 1 
i = i + 1
end while
// j now has the value x + y
return j
end function Sum
■

	
	
Section 2.3   More on Proof of Correctness	
133
The two functions of Example 25 and Practice 10 are somewhat unrealistic; 
after all, if we wanted to compute x * y or x + y, we could no doubt do it with a 
single program statement. However, the same techniques apply to more meaning-
ful computations, such as the Euclidean algorithm.
Euclidean Algorithm
The Euclidean algorithm was described by the Greek mathematician Euclid over 
2300 years ago, although it may have been known even earlier. At any rate, it is 
one of the oldest known algorithms.This algorithm finds the greatest common 
divisor of two positive integers a and b with a > b. The greatest common divisor 
of a and b, denoted by gcd(a, b), is the largest integer n such that n 0 a and n 0 b. For 
example, gcd(12, 18) is 6 and gcd(420, 66) = 6.
First, let’s dispense with two trivial cases of the gcd(a, b) that do not require 
the Euclidean algorithm.
	
i.	 gcd(a, a) = a. Clearly a 0 a and no larger integer divides a.
	
ii.	 gcd(a, 0) = a. Again, a 0 a and no larger integer divides a, but also a 0 0 
because 0 is a multiple of a: 0 = 0(a)
The Euclidean algorithm works by a succession of divisions. To find gcd(a, b), 
assuming that a > b, you first divide a by b, getting a quotient and a remainder. 
More formally, at this point a = q1b + r1, where 0 ≤ r1 < b. Next you ­divide the 
divisor, b, by the remainder, r1, getting b = q2r1 + r2, where 0 ≤ r2 < r1. Again di-
vide the divisor, r1, by the remainder, r2, getting r1 = q3r2 + r3, where 0 ≤ r3 < r2.
Clearly, there is a looping process going on, with the remainders ­getting succes-
sively smaller. The process terminates when the remainder is 0, at which point the 
greatest common divisor is the last divisor used.
A pseudocode version of the algorithm follows, given in the form of a func-
tion to return gcd(a, b).
	
Algorithm	
Euclidean Algorithm
GCD (positive integer a; positive integer b)
//a > b
Local variables:
integers i, j
i = a
j = b
	
Example 27	
To find gcd(420, 66) the following divisions are performed:
 6	
	
 2	
	
 1	
	
 3
 66q420	
	
 24q66	
	
 18q24	
	
 6q18
 396	
	
 48	
	
 18	
	
 18
 24	
	
 18	
	
 6	
	
 0
The answer is 6, the divisor used when the remainder became 0.

134	
Proofs, Induction, and Number Theory 
while j ≠ 0 do
compute i = q j + r, 0 ≤ r < j
i = j 
j = r
end while
// i now has the value gcd(a, b)
return i;
end function GCD
We intend to prove the correctness of this function, but we will need one ad-
ditional fact first, namely,
	
(4 integers a, b, q, r)3(a = qb + r) S (gcd(a, b) = gcd(b, r))4
(5)
To prove (5), assume that a = qb + r and suppose that c divides both a and b so 
that a = q1c and b = q2c. Then
r = a −qb = q1c −qq2c = c (q1 −qq2)
so that c divides r as well. Therefore anything that divides a and b also divides b 
and r. Now suppose d divides both b and r so that b = q3d and r = q4d. Then
a = qb + r = qq3d + q4d = d(qq3 + q4)
so that d divides a as well. Therefore anything that divides b and r also divides a 
and b. Because (a, b) and (b, r) have identical divisors, they must have the same 
greatest common divisor.
	
EXAMPLE 28 	
Prove the correctness of the Euclidean algorithm.
Using function GCD, we will prove the loop invariant Q: gcd(i, j) = gcd(a, b) 
and evaluate Q when the loop terminates. We use induction to prove Q(n):  
gcd(in, jn) = gcd(a, b) for all n ≥ 0. Q(0) is the statement
gcd(i0, j0) = gcd(a, b)
which is true because when we first get to the loop statement, i and j have the val-
ues a and b, respectively.
Assume Q(k):   gcd(ik, jk) = gcd(a, b)
Show Q(k + 1): gcd(ik+1, jk+1) = gcd(a, b)
By the assignment statements within the loop body, we know that
ik+1 = jk
jk+1 = rk

	
	
Section 2.3   More on Proof of Correctness	
135
Then
gcd(ik+1, jk+1) = gcd(  jk, rk)
	
= gcd(ik, jk)	
by (5)	
= gcd(a, b)	
by the inductive hypothesis	
Q is therefore a loop invariant. At loop termination, gcd(i, j) = gcd(a, b) and j = 0, 
so gcd(i, 0) = gcd(a, b). But gcd(i, 0) is i, so i = gcd(a, b). Therefore function 
GCD is correct.

136	
Proofs, Induction, and Number Theory 
Special Interest Page
Making Safer Software
Proof of correctness seeks to verify that a given com-
puter program or segment of a program meets its speci-
fications. As we have seen, this approach relies on 
formal logic to prove that if a certain relationship (the 
precondition) holds among the program variables before 
a given statement is executed, then after execution an-
other relationship (the postcondition) holds. Because of 
the labor-intensive nature of proof of correctness, its use 
is typically reserved for critical sections of code in im-
portant applications.
The B method is a set of tools that does two things:
1.	 Supports formal project specification by means 
of an abstract model of the system to be devel-
oped. This support includes both automatic gen-
eration of lemmas that must be proven in order 
to guarantee that the model reflects the system 
requirements and automatic proof tools to prove 
each lemma or flag it for human verification  
assistance.
2.	 Translates the abstract model into a code-ready 
design, again using lemmas to ensure that the 
design matches the abstract model. The final 
level can then be translated into code, often us-
ing the Ada programming language, described 
by its proponents as “the language designed for 
building systems that really matter.”
One of the most interesting applications of proof 
of correctness, based on the B method, is the develop-
ment of software for the Paris Météor train. This is part 
of the Paris metro train system designed to carry up to 
40,000 passengers per hour and per direction with an 
interval between trains as low as 85 seconds on peak 
hours. The safety-critical part of the software includes 
the running and stopping of every train, opening and 
closing of doors, electrical traction power, routes, 
speed of trains, and alarms from passengers. By the 
end of the project, 27,800 lemmas had been proven, 
with 92% proven automatically (with no human inter-
vention). But here is the amazing part: the number of 
bugs in the Ada code found by testing on the host com-
puter, the target computer, on site, and after the system 
was put into operation was—0. Zero, nada, none. Very 
impressive indeed.
Other formal method systems have been used for 
critical software projects, such as
•	 Development of a left ventricular assist device 
that helps the heart pump blood in those with 
congestive heart failure. The eventual goal is an 
artificial heart.
•	 “Conflict detection and resolution algorithms” 
for safety in air traffic control
•	 Development of the Tokeneer ID Station soft-
ware to perform biometric verification of a hu-
man seeking access to a secure computing en-
vironment. Tokeneer is a hypothetical system 
promoted by NSA (National Security Agency) as 
a challenge problem for security researchers.
Formal Verification of Large Software Systems, Yin, X., 
and Knight, J., Proceedings of the NASA Formal 
Methods Symposium, April 13–15, 2010, Washington 
D.C., USA.
http://libre.adacore.com/academia/projects-single/echo
http://shemesh.larc.nasa.gov/fm/fm-atm-cdr.html
“Météor: A Successful Application of B in a Large Project,” 
Behm, P., Benoit, P., Faivre, A., and Meynadier, J., 
World Congress On Formal Methods in the Develop-
ment of Computing Systems, Toulouse, France, 1999, 
vol. 1709, pp. 369–387.
Chapter 2

	
	
Section 2.3   More on Proof of Correctness	
137
Exercises 2.3
	 1.	 Let Q: x2 > x + 1 where x is a positive integer. Assume that Q is true after the kth iteration of the follow-
ing while loop; prove that Q is true after the next iteration.
while (x > 5) and (x < 40) do
	
x = x + 1
end while
	 2.	 Let Q: x! > 3x where x is a positive integer. Assume that Q is true after the kth iteration of the following 
while loop; prove that Q is true after the next iteration.
while (x > 10) and (x < 30) do
	
x = x + 2
end while
In Exercises 3–6, prove that the pseudocode program segment is correct by proving the given loop invariant Q 
and evaluating Q at loop termination.
	 3.	 Function to return the value of x! for x ≥ 1.
Factorial (positive integer x)
Local variables:
integers i, j
	
i = 2
	
j = 1
	
while i ≠ x + 1 do
	
	
j = j * i
	
	
i = i + 1
	
end while
	
//j now has the value x!
	
return j
end function Factorial
Q: j = (i − 1)!
	 4.	 Function to return the value of x 2 for x ≥ 1.
Square (positive integer x)
Local variables:
integers i, j
	
i = 1
	
j = 1
	
while i ≠ x do
	
	
j = j + 2i + 1
	
	
i = i + 1 
	
end while
S e c t i o n  2 . 3 	 Review
Techniques
•	 	Verify the correctness of a program segment that 
includes a loop statement.
•	 	Compute gcd(a, b) using Euclid’s algorithm.
Main Ideas
•	 A loop invariant, proved by induction on the num-
ber of loop iterations, can be used to prove correct-
ness of a program loop.
•	 The classic Euclidean algorithm for finding the 
greatest common divisor of two positive integers is 
provably correct.
W

138	
Proofs, Induction, and Number Theory 
	
//j now has the value x 2
	
return j
end function Square
Q: j = i 2
	 5.	 Function to return the value of x y for x, y ≥ 1.
Power (positive integer x, positive integer y)
Local variables:
integers i, j
	
i = 1 
	
j = x 
	
while i ≠ y do
	
	
j = j ∗ x
	
	
i = i + 1
	
end while
	
//j now has the value x y
	
return j
end function Power
Q: j = x i
	 6.	 Function to compute and write out quotient q and remainder r when x is divided by y, x ≥ 0, y ≥ 1.
Divide (nonnegative integer x; positive integer y);
Local variables:
nonnegative integers q, r
	
q = 0 
	
r = x 
	
while r ≥ y do 
	
	
q = q + 1 
	
	
r = r – y 
	
end while
	
//q and r are now the quotient and remainder
	
write(“The quotient is” q “and the remainder is” r)
end function Divide
Q: x = q ∗ y + r
For Exercises 7–12 use the Euclidean algorithm to find the greatest common divisor of the given numbers.
	 7.	 (308, 165)
	 8.	 (2420, 70)
	 9.	 (735, 90)
	 10.	(8370, 465)
	 11.	(1326, 252)
	 12.	(1018215, 2695)
	 13.	Following is the problem posed at the beginning of this chapter.
The nonprofit organization at which you volunteer has received donations of 792 bars of soap and 
400 bottles of shampoo. You want to create packages to distribute to homeless shelters such that 
each package contains the same number of shampoo bottles and each package contains the same 
number of bars of soap. How many packages can you create?
	
	 Explain why the solution to this problem is the gcd(792, 400).

	
	
Section 2.3   More on Proof of Correctness	
139
	 14.	Concerning the question posed in Exercise 13:
	
a.	 Use the Euclidean algorithm to find the number of packages.
	
b.	How many bottles of shampoo are in each package?
	
c.	 How many bars of soap are in each package?
In Exercises 15–21, prove that the program segment is correct by finding and proving the appropriate loop in-
variant Q and evaluating Q at loop termination.
	 15.	Function to return the value x ∗ y n for n ≥ 0.
Computation (integer x; integer y; nonnegative integer n)
Local variables:
integers i, j
	
i = 0 
	
j = x 
	
while i ≠n do
	
	
j = j ∗ y
	
	
i = i + 1
	
end while
	
//j now has the value x ∗ y n
	
return j
end function Computation
	 16.	 Function to return the value x – y for x, y ≥ 0.
Difference (nonnegative integer x; nonnegative integer y)
Local variables:
integers i, j
	
i = 0
	
j = x
	
while i ≠ y do
	
	
j = j – 1
	
	
i = i + 1
	
end while
	
//j now has the value x – y
	
return j
end function Difference
	 17.	Function to return the value (x + 1) 2 for x ≥ 1.
IncrementSquare (positive integer x)
Local variables:
integers i, j
	
i = 1
	
j = 4
	
while i ∙ x do 
	
	
j = j + 2i + 3
	
	
i = i + 1 
	
end while
	
//j now has the value (x + 1) 2
	
return j
end function IncrementSquare

140	
Proofs, Induction, and Number Theory 
	 18.	Function to return the value 2n for n ≥ 1.
TwosPower (positive integer n)
Local variables:
integers i, j
	
i = 1
	
j = 2
	
while i ∙ n do
	
	
j = j ∗ 2
	
	
i = i + 1
	
end while
	
//j now has the value 2n
	
return j
end function TwosPower
	 19.	Function to return the value x ∗ n! for n ≥ 1.
AnotherOne (integer x; positive integer n)
Local variables:
integers i, j
	
i = 1
	
j = x
	
while i ∙ n do
	
	
j = j ∗ (i + 1)
	
	
i = i + 1 
	
end while
	
//j now has the value x ∗ n!
	
return j
end function AnotherOne
	 20.	Function to return the value of the polynomial anxn + an–1 xn–1 + g+ a1x + a0 at a given value of x.
Polly (real an; … ; real a0; real x)
Local variables:
integers i, j
	
i = n
	
j = an
	
while i ∙ 0 do
	
	
j = j ∗ x + ai–1
	
	
i = i – 1
	
end while
	
//j now has value of the polynomial evaluation
	
return j
end function Polly
	 21.	Function to return the maximum value from the first n entries a[1], a[2], … , a[n], n ≥ 1, in an array of 
distinct integers.
ArrayMax (integers n, a[1], a[2], … , a[n])
Local variables:
integers i, j
	
i = 1

	
	
Section 2.3   More on Proof of Correctness	
141
	
j = a[1]
	
while i ∙ n do
	
	
i = i + 1
	
	
if a[i] > j then j = a[i]
	
end while
	
//j now has the value of the largest array element
	
return j 
end function ArrayMax
	 22.	Following are four functions intended to return the value a[1] + a[2] + g+ a[n] for n ≥ 1 (the sum of 
the first n entries in an array of integers). For those that do not produce correct results, explain what goes 
wrong. For those that do produce correct results, do a proof of correctness.
	
a.	 ArraySumA (integers n, a[1], a[2], … , a[n])
Local variables:
integers i, j
	
i = 0
	
j = 0
	
while i ≤ n do
	
	
i = i + 1
	
	
j = j + a[i]
	
end while
	
//j now has the value a[1] + a[2] + g+ a[n]
	
return j
end function ArraySumA
	
b.	ArraySumB (integers n, a[1], a[2], … , a[n])
Local variables:
integers i, j
	
i = 1
	
j = 0
	
while i ≤ n do
	
	
j = j + a[i]
	
	
i = i + 1
	
end while
	
//j now has the value a[1] + a[2] + g+ a[n] 
	
return j
end function ArraySumB
	
c.	 ArraySumC (integers n, a[1], a[2], … , a[n])
Local variables:
integers i, j
	
i = 0
	
j = 0
	
while i ≤ n do
	
	
j = j + a[i]
	
	
i = i + 1
	
end while
	
//j now has the value a[1] + a[2] + g+ a[n]
	
return j
end function ArraySumC

142	
Proofs, Induction, and Number Theory 
	
d.	ArraySumD (integers n, a[1], a[2], … , a[n])
Local variables:
integers i, j
	
i = 1
	
j = a[1]
	
while i ≤ n do
	
	
j = j + a[i + 1]
	
	
i = i + 1
	
end while
	
//j now has the value a[1] + a[2] + g+ a[n] 
	
return j
end function ArraySumD
Exercises 23–28 concern a variation of the Euclidean algorithm more suited to computer implementation. The 
original GCD algorithm relies on repeated integer divisions to compute remainders. The following variation, 
called the binary GCD algorithm, also uses divisions, but only by 2, plus subtraction and testing for parity (odd-
ness or evenness). Given that the numbers are stored in the computer in binary form, these operations are simple 
and often done using built-in circuits. Testing for even/odd can be done using bitwise conjunction of N & 1, 
which results in 1 if and only if N is odd. Given an even N, division by 2 is easily accomplished by a 1-bit right 
shift operation, where all bits are shifted one place to the right (the rightmost bit disappears), and the leftmost 
bit is set to 0. (Multiplication by 2 is a 1-bit left shift.) Subtraction involves the 2’s complement. As a result, the 
binary gcd algorithm, which avoids regular division, runs faster than the Euclidean algorithm, even though it 
does more (but simpler) steps. The binary GCD algorithm relies on three facts:
	
1.	If both a and b are even, then gcd(a, b) = 2gcd(a/2, b/2).
	
2.	If a is even and b is odd, then gcd(a, b) = gcd(a/2, b).
	
3.	If a and b are both odd, and a ≥ b, then gcd(a, b) = gcd((a − b)/2, b).
	 23.	To prove that if both a and b are even, then gcd(a, b) = 2gcd(a/2, b/2), let a and b be even integers. Then 
2 is a common factor of both a and b, so 2 is a factor of gcd(a, b). Let 2c = gcd(a, b). Then
a = n(2c) and b = m(2c)
a/2 = nc and b/2 = mc
	
	 so c 0 a/2 and c 0 b/2. Finish this proof by showing that c = gcd(a/2, b/2).
	 24.	To prove that if a is even and b is odd, then gcd(a, b) = gcd(a/2, b), note that because b is odd, 2 is not a 
factor of b, hence not a factor of gcd(a, b). Therefore all contribution to gcd(a, b) comes from b and a/2, 
and gcd(a, b) = gcd(a/2, b). Write an equation for gcd(a, b) when a is odd and b is even.
	 25.	We want to prove that if a and b are both odd, and a ≥ b, then gcd(a, b) = gcd((a − b)/2, b). If a and 
b are both odd and a ≥ b, then gcd(a, b) = gcd(a − b, b) because, from the regular Euclidean algorithm,  
gcd(a, b) begins with a = qb + r, 0 ≤ r < b and gcd(a − b, b) begins with a – b = (q − 1)b + r, 0 ≤ r < b. 
The next step in either case is to divide b by r, so the two final answers will be the same. Finish this proof 
by showing that gcd(a − b, b) = gcd((a – b)/2, b).

	
	
Section 2.4   Number Theory	
143
	 26.	To find gcd(420, 66) using the binary GCD algorithm takes the following steps (compare with Example 27). 
You can do these steps in your head!
420
66
Fact 1
Save the 2 factor to multiply at the end
210
33
Fact 2
105
33
Fact 3
36
33
Fact 2
18
33
Fact 2
9
33
Fact 3
[Because gcd(a, b) = gcd(b, a), it doesn’t matter whether the 
larger number is first or second or whether the even number is 
first or second.]
9
12
Fact 2
9
6
Fact 2
9
3
Fact 3
3
3
Fact 3
0
3
	
	 One number is now 0, so the other number is a factor in the gcd, therefore gcd(420, 66) = 2*3 = 6 (the 
factor of 2 comes from the very first step).
	
	 Use the binary GCD algorithm to find gcd(24, 20).
	 27.	Use the binary GCD algorithm to find gcd(308, 165) [see Exercise 7].
	 28.	Use the binary GCD algorithm to find gcd(2420, 70) [see Exercise 8].
	
S e c t i o n  2 . 4 	 Number Theory
In Section 2.1 we proved several elementary number theory results, such as “The 
product of two even integers is even.” These proofs relied on basic definitions and 
the standard proof techniques (direct proof, proof by contraposition, and proof by 
contradiction). Now that we have some additional ammunition, we can prove more 
number theory results. Number theory is fun because conjectures can be stated 
easily—after all, only integers are involved—yet sometimes it can be quite dif-
ficult to prove. As an extreme case, Fermat’s last theorem states that there are no 
positive integers x, y, and z for which
xn + yn = zn
for any integer n > 2. (There are solutions for n = 2, such as 32 + 42 = 52.) Pierre 
de Fermat stated this result around 1637 but—although many false “proofs” were 
published in the interim—it took until 1995 before a proof was found, using very 
complicated mathematics, by Dr. Andrew Wiles of Princeton University. We are 
interested in number theory, however, because of its usefulness in computer secu-
rity (see Section 5.6).

144	
Proofs, Induction, and Number Theory 
The Fundamental Theorem of Arithmetic
We’ll start by expanding on a result we proved using the second principle of math-
ematical induction in Example 23, Section 2.2: For every integer n ≥ 2, n is a 
prime number or a product of prime numbers.
In fact, a stronger statement can be made.
	
Theorem	
The Fundamental Theorem of Arithmetic
For every integer n ≥ 2, n is a prime number or can be written uniquely (ignoring 
ordering) as a product of prime numbers.
The new part is that there is only one way to factor a composite number 
into prime factors if we ignore the order in which we write the factors. Thus we 
consider
2(3)(3) = 3(2)(3)
to be the same factorization of 18. We intuitively accept the uniqueness idea—
how else could you factor 18 into prime factors? A formal proof requires quite a 
bit of preparation, and it begins with revisiting the idea of the greatest common 
divisor of two positive integers.
The Euclidean algorithm to find gcd(a, b) was given in Section 2.3. It turns out 
that if a and b are positive integers, then gcd(a,b) can always be written as a linear 
combination of a and b; that is,
gcd(a, b) = ia + jb for some integers i and j
Although it’s easy to verify in Example 29 that 3(420) − 19(66) indeed has the 
value 6, the coefficient values of 3 and −19 seem mysterious. They are not just 
pulled out of the air, however; in fact they are derived from the successive divi-
sions done by the Euclidean algorithm.
REMINDER
A prime number is an 
integer > 1 that is divisible 
only by itself and 1.
	
EXAMPLE 29	
In Section 2.3 we learned, using the Euclidean algorithm, that gcd(420, 66) = 6. 
And 6 can be written as a linear combination of 420 and 66:
6 = 3(420) − 19(66)
	
EXAMPLE 30	
The successive divisions performed by the Euclidean algorithm in finding  
gcd(420, 66) can be written as follows (see Example 27 in Section 2.3):
 420 = 6 # 66 + 24
 66 = 2 # 24 + 18
 24 = 1 # 18 + 6
 18 = 3 # 6 + 0

	
	
Section 2.4   Number Theory	
145
The Euclidean algorithm gives us a way to express gcd(a, b) as a linear combi-
nation of a and b, but there is another way to characterize this linear combination.
	
Theorem	
On gcd(a, b)
Given positive integers a and b, gcd(a, b) is the linear combination of a and b 
that has the smallest positive value.
To prove this result, we need to make use of the principle of well-ordering 
that we mentioned in Section 2.2, namely, that every collection of positive inte-
gers that contains any members at all has a smallest member. The collection we 
have in mind consists of all positive linear combinations of a and b, and certainly 
such numbers exist (as a trivial example, 1 # a + 1 # b). By the principle of well-
ordering, there is a least such number c = ia + jb where i and j are integers. The 
theorem claims that c = gcd(a, b), that is, that c 0 a, c 0 b, and c is the largest integer 
that divides both a and b.
To prove that c 0 a, we’ll use a proof by contradiction. Suppose c  |  a. Then 
when we divide a by c there is a nonzero remainder
a = mc + r          with m an integer and 0 < r < c
Rewriting this equation,
 r = a −mc
 = a −m(ia + jb)
 = (1 −mi)a −(mj)b
which makes r a positive linear combination of a and b, that is, r is a member of 
our collection, but r < c, which is a contradiction because c was the least member 
of this collection. Therefore c 0 a. In the same way we can show that c 0 b. Conse-
quently c is a common divisor of a and b; by Practice 11, c is the greatest common 
divisor of a and b, which completes the proof of the theorem.
Rewriting the first three equations from the bottom up,
 6 = 24 −1 # 18
 18 = 66 −2 # 24
 24 = 420 −6 # 66
Now we use these equations in a series of substitutions:
 6 = 24 −1 # 18 = 24 −1 # (66 −2 # 24)  (substituting for 18)
 = 3 # 24 −66
 = 3 # (420 −6 # 66) −66  (substituting for 24)
 = 3 # 420 −19 # 66
which reveals the linear combination of 420 and 66 that gives the value 6.

146	
Proofs, Induction, and Number Theory 
Recall that a prime number is an integer p > 1 that is not divisible by any 
integers other than 1 and p. If a is an integer that is a multiple of a prime p, 
then clearly p 0 p and p 0 a, so gcd(a, p) = p. But if a is not a multiple of p, then  
gcd(a, p) = 1 because nothing else divides p. Therefore all integers are either 
­multiples of p or are relatively prime to p.
Suppose that p is a prime number that divides the product ab of integers a and b. 
Because p is “irreducible,” p must divide either a or b. More formally, if p does not 
divide a, that is, a is not a multiple of p, then a is relatively prime to p, gcd(a, p) = 1, 
and there exist integers i and j such that
1 = ia + jp 
Multiplying this equation by b,
b = (ia)b + ( jp)b = i (ab) + ( jp)b
Because p 0 ab, ab can be written as kp, where k is an integer, so the previous 
­equation becomes
b = i(kp) + ( jp)b = (ik + jb)p    ik + jb an integer
so that p 0 b. This proves the following theorem.
	
Theorem	
On Division by Prime Numbers
Let p be a prime number such that p 0 ab where a and b are integers. Then either  
p 0 a or p 0 b.
Practice 11	
a.	 Prove that if d is a positive integer such that d 0 a and d 0 b, then d 0 c, where c = ia + jb.
b.	Prove that if d 0 c, then c ≥ d.
■
Practice 12	 The integers 21 and 16 are relatively prime. Find i and j such that i (21) + j(16) = 1.
■
Practice 13	 Extend the theorem on division by prime numbers as follows: Let p be a prime num-
ber such that p 0 a1a2 … ak where each ai is an integer. Then p 0 aj for some j, 1 ≤ j ≤ k.  
(Hint: You want to prove that this is true for every positive integer k—What proof technique 
should you use?)
■
	
Definition	
Relatively Prime
Two integers a and b are relatively prime if gcd(a, b) = 1.
From the theorem on gcd(a, b), it follows that a and b are relatively prime if 
and only if there exist integers i and j such that
ia + jb = 1

	
	
Section 2.4   Number Theory	
147
Finally we are ready to prove that the factorization of a composite number 
n > 2 into prime factors is unique (save for ordering). If n is a composite number, 
then n can be written as a product of primes:
n = p1 p2 gpr         where p1 ≤ p2 ≤ g≤ pr and each pi is a prime number
Now suppose that n can also be written as
n = q1q2 cqs         where q1 ≤ q2 ≤ g≤ qs and each qi is a prime number
Then
p1 p2 cpr = q1q2 cqs
We are assuming that these two representations are different, but they might still 
have some factors in common on both sides of the equation; let’s assume these 
have been divided out. Then
p1 0 p1 p2 cpr
so
p1 0 q1q2 cqs
By Practice 13, p1 0 qi for some i, 1 ≤ i ≤ s. However, qi is a prime number, divis-
ible only by itself and 1, which would mean that p1 = qi. This is a contradiction 
because we already eliminated common factors.
	
EXAMPLE 31	
To find the unique factorization of 825 as a product of primes, we can start by 
simply dividing 825 by successively larger primes (2, 3, 5, and so on).
2  |  825
825 = 3 # 275 = 3 # 5 # 55 = 3 # 5 # 5 # 11 = 3 # 52 # 11
Similarly,
455 = 5 # 7 # 13
From these factorizations we can see that gcd(825, 455) = 5. Decomposing two 
positive integers into their respective prime number factorizations is another way 
(besides the Euclidean algorithm) to determine their greatest common divisor.
Practice 14	 Find the unique factorization of 1176 as a product of primes.
■
Practice 15	 Find gcd(420, 66) by unique factorization into products of primes (see Example 27).
■

148	
Proofs, Induction, and Number Theory 
We have now completed the proof of the fundamental theorem of arithmetic. 
Note, however, that this is an existence result. It says that for any integer n ≥ 2 
that is not prime, there exists a unique factorization as a product of primes. But 
this does not tell us
	
a.	 how to decide whether n is prime.
	
b.	 if n is not prime, how to find the prime factors of n.
Neither of these problems has an efficient algorithmic solution. The approach in 
Example 31 of dividing a number n by successively larger primes accomplishes 
both tasks—if there are prime factors of n, they will be discovered and if there 
are none, then n is prime. However, this approach becomes very labor intensive 
when n is large.
More on Prime Numbers
Anything with a title as imposing as the fundamental theorem of arithmetic must 
be fairly important. We can use this theorem to discover several more results 
about prime numbers.
Given a positive integer n, suppose we test for prime factors by dividing n by 
successively larger primes. Clearly we can stop with the largest prime less than or 
equal to n, but in fact we can stop with the largest prime less than or equal to !n. 
If n can be factored in a nontrivial way as n = st, then s and t cannot both be greater 
than !n because then their product would be greater than n. Therefore one of s 
and t, let’s say s, must be less than or equal to.!n. By the fundamental theorem of 
arithmetic, s is either prime or can be written as a product of primes. In either case, 
there is a prime factor less than or equal to !n, which proves the following theorem.
	
Theorem	
On Size of Prime Factors
If n is a composite number, then it has a prime factor less than or equal to !n.
	
EXAMPLE 32	
Given n = 1021, let’s find the prime factors of n or determine that n is prime. The 
value of !1021 is just less than 32. So the primes we need to test are 2, 3, 5, 7, 11, 
13, 17, 19, 23, 29, 31. None divides 1021, so 1021 is prime.
How many prime numbers are there? An infinite number.
	
Theorem	
On Infinity of Primes (Euclid)
There is an infinite number of prime numbers.
Proof: Assume that there is a finite number of primes, listed as p1, p2, … , pk . 
Consider the number s = p1 p2 cpk + 1. The integer s is greater than any of the 
primes p1, … , pk , which we assumed is the total list of primes, therefore s is not 
prime. Thus s is composite and, by the fundamental theorem of arithmetic, s can 
be factored as a product of (some of) the prime numbers. Suppose that pj is one of 
the prime factors of s, that is, s = pj (m) for some integer m. Then
1 = s − p1p2 cpk = pj(m) − p1 cpk = pj(m − p1 cpj−1 pj+1 cpk)
Therefore pj 0 1, which is a contradiction. End of Proof

	
	
Section 2.4   Number Theory	
149
Although Euclid’s theorem says that there is always another prime number 
ahead as we march through the positive integers, the distribution of primes among 
the integers is erratic. Contrary to what one might think, the primes do not get 
farther and farther apart. Even among the small primes, 23 and 29 are farther 
apart than 29 and 31.
	
EXAMPLE 33	
In Example 11, we did a proof by contradiction that !2 is not a rational number. 
The same argument works for !3 and !5 (2, 3, and 5 are all prime numbers).
We can generalize this result from a single prime to any integer x that is the 
product of an odd number of primes. Assume that by the fundamental theorem of 
arithmetic, x = p1p2 c p2k+1 (In this example, we are not using any exponents, so 
some of these primes could be identical; that is, 75 = 3*5*5). Again doing a proof 
by contradiction, assume that !p1p2 c p2k+1 = a/b where a and b are integers, 
b ∙0, and a and b are relatively prime. Then
p1p2 c p2k+1 = a2
b2
a2 = p1p2 c p2k+1b2
By the fundamental theorem, a can be written as a product of one or more primes, 
but a2 will add another factor of each of a’s primes, resulting in a product of an even 
number of primes. Similarly, b2 is the product of an even number of primes. Therefore 
p1 p2 c p2k+1b2 is the product of an odd number and an even number (which gives 
an odd number) of prime factors. Contradiction: a2 has an even number of prime 
factors while p1 p2 c p2k+1b2 has an odd number of prime factors, yet by the fun-
damental theorem, factorization is unique.
The search for prime numbers and information about primes has generated 
much interest. As of June 2013, the largest known prime number is 257,885,161 − 1, 
which is a number with 17,425,170 decimal digits. If we consider that for a reason-
able type size it takes about 1 inch to print 10 digits, then it would take more than 
27 miles just to print out a number of this size!
One of the oldest conjectures about prime numbers—still unsolved—is Gold-
bach’s conjecture, formulated in 1742: Every even integer greater than 2 is the 
sum of two prime numbers.
Euler Phi Function
	
Definition	
Euler phi function
For n an integer, n ≥ 2, the Euler phi function of n, φ(n), is the number of posi-
tive integers less than or equal to n and relatively prime to n. (φ(n) is pronounced 
“fee” of n.)

150	
Proofs, Induction, and Number Theory 
Notice that n will never be relatively prime to n, so this definition could have 
been stated as, “the number of positive integers less than n and relatively prime to 
n,” but it turns out to be convenient to include equality.
For small n, it is easy to compute φ(n) by a brute-force approach of just try-
ing values < n to find how many are relatively prime to n. But there is actually a 
formula to compute φ(n), which we’ll derive now.
	
EXAMPLE 34	
The first few values of φ(n), together with the numbers that give those values, are
 φ(2) = 1 (the number 1)
 φ(3) = 2 (the numbers 1, 2)
 φ(4) = 2 (the numbers 1, 3)
 φ(5) = 4 (the numbers 1, 2, 3, 4)
 φ(6) = 2 (the numbers 1, 5)
 φ(7) = 6 (the numbers 1, 2, 3, 4, 5, 6)
Practice 16	 If p is a prime number, prove that φ (p) = p − 1.
	
EXAMPLE 35	
Using the fundamental theorem of arithmetic, write the positive integer n in its 
factored form as a product of primes, where if the same prime p occurs m times, it 
is written as pm. Suppose, for example, that
n = pm1
1 pm2
2 pm3
3
To compute φ(n), we’ll count all the positive integers ≤ n, of which there are n, 
and throw out those that are not relatively prime to n, Now let Ai , 1 ≤ i ≤ 3, be 
defined as the collection of all positive integral multiples of pi that are ≤ n; these 
numbers share a common factor of pi with n and so are not relatively prime to n. 
The integral multiples of pi that are ≤ n are pi, 2pi, 3pi, … , n. How many numbers 
are in this list? Exactly the number of times you can divide n by pi, or n/pi. So, 
denoting the size of Ai by 0 Ai 0, we know that 0 Ai 0 = n/pi. If we combine A1, A2, and 
A3, that will be all integers ≤ n that are not relatively prime to n. How many such 
integers are there? We can’t just add 0 A1 0 + 0 A2 0 + 0 A3 0 = n/p1 + n/p2 + n/p3 because 
there could be some numbers that appear in more than one of the three collec-
tions, and would therefore be counted twice. Numbers that appear in both Ai and 
Aj , i ∙ j, are integral multiples of both pi and pj, so there will be n/(pi  pj) of them. 
We’ll subtract those for all i, j combinations. But by doing this, we have subtracted 
any numbers in all three collections three times, which means they now are not 
counted at all, so we have to add back the n/(p1 p2  p3) numbers that are in all three 
collections.2 Therefore
2This lengthy discussion is an instance of the principle of inclusion and exclusion, discussed in Chapter 4.
■

	
	
Section 2.4   Number Theory	
151
 φ(n) = n −a n
p1
+ n
p2
+ n
p3
−
n
p1 p2
−
n
p2 p3
−
n
p1 p3
+
n
p1 p2 p3b
	
= na1 −1
p1
−1
p2
−1
p3
+
1
p1 p2
+
1
p2 p3
+
1
p1 p3
−
1
p1 p2 p3b
	
= nap1 p2 p3 −p2 p3 −p1  p3 −p1 p2 + p3 + p1 + p2 −1
p1  p2 p3
b     (adding  
fractions)
	
= na( p1 −1)( p2 −1)( p3 −1)
p1 p2 p3
b     (check this by multiplying out the 
numerator)
	
=
n
p1 p2 p3
 ( p1 −1)( p2 −1)( p3 −1)
	
= pm1−1
1
pm2−1
2
pm3−1
3
φ(p1)φ(p2)φ(p3)
(1)
Equation (1) expresses φ(n) in terms of the Euler phi function of its prime factors, 
which are known to us (see Practice 16).
Equation (1) in Example 34 gives the formula for φ(n) where n has 3 distinct 
prime factors. It is easy to extend this equation to the more general case where n 
has an arbitrary number of prime factors. If
n = pm1
1 pm2
2  c pmk
k
then
	
φ(n) = pm1−1
1
pm2−1
2
 c pmk−1
k
3φ(p1)φ(p2) c φ(pk)4
(2)
	
EXAMPLE 36	
For n = 133848 = 23 # 32 # 11 # 132,
φ(n) = 22 # 3 # 133φ(2)φ(3)φ(11)φ(13)4 = 4 # 3 # 1331 # 2 # 10 # 124 = 37440
Practice 17	 For n = 34 # 5 # 72, compute φ(n).
■
Equation (2) requires that we know the prime factorization of n, so it does not 
avoid the difficulty we noted earlier of factoring large values of n.

152	
Proofs, Induction, and Number Theory 
Techniques
•	 Write the gcd(a, b) as a linear combination of a and b.
•	 Test whether a given positive integer is prime or, if 
not, find its prime factorization.
•	 Compute the Euler phi function φ(n) for a positive 
integer n.
Main Ideas
•	 Every integer ≥ 2 is prime or can be uniquely fac-
tored into prime numbers (fundamental theorem of 
arithmetic).
•	 Two integers a and b are relatively prime if a linear 
combination of a and b can be found that equals 1.
•	 If n is not prime, it has a prime factor no greater 
than !n.
•	 An infinite number of prime numbers exist.
•	 There is no efficient algorithm to decide whether a 
positive integer n is prime, or to find the prime fac-
tors of n if n is not itself prime. 
•	 Given n written as a product of primes, there is a 
formula to compute φ(n), the number of positive 
integers ≤ n and relatively prime to n.
Exercises 2.4
Exercises 1–6 refer to Exercises 7–12 in Section 2.3
	 1.	 Write gcd(308, 165) as a linear combination of 308 and 165.
	 2.	 Write gcd(2420, 70) as a linear combination of 2420 and 70.
	 3.	 Write gcd(735, 90) as a linear combination of 735 and 90.
	 4.	 Write gcd(8370, 465) as a linear combination of 8370 and 465.
	 5.	 Write gcd(1326, 252) as a linear combination of 1326 and 252.
	 6.	 Write gcd(1018215, 2695) as a linear combination of 1018215 and 2695.
For Exercises 7–12, test whether n is prime and, if not, find its decomposition as a product of primes.
	 7.	 n =  1729
	 8.	 n = 1789
	 9.	 n = 1171
	 10.	n = 1177
	 11.	n = 8712
	 12.	n = 29575
Exercises 13–18 refer to Exercises 7–12 in Section 2.3
	 13.	Find gcd(308, 165) by unique factorization into products of primes.
	 14.	Find gcd(2420, 70) by unique factorization into products of primes.
	 15.	Find gcd(735, 90) by unique factorization into products of primes.
	 16.	Find gcd(8370, 465) by unique factorization into products of primes.
	 17.	Find gcd(1326, 252) by unique factorization into products of primes.
	 18.	Find gcd(1018215, 2695) by unique factorization into products of primes.
	 19.	The least common multiple of two positive integers a and b, lcm(a, b) is the smallest integer n such that  
a 0 n and b 0 n. Like the gcd(a, b), the lcm(a, b) can be found from the prime factorizations of a and b.  
Describe (in words) the gcd and the lcm in terms of the prime factors of a and b.
	 20.	Prove that for any positive integers a and b, a # b = gcd(a, b) # lcm(a, b). (Hint: consider both a and b in 
their factored form as a product of primes.)
S e c t i o n  2 . 4 	 Review
W

	
	
Section 2.4   Number Theory	
153
For Exercises 21–24, find the gcd and lcm of the two numbers given.
	 21.	a = 22 # 3 # 11, b = 2 # 3 # 112 # 13
	 22.	a = 24 # 52 # 73, b = 5 # 72
	 23.	a = 3 # 53 # 112, b = 32 # 5 # 11 # 17
	 24.	a = 5 # 11 # 232, b = 53 # 113
	 25.	Prove that for any positive integers a and b, gcd(a, b) = gcd(a, a + b).
	 26.	Prove that gcd(n, n + 1) = 1 for all positive integers n.
	 27.	Find an example where n 0 ab but n  |  a and n  |  b. Does this violate the theorem of division by prime 
numbers?
	 28.	The division of a full circle into 360° probably dates back to the early Persian calendar from around 
700 b.c. that used 360 days in a year, so one day represented a rotation of 1/360 of other stars around the 
North Star. But it was also chosen because it is divisible by so many factors, avoiding the need to deal with 
fractions. Find the distinct nontrivial (but not necessarily prime) factors of 360.
	 29.	Prove that there exist three consecutive odd positive integers that are prime numbers.
	 30.	Prove that for any positive integer n, there exist n consecutive composite numbers. [Hint: Start with 
(n + 1)! + 2]
For Exercises 31–34, find φ(n) together with the numbers that give those values.
	 31.	n = 8
	 32.	n = 9
	 33.	n = 10
	 34.	n = 11
	 35.	By Practice 16, if p is prime then φ(p) = p − 1. Prove that this is an “if and only if” condition by proving 
that if φ(n) = n – 1 for a positive integer n > 1, then n is prime.
	 36.	For any prime number p and any positive integer k, φ(pk) = pk−1φ(p). Although this result follows directly 
from Equation (2) in this section, give a direct proof using the definition of the Euler phi function.
	 37.	Compute φ(24) and state the numbers being counted. (Hint: See Exercise 36.)
	 38.	Compute φ(33) and state the numbers being counted. (Hint: See Exercise 36.)
For Exercises 39–42, compute φ(n).
	 39.	n = 117612 = 22 # 35 # 112
	 40.	n = 233206 = 2 # 17 # 193
	 41.	n = 1795625 = 54 # 132 # 17
	 42.	n = 1,690,541,699 = 74 # 113 # 232 
	 43.	If p and q are prime numbers with p ≠ q, then φ(pq) = φ(p)φ(q). Although this result follows directly 
from Equation (2) in this section, give a direct proof using the definition of the Euler phi function.
	 44.	Prove that if r and s are relatively prime, then φ(rs) = φ(r) φ(s).
	 45.	Prove that for n and m positive integers, φ(nm) = nm−1φ(n).
	 46.	Except for n = 2, all the values of φ(n) in Example 34 are even numbers. Prove that φ(n) is even for all 
n > 2.
	 47.	A particular class of prime numbers is known as Mersenne primes, named for a French monk and math-
ematician of the seventeenth century who studied them. Mersenne primes are numbers of the form 2p − 1 
where p is a prime, but not all numbers of this form are primes. For example, 211 − 1 = 23 # 89 is not 

154	
Proofs, Induction, and Number Theory 
prime. The largest known prime number as of June 2013 is 257,885,161 − 1, a Mersenne prime. There hap-
pens to be a particularly efficient algorithm for testing numbers of the form 2p − 1 for primality, which is 
why almost all of the largest known primes are Mersenne primes. In recent years, most of these Marsenne 
primes have been discovered (and verified) by the GIMPS (Great Internet Mersenne Prime Search) dis-
tributed computing project, a worldwide group of volunteers who collaborate over the Internet to test for 
Mersenne primes.
	
	 Find the first 4—the 4 smallest—Mersenne primes.
	 48.	Goldbach’s conjecture states that every even integer greater than 2 is the sum of two prime numbers. 
Verify Goldbach’s conjecture for
	
a.	 n = 8
	
b.	n = 14
	
c.	 n = 28
	 49.	A perfect number is a positive integer n that equals the sum of all divisors less than n. For example, 6 is a 
perfect number because 6 = 1 + 2 + 3. Perfect numbers are related to Mersenne primes (see Exercise 47) 
in that if p is a prime and 2p − 1 is a prime, then 2p−1(2p − 1) is a perfect number. (This result was proved 
by Euclid around 300 b.c.). For example, 6 = 21(22 − 1).
	
a.	 Prove that 28 is a perfect number by writing it as the sum of its divisors. 
	
b.	Write 28 in the form 2p−1(2p − 1).
	 50.	a.	 Prove that 496 is a perfect number (see Exercise 49) by writing it as the sum of its divisors.
	
b.	Write 496 in the form 2p−1(2p − 1).
	 51.	An algorithm exists to find all prime numbers less than some given positive integer n. This method, called 
the Sieve of Eratosthenes, was discovered by Eratosthenes, a student of Plato. To carry out this algorithm, 
list all integers from 1 through n − 1. Then make repeated passes through the list, on the first pass crossing 
out all multiples of 2 that are greater than 2. On the second pass cross out all multiples of 3 that are greater 
than 3. On the next pass, cross out all multiples of 5 that are greater than 5, and so forth for all primes less 
than !n. The numbers remaining when this process terminates are the primes less than n. Use the Sieve 
of Eratosthenes to find all prime numbers less than 100.
	 52.	a.	 Compute the square of 11.
	
b.	Compute the square of 111.
	
c.	 Prove that any n-digit number consisting of all 1’s, when squared, produces the number 	
 
123 … (n − 1)n(n − 1) … 321. A number that reads the same forward and backward is called a  
palindrome.
	 53.	Sudoku puzzles are popular number-based puzzles. A game con-
sists of a 9 × 9 grid made up of nine 3 × 3 blocks. Each row 
and each column of the game must contain exactly one of the 9 
digits 1 − 9; ­furthermore, each 3 × 3 block must contain exactly 
one of the digits 1 through 9. Following is a sample puzzle, used 
by permission from Web Sudoku at http://www.websudoku.com, 
where you can generate puzzles at any of four levels of difficulty. 
Try completing this puzzle.
2
2
2
2
2
2
5
5
5
5
3
3
3
3
8
8
8
8
8
9
9
9
4
4
4
4
6
1
1
1
1
7
7
7
7

	
	
Chapter 2   Review	
155
C h a p t e r  2 	
Review
Terminology
absolute value (p. 107)
basis step (p. 111)
composite number (p. 107)
contrapositive (p. 103)
converse (p. 103)
counterexample (p. 99)
deductive reasoning (p. 99)
direct proof (p. 101)
divides (p. 107)
Euclidean algorithm  
(p. 133)
Euler phi function (p. 149)
even number (p. 101)
Fermat’s last theorem (p. 143)
first principle of mathematical 
­induction (p. 111)
fundamental theorem of arithmetic 
(p. 144)
greatest common divisor (p. 133)
inductive assumption (p. 112)
inductive hypothesis (p. 112)
inductive reasoning (p. 99)
inductive step (p. 111)
linear combination (p. 144)
loop invariant (p. 130)
loop rule of inference (p. 131)
n factorial (p. 99)
number theory (p. 107)
odd number (p. 101)
partial correctness (p. 132)
perfect square (p. 107)
prime number (p. 107)
proof by cases (p. 104)
proof by contradiction (p. 104)
proof by contraposition (p. 103)
proof by exhaustion (p. 100)
rational number (p. 105)
relatively prime (p. 146)
second principle of mathematical 
induction (p. 118)
well-ordering principle (p. 119)
Section 2.1
1.	A conjecture can never be proved merely by prov-
ing a finite number of cases.
2.	A proof by contradiction of P S Q begins by as-
suming both P and Q′.
3.	In the statement of the theorem, “twice an odd inte-
ger is even,” an existential quantifier is understood.
4.	 To prove the conjecture, “If Laramie is the capital, 
then Wyoming is the state,” it is sufficient to prove, 
“If Wyoming is the state, then Laramie is the capital.”
5.	To prove, “A if and only if B,” requires a proof of 
A S B and a proof of B S A.
Section 2.2
1.	Induction is an appropriate proof technique for 
proving a statement about all the positive integers.
2.	The basis step of an inductive proof requires prov-
ing a property true for n = 1.
3.	If the truth of P(k + 1) depends on the truth of 
other previous values besides P(k), then the second 
principle of induction should be used.
4.	The key to a proof by the first principle of induc-
tion is to see how the truth of P at the value k + 1 
depends on the truth of P at value k.
5.	The equation k3 = k2(k+1)2/4 is the inductive hy-
pothesis in an inductive proof of the statement 
13 + 23 + c+ n3 = n2(n + 1)2∕4
Section 2.3
1.	A loop invariant remains true until the loop is ex-
ited, at which point it becomes false.
2.	Partial correctness of a loop statement in a program 
means that the loop behaves correctly for some in-
put values but not for others.
3.	The second principle of induction is used to prove 
loop invariants because the loop can be executed an 
arbitrary number of times.
4.	If a loop statement has the form
while (condition B)
	
P
end while
	
then the loop invariant Q will be B′.
5.	When computing the gcd(42, 30) by the Euclidean 
algorithm, the computation of dividing 30 by 12 is 
carried out.
Section 2.4
1.	gcd(a,b) can always be written as a linear combina-
tion of a and b.
2.	Two integers a and b are relatively prime if there 
exist integers i and j such that ia + jb = p where p 
is a prime number.
3.	If a positive integer n is not a prime number, then it 
has at least one prime factor > !n.
4.	φ(n) is a prime number for any integer n ≥ 2.
5.	φ( p) = p − 1 for any prime number p.
Self-Test
Answer the following true-false questions without looking back in the chapter.

156	
Proofs, Induction, and Number Theory 
For Exercises 1–5, write a computer program that pro-
duces the desired output from the given input.
1.	Input: Number n of terms in a geometric progres-
sion (see Exercise 27, Section 2.2), the initial term 
a, and the common ratio r
	
Output: Sum of the first n terms using
a.	 iteration
b.	 formula of Exercise 27, Section 2.2
2.	Input: Number n of terms in an arithmetic progres-
sion (see Exercise 28, Section 2.2), the initial term 
a, and the common difference d
Output: Sum of the first n terms using
a.	 iteration
b.	 formula of Exercise 28, Section 2.2
3.	Input: Number n
Output: Sum of the first n cubes using
a.	 iteration, using only multiplication and addi-
tion; output the number of multiplications and 
additions used
b.	 formula of Exercise 8, Section 2.2, using only 
multiplication, addition, and division; output 
the number of multiplications, additions, and 
divisions used
4.	Input: None
Output: Table showing every integer n, 8 ≤ n ≤ 100, 
as the sum of 3s and 5s (see Example 24)
5.	Input: Value for n
Output: Value for φ(n)
6.	The formula 4n < n! is true for all n ≥ N. Write a 
program to determine N and then prove the result 
by induction.
7.	The formula 2n > n3 is true for all n ≥ N. Write a 
program to determine N and then prove the result 
by induction.
O n  t h e  C o m p u t e r

Chapter Objectives
After studying this chapter, you will be able to:
•	 Understand recursive definitions of sequences, collections of objects, and op-
erations on objects.
•	 Write recursive definitions for certain sequences, collections of objects, and 
operations on objects.
•	 Understand how recursive algorithms execute.
•	 Write recursive algorithms to generate sequences defined recursively.
•	 Find closed-form solutions for certain types of recurrence relations.
•	 Analyze algorithms by counting the number of executions of a basic unit of 
work, either directly or by solving a recurrence relation.
You are serving on the city council’s Board of Land Management, which is consider-
ing a proposal by a private contractor to manage a chemical disposal site. The mate-
rial to be stored at the site degrades to inert matter at the rate of 5% per year. The 
contractor claims that, at this rate of stabilization, only about one-third of the original 
active material will remain at the end of 20 years.
	
Question:	
Is the contractor’s estimate correct?
It is possible to check this estimate by doing some brute-force calculations: If 
there is this much initially, then there will be that much next year, so much the fol-
lowing year, and so on through the 20 years. But a quick and elegant solution can 
be obtained by solving a recurrence relation; recurrence relations are discussed in 
Section 3.2.
Section 3.1 explores recursion, which is closely related to mathematical in-
duction (discussed in the previous chapter) and is important in expressing many 
definitions and even algorithms. Some sequences defined recursively can also 
be defined by a formula. Finding such a formula involves solving a recurrence 
relation; solution methods for several types of recurrence relations are devel-
oped in Section 3.2. Recurrence relations are an important tool in the analysis of 
algorithms, which mathematically determines the amount of work a particular 
algorithm must do. Analysis of algorithms is the topic of Section 3.3.
3
Recursion, Recurrence Relations, 
and Analysis of Algorithms
Chapter
157

158	
Recursion, Recurrence Relations, and Analysis of Algorithms
	
S e c t i o n  3 .1 	 Recursive Definitions
A definition in which the item being defined appears as part of the definition 
is called a recursive definition. At first this seems like nonsense—how can we 
define something in terms of itself? This works because there are two parts to a 
recursive definition:
	
1.	 A basis, where some simple cases of the item being defined are explicitly 
given
	
2.	 An inductive or recursive step, where new cases of the item being defined 
are given in terms of previous cases
Part 1 gives us a place to start by providing some simple, concrete cases;  
part 2 allows us to construct new cases from these simple ones and then to con-
struct still other cases from these new ones, and so forth. (This seems analogous 
to proofs by mathematical induction. In a proof by induction, there is a basis step, 
namely, to show that P(1)—or P at some other initial value—holds, and there is 
an inductive step where the truth of P(k + 1) is deduced from the truth of P at pre-
vious values. This similarity is why the term inductive definition is sometimes 
used instead of recursive definition.)
Recursion is an important idea that can be used to define sequences of ob-
jects, more general collections of objects, and operations on objects. (The Prolog 
predicate in-food-chain of Section 1.5 was defined recursively.) Even algorithms 
can be recursive.
Recursively Defined Sequences
A sequence S (an infinite sequence) is a list of objects that are enumerated in 
some order; there is a first such object, then a second, and so on. S(k) denotes 
the k th object in the sequence. The list goes on forever, so a sequence therefore 
consists of
S(1), S(2), … , S(k), …
Subscript notation is often used to denote the elements in a sequence, as in
S1 , S2 , … , Sk , …
The letter S is just a “dummy variable,” so a sequence could also be denoted by
a1 , a2 , … , ak , …     or     w1 , w2 , … , wk … 
and so forth.1
A sequence is defined recursively by explicitly naming the first value (or the 
first few values) in the sequence and then defining later values in the sequence in 
terms of earlier values.
1A more formal definition of a sequence is given in Chapter 5, Example 27.

Section 3.1   Recursive Definitions	
159
 
Example 1	
The sequence S is defined recursively by
 
1.	 S(1) = 2
	
2.	 S(n) = 2S(n − 1) for n ≥ 2
By statement 1, S(1), the first object in S, is 2. Then by statement 2, the second ob-
ject in S is S(2) = 2S(1) = 2(2) = 4. By statement 2 again, S(3) = 2S(2) = 2(4) = 8. 
Continuing in this fashion, we can see that S is the sequence
2, 4, 8, 16, 32, …
A rule like that of statement 2 in Example 1, which defines a sequence value 
in terms of one or more earlier values, is called a recurrence relation.
■
Practice 1	 The sequence T is defined recursively as follows:
1.	T(1) = 1
2.	T(n) = T(n − 1) + 3 for n ≥ 2
Write the first five values in the sequence T.
	
Example 2	
The Fibonacci sequence of numbers, introduced in the thirteenth century by an 
Italian merchant and mathematician, is defined recursively by
 F(1) = 1
 F(2) = 1
 F(n) = F(n −2) + F(n −1) for n > 2
Here the first two values of the sequence are given, and the recurrence relation 
defines the nth value for n > 2 in terms of the two preceding values. It’s best to 
think of the recurrence relation in its most general form, which says that F at any 
value—except 1 and 2—is the sum of F at the two previous values.
The Fibonacci sequence is famous because of its many interesting properties. 
Here is a small list (without proofs):
	
a.	 Every positive integer can be written uniquely as a sum of 1 or more dis-
tinct, nonconsecutive Fibonacci numbers. For example 11 = 3 + 8, where 
3 = F(4) and 8 = F(6).
	
b.	 gcd(F( p), F(q)) = F(gcd( p, q)). For example, if p = 6 and q = 9, then 
F(6) = 8, F(9) = 34, and gcd(8, 34) = 2. Also, gcd(6, 9) = 3 and F(3) = 2.
	
c.	 Every two consecutive Fibonacci numbers are relatively prime, that 
is, their greatest common divisor equals 1. As a result, the Euclidean 
­algorithm to find gcd(a, b) does the maximum amount of work when  
a and b are two consecutive Fibonacci numbers.
Practice 2	 Write the first eight values of the Fibonacci sequence.
■

160	
Recursion, Recurrence Relations, and Analysis of Algorithms
Other mathematical properties of the Fibonacci sequence are given in ­ 
Example  3 and in the exercises at the end of this section. But it’s not only 
­mathematicians who are interested in the Fibonacci sequence. Fibonacci num-
bers often occur in nature. The number of petals on a daisy is often a Fibonacci 
­number. Viewing a pine cone from its base, the seeds appear to be arranged in 
clockwise and counterclockwise spirals. Counting the number of each kind of 
spiral often gives two consecutive Fibonacci numbers (here 8 and 13). The same is 
true for seeds in flowers such as sunflowers, or for spirals on pineapples.
And in the worlds of art and architecture, the golden ratio is thought to create 
aesthetically pleasing proportions. The golden ratio is
1 + "5
2
≈1.6180339
and is the value approached by the ratio of two consecutive Fibonacci numbers  
F(n + 1)/F(n) for larger and larger values of n.
 
Example 3	
Prove that in the Fibonacci sequence 
F(n + 4) = 3F(n + 2) − F(n) for all n ≥ 1
Because we want to prove something true for all n ≥ 1, it is natural to think 
of a proof by induction. And because the value of F(n) depends on both F(n − 1) 
and F(n − 2), the second principle of induction should be used. For the basis step 
of the inductive proof, we’ll prove two cases, n = 1 and n = 2. For n = 1, by sub-
stituting 1 for n in the equation we want to prove, we get
F(5) = 3F(3) −F(1)
or (using values computed in Practice 2)
5 = 3(2) −1
which is true. For n = 2,
F(6) = 3F(4) −F(2)
or
8 = 3(3) −1
which is also true. Assume that for all r, 1 ≤ r ≤ k,
F(r + 4) = 3F(r + 2) −F(r).
1
2
3
5
6
7
8
4
1
2
3
5
6
7
8
9
10
11
12
13
4

Section 3.1   Recursive Definitions	
161
Now show the case for k + 1, where k + 1 ≥ 3. (We’ve already proved the 
case for n = 1 and the case for n = 2.) Thus we want to show
F(k + 1 + 4) 0 3F(k + 1 + 2) −F(k + 1)
or
F(k + 5) 0 3F(k + 3) −F(k + 1)
From the recurrence relation for the Fibonacci sequence, we have
	
F(k + 5) = F(k + 3) + F(k + 4)      (F at any value is the sum of F at 
the two previous values)	
and by the inductive hypothesis, with r = k − 1 and r = k, respectively,
F(k + 3) = 3F(k + 1) −F(k −1)
and
F(k + 4) = 3F(k + 2) −F(k)
Therefore
 F(k + 5) = F(k + 3) + F(k + 4)
 = 33F(k + 1) −F(k −1)4 + 33F(k + 2) −F(k)4
 = 33F(k + 1) + F(k + 2)4 −3F(k −1) + F(k)4
 = 3F(k + 3) −F(k + 1)      (using the recurrence relation again)
This completes the inductive proof.
Practice 3	 In the inductive proof of Example 3, why is it necessary to prove n = 2 as a special case?
■
	
Example 4	
The formula
F(n + 4) = 3F(n + 2) −F(n) for all n ≥1
of Example 3 can also be proved without induction, using just the recurrence rela-
tion from the definition of Fibonacci numbers. The recurrence relation
F(n + 2) = F(n) + F(n + 1)
can be rewritten as
	
F(n + 1) = F(n + 2) −F(n)
(1)

162	
Recursion, Recurrence Relations, and Analysis of Algorithms
Recursively Defined Sets
The objects in a sequence are ordered—there is a first object, a second object, and 
so on. A set of objects is a collection of objects on which no ordering is imposed. 
Some sets can be defined recursively.
 
Example 5	
In Section 1.1 we noted that certain strings of statement letters, logical connec-
tives, and parentheses, such as (A ` B)′ ~ C, are considered legitimate, while 
other strings, such as ` ` A′′B, are not legitimate. The syntax for arranging such 
symbols constitutes the definition of the set of propositional well-formed formulas, 
and it is a recursive definition.
	
1.	 Any statement letter is a wff.
	
2.	 If P and Q are wffs, so are (P ` Q), (P ~ Q), (P S Q), (P′) and (P 4 Q).2
Using the rules of precedence for logical connectives established in Section 1.1,  
we can omit parentheses when doing so causes no confusion. Thus we write 
(P ~ Q) as P ~ Q, or (P′) as P′; the new expressions are technically not wffs by 
the definition just given, but they unambiguously represent wffs.
By beginning with statement letters and repeatedly using rule 2, any proposi-
tional wff can be built. For example, A, B, and C are all wffs by rule 1. By rule 2,
(A ` B) and (C′) 
are both wffs. By rule 2 again,
((A ` B) S (C′))
is a wff. Applying rule 2 yet again, we get the wff
(((A ` B) S (C′))′)
Eliminating some pairs of parentheses, we can write this wff as
((A ` B) S C′)′
2Sometimes there is a final rule added to the effect that there are no applicable rules besides those already 
given, which means that if something can’t be generated using the rules already given, then it does not belong 
to the set being described. We’ll assume that when we stop writing rules, there are no more applicable rules!
Then
 F(n + 4) = F(n + 3) + F(n + 2)
 = F(n + 2) + F(n + 1) + F(n + 2)	
(rewriting F(n + 3))
 = F(n + 2) + 3F(n + 2) −F(n)4 + F(n + 2)	
(rewriting F(n + 1) 
 = 3F(n + 2) −F(n)	
using (1))

Section 3.1   Recursive Definitions	
163
Practice 4	 Show how to build the wff ((A ~ (B′)) S C) from the definition in Example 5.
■
■
Practice 5	 A recursive definition for the set of people who are ancestors of James could have the 
following basis:
James’s parents are ancestors of James.
Give the inductive step.
Strings of symbols drawn from a finite “alphabet” set are objects that are 
commonly encountered in computer science. Computers store data as binary 
strings, strings from the alphabet consisting of 0s and 1s; compilers view program 
statements as strings of tokens, such as key words and identifiers. The collection 
of all finite-length strings of symbols from an alphabet, usually called strings over 
an alphabet, can be defined recursively (see Example 6). Many sets of strings with 
special properties also have recursive definitions.
 
Example 6	
The set of all (finite-length) strings of symbols over a finite alphabet A is denoted 
by A*. The recursive definition of A* is
	
1.	 The empty string λ (the string with no symbols) belongs to A*.
	
2.	 Any single member of A belongs to A*.
	
3.	 If x and y are strings in A*, so is xy, the concatenation of strings x and y.
Parts 1 and 2 constitute the basis, and part 3 is the recursive step of this definition. 
Note that for any string x, xλ = λx = x.
Practice 6	 If x = 1011 and y = 001, write the strings xy, yx, and yxλx.
■
■
Practice 7	 Give a recursive definition for the set of all binary strings that are palindromes, strings 
that read the same forward and backward.
 
EXAMPLE 7	
Suppose that in a certain programming language, identifiers can be alphanumeric 
strings of arbitrary length but must begin with a letter. A recursive definition for the 
set of such strings is
	
1.	 A single letter is an identifier.
	
2.	 If A is an identifier, so is the concatenation of A and any letter or digit.
A more symbolic notation for describing sets of strings that are recursively 
­defined is called Backus–Naur form, or BNF, originally developed to define the  

164	
Recursion, Recurrence Relations, and Analysis of Algorithms
programming language ALGOL. In BNF notation, items that are defined in terms of 
other items are enclosed in angle brackets, while specific items that are not further 
broken down do not appear in brackets. The vertical line 0 denotes a choice, with the 
same meaning as the English word or. The BNF definition of an identifier is
<identifier> ::5 <letter> 0 <identifier> <letter> 0 <identifier> <digit>
<letter> ::5 a 0 b 0 c 0 c 0 z
<digit> ::5 1 0 2 0 c 0 9
Thus the identifier me2 is built from the definition by a sequence of choices such as
<identifier>	
can be	
<identifier> <digit>
	
which can be	
<identifier>2
	
which can be	
<identifier> <letter>2
	
which can be	
<identifier>e2
	
which can be	
<letter>e2
	
which can be	
me2
As a further connection between recursion and induction, there is a form of 
induction called structural induction that can be applied to recursively defined 
sets. Suppose we have a recursively defined set S and there is some property P(x) 
that may or may not hold for x a member of S. If we can prove
	
1.	 Property P holds for all members of S described in the basis.
	
2.	 If property P holds for some members of S, then it holds for new members 
of S constructed from these members using the recursive step.
then property P holds for all members of S.
 
EXAMPLE 8	
A set S of strings is defined recursively by
 
1.	 λ belongs to S.
	
2.	 If x belongs to S, so do 1x0 and 0x1.
We can use structural induction to prove that every string in S consists of an 
equal number of 0s and 1s. The basis, rule 1, identifies only a single string in S, 
namely λ, which consists of an equal number of 0s and 1s (zero 0s and zero 1s). 
Assume that string x consists of an equal number of 0s and 1s. Using rule 2, the two 
new strings that can be constructed from x each add a single 1 and a single 0, so the 
number of 0s and the number of 1s has each been increased by 1 and they are still 
equal. By structural induction, every string in S has an equal number of 0s and 1s.
Notice that not all strings with an equal number of 0s and 1s belong to S. For 
example there is no way to generate the string 1001 using the given rules.
Ordinary mathematical induction proves properties about integer values, and 
the integers are ordered: 1, 2, … , k, k + 1, …  . A set, however, isn’t necessarily 
ordered. If we consider the set S defined in Example 8, it looks like

Section 3.1   Recursive Definitions	
165
and structural induction helps us deal with this “spread” of values in the set.
Recursively Defined Operations
Certain operations performed on objects can be defined recursively, as in ­Examples 
9 and 10.
	
EXAMPLE 9	
A recursive definition of the exponentiation operation an on a nonzero real number 
a, where n is a nonnegative integer, is
 
1.	 a0 = 1
	
2.	 an = (an − 1)a	 for n ≥ 1
 
EXAMPLE 10	
A recursive definition for multiplication of two positive integers m and n is
	
1.	 m(1) = m
	
2.	 m(n) = m(n − 1) + m for n ≥ 2
■
Practice 8	 Let x be a string over some alphabet. Give a recursive definition for the operation xn 
(concatenation of x with itself n times) for n ≥ 1.
In Section 1.1, we defined the operation of logical disjunction on two ­statement 
letters. This definition can serve as the basis step for a recursive definition of the 
disjunction of n statement letters, n ≥ 2:
	
1.	 A1 ~ A2 defined as in Section 1.1
	
2.	 A1 ~ c~ An = (A1 ~ c~ An−1) ~ An for n > 2	
(2)
Using this definition, we can generalize the associative property of disjunction 
(tautological equivalence 2a) to say that in a disjunction of n statement letters, 
grouping by parentheses is unnecessary because all such groupings are equivalent 
to the general expression for the disjunction of n statement letters. In symbolic 
form, for any n with n ≥ 3 and any p with 1 ≤ p ≤ n − 1,
(A1 ~ c~ Ap) ~ (Ap+1 ~ c~ An) 3 A1 ~ c~ An
This equivalence can be proved by induction on n. For n = 3,
	
A1 ~ (A2 ~ A3) 3 (A1 ~ A2) ~ A3	
(by equivalence 2a) 
 
        =   A1 ~ A2 ~ A3	
(by equation (2))
01
λ
10
1100
0100 1010
0011

166	
Recursion, Recurrence Relations, and Analysis of Algorithms
Assume that for n = k and 1 ≤ p ≤ k − 1,
(A1 ~ c~ Ap) ~ (Ap+1 ~ c~ Ak) 3 A1 ~ c~ Ak
Then for n = k + 1 and 1 ≤ p ≤ k,
(A1 ~ c~ Ap) ~ (Ap+1 ~ c~ Ak+1)
      = (A1 ~ c~ Ap) ~ 3(Ap+1 ~ c~ Ak) ~ Ak+14	
(by equation (2))
   3 3(A1 ~ c~ Ap) ~ (Ap+1 ~ c~ AK)4 ~ Ak+1	
(by equivalence 2a)
   3 (A1 ~ c~ Ak) ~ Ak+1	
(by inductive ­hypothesis)
      = A1 ~ c~ Ak+1	
(by equation (2))
Recursively Defined Algorithms
Example 1 gives a recursive definition for a sequence S. Suppose we want to 
write a computer program to evaluate S(n) for some positive integer n. We can use 
­either of two approaches. If we want to find S(12), for example, we can begin with 
S(1) = 2 and then compute S(2), S(3), and so on, much as we did in Example  1, 
­until we finally get to S(12). This approach no doubt involves iterating through 
some sort of loop. A pseudocode function S that uses this iterative algorithm 
­follows. The basis, where n = 1, is handled in the first clause of the if statement; 
the value 2 is returned. The else clause, for n > 1, does some initializing and then 
goes into the while loop that computes larger values of the sequence until the 
­correct upper limit is reached. You can trace the execution of this algorithm for a 
few values of n to convince yourself that it works.
	
Algorithm
S(positive integer n)
//function that iteratively computes the value S(n)
//for the sequence S of Example 1
Local variables:
integer i	
//loop index
CurrentValue	 //current value of function S
if n = 1 then
return 2
else
i = 2
CurrentValue = 2
while i <= n do
CurrentValue = 2 * CurrentValue
i = i + 1
end while
//CurrentValue now has the value S(n)
return CurrentValue 
end if
end function S

Section 3.1   Recursive Definitions	
167
The second approach to computing S(n) uses the recursive definition of S 
directly. Following is a version of the recursive algorithm, written again as a 
pseudocode function.
The body of this function consists of a single if-then-else statement. To un-
derstand how the function works, let’s trace the execution to compute the value 
of S(3). The function is first invoked with an input value of n = 3. Because n is 
not 1, execution is directed to the else clause. At this point, activity on computing 
S(3) must be suspended until the value of S(2) is known. Any known information 
relevant to the computation of S(3) is stored within computer memory on a stack, 
to be retrieved when the computation can be completed. (A stack is a collection 
of data where any new item goes on top of the stack, and only the item on top of 
the stack at any given time can be accessed or removed from the stack. A stack is 
thus a LIFO—last in, first out—structure.) The function is invoked again with an 
input value of n = 2. Again, the else clause is executed, and computation of S(2) 
is suspended, with relevant information stored on the stack, while the function is 
invoked again with n = 1 as input.
This time the first clause of the if statement applies, and the functional value, 2, 
can be computed directly. This final invocation of the function is now ­complete, and 
its value of 2 is returned to the second-to-last invocation, which can now remove 
any information relevant to the n = 2 case from the stack, compute S(2), and return 
the result to the previous (initial) invocation. Finally, this original ­invocation of S 
is able to empty the stack and complete its calculation, returning the value of S(3).
What are the relative advantages of iterative and recursive algorithms for ­doing 
the same task? In this example, the recursive version is certainly shorter ­because it 
does not have to manage a loop computation. Describing the execution of the recur-
sive version makes it sound more complex than the iterative version, but all steps are 
carried out automatically. One need not be aware of what is ­happening internally 
except to note that a long series of recursive invocations can use a lot of memory 
by storing information relevant to previous invocations on the stack. If too much 
memory is consumed, a “stack overflow” can result. Besides using more memory, 
recursive algorithms can require many more computations and can run more slowly 
than nonrecursive ones (see Exercise 3 in On the Computer at the end of this chapter).
Nonetheless, recursion provides a natural way to think about many problems, 
some of which would have very complex nonrecursive solutions. The problem of 
computing values for a sequence that has itself been defined recursively is well-
suited to a recursive solution. Many programming languages support recursion.
	
Algorithm
S(positive integer n)
//function that recursively computes the value S(n)
//for the sequence S of Example 1
if n = 1 then
return 2
else
return 2 * S(n − 1)
end if
end function S

168	
Recursion, Recurrence Relations, and Analysis of Algorithms
A recursive algorithm invokes itself with “smaller” input values. Suppose a 
problem can be solved by solving smaller versions of the same problem, and the 
smaller versions eventually become trivial cases that are easily handled. Then 
a recursive algorithm can be useful, even if the original problem was not stated 
­recursively.
To convince ourselves that a given recursive algorithm works, we don’t have to 
start with a particular input and go down through smaller and smaller cases to the 
trivial case and then back up again. We did this when discussing the computation 
of S(3), but that was just to illustrate the mechanics of a recursive computation. 
Instead, we can verify the trivial case (like proving the base case in an induction 
proof) and verify that if the algorithm works correctly when invoked on smaller 
input values, then it indeed solves the problem for the original input values (this 
is similar to proving P(k + 1) from the assumption P(k) in an inductive proof).
■
Practice 9	 Write the body of a recursive function to compute T(n) for the sequence T defined in 
Practice 1.
 
EXAMPLE 11	
In Example 10, a recursive definition was given for multiplying two positive 
­integers m and n. A recursive pseudocode function for multiplication based on this 
definition follows.
	
Algorithm
Product(positive integer m; positive integer n)
//Function that recursively computes the product of m and n
if n = 1 then
return m;
else
return Product(m, n − 1) + m 
end if
end function Product
REMINDER
Think of a recursive 
algorithm whenever you 
could solve the problem 
from solutions to smaller 
versions of the problem.
 
Example 12	
One of the most common tasks in data processing is to sort a list L of n items into 
increasing or decreasing numerical or alphabetical order. (The list might consist of 
customer names, for example, and in sorted order “Valdez, Juanita” should come 
after “Tucker, Joseph.”) The selection sort algorithm—a simple but not particularly 
efficient sorting algorithm—is described in pseudocode in the accompanying box.
This function sorts the first j items in L into increasing order; when the func-
tion is initially invoked,  j has the value n (thus, the first invocation ultimately sorts 
the entire list). The recursive part of the algorithm lies within the else clause; the 
algorithm examines the section of the list under consideration and finds the loca-
tion i such that L[i] is the maximum value. It then exchanges L[i] and L[ j], after 
which the maximum value occurs at position j, the last position in the part of the 
list being considered. L[ j] is now correct and should never change again, so this 

Section 3.1   Recursive Definitions	
169
process is repeated on the list L[1] through L[ j − 1]. If this part of the list is sorted 
correctly, then the entire list will be sorted correctly. Whenever j has the value 1, 
the part of the list being considered consists of only one entry, which must be in 
the right place. The entire list is sorted at that point.
	
Algorithm	
SelectionSort
SelectionSort(list L; positive integer j)
//recursively sorts the items from 1 to j in list L into increasing order
if j = 1 then
sort is complete, write out the sorted list
else
find the index i of the maximum item in L between 1 and j
exchange L[i] and L[ j]
SelectionSort(L, j − 1)
end if
end function SelectionSort
Other recursive sorting algorithms are discussed in the exercises of Section 3.3.
 
Example 13	
Now that we have sorted our list, another common task is to search the list for a 
particular item. (Is Juanita Valdez already a customer?) An efficient search tech-
nique for a sorted list is the recursive binary search algorithm, which is described 
here in pseudocode.
	
Algorithm	
BinarySearch
BinarySearch(list L; positive integer i; positive integer j; itemtype x)
//searches sorted list L from L[i] to L[ j] for item x
if i > j then
write(“not found”)
else
find the index k midway between i and j
if x = midpoint item L[k] then
write(“found”)
else
if x < midpoint item L[k] then
BinarySearch(L, i, k − 1, x)
else
BinarySearch(L, k + 1, j, x)
end if
end if
end if
end function BinarySearch

170	
Recursion, Recurrence Relations, and Analysis of Algorithms
This algorithm searches the section of list L between L[i] and L[j] for item x; 
initially i and j have the values 1 and n, respectively. The first clause of the major if 
statement is the basis step that says x cannot be found in an empty list, one where 
the first index exceeds the last index. In the major else clause, the midpoint item in 
a section of the list must be found. (If the section contains an odd number of items, 
there is indeed a midpoint item; if the section contains an even number of items, 
it is sufficient to take as the “midpoint” item the one at the end of the first half of 
the list section.) Comparing x with the midpoint item either locates x or indicates 
which half of the list to search next, the half before the midpoint or the half after 
the midpoint.
 
Example 14	
Let’s apply the binary search algorithm to the list
3, 7, 8, 10, 14, 18, 22, 34
where the target item x is the number 25. The initial list is not empty, so the mid-
point item is located and determined to have the value 10. Then x is compared with 
the midpoint item. Because x > 10, the search is invoked on the second half of the 
list, namely, the items
14, 18, 22, 34
Again, this list is nonempty, and the midpoint item is 18. Because x > 18, the 
­second half of this list is searched, namely, the items
22, 34
In this nonempty list, the midpoint item is 22. Because x > 22, the search ­continues 
on the second half of the list, namely,
34
This is a one-element list, with the midpoint item being the only item. Because  
x < 34, a search is begun on the “first half” of the list; but the first half is empty. 
The algorithm terminates at this point with the information that x is not in the list.
This execution requires four comparisons in all; x is compared, in turn, to 10, 
18, 22, and 34.
Practice 10	 In a binary search of the list in Example 14, name the elements against which x is  
compared if x has the value 8.
■
We have now seen a number of recursive definitions. Table 3.1 summarizes 
their features.

Section 3.1   Recursive Definitions	
171
S e c t i o n  3 .1 	
Review
Techniques
•	 Generate values in a sequence defined recursively.
•	 Prove properties of the Fibonacci sequence.
•	 Recognize objects in a recursively defined collec-
tion of objects. 
•	 Give recursive definitions for particular sets of 
­objects.
•	 Give recursive definitions for certain operations on 
objects.
•	 Write recursive algorithms to generate sequences 
defined recursively.
Main Ideas
•	 Recursive definitions can be given for sequences of 
objects, sets of objects, and operations on objects 
where basis information is known and new infor-
mation depends on already known information.
•	 Recursive algorithms provide a natural way to 
solve certain problems by invoking the same task 
on a smaller version of the problem.
Table 3.1
Recursive Definitions
What Is Being Defined
Characteristics
Recursive sequence
The first one or two values in the sequence are known; later items in the sequence are 
defined in terms of earlier items.
Recursive set
A few specific items are known to be in the set; other items in the set are built from 
combinations of items already in the set.
Recursive operation
A “small” case of the operation gives a specific value; other cases of the operation are 
defined in terms of smaller cases.
Recursive algorithm 
For the smallest values of the arguments, the algorithm behavior is known; for larger 
values of the arguments, the algorithm invokes itself with smaller argument values.
W
Exercises 3.1
For Exercises 1–12, write the first five values in the sequence.
	 1.	 S(1) = 10
	
	 S(n) = S(n − 1) + 10 for n ≥ 2
	 2.	 C(1) = 5
	
	 C(n) = 2C(n − 1) + 5 for n ≥ 2
	 3.	 A(1) = 2
	
	 A(n) =
1
A(n −1) for n ≥ 2
	 4.	 B(1) = 1
	
	 B(n) = B(n − 1) + n2 for n ≥ 2
	 5.	 S(1) = 1
	
	 S(n) = S(n −1) + 1
n for n ≥ 2
	 6.	 T(1) = 1
	
	 T(n) = nT(n − 1) for n ≥ 2

172	
Recursion, Recurrence Relations, and Analysis of Algorithms
	 7.	 P(1) = 1
	
	 P(n) = n2 P(n − 1) + (n − 1) for n ≥ 2
	 8.	 A(1) = 2
	
	 A(n) = nA(n − 1) + n for n ≥ 2
	 9.	 M(1) = 2
	
	 M(2) = 2
	
	 M(n) = 2M(n − 1) + M(n − 2) for n > 2
	 10.	D(1) = 3
	
	 D(2) = 5
	
	 D(n) = (n − 1)D(n − 1) + (n − 2)D(n − 2) for n > 2
	 11.	W(1) = 2
	
	 W(2) = 3
	
	 W(n) = W(n − 1)W(n − 2) for n > 2
	 12.	T(1) = 1
	
	 T(2) = 2
	
	 T(3) = 3
	
	 T(n) = T(n − 1) + 2T(n − 2) + 3T(n − 3) for n > 3
In Exercises 13–18, prove the given property of the Fibonacci numbers directly from the definition.
	 13.	F(n + 1) + F(n − 2) = 2F(n) for n ≥ 3
	 14.	F(n) = 5F(n − 4) + 3F(n − 5) for n ≥ 6
	 15.	F(n) = 3F(n − 3) + 2F(n − 4) for n ≥ 5
	 16.	[F(n + 1)]2 = [F(n)]2 + F(n − 1)F(n + 2) for n ≥ 2
	 17.	F(n + 3) = 2F(n + 1) + F(n) for n ≥ 1
	 18.	F(n + 6) = 4F(n + 3) + F(n) for n ≥ 1
In Exercises 19–22, prove the given property of the Fibonacci numbers for all n ≥ 1. (Hint: The first principle 
of induction will work.)
	 19.	F(l) + F(2) + c+ F(n) = F(n + 2) − 1
	 20.	F(2) + F(4) + c+ F(2n) = F(2n + 1) − 1
	 21.	F(1) + F(3) + c+ F(2n − 1) = F(2n)
	 22.	[F(1)]2 + [F(2)]2 + c+ [F(n)]2 = F(n)F(n + 1)
In Exercises 23–26, prove the given property of the Fibonacci numbers using the second principle of induction.
	 23.	Exercise 17
	 24.	Exercise 18
	 25.	F(n) < 2n for n ≥ 1
	 26.	F(n) > a3
2b
n−1
 for n ≥ 6

Section 3.1   Recursive Definitions	
173
	 27.	Write a pseudocode recursive algorithm for a function to compute F(n), the nth Fibonacci number.
	 28.	Walk through your recursive algorithm from Exercise 27 to compute F(6).
	
a.	 How many times is the function invoked?
	
b.	How many times is F(4) computed?
	
c.	 How many times is F(3) computed?
	
d.	How many times is F(2) computed?
Exercises 29 and 30 concern a proof of correctness of the following iterative algorithm for a function to ­compute 
F(n), the nth Fibonacci number.
F(positive integer n)
//function that iteratively computes the value of
//the nth Fibonacci number
Local variables:
positive integer i	
//loop index
positive integers p, q, r	
//terms in Fibonacci sequence
if n = 1 then
return 1
else
if n = 2 then
return 1
else
i = 2
p = 1	
//p = lagging term in Fibonacci sequence
q = 1	
//q = leading term in Fibonacci sequence
while i < n do
r = p + q	
//form the next term as the 
	
//sum of the two previous terms
p = q	
//bump up p
q = r 	
//bump up q
i = i + 1
end while
//q now has the value F(n)
return q
end if
end if
end function F
	 29.	a.	 In the iterative Fibonacci algorithm, the condition B for loop continuation is i < n, so B′ is i ≥ n, but 
what is the exact value of i when the loop terminates?
	
b.	When the loop exits, you want q = F(n); what do you want for the value of p at that point?
	 30.	a.	 Write the loop invariant Q for the iterative Fibonacci algorithm.
	
b.	Prove that Q is a loop invariant.

174	
Recursion, Recurrence Relations, and Analysis of Algorithms
	 31.	The values p and q are defined as follows:
	
p = 1 + "5
2
	
and	
q = 1 −"5
2
	
a.	 Prove that 1 + p = p2 and 1 + q = q2.
	
b.	Prove that
F(n) = pn −qn
p −q
	
c.	 Use part (b) to prove that
F(n) = "5
5  a1 + "5
2
b
n
−"5
5  a1 −"5
2
b
n
 
	
	
is a closed-form solution for the Fibonacci sequence.
	 32.	The Lucas sequence is defined by
L(1) = 1
L(2) = 3
L(n) = L(n − 1) + L(n − 2) for n ≥ 2
	
a.	 Write the first five terms of the sequence.
	
b.	Prove that L(n) = F(n + 1) + F(n − 1) for n ≥ 2 where F is the Fibonacci sequence.
For Exercises 33–36, decide whether the sequences described are subsequences of the Fibonacci sequence, that 
is, whether their members are some or all of the members, in the right order, of the Fibonacci sequence.3
	 33.	The sequence A(n), where A(n) = 1 + (the sum of the first n terms of the Fibonacci sequence), n ≥ 1. The 
first four values are 2, 3, 5, 8, which—so far—form a subsequence of the Fibonacci sequence.
	 34.	The sequence B(n), where B(n) = (n − 1)2n−2 + 1, n ≥ 1. The first four values are 1, 2, 5, 13, which—so 
far—form a subsequence of the Fibonacci sequence.
	 35.	The sequence C(n), where C(n) is the number of ways in which n coins can be arranged in horizontal rows 
with all the coins in each row touching and every coin above the bottom row touching two coins in the row 
below it, n ≥ 1. The first five values are 1, 1, 2, 3, 5, which—so far—form a subsequence of the Fibonacci 
sequence.
n = 1
n = 2
n = 3
n = 5
n = 4
	 36.	The sequence D(n), where D(n) describes the number of ways to paint the floors on an n-story building 
where each floor is painted yellow or blue and no two adjacent floors can be blue (although adjacent floors 
3Exercises 33–36 are taken from “Mathematical Recreations” by Ian Stewart, Scientific American, May 1995.

Section 3.1   Recursive Definitions	
175
can be yellow), n ≥ 1. The first four values are 2, 3, 5, 8, which—so far—form a subsequence of the  
Fibonacci sequence. For example, D(3) = 5 because a three-story building can be painted
	
Y	
Y	
Y	
B	
B
	
Y	
Y	
B	
Y	
Y
	
Y	
B	
Y	
B	
Y
	
	 (Hint: think about a recursive expression for D(n + 1).)
	 37	 a.	 The original problem posed by Fibonacci concerned pairs of rabbits. Two rabbits do not breed until 
they are 2 months old. After that, each pair of rabbits produces a new pair each month. No rabbits ever 
die. Let R(n) denote the number of rabbit pairs at the end of n months if you start with a single rabbit 
pair. Show that R(n) is the Fibonacci sequence.
	
b.	Write 27 and 62 as the sum of distinct nonconsecutive Fibonacci numbers.
	 38.	a.	 The sequence of Catalan numbers is defined recursively by
C(0) = 1
C(1) = 1
C(n) = ∙
n
k=1
 C(k −1)C(n −k) for n ≥ 2
	
	 Compute the values of C(2), C(3), and C(4) using this recurrence relation.
	 b.	 Frank and Jody are both candidates for president of the County Council. The number of votes cast equals 
2n, where n votes are cast for Frank and n for Jody. Votes are counted sequentially. The ballot problem 
asks: In how many ways can the votes be counted so that Jody’s total is never ahead of Frank’s total? 
The answer, as it turns out, is C(n), the nth Catalan number. For example, if n = 5, one possible counting 
sequence that meets this requirement is
FFJJFJFFJJ
	
	 Using n = 3, write down all the satisfactory counting sequences and compare the result to the Catalan 
number C(3).
	 39.	A sequence is recursively defined by
S(1) = 2
S(2) = 2
S(3) = 6
S(n) = 3S(n − 3) for n ≥ 3
	
	 Prove that S(n) is an even number for n ≥ 1.
	 40.	A sequence is recursively defined by
T(5) = 6
T(6) = 10
T(n) = 2T(n − 2) + 2 for n ≥ 7
	
	 Prove that T(n) ≥ 2n for n ≥ 7.

176	
Recursion, Recurrence Relations, and Analysis of Algorithms
	 41.	A sequence is recursively defined by 
S(0) = 1
S(1) = 1
S(n) = 2S(n − 1) + S(n − 2) for n ≥ 2
	
a.	 Prove that S(n) is an odd number for n ≥ 0.
	
b.	Prove that S(n) < 6S(n − 2) for n ≥ 4.
	 42.	A sequence is recursively defined by
T(0) = 1
T(1) = 2
T(n) = 2T(n − 1) + T(n − 2) for n ≥ 2
	
	 Prove that T(n) ≤A5
2Bn for n ≥ 0.
	 43.	Write a recursive definition for a geometric progression with initial term a and common ratio r (see 
­Exercise 27, Section 2.2.).
	 44.	Write a recursive definition for an arithmetic progression with initial term a and common difference d (see 
Exercise 28, Section 2.2.).
	 45.	In an experiment, a certain colony of bacteria initially has a population of 50,000. A reading is taken every 
2 hours, and at the end of every 2-hour interval, there are 3 times as many bacteria as before.
	
a.	 Write a recursive definition for A(n), the number of bacteria present at the beginning of the nth time 
period.
	
b.	At the beginning of which interval are there 1,350,000 bacteria present?
	 46.	An amount of $500 is invested in an account paying 1.2% interest compounded annually.
	
a.	 Write a recursive definition for P(n), the amount in the account at the beginning of the nth year.
	
b.	After how many years will the account balance exceed $570?
	 47.	A set T of numbers is defined recursively by
	
1.	2 belongs to T.
	
2.	If x belongs to T, so does x + 3 and 2 * x.
	
	 Which of the following numbers belong to T?
	
a.  6	
b.  7	
c.  19	
d.  12
	 48.	A set M of numbers is defined recursively by
	
1.	2 and 3 belong to M.
	
2.	If x and y belong to M, so does x * y.
	
	 Which of the following numbers belong to M?
	
a.  6	
b.  9	
c.  16	
d.  21	
e.  26	
f.  54	
g.  72	
h.  218

Section 3.1   Recursive Definitions	
177
	 49.	A set S of strings of characters is defined recursively by
	
1.	a and b belong to S.
	
2.	If x belongs to S, so does xb.
	
	 Which of the following strings belong to S?
	
a.  a	
b.  ab	
c.  aba	
d.  aaab	
e.  bbbbb
	 50.	A set W of strings of symbols is defined recursively by
	
1.	a, b, and c belong to W.
	
2.	If x belongs to W, so does a(x)c.
	
	 Which of the following strings belong to W ?
	
a.  a(b)c	
b. a(a(b)c)c	
c. a(abc)c	
d. a(a(a(a)c)c)c	
e. a(aacc)c
	 51.	A set S of integers is defined recursively by
	
1.	0 and 3 belong to S.
	
2.	If x and y belong to S, so does x + y.
	
	 Use structural induction to prove that every integer in S is a multiple of 3.
	 52.	A set T of strings is defined recursively by
	
1.	pqq belongs to T.
	
2.	If x and y belong to T, so do pxqq, qqxp, and xy.
	
	 Use structural induction to prove that every string in T has twice as many q’s as p’s.
	 53.	Give a recursive definition for the set of all unary predicate wffs in x.
	 54.	Give a recursive definition for the set of all well-formed formulas of integer arithmetic, involving ­integers 
together with the arithmetic operations of +, −, *, and /.
	 55.	Give a recursive definition for the set of all odd integers.
	 56.	Give a recursive definition for the set of all strings of well-balanced parentheses.
	 57.	Give a recursive definition for the set of all binary strings containing an odd number of 0s.
	 58.	Give a recursive definition for the set of all binary strings containing an even number of 1s.
	 59.	Give a recursive definition for the set of all binary strings ending with 0.
	 60.	Give a recursive definition for the set of all binary strings with an equal number of 0s and 1s.
	 61.	Use BNF notation to define the set of positive integers.
	 62.	Use BNF notation to define the set of decimal numbers, which consist of an optional sign (+ or −), 
­followed by one or more digits, followed by a decimal point, followed by zero or more digits.
	 63.	Give a recursive definition for x R, the reverse of the string x.
	 64.	Give a recursive definition for 0 x 0 , the length of the string x.
	 65.	Give a recursive definition for the factorial operation n! for n ≥ 1.

178	
Recursion, Recurrence Relations, and Analysis of Algorithms
	 66.	Give a recursive definition for the addition of two nonnegative integers m and n.
	 67.	a.	 Write a recursive definition for the operation of taking the maximum of n integers a1, … , an, n ≥ 2.
	
b.	Write a recursive definition for the operation of taking the minimum of n integers a1, … , an, n ≥ 2.
	 68.	a.	 Give a recursive definition for the conjunction of n statement letters in propositional logic, n ≥ 2.
	
b.	Write a generalization of the associative property of conjunction (tautological equivalence 2b of  
Section 1.1) and use induction to prove it.
	 69.	Let A and B1, B2, … , Bn be statement letters. Prove the finite extension of the distributive equivalences of 
propositional logic:
A ~ (B1 ` B2 ` c` Bn) 3 (A ~ B1) ` (A ~ B2) ` c` (A ~ Bn)
	
	 and
A ` (B1 ~ B2 ~ c~ Bn) 3 (A ` B1) ~ (A ` B2) ~ c~ (A ` Bn)
	
	 for n ≥ 2.
	 70.	Let B1, B2, … , Bn be statement letters. Prove the finite extension of De Morgan’s laws:
(B1 ~ B2 ~ c~ Bn)′ 3 B′1 ` B′2 ` c` B′n
	
	 and
(B1 ` B2 ` c` Bn)′ 3 B′1 ~ B′2 ~ c~ B′n
	
	 for n ≥ 2.
In Exercises 71–76, write the body of a recursive function to compute S(n) for the given sequence S.
	 71.	1, 3, 9, 27, 81, …
	 72.	2, 1, 1/2, 1/4, 1/8, …
	 73.	1, 2, 4, 7, 11, 16, 22, …
	 74.	2, 4, 16, 256, …
	 75.	a, b, a + b, a + 2b, 2a + 3b, 3a + 5b, …
	 76.	p, p − q, p + q, p − 2q, p + 2q, p − 3q, …
	 77.	What value is returned by the following recursive function Mystery for an input value of n?
Mystery (positive integer n)
if n = 1 then
return 1
else
return Mystery(n − 1) + 1
end if
end function Mystery
	 78.	The following recursive function is initially invoked with an i value of 1. L is a list (array) of 10 integers. 
What does the function do?
g(list L; positive integer i; integer x)
if i > 10 then
return 0
else

Section 3.1   Recursive Definitions	
179
if L[ i ] = x then
return 10
else
return g(L, i + 1, x) 
end if
end if
end function g
 79.	Informally describe a recursive algorithm to reverse the entries in a list of items.
	 80.	Informally describe a recursive algorithm to compute the sum of the digits of a positive integer.
	 81.	Informally describe a recursive algorithm to compute the greatest common divisor of two positive integers 
a and b where a > b. (Hint: The solution is based on the Euclidean algorithm, discussed in Section 2.3. In 
particular, make use of expression (5) on page 134.)
	 82.	The famous Towers of Hanoi puzzle involves 3 pegs with n disks of varying sizes stacked in order from 
the largest (on the bottom) to the smallest (on the top) on 1 of the pegs. The puzzle requires that the disks 
end up stacked the same way on a different peg; only one disk at a time can be moved to another peg, and 
no disk can ever be stacked on top of a smaller disk. Informally describe a recursive algorithm to solve the 
Towers of Hanoi puzzle.
	 83.	Simulate the execution of algorithm SelectionSort on the following list L; write the list after every 
­exchange that changes the list.
4, 10, −6, 2, 5
	 84.	Simulate the execution of algorithm SelectionSort on the following list L; write the list after every 
­exchange that changes the list.
9, 0, 2, 6, 4
	 85.	The binary search algorithm is used with the following list; x has the value “Chicago.” Name the elements 
against which x is compared.
Boston, Charlotte, Indianapolis, New Orleans, Philadelphia, San Antonio, Yakima
	 86.	The binary search algorithm is used with the following list; x has the value “flour.” Name the elements 
against which x is compared.
butter, chocolate, eggs, flour, shortening, sugar
	 87.	Do a proof of correctness for the iterative function given in this section to compute S(n) of Example 1, 
S(n) = 2n.
	 88.	The Online Encyclopedia of Integer Sequences (OEIS) was originated and maintained for many years by 
Neil Sloane, a mathematician at AT&T who has also written several books about sequences. The OEIS 
Foundation now manages the database, which contains more than 200,000 sequences of integers that have 

180	
Recursion, Recurrence Relations, and Analysis of Algorithms
been submitted and studied by many people. (See oeis.org). There is even a YouTube movie about the OEIS! 
Recaman’s sequence (number A005132 in the OEIS catalog) is a recursive sequence defined as follows:
a(1) = 1
	
	 For n > 1,
	
	 a(n) = •
 a(n − 1) − n if that number is positive and not already in the sequence, 
  otherwise 
a(n − 1) + n
 
a.	 Confirm that the first few terms of this sequence are 1, 3, 6, 2, 7, 13.
	
b.	It has been conjectured that every nonnegative integer will eventually appear in this sequence. Find the 
index of this sequence at which the following numbers appear: 10, 12, 23.
	
S e c t i o n  3 . 2 	 Recurrence Relations
We developed two algorithms, one iterative and one recursive, to compute a 
­value S(n) for the sequence S of Example 1. However, there is a still easier way to 
­compute S(n). Recall that
	
S(1) = 2	
(1)
	
S(n) = 2S(n − 1) for n ≥ 2	
(2)
Because
S(1) = 2 = 21
S(2) = 4 = 22
S(3) = 8 = 23
S(4) = 16 = 24
and so on, we can see that
	
S(n) = 2n	
(3)
Using Equation (3), we can plug in a value for n and compute S(n) without hav-
ing to compute—either explicitly, or, through recursion, implicitly—all the lower 
values of S first. An equation such as (3), where we can substitute a value and get 
the output value back directly, is called a closed-form solution to the recurrence 
relation (2) subject to the basis step (1). Finding a closed-form solution is called 
solving the recurrence relation.
Recurrence relations can be used to describe a variety of things, from chemi-
cal degradation (see the opening problem for this chapter) to the amount in an 
interest-bearing account, from the growth of species to the spread of a computer 
virus. Clearly, it is nice to find a closed-form solution to a recurrence relation 
whenever possible.
Linear First-Order Recurrence Relations
Expand, Guess, and Verify
One technique for solving recurrence relations is an “expand, guess, and verify” 
approach that repeatedly uses the recurrence relation to expand the expression for 
the nth term until the general pattern can be guessed. Finally the guess is verified 
by mathematical induction.

Section 3.2   Recurrence Relations	
181
 
Example 15	
Consider again the basis step and recurrence relation for the sequence S of 
Example 1:
	
S(1) = 2	
(4)
	
S(n) = 2S(n − 1) for n ≥ 2	
(5)
Let’s pretend we don’t already know the closed-form solution and use the expand, 
guess, and verify approach to find it. Beginning with S(n), we expand by using the 
recurrence relation repeatedly. Keep in mind that the recurrence relation is a recipe 
that says S at any value can be replaced by two times S at the previous value. We 
apply this recipe to S at the values n, n − 1, n − 2, and so on:
S(n) = 2S(n − 1)
= 2[2S(n − 2)] = 22S(n − 2)
= 22 [2S(n − 3)] = 23S(n − 3)
By looking at the developing pattern, we guess that after k such expansions, the 
equation has the form
S(n) = 2kS(n − k)
This expansion of S values in terms of lower S values must stop when n − k = 1, 
that is, when k = n − 1. At that point,
S(n) = 2n−1S[n − (n − 1)]
= 2n−1S(l) = 2n−1(2) = 2n
which expresses the closed-form solution.
We are not yet done, however, because we guessed at the general pattern. 
We now confirm our closed-form solution by induction on the value of n. The 
­statement we want to prove is therefore S(n) = 2n for n ≥ 1.
For the basis step, S(l) = 21. This is true by equation (4). We assume that 
S(k) = 2k. Then
	
S(k + 1) = 2S(k)	
(by equation (5))
 
= 2(2k)	
(by the inductive hypothesis)
 
= 2k+1
This proves that our closed-form solution is correct.
■
Practice 11	 Find a closed-form solution for the recurrence relation, subject to the basis step, for  
sequence T:
1.	T(l) = 1
2.	T(n) = T(n − 1) + 3 for n ≥ 2
(Hint: Expand, guess, and verify.)
REMINDER
Don’t get hung up on “n” 
and “n − 1” in the recur-
rence relation. Think of it 
as “S at some value is 2 
times S at the previous 
value.”

182	
Recursion, Recurrence Relations, and Analysis of Algorithms
A Solution Formula
Some types of recurrence relations have known solution formulas. A recurrence 
relation for a sequence S(n) is linear if the earlier values of S appearing in the 
definition occur only to the first power. The most general linear recurrence rela-
tion has the form
S(n) = f1(n)S(n − 1) + f2(n)S(n − 2) + c+ fk(n)S(n − k) + g(n)
where the fi’s and g can be expressions involving n. The recurrence relation has 
constant coefficients if the fi’s are all constants. It is first-order if the nth term 
depends only on term n − 1. Linear first-order recurrence relations with constant 
coefficients therefore have the form
	
S(n) = cS(n − 1) + g(n)	
(6)
Finally, a recurrence relation is homogeneous if g(n) = 0 for all n.
We will find the solution formula for equation (6), the general linear first-
order recurrence relation with constant coefficients, subject to the basis that S(1) 
is known. We will use the expand, guess, and verify approach. The work here is a 
generalization of what was done in Example 15. Repeatedly applying equation (6) 
and simplifying, we get
S(n) = cS(n − 1) + g(n)
= c[cS(n − 2) + g(n − 1)] + g(n)
= c2S(n − 2) + cg(n − 1) + g(n)
= c2 [cS(n − 3) + g(n − 2)] + cg(n − 1) + g(n)
= c3S(n − 3) + c2 g(n − 2) + cg(n − 1) + g(n)
f
After k expansions, the general form appears to be
S(n) = ckS(n − k) + ck−1g(n − (k − 1)) + c+ cg(n − 1) + g(n)
If the sequence has a base value at 1, then the expansion terminates when  
n − k = 1 or k = n − 1, at which point
S(n) = cn−1S(1) + cn−2g(2) + c+ cg(n − 1) + g(n)
 
= cn−1S(1) + cn−2g(2) + c+ c1g(n − 1) + c0g(n)	
(7)
We can use summation notation to write part of this expression more compactly. 
The uppercase Greek letter sigma, ∙, stands for summation. The notation
∙
q
i=p
 (expression)
says to substitute into the expression successive values of i, the index of 
­summation, from the lower limit p to the upper limit q, and then sum the ­results. 
(See ­Appendix B for further discussion of summation notation.) Thus, for ­example,
∙
n
i=1
(2i −1) = 1 + 3 + 5 + c+ (2n −1)

Section 3.2   Recurrence Relations	
183
In Example 14, Section 2.2, we proved by induction that the value of this summa-
tion is n2.
In summation notation, Equation (7) becomes
S(n) = cn−1S(1) + ∙
n
i=2
cn−ig(i)
Induction can be used, much as was done in Example 15, to verify that this for-
mula is the solution to recurrence relation (6) (see Exercise 26).
Therefore, the solution to the recurrence relation (6) is
	
S(n) = cn−1S(1) + ∙
n
i=2
cn−ig(i)	
(8)
This is not yet a closed-form solution, however, because we must find an expres-
sion for the summation. Usually it is either trivial to find the sum or we found its 
value in Section 2.2 using mathematical induction. (If we can’t find an expression 
for the summation, we are really no better off than before. We must iterate through 
the summation to find the desired value as opposed to iterating through the recur-
rence relation to get the desired value.)
The work we’ve done here gives a general solution—Equation (8)—once and 
for all for any recurrence relation of the form shown in (6); this work need not be 
repeated. All that is necessary is to match your problem to equation (6) to find the 
value for c and the formula for g(n) and then plug these results into the expression 
in (8). The g(n) in Equation (6) is the usual notation for a function of n; although 
we will study functions formally in Chapter 5, you can think of g(n) as giving a 
“recipe” for what to do with its argument n. If, for example,
g(n) = 2n
then g doubles whatever its argument value is:
	
g(3) = 2(3) = 6	
g(27) = 2(27) = 54	
and	
g(i) = 2i
This last value, 2i, would be used in Equation (8) if g(n) = 2n.
You now have a choice of two alternative ways to solve a linear, first-order ­recur- 
rence relation with constant coefficients. Table 3.2 summarizes these­ ­approaches.
 
EXAMPLE 16	
The sequence S(n) of Example 15,
S(1) = 2
S(n) = 2S(n − 1) for n ≥ 2
is a linear, first-order, homogeneous recurrence relation with constant coefficients. 
In other words, it matches equation (6) with c = 2 and g(n) = 0. Because g(n) = 0, 
the g function evaluates to 0 no matter what the argument is. From formula (8), the 
closed-form solution is
S(n) = 2n−1(2) + ∙
n
i=2
0 = 2n
which agrees with our previous result.

184	
Recursion, Recurrence Relations, and Analysis of Algorithms
Table 3.2
To Solve Recurrence Relations of the Form S(n) ∙ cS(n ∙ 1) ∙ g(n) Subject to Basis S(1)
Method
Steps
Expand, guess, verify
1. Repeatedly use the recurrence relation until you can guess a pattern.
2. Decide what that pattern will be when n − k = 1.
3. Verify the resulting formula by induction.
Solution formula
1. Match your recurrence relation to the form 
S(n) = cS(n − 1) + g(n) to find c and g(n).
2. Use c, g(n), and S(1) in the formula
S(n) = cn−1S(1) + ∙
n
i=2
cn−ig(i )
3. Evaluate the resulting summation to get the final expression.
 
EXAMPLE 17	
Find a closed-form solution to the recurrence relation
S(n) = 2S(n − 1) + 3 for n ≥ 2
subject to the basis step
S(1) = 4
We’ll use the solution formula method. Comparing our recurrence relation
S(n) = 2S(n − 1) + 3
with the general form S(n) = cS(n − 1) + g(n), we see that
	
c = 2	
g(n) = 3
The fact that g(n) = 3 says that g has a constant value of 3 no matter what the value 
of its argument; in particular, g(i) = 3. Substituting into the general solution form
S(n) = cn−1S(1) + ∙
n
i=2
cn−ig(i)
we get
S(n) = 2n−1(4) + ∙
n
i=2
2n−i(3)
= 2n−1(22) + 3∙
n
i=2
2n−i
= 2n+1 + 332n−2 + 2n−3 + c+ 21 + 204
 = 2n+1 + 332n−1 −14      (from Example 15, Section 2.2)

Section 3.2   Recurrence Relations	
185
So the value of S(5), for example, is 26 + 3(24 − 1) = 64 + 3(15) = 109.
Alternatively, by the expand, guess, and verify technique, we expand
S(n) = 2S(n − 1) + 3
	
= 2[2S(n − 2) + 3] + 3 = 22S(n − 2) + 2 # 3 + 3
	
= 22[2S(n − 3) + 3] + 2 # 3 + 3 = 23S(n − 3) + 22 # 3 + 2 # 3 + 3
(
The general pattern seems to be
S(n) = 2kS(n − k) + 2k−1 # 3 + 2k−2  # 3 + c+ 22 # 3 + 2 # 3 + 3
which, when n − k = 1 or k = n − 1, becomes
S(n) = 2n−1S(1) + 2n−2 # 3 + 2n−3 # 3 + c+ 22 # 3 + 2 # 3 + 3
	
= 2n−1(4) + 3[2n−2 + 2n−3 + c+ 22 + 2 + 1]
	
	
= 2n+1 + 3[2n−1 − 1]	
(from Example 15, Section 2.2)
Finally, we must prove by induction that S(n) = 2n+1 + 3[2n−1 − 1].
Base case: n = 1: S(1) = 4 = 22 + 3[20 − 1], true
Assume S(k) = 2k+1 + 3[2k−1 − 1]
Show S(k + 1) = 2k+2 + 3[2k − 1]
S(k + 1) = 2S(k) + 3	
(by the recurrence relation)
= 2(2k+1 + 3[2k−1 − 1]) + 3	
(by the inductive ­hypothesis)
= 2k+2 + 3 # 2k − 6 + 3	
(multiplying out)
= 2k+2 + 3[2k − 1]
Practice 12	
Rework Practice 11 using Equation (8).
■
 
Example 18	
Find a closed−form solution to the recurrence relation
T(n) = T(n − 1) + (n + 1) for n ≥ 2
subject to the basis step
T(1) = 2
Using the solution formula method and comparing the recurrence ­relation 
with the general form from Equation (6), S(n) = cS(n − 1) + g(n), we find 
that c = 1 and g(n) = n + 1. We’ll substitute into the solution equation (8) 
S(n) = cn−1S(1) + ∙
n
i=2
cn−ig(i), where g(i) will be i + 1.
REMINDER
When expanding, be sure 
to pick up all the pieces 
of the recurrence relation 
recipe, like the + 3 in this 
example.

186	
Recursion, Recurrence Relations, and Analysis of Algorithms
T(n) = (1)n−1(2) + ∙
n
i=2
(1)n−i(i + 1)
= 2 + ∙
n
i=2
(i + 1)
= 2 + (3 + 4 + c+ (n + 1))
 = (n + 1)(n + 2)
2
−1
      (from Practice 7, Section 2.2)
 
Example 19	
Consider the problem of reading data from a computer disk drive.4 The circular 
drive is organized as a series of concentric tracks, divided into sectors. Each sector 
contains a block of data (Figure 3.1).
The time to read a particular block of data into memory has three components:
	
1.	 Seek time—the time to position the read head over the proper track. This 
time varies depending on the relative position of the read head and the 
proper track when the read request is generated. In the best case, the read 
head is already over the proper track and the seek time is 0. At the worst 
case, assuming there are n tracks, the read head might be over track 1 and 
have to move to track n, which would be n − 1 units, where a unit is the 
distance between adjacent tracks. We can assume that the seek time would 
be some multiple of the number of units.
	
2.	 Latency time—the time for the proper sector to rotate underneath the read 
head. This time also varies, depending on whether the correct sector is just 
coming under the read head (minimum latency time) or whether it has just 
gone by and a full rotation must occur (maximum latency time).
	
3.	 Transfer time—the time to read a block once it is positioned under the read 
head, usually a constant amount of time for all blocks.
The problem is to find the average seek time, actually the average number A(n) of 
units. The assumptions are that there are n tracks, the read head is positioned over 
some track i, and the read head is equally likely to have to move to any track j.
Figure 3.1
4This example is based on work found in “Research Problem for Undergraduate Students which Spans 
Hardware Issues, Mathematical Methods and Programming: Average Seek Time of a Computer Disk,” by 
Jan Plaza, http://faculty.plattsburgh.edu/jan.plaza/teaching/papers/seektime.html

Section 3.2   Recurrence Relations	
187
Table 3.3 shows the number of units in going from one track to another, where 
a row is the source track and a column is the destination track. For example, if the 
read head is currently over track 3 and must end up over track n, then n − 3 units are 
required, as shown by the entry in row 3, column n. The entry in row n, column 3 is 
the same because it takes the same number of units to move in the opposite direction.
Table 3.3
1
2
3
c
n − 1
n
1
0
1
2
c
n − 2
n − 1
2
1
0
1
c
n − 3
n − 2
3
2
1
0
c
n − 4
n − 3
c
c
c
c
n − 1
n − 2
n − 3
n − 4
 c
0
1
n
n − 1
n − 2
n − 3
c
1
0
Destination 
track
Source 
track
Table 3.3 illustrates the n2 different possible track moves. We find the ­average 
number A(n) of units for these n2 cases by computing the total number of units 
shown in the table, T(n), and then dividing by n2. To compute T(n), note that 
T(n) = T(n − 1) + (the total of the last row plus the last column) and that the last 
row plus the last column contribute
2[1 + 2 + 3 + c+ (n − 1)] = 2 c(n −1)n
2
d 	
(using Practice 7, Section 2.2)
= (n − 1)n
so that
T(n) = T(n − 1) + (n − 1)n
The base case is T(1) = 0 (no seek time for a 1-track disk). This is a linear, 
­first-order recurrence relation with constant coefficients. We can solve it using 
Equation (8), where c = 1 and g(n) = (n − 1)n. The solution is
	
T(n) = 0 + ∙
n
i=2
(i −1)i
 
= 1 # 2 + 2 # 3 + 3 # 4 + c+ (n − 1)n
 
= (n −1)n(n + 1)
3
      (from Exercise 19, Section 2.2)
Therefore the average number of units is
A(n) = (n −1)n(n + 1)
3
 / n2 = n3 −n2 + n2 −n
3n2
= n3 −n
3n2
= n2 −1
3n
 = n
3 −1
3n
Because the best case is 0 and the worst case is n − 1, we might have expected the 
average case to be close to n/2, but in fact it is slightly less than n/3.

188	
Recursion, Recurrence Relations, and Analysis of Algorithms
Linear Second-Order Recurrence Relations
In a first-order recurrence relation, the nth term depends only on the previous 
term. In a second-order recurrence relation, the nth term depends on the two 
previous terms. Linear second-order homogeneous recurrence relations with con-
stant coefficients therefore have the form
	
S(n) = c1 S(n − 1) + c2 S(n − 2)	
(9)
The Fibonacci sequence is an example (Exercise 37 asks for a solution):
F(1) = 1
F(2) = 1
F(n) = F(n − 1) + F(n − 2) for n > 2
 
Example 20	
Not every recurrence relation fits the pattern of Equation (6). Consider the recur-
rence relation
T(1) = 1
T(n) = 2nT(n −1) for n ≥2
Although this is a linear, first-order recurrence relation, it does not have constant 
coefficients. Equation (8) does not apply. To find a closed-form solution, we have 
to go back to the expand, guess, and verify technique.
T(n) = 2nT(n −1)
= 2n32(n −1)T(n −2)4 = 22n(n −1)T(n −2)
= 22n(n −1)32(n −2)T(n −3)4 = 23n(n −1)(n −2)T(n −3)
In general, it seems that
T(n) = 2kn(n −1)(n −2) … (n −(k −1))T(n −k)
When n − k = 1, then k = n − 1 and
T(n) = 2n−1n(n − 1)(n − 2) … (2)T(1) = 2n−1n(n − 1)(n − 2) … (2)(1) = 2n−1n!
This is our guess at a closed-form solution, which we verify by induction on n.
Base case, T(1):	 T(1) = 21−11! = 20(1) = 1, true
Assume T(k):	
T(k) = 2k−1k!
Show T(k + 1):	
T(k + 1) = 2k(k + 1)!
	
T(k + 1) = 2(k + 1)T(k)	
(by the recurrence relation)
 
= 2(k + 1)2k−1k!	
(by the inductive hypothesis)
 
= 2k(k + 1)!
Therefore our closed-form solution guess was correct.

Section 3.2   Recurrence Relations	
189
In such a sequence, we must have two “base case” values, that is, two known 
­values of the sequence in order to generate subsequent values.
We’d like to find a general solution formula for recurrence relations like (9). 
If we drop the second term, we of course have a linear first-order homogeneous 
recurrence relation with constant coefficients:
S(n) = c1S(n − 1)
From Equation (8), we know that the solution to this recurrence relation has the form
S(n) = cn−1
1
S(1)
Let’s express this solution as
	
S(n) = prn−1	
(10)
where r (that is, c1) is the solution (root) of the linear equation
	
t − c1 = 0	
(11)
and p (that is, S(1)) satisfies equation (10) for the initial condition n = 1:
S(1) = pr1−1 = pr0 = p
This viewpoint suggests a way in which we might conjecture a solution to 
equation (9). Since we now have two terms in the equation itself, let’s add a second 
term to (10) and represent a potential solution as
	
S(n) = prn−1
1
+ qrn−1
2
	
(12)
where r1 and r2 are two distinct roots of (extending (11) to a quadratic equation)
	
t2 − c1t − c2 = 0	
(13)
The p and q will have to be chosen to satisfy the two initial conditions:
S(1) = pr1−1
1
+ qr1−1
2
= p + q
S(2) = pr2−1
1
+ qr2−1
2
= pr1 + qr2
or, simplifying,
	
p + q = S(1)
	
pr1 + qr2 = S(2)	
(14)
Of course, this is just a wild leap of speculation on our part, so we must now verify 
that Equation (12) is a closed-form solution to recurrence relation (9).
We are trying to prove that
S(n) = prn−1
1
+ qrn−1
2
(where r1, r2, p, and q are as described) is a solution to
S(n) = c1S(n − 1) + c2S(n − 2)

190	
Recursion, Recurrence Relations, and Analysis of Algorithms
for all n ≥ 1. The “for all n ≥ 1” phrase suggests a proof by mathematical induc-
tion. Because S(n) has to “reach back” two values to compute the current value, 
we should use the second principle of induction.
Base Cases:
When n = 1, the proposed solution gives
S(1) = pr1−1
1
+ qr1−1
2
= p + q
When n = 2, the proposed solution gives
S(2) = pr2−1
1
+ qr2−1
2
= pr1 + qr2
Both are trivially true because we chose p and q to meet these very conditions.
Assume that for all r, 1 ≤ r ≤ k, S(r) = pr  r−1
1
+ qr  r−1
2
. Show that
S(k + 1) = prk
1 + qrk
2. Before we proceed, note that because r1 and r2 are ­solutions 
of the equation t2 − c1t − c2 = 0, it is true that
	
r 2
1 −c1r1 −c2 = 0	
or	
r 2
1 = c1r1 + c2	
	
r 2
2 −c1r2 −c2 = 0	
or	
r 2
2 = c1r2 + c2	
(15)
Now
S(k + 1) = c1S(k) + c2S(k −1)
	
(by the recurrence relation)
 = c1(prk−1
1
+ qrk−1
2
) + c2(prk−2
1
+ qrk−2
2
)	
(by the inductive 
 = prk−2
1
(c2 + c1r1) + qrk−2
2
(c2 + c1r2)
	
­hypothesis, applied twice)
 = prk−2
1
r2
1 + qrk−2
2
r2
2
	
(by Equation (15))
 = prk
1 + qrk
2
which is the desired result. This confirms that Equation (12) is a solution to 
­Equation (8).
	 The key to the solution is the quadratic equation
t 2 − c1t − c2 = 0
which is called the characteristic equation of the recurrence relation
S(n) = c1S(n − 1) + c2S(n − 2)
 
Example 21	
Solve the recurrence relation
S(n) = 2S(n − 1) + 3S(n − 2) for n ≥ 3
subject to the initial conditions
S(1) = 3
S(2) = 1

Section 3.2   Recurrence Relations	
191
In this recurrence relation, c1 = 2 and c2 = 3. To find the closed-form solution, we 
form the characteristic equation
t2 − 2t − 3 = 0
which has roots r1 = 3, r2 = −1. Equation (12) gives the solution form:
S(n) = p3n−1 + q(−1)n−1
where from Equation (14) p and q satisfy
p + q = 3
p(3) + q(−1) = 1
Solving this system of equations results in p = 1, q = 2. Therefore the ­closed-form 
solution is
S(n) = 3n−1 + 2(−1)n−1
Practice 13	
a.	 Using the base cases and the recurrence relation, compute the first five terms of the sequence 
S(n) of Example 21.
b.	Check that the closed-form solution formula in Example 21 produces the correct first five terms.
■
Although it would seem at this point that we have the solution method in 
hand for any linear second-order homogeneous recurrence relations with constant 
­coefficients, such is not the case. Consider the system of Equation (14):
p + q = S(1)
pr1 + qr2 = S(2)
We can solve the first equation for p—
p = S(1) − q
Practice 14	
Solve the recurrence relation
T(n) = 6T(n − 1) −5T(n − 2)  for n ≥ 3
subject to the initial conditions
T(1) = 5
T(2) = 13
■

192	
Recursion, Recurrence Relations, and Analysis of Algorithms
—and then substitute in the second equation to solve for q:
[S(1) − q]r1 + qr2 = S(2)
q(r2 − r1) = S(2) − S(1)r1
q = S(2) −S(1)r1
r2 −r1
Now what happens if the characteristic equation t2 − c1t − c2 = 0 happens 
to have one repeated root, that is, r1 = r2? Oops—we can’t solve this system of 
equations. The solution form when the characteristic equation has a repeated root 
r looks like
S(n) = prn−1 + q(n − 1)r n−1 for all n ≥ 1
where p and q satisfy the equations
p = S(1)
pr + qr = S(2)
This can be proved by induction in a manner similar to the distinct roots case  
(see Exercise 44).
 
Example 22	
Solve the recurrence relation
S(n) = 8S(n − 1) − 16S(n − 2) for n ≥ 3
subject to the initial conditions
S(1) = 1
S(2) = 12
In this recurrence relation, c1 = 8 and c2 = −16. To find the closed-form solution, 
we form the characteristic equation
t2 − 8t + 16 = 0 
(t − 4)2 = 0
which has a repeated root r = 4. The solution is
S(n) = p4n−1 + q(n − 1)4n−1
where
	
p = 1
	
p(4) + q(4) = 12
Solving this system of equations, p = 1 and q = 2, so the solution is
S(n) = 4n−1 + 2(n − 1)4n−1 = (2n − 1)4n−1

Section 3.2   Recurrence Relations	
193
Table 3.4 summarizes the solution steps for a linear second-order homoge-
neous recurrence relation with constant coefficients:
Divide-and-Conquer Recurrence Relations
Still another recurrence relation form occurs when the value of S(n) depends not 
on the previous term or on the two previous terms, but on the value halfway back 
in the sequence, S an
2b
Table 3.4
To Solve Recurrence Relations of the Form S(n) ∙ c1 S(n ∙ 1) ∙ c2 S(n ∙ 2)  
Subject to Initial Conditions S(1) and S(2)
1. Solve the characteristic equation t 2 − c1t − c2 = 0
2. If the characteristic equation has distinct roots r1 and r2, the solution is
S(n) = pr n−1
1
+ qr n−1
2
where
p + q = S(1)
pr1 + qr2 = S(2)
3. If the characteristic equation has a repeated root r, the solution is
S(n) = prn − 1 + q(n − 1)rn − 1 
where
p = S(1)
pr + qr = S(2)
The proofs for case 2 and case 3 are unchanged if the roots of the characteristic 
equation turn out to be complex numbers. In other words, the solution formulas still 
work.
Such recurrence relations will occur in the analysis of certain ­“divide- 
and-conquer” algorithms, algorithms that solve a problem by breaking it into 
smaller versions, each half the size of the original (see the next section). Hence 
such recurrence relations are called divide-and-conquer recurrence ­relations. 
The general form is
	
S(n) = cSan
2b + g(n) for n ≥ 2, n = 2m	
(16)
 
Example 23	
Consider the sequence with the following values:
S(1) = 2, S(2) = 4, S(4) = 8, S(8) = 16, S(16) = 32, …
We are looking at only selected terms of the sequence, namely S(n) where n is a 
power of 2. For these terms, we can see that S(n) = 2San
2b

194	
Recursion, Recurrence Relations, and Analysis of Algorithms
where c is a constant and g can be an expression involving n. It’s convenient to 
look only at values of n that are powers of 2 because then cutting n in half over 
and over always results in an integer. As we will see in the next section, this is not 
a significant restriction.
To solve a divide-and-conquer recurrence relation, we go back to the expand, 
guess, and verify approach. Also, the solution will involve the logarithm function; 
for a review of the logarithm function and its properties, see Appendix C.
 
Example 24	
Solve the recurrence relation
C(n) = 1 + Can
2b for n ≥ 2, n = 2m
subject to the basis step
C(1) = 1
Expanding, we get
C(n) = 1 + Can
2b
 
= 1 + a1 + Can
4bb
 
= 1 + 1 + a1 + Can
8bb
(
and the general term seems to be
C(n) = k + Ca n
2kb
The process stops when n/2k = 1 or 2k = n, which means k = log2 n. (We’ll omit 
the base 2 notation from now on—log n will mean log2 n. See Appendix C for a 
brief discussion of logarithms.) Then
C(n) = log n + C(l) = 1 + log n
Now we will use induction to verify that C(n) = 1 + log n for all n ≥ 1, 
n = 2m. This is a somewhat different form of induction, because the only values of 
interest are powers of 2. We still take 1 as the basis step for the induction, but then 
we prove that if our statement is true for a value k, it is true for 2k. The statement 
will then be true for 1, 2, 4, 8, … , that is, for all nonnegative integer powers of 2, 
which is just what we want.
For the base case,
C(1) = 1 + log 1 = 1 + 0 = 1, true

Section 3.2   Recurrence Relations	
195
Assume that C(k) = 1 + log k. Then
	
C(2k) = 1+ C(k)	
(by the recurrence relation)
 
= 1 + 1 + log k	
(by the inductive hypothesis)
 
= 1 + log 2 + log k	
(log 2 = 1)
 
= 1 + log 2k	
(property of logarithms)
This calculation completes the inductive proof.
We’d like to find a closed-form solution for (16) subject to the basis that S(1) 
is known. We could use the expand, guess, and verify approach to find the general 
solution, but instead we will do a transformation on (16) to convert it to a first-
order recurrence relation with constant coefficients, use the solution formula we 
already have for such a recurrence relation, and then reverse the transformation. 
Figure 3.2 shows this round-about approach.
Equation (16) assumes that n = 2m with n ≥ 2. From this it follows that 
m = log n and m ≥ 1. Substituting 2m for n in equation (16) results in
	
S(2m) = cS(2m−1) + g(2m)	
(17)
Now, letting T(m) represent S(2m) in Equation (17), we get
	
T(m) = cT(m − 1) + g(2m) for m ≥ 1	
(18)
Equation (18) is a linear, first-order equation with constant coefficients; from 
Equation (8), we obtain the solution
	
T(m) = cm−1T(1) + ∙
m
i=2
cm−ig(2i)	
(19)
subject to the basis condition that T(l) is known. Because Equation (18) holds for 
m = 1, we know that
T(1) = cT(0) + g(2)
Figure 3.2
B. First-order
    recurrence relation,
    constant coefﬁcients
Solution to B
Solution to A
A. Divide & conquer
    recurrence relation

196	
Recursion, Recurrence Relations, and Analysis of Algorithms
Making this substitution in (19) results in
	
T(m) = cmT(0) + ∙
m
i=1
cm−ig(2i)	
(20)
Now reversing the substitution T(m) = S(2m), (20) becomes
S(2m) = cmS(20) + ∙
m
i=1
cm−ig(2i)
Finally, letting 2m = n or m = log n, we get
	
S(n) = clog nS(1) + ∙
log n
i=1
c(log n)−ig(2i)	
(21)
Equation (21) thus represents the solution for the recurrence relation (16). As 
before, to use this general solution you need only match your recurrence relation 
to (16) to determine c and g(n), then substitute into Equation (21). Again as be-
fore, g(n), gives a recipe for what to do with an argument n; in Equation (21), the 
argument is 2i. If you can evaluate the resulting summation, you will then have a 
closed-form solution. Table 3.5 outlines the solution steps.
REMINDER
In the summation part 
of the general ­solution 
­formula, c is raised to the 
(log n) − i power, not  
(log n) − 1
Table 3.5
To Solve Recurrence Relations of the Form S(n) ∙ cSan
2b ∙ g(n) for n # 2, 
n ∙ 2m Subject to Initial Condition S(1)
1. Match your recurrence relation to the form
S(n) = cSan
2b + g(n)
to find c and g(n).
2. Use c, g(n) and S(1) in the formula
S(n) = clog nS(1) + ∙
 log n
i=1
c(log n)−ig(2i)
3. Evaluate the resulting summation to get the final expression.
	
Example 25	
The recurrence relation
C(1) = 1
C(n) = 1 + Can
2b  for n ≥ 2, n = 2m
matches Equation (16), with c = 1 and g(n) = 1. Because  g(n) = 1, the g function 
evaluates to 1 no matter what the argument is. The solution, according to formula 
(21), is
C(n) = 1log nC(1) + ∙
log n
i=1
1(log n)−i(1)
= 1 + (log n)(1) = 1 + log n
which agrees with our previous result from Example 24.

Section 3.2   Recurrence Relations	
197
 
Example 26	
Solve the recurrence relation
T(1) = 3
T(n) = 2T an
2b + 2n
This is a match for Equation (16), where c = 2 and g(n) = 2n. Therefore 
g(2i) = 2(2i). Substituting into Equation (21)—the solution of Equation (16)—
gives the following result, where we use the fact that 2log n = n.
T(n) = 2log nT(1) + ∙
log n
i=1
2log n−i2(2i)
= 2log n(3) + ∙
log n
i=1
2log n+1
= n(3) + (2log n+1)log n
= 3n + (2log n # 2)log n
= 3n + 2n log n
Practice 15	
Show that the solution to the recurrence relation
S(1) = 1
S(n) = 2San
2b + 1 for n ≥2, n = 2m
is 2n − 1. (Hint: See Example 15 in Section 2.2 and note that 2log n = n.)
■
Exercises 3.2
In Exercises 1–12, solve the recurrence relation subject to the basis step.
	 1.	 S(1) = 5
	
	 S(n) = S(n − 1) + 5 for n ≥ 2
	 2.	 B(1) = 5
	
	 B(n) = 3B(n − 1) for n ≥ 2
S e c t i o n  3 . 2 	 Review
Techniques
•	 Solve recurrence relations by the expand, guess, 
and verify technique.
•	 Solve linear, first-order recurrence relations with 
constant coefficients by using a solution formula.
•	 Solve linear, second-order homogeneous ­recurrence 
relations with constant coefficients by using the 
characteristic equation.
•	 Solve divide-and-conquer recurrence relations by 
using a solution formula.
Main Idea
•	 Certain recurrence relations have closed-form 
­solutions.
W
W

198	
Recursion, Recurrence Relations, and Analysis of Algorithms
	 3.	 F(1) = 2
	
	 F(n) = 2F(n − 1) + 2n for n ≥ 2
	 4.	 T(1) = 1
	
	 T(n) = 2T(n − 1) + 1 for n ≥ 2
	
	 (Hint: See Example 15 in Section 2.2.)
	 5.	 A(1) = 1
	
	 A(n) = A(n − 1) + n for n ≥ 2
	
	 (Hint: See Practice 7 in Section 2.2.)
	 6.	 S(1) = 1
	
	 S(n) = S(n − 1) + (2n − 1) for n ≥ 2
	
	 (Hint: See Example 14 in Section 2.2.)
	 7.	 T(1) = 1
	
	 T(n) = T(n − 1) + n2 for n ≥ 2
	
	 (Hint: See Exercise 7 in Section 2.2.)
	 8.	 P(1) = 2
	
	 P(n) = 2P(n − 1) + n2n	 for n ≥ 2
	
	 (Hint: See Practice 7 in Section 2.2.)
	 9.	 F(1) = 1
	
	 F(n) = nF(n − 1) for n ≥ 2
	 10.	S(1) = 1
	
	 S(n) = nS(n − 1) + n! for n ≥ 2
	 11.	A(1) = 1
	
	 A(n) = 2(n − 1)A(n − 1) for n ≥ 2
	
	 (Hint: 0! is defined to equal 1.)
	 12.	P(1) = 2
	
	 P(n) = 3(n + 1)P(n − 1) for n ≥ 2
	 13.	At the beginning of this chapter the contractor claimed:
The material to be stored at the chemical disposal site degrades to inert matter at the rate of 5% per 
year. ­Therefore only about one-third of the original active material will remain at the end of 20 years.
	
a.	 Write a recurrence relation T(n) for the amount of active material at the beginning of year n. Assume 
that T(1) = X, a specific but unknown amount.
	
b.	Solve the recurrence relation.
	
c.	 Compute T(21) to check the contractor’s claim; note that the end of 20 years is the beginning of the  
21st year.
	 14.	 A colony of bats is counted every 2 months. The first four counts are 1200, 1800, 2700, and 4050.
	
a.	 Assuming that this growth rate continues, write a recurrence relation for the number of bats at count n.
	
b.	Solve the recurrence relation.
	
c.	 What will the 12th count be?
	 15.	Spam e-mail containing a virus is sent to 1,000 e-mail addresses. After 1 second, a recipient machine 
broadcasts 10 new spam e-mails containing the virus, after which the virus disables itself on that  
machine.

Section 3.2   Recurrence Relations	
199
	
a.	 Write a recurrence relation for the number of e-mails sent at the start of the nth second.
	
b.	Solve the recurrence relation.
	
c.	 How many e-mails are sent at the end of 20 seconds (that is, at the beginning of the 21st second)?
	 16.	Total natural gas consumption in the state of New Jersey was 614,908 million cubic feet in 2008 and 
653,459 million cubic feet in 2010.
	
a.	 Assuming a constant annual percentage growth rate r, write a recurrence relation (in terms of r) for the 
total natural gas consumption in New Jersey in year n.
	
b.	Solve the recurrence relation (in terms of r).
	
c.	 Using the given data, compute the value of r.
	
d.	What will be the total natural gas consumption in New Jersey in the year 2020?
	 17.	A loan of $5,000 is charged a 12% annual interest rate. An $80 payment is made each month.
	
a.	 Write a recurrence relation for the loan balance remaining at the beginning of month n.
	
b.	Solve the recurrence relation. (See Exercise 27 of Section 2.2 for the formula for the sum of a geometric 
sequence.)
	
c.	 How much is left of the loan balance at the beginning of the 19th month?
	 18.	In an account that pays 3% annually, $1,000 is deposited. At the end of each year, an additional $100 is 
deposited into the account.
	
a.	 Write a recurrence relation for the amount in the account at the beginning of year n.
	
b.	Solve the recurrence relation. (See Exercise 27 of Section 2.2 for the formula for the sum of a geometric 
sequence.)
	
c.	 What is the account worth at the beginning of the 8th year?
	 19.	The shellfish population in a bay is estimated to have a count of about 1,000,000. Studies show that 
­pollution reduces this population by about 2% per year, while other hazards are judged to reduce the 
population by about 10,000 per year.
	
a.	 Write a recurrence relation for the shellfish population at the beginning of year n.
	
b.	Solve the recurrence relation. (See Exercise 27 of Section 2.2 for the formula for the sum of a geometric 
sequence.)
	
c.	 What is the approximate shellfish population at the beginning of year 10?
	 20.	A certain protected species normally doubles its population each month. The initial population is 20, 
but by the beginning of the next month, 1 specimen has died of an infection. In successive months, the 
­infection kills 2, then 4, then 8, and so forth.
	
a.	 Write a recurrence relation for the size of the population at the beginning of month n.
	
b.	Solve this recurrence relation.
	
c.	 What is the size of the population at the beginning of month 7?
	 21.	A computer virus that spreads by way of e-mail messages is planted in 3 machines the first day. Each 
day, each infected machine from the day before infects 5 new machines. By the end of the second day, a 
software solution has been found to counteract the virus, and 1 machine is clean at that point. Each day 
thereafter, 6 times as many machines are clean as were clean the day before.
	
a.	 Write a recurrence relation for the total number of infected machines on day n.
	
b.	Solve this recurrence relation.
	
c.	 How many days will it be before the effects of the virus are completely gone?
	 22.	This problem concerns the Towers of Hanoi puzzle (see Exercise 82 in Section 3.1).
	
a.	 Based on the recursive algorithm of Exercise 82 in Section 3.1, find a recurrence relation M(n) for the 
number of disk moves required to solve the Towers of Hanoi puzzle for n disks.

200	
Recursion, Recurrence Relations, and Analysis of Algorithms
	
b.	Solve this recurrence relation. (Hint: See Exercise 15 in Section 2.2.)
	
c.	 Go through the steps of the solution algorithm for n = 3 and record the number of disk moves required. 
Compare this number with the result from part (b) with n = 3.
	
d.	The mythical origin of the Towers of Hanoi puzzle concerns 64 golden disks that a group of monks are 
moving from one tower to another. When their task is complete, the world will end. Assuming that the 
monks can move 1 disk per second, calculate the number of years to complete the task.
	 23.	Early members of the Pythagorean Society defined figurate numbers to be the number of dots in certain 
geometrical configurations. The first few triangular numbers are 1, 3, 6, and 10:
1
3
6
10
	
	 Find and solve a recurrence relation for the nth triangular number. (Hint: See Practice 7 in Section 2.2.)
	 24.	The first few square numbers (see the previous Exercise) are 1, 4, 9, and 16:
16
1
9
4
	
	 Find and solve a recurrence relation for the nth square number. (Hint: See Example 14 in Section 2.2.)
	 25.	The first few pentagonal numbers (see Exercise 23) are 1, 5, 12, and 22:
1
5
12
22
	
	 Find and solve a recurrence relation for the nth pentagonal number. (Hint: See Exercise 28 of Section 2.2 
for the formula for the sum of an arithmetic sequence.)
	 26.	Use induction to verify that equation (8) of this section is the solution to the recurrence relation (6) subject 
to the basis condition that S(1) is known.
In Exercises 27–34, solve the recurrence relation subject to the initial conditions.
	 27.	T(1) = 5
	
T(2) = 11
	
T(n) = 5T(n − 1) − 6T(n − 2) for n ≥ 3

Section 3.2   Recurrence Relations	
201
	 28.	A(1) = 7
	
A(2) = 18
	
A(n) = 6A(n − 1) − 8A(n − 2) for n ≥ 3
	 29.	S(1) = 4
	
S(2) = −2
	
S(n) = −S(n − 1) + 2S(n − 2) for n ≥ 3
	 30.	P(1) = 5
	
P(2) = 17
	
P(n) = 7P(n − 1) − 12P(n − 2) for n ≥ 3
	 31.	F(1) = 8
	
F(2) = 16
	
F(n) = 6F(n − 1) − 5F(n − 2) for n ≥ 3
	 32.	T(1) = −1
	
T(2) = 7
	
T(n) = −4T(n − 1) − 3T(n − 2) for n ≥ 3
	 33.	B(1) = 3
	
	 B(2) = 14
	
	 B(n) = 4B(n − 1) − 4B(n − 2) for n ≥ 3
	 34.	F(1) = −10
	
F(2) = 40
	
F(n) = −10F(n − 1) − 25F(n − 2) for n ≥ 3
In Exercises 35 and 36, solve the recurrence relation subject to the initial conditions; the solutions involve 
complex numbers.
	 35.	A(1) = 8
	
A(2) = 8
	
A(n) = 2A(n − 1) −2A(n − 2) for n ≥ 3
	 36.	S(1) = 4
	
S(2) = −8
	
S(n) = −4S(n − 1) − 5S(n − 2) for n ≥ 3
	 37.	Solve the Fibonacci recurrence relation
F(1) = 1
F(2) = 1
	
F(n) = F(n − 1) + F(n − 2) for n > 2
	
	 Compare your answer with Exercise 31 of Section 3.1.
	 38.	Find a closed-form solution for the Lucas sequence
L(1) = 1
L(2) = 3
	
L(n) = L(n − 1) + L(n − 2) for n ≥ 3

202	
Recursion, Recurrence Relations, and Analysis of Algorithms
	 39.	Houses in a new development go on sale initially for an average price of $200,000. At the beginning of 
month 2, the average sale price has risen to $250,000. At the beginning of each succeeding month, the 
average price increase is half what it was the previous month.
	
a.	 Write and solve a recurrence relation for M(n), the average sale price at the beginning of month n.
	
b.	At the beginning of which month is the average price within $2,000 of $300,000?
	 40.	A contaminated soil site is tested monthly for the presence of a particular microorganism. Initially,  
950 microorganisms per cubic foot of soil are found; at the beginning of month 2, there are 1,000 organ-
isms per cubic foot. Left untreated, the growth rate of this microorganism increases by 25% per month.
	
a.	 Write and solve a recurrence relation for O(n), the number of organisms present per cubic foot at the 
beginning of month n.
	
b.	At the end of what month does the number of organisms first exceed 5,000 per cubic foot?
	 41.	Prove that the number of binary strings of length n with no two consecutive 0s is given by the Fibonacci 
sequence term F(n + 2). (Hint: Write a recurrence relation; consider strings of length n that end in 1 and 
those that end in 0.)
	 42.	a.	 Find a recurrence relation for the number of binary strings of length n that have two consecutive 1s.
	
b.	How many binary strings of length 4 have two consecutive 1s? What are these strings?
	 43.	Consider the recurrence relation S(n) = c1S(n − 1) as a linear second-order homogeneous recurrence 
­relation with constant coefficients where c2 = 0. Solve this recurrence relation using its characteristic 
equation, and prove that the solution is the same as that of Equation (8).
	 44.	Prove that
S(n) = prn−1 + q(n − 1)rn−1
where
p = S(1)
pr + qr = S(2)
	
	 is a solution to the recurrence relation S(n) = c1S(n − 1) + c2S(n − 2) for all n ≥ 1 if r is a repeated root 
of the characteristic equation.
In Exercises 45–48, solve the recurrence relation subject to the basis step. (Hint: See Example 15 in Section 2.2,  
and note that 2log n = n.)
	 45.	P(1) = 1
	
P(n) = 2Pan
2b + 3 for n ≥ 2, n = 2m
	 46.	T(1) = 3 
	
T(n) = Tan
2b + n for n ≥ 2, n = 2m
	 47.	S(1) = 1
	
S(n) = 2San
2b + n for n ≥ 2, n = 2m
	 48.	P(1) = 1
	
P(n) = 2Pan
2b + n2 for n ≥ 2, n = 2m

Section 3.3   Analysis of Algorithms	
203
	
S e c t i o n  3 . 3 	 Analysis of Algorithms 
The General Idea
Often more than one algorithm can perform the same task. Because we assume that 
all these algorithms perform correctly, we need some other basis of ­comparison to 
decide which algorithm to use in a given situation. Several criteria could be used 
to judge which is the “best” algorithm. We might ask, for example, which is easi-
est to understand, which makes the most efficient use of machine memory when 
implemented as computer code, or which runs most efficiently. One might expect 
that to judge whether an algorithm is “running efficiently” means standing by with 
a stopwatch while the computer code executes. But the stopwatch ­approach may tell 
us more about the speed of the processor than it does the inherent efficiency of the 
algorithm. Even timing the code for competing algorithms on the same processor 
and using the same input data can give a misleading picture of what might happen 
when the input data set is larger.
Instead, we evaluate the time efficiency of an algorithm by estimating the 
number of operations it must perform. We count only the operations that are 
basic to the task at hand, not “housekeeping” operations that make just a small 
­contribution to the total work required.
The study of the efficiency of algorithms, that is, the number of operations 
they perform, is called analysis of algorithms. Various techniques for algorithm 
analysis have been developed. Sometimes a rather straightforward analysis can be 
done simply by inspecting the algorithm.
	
EXAMPLE 27	
Following is an algorithm to write out, for each student on a grade roster, the sum 
of m quiz grades minus the lowest grade. The outer loop goes through each of the 
n students; the inner loop goes through the quizzes for the current student. For each 
student, the successive quiz grades are added and the lowest grade is ultimately 
subtracted from the sum of all the grades. These additions and subtractions seem 
fundamental to how the algorithm works, so we will count the work contributed by 
these arithmetic operations.
for i = 1 to n do
low = roster[i].quiz[1]
sum = roster[i].quiz[1]
for j = 2 to m do
sum = sum + roster[i].quiz[ j]	
//A
if roster[i].quiz[ j] < low then
low = roster[i].quiz[ j]
end if
end for
sum = sum − low	
//S 
write(“Total for student”, i, “is”, sum)
end for
Subtraction occurs at the line marked //S, which is executed once for each 
pass through the outer loop (once for each student), a total of n times. Addition, 

204	
Recursion, Recurrence Relations, and Analysis of Algorithms
­however, occurs at the line marked //A. This is done within the inner loop, which 
executes m − 1 times for each student, that is, for each of the n passes of the outer 
loop. The total number of additions is therefore n(m − 1). The total number of 
­arithmetic operations is n + n(m − 1) = nm. Of course the value of this expression 
depends on n (the number of students) and m (the number of quizzes). The quanti-
ties n and m measure the amount of input data; virtually any algorithm’s work will 
change with the input size.
The algorithm also does some “housekeeping” work. Values are assigned 
to variables, comparisons are done (to find the lowest quiz grade for each stu-
dent), and for the loop indices i and j have to be incremented. But the number of 
times these operations are done also depends on the number of times through the 
loops, so their effect might be to multiply the nm result by some constant factor. In 
­comparing algorithms A and B, we’re usually looking for bigger differences than 
just a constant multiple, which is why we ignore the housekeeping details.
Now suppose the task is to search a sorted list of n words or numbers for a 
particular target value x. We already have one algorithm to perform this task, the 
binary search algorithm from Section 3.1. Another algorithm for the same task, the 
sequential search algorithm, simply compares x with each entry in the list in turn 
until either x is found or the list is exhausted. (This algorithm actually works on any 
list, sorted or not.) A pseudocode description of the sequential search algorithm is 
given in the following box.
	
Algorithm	
SequentialSearch
SequentialSearch(list L; integer n; itemtype x)
//searches a list L of n items for item x
Local variable:
integer i	
//marks position in the list
	
i = 1
	
while L[i] ∙ x and i < n do
	
i = i + 1
	
end while
	
if L[i] = x then
	
write(“Found”)
	
else
	
write(“Not found”)
	
end if
end function SequentialSearch
Both binary search and sequential search work by comparing elements from 
the list with the target value x until a match is found. In fact it is difficult to imag-
ine how any possible search algorithm could avoid such comparisons, so these 
­comparisons will be the basic operation to count in analyzing these two ­algorithms.

Section 3.3   Analysis of Algorithms	
205
The sequential search algorithm does the maximum amount of work (number 
of comparisons) when x is the last item in the list or when x does not appear in 
the list at all. In either case, all elements are compared to x, so n comparisons are 
done. This is the “worst case” for this algorithm, and the work depends on the size 
n of the input (the length of the list). The minimum amount of work is done when 
x is the very first item in the list; only one comparison is made. This is the “best 
case” for this algorithm. (In the algorithm of Example 27, the same number of 
arithmetic operations is always done; there is no best or worst case.)
There are many possibilities between the best case and the worst case. If x falls 
in the exact middle of the list, the search would require roughly n/2 comparisons. 
It would be helpful to obtain some measure of the “average” amount of work done. 
This measure would require some way to describe the average list being searched 
and the average relationship of a target item x to that list. ­Exercises 35 and 36 
in this section explore some aspects of average case analysis for the ­sequential 
search algorithm. For most algorithms, however, average behavior is very difficult 
to determine. To compare the efficiency of algorithms, therefore, we often content 
ourselves with the worst-case count of the number of operations required.
	
EXAMPLE 28	
Given a long string of text characters, can we find the first instance of a particular 
substring or “pattern” within the text? This problem has a number of important 
­applications, such as
•	 looking for specific strings in an HTML document that might be governed 
by a style rule of a Cascading Style Sheet.
•	 using the UNIX grep command to search a file for a specified string, or the 
“Find” command in any text editor or word processor.
•	 looking for specific gene sequences within a strand of DNA.
DNA is a long molecule that is basically a chemically bonded chain of smaller 
molecules called nucleotides. There are four nucleotides, abbreviated as A, C, G, 
and T. Thus a section of DNA might be represented as the sequence
…TAATCATGGTCATAGCTGTTTCCTGTGTGAAATTG…
DNA is stored within the cells of living organisms on chromosomes; ­various 
sections of these chromosomes are identified as genes. Genes, through their 
DNA “instructions,” create proteins that control specific functions or traits with-
in the organism (hair color, blood type, and so on). Thus our entire genetic code 
requires only four symbols! “Mapping the human genome”, that is, ­determining 
the entire DNA sequence of humans, was a huge scientific undertaking, essen-
tially completed in 2003, although the work of identifying specific genes and 
their particular function is ongoing. It is known, for example, that the disease 
cystic fibrosis is caused by a mutation in a particular gene (DNA sequence) that 
is composed of about 230,000 nucleotides.
The most intuitive (although not the most efficient) string pattern-matching 
algorithm compares the pattern (a string of length m) against the text (a string of 
length n with n ≥ m), starting with the first character of the text and marching 
through the pattern.

206	
Recursion, Recurrence Relations, and Analysis of Algorithms
T1   T2   T3 … Tm   Tm+1   …   Tn
 `     `     `        `
P1   P2   P3 … Pm
If all m characters match, the pattern has been found. If there is a mismatch at some 
point between the text and the pattern, the pattern slides over one character in the 
text, and the matching process begins again.
T1   T2   T3 … Tm   Tm+1   …   Tn
        `    `                 `
	
   P1 P2 P3   …   Pm
The last segment of text where the pattern could possibly occur is the last m 
­elements of the text. This segment begins at Tn−m+1, as shown below.
T1   T2   T3 … Tn−m+1   Tn−m+2 … Tn−m+m = Tn
                `              `	
`
	
   P1        P2    …    Pm
For example, if the text is 23 characters long and the pattern is 5 characters long, 
then the last piece of text that can possibly hold the pattern is T19T20T21T22T23.
The unit of work in this algorithm is comparisons between a text character and 
a pattern character. The best case occurs when the pattern is found as the first m 
characters of the text, which requires m comparisons. The worst case is when the 
pattern does not occur in the text at all, and the pattern “window” slides all the way 
over to Tn−m+1. From each of those n − m + 1 starting points, the pattern fails 
to be found, but the worst case is if the pattern almost matches and only the last 
character fails. For example, consider the text and pattern shown:
Text: TTTTTTTTTTTTT
Pattern: TTTTTS
This example requires m comparisons (the first m − 1 are matches and only the 
mth comparison fails) at each of the n − m + 1 starting positions, making the total 
number of comparisons m(n − m + 1).
Analysis Using Recurrence Relations
In this section we will analyze algorithms that are defined recursively. Because 
much of the activity of a recursive algorithm takes place “out of sight” in the 
many invocations that can occur, an analysis using the direct counting technique 
of ­Example 27 won’t work. Analysis of recursive algorithms usually involves 
­solving a recurrence relation.

Section 3.3   Analysis of Algorithms	
207
	
EXAMPLE 29	
We can recast the sequential search algorithm from an iterative version 
­(repeating some action over and over in a loop) to a recursive version. The base 
case says that you check whether you have run off the end of the list and if not, 
you check for the target x at the first position in the list. If you find it, fine, if not, 
then you invoke the algorithm again on the rest of the list. Here is ­pseudocode 
for the recursive function to search the list from L[i] to L[n]; the function is 
invoked initially with i = 1.
	
Algorithm	
SequentialSearchRecursive
SequentialSearchRecursive(list L; integer i, n; itemtype x)
//searches list L from L[i] to L[n] for item x
if i > n then
write(“not found”)
else
if L[i] = x then
write(“found”) 
else
SequentialSearchRecursive(L, i + 1, n, x)
end if
end if
end function SequentialSearchRecursive
Figure 3.3 gives a visual representation of the recursive sequential search ­algorithm. 
Each time the algorithm is invoked, the new list to be searched is only 1 element shorter 
than the previous list, so in the worst case the algorithm has to work quite hard.
Search
here;
if fail,
not in list
Search
here;
if fail,
search here
Search
here;
if fail,
search here
if fail,
search here
Search
here;
Search
here;
Search
here;
if fail,
search here
if fail,
search here
Figure 3.3

208	
Recursion, Recurrence Relations, and Analysis of Algorithms
Let C(n) represent the maximum number of comparisons required for an 
­n-element list. This is a symbolic expression for an answer we are assuming we 
don’t already know, but will learn by solving the recurrence relation. By this no-
tation, C(n − 1) symbolically represents the maximum number of comparisons 
­required to search the rest of the list after the first position. The recurrence relation is
	
C(1) = 1	
	 (1 comparison to search a 1-element list)
	C(n) = 1 + C(n − 1) for n ≥ 2	
(1 comparison against the first element, 
	
	 	
	
	
then however many comparisons 
	
	 	
	
	
are required for the rest of the list)
This is a first-order, linear recurrence relation with constant coefficients. By 
­Equation (8) in Section 3.2, the solution is
C(n) = (1)n−1(1) + ∙
n
i=2
(1)n−i(1) = 1 + (n −1) = n
This agrees with our previous analysis for the worst case.
 
EXAMPLE 30	
Now let’s do a worst-case analysis of the binary search algorithm. Recall that ­binary 
search is a recursive algorithm that operates on a list that is sorted in ­increasing 
order. It first does one comparison of the target with the midpoint value of the list. 
If this comparison fails, then the process is repeated on the right half or the left half 
of the list, depending on whether the target value is greater than or less than the 
midpoint value. Figure 3.4 illustrates one possible worst-case path.
Search
here;
if fail,
not in list
Search
here;
Search
here;
if fail, test
for smaller or larger
Search
here;
if fail, test
for smaller or larger
if fail, test
for smaller or larger
Figure 3.4
Binary search is a divide-and-conquer algorithm, where the problem is 
­decomposed recursively into significantly smaller subproblems. If the original list 
is n elements long, then half the list is at worst n/2 elements long. (In the 8-element 
list of Example 14, for instance, when 10 is the midpoint value, the right “half” of 
the list has 4 elements but the left “half” has only 3.) Cutting the list in half makes 
much faster progress than reducing the list by one element, as in sequential search, 
so we expect the worst case of binary search to require less work.

Section 3.3   Analysis of Algorithms	
209
Let C(n) stand for the maximum number of comparisons required to do a 
­binary search on an n-element list. Then Can
2b stands for the maximum number 
of comparisons required to search a list half that size. If we are to keep cutting the 
list in half, it is convenient to consider only the case where we get an integer value 
each time we cut in half, so we will assume that n = 2m for some m ≥ 0.The recur-
rence relation for C(n) is
C(1) = 1	
(1 comparison to search a 
1-­element list)
C(n) = 1 + Can
2b for n ≥ 2, n = 2m	
(1 comparison against the middle 
element, then however many 
comparisons are required for half 
the list)
This recurrence relation was solved in the previous section (Examples 24 and 25). 
The solution is
C(n) = 1 + log n
By the preceding example, the maximum number of comparisons ­required 
to do a binary search on an n-element ordered list, with n = 2m, is 1 + log n. 
In ­Example 14, n was 8, and four comparisons (1 + log 8) were required in the 
worst case (x not in the list). A sequential search would require eight ­comparisons.  
Because
1 + log n < n for n = 2m, n ≥ 4
binary search is almost always more efficient than sequential search. However, 
the sequential search algorithm does have one big advantage—if the list being 
searched is unsorted, the sequential search algorithm works, but the binary search 
algorithm does not. If we first sort the list and then use the binary search algo-
rithm, we must then consider the work involved in sorting the list. Exercises 13–34 
at the end of this section ask you to count the operations required to sort a list by 
several different algorithms.
■
Practice 16	
Fill in the following table for the worst-case number of comparisons required for 
­sequential search and binary search on a list of the indicated size.
n
Sequential Search
Binary Search
64
1024
32768
Although we have computed the work for binary search only on a list of size n 
where n is a power of 2, this gives us a range for the work required for values of n 

210	
Recursion, Recurrence Relations, and Analysis of Algorithms
that fall between powers of 2. That’s why limiting n to powers of 2 in our analysis 
is not particularly significant.
Upper Bound (Euclidean Algorithm)
The Euclidean algorithm, as presented in Section 2.3, uses a while loop to do 
­successive divisions to find gcd(a, b) for positive integers a and b, a > b. To 
­analyze the Euclidean algorithm, we must first decide on the operation we are 
counting. Because the Euclidean algorithm does repeated divisions, we’ll take the 
division operation as our unit of work. Because a > b, we can take a as a measure 
of the size of the input values (which we usually denote by n). We want to find E(a), 
where this denotes the amount of work (the number of divisions) required to find 
gcd(a, b) in the worst case.
A recursive version of the Euclidean algorithm can also be written (see  
Exercise 81, Section 3.1); the key to the recursive version is to recognize that  
gcd(a, b) involves finding gcd(b, r), where r is the remainder on dividing a by 
b. We’ve just seen a case where the operations of a recursive algorithm (binary 
search) could be expressed neatly as a recurrence relation where the input size gets 
halved after each operation. A recurrence relation would express E(a) in terms of 
E at smaller values. But what are these smaller values? To find gcd(a, b) we find  
gcd(b, r), so it is clear that the input size is getting smaller, but in what way? Con-
sider Example 27 of Section 2.3, where to find gcd(420, 66) the following divisions 
were performed:
	
 6	
 2	
 1	
 3
	
 66q420	
 24q66	
 18q24	
 6q18
	
 396	
 48	
 18	
 18
	
 24	
 18	
 6	
 0
Here the successive values being divided are 420, 66, 24, 18. The change from 
420 to 66 is much larger than cutting in half, while the change from 24 to 18 is less.
In fact, we won’t find a recurrence relation or an exact expression for E(a). But 
we will at least find an upper bound for E(a). An upper bound is a ceiling on the 
amount of work an algorithm does; the algorithm can require no more steps than 
the upper bound, but it may not require that many.
To find this upper bound, we will show that if i > j and i is divided by j with 
remainder r, then r < i/2. There are two cases:
	
1.	 If j ≤ i/2, then r < i/2 because r < j.
	
2.	 If j > i/2, then i = 1 * j + (i − j); in other words, the quotient is 1 and r is 
i − j, which is < i/2.
In the Euclidean algorithm, the remainder r at any step becomes the dividend 
(the number being divided) two steps later. So the successive dividends are at least 
halved every two divisions. The value a can be halved log n times, therefore at 
most 2 log n divisions are done. Thus
	
E(a) ≤ 2 log a	
(1)
The value of 2 log a for a = 420 is almost 18, whereas it took only 4 ­divisions 
to find gcd(420, 66). Evidently this upper bound estimate is rather loose, like 
­saying that every student in this class is under 12 feet in height. An improved (that 
is, lower) upper bound is derived in Exercises 37–40 at the end of this section.

Section 3.3   Analysis of Algorithms	
211
Special Interest Page
Of Trees % and Pancakes
Of Trees %
Mapping the evolutionary “tree of life” has been 
the subject of research since Charles Darwin. Until 
­recently, this research sought to find similarities be-
tween species based on structural properties such 
as skeletons, but today scientists search for similari-
ties in DNA and other genetic evidence. This field of 
­research, called phylogenetics, can involve aligning 
the molecular sequences of many thousands of species, 
and the work becomes an enormous computational 
problem. Researchers at the University of Texas have 
developed a software package called SATé (and a new 
and improved SATé-II)—Simultaneous Alignment 
and Tree Estimation—that uses a divide-and-conquer 
algorithm. Huge data sets are divided into small data 
sets, alignments are found for the small sets, and then 
the results are combined to determine an overall align-
ment (and a likely tree) for the full data set. The re-
sulting full alignment isn’t foolproof, and the software 
repeats this process many times, creating new align-
ments and trees. A statistical “maximum likelihood” 
method selects the best result by comparison with 
known answers. This approach has been proven to 
produce results comparable to other, slower methods, 
or to produce more accurate results in the same amount 
of time.
Sequence alignment and evolutionary t­ree-building 
tools have applications to areas other than tracing the 
path of historical evolution. For example, the Centers 
for Disease Control use them to detect how a newly 
emerging virus differs from previous viruses in order 
to plan the best counterattack.
http://www.tacc.utexas.edu/news/feature-stories/2012/ 
tree-of-life
http://www.ncbi.nlm.nih.gov/pubmed/22139466
% and Pancakes
A problem posed in the American Mathematical 
Monthly in 1975 by Jacob Goodman concerned a 
waiter in a café where the cook produced a stack of 
pancakes of varying sizes. The waiter, on the way to 
delivering the stack to the customer, attempted to ar-
range the pancakes in order by size, with the largest 
on the bottom. The only action available was to stick 
a spatula into the stack at some point and flip the en-
tire stack above that point. The question is: What is the 
maximum number of flips ever needed for any stack 
of n pancakes? This number, Pn , is known as the nth 
pancake number.
Here’s a fairly simple algorithm to arrange the pan-
cakes. Put the spatula under the largest pancake, and flip. 
This puts the largest pancake on top. Put the spatula at 
the bottom of the unordered section (in this case at the 
bottom) and flip. This puts the largest pancake on the 
bottom, where it belongs. Repeat with the rest of the pan-
cakes. Each pancake therefore requires two flips, which 
would give a total of 2n flips required. But the last two 
pancakes require at most one flip; if they are already 
in order, no flips are needed, and if they are out of or-
der, only one flip is needed. So this algorithm requires 
at most 2(n − 2) + 1 = 2n − 3 flips in the worst case, 
which means that Pn ≤ 2n − 3. Are there other algo-
rithms that require fewer flips in the worst case?
A faculty member at Harvard University posed 
this question to his class; several days later, a sopho-
more from the class came to his office with a better 
­algorithm. This algorithm, which requires at most  
(5n + 5)/3 flips, was published in the journal Discrete 
Mathematics in 1979. The authors were William Gates 
(the student) and Christos Papadimitriou.
Yes, THAT William Gates.
From SCHNEIDER/GERSTING. Invitation to Computer 
Science, 6/E. © 2013 South-Western, a part of Cengage 
Learning, Inc. Reproduced by permission.  
www.cengage.com/permissions
Chapter 3

212	
Recursion, Recurrence Relations, and Analysis of Algorithms
Exercises 3.3
	 1.	 Modify the algorithm of Example 27 so that in addition to dropping the student’s lowest quiz grade, the 
highest quiz grade is counted twice (like the old version, your new algorithm should do no operations 
besides addition and subtraction).
	 2.	 What is the total number of arithmetic operations done in the algorithm of Exercise 1?
	 3.	 The following algorithm adds all the entries in a square n × n array A. Analyze this algorithm where the 
work unit is the addition operation.
sum = 0
for i = 1 to n do
	
	for j = 1 to n do
	
	sum = sum + A[i, j]
	
end for
end for
write (“Total of all array elements is”, sum)
	 4.	 The following algorithm adds all the entries in the “upper triangular” part of a square n × n array A. 
­Analyze this algorithm where the work unit is the addition operation.
sum = 0
for k = 1 to n do
	
for j = k to n do
	
	sum = sum + A[k, j]
	
end for
end for
write (“Total of all upper triangular array elements is”, sum)
	 5.	 Analyze the following algorithm where the work unit is the output statement. Assume that n = 2m for 
some positive integer m.
integer j, k
	for k = 1 to n do
j = n;
	
while j ≥ 2 do
	
write j
	
j = j/2 
	
end while
end for
S e c t i o n  3 . 3 	
Review
Technique
•	 Do a worst-case analysis of an algorithm either 
directly from the algorithm description or from a 
recurrence relation.
Main Ideas
•	 Analysis of an algorithm estimates the number of 
basic operations that the algorithm performs, which 
is dependent on the size of the input.
•	 Analysis of recursive algorithms often leads to re-
currence relations.
•	 Lacking an exact expression for the number of op-
erations an algorithm performs, it may be possible 
to find an upper bound.

Section 3.3   Analysis of Algorithms	
213
	 6.	 Analyze the following algorithm where the work unit is the output statement. (Hint: One of the exercises 
in Section 2.2 might be helpful).
integer i
real d, x;
for i = 1 to n do
d = 1.0/i;
x = i;
	 while x > 0 do
	
write x
	
x = x − d; 
	 end while
end for
Exercises 7 and 8 involve n! = n(n − 1)(n − 2) c1.
	 7.	 a.	 Write the body of an iterative function to compute n! for n ≥ 1.
	
b.	Analyze this function where the work unit is the multiplication operation.
	 8.	 a.	 Write a recursive function to compute n! for n ≥ 1.
	
b.	Write a recurrence relation for the work done by this function where multiplication is the unit of work.
	
c.	 Solve the recurrence relation of part b.
	
d.	Compare your answer in part c to your result in Exercise 7b.
Exercises 9 and 10 involve evaluating a polynomial anxn + an−1xn−1 + c+ a0 for a specific value of x.
	 9.	 A straightforward algorithm to evaluate a polynomial is given by the following function:
Poly(real an, real an−1, … , real a0, real c, integer n)
//evaluates polynomial anxn + an−1xn−1 + c+ a0      for x = c
Local variables:
integer i
real sum = a0
real product = 1
	 for i = 1 to n do
	
product = product * c
	
sum = sum + ai * product
	 end for
return sum
end function Poly
	 a.	 Walk through this algorithm to compute the value of 2x3 − 7x2 + 5x − 14 for x = 4.
	 b.	 The algorithm involves both additions and multiplications; analyze this algorithm where those operations 
are the work units.
	 10.	An alternative to the polynomial evaluation algorithm in Exercise 9 is an algorithm called Horner’s 
­method. Horner’s method relies on an alternative expression for a polynomial, for example
2x3 − 7x2 + 5x − 14 = −14 + x(5 + x(−7 + x(2)))

214	
Recursion, Recurrence Relations, and Analysis of Algorithms
Horner(real an, real an−1, … , real a0, real c, integer n)
//evaluates polynomial anxn + an−1xn−1 + c+ a0	
for x = c
//using Horner’s method
Local variables:
integer i
real result = an
	
for i = 1 to n do
	
	
result = result * c + an−i
	
end for
	
return result
end function Horner
	 a.	 Walk through this algorithm to compute the value of 2x3 − 7x2 + 5x − 14 for x = 4.
	 b.	 Analyze this algorithm where addition and multiplication operations are the work units.
	 c.	 In evaluating a polynomial of degree n = 98 for some value of x, how many operations have been saved 
by using Horner’s method over the method of Exercise 9?
	 11.	For the algorithm of Example 27, count the total number of assignments and comparisons done in the best 
case (least work) and the worst case (most work); describe each of these cases.
	 12.	a.	 Write a function to convert a binary string bnbn−1 … b1b0 to its decimal equivalent.
	
b.	Test your function on the binary string 10011
	
c.	 Describe the worst case for this algorithm and find the number of multiplications and additions done in 
this case.
	
d.	 Describe the best case for this algorithm and find the number of multiplications and additions done in 
this case.
Exercises 13 and 14 relate to a recursive sorting algorithm called BubbleSort.
	 13.	Algorithm BubbleSort works by making repeated passes through a list; on each pass, adjacent elements 
that are out of order are exchanged. At the end of pass 1, the maximum element has “bubbled up” to the 
end of the list and does not participate in subsequent passes. The following algorithm is called initially 
with j = n.
BubbleSort(list L; integer j)
//recursively sorts the items from 1 to j in list L into increasing order
if j = 1 then
sort is complete, write out the sorted list
else
for i = 1 to j − 1 do
if L[i] > L[i + 1] then
exchange L[i] and L[i + 1] 
end if
end for
BubbleSort(L, j − 1) 
end if
end function BubbleSort

Section 3.3   Analysis of Algorithms	
215
	 a.	 Walk through algorithm BubbleSort to sort the list 5, 6, 3, 4, 8, 2.
	 b.	 Write a recurrence relation for the number of comparisons of list elements done by this algorithm to sort 
an n-element list.
	 c.	 Solve this recurrence relation.
	 14.	In algorithm BubbleSort, suppose we include exchanges of list elements as a work unit, in addition to 
comparisons between list elements.
	 a.	 Describe the worst case and find the number of comparisons and exchanges done in this case.
	 b.	 Describe the best case and find the number of comparisons and exchanges done in this case.
	 c.	 Assume that on the average exchanges between elements must be done about half the time. Find the 
­number of comparisons and exchanges done in this case.
Exercises 15–18 refer to the recursive algorithm SelectionSort of Section 3.1.
	 15.	In one part of algorithm SelectionSort, the index of the maximum item in a list must be found. This ­requires 
comparisons between list elements. In an n-element (unsorted) list, how many such comparisons are needed 
in the worst case to find the maximum element? How many such comparisons are needed in the average case?
	 16.	Defining the basic operation as the comparison of list elements and ignoring the amount of work required 
to exchange list elements, write a recurrence relation for the amount of work done by selection sort on an 
n-element list. (Hint: Use the result from Exercise 15.)
	 17.	Solve the recurrence relation of Exercise 16.
	 18.	Assume that the exchange of L[i] and L[ j] takes place even if i = j. Write an expression for the total 
­number of comparisons and exchanges done to sort an n-element list.
Exercises 19–24 relate to a recursive sorting algorithm called MergeSort, which is described as follows: A one-
element list is already sorted; no further work is required. Otherwise, split the list in half, sort each half using 
MergeSort (this is the recursive part), and then merge the two halves back into one sorted list.
	 19.	The merge part of algorithm MergeSort requires comparing elements from each of two sorted lists to see 
which goes next into the combined, sorted list. When one list runs out of elements, the remaining elements 
from the other list can be added without further comparisons. Given the following pairs of lists, perform 
a merge and count the number of comparisons to merge the two lists into one.
	
a.	 6, 8, 9 and 1, 4, 5
	
b.	1, 5, 8 and 2, 3, 4
	
c.	 0, 2, 3, 4, 7, 10 and 1, 8, 9
	 20.	Under what circumstances will the maximum number of comparisons take place while merging two sorted 
lists? If the lengths of the lists are r and s, what is the maximum number of comparisons?
	 21.	Write a recurrence relation for the number of comparisons between list elements done by algorithm 
MergeSort in the worst case. Assume that n = 2m.
	 22.	Solve the recurrence relation of Exercise 21.
	 23.	Use the results of Exercises 18 and 22 to compare the worst-case behavior of SelectionSort (counting 
­comparisons and exchanges) and MergeSort (counting comparisons) for n = 4, 8, 16, and 32 (use a 
­calculator or spreadsheet).
	 24.	Use the results of Exercises 14 and 22 to compare the worst-case behavior of BubbleSort (counting 
­comparisons and exchanges) and MergeSort (counting comparisons) for n = 4, 8, 16, and 32 (use a 
­calculator or spreadsheet).
Exercises 25–34 relate to a recursive sorting algorithm called QuickSort, which is described as follows: A 
­one-element list is already sorted; no further work is required. Otherwise, take the first element in the list, call it the 

216	
Recursion, Recurrence Relations, and Analysis of Algorithms
pivot element, then walk through the original list to create two new sublists, L1 and L2. L1 consists of all ­elements 
that are less than the pivot element and L2 consists of all elements that are greater than the pivot ­element. Put the 
pivot element between L1 and L2. Sort each of L1 and L2 using QuickSort (this is the ­recursive part). Eventually 
all lists will consist of 1 element sublists separated by previous pivot elements, and at this point the entire original 
list is in sorted order. This is a little confusing, so here is an example, where pivot ­elements are shown in brackets:
	
	 Original list: 6, 2, 1, 7, 9, 4, 8
	
	 After 1st pass: 2, 1, 4, [6], 7, 9, 8
	
	 After 2nd pass: 1, [2], 4, [6], [7], 9, 8
	
	 After 3rd pass: 1, [2], 4, [6], [7], 8, [9]	
Sorted
	 25.	Illustrate QuickSort as above using the list 9, 8, 3, 13.
	 26.	Illustrate QuickSort as above using the list 8, 4, 10, 5, 9, 6, 14, 3, 1, 12, 11.
	 27.	How many comparisons between list elements are required for pass 1 of QuickSort in the example list?
	 28.	How many comparisons between list elements are required for pass 1 of QuickSort on an n-element list?
	 29.	Suppose that for each pass, each pivot element splits its sublist into two equal-length lists, each approxi-
mately half the size of the sublist (which is actually very difficult to achieve). Write a recurrence relation 
for the number of comparisons between list elements in this case.
	 30.	Solve the recurrence relation of Exercise 29.
	 31.	Suppose that for each pass, each pivot element splits its sublist (which has k elements) into one empty list 
and one list of size k − 1. Write a recurrence relation for the number of comparisons between list elements 
in this case.
	 32.	Solve the recurrence relation of Exercise 31.
	 33.	Unlike the situation described in Exercise 29 where each pivot element splits the sublist in half for the next 
pass, the situation described in Exercise 31 can easily occur. Describe a characteristic of the original list 
that would cause this to happen.
	 34.	Exercise 29 describes the best case of QuickSort and Exercise 31 describes the worst case of QuickSort 
with respect to comparisons between list elements.
	
a.	 To which sorting algorithm (SelectionSort, BubbleSort, MergeSort) is the best case of QuickSort 
­comparable in the number of comparisons required?
	
b.	To which sorting algorithm (SelectionSort, BubbleSort, MergeSort) is the worst case of QuickSort 
­comparable in the number of comparisons required?
Exercises 35 and 36 refer to algorithm SequentialSearch. It is not hard to do an average case analysis of the 
sequential search algorithm under certain assumptions. Given an n-element list and a target value x for which 
we are searching, the basic operation is a comparison of list elements to x, hence an analysis should count how 
many times such an operation is performed “on the average.” The definition of “average” is shaped by our 
­assumptions.
	 35.	Assume that x is in the list and is equally to be found at any of the n positions in the list. Fill in the rest of 
the table giving the number of comparisons for each case.
Position at Which x ­Occurs
Number of Comparisons
1
1
2
3
(
n

Chapter 3   Review	
217
	
	 Find the average number of comparisons by adding the results from the table and dividing by n. (Hint: See 
Practice 7 of Section 2.2—we told you that you should remember this!)
	 36.	Find the average number of comparisons under the assumption that x is equally likely to be at any of the 
n positions in the list or not in the list.
Exercises 37–40 concern a better upper bound for the number of divisions required by the Euclidean algorithm 
in finding gcd(a, b). Assume that a and b are positive integers with a > b.
	 37.	Suppose that m divisions are required to find gcd(a, b). Prove by induction that for m ≥ 1, it is true that 
a ≥ F(m + 2) and b ≥ F(m + 1), where F(n) is the Fibonacci sequence. (Hint: To find gcd(a, b), after the 
first division the algorithm computes gcd(b, r).)
	 38.	Suppose that m divisions are required to find gcd(a, b), with m ≥ 4. Prove that
a3
2b
m+1
< F(m + 2) ≤a
(Hint: Use the result of Exercise 37 here and Exercise 26 of Section 3.1.)
	 39.	Suppose that m divisions are required to find gcd(a, b), with m ≥ 4. Prove that m < (log1.5 a) − 1. 
(Hint: Use the result of Exercise 38.)
	 40.	a.	Compute gcd(89, 55) and count the number of divisions required.
	
	 b.	Compute the upper bound on the number of divisions required for gcd(89, 55) using Equation (1).
	
	 c.	Compute the upper bound on the number of divisions required for gcd(89, 55) using the result of 
­Exercise 39.
	
	 d.	The eighteenth-century French mathematician Gabriel Lamé proved that an upper bound on the number 
of division done by the Euclidean algorithm to find gcd(a, b) where a > b is 5 times the number of 
decimal digits in b. Compute the upper bound on the number of divisions required for gcd(89, 55) using 
Lamé’s theorem.
C h a p t e r  3 	
Review
Terminology
analysis of algorithms (p. 203)
Backus−Naur form (BNF) 
(p. 163)
binary search algorithm (p. 169)
binary string (p. 163)
characteristic equation of a 
recurrence relation (p.190)
closed−form solution (p. 180)
concatenation (p. 163)
constant coefficient recurrence 
relation (p. 182)
divide-and-conquer algorithm  
(p. 208)
divide-and-conquer recurrence 
relation (p. 193)
empty string (p. 163)
Fibonacci sequence (p. 159)
first-order recurrence relation  
(p. 182)
homogeneous recurrence relation 
(p. 182)
index of summation (p. 182)
inductive definition (p. 158)
linear recurrence relation  
(p. 182)
palindrome (p. 163)
recurrence relation (p. 159)
recursive definition (p. 158)
second-order recurrence relation 
(p. 188)
selection sort algorithm (p. 168)
sequence (infinite sequence)  
(p. 158)
sequential search algorithm  
(p. 204)
solving a recurrence relation  
(p. 180)
structural induction (p. 164)
summation notation (p. 182)
upper bound (p. 210)

218	
Recursion, Recurrence Relations, and Analysis of Algorithms
Self-Test
Answer the following true-false questions without looking back in the chapter.
Section 3.1
1.	A sequence defined by
	
S(l) = 7
	
S(n) = 3S(n − 1) + 2    for n ≥ 2
contains the number 215.
2.	A collection T of numbers is defined recursively by
1.	 6 and 8 belong to T
2.	 If X and Y belong to T, so does X + 2Y
Every even number ≥ 18 belongs to T.
3.	 Recursive algorithms are valuable primarily ­because 
they run more efficiently than iterative ­algorithms.
4.	In the recursive algorithm SelectionSort, changing 
one line of the algorithm to
“find the index i of the minimum item in L 
between 1 and j ”
sorts the list L in decreasing order.
5.	In applying the binary search algorithm to the list
2, 5, 7, 10, 14, 20
where x = 8 is the target item, x is never compared 
to 5.
Section 3.2
1.	A closed-form solution to a recurrence relation is 
obtained by applying mathematical induction to the 
recurrence relation.
O n  t h e  C o m p u t e r
For Exercises 1–7, write a computer program that 
­produces the desired output from the given input.
1.	Input: Binary string 
Output: Message indicating whether the input 
string is a palindrome (see Practice 7)	  
Algorithm: Use recursion.
2.	 Input: String of characters x and a positive integer n 
Output: Concatenation of n copies of x 
Algorithm: Use recursion. 
(Some programming languages provide built-
in string manipulation capabilities, such as 
­concatenation.)
3.	Input: Positive integer n 
Output: nth value in the Fibonacci sequence ­using
a.	 iteration.
b.	 recursion.
2.	S(n) = 2S(n − 1) + 3S(n − 2) + 5n is a ­linear, 
first-order recurrence relation with constant 
c­oefficients.
3.	 S(n) = cn−1S(1) + ∙
n
i=2
cn−ig(i) is a closed-form 
solution to any linear first-order recurrence relation 
with constant coefficients.
4.	The solution to the recurrence relation S(n) =  
c1S(n − 1) + c2S(n − 2) involves solving the char-
acteristic equation t2 − c1t − c2 = 0.
5.	Divide-and-conquer algorithms lead to recurrence 
relations that are not first-order.
Section 3.3
1.	Analysis of an algorithm generally finds the amount 
of work done in the worst case because it is too 
­difficult to analyze an average case.
2.	In the worst case, the string pattern-matching 
­algorithm requires n + m comparisons, where 
n = the text size and m = the pattern size.
3.	Binary search is more efficient than sequential 
search on a sorted list of more than three ­elements.
4.	The recursive version of the sequential search 
­algorithm is a divide-and-conquer algorithm.
5.	An upper bound for the Euclidean algorithm gives 
a ceiling on the number of divisions required to find 
gcd(a, b).

Chapter 3   Review	
219
Now insert a counter in each version to indicate the 
total number of addition operations done. Run each 
version for various values of n and, on a single graph, 
plot the number of additions as a function of n for each 
version.
4.	Input: Two positive integers a and b with a > b 
Output: gcd(a, b) using
a.	 the iterative version of the Euclidean algorithm
b.	 a recursive version of the Euclidean algorithm
5.	Input: Unsorted list of 10 integers 
Output: Input list sorted in increasing order 
Algorithm: Use the recursive selection sort of 
­Example 12.
6.	Input: Sorted list of 10 integers and an integer x 
Output: Message indicating whether x is in the list 
Algorithm: Use the binary search algorithm of 
­Example 13.
7.	Input: Text string, pattern string 
Output: Location of beginning of pattern string in 
text string, or a message that the pattern string is 
not found within the text string 
Algorithm: See Example 28.
8.	The value (1 + "5)∙2, known as the golden ratio, 
is related to the Fibonacci sequence by
lim
nS∞
F(n + 1)
F(n)
= 1 + "5
2
Verify this limit by computing F(n + 1)/F(n) for 
n = 10, 15, 25, 50, and 100 and comparing the 
­result with the golden ratio.
9.	 Compare the work done by sequential search and bi-
nary search on an ordered list of n entries by comput-
ing n and 1 + log n for values of n from 1 to 100. 
Present the results in graphic form.

This page intentionally left blank 

Chapter Objectives
After studying this chapter, you will be able to:
•	 Use the notation of set theory.
•	 Find the power set of a finite set.
•	 Find the union, intersection, difference, complement, and Cartesian product 
of sets.
•	 Identify binary and unary operations on a set.
•	 Prove set identities.
•	 Recognize that not all sets are countable.
•	 Apply the multiplication principle and the addition principle to solve counting 
problems.
•	 Use decision trees to solve counting problems.
•	 Use the principle of inclusion and exclusion to find the number of elements in 
the union of sets.
•	 Use the pigeonhole principle to decide when certain events must occur.
•	 Use the formulas for permutations and combinations of r objects, with and 
without repetition, from a set of n distinct objects.
•	 Find the number of distinct permutations of n objects that are not all distinct.
•	 Generate all permutations of n distinct objects, and all combinations of r out 
of n distinct objects.
•	 Find the probability of an event given that all outcomes are equally likely, that 
a probability distribution has been assigned to the outcomes, or that another 
event has already occurred.
•	 Compute the expected value of a quantity with an assigned probability 
­distribution.
•	 Use the binomial theorem to expand (a + b)n.
You survey the 87 computer users who subscribe to your electronic newsletter in 
preparation for the release of your new software product. The results of your survey 
reveal that 68 have a Windows-based system available to them, 34 have a Linux 
system available, and 30 have access to a Mac. In addition, 19 have access to both 
Windows and Linux systems, 11 have access to both Linux systems and Macs, and 
23 can use both Macs and Windows.  
	
Question:	
How many of your subscribers have access to all three types of systems?
4
Sets, Combinatorics,  
and Probability
Chapter
221

222	
Sets, Combinatorics, and Probability 
This is an example of a counting problem; you want to count the number of ele-
ments in a certain collection or set—the set of all subscribers with access to all 
three systems. A formula that easily solves this counting problem is developed in 
Section 4.3.
Set theory is one of the cornerstones of mathematics. Many concepts in math-
ematics and computer science can be conveniently expressed in the language of 
sets. Operations can be performed on sets to generate new sets. Although most sets 
of interest to computer scientists are finite or countable, there are sets with so many 
members that they cannot be enumerated. Set theory is discussed in Section 4.1.
It is often of interest to count the number of elements in a finite set. This may 
not be a trivial task. Section 4.2 provides some ground rules for counting the num-
ber of elements in a set consisting of the outcomes of an event. Counting the ele-
ments in such a set can be made manageable by breaking the event down into a se-
quence of subevents or into disjoint subevents that have no outcomes in common. 
Some specialized counting principles appear in Section 4.3. Section 4.4 provides 
formulas for counting the number of ways to arrange objects in a set and to select 
objects from a set, as well as algorithms to generate all the possible arrangements 
or selections. Section 4.5 discusses the binomial theorem, an algebraic result that 
can also be viewed as a consequence of the counting formulas. Finally, Section 4.6 
extends “counting” to the more general idea of probability.
	
S e c t i o n  4 .1 	 Sets
Definitions are important in any science because they contribute to precise commu-
nication. However, if we look up a word in the dictionary, the definition is expressed 
using other words, which are defined using still other words, and so on. Thus, we 
have to have a starting point for definitions where the meaning is taken to be under-
stood; our starting point in this discussion will be the idea of a set, a term that we 
will not formally define. Instead, we will simply use the intuitive idea that a set is a 
collection of objects. Usually all of the objects in a set share some common property 
(aside from that of belonging to the same set!); any object that has the property is a 
member of the set, and any object that does not have the property is not a member. 
(This is consistent with our use of the word set in Section 3.1, where we talked about 
the set of propositional well-formed formulas, the set of all strings of symbols from 
a finite alphabet, and the set of identifiers in some programming language.)
Notation
We use capital letters to denote sets and the symbol [ to denote membership 
in a set. Thus a [ A means that object a is a member, or element, of set A, and  
b o A means that object b is not an element of set A. Braces are used to indicate 
a set.
	
Example 1	
If A = {violet, chartreuse, burnt umber}, then chartreuse [ A and magenta o A.
No ordering is imposed on the elements in a set; therefore {violet, chartreuse, 
burnt umber} is the same as {chartreuse, burnt umber, violet}. Also, each element 
of a set is listed only once; it is redundant to list it again.

Section 4.1   Sets	
223
Practice 1	 Describe each of the following sets by listing its elements.
a.	 {x 0 x is an integer and 3 < x ≤ 7}
b.	{x 0 x is a month with exactly 30 days}
c.	 {x 0 x is the capital of the United States}
■
Practice 2	 Describe each of the following sets by giving a characterizing property.
a.	 {1, 4, 9, 16}
b.	{the butcher, the baker, the candlestick maker}
c.	 {2, 3, 5, 7, 11, 13, 17, …}
■
Two sets are equal if they contain the same elements. (In a definition, “if” 
­really means “if and only if”; thus two sets are equal if and only if they contain 
the same elements.) Using predicate logic notation,
A = B means (4x)[(x [ A S x [ B) ` (x [ B S x [ A)]
In describing a particular set, we have to identify its elements. For a finite set (one 
with n elements for some nonnegative integer n), we might do this by ­simply listing 
all the elements, as in set A of Example 1. Although it is impossible to list all ele-
ments of an infinite set (one that is not finite), for some infinite sets we can indicate 
a pattern for listing elements indefinitely. Thus, we might write {2, 4, 6, …} to 
express the set S of all positive even integers. (Although this is a common prac-
tice, the danger exists that the reader will not see the pattern that the writer has in 
mind.) S can also be defined recursively by giving an explicit member of S and then 
describing other members of S in terms of already known members. For example,
	
1.	 2 [ S	
	
2.	 If n [ S, then (n + 2) [ S
But the clearest way to describe this particular set S is to describe the ­ 
characterizing property of the set elements in words and write
S = {x 0 x is a positive even integer}
read as “the set of all x such that x is a positive even integer.”
We’ve now given three ways to describe a set:
	
1. List (or partially list) its elements.
	
2. Use recursion to describe how to generate the set elements.
	
3. Describe a property P that characterizes the set elements.
Later in this section we’ll see that there are sets for which the first approach won’t 
work; often the second approach is difficult to use. The third method is usually 
the best choice.
The notation for a set S whose elements are characterized as having property 
P is {x 0 P(x)}. Property P here is a unary predicate; this term was introduced in 
Chapter 1. For any given x, P(x) is either true or false. In fact, the formal logic 
notation of Chapter 1 again comes to the rescue to clarify what we mean by a 
characterizing property of a set’s elements:
S = {x 0 P(x)} means (4x)[(x [ S S P(x)) ` (P(x) S x [ S )]
In words, every element of S has property P and everything that has property P 
is an element of S.

224	
Sets, Combinatorics, and Probability 
It is convenient to name certain standard sets so that we can refer to them 
easily. We will use
ℕ = set of all nonnegative integers (note that 0 [ ℕ)
ℤ = set of all integers
ℚ = set of all rational numbers
ℝ = set of all real numbers
ℂ = set of all complex numbers
Sometimes we will also want to talk about the set with no elements (the empty set, 
or null set), denoted by [ or { }. For example, if S = {x 0 x [ ℕ and x < 0}, then 
S = [. Note that [, the set with no elements, is not the same as {[}, which is a 
set with a single element where the single element is the empty set.
Practice 3	 Describe each set.
a.	 A = {x 0 x [ ℕ and (4y)(y [ {2, 3, 4, 5} S x ≥ y)}
b.	B = {x 0 (E y)(E z)( y [ {1, 2} and z [ {2, 3} and x = y + z)}
■
Practice 4	 Complete the definition: A is a subset of B if
(4x)(x [ A S __________ )
■
Relationships Between Sets
For A = {2, 3, 5, 12} and B = {2, 3, 4, 5, 9, 12}, every member of A is also a 
­member of B. When this happens, A is said to be a subset of B.
	
Example 2	
Suppose that a set A is described as
A = {x 0 (E y)(y [ {0, 1, 2} and x = y3)}
Because y is not a free variable here, this is still of the form A = {x 0 P(x)}. The 
members of A can be found by letting y assume each of the values 0, 1, and 2 and 
then taking the cube of each such value. Therefore A = {0, 1, 8}. For
B = {x 0 x [ ℕ and (E y)(y [ ℕ and x ≤ y)}
choosing y = 0 gives x = 0; choosing y = 1 gives x = 0 or 1; choosing y = 2 gives 
x = 0, 1, or 2; and so on. In other words, B consists of all nonnegative integers 
that are less than or equal to some nonnegative integer, which means that B = ℕ. 
For the set
C = {x 0 x [ ℕ and (4y)(y [ ℕ S x ≤ y)}
0 is the only nonnegative integer that is less than or equal to every nonnegative 
integer, so C = {0}.

Section 4.1   Sets	
225
If A is a subset of B, we denote the relationship by A # B. If A # B but A ∙ B (there 
is at least one element of B that is not an element of A), then A is a proper subset 
of B, denoted by A ( B.
■
Practice 5	 Use formal logic notation to define A ( B.
	
Example 3	
Let
A = 51, 7, 9,156
B = 57, 96
C = 57, 9, 15, 206
Then the following statements (among others) are all true:
	
B # C	
15 [ C
	
B # A	
{7, 9} # B
	
B ( A	
{7} ( A
	
A h C	
 [ # C
The last statement ([ # C ) is true because the statement (4x)(x [ [ S x [ C ) is 
true because x [ [ is always false.
REMINDER
Be sure you understand 
the difference between 
the symbols [ (element of) 
and # (subset of).
Suppose that B = {x 0 P(x)} and that A # B. Because every element of A is 
also an element of B, and P is a property characterizing all elements of B, then 
every ­element in A also has property P(x). The elements of A “inherit” property 
P. In fact, to prove that A # B, we pick an arbitrary x [ A and show that P(x) 
Practice 6	 Let
	
A = {x 0 x [ ℕ and x ≥ 5}
	
B = {10, 12, 16, 20}
	
C = {x 0 (E y)( y [ ℕ and x = 2y)}
Which of the following statements are true?
	
a.	B # C	
g.	{12} [ B
	
b.	B ( A	
h.	{12} # B
	
c.	A # C	
i.	 {x 0 x [ ℕ and x < 20} h B
	
d.	26 [ C	
j.	 5 # A
	
e.	{11, 12, 13 } # A	
k.	{[} # B
	
f.	 {11, 12, 13} ( C	
l.	 [ o A
■

226	
Sets, Combinatorics, and Probability 
holds. If A is a proper subset of B, A’s elements will usually have some additional 
characterizing property not shared by all elements of B. (This is the same notion 
of “inheritance” that prevails when a child type, or subtype, or derived type is de-
fined in an object-oriented programming language. The child type inherits all of 
the properties and operations from the parent type with the addition of specialized 
local properties or operations as needed.)
	
Example 4	
Let
B = {x 0 x is a multiple of 4}
and let
A = {x 0 x is a multiple of 8}
Then we have A # B. To prove it, let x [ A; note that x is a completely arbitrary 
member of A. We must show that x satisfies the characterizing property of B; 
in other words, we must show that x is a multiple of 4. Because we have x [ A, x 
satisfies the characterizing property of A; that is, x is a multiple of 8 and thus 
we can write x = m # 8 for some integer m. This equation can be written as  
x = m # 2 # 4 or x = k # 4, where k = 2m, so k is an integer. This shows that x is a 
multiple of 4, and therefore x [ B.
There are numbers (like 12) that are multiples of 4 but not multiples of 8, so  
A ( B. Another way to describe A is
A = {x 0 x = k # 4 and k is an even number}
In this form it is clear that A’s elements have inherited the characterizing property 
of B—being a multiple of 4—but that there is an additional restriction that makes 
A less general than B.
Practice 7	 Let
A = {x 0 x [ ℝ and x2 − 4x + 3 = 0}
B = {x 0 x [ ℕ and 1 ≤ x ≤ 4}
Prove that A ( B.
■
We know that A and B are equal sets if they have the same elements. We can 
restate this equality in terms of subsets: A = B if and only if A # B and B # A. 
Proving set inclusion in both directions is the usual way to establish the equality 
of two sets.

Section 4.1   Sets	
227
	
Example 5	
We will prove that {x 0 x [ ℕ and x2 < 15} = {x 0 x [ ℕ and 2x < 7}.
Let A = {x 0 x [ ℕ and x2 < 15} and B = {x 0 x [ ℕ and 2x < 7}. To show that  
A = B, we show A # B and B # A. For A # B, we must choose an arbitrary 
­member of A—that is, anything satisfying the characterizing property of A—and 
show that it also satisfies the characterizing property of B. Let x [ A. Then x is a 
nonnegative integer satisfying the inequality x2 < 15. The nonnegative integers 
with squares less than 15 are 0, 1, 2, and 3, so these integers are the members of A. 
The double of each of these nonnegative integers is a number less than 7. Hence, 
each member of A is a member of B, and A # B.
Now we show B # A. Any member of B is a nonnegative integer whose  
double is less than 7. These numbers are 0, 1, 2, and 3, each of which has a square 
less than 15, so B # A.
Sets of Sets
For a set S, we can form a new set whose elements are all of the subsets of S. This 
new set is called the powerset of S, ℘(S).
	
Example 6	
For S = {0, 1}, ℘(S ) = {[, {0}, {1}, {0, 1}}. Note that the members of the power 
set of a set are themselves sets.
For any set S, ℘(S) will always have at least [ and S itself as members, since  
[ # S and S # S are always true.
Practice 8	 For A = {1, 2, 3}, what is ℘(A)?
■
In Practice 8, A has 3 elements and ℘(A) has 8 elements. Try ­finding ℘(S) for 
other sets S until you can guess the answer to the following practice problem.
REMINDER
To find ℘(S), start with [. 
Then add sets taking 1 ele-
ment from S at a time, then 
2 elements at a time, then 
3 at a time, and so forth.
Practice 9	
If S has n elements, then ℘(S ) has ______ elements. (Does your answer work for 
n = 0, too?)
■
There are several ways we can show that for a set S with n elements, ℘(S) will 
have 2n elements. The following proof uses induction. For the basis step of the 
induction, we let n = 0. The only set with 0 elements is [. The only subset of [ 
is [, so ℘([) = {[}, a set with 1 = 20 elements. We assume that for any set with 
k elements, the power set has 2k elements.

228	
Sets, Combinatorics, and Probability 
Now let S have k + 1 elements and put one of these elements, call it x, aside. 
The remaining set has k elements, so by our inductive assumption, its power set has 
2k elements. Each of these elements is also a member of ℘(S). The only members of 
℘(S) not counted by this procedure are those including element x. All the subsets in-
cluding x can be found by taking all those subsets not including x (of which there are 
2k ) and throwing in the x; thus, there will be 2k subsets including x. Altogether, there 
are 2k subsets without x and 2k subsets with x, or 2k + 2k = 2 # 2k = 2k+1 ­subsets. 
Therefore, ℘(S) has 2k+1 elements.
Analogy with the truth tables of Section 1.1 is another way to show that ℘(S) 
has 2n elements for a set S with n elements. There we had n statement letters and 
showed that there were 2n true-false combinations among these letters. But we can 
also think of each true-false combination as representing a particular subset, with 
T indicating membership and F indicating nonmembership in that subset. (For 
example, the row of the truth table with all statement letters F corresponds to the 
empty set.) Thus, the number of true-false combinations among n statement letters 
equals the number of subsets of a set with n elements; both are 2n.
Binary and Unary Operations
By itself a set is not very interesting until we do something with its elements. For 
example, we can perform several arithmetic operations on elements of the set 
Z. We might subtract two integers, or we might take the negative of an integer. 
­Subtraction acts on two integers; it is a binary operation on Z. Negation acts on 
one integer; it is a unary operation on Z.
To see exactly what is involved in a binary operation, let’s look at subtraction 
more closely. For any two integers x and y, x − y produces an answer and only one 
answer, and that answer is always an integer. Finally, subtraction is performed on 
an ordered pair of numbers. For example, 7 − 5 does not produce the same result 
as 5 − 7. An ordered pair is denoted by (x, y), where x is the first component of the 
ordered pair and y is the second component. Order is important in an ordered pair; 
thus, the sets {1, 2} and {2, 1} are equal, but the ordered pairs (1, 2) and (2, 1) are 
not. You are probably familiar with ordered pairs used as coordinates to locate a 
point in the plane. The point (1, 2) is different from the point (2, 1). Two ordered 
pairs (x, y) and (u, v) are equal only when it is the case that x = u and y = v.
■
Practice 10	 Given that (2x − y, x + y) = (7, −1), solve for x and y.
■
Practice 11	 Let S = {3, 4}. List all the ordered pairs (x, y) of elements of S.
We will generalize the properties of subtraction on the integers to define a 
binary operation + on a set S. The symbol + is merely a placeholder; in any spe-
cific discussion, it will be replaced by the appropriate operation symbol, such as 
a subtraction sign.

Section 4.1   Sets	
229
	
Definition	
Binary Operation
+ is a binary operation on a set S if for every ordered pair (x, y) of elements of S, 
x + y exists, is unique, and is a member of S.
In other words, if + is a binary operation on S, then for any two values x and 
y in S, x + y produces one and only one answer, and that answer belongs to S. 
That the value x + y always exists and is unique. It is described by saying that 
the binary operation + is well-defined. The property that x + y always belongs to 
S is described by saying that S is closed under the operation +. Uniqueness does 
not mean that the result of a binary operation occurs only once; it means that for 
a given x and y, there is only one result. For subtraction, there are many x and y 
values such that x − y = 7, but for a given x and y, like x = 5 and y = 2, there is 
only one answer for x − y.
	
Example 7	
Addition, subtraction, and multiplication are all binary operations on ℤ. For 
­example, when we perform addition on the ordered pair of integers (x, y), x + y 
exists and is a unique integer.
	
Example 8	
The logical operations of conjunction, disjunction, implication, and equivalence 
are binary operations on the set of propositional wffs. If P and Q are propositional 
wffs, then P ` Q, P ~ Q, P S Q, and P 4 Q are unique propositional wffs.
A candidate + for an operation can fail to be a binary operation on a set S in 
any of three ways: (1) There are elements x, y [ S for which x + y does not exist; (2) 
there are elements x, y [ S for which x + y gives more than one result; or (3) there 
are elements x, y [ S for which x + y does not belong to S.
	
Example 9	
Division is not a binary operation on ℤ because x ÷ 0 does not exist.
	
Example 10	
Define x + y on ℕ by
x + y = e 1 if x ≥5  
	 0 if x ≤5
Then, by the first part of the definition for +, 5 + 1 = 1, but by its second part,  
5 + 1 = 0. Thus, + is not well-defined on ℕ because the result of 5 + 1 is not  
unique.
	
Example 11	
Subtraction is not a binary operation on ℕ because ℕ is not closed under subtrac-
tion. (For example, 1 − 10 o ℕ.)

230	
Sets, Combinatorics, and Probability 
For # to be a unary operation on a set S, it must be true that for any x [ S, 
x# is well-defined and S is closed under #; in other words, for any x [ S, x# exists, 
is unique, and is a member of S. We do not have a unary operation if any of these 
conditions is not met.
	
Example 12	
Let x# be defined by x# = −x so that x# is the negative of x. Then # is a unary 
­operation on ℤ but not on ℕ because ℕ is not closed under #.
	
Example 13	
The logical connective of negation is a unary operation on the set of propositional 
wffs. If P is a propositional wff, then P′ is a unique propositional wff.
From these examples it is clear that whether + (or # ) is a binary (or unary) 
­operation can depend not only on its definition but also on the set involved.
Practice 12	 Which of the following candidates are neither binary nor unary operations on the given 
sets? Why not?
a.	 x + y = x ÷ y; S = set of all positive integers
b.	x + y = x ÷ y; S = set of all positive rational numbers
c.	 x + y = xy; S = R
d.	x + y = maximum of x and y; S = N
e.	 x# =!x; S = set of all positive real numbers
f.	 x# = solution to equation (x# )2 = x; S = ℂ
■
So far, all our binary operations have been defined by means of a descrip-
tion or an equation. Suppose S is a finite set, S = {x1, x2, … , xn}. Then a binary 
­operation + on S can be defined by an n × n table, where element i, j (ith row and 
jth column) denotes xi + xj.
	
Example 14	
Let S = {2, 5, 9}, and let + be defined by the table
+
2
5
9
2
2
2
9
5
5
9
2
9
5
5
9
Thus, 2 + 5 = 2 and 9 + 2 = 5. Inspecting the table, we see that + is a binary 
­operation on S.
Operations on Sets
Most of the operations we have seen operate on numbers, but we can also op-
erate on sets. Given an arbitrary set S, we can define some binary and unary 

Section 4.1   Sets	
231
operations on the set ℘(S). S in this case is called the universal set or the  
universe of ­discourse. The universal set defines the context of the objects  
being discussed. If S = Z, for example, then all subsets will contain only ­integers.
A binary operation on ℘(S) must act on any two subsets of S to produce a 
unique subset of S. There are at least two natural ways in which this can happen.
	
Example 15	
Let S be the set of all students at Silicon U. Then the members of ℘(S ) are sets of 
students. Let A be the set of computer science majors, and let B be the set of busi-
ness majors. Both A and B belong to ℘(S ). A new set of students can be defined 
that consists of everybody who is majoring in either computer science or business 
(or both); this set is called the union of A and B. Another new set can be defined 
that consists of everybody who is majoring in both computer science and business. 
This set (which might be empty) is called the intersection of A and B.
We can use Venn diagrams (named for the nineteenth-century British math-
ematician John Venn) to visualize the binary operations of union and intersection. 
The shaded areas in Figures 4.1 and 4.2 illustrate the set that results from perform-
ing the binary operation on the two given sets.
	
Definition	
Union and Intersection of Sets
Let A, B [ ℘(S). The union of A and B, denoted by A c B, is {x 0 x [ A or x [ B}. 
The intersection of A and B, denoted by A d B, is {x 0 x [ A and x [ B }.
	
Example 16	
Let A = {1, 3, 5, 7, 9} and B = {3, 5, 6, 10, 11}. Here we may consider A and B 
as members of ℘(ℕ). Then A c B = {1, 3, 5, 6, 7, 9, 10, 11} and A d B = {3, 5}. 
Both A c B and A d B are members of ℘(ℕ).
■
Practice 13	 Let A, B [ ℘(S) for any set S. Is it always the case that A d B # A c B?
$
%
6
$F%
$
%
6
$G%
We will define one unary operation on ℘(S).
Figure 4.1
Figure 4.2

232	
Sets, Combinatorics, and Probability 
	
Definition	
Complement of a Set
For a set A [ ℘(S), the complement of A, A′, is {x 0 x [ S and x o A}.
■
Practice 14	 Illustrate A′ in a Venn diagram.
	
Example 17	
In Section 1.1 we discussed the use of logical connectives to formulate Web search 
queries. A query such as
“used cars” AND (Ford OR Buick) AND NOT trucks
is asking the search engine to return a set of pages (or more properly, a set of links 
to pages). If
	
U = set of used car pages
	
F = set of Ford pages
	
B = set of Buick pages
	
T = set of truck pages
then
U d (F c B) d T′
represents the set of Web pages that is the desired result of the query.
Another binary operation on sets A and B in ℘(S) is set difference: A − B = 
{x 0 x [ A and x o B}. This operation can be rewritten as A − B = {x 0 x [ A and 
x [ B′} and, finally, as A − B = A d B′.
■
Practice 15	 Illustrate A − B in a Venn diagram.
Two sets A and B such that A d B = [ are said to be disjoint. Thus, A − B 
and B − A, for example, are disjoint sets.
	
Example 18	
Let
	
A = {x 0 x is an even nonnegative integer}
	
B = {x 0 (E y)( y [ ℕ and x = 2y + 1)}
	
C = {x 0 (E y)( y [ ℕ and x = 4y)}
be subsets of ℕ. Because B represents the set of nonnegative odd integers, A and B 
are disjoint sets. Also, every nonnegative integer is either even or odd, so A c B = ℕ. 
These two facts also tell us that A′ = B. Every multiple of 4 is an even number, 
so C is a subset of A, from which it follows that A c C = A. C is in fact a proper 
subset of A, and A − C = {x 0 (E y)( y [ ℕ and x = 4y + 2)}.

Section 4.1   Sets	
233
■
Practice 16	 Let
	
A = {1, 2, 3, 5, 10}
	
B = {2, 4, 7, 8, 9}
	
C = {5, 8, 10}
be subsets of S = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. Find
a.  A c B	
b.  A − C	
c.  B′ d (A c C )
We will define one final operation using elements of ℘(S).
	
Definition	
Cartesian Product
Let A and B be subsets of S. The Cartesian product (cross product) of A and B, 
denoted by A × B, is defined by
A × B = {(x, y) 0 x [ A and y [ B}
Thus, the Cartesian product of two sets A and B is the set of all ordered pairs 
whose first component comes from A and whose second component comes from B. 
The cross product is not a binary operation on ℘(S). Although it acts on an or-
dered pair of members of ℘(S) and gives a unique result, the resulting set is not, 
in general, a subset of S. The elements are not members of S but ordered pairs of 
members of S. So the resulting set is not a member of ℘(S). The closure property 
for a binary operation fails to hold.
Because we will often be interested in the cross product of a set with itself, we 
will abbreviate A × A as A2; in general, we use An to mean the set of all ordered 
n-tuples (x1, x2, … , xn) of elements of A.
■
Practice 17	 Let A = {1, 2} and B = {3, 4}.
a.  Find A × B.	
b.  Find B × A.	
c.  Find A2.	
d.  Find A3.
Set Identities
There are many set equalities involving the operations of union, intersection, 
difference, and complementation that are true for all subsets of a given set S. 
Because they are independent of the particular subsets used, these equali-
ties are called set identities. Some basic set identities follow. The names and 
forms of these identities are very similar to the tautological equivalences of  
Section 1.1 (check back and compare). We will see in Chapter 8 that this 
­similarity is not a coincidence.

234	
Sets, Combinatorics, and Probability 
■
Practice 18	 Prove identity 4a.
Basic Set Identities
	
1a. A c B = B c A	
1b. A d B = B d A	
(commutative 
­properties)
	
2a. (A c B) c C = A c (B c C )	
2b. (A d B) d C = A d (B d C )	
(associative  
properties)
	
3a. A c (B d C ) = (A c B) d (A c C )	
3b. A d (B c C ) = (A d B) c (A d C )	
(distributive  
properties)
	
4a. A c [ = A	
4b. A d S = A	
(identity  
properties)
	
5a. A c A′= S	
5b. A d A′= [	
(complement  
properties)
(Note that 2a allows us to write A c B c C with no need for parentheses; 2b allows 
us to write A d B d C.)
	
Example 19	
Let’s prove identity 3a. We might draw Venn diagrams for each side of the equa-
tion and see that they look the same. However, identity 3a is supposed to hold for 
all subsets A, B, and C, and whatever one picture we draw cannot be completely 
general. Thus, if we draw A and B disjoint, that’s a special case, but if we draw A 
and B not disjoint, that doesn’t take care of the case where A and B are disjoint. 
To do a proof by Venn diagrams requires a picture for each possible case, and the 
more sets involved (A, B, and C in this problem), the more cases there are. To avoid 
drawing a picture for each case, let’s prove set equality by proving set inclusion in 
each direction. Thus, we want to prove
A c (B d C ) # (A c B) d (A c C )
and also
(A c B) d (A c C ) # A c (B d C )
To show that A c (B d C ) # (A c B) d (A c C ), we let x be an arbitrary member 
of A c (B d C ). Then we can proceed as follows:
x [ A c (B d C ) S x [ A or x [ (B d C )
	
S x [ A or (x [ B and x [ C )
	
S (x [ A or x [ B) and (x [ A or x [ C )
	
S x [ (A c B) and x [ (A c C )
	
S x [ (A c B) d (A c C )
To show that (A c B) d (A c C ) # A c (B d C ), we reverse the above argument.

Section 4.1   Sets	
235
Once we have proved the set identities in this list, we can use them to prove 
other set identities. Just as the tautological equivalences of propositional logic 
represent recipes or patterns for transforming wffs, the set identities represent 
patterns for transforming set expressions. And, as with tautologies, the set identity 
can be applied only when the set expression exactly matches the pattern.
The dual for each set identity in our list also appears in the list. The dual is 
obtained by interchanging c and d and interchanging S and [. The dual of the 
identity in Example 20 is
[A d (B c C )] c ([A′ d (B c C )] c (B c C )′) = S
which we could prove true by replacing each basic set identity used in the proof of 
Example 20 with its dual. Because this method always works, any time we have 
proved a set identity by using the basic identities, we have also proved its dual.
	
Example 20	
We can use the basic set identities to prove
[A c (B d C )] d ([A′ c (B d C )] d (B d C )′) = [
for A, B, and C any subsets of S. In the following proof, the number to the right is 
that of the basic set identity used to validate each step. The first step uses identity 
2b because the expression
[A c (B d C )] d ([A′ c (B d C )] d (B d C )′)
matches the right side of 2b, A d (B d C ) where A is [A c (B d C )], B is  
[A′ c (B d C )], and C is (B d C )′
[A c (B d C )] d ([A′ c (B d C )] d (B d C )′)
	
= ([A c (B d C )] d [A′ c (B d C )]) d (B d C )′	
(2b)
	
= ([(B d C ) c A] d [(B d C ) c A′]) d (B d C )′	
(la twice)
	
= [(B d C ) c (A d A′)] d (B d C )′	
(3a)
	
= [(B d C ) c [] d (B d C )′	
(5b)
	
= (B d C ) d (B d C )′	
(4a)
	
= [	
(5b)
REMINDER
You must match the 
­pattern of a set identity in 
order to use it. In the set 
identities, A, B, and C can 
represent any sets.
Practice 19	
a.	 Using the basic set identities, establish the set identity
[C d (A c B)] c [(A c B) d C′] = A c B
	
(A, B, and C are any subsets of S.)
b.	State the dual identity that you now know is true.
■

236	
Sets, Combinatorics, and Probability 
Countable and Uncountable Sets
In a finite set S, we can always designate one element as the first member, s1, 
­another element as the second member, s2, and so forth. If there are k elements in 
the set, then these can be listed in the order we have selected:
s1, s2, … , sk
This list represents the entire set S. The number of elements in a finite set is the 
cardinality of the set, so this would be a set of cardinality k, denoted by 0S0 = k.
If the set is infinite, we may still be able to select a first element s1, a second 
­element s2, and so forth, so that the list
s1, s2, s3, …
represents all elements of the set. Every element of the set will eventually appear 
in this list. Such an infinite set is said to be denumerable. Both finite and denu-
merable sets are countable sets because we can count, or enumerate, all of their 
elements. Being countable does not mean that we can state the total number of 
elements in the set; rather, it means that we can say, “Here is a first one,” “Here 
is a second one,” and so on, through the set. There are, however, infinite sets that 
are uncountable. In an uncountable set, the set is so big that there is no way to 
count out the elements and get the whole set in the process. Before we prove that 
uncountable sets exist, let’s look at some denumerable (countably infinite) sets.
Table 4.1
Method
Comment
Draw a Venn diagram
Not a good plan because no one diagram fits all cases 
and it will not prove the general identity.
Establish set inclusion 
in each direction
Take an arbitrary member of one side and show it  
belongs to the other side, and ­conversely.
Use already proved 
identities
Be sure to match the pattern of the identity you want to 
use.
Table 4.1 summarizes the approaches to proving set identities.
 
Example 21	
The set ℕ is denumerable.
To prove denumerability, we need only exhibit a counting scheme. For the set 
ℕ of nonnegative integers, it is clear that
0, 1, 2, 3, …
is an enumeration that will eventually include every member of the set.
■
Practice 20	 Prove that the set of even positive integers is denumerable.

Section 4.1   Sets	
237
	
Example 22	
The set ℚ+ of positive rational numbers is denumerable.
We assume that each positive rational number is written as a fraction of 
­positive integers. We can write all such fractions having the numerator 1 in one 
row, all those having the numerator 2 in a second row, and so on:
1/1
1/2
1/3
1/4
1/5
2/1
2/2
2/3
2/4
2/5
3/1
3/2
3/3
3/4
3/5
4/1
4/2
4/3
4/4
4/5
To show that the set of all fractions in this array is denumerable, we will thread 
an arrow through the entire array, beginning with 1/1; following the arrow gives 
an enumeration of the set. Thus the fraction 1/3 is the fourth member in this 
­enumeration:
1/1
1/2
1/3
1/4
1/5
2/1
2/2
2/3
2/4
2/5
3/1
3/2
3/3
3/4
3/5
4/1
4/2
4/3
4/4
4/5
Therefore the set represented by the array is denumerable. Note that our path 
through the array must “spread out” from one corner. If we begin to follow just the 
first row or just the first column, for example, we will never finish it to get on to 
other rows (or columns).
To obtain an enumeration of ℚ+, we use the enumeration of the set shown 
but eliminate any fractions not in lowest terms. This avoids the problem of listing 
both 1/2 and 2/4, for example, which represent the same positive rational. The 
­enumeration of ℚ+ thus begins with
1/1, 2/1, 1/2, 1/3, 3/1, 4/1, …
For example, we have eliminated 2/2, which reduces to 1/1.
■
Practice 21	 What is the 11th fraction in the above enumeration? What is the 1lth positive rational?
Now let’s show that there is an uncountable (not countable) infinite set. The 
proof technique that seems appropriate to prove that set A does not have property 
B is to assume that A does have property B and look for a contradiction. The 
proof in Example 23 is a very famous proof by contradiction known as Cantor’s 
­diagonalization method, after Georg Cantor, the nineteenth-century German 
mathematician known as the “father of set theory.”

238	
Sets, Combinatorics, and Probability 
 
Example 23	
We will show that the set of all the real numbers between 0 and 1 is uncountable.
We will write such numbers in decimal form; thus any member of the set can 
be written as
0.d1d2d3 …
Now let us assume that our set is countable. Therefore some enumeration of the 
set exists. A number such as 0.24999999 … can be written in alternative form as 
0.2500000 … (see Exercise 102 for an explanation of why these are alternative 
­representations of the same number). To avoid writing the same element twice in 
our enumeration, we will choose (arbitrarily) to always use the former representa-
tion and not the latter. We can depict an enumeration of the set as follows, where 
dij is the jth decimal digit in the ith number in the enumeration:
0.d11d12d13
0.d21d22d23
0.d31d32d33
We now construct a real number p = 0.p1p2 p3 … as follows: pi is always chosen 
to be 5 if dii ∙ 5 and 6 if dii = 5. Thus p is a real number between 0 and 1. For 
instance, if the enumeration begins with
0.342134 . . .
0.257001 . . .
0.546122 . . .
0.716525 . . .
then d11 = 3, d22 = 5, d33 = 6, and d44 = 5, so p1 = 5, p2 = 6, p3 = 5, and p4 = 6. 
Thus p begins with 0.5656 … .
If we compare p with the enumeration of the set, p differs from the first ­number 
at the first decimal digit, from the second number at the second decimal digit, from 
the third number at the third decimal digit, and so on.
0. 3  4  2  1  3  4 . . . 
0. 2  5  7  0  0  1 . . .
0. 5  4  6  1  2  2 . . .
0. 7  1  6  5  2  5 . . .
Therefore p does not agree with any of the representations in the enumeration. Fur-
thermore, because p contains no 0s to the right of the decimal, it is not the alterna-
tive representation of any of the numbers in the enumeration. Therefore p is a real 
number between 0 and 1 different from any other number in the enumeration, yet 
the enumeration was supposed to include all members of the set. Here, then, is the 
contradiction, and the set of all real numbers between 0 and 1 is indeed uncount-
able. (You can see why this proof is called a “diagonalization method.”)

Section 4.1   Sets	
239
Although it is interesting and perhaps surprising to learn that there are 
­uncountable sets, we are usually concerned with countable sets. A computer, of 
course, can manage only finite sets. In the rest of this chapter, we too, limit our 
attention to finite sets and various ways to count their elements.
Exercises 4.1
	
1.	Let S = {2, 5, 17, 27}. Which of the following expressions are true?
	
a.	 5 [ S	
b.	 2 + 5 [ S	
c.	 [ [ S	
d.	 S [ S
	
2.	Let B = {x 0 x [ ℚ and −1 < x < 2}. Which of the following expressions are true?
	
a.	 0 [ B	
b.	 −1 [ B	
c.	 −0.84 [ B	
d.	 "2 [ B
	
3.	How many different sets are described here? What are they?
	
{2, 3, 4}	
[
	
{x 0 x is the first letter of cat, bat, or apple}	
{x 0 x is the first letter of cat, bat, and apple}
	
{x 0 x [ ℕ and 2 ≤ x ≤ 4}	
{2, a, 3, b, 4, c}
	
{a, b, c}	
{3, 4, 2}
	
4.	How many different sets are described here? What are they?
	
{x 0 x = F(n) ` n [ {5, 6, 7}} [F(n) is a Fibonacci number]
	
{x 0 x 0 24} [x divides 24]
	
{1, 2, 3, 4}
	
{5, 8, 13}
	
{x 0 x [ ℕ ` 0 < x ≤ 4}
	
{x 0 x [ φ(5)} [φ(n) is the Euler phi function]
	
{12, 2, 6, 24, 8, 3, 1, 4}
	
{x 0 x is a digit in the decimal equivalent of the Roman numeral MCCXXXIV}
S e c t i o n  4 .1 	
Review
Techniques
•	 Describe sets by a list of elements and by a 
­characterizing property.
•	 Prove that one set is a subset of another.
•	 Find the power set of a set.
•	 Check that the required properties for a binary or 
unary operation are satisfied.
•	 Form new sets by taking the union, intersection, 
complement, and cross product of sets.
•	 Prove set identities by showing set inclusion in 
each direction or using the basic set identities.
•	 Demonstrate the denumerability of certain sets.
•	 Use the Cantor diagonalization method to prove 
that certain sets are uncountable.
Main Ideas
•	 Sets are unordered collections of objects that can 
be related (equal sets, subsets, etc.) or combined 
(union, intersection, etc.).
•	 Certain standard sets have their own notation.
•	 The power set of a set with n elements has 2n ­elements.
•	 Basic set identities exist (in dual pairs) and can be 
used to prove other set identities; once an identity is 
proved in this manner, its dual is also true.
•	 Countable sets can be enumerated, and ­uncountable 
sets exist.
W
W

240	
Sets, Combinatorics, and Probability 
	
5.	Describe each of the following sets by listing its elements:
	
a.	 {x 0 x [ ℕ and x2 < 25}
	
b.	{x 0 x [ ℕ and x is even and 2 < x < 11}
	
c.	 {x 0 x is one of the first three U.S. presidents}
	
d.	{x 0 x [ ℝ and x2 = −1}
	
e.	 {x 0 x is one of the New England states}
	
f.	 {x 0 x [ ℤ and 0 x 0 < 4} ( 0 x 0 denotes the absolute value function)
	
6.	Describe each of the following sets by listing its elements:
	
a.	 {x 0 x [ ℕ and x2 − 5x + 6 = 0}
	
b.	{x 0 x [ ℝ and x2 = 7}
	
c.	 {x 0 x [ ℕ and x2 − 2x − 8 = 0}
	
7.	Describe each of the following sets by giving a characterizing property:
	
a.	 {1, 2, 3, 4, 5} 
	
b.	{1, 3, 5, 7, 9, 11, …}
	
c.	 {Melchior, Gaspar, Balthazar}
	
d.	{0, 1, 10, 11, 100, 101, 110, 111, 1000, …}
	
8.	Describe each of the following sets:
	
a	 {x 0 x [ ℕ and (E q)(q [ {2, 3} and x = 2q)}
	
b.	{x 0 x [ ℕ and (E y)(E z)(y [ {0, 1} and z [ {3, 4} and y < x < z)}
	
c.	 {x 0 x [ ℕ and (4y)(y even S x ∙ y)}
	
9.	Given the description of a set A as A = {2, 4, 8 …}, do you think 16 [ A?
	 10.	What is the cardinality of each of the following sets?
	
a.	 S = {a, {a, {a}}}
	
b.	S = {{a}, {{a}}}
	
c.	 S = {[}
	
d.	S = {a, {[}, [}
	
e.	 S = {[, {[, {[}}, {[, {[, {[}}}}
	 11.	Let
	
A = {2, 5, 7}
	
B = {1, 2, 4, 7, 8}
	
C = {7, 8}
	
	Which of the following statements are true?
	
a.	 5 # A	
d.	 7 [ B
	
b.	C # B	
e.	 {2, 5} # A
	
c.	 [ [ A	
f.	 [ # C
	 12.	Let
	
A = {x 0 x [ ℕ and 1 < x < 50}
	
B = {x 0 x [ ℝ and 1 < x < 50}
	
C = {x 0 x [ ℤ and 0 x 0 ≥ 25}

Section 4.1   Sets	
241
	
	Which of the following statements are true?
	
a.	 A # B	
e.	"3 [ B
	
b.	17 [ A	
f.	 {0, 1, 2} # A
	
c.	 A # C	
g.	[ [ B
	
d.	−40 [ C	
h.	{x 0 x [ ℤ and x2 > 625} # C
	 13.	Let
	
R = {1, 3, π, 4.1, 9, 10}	
T = {1, 3, π}
	
S = {{1}, 3, 9, 10}	
U = {{1, 3, π}, 1}
	
	Which of the following statements are true? For those that are not, why not?
	
a.	 S # R	
e.	 {1} # T
	
b.	1 [ R	
f.	 {1} # S
	
c.	 1 [ S	
g.	 T ( R
	
d.	1 # U
	 14.	Let
	
R = {1, 3, π, 4.1, 9, 10}	
T = {1, 3, π}	
	
S = {{1}, 3, 9, 10} 	
U = {{1, 3, π}, 1}
	
	Which of the following statements are true? For those that are not, why not?
	
a.	 {1} [ S	
e.	 T o R
	
b.	[ # S	
f.	 T # R
	
c.	 T # U	
g.	 S # {1, 3, 9, 10}
	
d.	T [ U
	 15.	Let
	
A = {a, {a}, {{a}}}	
B = {a}	
C = {[, {a, {a}}}
	
	Which of the following statements are true? For those that are not, where do they fail?
	
a.	 B # A	
f.	 {a, {a}} [ A
	
b.	B [ A	
g.	 {a, {a}} # A
	
c.	 C # A	
h.	 B # C
	
d.	[ # C	
i.	 {{a}} # A
	
e.	 [ [ C
	 16.	Let
	
A = {[, {[, {[}}}	
B = [	
C = {[}	
D = {[, {[}}
	
	Which of the following statements are true? For those that are not, where do they fail?
	
a.	 C # A	
f.	 C = B
	
b.	C [ A	
g.	 C # D
	
c.	 B [ A	
h.	 C [ D
	
d.	B # A	
i.	 D # A
	
e.	 B [ C

242	
Sets, Combinatorics, and Probability 
	 17.	Let
A = {(x, y) 0 (x, y) lies within 3 units of the point (1, 4)}
	
	and
B = {(x, y) 0 (x − 1)2 + (y − 4)2 ≤ 25}
	
	Prove that A ( B.
	 18.	Let
A = {x 0 x [ ℝ and x2 − 4x + 3 < 0}
	
	and
B = {x 0 x [ ℝ and 0 < x < 6}
	
	Prove that A ( B.
	 19.	Program QUAD finds and prints solutions to quadratic equations of the form ax2 + bx + c = 0. Program 
EVEN lists all the even integers from −2n to 2n. Let Q denote the set of values output by QUAD and E 
denote the set of values output by EVEN.
	
a.	 Show that for a = 1, b = −2, c = −24, and n = 50, Q # E.
	
b.	Show that for the same values of a, b, and c, but a value for n of 2, Q h E.
	 20.	Let A = {x 0 cos(x/2) = 0} and B ={x 0 sin x = 0}. Prove that A # B.
	 21.	Which of the following statements are true for all sets A, B, and C?
	
a.	 If A # B and B # A, then A = B.	
d.	 [ [ {[}
	
b.	{[} = [	
e.	 [ # A
	
c.	 {[} = {0}
	 22.	Which of the following statements are true for all sets A, B, and C?
	
a.	 [ [ A
	
b.	{[} = {{[}}
	
c.	 If A ( B and B # C, then A ( C.
	
d.	If A ∙ B and B ∙ C, then A ∙ C.
	
e.	 If A [ B and B h C, then A o C.
	 23.	Prove that if A # B and B # C, then A # C.
	 24.	Prove that if A′ # B′, then B # A.
	 25.	Prove that for any integer n ≥ 2, a set with n elements has n (n − 1)/2 subsets that contain exactly two 
elements.
	 26.	Prove that for any integer n ≥ 3, a set with n elements has n(n − 1)(n − 2)/6 subsets that contain exactly 
three elements. (Hint: Use Exercise 25.)
	 27.	Find ℘(S) for S = {a}.
	 28.	Find ℘(S) for S = {a, b}.
	 29.	Find ℘(S) for S = {1, 2, 3, 4}. How many elements do you expect this set to have?
	 30.	Find ℘(S) for S = {[}.

Section 4.1   Sets	
243
	 31.	Find ℘(S ) for S = {[, {[}, {[, {[}}}.
	 32.	Find ℘(℘(S )) for S = {a, b}.
	 33.	What can be said about A if ℘(A) = {[, {x}, {y}, {x, y}}? 
	 34.	What can be said about A if ℘(A) = {[, {a}, {{a}}}?
	 35.	Prove that if ℘(A) = ℘(B), then A = B.
	 36.	Prove that if A # B, then ℘(A) # ℘(B).
	 37.	Solve for x and y.
	
a.	 (y, x + 2) = (5, 3)	
b.	 (2x, y) = (16, 7)	
c.	 (2x − y, x + y) = (−2, 5)
	 38.	a.	 Recall that ordered pairs must have the property that (x, y) = (u, v) if and only if x = u and y = v. 
Prove that {{x}, {x, y}} = {{u}, {u, v}} if and only if x = u and y = v. Therefore, although we know that  
(x, y) ∙ {x, y}, we can define the ordered pair (x, y) as the set {{x}, {x, y}}.
	
b.	Show by an example that we cannot define the ordered triple (x, y, z) as the set {{x}, {x, y}, {x, y, z}}.
	 39.	Which of the following candidates are binary or unary operations on the given sets? For those that are not, 
where do they fail?
	
a.	 x + y = x + 1; S = ℕ
	
b.	x + y = x + y − 1; S = ℕ
	
c.	 x + y =	
	
S = ℤ
	
d.	x# = ln x; S = ℝ
	 40.	Which of the following candidates are binary or unary operations on the given sets? For those that are not, 
where do they fail?
	
a.	 x# = x2; S = ℤ
	
b.	
e x − 1 if x is odd 
	 x	
if x is even
+
1
2
3
1
1
2
3
2
2
3
4
3
3
4
5
	
S = {1, 2, 3}
	
c.	 x + y = that fraction, x or y, with the smaller denominator; S = set of all fractions.
	
d.	x + y = that person, x or y, whose name appears first in an alphabetical sort; S = set of 10 people with 
different names.
	 41.	Which of the following candidates are binary or unary operations on the given sets? For those that are not, 
where do they fail?
	
a.	 x + y = e 1/x 	
if x is positive 
	 1/ (−x)	
if x is negative
S = ℝ
	
b.	x + y = xy (concatenation); S = set of all finite-length strings of symbols from the set { p, q, r}
	
c.	 x# = :x; where :x; denotes the greatest integer less than or equal to x; S = ℝ
	
d.	x + y = min(x, y); S = ℕ
	 42.	Which of the following candidates are binary or unary operations on the given sets? For those that are not, 
where do they fail?
	
a.	 x + y = greatest common multiple of x and y; S = ℕ
	
b.	x + y  = x + y; S = the set of Fibonacci numbers

244	
Sets, Combinatorics, and Probability 
	
c.	 x# = the string that is the reverse of x; S = set of all finite-length strings of symbols from the set { p, q, r}
	
d.	x + y = x + y; S = ℝ − ℚ
	 43.	How many different unary operations can be defined on a set with n elements? (Hint: Think about filling 
in a table.)
	 44.	How many different binary operations can be defined on a set with n elements? (Hint: Think about filling 
in a table.)
	 45.	We have written binary operations in infix notation, where the operation symbol appears between the two 
operands, as in A + B. Evaluation of a complicated arithmetic expression is more efficient when the op-
erations are written in postfix notation, where the operation symbol appears after the two operands, as in 
AB+. Many compilers change expressions in a computer program from infix to postfix form. One way to 
produce an equivalent postfix expression from an infix expression is to write the infix expression with a 
full set of parentheses, move each operator to replace its corresponding right parenthesis, and then elimi-
nate all left parentheses. (Parentheses are not required in postfix notation.) Thus,
A * B + C
	
	becomes, when fully parenthesized,
((A * B) + C )
	
	and the postfix notation is AB * C+. Rewrite each of the following  expressions in postfix notation:
	
a.	 (A + B) * (C − D)
	
b.	A ** B − C * D (**denotes exponentiation)
	
c.	 A * C + B/(C + D * B)
	 46.	Evaluate the following postfix expressions (see Exercise 45):
	
a	 2 4 * 5 + 	
b.	 5 1 + 2/1 − 	
c.	 3 4 + 5 1 − *
	 47.	Let
	
A = { p, q, r, s}
	
B = {r, t, v}
	
C = { p, s, t, u}
	
be subsets of S = { p, q, r, s, t, u, v, w}. Find
	
a.	 B d C	
b.	 A c C	
c.	 C′	
d.	 A d B d C
	 48.	Let
	
A = { p, q, r, s}
	
B = {r, t, v}
	
C = { p, s, t, u}
	
be subsets of S = { p, q, r, s, t, u, v, w}. Find
	
a.	 B − C	
b.	 (A c B)′	
c.	 A × B	
d.	 (A c B) d C′

Section 4.1   Sets	
245
	 49.	Let
	
A = {2, 4, 5, 6, 8}
	
B = {1, 4, 5, 9}
	
C = {x 0 x [ ℤ and 2 ≤ x < 5}
	
be subsets of S = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. Find
	
a.	 A c B	
e.	 A − B
	
b.	A d B	
f.	 A′
	
c.	 A d C	
g.	 A d A′
	
d.	B c C
	 50.	Let
	
A = {2, 4, 5, 6, 8}
	
B = {1, 4, 5, 9}
	
C = {x 0 x [ ℤ and 2 ≤ x < 5}
	
be subsets of S = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. Find
	
a.	 (A d B)′	
e.	 (C ′ c B)′
	
b.	C − B	
f.	 B × C
	
c.	 (C d B) c A′	
g.	(B − A) c C
	
d.	(B − A)′ d (A − B)
	 51.	Let
	
A = {a, {a}, {{a}}}
	
B = {[, {a}, {a, {a}}}
	
C = {a}
	
be subsets of S = {[, a, {a}, {{a}}, {a, {a}}}. Find 
	
a.	 A d C	
d.	 [ d B	
f.	 A′ d B
	
b.	B d C′	
e.	 (B c C ) d A	
g.	 {[} d B
	
c.	 A c B
	 52.	Let
	
A = {x 0 x is the name of a former president of the United States}
	
B = {Adams, Hamilton, Jefferson, Grant}
	
C = {x 0 x is the name of a state}
	
Find
	
a.	 A d B	
b.	 A d C	
c.	 B d C

246	
Sets, Combinatorics, and Probability 
	 53.	Let S = A × B where A = {2, 3, 4} and B = {3, 5}. Which of the following statements are true?
	
a.	 A # S	
d.	 (5, 4) [ S
	
b.	3 [ S	
e.	 [ # S
	
c.	 (3, 3) [ S	
f.	 {(2, 5)} # S
	 54.	Let
	
A = {x 0 x is a word that appears before dog in an English language dictionary}
	
B = {x 0 x is a word that appears after canary in an English language dictionary}
	
C = {x 0 x is a word of more than four letters}
	
Which of the following statements are true?
	
a.	 B # C
	
b.	A c B = {x 0 x is a word in an English language dictionary}
	
c.	 cat [ B d C ′
	
d.	bamboo [ A − B
	 55.	Consider the following subsets of ℤ:
	
A = {x 0 (E y)( y [ ℤ and y ≥ 4 and x = 3y)}
	
B = {x 0 (E y)( y [ ℤ and x = 2y)}
	
C = {x 0 x [ ℤ and 0 x 0 ≤ 10}
	
Using set operations, describe each of the following sets in terms of A, B, and C.
	
a.	 set of all odd integers
	
b.	{−10, −8, −6, −4, −2, 0, 2, 4, 6, 8, 10}
	
c.	 {x 0 (E y)( y [ ℤ and y ≥ 2 and x = 6y)}
	
d.	{−9, −7, −5, −3, −1, 1, 3, 5, 7, 9}
	
e.	 {x 0 (E y)( y [ ℤ and y ≥ 5 and x = 2y + 1)} c {x 0 (E y)( y [ ℤ and y ≤ −5 and x = 2y − 1)}
	 56.	Let
	
A = {x 0 x [ ℝ and 1 < x ≤ 3}
	
B = {x 0 x [ ℝ and 2 ≤ x ≤ 5}
	
Using set operations, describe each of the sets shown in terms of A and B.
	
a.	
0
1
2
3
4
0
1
2
3
4
0
1
2
3
4
	
b.	
	
c.	

Section 4.1   Sets	
247
	 57.	Consider the following subsets of the set of all students:
	
A = set of all computer science majors
	
B = set of all physics majors
	
C = set of all science majors
	
D = set of all female students
	
Using set operations, describe each of the following sets in terms of A, B, C, and D:
	
a.	 set of all students not majoring in science
	
b.	set of all female physics majors
	
c.	 set of all students majoring in both computer science and physics
	
d.	set of all male computer science majors
	 58.	Consider the following subsets of the set of all students:
	
A = set of all computer science majors
	
B = set of all physics majors
	
C = set of all science majors
	
D = set of all female students
	
Using set operations, describe each of the following sets in terms of A, B, C, and D:
	
a.	 set of all male students who are not physics majors
	
b.	set of all science majors who are not computer science majors
	
c.	 set of all students who are female or science majors
	
d.	set of all students who are science majors but are neither computer science nor physics majors
	 59.	Write the set expression for the desired results of the Web search query for sites pertaining to dogs that are 
not retrievers (Exercise 31, Section 1.1). Assume that D = set of dog pages, R = set of retriever pages.
	 60.	Write the set expression for the desired results of the Web search query for sites pertaining to oil paintings 
by Van Gogh or Rembrandt but not Vermeer (Exercise 32, Section 1.1). Assume that O = set of oil paint-
ing pages, G = set of Van Gogh pages, R = set of Rembrandt pages, V = set of Vermeer pages.
	 61.	Write the set expression for the desired results of the Web search query for sites pertaining to novels or 
plays about AIDS (Exercise 33, Section 1.1). Assume that N = set of novel pages, P = set of play pages, 
A = set of AIDS pages.
	 62.	Write the set expression for the desired results of the Web search query for sites pertaining to coastal 
­wetlands in Louisiana but not in Alabama (Exercise 34, Section 1.1). Assume that C = set of coastal 
­wetlands pages, L = set of Louisiana pages, A = set of Alabama pages.
	 63.	Which of the following statements are true for all sets A, B, and C?
	
a.	 A c A = A	
d.	 (A′)′ = A
	
b.	B d B = B	
e.	 A − B = (B − A)′
	
c.	 (A d B)′ = A′ d B′	
f.	 (A − B) d (B − A) = [
	 64.	Which of the following statements are true for all sets A, B, and C?
	
a. If A d B = [, then A ( B.	
d.	 [ d {[} = [
	
b. B × A = A × B	
e.	 (A − B) c (B − C ) = A − C
	
c. [ × A = [	
f.	 (A − C ) d (A − B) = A − (B c C )

248	
Sets, Combinatorics, and Probability 
	 65.	Which of the following statements are true for all sets A, B, and C?
	
a.	 A c (B × C ) = (A c B) × (A c C )
	
b.	A × (B d C ) = (A × B) d (A × C )
	
c.	 A × [ = [
	 66.	Which of the following statements are true for all sets A, B, and C?
	
a.	 ℘(A) × ℘(A) = ℘(A2)
	
b.	A × (B × C ) = (A × B) × C
	
c.	 ℘(A × B) = ℘(A) × ℘(B)
	 67.	For each of the following statements, find general conditions on sets A and B to make the statement true:
	
a.	 A c B = A	
c.	 A c [ = [	
e.	 A c B # A d B
	
b.	A d B = A	
d.	 B − A = [	
f.	 A × B = B × A
	 68.	For any finite set S, 0 S 0 denotes the number of elements in S. If 0 A 0 = 3 and 0 B 0 = 4, find
	
a.	 0 A × B 0
	
b.	0 A2 0
	
c.	 0 B2 0
	
d.	the maximum possible value for 0 A d B 0
	
e.	 the minimum possible value for 0 A c B 0
	 69.	Prove that (A d B) # A where A and B are arbitrary sets.
	 70.	Prove that A # (A c B) where A and B are arbitrary sets.
	 71.	Prove that ℘(A) d ℘(B) = ℘(A d B) where A and B are arbitrary sets.
	 72.	Prove that ℘(A) c ℘(B) # ℘(A c B) where A and B are arbitrary sets.
	 73.	Prove that if A c B = A − B, then B = [. (Hint: Do a proof by contradiction.)
	 74.	Prove that if (A − B) c (B − A) = A c B, then A d B = [. (Hint: Do a proof by contradiction.)
	 75.	Prove that if C # B − A, then A d C = [.
	 76.	Prove that if (A − B) c B = A, then B # A.
	 77.	Prove that A # B if and only if A d B′ = [.
	 78.	Prove that (A d B) c C = A d (B c C ) if and only if C # A.
Exercises 79 and 80 refer to a binary operation on sets called the symmetric difference, which is defined by  
A ! B = (A − B) c (B − A).
	 79.	a.	 Draw a Venn diagram to illustrate A ! B.
	
b.	For A = {3, 5, 7, 9} and B = {2, 3, 4, 5, 6}, what is A ! B?
	
c.	 Prove that A ! B = (A c B) − (A d B) for arbitrary sets A and B.
	 80.	a.	 For an arbitrary set A, what is A ! A? What is [ ! A?
	
b.	Prove that A ! B = B ! A for arbitrary sets A and B.
	
c.	 For any sets A, B, and C, prove that (A ! B) ! C = A ! (B ! C ).
	 81.	Verify the basic set identities on page 234 by showing set inclusion in each direction. (We have already 
done 3a and 4a.)
	 82.	A and B are subsets of a set S. Prove the following set identities by showing set inclusion in each direction.
	
a.	 (A c B)′ = A′ d B′
	
b.	(A d B)′ = A′ c B′ f  De Morgan’s laws

Section 4.1   Sets	
249
	
c.	 A c (B d A) = A
	
d.	(A d B′)′ c B = A′ c B 
	
e.	 (A d B) c (A d B′) = A
	
f.	 [A d (B c C )]′ = A′ c (B′ d C′)
	 83.	A, B, and C are subsets of a set S. Prove the following set identities using the basic set identities listed in 
this section. Give a reason for each step. State the dual of each of these identities.
	
a.	 (A c B) d (A c B′) = A
	
b.	([(A d C ) d B] c [(A d C ) d B′]) c (A d C )′ = S
	
c.	 (A c C ) d [(A d B) c (C′ d B)] = A d B 
	 84.	A is a subset of a set S. Prove the following set identities:
	
a. A c A = A	
d. A c S = S
	
b. A d A = A	
e. (A′)′ = A
	
c. A d [ = [
	 85.	A, B, and C are subsets of a set S. Prove the following set identities by using previously proved identities, 
including those in Exercises 82–84. Give a reason for each step.
	
a.	 A d (B c A′) = B d A
	
b.	(A c B) − C = (A − C ) c ( B − C )
	
c.	 (A − B) − C = (A − C ) − B
	 86.	A, B, and C are subsets of a set S. Prove the following set identities by using previously proved identities, 
including those in Exercises 82–84. Give a reason for each step.
	
a.	 [(A′ c B′) d A′ ]′ = A
	
b.	(A − B) − C = (A − C ) − (B − C )
	
c.	 A − (A − B) = A d B
	
d.	(A c B) − (A d B) = (A − B) c (B − A) 
	 87.	The operation of set union can be defined as an n-ary operation for any integer n ≥ 2.
	
a.	 Give a definition similar to that for the union of two sets for A1 c A2 c cc An.
	
b.	Give a recursive definition for A1 c A2 c cc An.
	 88.	Using the recursive definition of set union from Exercise 87(b), prove the generalized associative property 
of set union, which is that for any n with n ≥ 3 and any p with 1 ≤ p ≤ n − 1,
(A1 c A2 c cc Ap) c (Ap+1 c Ap+2 c cc An) = A1 c A2 c cc An
	 89.	The operation of set intersection can be defined as an n-ary operation for any integer n ≥ 2.
	
a.	 Give a definition similar to that for the intersection of two sets for A1 d A2 d cd An.
	
b.	Give a recursive definition for  A1 d A2 d cd An.
	 90.	Using the recursive definition of set intersection from Exercise 89(b), prove the generalized associative 
property of set intersection, which is that for any n with n ≥ 3 and any p with 1 ≤ p ≤ n − 1,
(A1 d A2 d cd Ap) d (Ap+1 d Ap+2 d cd An) = A1 d A2 d cd An

250	
Sets, Combinatorics, and Probability 
	 91.	Prove that for subsets A1, A2, … , An and B of a set S, the following generalized distributive properties hold, 
where n ≥ 2. (See Exercises 87 and 89.)
	
a.	 B c (A1 d A2 d cd An) = (B c A1) d (B c A2) d cd (B c An)
	
b.	B d (A1 c A2 c cc An) = (B d A1) c (B d A2) c cc (B d An)
	 92.	Prove that for subsets A1, A2, … , An of a set S, the following generalized De Morgan’s laws hold, where 
n ≥ 2. (See Exercises 82, 87, and 89.)
	
a.	 (A1 c A2 c cc An)′ = A′1 d A′2 d cd A′n
	
b.	(A1 d A2 d cd An)′ = A′1 c A′2 c cc A′n
	 93.	The operations of set union and set intersection can be extended to apply to an infinite family of sets. We 
may describe the family as the collection of all sets Ai, where i takes on any of the values of a fixed set I. 
Here, I is called the index set for the family. The union of the family, di[I
 Ai, is defined by
di[I Ai = {x 0 x is a member of some Ai}
	
The intersection of the family, ti[I Ai, is defined by
ti[I Ai = {x 0 x is a member of each Ai}.
	
a.	 Let I = {1, 2, 3, …}, and for each i [ I, let Ai be the set of real numbers in the interval (−1/i, 1/i ). 
What is di[I Ai? What is ti[I Ai?
	
b.	Let I = {1, 2, 3 …}, and for each i [ I, let Ai be the set of real numbers in the interval [−1/i, 1/i ]. 
 What is di[I Ai? What is ti[I Ai?
	 94.	According to our use of the word “set,” if C is a subset of the universal set S, then every element of S either 
does or does not belong to C. In other words, the probability of a member x of S being a member of C is 
either 1 (x is a member of C ) or 0 (x is not a member of C ). C is a fuzzy set if every x [ S has a probability 
p, 0 ≤ p ≤ 1, of being a member of C. The probability p associated with x is an estimate of the likelihood 
that x may belong to C when the actual composition of C is unknown. Set operations can be done on fuzzy 
sets as follows: If element x has probability p1 of membership in C and probability p2 of membership in D, 
then the probability of x being a member of C c D, C d D, and C′ is, respectively, max( p1, p2), min( p1, p2), 
and 1 − p1. (If we consider the statements x [ C and x [ D as propositional wffs A and B, respectively, with 
certain probabilistic truth values, then the probability of x [ C c D is the probability that A ~ B is true. The 
rules for fuzzy set operations then parallel the rules for fuzzy logic, discussed in Exercise 54, Section 1.1.)
Let S be a set of possible disease-causing agents, S = {genetics, virus, nutrition, bacteria, ­environment}. 
The fuzzy sets AIDS and ALZHEIMERS are defined as AIDS = {genetics, 0.2; virus, 0.8; nutrition, 0.1; 
bacteria, 0.4; environment, 0.3} and ALZHEIMERS = {genetics, 0.7; virus, 0.4; nutrition, 0.3; bacteria, 
0.3; environment, 0.4}.
	
a.	 Find the fuzzy set AIDS c ALZHEIMERS.
	
b.	Find the fuzzy set AIDS d ALZHEIMERS.
	
c.	 Find the fuzzy set (AIDS)′.
Exercises 95 and 96 complete the proof, begun in Section 2.2, that the second principle of induction, the first 
principle of induction, and the principle of well-ordering are all equivalent.
	 95.	The principle of well-ordering says that every nonempty set of positive integers has a smallest member. 
Prove that the first principle of mathematical induction, that is,
	
1.	P(1) is true 
	
2.	(4k)[P(k) true S P(k + 1) true] f  S P(n) true for all positive integers n

Section 4.1   Sets	
251
	
	implies the principle of well-ordering. (Hint: Assume that the first principle of mathematical induction 
is valid, and use proof by contradiction to show that the principle of well-ordering is valid. Let T be a 
nonempty subset of the positive integers that has no smallest member. Let P(n) be the property that every 
member of T is greater than n.)
	 96.	Prove that the principle of well-ordering (see Exercise 95) implies the second principle of mathematical 
induction. Hint: Assume that the principle of well-ordering is valid, and let P be a property for which
	
1.′	 P(1) is true 
	
2.′	 (4k)[P(r) true for all r, 1 ≤ r ≤ k S P(k + 1) true]
	
	Let T be the subset of the positive integers defined by
T = {t 0 P(t) is not true}
	
	Show that T is the empty set.
	 97.	Prove that the set of odd positive integers is denumerable.
	 98.	Prove that the set ℤ of all integers is denumerable.
	 99.	Prove that the set of all finite-length strings of the letter a is denumerable.
	100.	Prove that the set of all finite-length binary strings is denumerable.
	101.	Prove that the set ℤ × ℤ is denumerable.
	102.	In Example 23, the claim was made that 0.249999999 … is the same number as 0.250000000 … . The first 
representation is a nonterminating decimal, and a calculus-type argument can be made that “in the limit” 
these are the same values. Here is a slightly different argument:
	
a.	 Let n = 0.249999 … .
	
	
Compute 100n by multiplying both sides of this equation by 100.
	
	
Subtract n from 100n to give a value for 99n.
	
	
Solve the resulting equation for n.
	
b.	Let m = 0.250000 … .
	
	
Compute 100m by multiplying both sides of this equation by 100.
	
	
Subtract m from 100m to give a value for 99m.
	
	
Solve the resulting equation for m.
	
c.	 Compare the values of n and m.
	103.	Use Cantor’s diagonalization method to show that the set of all infinite sequences of positive integers is 
not countable.
	104.	Use Cantor’s diagonalization method to show that the set of all infinite strings of the letters {a, b} is not 
countable.
	105.	Explain why the union of any two denumerable sets is denumerable.
	106.	Explain why any subset of a countable set is countable.
	107.	Sets can have sets as elements (see Exercise 13, for example). Let B be the set defined as follows:
B = {S 0 S is a set and S o S}
	
	Argue that both B [ B and B o B are true. This contradiction is called Russell’s paradox, after the famous 
philosopher and mathematician Bertrand Russell, who stated it in 1901. (A carefully constructed axiomat-
ization of set theory puts some restrictions on what can be called a set. All ordinary sets are still sets, but 
peculiar sets that get us into trouble, like B in this exercise, seem to be avoided.)

252	
Sets, Combinatorics, and Probability 
	
S e c t i o n  4 . 2 	 Counting
Combinatorics is the branch of mathematics that deals with counting. Count-
ing questions are important whenever we have finite resources (How much stor-
age does a particular database consume? How many users can a given computer 
configuration support?) or whenever we are interested in efficiency (How many 
computations does a particular algorithm involve?).
Counting questions often boils down to finding how many members there are 
in some finite set, that is, what is the cardinality of the set. This seemingly trivial 
question can be difficult to answer. We have already answered some “how many” 
questions—How many rows are there in a truth table with n statement letters, and 
how many subsets are there in a set with n elements? (Actually, as we’ve noted, 
these questions can be thought of as the same question.)
Multiplication Principle
We solved the truth table question by drawing a tree of possibilities. This tree sug-
gests a general principle that can be used to solve many counting problems. Before 
we state the general principle, we look at another tree example.
	
Example 24	
A child is allowed to choose one jellybean out of two jellybeans, one red and one 
black, and one gummy bear out of three gummy bears, yellow, green, and white. 
How many different sets of candy can the child have?
We can solve this problem by breaking the task of choosing candy into two 
sequential tasks of choosing the jellybean and then choosing the gummy bear.  
The tree of Figure 4.3 shows that there are 2 × 3 = 6 possible outcomes: {R, Y}, 
{R, G}, {R, W}, {B, Y}, {B, G}, and {B, W}.
{R, Y}
{R, G}
{R, W}
{B, Y}
{B, G}
{B, W}
Y
G
W
Y
G
W
R
B
Choose jellybean.
Choose gummy bear.
In this problem the sequence of events could be reversed; the child could 
choose the gummy bear first and the jellybean second, resulting in the tree of 
Figure 4.4, but the number of outcomes is the same (3 × 2 = 6). Thinking of a se-
quence of successive events helps us solve the problem, but the sequencing is not 
a part of the problem since the set {R, Y} is the same as the set {Y, R}.
{Y, R}
{Y, B}
{G, R}
{G, B}
{W, R}
{W, B}
R
B
R
G
B
R
B
Y
W
Choose gummy bear.
Choose jellybean.
Both these trees are “balanced” in the sense that the second level has a fixed num-
ber of outcomes regardless of the outcome at the previous level.
Figure 4.3
Figure 4.4

Section 4.2   Counting	
253
Example 24 illustrates that the total number of outcomes for a sequence 
of events can be obtained by multiplying the number of outcomes for the first 
event by the number of outcomes for the second. This idea is summarized in the 
­multiplication principle.
	
Principle	
Multiplication Principle
If there are n1 possible outcomes for a first event and n2 possible outcomes for 
a second event, there are n1 × n2 possible outcomes for the sequence of the two 
events.
The multiplication principle can be extended by induction to apply to a 
­sequence of any finite number of events. (See Exercise 73 at the end of this sec-
tion.) The multiplication principle is useful whenever we want to count the total 
number of possible outcomes for a task that can be broken down into a sequence 
of successive subtasks.
REMINDER
Use the multiplication 
principle when there is a 
sequence of events.
	
Example 25	
The last part of your telephone number contains four digits. How many such 
­four-digit numbers are there?
We can construct four-digit numbers by performing a sequence of subtasks: 
choose the first digit, then the second, the third, and finally the fourth. The first 
digit can be any one of the 10 digits from 0 to 9, so there are 10 possible outcomes 
for the first subtask. Likewise, there are 10 different possibilities each for the sec-
ond digit, the third, and the fourth. Using the multiplication principle, we multiply 
the number of outcomes for each subtask in the sequence. Therefore there are  
10 # 10 # 10 # 10 = 10,000 different numbers.
If an element cannot be used again—that is, if repetitions are not allowed—
the number of possible outcomes for successive events will be affected.
	
Example 26	
Referring to Example 25, how many four-digit numbers are there if the same digit 
cannot be used twice?
Again we have the sequence of subtasks of selecting the four digits, but no 
repetitions are allowed. There are 10 choices for the first digit, but only 9 choices 
for the second because we can’t use what we used for the first digit, and so on. 
There are 10 # 9 # 8 # 7 = 5040 different numbers.
	
Example 27	
	
a.	 How many ways are there to choose three officers from a club of  
25 ­people?
	
b.	 How many ways are there to choose three officers from a club of 25 ­people 
if someone can hold more than one office?
In (a), there are three successive subtasks with no repetitions. The first subtask, 
choosing the first officer, has 25 possible outcomes. The second ­subtask has 24 out-
comes, the third 23 outcomes. The total number of outcomes is 25 # 24 # 23 = 13,800. 
In (b), the same three subtasks are done in succession, but repetitions are allowed. 
The total number of outcomes is 25 # 25 # 25 = 15,625.

254	
Sets, Combinatorics, and Probability 
	
Example 28	
When you order pizza at your favorite pizza place, you have the choice of thin 
crust, regular crust, or deep-dish; small, medium, or large; and pepperoni, sausage, 
barbeque, extra cheese, or vegetable. How many different pizzas can be ordered?
Again, there is a sequence of tasks: choose the crust, choose the size, and 
choose the topping. The total number of outcomes is 3 # 3 # 5 = 45.
■
Practice 22	 If a man has four suits, eight shirts, and five ties, how many outfits can he put together?
	
Example 29	
For any finite set S, 0 S 0 denotes the number of elements in S. If A and B are finite 
sets, then
0 A × B 0 = 0 A 0 # 0 B 0
A × B consists of all ordered pairs with first component from A and second com-
ponent from B. Forming such ordered pairs can be thought of as the sequence of 
tasks of choosing the first component, for which there are 0 A 0 outcomes, and then 
choosing the second component, for which there are 0 B 0 outcomes. The result fol-
lows from the multiplication principle.
Addition Principle
Suppose we want to select a dessert from three pies and four cakes. In how many 
ways can this be done? There are two events, one with three outcomes (choosing 
a pie) and one with four outcomes (choosing a cake). However, we are not do-
ing a sequence of two events here, since we are getting only one dessert, which 
must be chosen from the two disjoint sets of possibilities. The number of different 
outcomes is the total number of choices we have, 3 + 4 = 7. This illustrates the 
addition principle.
	
Principle	
Addition Principle
If A and B are disjoint events with n1 and n2 possible outcomes, respectively, then 
the total number of possible outcomes for event “A or B” is n1 + n2.
The addition principle can be extended by induction to the case of any finite 
number of disjoint events. (See Exercise 74 at the end of this section.) The addi­
tion principle is useful whenever we want to count the total number of possible 
outcomes for a task that can be broken down into disjoint cases.
	
Example 30	
A customer wants to purchase a vehicle from a dealer. The dealer has 23 autos and 
14 trucks in stock. How many selections does the customer have?
The customer wants to choose a car or truck. These are disjoint events; choosing 
an auto has 23 outcomes and choosing a truck has 14. By the addition principle, 
choosing a vehicle has 23 + 14 = 37 outcomes. Notice the requirement that the 
outcomes for events A and B be disjoint sets. Thus, if a customer wanted to pur-
chase a vehicle from a dealer who had 23 autos, 14 trucks, and 17 red vehicles in 
stock, we could not conclude that the customer had 23 + 14 + 17 choices!
REMINDER
Use the addition principle 
only when the events are 
disjoint—have no com-
mon outcomes.

Section 4.2   Counting	
255
	
Example 31	
Let A and B be disjoint finite sets. Then 0 A c B 0 = 0 A 0 + 0 B 0.
Finding 0 A c B 0 can be done by the disjoint cases of counting the number of 
elements in A, 0 A 0, and the number of elements in B, 0 B 0. By the addition principle, 
we sum these two numbers.
 
	
Example 32	
If A and B are finite sets, then
0 A − B 0 = 0 A 0 − 0 A d B 0
and
0 A − B 0 = 0 A 0 − 0 B 0 if B # A
To prove the first equality, note that
	
(A − B) c (A d B) = (A d B′) c (A d B) 
	
= A d (B′ c B)
	
= A d S
	
= A
so that A = (A − B) c (A d B). Also, A − B and A d B are disjoint sets; therefore, 
by Example 31,
0 A 0 = 0 (A − B) c (A d B) 0 = 0 A − B 0 + 0 A d B 0
or
0 A − B 0 = 0 A 0 − 0 A d B 0
The second equation follows from the first, because if B # A then A d B = B.
Using the Principles Together
Frequently the addition principle is used in conjunction with the multiplication 
principle.
 
	
Example 33	
Referring to Example 24, suppose we want to find how many different ways the 
child can choose the candy, rather than the number of sets of candy the child can 
have. Then choosing a red jellybean followed by a yellow gummy bear is not the 
same as choosing a yellow gummy bear followed by a red jellybean. We can con-
sider two disjoint cases—choosing jellybeans first or choosing gummy bears first. 
Each of these cases (by the multiplication principle) has six outcomes, so (by the 
addition principle) there are 6 + 6 = 12 possible ways to choose the candy.

256	
Sets, Combinatorics, and Probability 
Often a counting problem can be solved in more than one way. Although the 
possibility of a second solution might seem confusing, it provides an excellent 
way to check our work; if two different ways of looking at the problem produce 
the same answer, it increases our confidence that we have analyzed the problem 
correctly.
 
	
Example 34	
How many four-digit numbers begin with a 4 or a 5?
We can consider the two disjoint cases—numbers that begin with 4 and num-
bers that begin with 5. Counting the numbers that begin with 4, there is 1 out-
come for the subtask of choosing the first digit, then 10 possible outcomes for the 
subtasks of choosing each of the other three digits. Hence, by the multiplication 
principle there are 1 # 10 # 10 # 10 = 1000 ways to get a four-digit number beginning 
with 4. The same reasoning shows that there are 1000 ways to get a four-digit num-
ber beginning with 5. By the addition principle, there are 1000 + 1000 = 2000 total 
­possible outcomes.
■
Practice 23	 If a woman has 7 blouses, 5 skirts, and 9 dresses, how many different outfits does she  
have?
 
	
Example 35	
Consider the problem of Example 34 again. We can avoid using the addition princi-
ple by thinking of the problem as four successive subtasks, where the first ­subtask, 
choosing the first digit, has two possible outcomes—choosing a 4 or choosing a 5. 
Then there are 2 # 10 # 10 # 10 = 2000 possible outcomes.
 
	
Example 36	
How many three-digit integers (numbers between 100 and 999 inclusive) are even?
One solution notes that an even number ends in 0, 2, 4, 6, or 8. Taking these 
as separate cases, the number of three-digit integers ending in 0 can be found by 
choosing the three digits in turn. There are 9 choices, 1 through 9, for the first digit; 
10 choices, 0 through 9, for the second digit; and 1 choice for the third digit, 0. 
By the multiplication principle, there are 90 numbers ending in 0. Similarly, there 
are 90 numbers ending in 2, 4, 6, and 8, so by the addition principle, there are  
90 + 90 + 90 + 90 + 90 = 450 numbers.
Another solution takes advantage of the fact that there are only 5 choices for 
the third digit. By the multiplication principle, there are 9 # 10 # 5 = 450 numbers.
For this problem, there is a third solution of the “serendipity” type we dis-
cussed in Section 2.1. There are 999 − 100 + 1 = 900 three-digit integers in the 
range specified. Half are even and half are odd, so 450 of them must be even.
 
	
Example 37	
Suppose the last four digits of a telephone number must include at least one re-
peated digit. How many such numbers are there?
Although it is possible to do this problem by using the addition principle direct-
ly, it is difficult because there are so many disjoint cases to consider. For ­example, 
if the first two digits are alike but the third and fourth are different, there are  
10 # 1 # 9 # 8 ways this can happen. If the first and third digit are alike but the ­second 

Section 4.2   Counting	
257
and fourth are different, there are 10 # 9 # 1 # 8 ways this can happen. If the first two 
digits are alike and the last two are also alike but different from the first two, there are 
10 # 1 # 9 # 1 such numbers. Obviously, there are many other possibilities.
Instead, we solve the problem by noting that numbers with repetitions and 
numbers with no repetitions are disjoint sets whose union equals all four-digit 
numbers. By Example 31 we can find the number with repetitions by subtracting 
the number with no repetitions (5040, according to Example 26) from the total 
number (10,000, according to Example 25). Therefore, there are 4960 numbers 
with repetitions.
	
Example 38	
A computer (or tablet, or camera, or cell phone) that wishes to connect to the In-
ternet must have an IP (Internet Protocol) address assigned to it. This allows the 
device to be “found” over the Internet, much as a postal address allows a building 
to be “found” via regular mail. The version of IP known as IPv4 uses an address 
that is a 32-bit, or 4-byte, number (1 byte equals 8 bits). The first part of the ad-
dress, called the netid, identifies the network that the machine is part of and the 
rest, called the hostid, identifies the machine itself. Note that this is a hierarchical 
addressing scheme. A router trying to decide where to send a data packet looks at 
the netid to determine the network. The hostid bytes need never be consulted until 
the data packet has reached the correct network. U.S. postal addresses are hierar-
chical in the opposite order, with the most specific information first.
How many different IPv4 addresses are there? Each of the 32 bits can be set to 
0 or 1, so by the multiplication principle, there are 2 # 2 # 2 #  c # 2 = 232 different 
bit patterns. Looking at a more abstract view, assume that a particular IP address 
uses 16 bits for the netid and 16 bits for the hostid. Again using the multiplication 
principle, this would give 216 # 216 = (again) 232 unique IP addresses. This number 
is roughly 4.3 billion, which seems large enough to satisfy the world’s needs. But 
no − the pool of IPv4 addresses allotted to some regions of the world began to run 
out in 2011 and more would do so in another year or two. Hence the switch to IPv6.
An IPv6 address is 128 bits, divided into 64 bits for the network prefix that 
identifies a particular network and the last 64 bits for the interface ID that identifies 
the unique node on the network. While the gross structure of an IPv6 address there-
fore sounds just like an IPv4 address only bigger, there are details that make the 
IPv6 scheme more efficient. And exactly how big is the pool of IPv6 addresses? 
Using the same reasoning as before, there are 2128 unique addresses. This number 
is roughly 3.4 × 1038, or 340 trillion trillion trillion, enough, it is said, for every 
star in the known universe to have the equivalent of its very own IPv4 internet.
The World IPv6 Launch occurred on June 6, 2012, but it was not like turning 
on a switch. Many major companies already supported IPv6 and IPv4 will con-
tinue to be supported over a few years of transition.
Decision Trees
Trees such as those in Figures 4.3 and 4.4 illustrate the number of outcomes of an 
event based on a series of possible choices. Such trees are called decision trees. 
We will see in Chapter 6 how decision trees are used in analyzing algorithms, 
but for now we use them to solve additional counting problems. The trees of  
Figures 4.3 and 4.4 led to the multiplication principle because the number of  

258	
Sets, Combinatorics, and Probability 
outcomes at any one level of the tree is the same throughout that level. In  
Figure 4.4, for example, level 2 of the tree shows two outcomes for each of the  
3 branches formed at level 1. Less regular decision trees can still be used to solve 
counting problems where the multiplication principle does not apply.
	
Example 39	
Tony is pitching pennies. Each toss results in heads (H) or tails (T). How many 
ways can he toss the coin 5 times without having 2 heads in a row?
T
H
T
T
T
H
H
T
H
T
H
H
T
H
T
T
H
T
T
T
H
H
T
T
H
T
H
T
T
T
T
H
T
T
T
H
T
T
H
T
T
H
T
H
T
H
T
T
H
T
T
T
H
T
T
T
H
H
T
T
T
H
T
T
H
T
H
T
T
H
T
T
T
T
T
T
H
T
T
T
H
T
T
T
T
T
T
H
T
T
T
H
H
T
H
T
Toss 1
Toss 2
Toss 5
Toss 4
Toss 3
Figure 4.5 shows the decision tree for this problem. Each coin toss has 2 outcomes; 
the left branch is labeled H for heads, the right branch is labeled T for tails. When-
ever an H appears on a branch, the next level can only contain a right (T) branch. 
There are 13 possible outcomes, shown at the bottom of the tree.
Figure 4.5
■
Practice 24	 Explain why the multiplication principle does not apply to Example 39.
■
Practice 25	 Draw the decision tree for the number of strings of X ’s, Y ’s, and Z ’s with length 3 that do 
not have a Z following a Y.
S e c t i o n  4 . 2 	 Review
Technique
•	 Use the multiplication principle, the addition prin-
ciple, and decision trees for counting the number of 
objects in a finite set.
Main Ideas
•	 The multiplication principle is used to count  
the number of possible out­comes for a sequence of 
events, each of which has a fixed number of ­outcomes.
•	 The addition principle is used to count the number 
of possible outcomes for disjoint events.
•	 The multiplication and addition principles are often 
used together.
•	 Decision trees can be used to count the number 
of outcomes for a sequence of events where the 
number of outcomes for a given event is not con-
stant but depends on the outcome of the preced-
ing event.
W

Section 4.2   Counting	
259
Exercises 4.2
	
1.	A frozen yogurt shop allows you to choose one flavor (vanilla, strawberry, lemon, cherry, or peach), 
one topping (chocolate shavings, crushed toffee, or crushed peanut brittle), and one condiment (whipped 
cream or shredded coconut). How many different desserts are possible?
	
2.	In Exercise 1, how many dessert choices do you have if you are allergic to strawberries and chocolate?
	
3.	A video game is begun by making selections from each of 3 menus. The first menu (number of players) 
has 4 selections, the second menu (level of play) has 8, and the third menu (speed) has 6. In how many 
configurations can the game be played?
	
4.	A multiple choice exam has 20 questions each with 4 possible answers and 10 additional questions each 
with 5 possible answers. How many different answer sheets are possible?
	
5.	A user’s password to access a computer system consists of 3 letters followed by 2 digits. How many dif-
ferent passwords are possible?
	
6.	On the computer system of Exercise 5, how many passwords are possible if uppercase and lowercase let-
ters can be distinguished?
	
7.	A telephone conference call is being placed from Central City to Booneville by way of Cloverdale. There 
are 45 trunk lines from Central City to Cloverdale and 13 from Cloverdale to Booneville. How many dif-
ferent ways can the call be placed?
	
8.	A, B, C, and D are nodes on a computer network. There are 2 paths between A and C, 2 between B and 
D, 3 between A and B, and 4 between C and D. Along how many routes can a message from A to D 
be sent?
	
9.	How many nine-digit Social Security numbers are possible?
	 10.	An apartment building purchases a new lock system for its 175 units. A lock is opened by punching in a 
two-digit code. Has the apartment management made a wise purchase?
	 11.	A palindrome is a string of characters that reads the same forward and backward. How many five-letter 
English language palindromes are possible?
	 12.	How many three-digit numbers less than 600 can be made using the digits 8, 6, 4, and 2?
	 13.	A binary logical connective can be defined by giving its truth table. How many different binary logical 
connectives are there?
	 14.	Three seats on the county council are to be filled, each with someone from a different party. There are 4 
candidates running from the Concerned Environmentalist party, 3 from the Limited Development party, 
and 2 from the Friends of the Spotted Newt party. In how many ways can the seats be filled?
	 15.	In the original BASIC programming language, an identifier must be either a single letter or a letter  
followed by a single digit. How many identifiers are possible?
	 16.	A president and vice-president must be chosen for the executive committee of an organization. There are 
17 volunteers from the Eastern Division and 24 volunteers from the Western Division. If both officers 
must come from the same division, in how many ways can the officers be selected?
	 17.	A dinner special allows you to select from 5 appetizers, 3 salads, 4 entrees, and 3 beverages. How many 
different dinners are there?
	 18.	In Exercise 17, how many different dinners are there if you may have an appetizer or a salad but not both?
	 19.	A new car can be ordered with a choice of 10 exterior colors; 7 interior colors; automatic or three-speed 
or five-speed transmission; with or without air conditioning; with or without power steering; and with or 
without the option package that contains the power door lock and the rear-window defroster. How many 
different cars can be ordered?
	 20.	In Exercise 19, how many different cars can be ordered if the option package comes only on a car with an 
automatic transmission?

260	
Sets, Combinatorics, and Probability 
	 21.	In one state, automobile license plates must have two digits (no leading zeros) followed by one letter 
followed by a string of two to four digits (leading zeros are allowed). How many different plates are 
­possible?
	 22.	A Hawaiian favorite fast food is the “loco moco,” invented at a Hilo restaurant. It consists of a bed of rice 
under a meat patty with egg on top, the whole thing smothered in brown gravy. The rice can be white or 
brown, the egg can be fried, scrambled, or poached, and the meat can be hamburger, Spam, ­Portuguese sau-
sage, bacon, turkey, hot dog, salmon, or mahi. How many different loco mocos can be ordered?
	 23.	A customer at a fast-food restaurant can order a hamburger with or without mustard, ketchup, pickle, 
or onion; a fish sandwich with or without lettuce, tomato, or tartar sauce; and a choice of 3 kinds of soft 
drinks or 2 kinds of milk shakes. How many different orders are possible if a customer can order at most 
1 hamburger, 1 fish sandwich, and 1 beverage but can order less?
	 24.	How many unique ways are there to stack two 2 × 4 Lego bricks of the same color? Two stacks that look 
the same if you merely rotate them are considered to be the same arrangement. Here is one such stack, the 
original on top and the same stack after rotating 180°.
	 25.	What is the value of Count after the following pseudocode has been executed?
Count = 0
for i = 1 to 5 do 
for Letter = ‘A’ to ‘C’ do
Count = Count + 1
end for
end for
	 26.	What is the value of Result after the following pseudocode has been executed?
Result = 0
for Index = 20 down to 10 do
for Inner = 5 to 10 do
Result = Result + 2
end for
end for
Exercises 27–32 concern the set of three-digit integers (numbers between 100 and 999 inclusive).
	 27.	How many are divisible by 5?
	 28.	How many are divisible by 4?
	 29.	How many are not divisible by 5?
	 30.	How many are divisible by 4 or 5?
	 31.	How many are divisible by 4 and 5?
	 32.	How many are divisible by neither 4 nor 5?

Section 4.2   Counting	
261
Exercises 33–42 concern the set of binary strings of length 8 (each character is either the digit 0 or the digit 1).
	 33.	How many such strings are there?
	 34.	How many begin and end with 0?
	 35.	How many begin or end with 0?
	 36.	How many have 1 as the second digit?
	 37.	How many begin with 111?
	 38.	How many contain exactly one 0?
	 39.	How many begin with 10 or have a 0 as the third digit?
	 40.	How many are palindromes? (See Exercise 11.)
	 41.	How many contain exactly seven 1s?
	 42.	How many contain two or more 0s?
In Exercises 43–48, 2 dice are rolled, 1 black and 1 white.
	 43.	How many different rolls are possible? (Note that a 4-black, 1-white result and a 1-black, 4-white result 
are two different outcomes.)
	 44.	How many rolls result in “snake eyes” (both dice showing 1)?
	 45.	How many rolls result in doubles (both dice showing the same value)?
	 46.	How many rolls result in a total of 7 or 11?
	 47.	How many rolls occur in which neither die shows the value 4?
	 48.	How many rolls occur in which the value on the white die is greater than the value on the black die?
In Exercises 49–54, a customer is ordering a new desktop computer system. The choices are 21-inch, 23-inch, 
or 24-inch monitor (optional); 1 TB or 2 TB hard drive; 6 GB or 8 GB of RAM; 16X DVD or Blu-ray disk 
optical drive; Intel, AMD, or NVIDIA video card; inkjet, laser, or laser color printer; 1-, 2-, or 3-year warranty.
 49 How many different machine configurations are possible?
	 50.	How many different machines can be ordered with a 2 TB hard drive?
	 51.	How many different machines can be ordered with a 21-inch monitor and an inkjet printer?
	 52.	How many different machines can be ordered if the customer decides not to get a new monitor?
	 53.	How many different machines can be ordered with a 21-inch monitor, a 1 TB hard drive, and an inkjet 
printer?
	 54.	How many different machines can be ordered if the customer does not want a 3-year warranty?
Exercises 55–58 refer to the Konami code, a sequence of 10 keystrokes using 6 different characters:  
c c T  T d S d S B A. This code was inadvertently left by the developer in the first release of a video game; 
when entered on the video game console as the title screen is open, it surreptitiously adds assets to the player’s 
on-screen avatar. This code or versions of it have been retained in many video games.
	 55.	How many 10-character codes can be created using these 6 characters?
	 56.	How many 10-character codes can be created if the BA sequence must be the last 2 characters?
	 57.	How many 10-character codes can be created if only 2 down-arrow characters can be used and they must 
be paired together wherever they appear?
	 58.	How many 10-character codes can be created if only the arrow characters are used?

262	
Sets, Combinatorics, and Probability 
In Exercises 59–68, a hand consists of 1 card drawn from a standard 52-card deck with flowers on the back and 
1 card drawn from a standard 52-card deck with birds on the back. A standard deck has 13 cards from each of 
4 suits (clubs, diamonds, hearts, spades). The 13 cards have face value 2 through 10, jack, queen, king, or ace. 
Each face value is a “kind” of card. The jack, queen, and king are “face cards.”
	 59.	How many different hands are possible? (Note that a flower-ace-of-spades, bird-queen-of-hearts and a 
flower-queen-of-hearts, bird-ace-of-spades are two different outcomes.)
	 60.	How many hands consist of a pair of aces?
	 61.	How many hands contain all face cards?
	 62.	How many hands contain exactly 1 king?
	 63.	How many hands consist of two of a kind (2 aces, 2 jacks, and so on)?
	 64.	How many hands have a face value of 5 (aces count as 1, face cards count as 10)?
	 65.	How many hands have a face value of less than 5 (aces count as 1, face cards count as 10)?
	 66.	How many hands do not contain any face cards?
	 67.	How many hands contain at least 1 face card?
	 68.	How many hands contain at least 1 king?
	 69.	Draw a decision tree to find the number of binary strings of length 4 that do not have consecutive 0s. 
(Compare your answer with the one for Exercise 41 of Section 3.2.)
	 70.	Draw a decision tree (use teams A and B) to find the number of ways the NBA playoffs can happen, where 
the winner is the first team to win 4 out of 7.
	 71.	Voting on a certain issue is conducted by having everyone put a red, blue, or green slip of paper into a hat. 
Then the slips are pulled out one at a time. The first color to receive two votes wins. Draw a decision tree 
to find the number of ways in which the balloting can occur.
	 72.	In Example 39, prove the following facts, where C(n) = the total number of nodes in the decision tree at 
level n, H(n) = the total number of nodes at level n resulting from an H toss, T(n) = the total number of 
nodes at level n resulting from a T toss.1
	
a.	 C(n) = H(n) + T(n)
	
b.	H(n) = T(n − 1)
	
c.	 T(n) = H(n − 1) + T(n − 1)
	
d.	H(n) = H(n − 2) + T(n − 2)
	
e.	 C(n) = C(n − 2) + C(n − 1) for n ≥ 3
	
f.	 C(n) = F(n + 1) where F(n) is the nth Fibonacci number
	 73.	Use mathematical induction to extend the multiplication principle to a sequence of m events for any inte-
ger m, m ≥ 2.
	 74.	Use mathematical induction to extend the addition principle to m disjoint events for any integer m, m ≥ 2.
	 75.	Consider the product of n factors, x1 # x2 cxn. Such an expression can be fully parenthesized to indicate 
the order of multiplication in a number of ways. For example, if n = 4, there are five ways to parenthesize:
x1 # (x2 # (x3 # x4))
x1 # ((x2 # x3) # x4)
(x1 # x2) # (x3 # x4)
(x1 # (x2 # x3)) # x4
((x1 # x2) # x3) # x4
1This problem was suggested by Mr. Tracy Castile, a former University of Hawaii at Hilo student.

Section 4.3   Principle of Inclusion and Exclusion; Pigeonhole Principle 	
263
	
a.	 Write a recurrence relation for P(n), the number of ways to parenthesize a product of n factors, n ≥ 1. 
Assume that P(1) = 1. (Hint: Note that for n > 2, the last multiplication to be performed can occur in 
any of n − 1 positions.)
	
b.	Prove that
P(n) = C(n − 1)
	
	
where C(0), C(1), … is the sequence of Catalan numbers (see Exercise 38 of Section 3.1).
	 76.	A simple closed convex polygon consists of n points in the plane joined in pairs by n line segments; each 
point is the endpoint of exactly 2 line segments, and any line connecting 2 nonadjacent points lies wholly 
within the polygon.
	
a.	 Show that an (n + 2)-sided simple closed convex polygon can be triangulated  (divided into ­triangular 
regions) using n − 1 lines. (The figures show two different triangulations of a 6-sided polygon,  
where n = 4).
	
	
(Hint: Use a pair of straight lines to shave off 2 corners; consider the cases where n is even and the cases 
where n is odd.)
	
b.	Write a recurrence relation for T(n), the number of different triangulations of an (n + 2)-sided polygon. 
Assume that T(0) = 1. (Hint: Fix one edge of the polygon as the base of a triangle whose tip rotates 
around the polygon, as shown. Use the sides of the triangle to divide the polygon into 2 polygonal sec-
tions with (k + 1) sides and (n − k + 2) sides.)
k = 1
k = 2
k = 3
k = 4
Trivial
2-sided
polygon
Trivial
2-sided
polygon
	
c.	 Prove that T(n) = C(n), where C(0), C(1), … is the sequence of Catalan numbers (see Exercise 38 of 
Section 3.1).
	
S e c t i o n  4 . 3 	 Principle of Inclusion and Exclusion;  
Pigeonhole Principle
In this section we discuss two more counting principles that can be used to solve 
combinatorics problems.

264	
Sets, Combinatorics, and Probability 
Principle of Inclusion and Exclusion
To develop the principle of inclusion and exclusion, we first note that if A and B 
are any subsets of a universal set S, then A − B, B − A, and A d B are mutually 
disjoint sets (see Figure 4.6). For example, if x [ A − B, then x o B, therefore 
x o B − A and x o A d B.
$
%
6
$G%
%±$
$±%
Also, something can be said about the union of these three sets.
Figure 4.6
From Example 31 (extended to three disjoint finite sets),
	
0 (A − B) c (B − A) c (A d B) 0 = 0 A − B 0 + 0 B − A 0 + 0 A d B 0	
(1)
From Example 32,
0 A − B 0 = 0 A 0 − 0 A d B 0
and
0 B − A 0 = 0 B 0 − 0 A d B 0
Using these expressions in Equation (1), along with the result of Practice 26, we get
0 A c B 0 = 0 A 0 − 0 A d B 0 + 0 B 0 − 0 A d B 0 + 0 A d B 0
or
	
0 A c B 0 = 0 A 0 + 0 B 0 − 0 A d B 0	
(2)
Equation (2) is the two-set version of the principle of inclusion and exclusion. 
The name derives from the fact that when counting the number of elements in 
the union of A and B, we must “include” (count) the number of elements in A and 
the number of elements in B, but we must “exclude” (subtract) those elements in  
A d B to avoid counting them twice.
■
Practice 26	 What is another name for the set (A − B) c (B − A) c (A d B)?

Section 4.3   Principle of Inclusion and Exclusion; Pigeonhole Principle 	
265
Practice 27	 How does Equation (2) relate to Example 31 of Section 4.2?
■
	
Example 40	
A pollster queries 35 voters, all of whom support referendum 1, referendum 2, or 
both, and finds that 14 voters support referendum 1 and 26 support referendum 2. 
How many voters support both?
If we let A be the set of voters supporting referendum 1 and B be the set of 
voters supporting referendum 2, then we know that
	
0 A c B 0 = 35	
0 A 0 = 14	
0 B 0 = 26
From Equation (2),
	
0 A c B 0 = 0 A 0 + 0 B 0 − 0 A d B 0
	
35 = 14 + 26 − 0 A d B 0
	
0 A d B 0 = 14 + 26 − 35 = 5
so 5 voters support both.
Equation (2) can easily be extended to three sets, as follows:
0 A c B c C 0 = 0 A c (B c C ) 0
	
= 0 A 0 + 0 B c C 0 − 0 A d (B c C ) 0
	
= 0 A 0 + 0 B 0 + 0 C 0 − 0 B d C 0 − 0 (A d B) c (A d C ) 0
	
= 0 A 0 + 0 B 0 + 0 C 0 − 0 B d C 0 − ( 0 A d B 0 + 0 A d C 0 − 0 A d B d C 0 )
	
= 0 A 0 + 0 B 0 + 0 C 0 − 0 A d B 0 − 0 A d C 0 − 0 B d C 0 + 0 A d B d C 0
Therefore the three-set version of the principle of inclusion and exclusion is
                  0 A c B c C 0 = 0 A 0 + 0 B 0 + 0 C 0 − 0 A d B 0 − 0 A d C 0 − 0 B d C 0 + 0 A d B d C 0	
(3)
Practice 28	 Justify each of the equalities used in deriving Equation (3).
■
In addition to the formal derivation of Equation (3) that we just did, a sort of 
geometric argument for 0 A c B c C 0 is suggested by Figure 4.7 on the next page. 
When we add 0 A 0 + 0 B 0 + 0 C 0, we are counting each of 0 A d B 0, 0 A d C 0, and 0 B 
d C 0 twice, so we must throw each of them away once. When we add 0 A 0 + 0 B 0 
+ 0 C 0, we are counting 0 A d B d C0 three times, but in subtracting 0 A d B 0, 
0 A d C 0, 0 B d C 0 we have thrown it away three times, so we must add it back once.

266	
Sets, Combinatorics, and Probability 
A
B
C
S
Figure 4.7
	
Example 41	
A group of students plans to order pizza. If 13 will eat sausage topping, 10 will eat 
pepperoni, 12 will eat extra cheese, 4 will eat both sausage and pepperoni, 5 will 
eat both pepperoni and extra cheese, 7 will eat both sausage and extra cheese, and 
3 will eat all three toppings, how many students are in the group?
Let
	
A = {students who will eat sausage}
	
B = {students who will eat pepperoni}
	
C = {students who will eat extra cheese}
Then 0 A 0 = 13, 0 B 0 = 10, 0 C 0 = 12, 0 A d B 0 = 4, 0 B d C 0 = 5, 0 A d C 0 = 7, and  
0A d B d C 0 = 3. From Equation (3),
0 A c B c C 0 = 13 + 10 + 12 − 4 − 5 − 7 + 3 = 22
We can also solve this problem by filling in all the pieces in a Venn diagram. 
Working from the middle outward, we know there are 3 people in 0 A d B d C 0 
­(Figure 4.8a). We also know the number in each of 0 A d B 0, 0 B d C 0, and 0 A d C 0, 
so with a little subtraction we can fill in more pieces (Figure 4.8b). We also know 
the size of A, B, and C, allowing us to complete the picture (Figure 4.8c). Now the 
total number of students, 22, is obtained by adding up all the numbers.
A
B
C
3
A
B
C
3
1
4
2
A
B
C
3
3
1
4
2
4
5
(a)
(b)
(c)
Although we are about to generalize Equation (3) to an arbitrary number of sets, 
the Venn diagram approach gets too complicated to draw with more than three 
sets.
Figure 4.8

Section 4.3   Principle of Inclusion and Exclusion; Pigeonhole Principle 	
267
	
Example 42	
A produce stand sells only broccoli, carrots, and okra. One day the stand served 
207 people. If 114 people purchased broccoli, 152 purchased carrots, 25 purchased 
okra, 64 purchased broccoli and carrots, 12 purchased carrots and okra, and 9 pur-
chased all three, how many people purchased broccoli and okra?
Let
	
A = {people who purchased broccoli}
	
B = {people who purchased carrots}
	
C = {people who purchased okra}
Then 0 A c B c C 0 = 207, 0 A 0 = 114, 0 B 0 = 152, 0 C 0 = 25, 0 A d B 0 = 64, 0 B d C 0 = 12,  
and 0 A d B d C 0 = 9. From Equation (3),
	0 A c B c C 0 = 0 A 0 + 0 B 0 + 0 C 0 − 0 A d B 0 − 0 A d C 0 − 0 B d C 0 + 0 A d B d C 0
	
207 = 114 + 152 + 25 − 64 − 0 A d C 0 − 12 + 9
	
0 A d C 0 = 114 + 152 + 25 − 64 − 12 + 9 − 207 = 17
In Equation (2), we add the number of elements in the single sets and subtract 
the number of elements in the intersection of two sets. In Equation (3), we add the 
number of elements in the single sets, subtract the number of elements in the in-
tersection of two sets, and add the number of elements in the intersection of three 
sets. This seems to suggest a pattern: If we have n sets, we should add the number 
of elements in the single sets, subtract the number of elements in the intersection 
of two sets, add the number of elements in the intersection of three sets, subtract 
the number of elements in the intersection of four sets, and so on. This leads us to 
the general form of the principle of inclusion and exclusion:
In Equation (4) the notation
∙
1≤i<j≤n
 0 Ai d Aj 0
for example, says to add together the number of elements in all the intersections of 
the form Ai d Aj where i and j can take on any values between 1 and n as long as i < j. 
	
Principle	
Of Inclusion and Exclusion
Given the finite sets A1, c, An, n ≥ 2, then
0 A1 c c c An 0 = ∙
1≤i≤n
 0 Ai 0 − 
∙
1≤i<j≤n
 0 Ai d Aj 0
+
∙
1≤i<j<k≤n
 0 Ai d Aj d Ak 0
	
−c+ (−1)n+1 0 A1 d cd An 0	
(4)

268	
Sets, Combinatorics, and Probability 
For n = 3, this gives 0 A1 d A2 0 (i = 1, j = 2), 0 A1 d A3 0 (i = 1, j = 3), and 0 A2 d A3 0 
(i = 2, j = 3). This agrees with Equation (3), where A1 = A, A2 = B, and A3 = C.
To prove the general form of the principle of inclusion and exclusion, we use 
mathematical induction. Although the idea of the proof is straightforward, the 
notation is rather messy. The base case, n = 2, is just Equation (2). We assume 
that Equation (4) is true for n = k and show that it is true for n = k + 1. We write
	
0 A1 c c c Ak + 1 0
	
= 0 (A1 c c c Ak ) c Ak + 1 0
	
= 0 (A1 c c c Ak ) 0 + 0 Ak + 1 0
	
− 0 (A1 c c c Ak ) d Ak + 1 0	
(by Equation (2))
	
= ∙
1≤i≤k
 0 Ai 0 − 
∙
1≤i<j≤k
 0 Ai d Aj 0 +
∙
1≤i<j<m≤k
 0 Ai d Aj d Am 0 
	
−c+ (−1)k+1 0 A1 d c d Ak  0 + 0 Ak + 1 0
	
 − 0 (A1 d Ak + 1) c c c (Ak d Ak + 1) 0
(by the inductive hypothesis and the distributive property)
= 
∙
1≤i≤k+1
 0 Ai 0 − 
∙
1≤i<j≤k
 0 Ai d Aj 0 +
∙
1≤i<j<m≤k
 0 Ai d Aj d Am 0 
−c+ (−1)k+1 0 A1 d cd Ak  0
 − a ∙
1≤i≤k
 0 Ai d Ak + 1 0 − 
∙
1≤i<j≤k
 0 Ai d Aj d Ak + 1 0 + c+
+ (−1)k 
∙
1≤i<j< c<m≤k
 0 (Ai d Ak + 1) d (Aj d Ak + 1) d c d (Am d Ak + 1) 0
+ (−1)k+1 0 A1 d cd Ak + 1 0b
(by combining terms ➀ from above and using the inductive hypothesis on the k sets  
A1 d Ak + 1, A2 d Ak + 1, … , Ak d Ak + 1)
= 
∙
1≤i≤k+1
 0 Ai 0 − 
∙
1≤i<j≤k +1
 0 Ai d Aj 0 +
∙
1≤i<j<m≤k +1
 0 Ai d Aj d Am 0 
−c−(−1)k+1 0 A1 d cd Ak + 1 0
(by combining like-numbered terms from above)
= 
∙
1≤i≤k+1
 0 Ai 0 − 
∙
1≤i<j≤k +1
 0 Ai d Aj 0 +
∙
1≤i<j<m≤k +1
 0 Ai d Aj d Am 0 
−c+ (−1)k+2 0 A1 d cd Ak + 1 0
This completes the proof of Equation (4). A different proof of the principle of in-
clusion and exclusion can be found in Exercise 23 of Section 4.5.
➀
➀
➁
➂
➁
➂
➃
('''''''''')''''''''''*
k − 1 terms
➃

Section 4.3   Principle of Inclusion and Exclusion; Pigeonhole Principle 	
269
Pigeonhole Principle
The pigeonhole principle acquired its quaint name from the following idea: If 
more than k pigeons fly into k pigeonholes, then at least 1 hole will end up with 
more than 1 pigeon. Although this seems immediately obvious, we can belabor the 
point. Suppose each of the k pigeonholes contains at most 1 pigeon. Then there are 
at most k pigeons, not the more-than-k pigeons that supposedly flew in.
Now we’ll state the pigeonhole principle in a less picturesque way.
	
Principle	
Pigeonhole Principle
If more than k items are placed into k bins, then at least 1 bin contains more than 
1 item.
By cleverly choosing items and bins, a number of interesting counting prob-
lems can be solved (see Example 7 of Chapter 2).
	
Example 43	
How many people must be in a room to guarantee that 2 people have last names 
that begin with the same initial?
There are 26 letters of the alphabet (bins). If there are 27 people, then there are 
27 initials (items) to put into the 26 bins, so at least 1 bin will contain more than 
1 last initial.
■
Practice 29	 How many times must a single die be rolled in order to guarantee getting the same value 
twice?
	
Example 44	
Prove that if 51 positive integers between 1 and 100 are chosen, then one of them 
must divide another.
Let the integers be n1, …, n51. Each integer ni ≥ 2 can be written as a product 
of prime numbers (fundamental theorem of arithmetic), every prime number except 
2 is odd, and the product of odd numbers is odd. Therefore for each i, ni = 2kibi, 
where ki ≥ 0 and bi is an odd number. Furthermore, 1 ≤ bi ≤ 99, and there are 50 
odd integers between 1 and 99 inclusive, but there are 51 b values. By the pigeon-
hole principle, bi = bj for some i and j, so ni = 2kibi and nj = 2kjbi. If ki ≤ k j, then ni 
divides nj; otherwise, nj divides ni.
S e c t i o n  4 . 3 	
Review
Techniques
•	 Use the principle of inclusion and exclusion to find 
the number of elements in the union of sets.
•	 Use the pigeonhole principle to find the ­minimum 
number of elements to guarantee two with a  
duplicate property.
Main Idea
•	 The principle of inclusion and exclusion and the 
piegeonhole principle are additional counting 
mechanisms for sets.
W

270	
Sets, Combinatorics, and Probability 
Exercises 4.3
	
1.	All the guests at a dinner party drink coffee or tea; 13 guests drink coffee, 10 drink tea, and 4 drink both 
coffee and tea. How many people are guests at the dinner party?
	
2.	In a group of 42 tourists, everyone speaks English or French; there are 35 English speakers and 18 French 
speakers. How many speak both English and French?
	
3.	After serving 137 customers, a cafeteria notes at the end of the day that 56 orders of green beans were 
sold, 38 orders of beets were sold, and 17 customers purchased both green beans and beets. How many 
customers bought neither beans nor beets?
	
4.	A bike show will be held for mountain bikes and road bikes. Of the 24 people who register for the show, 17 
will bring road bikes and 5 will bring both road bikes and mountain bikes. How many will bring mountain 
bikes?
	
5.	Quality control in a factory pulls 40 parts with paint, packaging, or electronics defects from an assembly 
line. Of these, 28 had a paint defect, 17 had a packaging defect, 13 had an electronics defect, 6 had both 
paint and packaging defects, 7 had both packaging and electronics defects, and 10 had both paint and 
electronics defects. Did any part have all three types of defect?
	
6.	In a group of 24 people who like rock, country, and classical music, 14 like rock, 17 like classical, 11 like 
both rock and country, 9 like rock and classical, 13 like country and classical, and 8 like rock, country, and 
classical. How many like country?
	
7.	Nineteen different mouthwash products make the following claims: 12 claim to freshen breath, 10 claim 
to prevent gingivitis, 11 claim to reduce plaque, 6 claim to both freshen breath and reduce plaque, 5 claim 
to both prevent gingivitis and freshen breath, and 5 claim to both prevent gingivitis and reduce plaque.
	
a.	 How many products make all three claims?
	
b.	How many products claim to freshen breath but do not claim to reduce plaque?
	
8.	From the 83 students who want to enroll in CS 320, 32 have completed CS 120, 27 have completed  
CS 180, and 35 have completed CS 215. Of these, 7 have completed both CS 120 and CS 180, 16 have 
completed CS 180 and CS 215, and 3 have completed CS 120 and CS 215. Two students have completed 
all three courses. The prerequisite for CS 320 is completion of one of CS 120, CS 180, or CS 215. How 
many students are not eligible to enroll?
	
9.	A survey of 150 college students reveals that 83 own automobiles, 97 own bikes, 28 own motorcycles, 53 
own a car and a bike, 14 own a car and a motorcycle, 7 own a bike and a motorcycle, and 2 own all three.
	
a.	 How many students own a bike and nothing else? 
	
b.	How many students do not own any of the three?
	 10.	Among a bank’s 214 customers with checking or savings accounts, 189 have checking accounts, 73 have 
regular savings accounts, 114 have money market savings accounts, and 69 have both checking and regu-
lar savings accounts. No customer is allowed to have both regular savings and money market savings 
accounts.
	
a.	 How many customers have both checking and money market savings accounts?
	
b.	How many customers have a checking account but no savings account?
	 11.	At the beginning of this chapter you surveyed the 87 computer users who subscribe to your electronic 
newsletter in preparation for the release of your new software product.
The results of your survey reveal that of the 87 subscribers, 68 have a Windows-based system available 
to them, 34 have a Linux system available, and 30 have access to a Mac. In addition, 19 have access 
to both Windows and Linux systems, 11 have access to both Linux systems and Macs, and 23 can use 
both Macs and Windows.

Section 4.3   Principle of Inclusion and Exclusion; Pigeonhole Principle 	
271
	
	Use the principle of inclusion and exclusion to determine how many subscribers have access to all three 
types of systems.
	 12. 	You are developing a new bath soap, and you hire a public opinion survey group to do some market re-
search for you. The group claims that in its survey of 450 consumers, the following criteria were named 
as important factors in purchasing bath soap:
Odor	
425
Lathering ease	
397
Natural ingredients	
340
Odor and lathering ease	
284
Odor and natural ingredients	
315
Lathering ease and natural ingredients	
219
All three factors	
147
	
	Should you have confidence in these results? Why or why not?
	 13.	a.	 How many integers n, 1 ≤ n ≤ 100, are multiples of either 2 or 5?
	
b.	How many integers n, 1 ≤ n ≤ 100, are not multiples of either 2 or 5?
	 14.	How many integers n, 1 ≤ n ≤ 1000, are not multiples of either 3 or 7?
	 15.	a.	 Write the expression for 0 A c B c C c D 0 from Equation (4).
	
b.	Write an expression for the number of terms in the expansion of 0 A1 c cc An 0 given by Equation (4).
	 16.	Patrons of a local bookstore can sign up for advance notification of new book arrivals in genres of interest. 
In the first month of this service, 32 sign up for mysteries, 34 for spy novels, 18 for westerns, and 41 for 
science fiction. Of these, 17 sign for both mysteries and spy novels, 8 for both mysteries and westerns, 
19 for mysteries and science fiction, 5 for spy novels and westerns, 20 for spy novels and science fiction, 
and 12 for westerns and science fiction. In addition, 2 sign up for mysteries, spy novels and westerns, 11 
for mysteries, spy novels and science fiction, 6 for mysteries, westerns, and science fiction, and 5 for spy 
novels, westerns, and science fiction. Finally, 2 people sign up for all four categories. How many people 
signed up for service in the first month?
	 17.	How many cards must be drawn from a standard 52-card deck to guarantee 2 cards of the same suit?
	 18.	How many cards must be drawn from a standard 52-card deck to guarantee a black card?
	 19.	If 12 cards are drawn from a standard deck, must at least 2 of them be of the same denomination (type)?
	 20.	How many cards must be drawn from a standard 52-card deck to guarantee 2 queens?
	 21.	A computerized dating service has a list of 50 men and 50 women. Names are selected at random; how 
many names must be chosen to guarantee one name of each gender?
	 22.	A computerized housing service has a list of 50 men and 50 women. Names are selected at random; how 
many names must be chosen to guarantee two names of the same gender?
	 23.	How many people must be in a group to guarantee that 2 people in the group have the same birthday (don’t 
forget leap year)?
	 24.	In a group of 25 people, must there be at least 3 who were born in the same month?
	 25.	Prove that if four numbers are chosen from the set {1, 2, 3, 4, 5, 6}, at least one pair must add up to 7. 
(Hint: Find all the pairs of numbers from the set that add to 7.)
	 26.	How many numbers must be selected from the set {2, 4, 6, 8, 10, 12, 14, 16, 18, 20} to guarantee that at 
least one pair adds up to 22? (See the hint for Exercise 25).
	 27.	Let n be a positive number. Show that in any set of n + 1 numbers, there are at least two with the same 
remainder when divided by n.

272	
Sets, Combinatorics, and Probability 
	
S e c t i o n  4 . 4 	 Permutations and Combinations
Permutations
Example 26 in Section 4.2 discussed the problem of counting all possibilities for 
the last four digits of a telephone number with no repeated digits. In this problem, 
the number 1259 is not the same as the number 2951 because the order of the 
four digits is important. An ordered arrangement of objects is called a permuta-
tion. Each of these numbers is a permutation of 4 distinct objects chosen from 
a set of 10 distinct objects (the digits). How many such permutations are there? 
The answer, found by using the multiplication principle, is 10 # 9 # 8 # 7—there are  
10 choices for the first digit, then 9 for the next digit because repetitions are not al-
lowed, 8 for the next digit, and 7 for the fourth digit. The number of permutations 
of r distinct objects chosen from n distinct objects is denoted by P(n, r). Therefore 
the solution to the problem of the four-digit number without repeated digits can be 
expressed as P(10, 4).
A formula for P(n, r) can be written using the factorial function. For a positive 
integer n, n factorial is defined as n(n − 1)(n − 2) c1 and denoted by n!; also, 0! 
is defined to have the value 1. From the definition of n!, we see that
n! = n(n −1)!
and that for r < n,
n!
(n −r)! = n(n −1) c (n −r + 1)(n −r)!
(n −r)!
 = n(n −1) c (n −r + 1)
Using the factorial function,
P(10, 4) = 10 # 9 # 8 # 7
 = 10 # 9 # 8 # 7 # 6 # 5 # 4 # 3 # 2 # 1
6 # 5 # 4 # 3 # 2 # 1
= 10!
6! =
10!
(10 −4)!
In general, P(n, r) is given by the formula
P(n, r) =
n!
(n −r)! for 0 ≤r ≤n
	
Example 45	
The value of P(7, 3) is
7!
(7 −3)! = 7!
4! = 7 # 6 # 5 # 4 # 3 # 2 # 1
4 # 3 # 2 # 1
= 7 # 6 # 5 = 210
	
Example 46	
Three somewhat special cases that can arise when computing P(n, r) are the two 
“boundary conditions”  P(n, 0) and  P(n, n), and also  P(n, 1). According to the  
formula,

Section 4.4   Permutations and Combinations	
273
P(n, 0) =
n!
(n −0)! = n!
n! = 1
This formula can be interpreted as saying that there is only one ordered arrange-
ment of zero objects—the empty set.
P(n, 1) =
n!
(n −1)! = n
This formula reflects the fact that there are n ordered arrangements of 1 object. 
(Each arrangement consists of the 1 object, so this merely counts how many ways 
to get the 1 object.)
P(n, n) =
n!
(n −n)! = n!
0! = n!
This formula states that there are n! ordered arrangements of n distinct ­objects, 
which merely reflects the multiplication principle—n choices for the first 
­object, n − 1 choices for the second object, and so on, with 1 choice for the nth  
object.
	
EXAMPLE 47	
The number of permutations of 3 objects, say a, b, and c, is given by 
P(3, 3) = 3! = 3 # 2 # 1 = 6. The 6 permutations of a, b, and c are
abc, acb, bac, bca, cab, cba
Note that we could have solved Example 48 just by using the multiplication 
principle—there are 8 choices for the first letter, 7 for the second, and 6 for the 
third, so the answer is 8 # 7 # 6 = 336. P(n, r) simply gives us a new way to think 
about the problem, as well as a compact notation.
	
Example 48	
How many three-letter words (not necessarily meaningful) can be formed from the 
word “compiler” if no letters can be repeated? Here the arrangement of letters mat-
ters, and we want to know the number of permutations of 3 distinct objects taken 
from 8 objects. The answer is P(8, 3) = 8!/5! = 336.
	
Example 49	
Ten athletes compete in an Olympic event. Gold, silver, and bronze medals are 
awarded; in how many ways can the awards be made?
This problem is essentially the same as the one in Example 48. Order mat-
ters; given 3 winners A, B, and C, the arrangement A−gold, B−silver, C−bronze 
is different than the arrangement C−gold, A−silver, B−bronze. So we want the 
number of ordered arrangements of 3 objects from a pool of 10, or P(10, 3). Using 
the formula for P(n, r), P(10, 3) = 10!/7! = 10 # 9 # 8 = 720.

274	
Sets, Combinatorics, and Probability 
Practice 30	 In how many ways can a president and vice-president be selected from a group of  
20 people?
■
Practice 31	 In how many ways can 6 people be seated in a row of 6 chairs?
■
Counting problems can have other counting problems as subtasks.
Combinations
Sometimes we want to select r objects from a set of n objects, but we don’t care 
how they are arranged. Then we are counting the number of combinations of r 
distinct objects chosen from n distinct objects, denoted by C(n, r). For each such  
combination, there are r! ways to permute the r chosen objects. By the ­multipli- 
cation principle, the number of permutations of r distinct objects chosen from 
n objects is the product of the number of ways to choose the objects, C(n, r),  
multiplied by the number of ways to arrange the objects chosen, r! Thus,
C(n, r) # r! = P(n, r)
or
C(n, r) = P(n, r)
r!
=
n!
r!(n −r)! for 0 ≤r ≤n
Other notations for C(n, r) are
nCr,     C n
r,     a n
rb
	
Example 50	
A library has 4 books on operating systems, 7 on programming, and 3 on data 
structures. Let’s see how many ways these books can be arranged on a shelf, given 
that all books on the same subject must be together.
We can think of this problem as a sequence of subtasks. First we consider 
the subtask of arranging the 3 subjects. There are 3! outcomes to this ­subtask, 
that is, 3! different orderings of subject matter. The next subtasks are ­arranging 
the books on operating systems (4! outcomes), then arranging the books on 
programming (7! outcomes), and finally arranging the books on data structures  
(3! outcomes). Thus, by the multiplication principle, the final number of arrange-
ments of all the books is (3!)(4!)(7!)(3!) = 4,354,560.
	
Example 51	
The value of C(7, 3) is
7!
3!(7 −3)! = 7!
3!4! = 7 # 6 # 5 # 4 # 3 # 2 # 1
3 # 2 # 1 # 4 # 3 # 2 # 1
 = 7 # 6 # 5
3 # 2 # 1 = 7 # 5 = 35
From Example 45, the value of P(7, 3) is 210, and C(7, 3) # (3!) = 35(6) = 210 = 
P(7, 3).

Section 4.4   Permutations and Combinations	
275
(b)
(a)
C[n, r]
P[n, r]
n
r]
n
r]
Figure 4.9
	
Example 52	
The special cases for C(n, r) are C(n, 0), C(n, 1), and C(n, n). The formula for C(n, 0),
C(n, 0) =
n!
0!(n −0)! = 1
reflects the fact that there is only one way to choose zero objects from n objects: 
Choose the empty set.
C(n, 1) =
n!
1!(n −1)! = n
Here the formula indicates that there are n ways to select 1 object from n objects.
C(n, n) =
n!
n!(n −n)! = 1
Here we see that there is only one way to select n objects from n objects, and that 
is to choose all of the objects.
In the formula for C(n, r), suppose n is held fixed and r is increased. Then r! 
increases, which tends to make C(n, r) smaller, but (n − r)! decreases, which tends 
to make C(n, r) larger. For small values of r, the increase in r! is not as great as 
the decrease in (n − r)!, and so C(n, r) increases from 1 to n to larger values. At 
some point, however, the increase in r! overcomes the decrease in (n − r)!, and 
the values of C(n, r) decrease back down to 1 by the time r = n, as we calculated 
in Example 52. Figure 4.9a illustrates the rise and fall of the values of C(n, r) for a 
fixed n. For P(n, r), as n is held fixed and r is increased, n − r and therefore (n − r)! 
decreases, so P(n, r) increases. Values of P(n, r) for 0 ≤ r ≤ n thus increase from 
1 to n to n!, as we calculated in Example 46. See Figure 4.9b; note the difference 
in the vertical scale of Figures 4.9a and 4.9b.
	
Example 53	
How many 5-card poker hands are possible with a 52-card deck? Here order does 
not matter because we simply want to know which cards end up in the hand. We 
want the number of ways to choose 5 objects from a pool of 52, which is a combi-
nations problem. The answer is C(52, 5) = 52!/(5!47!) = 2,598,960.

276	
Sets, Combinatorics, and Probability 
Unlike earlier problems, the answer to Example 53 cannot easily be obtained 
by applying the multiplication principle. Thus, C(n, r) gives us a way to solve new 
problems.
	
Example 54	
Ten athletes compete in an Olympic event; 3 will be declared winners. How many 
sets of winners are possible?
Here, as opposed to Example 49, there is no order to the 3 winners, so we 
are simply choosing 3 objects out of 10. This is a combinations problem, not a 
permutations problem. The result is C(10, 3) = 10!/(3!7!) = 120. Notice that 
there are fewer ways to choose 3 winners (a combinations problem) than to 
award gold, silver, and bronze medals to 3 winners (a permutations problem— 
Example 49).
Remember that the distinction between permutations and combinations lies 
in whether the objects are to be merely selected or both selected and ordered. 
If ordering is important, the problem involves permutations; if ordering is not 
important, the problem involves combinations. For example, Practice 30 is a per-
mutations problem—2 people are to be selected and ordered, the first as president, 
the second as vice-president—whereas Practice 32 is a combinations problem— 
3 people are selected but not ordered.
In solving counting problems, C(n, r) can be used in conjunction with the 
multiplication principle or the addition principle.
Practice 32	 How many committees of 3 are possible from a group of 12 people?
■
REMINDER
In a counting problem, 
first ask yourself if order 
matters. If it does, it’s a 
permutations problem. If 
not, it’s a combinations 
problem.
	
Example 55	
A committee of 8 students is to be formed from a class consisting of 19 freshmen 
and 34 sophomores.
	
a.	 How many committees of 3 freshmen and 5 sophomores are possible?
	
b.	 How many committees with exactly 1 freshman are possible?
	
c.	 How many committees with at most 1 freshman are possible?
	
d.	 How many committees with at least 1 freshman are possible?
Because the ordering of the individuals chosen is not important, these are com­
binations problems.
For part (a), we have a sequence of two subtasks, selecting freshmen and  
selecting sophomores. The multiplication principle should be used. (Thinking of a 
sequence of subtasks may seem to imply ordering, but it just sets up the levels of 
the decision tree, the basis for the multiplication principle. There is no ordering of 
the students.) Because there are C(19, 3) ways to choose the freshmen and C(34, 5) 
ways to choose the sophomores, the answer is
C(19, 3) # C(34, 5) = 19!
3!16!
# 34!
5!29! = (969)(278,256)

Section 4.4   Permutations and Combinations	
277
For part (b), we again have a sequence of subtasks: selecting the single fresh-
man and then selecting the rest of the committee from among the sophomores. 
There are C(19, 1) ways to select the single freshman and C(34, 7) ways to select 
the remaining 7 members from the sophomores. By the multiplication principle, 
the answer is
C(19, 1) # C(34, 7) =
19!
1!(19 −1)!
#
34!
7!(34 −7)! = 19(5,379,616)
For part (c), we get at most 1 freshman by having exactly 1 freshman or by 
having 0 freshmen. Because these are disjoint events, we use the addition prin-
ciple. The number of ways to select exactly 1 freshman is the answer to part (b). 
The number of ways to select 0 freshmen is the same as the number of ways to 
select the entire 8-member committee from among the 34 sophomores, C(34, 8). 
Thus the answer is
C(19, 1) # C(34, 7) + C(34, 8) = some big number
We can attack part (d) in several ways. One way is to use the addition princi-
ple, thinking of the disjoint possibilities as exactly 1 freshman, exactly 2 freshmen, 
and so on, up to exactly 8 freshmen. We could compute each of these numbers and 
then add them. However, it is easier to do the problem by counting all the ways the 
committee of 8 can be selected from the total pool of 53 people and then eliminat-
ing (subtracting) the number of committees with 0 freshmen (all sophomores). 
Thus the answer is
C(53, 8) −C(34, 8)
REMINDER
“At least” counting prob-
lems are often best solved 
by subtraction.
The factorial function grows large quickly. A number like 100! cannot be 
computed on most calculators (or on most computers unless double−precision 
arithmetic is used), but expressions like
100!
25!75!
can nevertheless be computed by first canceling common factors.
Eliminating Duplicates
We mentioned earlier that counting problems can often be solved in different ways. 
Unfortunately, it is also easy to find so-called solutions that sound eminently rea-
sonable but are incorrect. Usually they are wrong because they count something 
more than once (or sometimes they overlook counting something entirely).
	
Example 56	
Consider again part (d) of Example 55, the number of committees with at least 1 
freshman. A bogus solution to this problem goes as follows: Think of a sequence 
of two subtasks, choosing a freshman and then choosing the rest of the ­committee. 

278	
Sets, Combinatorics, and Probability 
There are C(19, 1) ways to choose 1 freshman. Once a freshman has been selected, 
that guarantees that at least 1 freshman will be on the committee, so we are free to 
choose the remaining 7 members of the committee from the remaining 52 people 
without any restrictions, giving us C(52, 7) choices. By the multiplication prin-
ciple, this gives C(19, 1) # C(52, 7). However, this is a bigger number than the 
correct answer.
The problem is this: Suppose Derek and Felicia are both freshmen. In one of 
the choices we have counted, Derek is the one guaranteed freshman, and we pick 
the rest of the committee in such a way that Felicia is on it along with 6 others. But 
we have also counted the option of making Felicia the guaranteed freshman and 
having Derek and the same 6 others be the rest of the committee. This is the same 
committee as before, and we have counted it twice.
Practice 33	 A committee of 2 to be chosen from 4 math majors and 3 physics majors must include at 
least 1 math major. Compute the following 2 values.
a.	 C(7, 2) − C(3, 2) (correct solution: all committees minus those with no math majors)
b.	 C(4, 1) # C(6, 1) (bogus solution: choose 1 math major and then choose the rest of the committee)
The expression C(4, 1) # C(6, 1) − C(4, 2) also gives the correct answer because C(4, 2) is the number 
of committees with 2 math majors, and these are the committees counted twice in C(4, 1) # C(6, 1).
■
	
Example 57	
	
a.	 How many distinct permutations can be made from the characters in the 
word FLORIDA?
	
b.	 How many distinct permutations can be made from the characters in the 
word MISSISSIPPI?
Part (a) is a simple problem of the number of ordered arrangements of seven 
distinct objects, which is 7!. However, the answer to part (b) is not 11! because the 
11 characters in MISSISSIPPI are not all distinct. This means that 11! counts some 
of the same arrangements more than once (the same arrangement meaning that we 
cannot tell the difference between MIS1S2ISSIPPI and MIS2S1ISSIPPI.)
Consider any one arrangement of the characters. The four S’s occupy certain 
positions in the string. Rearranging the S’s within those positions would result in 
no distinguishable change, so our one arrangement has 4! look-alikes. In order to 
avoid overcounting, we must divide 11! by 4! to take care of all the ways of mov-
ing the S’s around. Similarly, we must divide by 4! to take care of the four I’s and 
by 2! to take care of the two P’s. The number of distinct permutations is thus
11!
4!4!2!
In general, suppose there are n objects of which a set of n1 are indistinguish-
able from each other, another set of n2 are indistinguishable from each other, and 
so on, down to nk objects that are indistinguishable from each other. The number 
of distinct permutations of the n objects is
n!
(n1!)(n2!) c (nk!)

Section 4.4   Permutations and Combinations	
279
Practice 34	 How many distinct permutations are there of the characters in the word MONGOOSES?
■
Permutations and Combinations with Repetitions
Our formulas for P(n, r) and C(n, r) assume that we arrange or select r objects out 
of the n available using each object only once. Therefore r ≤ n. Suppose, however, 
that the n objects are available for reuse as many times as desired. For example, we 
construct words using the 26 letters of the alphabet; the words may be as long as 
desired with letters used repeatedly. Or we may draw cards from a deck, replacing 
a card after each draw; we may draw as many cards as we like with cards used 
repeatedly. We can still talk about permutations or combinations of r objects out 
of n, but with repetitions allowed, r might be greater than n.
Counting the number of permutations of r objects out of n distinct objects 
with repetition is easy. We have n choices for the first object and, because we can 
repeat that object, n choices for the second object, n choices for the third, and so 
on. Hence, the number of permutations of r objects out of n distinct objects with 
repetition allowed is nr.
To determine the number of combinations of r objects out of n distinct objects 
with repetition allowed, we use a rather clever idea.
	
Example 58	
A jeweler designing a pin has decided to use five stones chosen from a supply of 
diamonds, rubies, and emeralds. How many sets of stones are possible?
Because we are not interested in any ordered arrangement of the stones, this is 
a combinations problem rather than a permutations problem. We want the number 
of combinations of five objects out of three objects with repetition allowed. The 
pin might consist of 1 diamond, 3 rubies, and 1 emerald, for instance, or 5 dia-
monds. We can represent these possibilities by representing the stones chosen by 
5 asterisks and placing markers between the asterisks to represent the distribution 
among the three types of gem, diamonds, rubies, and emeralds. For example, we 
could represent the choice of 1 diamond, 3 rubies, and 1 emerald by
*0***0*
while the choice of 5 diamonds, 0 rubies, and 0 emeralds would be represented by
*****0 0
Although we wrote the asterisks and markers in a row, there is no ordering implied. 
We are just looking at seven slots holding the five gems and the two markers, and 
the different choices are represented by which of the seven slots are occupied by 
asterisks. We therefore count the number of ways to choose five items out of seven, 
which is C(7, 5) or
7!
5!2!

280	
Sets, Combinatorics, and Probability 
In general, if we use the same scheme to represent a combination of r objects out 
of n distinct objects with repetition allowed, there must be n − 1 markers to indi-
cate the number of copies of each of the n objects. This gives r + (n − 1) slots to 
fill, and we want to know the number of ways to select r of these. Therefore we 
want
C(r + n −1, r) =
(r + n −1)!
r!(r + n −1 −r)! = (r + n −1)!
r!(n −1)!
This agrees with the result in Example 58, where r = 5, n = 3.
We have discussed a number of counting techniques in this chapter. Table 4.2 
summarizes the techniques you can apply in various circumstances, although there 
may be several legitimate ways to solve any one counting problem.
Practice 35	 Six children get one lollipop each from among a selection of red, yellow, and green lol-
lipops. How many sets of lollipops are possible? (We do not care which child gets which.)
■
Table 4.2
You Want to Count the Number of …
Technique to Try
Subsets of an n-element set
Use formula 2n.
Outcomes of successive events
Multiply the number of outcomes for 
each event.
Outcomes of disjoint events
Add the number of outcomes for each 
event.
Outcomes given specific choices at 
each step
Draw a decision tree and count the  
number of paths.
Elements in overlapping sections of 
­related sets
Use principle of inclusion and exclusion 
formula.
Ordered arrangements of r out of n 
­distinct objects
Use P( n, r ) formula.
Ways to select r out of n distinct  
objects
Use C( n, r ) formula.
Ways to select r out of n distinct  
objects with repetition allowed
Use C( r + n − 1, r ) formula.
Generating Permutations and Combinations
In a certain county, lottery ticket numbers consist of a sequence (a permutation) 
of the 9 digits 1, 2, …, 9. The ticket printing company may or may not know that  
9! = 362,880 distinct ticket numbers are possible, but it certainly needs a way to 

Section 4.4   Permutations and Combinations	
281
generate all possible ticket numbers. Or the county council (a group of 12 mem-
bers) wants to form a subcommittee of 4 members but wants to pick the combina-
tion of council members it feels can best work together. The council could ask 
someone to generate all C(12, 4) = 495 potential subcommittees and examine 
the membership of each one. We see that in some situations, simply counting the 
number of permutations or combinations is not enough; it is useful to be able to 
list all the permutations or combinations.
	
Example 59	
Example 47 asked for the number of permutations of the three objects a, b, and c. 
The answer is given by the formula P(3,3) = 3! = 6. However Example 47 went 
on to list the six permutations:
abc, acb, bac, bca, cab, cba
This list presents the six permutations using lexicographical ordering, that is, the 
order in which they would be found in a dictionary if they were legitimate words. 
Thus abc precedes acb because although both words begin with the same first 
character, for the second character, b precedes c. If we had three integers, say 4, 6, 
and 7, instead of three alphabetical characters, the lexicographical ordering of all 
six permutations would present values in increasing numerical order:
467, 476, 647, 674, 746, 764
Practice 36	 Arrange the following list of permutations in lexicographical order:
scary, yarsc, scyra, cysar, scrya, yarcs
■
Words that are close in lexicographical order have the maximum number of 
matching leftmost characters or, equivalently, differ in the fewest rightmost char-
acters. We use this characteristic to develop a process to generate all permutations 
of the integers {1, …, n} in lexicographical order.
	
Example 60	
Consider the set {1, 2, 3, 4, 5}. The smallest numerical value (the first permutation) 
is given by the increasing order of all the integers, namely,
12345
To generate the next number in lexicographical order, we want to retain as many 
of the leftmost digits as possible. Clearly we can’t keep the leftmost four digits be-
cause this also determines the fifth digit. To keep the leftmost three digits, 123 − −, 
we must be able to rearrange the remaining two digits to represent a larger value 
than they do now. Reading 12345 from right to left, we find in the last two digits 
that 4 < 5, which means we can reverse the 4 and the 5 to get
12354

282	
Sets, Combinatorics, and Probability 
which is the next permutation in the list. That’s all that can be done with the last 
two digits; in particular, since 54 is a decreasing sequence, we can’t use these two 
values to generate anything larger.
For the next number, we keep 12 − − − and consider how to arrange the last 
three digits. Reading 12354 from right to left, we find in the last three digits that  
3 < 5, but we know that everything from 5 to the right is a decreasing sequence. 
The next permutation should replace 3 with the next largest value to its right. 
Reading from right to left in the number 12354, the first value larger than 3, in 
this case 4, is the least value larger than 3. Swapping 3 and 4 gives 12453, which 
puts 4 in the correct order; the digits to the right are now in descending order, so 
reversing them gives
12435
which is the next permutation.
	
Example 61	
To continue Example 60, let’s jump ahead. Suppose we have just generated 
­permutation
25431
and we want the next permutation. Reading from right to left, everything increases 
until we get to 2, where we have 2 < 5. Starting again from right to left, we stop 
at the first (and smallest) value greater than 2, which is 3. Swapping 2 and 3 gives 
35421, giving the correct first digit. The digits after 3 are in descending order, so 
reversing them involves swapping 5 and 1, and also swapping 4 and 2, giving the 
next permutation
31245
	
Algorithm	
Permutation Generator
PermGenerator(integer n ≥ 2)
//generates in lexicographical order all permutations 
//of the integers in the set {1, …, n}
Local variables:
integers i, j	
	
	
	
//indices of permutation elements
integer k	
	
	
	
//for loop counter
integers d1, d2, …, dn	 	
	
//left to right elements of a permutation
From the preceding examples, we can construct an algorithm to generate all 
permutations of the integers from 1 to n in lexicographical order.

Section 4.4   Permutations and Combinations	
283
//create and write out smallest permutation
for k = 1 to n do
dk = k
end for
write d1d2…dn
//create and write out remaining permutations
for k = 2 to n! do
//look right to left for first break in increasing sequence
i = n – 1 
j = n
while di > dj do //still increasing right to left
i = i – 1 
j = j – 1
end while
//now di < dj, need to replace di with next largest integer
//look right to left for smallest value greater than di
j = n
while di > dj do
j = j – 1
end while
//now dj is smallest value > di
swap di and dj
//reverse the digits to the right of index i
i = i + 1
j = n
while i < j do
swap di and dj
i = i + 1
j = j − 1
end while
write d1d2…dn
end for
end function PermGenerator
Practice 37	 Walk through the steps in the algorithm that generate the next permutation following 
51432.
■
Another algorithm for generating (not in lexicographical order) all permuta-
tions of the integers {1, … , n} is suggested in Exercise 7 of On the Computer at 
the end of this chapter. Both of these algorithms can also be used to generate all 

284	
Sets, Combinatorics, and Probability 
permutations of any n distinct elements; simply assign each of the n elements a 
unique integer from 1 to n, generate the permutations of the integers, and then 
reverse the assignment.
Our second problem is to generate the C(n, r) combinations of r distinct in-
tegers chosen from {1, … , n}. Such a combination does not involve order, it is 
merely a subset of r elements. Nonetheless we will represent the subset {3, 5, 7} 
as the sequence 357, and generate the subsets in lexicographical order. Once we 
generate 357, we can’t also generate 375 or 753 or any of the other permutations of 
the elements in this set. Each legitimate representation is an increasing sequence.
	
Example 62	
Consider the lexicographical ordering of the combinations of 4 integers from  
{1, … , 7}. If the combination
2346
has just been generated, then the next combination would be
2347
obtained by incrementing the last digit of the sequence. However, in 2347, the last 
digit is already at its maximum allowable value. Moving to the left, the 4 can be 
bumped up to 5, but then the last digit has to be reduced to its minimum value, 
which is 6 (one more than 5). Therefore,
2356
is the next combination. The next two values are
2357, 2367
at which point both 7 and 6 are at their maximum values. The 3 can be bumped up, 
but the two digits to its right have to be reset to their lowest possible values. The 
next few values are
2456, 2457, 2467, 2567 …
Based on the ideas of Example 62, given a combination sequence the algo-
rithm should bump up the rightmost digit that is not at its maximum allowable 
value. The sequence of digits to the right of the newly incremented digit v should 
have the values v + 1, v + 2, and so on. The initial (smallest) combination is  
12 … r.

Section 4.4   Permutations and Combinations	
285
	
Algorithm	
Combination Generator
CombGenerator(integer n ≥ 2, integer r ≥ 1)
//generates in lexicographical order all combinations 
//of r integers from the set {1, …, n}
Local variables:
integers i, j	
//indices of combination elements
integer k	
//for loop counter
integer max	
//maximum allowable value for a digit
integers d1, d2, …, dr	
//left to right elements of a combination
//create and write out smallest combination
for k = 1 to r do
dk = k
end for
write d1d2 … dr
//create and write out remaining combinations
for k = 2 to C(n, r) do
//look right to left for first non-max value
max = n
i = r
while di = max do //look left
i = i − 1
max = max − 1
end while
//now di < max, need to increment di
di = di + 1
//reset values right of di
for j = i + 1 to r do
dj = dj−1 + 1
end for
write d1d2…dr
end for
end function CombGenerator
Practice 38	 Using this algorithm, find the next combination of five items from {1, … , 9} after 24589.
■

286	
Sets, Combinatorics, and Probability 
Special Interest Page
Archimedes and the Stomachion
Archimedes was one of the greatest mathematicians 
of the ancient world. He lived about 287−212 b.c.e. in 
Syracuse (a Greek city-state in current-day Sicily). It 
is thought that he studied for a time in Alexandria 
(Egypt) with students of Euclid. At any rate, he was 
greatly interested in geometry, and he thought his 
most important work was the discovery of a formula 
for the volume of a sphere. He also approximated the 
value of π and grasped the ideas of integral calculus 
by ­approximating the area under a curve by breaking 
it up into a series of rectangles. His contributions to 
­mechanics, engineering, physics, and astronomy are 
also ­amazing. Some of his inventions helped defend 
the city of ­Syracuse from Roman invaders.
Archimedes wrote a treatise about the Stoma-
chion, which is a puzzle apparently known even 
before Archimedes’ time. The puzzle consists of 14 
polygons that fill a 12 × 12 square. It is constructed 
by marking off unit intervals along the edges of the 
square and connecting them to create a grid. Each in-
tersection of two grid lines, or of a grid line with the 
square’s border, is called a lattice point. The polygons 
are formed by lines that connect certain lattice points. 
The 14 pieces and their areas (each an integer) are 
shown here, and these areas add up to 144, the area 
of the square. (A ­modern result, Pick’s theorem, says 
that the area of such a ­polygon is given by the formula 
A = I + B/2 − 1, where I = the number of lattice 
points enclosed within the polygon and B = the num-
ber of lattice points on the border of the polygon. You 
can test this theorem on the diagram here, which is 
from the Stomachion construction Web page.)
12
12
12
12
3
3
21
12
9
6
6
6
24
6
That Archimedes’ work on the Stomachion is 
available today, at least in part, is quite a story. No 
original writings of Archimedes exist today, but ­copies 
were made throughout the ages. One such copy is an 
ancient parchment (goatskin) manuscript that was 
written sometime in the 900s. It survived for 300 cen-
turies but in 1229 it was torn apart, washed, folded, and 
written over as a prayer book (early recycling!). Then 
it disappeared for hundreds of years, to be discovered 
in the library of a Greek Orthodox monastery in Con-
stantinople in 1906 by a Danish classics scholar who 
noted the written-over characters and deciphered what 
he could, enough to recognize that it was a work by 
Archimedes. It contained information on the Stoma-
chion. The object of the puzzle, it was thought, was to 
use the pieces to construct interesting shapes (a bird, 
an elephant, etc.), much like the better-known tangram 
puzzle. Pretty trivial stuff to occupy the mind of Ar-
chimedes, it seemed.
The parchment prayer book again disappeared 
after World War I until it was put up for auction by a 
French family in 1998. Purchased by an anonymous 
American buyer for $2 million, it was handed over to 
scientists for further study. By this time, the parch-
ment was in terrible shape, with missing pages, holes 
and tears, and covered with mold, to say nothing of 
the overwriting. Modern technology has revealed 
more of the original text, which brought about a new 
interpretation of the Stomachion puzzle.
Dr. Reviel Netz, a mathematics historian at Stan-
ford, has concluded that Archimedes was trying to 
count how many ways the pieces could be combined 
to form the original square. This is essentially a 
combinatorics problem. Is it a simple problem? No, 
as it turns out. Dr. Netz posed this problem to two 
­husband-and-wife teams of combinatorics experts, 
who worked six weeks to prove that the number is 
17,152. If you ignore issues of symmetry, such as ro-
tations and reflections, the answer is 536, which was 
confirmed via a computer program written by the 
computer scientist Dr. William Cutler.
Chapter 4

Section 4.4   Permutations and Combinations	
287
Combinatorics had been considered a modern 
branch of mathematics, of much interest in com-
puter science but supposedly unknown to the ancient 
Greeks. Archimedes’ Palimpsest (a “palimpsest” is a 
written-over manuscript) gives combinatorics a much 
earlier foundation.
“Archimedes,” Encyclopedia Britannica,  
http://www.­britannica.com/EBchecked/topic/32808/
Archimedes
“In Archimedes’ Puzzle, a New Eureka Moment,” The New 
York Times, December 14, 2003,
http://www.nytimes.com/2003/12/14/us/in-­
archimedes-puzzle-a-new-eureka-moment.
html?pagewanted=all&src=pm
Reading Between the Lines, Smithsonian.com,
http://www.smithsonianmag.com/science-nature/­
archimedes.html?c=y&page=1
Stomachion construction,
http://www.math.nyu.edu/~crorres/Archimedes/­
Stomachion/construction.html
A Tour of Archimedes’ Stomachion, Chung, F., and 
­Graham, R., 
http://www.math.ucsd.edu/~fan/stomach/

288	
Sets, Combinatorics, and Probability 
Exercises 4.4
	
1.	Compute the value of the following expressions.
	
a.	 P(7, 2)	
b.	 P(8, 5)
	
2.	Compute the value of the following expressions.
	
a.	 P(6, 4)	
b.	 P(n, n − 1)
	
3.	How many batting orders are possible for a 9-man baseball team?
	
4.	The 14 teams in the local Little League are listed in the newspaper. How many listings are possible?
	
5.	How many different ways can 10 flavors of ice cream be arranged in an ice cream store display case?
	
6.	How many different ways are there to arrange 6 candidate names on a ballot?
	
7.	How many permutations of the characters in COMPUTER are there? How many of the permutations end 
in a vowel?
	
8.	In how many ways can 6 people be seated in a circle of 6 chairs? Only relative positions in the circle can 
be distinguished.
	
9.	In how many ways can first, second, and third prize in a pie-baking contest be given to 15 contestants?
	 10.	a.	 Stock designations on an exchange are limited to 3 letters. How many different designations are there?
	
b.	How many different designations are there if letters cannot be repeated?
	 11.	In how many different ways can 19 people be seated in a row?
	 12.	In how many different ways can 11 men and 8 women be seated in a row?
	 13.	In how many different ways can 11 men and 8 women be seated in a row if the men all sit together and the 
women all sit together?
	 14.	In how many different ways can 11 men and 8 women be seated in a row if no 2 women are to sit together?
	 15.	In how many different ways can 11 men and 8 women be seated around a circular table? (Only relative 
positions in the circle can be distinguished.)
	 16.	In how many different ways can 11 men and 8 women be seated around a circular table if no 2 women are 
to sit together? (Only relative positions in the circle can be distinguished.)
S e c t i o n  4 . 4 	
Review
Techniques
•	 Find the number of permutations of r distinct  
objects chosen from n distinct objects.
•	 Find the number of combinations of r distinct  
objects chosen from n distinct objects.
•	 Use permutations and combinations in conjunction 
with the multiplication principle and the addition 
principle.
•	 Find the number of distinct permutations of n  
objects that are not all distinct.
•	 Find the number of permutations of r objects 
out of n distinct objects when objects may be  
repeated.
•	 Find the number of combinations of r objects out 
of n distinct objects when objects may be repeated.
•	 Generate all permutations of the integers {1, … , n} 
in lexicographical order.
•	 Generate all combinations of r integers from the set 
{1, … , n}.
Main Ideas
•	 There are formulas for counting various permuta-
tions and combinations of objects.
•	 Care must be taken when analyzing a counting 
problem to avoid counting the same thing more 
than once or not counting some things at all.
•	 Algorithms exist to generate all permutations of  
n objects and all combinations of r out of n objects.
W

Section 4.4   Permutations and Combinations	
289
	 17.	Compute the value of the following expressions.
	
a.	 C(10, 7)	
b.	 C(9, 2)	
c.	 C(8, 6)
	 18.	Compute C(n, n − 1). Explain why C(n, n − 1) = C(n, 1).
	 19.	Quality control wants to test 25 microprocessor chips from the 300 manufactured each day. How many 
different batches of test chips are possible?
	 20.	A soccer team carries 18 players on the roster; 11 players make a team. How many different teams are 
possible?
	 21.	How many juries of 5 men and 7 women can be formed from a panel of 17 men and 23 women?
	 22.	How many different sets of 4 novels and 3 plays can be created from a collection of 21 novels and  
11 plays?
Exercises 23–26 deal with the following situation: Of a company’s personnel, 7 people work in design, 14 in 
manufacturing, 4 in testing, 5 in sales, 2 in accounting, and 3 in marketing. A committee of 6 people is to be 
formed to meet with upper management.
	 23.	How many committees with 1 member from each department are possible?
	 24.	How many committees with exactly 2 members from manufacturing are possible?
	 25.	How many committees with no representative from accounting and exactly 1 representative from market-
ing are possible?
	 26.	How many committees with at least 2 representatives from manufacturing are possible?
Exercises 27–32 concern a 5-card hand from a standard 52-card deck. A standard deck has 13 cards from each 
of 4 suits (clubs, diamonds, hearts, spades). The 13 cards have face value 2 through10, jack, queen, king, or ace. 
Each face value is a “kind” of card. The jack, queen, and king are “face cards.”
	 27.	How many hands contain 4 queens?
	 28.	How many hands contain all diamonds?
	 29.	How many hands contain 3 spades and 2 hearts?
	 30.	How many hands contain cards from all 4 suits?
	 31.	How many hands consist of all face cards?
	 32.	How many hands contain exactly 2 spades and exactly 2 hearts?
Exercises 33–42 concern 5-card poker hands from a standard 52-card deck.
 33. How many hands contain a royal straight flush (that is, the 10, jack, queen, king, ace of one suit)?
 34. How many hands contain a straight flush (that is, 5 consecutive cards of the same suit, where aces can be 
low or high) that is not a royal straight flush (see Exercise 33)?
 35. How many hands contain four of a kind (such as 4 jacks plus a fifth card)?
	 36.	How many hands contain a full house (that is, three of a kind plus a pair of another kind)?
 37. How many hands contain a flush (that is, 5 cards of the same suit) that is not a straight flush or a royal 
straight flush (see Exercises 33 and 34)?
	 38.	How many hands contain a straight (that is, 5 consecutive cards, where aces can be low or high) that is not 
a straight flush or a royal straight flush (see Exercises 33 and 34)?
	 39.	How many hands contain three of a kind (that is, exactly 3 cards of the same kind plus 2 other cards that 
are not a pair)?
 40. How many hands contain 2 pairs (that is, 2 pairs of 2 different kinds plus a fifth card of some third kind)?
	 41.	How many hands contain 1 pair (that is, exactly 2 cards of the same kind)?

290	
Sets, Combinatorics, and Probability 
	 42.	If the joker is added to the deck and functions as a fifth ace (of any suit), how many hands contain a royal 
straight flush (that is, the 10, jack, queen, king, ace of one suit)?
For Exercises 43–48, 14 copies of a code module are to be executed in parallel on identical processors or-
ganized into two communicating clusters, A and B. Cluster A contains 16 processors and cluster B contains  
32 processors.
	 43.	How many different sets of processors can be used?
	 44.	How many different sets of processors can be used if all modules must execute on cluster B?
	 45.	How many different sets of processors can be used if 8 modules are to be processed on cluster A and 6 on 
cluster B?
	 46.	How many different sets of processors can be used if cluster A has 3 failed processors and cluster B has  
2 failed processors?
	 47.	How many different sets of processors can be used if exactly 2 modules are to execute on cluster B?
	 48.	How many different sets of processors can be used if all modules are to be executed either on cluster A or 
on cluster B?
For Exercises 49–52, a set of 4 coins is selected from a box containing 5 dimes and 7 quarters.
	 49.	Find the number of sets of 4 coins.
	 50.	Find the number of sets in which 2 coins are dimes and 2 are quarters.
	 51.	Find the number of sets composed of all dimes or all quarters.
	 52.	Find the number of sets with 3 or more quarters.
Exercises 53–56 concern a computer network with 60 switching nodes.
	 53.	The network is designed to withstand the failure of any 2 nodes. In how many ways can such a failure 
occur?
	 54.	In how many ways can 1 or 2 nodes fail?
	 55.	If 1 node has failed, in how many ways can 7 nodes be selected without encountering the failed node?
	 56.	If 2 nodes have failed, in how many ways can 7 nodes be selected to include exactly 1 failed node?
In Exercises 57–60, a congressional committee of 3 is to be chosen from a set of 5 Democrats, 3 Republicans, 
and 4 independents.
	 57.	How many committees are possible? 
	 58.	How many committees with at least 1 independent are possible?
	 59.	How many committees that do not include both Democrats and Republicans are possible?
	 60.	How many committees with at least 1 Democrat and at least 1 Republican are possible?
In Exercises 61–66, the states of California, Arizona, New Mexico, Utah, and Nevada each send a team of  
6 delegates to the Southwestern States annual conference. A subcommittee of 9 is to be formed to discuss water 
rights.
	 61.	How many committees are possible?
	 62.	How many committees with no delegates from New Mexico are possible?
	 63.	How many committees with exactly 1 delegate from New Mexico are possible?
	 64.	How many committees with at most 1 delegate from New Mexico are possible?

Section 4.4   Permutations and Combinations	
291
	 65.	How many committees with at least 2 delegates from Nevada are possible?
	 66.	How many committees with at most 4 delegates total from Arizona and California are possible?
In Exercises 67–70, a hostess wishes to invite 6 dinner guests from a list of 14 friends.
	 67.	How many sets of guests are possible?
	 68.	How many sets of guests are possible if 6 friends are boring and 6 friends are interesting, and the hostess 
wants to have at least 1 of each?
	 69.	How many sets of guests are possible if 2 of the friends dislike each other and neither will come if the 
other is present?
	 70.	How many sets of guests are possible if 2 of the friends are very fond of each other and one won’t come 
without the other?
 71. Twenty-five people, including Simon and Yuan, are candidates to serve on a committee of 5. How many 
committees that include Simon or Yuan are possible?
	 72.	A student must select 5 classes for the next semester from among 12, but one of the classes must be either 
American history or English literature. How many sets of classes are possible?
	 73.	How many 5-card hands from a standard 52-card deck contain exactly 4 aces and exactly 1 club?
	 74.	How many 5-card hands from a standard 52-card deck contain exactly 3 jacks and exactly 2 hearts?
	 75.	How many distinct permutations of the characters in ERROR are there? (Remember that the various R’s 
cannot be distinguished from one another.)
	 76.	How many distinct permutations of the characters in LOLLAPALOOZA are there?
	 77.	a.	 How many distinct permutations of the characters in the word HAWAIIAN are there?
	
b.	How many of the permutations begin with H?
	 78.	a.	 How many distinct permutations of the characters in the word APALACHICOLA are there?
	
b.	How many of the permutations have both L’s together?
	 79.	A bookstore displays a shelf of 5, 3, and 4 copies, respectively, of the top 3 bestsellers. How many distin-
guishable arrangements of these books are there if books with the same title are not ­distinguishable?
 80. The United Group for Divisive Action uses secret code words that are permutations of 5 characters. You 
learn that there are only 10 code words. What can you say about repeated characters in the code words?
	 81.	At a dinner party for 5, a tray of 5 servings of appetizers is prepared. An appetizer could be escargots, egg 
rolls, or nachos. How many different trays could the kitchen produce?
	 82.	A florist has a large number of roses, carnations, lilies, and snapdragons in stock. How many different 
bouquets of one dozen flowers can be made?
	 83.	A cheese shop carries a large stock of 34 kinds of cheese. By the end of the day, 48 cheese sales have been 
made, and the items sold must be restocked. How many different restocking orders are possible?
	 84.	One “game package” consists of 12 bingo cards. How many different game packages are there if there are 
15 kinds of cards and repetitions are allowed?
	 85.	A hardware shipping order contains 6 items, where each item is either a gallon of paint, a hammer, or a 
drill.
	
a.	 How many different shipping orders are possible? 
	
b.	How many different shipping orders are possible if no paint is shipped?
	
c.	 How many different shipping orders are possible if each order must contain at least 1 gallon of paint,  
1 hammer, and 1 drill?

292	
Sets, Combinatorics, and Probability 
	 86.	At a birthday party, a mother prepares a plate of cookies for 8 children. There are plenty of chocolate chip, 
peanut butter, and oatmeal cookies, but each child gets only 1 cookie.
	
a.	 How many different plates can be prepared?
	
b.	How many different plates can be prepared if at least 1 of each kind of cookie is given out?
	
c.	 How many different plates can be prepared if no one likes oatmeal cookies?
	
d.	How many different plates can be prepared if 2 children insist on getting peanut butter?
	
e.	 How many different plates can be prepared if the dog got into the kitchen and ate all the chocolate chip 
cookies except 2?
	 87.	On Halloween, 10 identical apples are distributed to 7 children.
	
a.	 How many distributions are possible? (Hint: One possible distribution is that child 1 gets 3 apples, 
child 2 gets 0 apples, child 3 gets 2 apples, child 4 gets 0 apples, child 5 and child 6 get 1 apple 
each, and child 7 gets 3 apples. Although the problem says apples are distributed to children, think of 
­assigning a child’s name to each apple; a child’s name can go to more than 1 apple.)
	
b.	How many distributions are possible if each child is to receive at least 1 apple?
	 88.	Eight identical antique pie safes are sold at a furniture auction to 3 bidders.
	
a.	 In how many ways can the pie safes be distributed among the bidders? (See the hint for Exercise 87.)
	
b.	In how many ways can the pie safes be distributed if bidder A gets only 1 pie safe?
	 89.	How many distinct nonnegative integer solutions are there to the equation
x1 + x2 + x3 + x4 = 10
	
	where the solution
x1 = 3, x2 = 1, x3 = 4, x4 = 2
	
	and the solution
x1 = 4, x2 = 2, x3 = 3, x4 = 1
	
	are distinct? (Hint: Think of this problem as distributing 10 pennies to 4 children; then see the hint in 
Exercise 87.)
	 90.	How many distinct nonnegative integer solutions are there to the equation
x1 + x2 + x3 = 7
	
	in which x1 ≥ 3? (See the hint for Exercise 89.)
	 91.	Prove that for n ≥ 1, P(n, n) = P(n, n − 1). (The proof does not require induction, even though it sounds 
like a very likely candidate for induction.)
	 92.	Prove that for n ≥ 2, P(n, 1) + P(n, 2) = n2.
	 93.	Prove that for any n and r with 0 ≤ r ≤ n, C(n, r) = C(n, n − r). Explain why this is intuitively true.
	 94.	Prove that for any n and r with 0 ≤ r ≤ n, C(n, 2) = C(r, 2) + C(n − r, 2) + r(n − r).
	 95.	Prove the identity
C(n, r)C(r, k) = C(r, k)C(n − k, r − k) for r ≤ n and k ≤ r
	
	Give a combinatorial argument.

Section 4.4   Permutations and Combinations	
293
	 96.	Prove Vandermonde’s identity:
C(n + m, r) = ∙
r
k=0
C(n, k)C(m, r −k)
	
	(Hint: use a combinatorial argument, picking r elements from the union of two disjoint sets of size n and 
m, respectively.)
	 97.	The recurrence relation for the sequence of Catalan numbers is
C(0) = 1
C(1) = 1
C(n) = ∙
n
k=1
C(k −1)C(n −k)    n ≥2
	
	Although we will not prove it, a closed-form solution to this recurrence relation is
C(n) =
1
n + 1 C(2n, n)
	
	(Note that C(n) denotes a value in the Catalan sequence and C(2n, n) denotes the number of combinations 
of n objects from 2n objects.) Compute C(2), C(3), and C(4) using this formula and compare the results 
with the recurrence relation results (see Exercise 38 of Section 3.1).
	 98.	a.	 A turtle begins at the upper left corner of an n × n grid and makes his way to the lower right corner. 
Along the way, he can move only right or down. The accompanying figure shows two possible paths in 
a 4 × 4 grid. How many possible paths can the turtle take?
	
	(Hint: Each path can be described by a sequence of R’s (right moves) and D’s (down moves). Find the 
number of ways to distribute the R’s in such a sequence.)
	
b.	Relate the answer to part (a) to the sequence of Catalan numbers (see Exercise 97).
	 99.	Arrange the following permutations of the numbers {1, … , 6} in lexicographical order:
163542, 345621, 643125, 634521, 163452, 356421
	100.	Arrange the following permutations of the numbers {1, … , 5} in reverse lexicographical order:
32541, 35142, 53124, 42531, 32154, 42315

294	
Sets, Combinatorics, and Probability 
In Exercises 101–104, use algorithm permutation generator to generate the next permutation after the given 
permutation in the set of all permutations of the numbers {1, … , 7}.
	101.	7431652
	102.	4365127
	103.	3675421
	104.	2756431
	105.	In generating all combinations of five items from the set {1, … , 9}, find the next five values in the list 
after 24579.
	106.	In generating all combinations of four items from the set {1, … , 6}, find the next five values in the list 
after 1234.
	107.	Describe an algorithm to generate all permutations of the integers {1, … , n} in reverse lexicographical 
order.
	108.	Describe an algorithm to generate all permutations of r elements from the set {1, … , n}.
	
S e c t i o n  4 . 5 	 Binomial Theorem
The expression for squaring a binomial is a familiar one:
(a + b)2 = a2 + 2ab + b2
This is a particular case of raising a binomial to a nonnegative integer power n. 
The formula for (a + b)n involves combinations of n objects. Before we prove this 
formula, we’ll look at a historically interesting array of numbers that suggests a 
fact we will need in the proof.
Pascal’s Triangle
Pascal’s triangle is named for the seventeenth-century French mathematician 
Blaise Pascal (for whom the programming language Pascal was also named), al-
though it was apparently known several centuries earlier. Row n of the triangle  
(n ≥ 0) consists of all the values C(n, r) for 0 ≤ r ≤ n. Thus the triangle looks like 
this:
C(0, 0)
C(1, 0)
C(1, 1)
C(2, 0)
C(2, 1)
C(2, 2)
C(3, 0)
C(3, 1)
C(3, 2)
C(3, 3)
C(4, 0)
C(4, 1)
C(4, 2)
C(4, 3)
C(4, 4)
C(5, 0)
C(5, 1)
C(5, 2)
C(5, 3)
C(5, 4)
C(5, 5)
C(n, 0)
C(n, 1)
...
C(n, n
1)
C(n, n)
Row
0
1
2
3
4
5
n

Section 4.5   Binomial Theorem	
295
If we compute the numerical values of the expressions, we see that Pascal’s tri-
angle has the form
1
1
1
1
2
1
1
3
3
1
1
4
6
4
1
1 5 10 10 5 1
Observing this figure, it is clear that the outer edges are all 1s. But it also seems 
that any element not on the outer edge can be obtained by adding together the two 
elements directly above it in the preceding row (for example, the first 10 in row 
five is below the first 4 and the 6 of row four). If this relationship is indeed always 
true, it means that
	
C(n, k) = C(n − 1, k − 1) + C(n − 1, k) for 1 ≤ k ≤ n − 1	
(1)
Equation (1) is known as Pascal’s formula.
To prove Pascal’s formula, we begin with the right side:
C(n −1, k −1) + C(n −1, k) =
(n −1)!
(k −1)!3n −1 −(k −1)4! +
(n −1)!
k!(n −1 −k)!
=
(n −1)!
(k −1)!(n −k)! +
(n −1)!
k!(n −1 −k)!
= k(n −1)!
k!(n −k)! + (n −1)!(n −k)
k!(n −k)!
(multiplying the first term by k/k and the second term by (n − k)/(n − k))
 = k (n −1)! + (n −1)!(n −k)
k!(n −k)!
(adding fractions)
= (n −1)!3k + (n −k)4
k!(n −k)!
(factoring the numerator)
 = (n −1)!(n)
k!(n −k)!
=
n!
k!(n −k)!
= C(n, k)

296	
Sets, Combinatorics, and Probability 
Another, less algebraic way to prove Pascal’s formula involves a counting ar-
gument; hence it is called a combinatorial proof. We want to compute C(n, k), 
the number of ways to choose k objects from n objects. There are two disjoint 
­categories of such choices—item 1 is one of the k objects or it is not. If item 1 is 
one of the k objects, then the remaining k − 1 objects must come from the remain-
ing n − 1 objects exclusive of item 1, and there are C(n − 1, k − 1) ways for this 
to happen. If item 1 is not one of the k objects, then all k objects must come from 
the remaining n − 1 objects, and there are C(n − 1, k) ways for this to happen. 
The total number of outcomes is the sum of the number of outcomes from these 
two disjoint cases.
Once we have Pascal’s formula for our use, we can develop the formula for  
(a + b)n, known as the binomial theorem.
Binomial Theorem and Its Proof
In the expansion of (a + b)2, a2 + 2ab + b2, the coefficients are 1, 2, and 1, which 
is row 2 in Pascal’s triangle.
Looking at the coefficients in the expansion of (a + b)2, (a + b) 3, and (a + b)4 
suggests a general result, which is that the coefficients in the expansion of (a + b)n 
look like row n in Pascal’s triangle. This is indeed the binomial theorem.
Practice 39	 Compute the expansion for (a + b)3 and (a + b)4 and compare the coefficients with rows 3 
and 4 of Pascal’s triangle.
■
	
Theorem	
Binomial Theorem
For every nonnegative integer n,
(a + b)n = C(n, 0)anb0 + C(n, 1)an−1b1 + C(n, 2)an−2b2
+ c+ C(n, k)an−kbk + c+ C(n, n −1)a1bn−1 + C(n, n)a0bn
= ∙
n
k=0
C(n, k)an−kbk
Because the binomial theorem is stated “for every nonnegative integer n,” a proof 
by induction seems appropriate. For the basis step, n = 0, the theorem states
(a + b)0 = C(0, 0)a0b0 
which is
1 = 1
Since this is certainly true, the basis step is satisfied.
REMINDER
The expansion of (a + b)n 
starts with anb0. From 
there the power of a goes 
down and the power of b 
goes up, but for each term 
the powers of a and b add 
up to n. The coefficients 
are all of the form  
C(n, the power of b).

Section 4.5   Binomial Theorem	
297
As the inductive hypothesis, we assume that
(a + b)k = C(k, 0)akb0 + C(k, 1)ak−1b1 + c+ C(k, k −1)a1bk−1 + C(k, k)a0bk
Now consider
(a + b)k+1 = (a + b)k(a + b) = (a + b)ka + (a + b)kb
 = 3C(k, 0)akb0 + C(k, 1)ak−1b1 + c+ C(k, k −1)a1bk−1
+ C(k, k)a0bk4a + 3C(k, 0)akb0 + C(k, 1)ak−1b1
+ c+ C(k, k −1)a1bk−1 + C(k, k)a0bk4b
(by the inductive hypothesis)
= C(k, 0)ak+1b0 + C(k, 1)akb1 + c+ C(k, k −1)a2bk−1
+ C(k, k)a1bk + C(k, 0)akb1 + C(k, 1)ak−1b2
+ c+ C(k, k −1)a1bk + C(k, k)a0bk+1
= C(k, 0)ak+1b0 + 3C(k, 0) + C(k, 1)4akb1 + 3C(k, 1) + C(k, 2)4ak−1b2
+ c+ 3C(k, k −1) + C(k, k)4a1bk + C(k, k)a0bk+1
(collecting like terms)
= C(k, 0)ak+1b0 + C(k + 1, 1)akb1 + C(k + 1, 2)ak−1b2
+ c+ C(k + 1, k)a1bk + C(k, k)a0bk+1
(using Pascal’s formula)
= C(k + 1, 0)ak+1b0 + C(k + 1, 1)akb1 + C(k + 1, 2)ak−1b2
+ c+ C(k + 1, k)a1bk + C(k + 1, k + 1)a0bk+1
(because C(k, 0) = 1 = C(k + 1, 0) and C(k, k) = 1 = C(k + 1, k + 1))
This completes the inductive proof of the binomial theorem.
The binomial theorem also has a combinatorial proof. Writing (a + b)n 
as (a + b)(a + b) c(a + b) (n factors), we know that the answer (using the distribu-
tive law of numbers) is the sum of all values obtained by multiplying each term in 
a factor by a term from every other factor. For example, using b as the term from k 
factors and a as the term from the remaining n − k factors produces the expression 
an−kbk. Using b from a different set of k factors and a from the n − k remaining fac-
tors also produces an−kbk. How many such terms are there? There are C(n, k) different 
ways to select k factors from which to use b; hence there are C(n, k) such terms. After 
adding these terms together, the coefficient of an−kbk is C(n, k). As k ranges from 0 
to n, the result of summing the terms is the binomial theorem.
Because of its use in the binomial theorem, the expression C(n, r) is also 
known as a binomial coefficient.

298	
Sets, Combinatorics, and Probability 
Applying the Binomial Theorem
	
Example 63	
Using the binomial theorem, we can write the expansion of (x − 3)4. To match 
the form of the binomial theorem, think of this expression as (x + (−3))4 so that b 
equals −3. Remember that a negative number raised to a power is positive for an 
even power, negative for an odd power. Thus
(x −3)4 = C(4, 0)x4(−3)0 + C(4, 1)x3(−3)1 + C(4, 2)x2(−3)2
+ C(4, 3)x1(−3)3 + C(4, 4)x0(−3)4
= x4 + 4x3(−3) + 6x2(9) + 4x(−27) + 81
= x4 −12x3 + 54x2 −108x + 81
Practice 40	 Expand (x + 1)5 using the binomial theorem.
■
Practice 41	 What is the fifth term in the expansion of (x + y)7?
■
The binomial theorem tells us that term k + 1 in the expansion of (a + b)n 
is C(n, k)an−kbk. This allows us to find individual terms in the expansion without 
computing the entire expression.
By using various values for a and b in the binomial theorem, certain identities 
can be obtained.
	
Example 64	
Let a = b = 1 in the binomial theorem. Then
(1 + 1)n = C(n, 0) + C(n, 1) + c+ C(n, k) + c+ C(n, n)
or
	
2n = C(n, 0) + C(n, 1) + c+ C(n, k) + c+ C(n, n)	
(2)
This result says that the sum of all the entries in row n of Pascal’s triangle equals 
2n. Actually, Equation (2) can be proved on its own using a combinatorial proof. 
The number C(n, k), the number of ways to select k items from a set of n items, can 
be thought of as the number of k-element subsets of an n-element set. The right 
side of Equation (2) therefore represents the total number of all the subsets (of all 
sizes) of an n-element set. But we already know that the number of such subsets 
is 2n.

Section 4.5   Binomial Theorem	
299
Exercises 4.5
	
1.	Expand the expression using the binomial theorem.
	
a.	 (a + b)5
	
b.	(x + y)6
	
c.	 (a + 2)5
	
d.	(a − 4)4
	
2.	Expand the expression using the binomial theorem.
	
a.	 (2x + 3y) 3
	
b.	(3x − 1)5
	
c.	 (2p − 3q)4 
	
d.	(3x + ½)5
In Exercises 3–10, find the indicated term in the expansion.
	
3.	The fourth term in (a + b)10
	
4.	The seventh term in (x − y)12
	
5.	The sixth term in (2x − 3)9
	
6.	The fifth term in (3a + 2b)7
	
7.	The last term in (x − 3y)8
	
8.	The last term in (ab + 3x)6
	
9.	The third term in (4x − 2y)5
	 10.	The fourth term in (3x − ½)8
	 11.	Use the binomial theorem (more than once) to expand (a + b + c)3.
	 12.	Expand (1 + 0.1)5 in order to compute (1.1)5.
	 13.	What is the coefficient of x3y4 in the expansion of (2x − y + 5)8?
	 14.	What is the coefficient of x5y 2z 2 in the expansion of (x + y + 2z)9?
	 15.	Prove that
C(n + 2, r) = C(n, r) + 2C(n, r − 1) + C(n, r − 2) for 2 ≤ r ≤ n
	
	(Hint: Use Pascal’s formula.)
	 16.	Prove that
C(k, k) + C(k + 1, k) + c+ C(n, k) = C(n + 1, k + 1) for 0 ≤ k ≤ n
	
	(Hint: Use induction on n for a fixed, arbitrary k, as well as Pascal’s formula.)
S e c t i o n  4 . 5 	
Review
Technique
•	 Use the binomial theorem to expand a binomial.
•	 Use the binomial theorem to find a particular term 
in the expansion of a binomial.
Main Ideas
•	 The binomial theorem provides a formula for ex-
panding a binomial without multiplying it out.
•	 The coefficients of a binomial raised to a nonnega-
tive integer power are combinations of n items as 
laid out in row n of Pascal’s triangle.
W
W

300	
Sets, Combinatorics, and Probability 
	 17.	Use the binomial theorem to prove that
C(n, 0) − C(n, 1) + C(n, 2) − c+ (− 1)nC(n, n) = 0
	 18.	Use the binomial theorem to prove that
C(n, 0) + C(n, 1)2 + C(n, 2)22 + c+ C(n, n)2n = 3n
	 19.	Use the binomial theorem to prove that
C(n, n) + C(n, n − 1)2 + C(n, n − 2)22 + c+ C(n, 1)2n−1 + C(n, 0)2n = 3n
	 20.	Prove the result of Exercise 19 directly from Exercise 18.
	 21.	(Requires calculus)
	
a.	 Expand (1 + x)n.
	
b.	Differentiate both sides of the equation from part (a) with respect to x to obtain
n(l + x)n−1 = C(n, 1) + 2C(n, 2)x + 3C(n, 3)x2 + c+ nC(n, n)xn−1
	
c.	 Prove that
C(n, 1) + 2C(n, 2) + 3C(n, 3) + c+ nC(n, n) = n2n−1
	
d.	Prove that
C(n, 1) − 2C(n, 2) + 3C(n, 3) − 4C(n, 4) + c+ (−1)n−1nC(n, n) = 0
	 22.	(Requires calculus)
	
a.	 Prove that
2n+1 −1
n + 1
= C(n, 0) + 1
2 C(n, 1) + 1
3 C(n, 2) + c+
1
n + 1 C(n, n)
	
b.	Prove that
1
n + 1 =  C(n, 0) −1
2 C(n, 1) + 1
3 C(n, 2) + c+ (−1)n 
1
n + 1 C(n, n)
	
	
(Hint: Integrate both sides of the equation from part (a) of Exercise 21.)
	 23.	The general form of the principle of inclusion and exclusion is
0 A1 c cc An 0 = ∙
1≤i≤n
 0 Ai 0 − 
∙
1≤i<j≤n
 0 Ai d Aj 0
	
+
∙
1≤i<j<k≤n
 0 Ai d Aj d Ak 0
	
−c+ (−1)n+1 0 A1 d cd An 0	
(1)

Section 4.6   Probability	
301
	
	This exercise provides an alternate to the inductive proof given in Section 4.3 of the principle of inclusion 
and exclusion. Equation (1) is correct if for any x in {A1 c cc An}, x is counted exactly once by the right 
side of the equation.
	
a.	 Suppose x is an element of k of the n sets {A1, … , An}. Let B equal the set of Ai s of which x is a member. 
Then x is counted once in the right side of (1) for each of the intersections that include only sets from 
B. Show that in the intersections of m sets from {A1, … , An}, 1 ≤ m ≤ k, there are C(k, m) that include 
only sets from B.
	
b.	Using the result of part (a), write a sum of terms that represents the number of times x is counted in the 
right side of (1).
	
c.	 Use Exercise 17 to show that this sum of terms equals 1.
	 24.	Pascal’s triangle has many interesting properties. If you follow diagonal paths through the triangle and 
sum the values on each path, the result is the Fibonacci sequence (see (a) below). The values along the 
diagonals are easier to understand if the rows of the triangle are written one row per line with each row 
beginning one position to the right of the previous row (see (b) below).	Then the diagonals are the table 
columns.
	
	
1
1
1
1
1
1
1
5
10
10
...
5
1
4
6
4
1
3
3
1
2
1
11 2
3
5
8
	
6
7
8
5
4
3
2
1
0
0
1
1
1
1
2
1
2
3
4
5
6
7
8
1
1
2
3
5
8
13
21
34
1
1
3
1
3
1
4
1
6
4
1
5
10
10
1
6
15
1
7
1
	
a.	 Prove that the values in column n, n ≥ 2, read from bottom to top, are given by the expression 
∙
n∙2
k=0
C(n −k, k) if n is even and by ∙
(n−1)∙2
k=0
C(n −k, k) if n is odd.
	
b.	Prove that the sum of the values in column n, n ≥ 0, equals F(n + 1).
	
S e c t i o n  4 . 6 	 Probability
Introduction to Finite Probability
Probability is an extension of the combinatorics (counting) ideas we have already 
been using. If some action can produce Y different outcomes and X of those Y 
outcomes are of special interest, we may want to know how likely it is that one of 
the X outcomes will occur. Probability had its beginnings in gaming or gambling, 
and we have pretty good intuition for simple cases.
(a)
(b)

302	
Sets, Combinatorics, and Probability 
	
Example 65	
What is the probability of
	
a.	 getting “heads” when a coin is tossed?
	
b.	 getting a 3 with a roll of a die?
	
c.	 drawing either the ace of clubs or the queen of diamonds from a standard 
deck of cards?
For (a), tossing a coin results in 2 different possible results, heads or tails, but only 
the heads result is of interest. The probability of getting heads is “one out of two” 
or 1/2. For (b), the roll of a standard 6-sided die has 6 possible results—any of the 
numbers 1, 2, 3, 4, 5, or 6 might come up. The 3 is exactly one of these possibili-
ties, so the probability of rolling a 3 is 1/6. For (c), because a standard card deck 
contains 52 cards, the action of drawing one card has 52 possible results. Two of 
these are successful results (ace of clubs or queen of diamonds), so the probability 
of succeeding in this task is 2/52 or 1/26.
On closer examination, our intuitive answers rely on certain assumptions. We 
assume that the coin is a “balanced” coin, equally likely to come up heads or tails. 
We assume that the die is not “loaded” and that the deck of cards is not “stacked.” 
In other words, we assume that each of the possible outcomes is equally likely; 
otherwise our probability of success would be different. (Loaded dice and stacked 
decks are the motivation for many Western movie gunfights.)
The set of all possible outcomes of an action is called the sample space S of 
the action. Any subset of the sample space is called an event. If S is a finite set 
of equally likely outcomes, then the probability P(E) of event E is defined to be
P(E) = 0  E 0
0  S 0
(Remember that 0 A 0 denotes the size of a finite set A.)
	
Example 66	
Two coins, A and B, are tossed at the same time; each coin is a fair coin, equal-
ly likely to come up heads (H) or tails (T). The sample space of this action is  
S = {HH, HT, TH, TT}. Here HT denotes that A comes up heads and B comes up 
tails, while TH denotes that A comes up tails and B comes up heads; these are two 
different outcomes. Let the event E be the set {HH}. The probability of E—that is, 
the probability of having both coins come up heads2—is
P(E ) = 0  E 0
0  S 0 =
0 5HH60
0 5HH, HT, TH, TT60 = 1
4 = 0.25
2An event, while technically a set, is also used to describe the action whose outcomes are the members of 
this set. Here the event E is the set {HH}, but we also speak of the event as the action of tossing two coins 
and having both come up heads.
■
Practice 42	 Find the probability of drawing an ace from a standard deck of cards.

Section 4.6   Probability	
303
Because events are sets, they can be combined using set operations. Suppose 
that E1 and E2 are two events from the same sample space S. If we are interested 
in the outcomes in either E1 or E2 or both, this will be the event E1 c E2. If we are 
interested in the outcomes in both E1 and E2, this will be the event E1 d E2. And if 
we are interested in all the outcomes that are not in E1, this will be E1′.
	
Example 67	
Employees from testing, development, and marketing participate in a drawing in 
which one employee name is chosen. There are 5 employees in testing (2 men and 
3 women), 23 in development (16 men and 7 women), and 14 in marketing (6 men 
and 8 women).
The sample space has 42 names, that is, 0 S 0 = 42. Let W be the event that a 
name drawn belongs to a woman. Then 0 W 0 = 3 + 7 + 8 = 18. Therefore, the 
probability P(W ) that the name drawn belongs to a woman is 0 W 0 / 0 S 0 = 18/42 = 
3/7. Let M be the event that a name drawn belongs to someone from marketing. Then 
0 M 0 = 14. Thus, the probability P(M ) that the name drawn belongs to someone from 
marketing is 0 M 0 / 0 S 0 = 14/42 = 1/3. The event that the name drawn belongs to a 
woman in marketing is W d M. Because there are 8 women in marketing, 0 W d M 0 
= 8, and the probability P(W d M ) that the name drawn belongs to a woman from 
marketing is 8/42 = 4/21. Finally, the event that a name drawn belongs to either a 
woman or to someone from marketing is W c M, and 0 W c M 0 = 3 + 7 + 14 = 24. 
Hence P(W c M ) = 24/42 = 4/7.
Probability involves finding the size of sets, either of the sample space or of 
the event of interest. Therefore many of our previous counting techniques come 
into play. We may need to use the addition or multiplication principles, the prin-
ciple of inclusion and exclusion, or the formula for the number of combinations of 
r things from n objects. (In Example 67, we could have found the size of the union 
of the women and the marketing people by using the principle of inclusion and 
exclusion: 0W c M 0 = 0W 0 + 0 M 0 − 0W d M 0 = 18 + 14 − 8 = 24.)
Practice 43	 In Example 67, what is the probability of drawing the name of a male from development? 
Of drawing a name from testing or development?
■
	
Example 68	
At a party, each card in a standard deck is torn in half and both halves are placed in 
a box. Two guests each draw a half-card from the box. What is the probability that 
they draw two halves of the same card?
There are 52 # 2 = 104 half-cards in the box. The size of the sample space is 
the number of ways to pick two objects from 104, that is, 0 S 0 = C(104,2). Let H be 
the event that the halves match. There are 52 ways that the halves can match, so 
0 H 0 = 52. The probability is therefore
P(H) = 0  H 0
0S 0 =
52
C(104,2) =
52
104!
2!102!
=
52
104 # 103
2
=
52
52 # 103 =
1
103 > 0.0097

304	
Sets, Combinatorics, and Probability 
Using our definition
P(E) = 0  E 0
0  S 0
we can make some observations about probability for any events E1 and E2 from a 
sample space S of equally likely outcomes (Table 4.3). These observations are also 
called probability axioms.
Table 4.3
Observation
Justification
1.
0 ≤ P( E1) ≤ 1
E1 # S so 0 ≤ 0 E10 and 0 E10 ≤ 0 S 0
2.
The probability of an impossibility is 0
E1 = [ so 0 E1 0 = 0
3.
The probability of a “sure thing” is 1
E1 = S so 0 E1 0 = 0 S 0
4.
P( E1′) = 1 − P( E1)
0 E1′0 = 0 S 0 − 0 E1 0
5.
P( E1 c E2 ) = P( E1) + P( E2) − P( E1 d E2 )
See following discussion
6.
If E1 and E2 are disjoint events, then 
P( E1 c E2 ) = P( E1) + P( E2 )
Follows from observation 5
Observation 5 requires a bit of explanation. From the principle of inclusion 
and exclusion,
0 E1 c E2 0 = 0 E1 0 + 0 E2 0 − 0 E1 d E2 0
So
P(E1 c E2) =
0E1 c E20
0  S 0
=
0E10 + 0E20 −0E1 d E20
0  S 0
=
0E10
0  S 0 +
0E20
0  S 0 −
0E1 d E20
0  S 0
= P(E1) + P(E2) −P(E1 d E2)
Probability Distributions
If an action produces outcomes that are not all equally likely, one way to handle 
the situation is by introducing an appropriate number of repetitions of some of the 
outcomes.
 
Example 69	
Suppose a fair die is rolled. There are 6 possible outcomes, so 0 S 0 = 6. Let T be the 
event of rolling a 3; there is only one successful outcome, so 0 T  0 = 1. Therefore the 
probability of rolling a 3, just as in Example 65b, is
P(T  ) = 0  T  0
0  S  0 = 1
6 > 0.167
The probability of rolling a 4 is the same.

Section 4.6   Probability	
305
Now suppose the die is loaded so that a 4 comes up three times more often 
than a 1, 2, 3, 5, or 6. We can describe the set of outcomes for the loaded die by
{1, 2, 3, 41, 42, 43, 5, 6}
The size of the sample space is now 0 S 0 = 8 and the probability of rolling a 3 is now
P(T ) = 0  T 0
0  S 0 = 1
8 = 0.125
This is a lower probability than before because the loaded die is not as likely to 
come up with a 3. However, if F is the event of rolling a 4, then there are three 
successful outcomes from the sample space. Therefore, the probability of rolling 
a 4 is now
P(F ) = 0  F 0
0  S 0 = 3
8 = 0.375
which is higher than before because the loaded die is more likely to come up  
with a 4.
Another way to look at problems where not all outcomes are equally likely is 
to assign a probability distribution to the sample space. Rather than artificially 
enlarging the sample space by creating duplicates of outcomes that occur more 
frequently, simply consider each distinct outcome in the original sample space as 
an event and assign it a probability. If there are k different outcomes in the sam-
ple space and each outcome xi is assigned a probability p(xi), the following rules  
apply:
	
1.	 0 ≤ p(xi) ≤ 1
	
2.	 ∙
k
i=1
p(xi) = 1
The first equation must hold because any probability value must fall within this 
range. The second equation must hold from observation 6 in Table 4.3; the union 
of all of these k disjoint outcomes is the sample space S, and the probability of S 
is 1.
Now consider some event E # S. The probability of event E is then given by
	
P(E) = ∙
xi[E
p(xi)	
(1)
In other words, we can add up all the probabilities for the individual outcomes 
in E. This also follows from observation 6 in Table 4.3; E is the union of all its 
distinct outcomes. The definition of P(E) as 0 E 0/0 S 0 when the outcomes are equally 
likely is a special case of this definition where p(xi) = 1/0 S 0 for each xi in E.

306	
Sets, Combinatorics, and Probability 
	
Example 70	
For the loaded die of Example 69, the appropriate probability distribution is
xi
1
2
3
4
5
6
p(xi)
1/8
1/8
1/8
3/8
1/8
1/8
As in Example 69, the probability of rolling a 3 is 1/8 and the probability of rolling 
a 4 is 3/8. Let E be the event that a 2 or a 4 is rolled. These are disjoint outcomes, 
so by Equation (1), P(E) = p(2) + p(4) = 1/8 + 3/8 = 4/8 = 0.5.
Practice 44	 The sample space S = {a, b, c}. Assume p(a) = 0.2 and p(b) = 0.3.
a.	 What is p(c)?
b.	What is the probability of getting an outcome of a or c?
■
Conditional Probability
A fair coin is tossed twice. The sample space is
{HH, HT, TH, TT}
The probability of getting two tails is clearly 1/4, but let us belabor this conclusion. 
Let E1 be the event that the first toss results in T, so E1 = {TH, TT}; let E2 be the 
event that the second toss results in T, so E2 = {HT, TT}. Then getting two tails is 
the event E1 d E2 = {TT}. The desired probability is
P(two tails) =
0  E1 d E2 0
0  S 0
= 1
4
Suppose, however, that we already know that the first toss resulted in T. Does 
this fact change the probability of getting two tails? Surely so, because we already 
have half of what we want. The outcome of interest is still E1 d E2 = {TT}, but 
the sample space is now limited to that meeting the condition that E1 has indeed 
occurred. That is, because we are assuming that event E1 has occurred, our sample 
space now becomes E1 itself, namely {TH, TT}. Let E2 0 E1 denote the event that E2 
occurs given that E1 has already occurred. Then
P(E20  E1) =
0  E1 d E20
0  E10
= 1
2
In terms of probabilities, P(E1 d E2) = 1/4, P(E1) = 2/4, and
P(E1 d E2)
P(E1)
= 1∙4
2∙4 = 1∙2 = P(E2 0 E1)
This suggests the following definition.

Section 4.6   Probability	
307
	
Definition	
Conditional Probability
Given events E1 and E2, the conditional probability of E2 given E1, P(E2 0 E1), is
P(E2 0 E1) = P(E1 d E2)
P(E1)
Practice 45	 In the problem of tossing a fair coin twice, what is the probability of getting two heads 
given that at least one of the tosses results in heads? (Hint: Let E2 be the event of two heads and E1 be 
the event of at least one head.)
■
	
Example 71	
In a drug study of a group of patients, 17% responded positively to compound A, 
34% responded positively to compound B, and 8% responded positively to both. 
The probability that a patient responded positively to compound B given that he or 
she responded positively to A is
P(B 0  A) = P(A d B)
P(A)
= 0.08
0.17 > 0.47
If P(E2 0 E1) = P(E2), then E2 is just as likely to happen whether E1 happens or 
not. In this case E1 and E2 are said to be independent events and we have
P(E2 0  E1) = P(E1 d E2)
P(E1)
= P(E2)
or
	
P(E1 d E2) = P(E1) # P(E2)	
(2)
Equation (2) can be extended to any finite number of independent events and can 
also be used to test whether events are independent.
	
Example 72	
The events of tossing a coin and coming up heads one time (E1) and heads the next 
(E2) are independent events because
P(E1 d E2) = 1/4
P(E1) = 1/2, P(E2) = 1/2
so Equation (2) is satisfied. If we toss a fair coin repeatedly and the coin lands 4 or 
5 or 6 times in a row heads up, we may feel that tails is “due to come up,” in other 
words, that at the next toss the coin has a better than 50% probability of coming up 
tails, but in fact that’s not the case. It is true that the probability of getting longer 
and longer runs of heads decreases from 1/4 (two heads) to 1/8 (three heads) to 
1/16 (four heads), and so forth, yet on each successive toss, the probability of get-
ting a head is still 1/2.

308	
Sets, Combinatorics, and Probability 
At this point we have what might be called an addition rule and a multiplica-
tion rule for probability, loosely related to the addition principle and the multi-
plication principle for counting. If we want the probability of event E1 or event 
E2, that is, P(E1 c E2), we can add the respective probabilities—but only if the 
events are disjoint. If we want the probability of event E1 and event E2, that is,  
P(E1 d E2), we can multiply the respective probabilities—but only if the events 
are independent.
Bayes’ Theorem
Bayes’ theorem allows us to squeeze an additional probability out of a certain set 
of known probabilities. Before we state the theorem, let’s look at an example.
	
Example 73	
A grocery store receives an order from Supplier A that consists of 57% lettuce and 
43% spinach. It also receives an order from Supplier B that consists of 39% lettuce 
and 61% spinach. Before the orders are unloaded, a clerk randomly selects an order 
box and pulls out a package of produce to show to the produce manager. Later the 
grocer is notified that spinach from Supplier B is contaminated. If the clerk pulled out 
a package of spinach, what is the probability that it came from Supplier B?
Let E1 be the event that the package came from Supplier A and E2 be the event 
that the package came from Supplier B. Let F be the event that the package was 
spinach. The sample space looks something like
{AL1, AL2, AL3, …, AS1, AS2,AS3, …, BL1, BL2,BL3, …, BS1, BS2, BS3 …}
E1 and E2 are disjoint events and E1 c E2 = S.
We know that
	
P(E1) = 1/2	
(equally likely that either box was chosen)
	
P(E2) = 1/2
	
P(F 0 E1) = 43/100	
(percentage of spinach in Supplier A order)
	
P(F 0 E2) = 61/100	
(percentage of spinach in Supplier B order)
and we want
	
P(E2 0 F)	
(probability the package came from Supplier B 
given that it was spinach)
Although we know that the probability of the clerk choosing the Supplier B ­order 
box is 0.5, we suspect that P(E2 0 F ) is greater than 0.5 because the item was ­spinach 
and Supplier B has a higher percentage of spinach than Supplier A. It turns out that 
we can compute this probability by sufficient fiddling with the ­probabilities we do 
have.
From the definition of conditional probability,
P(E2 0  F ) = P(F d E2)
P(F)
 or P(F d E2) = P(E2 0  F )P(F )
REMINDER
P(E1c E2) = P(E1)+P(E2) 
only when E1 and E2 are 
disjoint events. P(E1 d E2) 
= P(E1) # P(E2) only when 
E1 and E2 are independent 
events.

Section 4.6   Probability	
309
P(F 0  E2) = P(E2 d F )
P(E2)
 or P(E2 d F ) = P(F 0  E2 )P(E2)
Because F d E2 = E2 d F, P(F d E2) = P(E2 d F) and therefore
P(F d E2) = P(F 0 E2)P(E2) [and a similar equation for P(F d E1)]
and
P(E2 0  F) = P(F d E2)
P(F)
= P(F 0  E2)P(E2)
P(F)
F is another event in (that is, subset of) S, and
F = F d S = F d (E1 c E2) = (F d E1) c (F d E2)
so F is the union of disjoint events, and
	
P(F ) = P(F d E1) + P(F d E2) = P(F 0 E1)P(E1)+ P(F 0 E2)P(E2)
	
= 43
100
# 1
2 + 61
100
# 1
2 = 43 + 61
200
= 104
200
Finally,
P(E2 0  F ) = P(F 0  E2)P(E2)
P(F )
= (61∙100)(1∙2)
104∙200
= 61∙200
104∙200 = 61∙104 > 0.587
As we suspected, the probability that the spinach came from the contaminated 
batch is greater than 0.5.
The general statement of Bayes’ theorem (see Exercise 89) follows.
	
Theorem	
Bayes’ Theorem
Let E1, … , En be disjoint events from a sample space S whose union equals S. If 
F is another event from S, then the probability of event Ei, 1 ≤ i ≤ n, given event 
F, is
P(Ei 0  F) =
P(F 0  Ei)P(Ei)
∙
n
k=1
P(F 0  Ek)P(Ek)
Practice 46	 In Example 73, what is the probability that the package came from Supplier A if it was  
lettuce?
■

310	
Sets, Combinatorics, and Probability 
Expected Value
A student takes three tests; the set of grades received is S = {g1, g2, g3}. The 
­student computes the average test grade A(g) by
 A(g) = g1 + g2 + g3
3
This assumes that the three tests are equally weighted. If we write
A(g) = 1
3 (g1 + g2 + g3) = g1a1
3b + g2a1
3b + g3a1
3b
we can also see that A(g) is the sum of the product of each test grade times the 
amount of its contribution to the total grade. If the last test counts twice as much 
as the other two, then the “weighted average” grade would be
A(g) = 1
4 (g1 + g2 + 2g3) = g1a1
4b + g2a1
4b + g3a2
4b
If we consider S as the sample space and assign the probability distribution
xi
g1
g2
g3
p(xi)
1/4
1/4
2/4
then
	
A(g) = ∙
3
i=1
gi p(gi)	
(3)
We want to take the weighted average idea of Equation (3) and make it a 
bit more general. For the test grades, the sample space S consisted of numerical 
values. If the values in the sample space are not numerical, we may find a func-
tion X that associates a numerical value (a real number) with each element in the 
sample space. Such a function is called a random variable.3 Given a sample space  
S = {x1, x2, …, xn} to which a random variable X and a probability distribution 
p have been assigned, the expected value or weighted average of the random  
variable is
E(X ) = ∙
n
i=1
X(xi)p(xi)
3The term “random variable” is a misnomer because X is neither random nor a variable—it’s a function that 
associates with each value xi in S a real number X(xi)

Section 4.6   Probability	
311
	
Example 74	
A fair coin is tossed three times. The sample space S is
S = {HHH, HHT, HTH, HTT, THH, THT, TTH, TTT}
Let the random variable X assign to each outcome in S the number of heads in that 
outcome, which will be an integer value between 0 and 3. Because this is a fair 
coin, each member of S occurs with equal probability, which determines the prob-
ability distribution. Hence we can write
xi
HHH
HHT
HTH
HTT
THH
THT
TTH
TTT
X(xi)
3
2
2
1
2
1
1
0
p(xi)
1/8
1/8
1/8
1/8
1/8
1/8
1/8
1/8
The expected value of X, that is, the expected number of heads in three tosses, is
E(X ) = ∙
8
i=1
X(xi)p(xi)
= 3(1/8) + 2(1/8) + 2(1/8) + 1(1/8) + 2(1/8) + 1(1/8) + 1(1/8) + 0(1/8)
= 12(1/8) = 3/2 = 1.5
This seems intuitively correct; because the coin is fair, we would expect to get 
heads about half the time, or 1.5 times out of 3. (Of course, we really can’t get half 
a head, but if we get heads about half the time, then we expect to get 4 heads out of 
8 tosses, or 64 heads out of 128 tosses, and so forth.) Note how the expected value 
is a “predictor” of future outcomes.
Now suppose the coin is weighted in such a way that it is three times more 
likely to come up heads. In other words, the probability of a head is 3/4 while the 
probability of a tail is 1/4. The elements in the sample space are no longer equally 
likely, but we can compute their probability distribution. We know that the succes-
sive tosses are independent events, so the probability of each outcome in S can be 
obtained by multiplying the probability of each toss. The probability of HTT, for 
example, is
a3
4b a1
4b a1
4b = 3
64
The new table looks like
xi
HHH
HHT
HTH
HTT
THH
THT
TTH
TTT
X(xi)
3
2
2
1
2
1
1
0
p(xi)
27/64
9/64
9/64
3/64
9/64
3/64
3/64
1/64
and the new expected value for X is

312	
Sets, Combinatorics, and Probability 
E(X  ) = ∙
8
i=1
X(xi)p(xi)
= 3(27/64) + 2(9/64) + 2(9/64) + 1(3/64) + 2(9/64) + 1(3/64) + 1(3/64) + 0(1/64)
= 144/64 = 2.25
The expected number of heads is now higher because the coin is much more likely 
than before to come up heads.
Practice 47	 Given the following table for a sample space, a random variable X, and a probability 
­distribution p, find the expected value for X.
xi
x1
x2
x3
x4
X(xi)
5
2
3
7
p(xi)
2/8
3/8
2/8
1/8
■
Expected value has a property called linearity. If X1 and X2 are two random 
variables on the same sample space S and a and b are real numbers, then
	
E(X1 + X2) = E(X1) + E(X2)	
(4)
	
E(aX1 + b) = aE(X1) + b	
(5)
Keep in mind that for any xi in S, X1(xi) and X2(xi) are both numerical values that 
can be added, so the random variable X1 + X2 just means that (X1 + X2)(xi) = 
X1(xi) + X2(xi). Similarly, if a and b are real numbers, then aX1 + b just means 
that (aX1 + b)(xi) = aX1(xi) + b. Then Equation (4) is true because
E(X1 + X2) = ∙
n
i=1
(X1 + X2)(xi)p(xi) = ∙
n
i=1
(X1(xi) + X2(xi))p(xi)
= ∙
n
i=1
X1(xi)p(xi) + ∙
n
i=1
X2(xi)p(xi) = E(X1) + E(X2)
Equation (4) extends to any finite sum of random variables. Equation (5) is true 
because (note that ∙
n
i=1
p(xi) = 1)
E(aX1 + b) = ∙
n
i=1
(aX1 + b)(xi)p(xi) = ∙
n
i=1
(aX1(xi) + b)p(xi)
= a∙
n
i=1
X1(xi)p(xi) + b∙
n
i=1
p(xi) = aE(X1) + b(1)
Use of linearity can sometimes simplify the calculation of an expected value (see 
Exercise 94).

Section 4.6   Probability	
313
Binomial Distributions
Consider an event that has only two possible outcomes, success or failure. The 
probability of success is p and the probability of failure q = 1 − p. Our well-
known coin toss would fit this description because there are only two possible 
outcomes. Such an event is called a Bernoulli trial or Bernoulli experiment 
after the eighteenth-century Swiss mathematician Jacob (or James) Bernoulli. 
However, a single Bernoulli trial is not of much interest; instead we want to talk 
about a finite series of Bernoulli trials, each of which has the same probability p of 
success (hence the same probability q = 1 − p of failure). Because the probability 
of ­success does not vary, the various trials are mutually independent events.
Without specifically describing the sample space S, we can define a random 
variable X as the number of successful outcomes that occur in the n trials. X can 
range from 0 (no successful outcomes) to n (all successful outcomes). We can de-
termine the probability of k successful outcomes out of n trials as follows:
Assume the k successes (and (n − k) failures) occur in some specific pattern. 
For example if k = 3 and n = 4, one pattern would look like S-F-S-S. The prob-
ability of a success is p, the probability of a failure is q. Because the n trials are 
mutually independent, we can multiply their probabilities, giving pkqn−k. But this 
is only one pattern of k successes; how many patterns are there? Exactly the num-
ber of ways we can select k out of n items, C(n, k). So the probability of k success-
ful outcomes out of n trials is
P(k) = C(n, k)pkqn−k
We have therefore determined a probability distribution for the various values of 
X, as shown in this table:
X = k
0
1
2
c
k
c
n
P(k)
C(n, 0) p0qn C(n,1)pqn−1 C(n,2)p2qn−2
C(n,k)pkqn−k
C(n,n)pnq0
Look at the values in this probability distribution. They are the terms in the expan-
sion of (q + p)n. Hence this is called a binomial distribution.
Notice that because q + p = 1, the sum of the probability distribution terms 
equals 1n = 1. This makes sense because the various values of X are all disjoint so 
the probability of their union is the sum of their individual probabilities. But the 
union covers all possible outcomes, so its probability is 1.
	
Example 75	
A fair coin is tossed three times, with heads being considered a success, tails being 
considered a failure. Here n = 3 and p = q = 1/2. The binomial distribution is
k
0
1
2
3
P(k)
(1/2)3 = 1/8
3(1/2)(1/2)2 = 3/8
3(1/2)2(1/2) = 3/8
(1/2)3 = 1/8
Note that this table contains the same information as the table in Example 74, 
­except that here we don’t care about the order in which the heads occur.
To compute E(X ),
E(X ) = 0(1/8) + 1(3/8) + 2(3/8) + 3(1/8) = 12/8 = 1.5
again agreeing with the result in Example 74.

314	
Sets, Combinatorics, and Probability 
Practice 48	 From the expected value in Example 75, we “expect” to get 100 heads if we toss a fair coin 
200 times. Find the actual probability of getting 100 heads out of 200 trials.
■
Average Case Analysis of Algorithms
Previously, we have done primarily worst-case analysis of algorithms (Section 3.3). 
Expected value may help give an average case analysis of an algorithm, i.e., tell 
us the expected “average” amount of work performed by an algorithm. As in any 
algorithm analysis, the first step is to identify a suitable “unit of work” based on 
the nature of the algorithm. Then let the sample space S be the set of all possible 
inputs to the algorithm. We’ll assume that S is finite; while there may be an infinite 
number of distinct input values, we can group together those with the same work 
unit characteristics. Let the random variable X assign to each member of S the 
number of work units required to execute the algorithm on that input. And let p 
be a probability distribution on S (here is where we make assumptions about what 
constitutes “average” input). Then
E(X ) = ∙
n
i=1
X(xi)p(xi)
gives the expected number of work units.
	
Example 76	
Consider the sequential search algorithm (Section 3.3). The work unit is the num-
ber of comparisons of a target element x against the n elements in a list. Assume 
that the target element is in the list and is equally likely to be any of the n elements 
of the list (see Exercise 35 of Section 3.3). This assumption gives the table
xi
L1
L2
c
Ln
X(xi)
1
2
c
n
p(xi)
1/n
1/n
c
1/n
Then
E(X ) = ∙
n
i=1
X(xi)p(xi)
= ∙
n
i=1
ia1
nb = 1
n ∙
n
i=1
i = 1
n (1 + 2 + c+ n) = 1
n n(n + 1)
2
= n + 1
2
The average number of comparisons to find a target in the list, with a uniform 
probability distribution, is a little more than half the length of the list.

Section 4.6   Probability	
315
S e c t i o n  4 . 6 	
Review
Techniques
•	 Compute the probability of an event when all out-
comes of an action are equally likely.
•	 Compute the probability of an event when a prob-
ability distribution has been assigned to the sample 
space.
•	 Compute the conditional probability of an event 
given that another event has already occurred.
•	 Determine whether two events are independent.
•	 Given a sample space with a random variable x and 
a probability distribution, compute the expected 
value E(X ).
Main Ideas
•	 An event is a subset of the set of all possible out-
comes of some action.
•	 For equally likely outcomes, the probability of an 
event is the ratio of the number of outcomes in the 
event to the number of all possible outcomes.
•	 In the conditional probability of event E2 given that 
event E1 has already taken place, the sample space 
is reduced to E1.
•	 Events E1 and E2 are independent if and only if the 
conditional probability of E2 given E1 is the same 
as the probability of E2.
•	 In the simplest form of Bayes’ theorem, the prob-
ability of event A given event B can be computed 
from the probability of A, the probability of B, and 
the probability of B given A.
•	 Given a sample space to which a random variable 
and a probability distribution have been assigned, 
the expected value of the random variable is a pre-
dictor of its future value.
•	 An average case analysis of an algorithm is the 
­expected value of work units over the sample 
space of all inputs; the probability ­distribution re-
flects the assumptions being made about “­average” 
input.
W
W
Exercises 4.6
Exercises 1−6 concern three coins tossed at the same time, each equally likely to come up heads or tails.
	
1.	What is the size of the sample space?
	
2.	What is the probability of getting 1 head and 2 tails?
	
3.	What is the probability of getting all tails?
	
4.	What is the probability that no coin comes up heads?
	
5.	What is the probability of getting all tails or all heads?
	
6.	What is the probability of getting all tails and all heads?
In Exercises 7−14, a pair of fair dice is rolled.
	
7.	What is the size of the sample space?
	
8.	What is the probability of getting “snake eyes” (two 1s)?
	
9.	What is the probability of getting doubles (the same number on each die)?
	 10.	What is the probability of getting a 1 on at least one die?
	 11.	What is the probability of getting a total of 7 on the two dice?
	 12.	What is the probability of getting two consecutive values, such as 3−4, on the two dice?
	 13.	What is the probability of getting a total on the two dice greater than 10?
	 14.	What is the probability of getting a total on the two dice that is an odd number?

316	
Sets, Combinatorics, and Probability 
Exercises 15−18 concern 3 people participating in a race, with each participant equally likely to either ­finish 
the race or drop out of the race.
	 15.	What is the size of the sample space?
	 16.	What is the probability of exactly 1 participant finishing the race?
	 17.	What is the probability of no one finishing the race?
	 18.	What is the probability of at least 2 of the participants finishing the race?
Exercises 19−24 concern a single card drawn from a standard 52-card deck. A standard deck has 13 cards from 
each of 4 suits (clubs, diamonds, hearts, spades). The 13 cards have face value 2 through 10, jack, queen, king, 
or ace. Each face value is a “kind” of card. The jack, queen, and king are “face cards.”
	 19.	What is the probability of drawing a diamond?
	 20.	What is the probability of drawing a queen?
	 21.	What is the probability of drawing the queen of diamonds?
	 22.	What is the probability of drawing a queen or a diamond?
	 23.	What is the probability of drawing a black card?
	 24.	What is the probability of drawing a card with a value less than 4 (aces count low)?
Exercises 25−36 concern 2-card hands from a standard 52-card deck. A standard deck has 13 cards from each of 
4 suits (clubs, diamonds, hearts, spades). The 13 cards have face value 2 through 10, jack, queen, king, or ace. 
Each face value is a “kind” of card. The jack, queen, and king are “face cards.”
	 25.	What is the size of the sample space?
	 26.	What is the probability that both cards are the same suit?
	 27.	What is the probability that neither card is a spade?
	 28.	What is the probability that both cards are spades?
	 29.	What is the probability that exactly 1 card is a spade?
	 30.	What is the probability that at least 1 card is a spade?
	 31.	What is the probability that both cards are face cards?
	 32.	What is the probability that exactly 1 card is a face card?
	 33.	What is the probability that both cards are spade face cards?
	 34.	What is the probability that both cards are either face cards or spades?
	 35.	How does the answer to Exercise 30 relate to the answers for Exercises 28 and 29?
	 36.	How does the answer to Exercise 30 relate to the answer for Exercise 27?
Exercises 37−40 concern possible games in the Hoosier lottery, the Indiana state lottery.
	 37.	In the Daily 3 game, three numbers between 0 and 9 will be drawn in succession (repetitions allowed). 
The player marks three numbers on a game card and has a choice of how to play, straight (the player’s 
numbers will match the three numbers drawn in exact order) or box (the player’s numbers will match the 
three drawn in any order).
	
a.	 What is the size of the sample space?
	
b.	What is the probability of a straight?
	
c.	 What is the probability of a box if 3 distinct numbers are drawn?
	
d.	What is the probability of a box if 2 of the numbers drawn are the same?

Section 4.6   Probability	
317
	 38.	In the Daily4 game, four numbers between 0 and 9 will be drawn in succession (repetitions allowed). The 
player marks four numbers on a game card and has a choice of how to play, straight (the player’s numbers 
will match the four numbers drawn in exact order) or box (the player’s numbers will match the four drawn 
in any order).
	
a.	 What is the size of the sample space?
	
b.	What is the probability of a straight?
	
c.	 What is the probability of a box if four distinct numbers are drawn?
	
d.	What is the probability of a box if two of  the numbers drawn are the same?
	
e.	 What is the probability of a box if two distinct pairs of numbers are drawn?	
	
f.	 What is the probability of a box if three of the numbers drawn are the same?
	 39.	In the Cash5 game, five different numbers between 1 and 39 will be drawn in succession. The player 
marks five different numbers between 1 and 39 on a game card.
	
a.	 What is the size of the sample space?
	
b.	What is the probability of matching all five numbers in any order?
	
c.	 What is the probability of matching exactly four of the five numbers in any order?
	
d.	What is the probability of matching exactly three of the five numbers in any order?
	 40.	In the Powerball game, five different numbers between 1 and 59 will be drawn in succession, and then one 
number (the Powerball number) between 1 and 35 will be drawn. The player marks five different numbers 
between 1 and 59 and one number between 1 and 35 on a game card.
	
a.	 What is the size of the sample space?
	
b.	What is the probability of matching all five numbers in any order plus matching the Powerball number?
	
c.	 What is the probability of matching none of the five numbers but matching the Powerball number?
Exercises 41−50 concern 5-card poker hands from a standard 52-card deck. A standard deck has 13 cards from 
each of 4 suits (clubs, diamonds, hearts, spades). The 13 cards have face value 2 through 10, jack, queen, king, 
or ace. Each face value is a “kind” of card. The jack, queen, and king are “face cards.” (See Exercises 33−41 
of Section 4.4. for the definitions of terms.)
	 41.	What is the probability of a royal straight flush?
	 42.	What is the probability of a straight flush that is not a royal straight flush?
	 43.	What is the probability of four of a kind?
	 44.	What is the probability of a full house?
	 45.	What is the probability of a flush that is not a straight flush or a royal straight flush?
	 46.	What is the probability of a straight that is not a straight flush or a royal straight flush?
	 47.	What is the probability of three of a kind?
	 48.	What is the probability of two pairs?
	 49.	What is the probability of a pair?
	 50.	Explain why, in poker,
	
a.	 a straight flush beats a full house.
	
b.	four of a kind beats a straight.

318	
Sets, Combinatorics, and Probability 
Exercises 51−56 relate to the well-known “birthday problem.” Consider a room containing n persons, each of 
whom has a birthday equally likely to fall on day 1−365 of the year (ignoring leap years).
	 51.	What is the size of the sample space of all possible assignments of birthdays to people?
	 52.	Let E be the event that no 2 persons in the room have the same birthday. Find an expression for P(E).
	 53.	Let B be the event that 2 or more persons in the room share the same birthday. Find an expression for P(B).
	 54.	Let C be the event that exactly 2 persons in the room share the same birthday. Find an expression for P(C ).
	 55.	Which has the larger probability, B or C, and why?
	 56.	Use a spreadsheet or calculator to determine that 23 is the minimum number of people in the room to give 
a probability of least 1/2 that 2 or more people share the same birthday.
Exercises 57−62 refer to the gambling game of roulette. A roulette wheel contains 18 black slots and 18 red 
slots that are numbered (not sequentially) 1−36. There are two green slots numbered 0 and 00. The dealer spins 
the wheel and spins a ball into the wheel in the opposite direction. Bets are made on which slot the ball will fall 
into as the wheel slows to a stop. The ball is equally likely to fall into any slot.
	 57.	What is the size of the sample space?
	 58.	What is the probability that the ball lands in a red slot (a “red” bet)?
	 59.	What is the probability that the ball lands in a specific numbered slot (a “straight up” bet)?
	 60.	What is the probability that the ball lands on one of three specific numbers (a “street” bet)? 
	 61.	What is the probability that the ball lands on one of four specific numbers (a “corner” bet)?
	 62.	What is the probability that the ball lands on an odd number three times in a row?
	 63.	A woman in Lake Havasu City, Arizona, gave birth to twin girls on September 22, 2006. This happened 
to be the same date as the woman’s birthday—and the same date as her mother’s birthday. What is the 
probability that three generations share the same birthday?
	 64.	The NCAA men’s Division I college basketball championship (known as “March Madness”) is a single-
elimination tournament held in March of each year. The tournament begins with 68 teams. The structure 
of the tournament is as follows; the loser of each game is eliminated:
	
	What is the probability of correctly picking the championship team? (Assume that all teams are equally 
likely to win their respective games.)
Name of the Round
Number of Teams
Number of Games 
The First Four
  8
  4
Round of 64
64
32
Round of 32
32
16
Sweet Sixteen
16
  8
Elite Eight
  8
  4
Final Four
  4
  2
Championship Game
  2
  1

Section 4.6   Probability	
319
	 65.	Bridge is a card game played by four players with a standard 52-card deck. All 52 cards are dealt to the 
four players at the beginning of each hand. In 1963, women playing bridge in Kankakee, Illinois, discov-
ered that after the deal, each player held the 13 cards of a single suit. What is the probability of one player 
being dealt an entire suit?
	 66.	Referring to Exercise 65, what is the probability of each of the four players being dealt an entire suit?
	 67.	E1 and E2 are events from the same sample space; P(E1) = 0.37, P(E2) = 0.45, and P(E1 d E2) = 0.14. 
	
a.	 Find the probability that E2 does not occur.
	
b.	Find the probability that either E1 or E2 occurs.
	
c.	 Find the probability that neither E1 nor E2 occurs.
	 68.	An 8-letter password is automatically generated from the 26 lowercase letters of the English alphabet. 
Each letter is equally likely to be used, and letters can be repeated.
	
a.	 What is the size of the sample space?
	
b.	Find the probability that the word does not contain an “e.”
	
c.	 Find the probability that the word contains at least one “e.”
	
d.	Find the probability that the word contains a single “e.”
	
e.	 Find the probability that the word contains both a single “h” and a single “x.”
	
f.	 Find the probability that the word contains either a single “h” or a single “x.”
	 69.	A loaded die has the following probability distribution:
	
	When the die is rolled, let E1 be the event that the number rolled is odd, let E2 be the event that the number 
rolled is 3 or 6, and let E3 be the event that the number rolled is 4 or more.
	
a.	 Find P(E1).
	
b.	Find P(
2).
	
c.	 Find P(E3).
	
d.	Find P(E2 d E3).
	
e.	 Find P(E1 c E3).
	 70.	A congressional race has a Democratic, a Republican, and an Independent candidate in a district where 
past voting patterns indicate that a Democrat is twice as likely to be elected as a Republican, and that a 
Republican is four times as likely to be elected as an Independent.
	
a.	 Find the appropriate probability distribution.
	
b.	What is the probability that a Democrat will be elected?
	
c.	 What is the probability that a Republican will not be elected?
	 71.	At a certain school, 72% of the students play one or more sports. The percentage of students who play 
one or more sports and who graduate is 67%. Find the probability that a student graduates given that the 
student plays one or more sports.
xi
1
2
3
4
5
6
p(xi)
0.2
0.05
0.1
0.2
0.3
0.15

320	
Sets, Combinatorics, and Probability 
	 72.	On a particular manufacturing job, the probability that there will be a shortage of copper is 0.37. The prob-
ability that there will be a shortage of both copper and aluminum is 0.28. Find the probability of a shortage 
of aluminum given a shortage of copper.
	 73.	In Example 71,
	
a.	 What is the probability that a patient responds positively to compound A given that he or she responds 
positively to B?
	
b.	What is the probability that a patient responds positively to either compound A or compound B?
	
c.	 What is the probability that a patient does not respond positively to either compound?
	 74.	A food magazine surveys the preferences of its readers who like Asian food. The findings follow.
47% like Thai food	
(E1)
39% like Indian food	
(E2)
78% like Chinese food	
(E3)
23% like both Thai and Indian food
31% like both Indian and Chinese food
29% like both Thai and Chinese food
	
a.	 Extend observation 5 in Table 4.3 to the case of three events, E1, E2, and E3.
	
b.	Find the probability that a reader likes all three types of food.
	
c.	 Find the probability that a reader likes Chinese food given that the reader likes Indian food.
For Exercises 75−80, a student takes a true−false quiz with four questions, each equally likely to be either T or F.
	 75.	What is the probability of getting exactly one question wrong?
	 76.	What is the probability of getting Question 1 correct?
	 77.	What is the probability of getting three or more questions correct?
	 78.	What is the probability of getting the first two questions correct?
	 79.	What is the probability of getting the first two questions correct given that the answer to Question 1 is 
correct?
	 80.	What is the probability of getting all four questions correct given that the answers to the first two questions 
are correct?
For Exercises 81−88, a family has 3 children; boys and girls are equally likely offspring.
	 81.	What is the probability that the oldest child is a boy?
	 82.	What is the probability that the youngest two children are girls?
	 83.	What is the probability of 2 boys and 1 girl?
	 84.	What is the probability of no girls?
	 85.	What is the probability of at least 1 girl?
	 86.	What is the probability of 3 girls?
	 87.	What is the probability of 3 girls given that the first 2 are girls?
	 88.	What is the probability of at least 1 boy and at least 1 girl given that there is at least 1 boy?

Section 4.6   Probability	
321
	 89.	Prove Bayes’ theorem. The proof parallels what was done in Example 73. Let E1, …, En be disjoint events 
from a sample space S whose union equals S. If F is another event from S, then Bayes’ theorem says that 
the probability of event Ei, 1 ≤ i ≤ n, given event F, is
P(Ei 0  F ) =
P(F 0  Ei)P(Ei)
∙
n
k=1
P(F 0  Ek)P(Ek)
	
a.	 Use the definition of P(Ei 0 F ) and P(F 0 Ei) to prove that
P(Ei 0  F ) = P(F 0  Ei)P(Ei)
P(F )
	
b.	Prove that
P(F ) = ∙
n
k=1
P(F d Ek)
	
c.	 Use the definition of P(F 0 Ei) and the result from part (b) to prove that
P(F ) = ∙
n
k=1
P(F 0  Ei)P(Ei)
	
d.	Using parts (a) and (c), prove Bayes’ theorem.
	 90.	Toys for boys and for girls are donated to a benefit event by two groups. The Lakeville Do-Gooders 
­donated 5 toys for boys and 7 for girls. The Southside Champions Club donated 6 toys for boys and 5 for 
girls. The master of ceremonies pulls the first toy out of a bin and it’s a toy for a boy. Find the probability 
that it was donated by the Do-Gooders.
	 91.	An online pharmacy sells an over-the-counter drug, medication X, that is used for a variety of purposes. 
The pharmacy has data that say that 18% of its customers are HIV positive, 9% of its HIV-positive cus-
tomers buy medication X, and 3% of the customers who are not HIV positive buy medication X. Find the 
probability that a customer who buys medication X is HIV positive. The pharmacy can use this data to 
shape its marketing/advertising plan.
	 92.	Of the high blood pressure patients in a particular clinic, 62% are treated with medication X, the remainder 
with medication Y. It is known that 1.4% of patients using medication X suffer from fainting spells, as do 
2.9% of the patients using medication Y. A patient known by the clinic to have high blood pressure suffers 
a fainting spell, but she does not remember which medication she is on. Which medication is she most 
likely to be taking? (Hint: Let E1 and E2—treated with X and treated with Y, respectively—be events in 
the sample space of all patients with high blood pressure in the clinic, and let F be the event of fainting; 
find P(X 0 F ) and P(Y 0 F ).)
	 93.	a.	 A fair die is rolled once. Let the random variable X equal the value that comes up. Find the expected 
value of X, E(X ).
	
b.	The die is now “loaded” so that a 2 comes up twice as often as any other number. Find the new expected 
value of X.
	
c.	 Your answer to part (b) should be (greater than, less than) your answer to part (a). Explain why.

322	
Sets, Combinatorics, and Probability 
	 94.	Two fair dice are rolled. The sample space S contains the 36 combinations of two numbers. For each mem-
ber (r, s) of S, the random variable X(r, s) = r + s.
	
a.	 Write a table showing the values for X and the probability of those values; instead of 36 columns each 
with probability 1/36, do a column for each distinct value of X and show the probability of that value.
	
b.	Find the expected value of the sum of the numbers that come up when two fair dice are rolled.
	
c.	 Find the expected value of the sum of the numbers that come up when two fair dice are rolled. This 
time let the sample space S consist of the ordered pairs (r, s) that can appear on the two dice. Use two 
different random variables over this sample space, where X1 = the value of the first component of the 
ordered pair and X2 = the value of the second component of the ordered pair. Make use of the linearity 
property from Equation (4).
	 95.	At a gambling casino, a ball will be drawn from a bin containing 43 red balls, 27 green balls, and 8 blue 
balls. A player marks a game card with the color he or she believes will be picked. The prize money for 
guessing the correct color is
	
	 Red	
$3.00
	
	 Green	
$6.00
	
	 Blue	
$10.00
	
	The price of the game card is $5.00. Find the expected value of the prize money.
	 96.	A directory on a computer’s hard disk contains 12 files, 3 of which have viruses. If a file with a virus is 
selected, the virus is detected and another file is then selected. Find the expected number of files that must 
be selected in order to get a virus-free file.
	 97.	Bit strings are sent across a computer network in packets of length 10. The probability of a bit getting cor-
rupted (that is, a 0 gets changed to a 1 or vice versa) is 0.01. These bit errors are independent.
	
a.	 Find the probability that in a single packet there are no bit errors. (Hint: It’s OK to call a bit error a 
“success.”)
	
b.	Find the probability that there are no more than two bit errors.
	
c.	 Find the probability that there is at least one bit error.
	 98.	Of the items produced in a certain manufacturing facility, 5% are defective. If 8 items are chosen at ran-
dom, find the probability that
	
a.	 1 is defective.
	
b.	2 are defective.
	
c.	 none is defective.
	
d.	at least 1 is defective.
	
e.	 at most 1 is defective.
	 99.	A student has failed to study for a true−false test and guesses at every one of the 10 questions. If the pass-
ing grade is 8 correct answers, what is the probability that the student will pass the quiz?
	100.	A baseball player has a probability p = 0.04 of hitting a home run for each at bat. Find the minimum 
number of at bats he must take so that there is at least an 80% probability of hitting a home run (that is, at 
least 1 home run).
	101.	Find the average number of comparisons to search for a target element x using the sequential search al-
gorithm under the assumption that x is equally likely to be at any of the n positions in the list or not in the 
list.
	102.	Find the average number of comparisons to search for a target element x using the sequential search algo-
rithm under the assumption that x is not in the list 80% of the time, but if x is in the list it is equally likely 
to be at any of the n positions.

C h a p t e r  4 	
Review
Terminology
addition principle (p. 254)
Bayes’ theorem (p. 309)
Bernoulli trial (p. 313)
Bernoulli experiment (p. 313)
binary operation (p. 229)
binomial coefficient (p. 297)
binomial distribution (p.313)
binomial theorem (p. 296)
Cantor’s diagonalization method 
(p. 237)
cardinality of a set (p. 236)
Cartesian product (cross product) 
of sets (p. 233)
closed set under an operation  
(p. 229)
combination (p. 274)
combinatorial proof (p. 296)
combinatorics (p. 252)
complement of a set (p. 232)
conditional probability (p. 307)
countable set (p. 236)
decision tree (p. 257)
denumerable set (p. 236)
disjoint sets (p. 232)
dual of a set identity (p. 235)
empty set (p. 224)
equal sets (p. 223)
event (p. 302)
expected value (p. 310)
finite set (p. 223)
independent events (p. 307)
infinite set (p. 223)
intersection of sets (p. 231)
lexicographical ordering (p. 281)
linearity of expected value  
(p. 312)
multiplication principle (p. 253)
n factorial (p. 272)
null set (p. 224)
ordered pair (p. 228)
Pascal’s formula (p. 295)
Pascal’s triangle (p. 294)
permutation (p. 272)
pigeonhole principle (p. 269)
power set (p. 227)
principle of inclusion and 
exclusion (p. 267)
probability axioms (p. 304)
probability distribution (p. 305)
probability of an event (p. 302)
probability of an event E (p. 305)
proper subset (p. 225)
random variable (p. 310)
sample space (p. 302)
set difference (p. 232)
subset (p. 224)
unary operation (p. 230)
uncountable set (p. 236)
union of sets (p. 231)
universal set (p. 231)
universe of discourse (p. 231)
weighted average (p. 310)
well-defined operation (p. 229)
Self-Test
Answer the following true−false questions.
Section 4.1
1.	The empty set is a proper subset of every set.
2.	If A and B are disjoint sets, then (A − B) c (B − A) 
= A c B.
3.	If a set has n elements, then its power set has 2n 
elements.
4.	If a binary operation + on a set S is well-defined, 
then x + y [ S for all x and y in S.
5.	Cantor’s diagonalization method is a way to prove 
that certain sets are denumerable. 
Section 4.2
1.	According to the multiplication principle, the number 
of outcomes for a sequence of tasks is the product of 
the number of outcomes for each separate task.
2.	The addition principle finds the total number of 
branches of a decision tree.
3.	The addition principle requires the tasks at hand to 
have disjoint sets of outcomes.
4.	The multiplication principle says that the number of 
elements in A × B equals the number of ­elements in 
A times the number of elements in B.
5.	Any problem that requires a decision tree for its 
­solution cannot be solved by the multiplication 
principle.
Section 4.3
1.	The principle of inclusion and exclusion requires 
that A and B be disjoint sets in order to find the 
number of elements in A c B.
2.	The principle of inclusion and exclusion applied 
to two sets says that the number of elements in 
the union minus the number of elements in the 
intersection is the sum of the number of elements 
in each set.
Chapter 4   Review	
323

324	
Sets, Combinatorics, and Probability 
3.	The principle of inclusion and exclusion applies to 
the union of any number of sets as long as at least 
one of them is finite.
4.	The pigeonhole principle is a way to count the 
number of elements in the union of disjoint sets, or 
“pigeonholes.”
5.	The piegeonhole principle guarantees that if there 
are 8 people in a room, at least 2 must have been 
born on the same day of the week.
Section 4.4
1.	A permutation is an ordered arrangement of  
objects.
2.	The number of combinations of r objects out of n,  
r > 1, is fewer than the number of permutations of 
r objects out of n.
3.	To find the number of ways a subset of r objects can 
be selected from n objects, use the formula P(n, r).
4.	The number of permutations of the letters in a word 
with three sets of re­peated letters is n!/3.
5.	The formula C(r + n − 1, r) computes the number 
of combinations of r ob­jects out of n objects where 
objects may be used repeatedly.
Section 4.5
1.	Pascal’s triangle consists of rows that represent the 
number of ways to arrange r out of n objects for 
various r.
2.	Pascal’s formula says that an “interior” number 
in Pascal’s triangle is the sum of the two numbers  
directly above it in the triangle.
3.	In the expansion of a binomial to the nth power, the 
kth term is found in row k of Pascal’s triangle.
4.	A combinatorial argument is one that is based on 
counting techniques.
5.	The coefficient of the seventh term in the expansion 
of (a + b)12 is given by the expression C(12, 6).
Section 4.6
1.	The probability of an event always falls in the range 
between 0 and 1.
2.	In a sample space with n equally likely ­outcomes, 
the probability distribution is 1/n for each 
outcome.
3.	To find the probability of several events occur-
ring, multiply the probabilities of the individual 
events.
4.	A random variable is a variable whose value 
is randomly assigned using a random number  
generator.
5.	If E1 and E2 are disjoint events whose union 
equals the sample space, then Bayes’ theorem 
allows you to derive the conditional probability 
P(E1 0 F ) if you know P(F 0 E1), P(F 0 E2), P(E1) 
and P(E2).
O n  t h e  C o m p u t e r
For Exercises 1−10, write a computer program that 
produces the desired output from the given input.
1.	Input: Elements in a finite set S 
	
Output: Elements in ℘(S)
	
Algorithm: Use recursion.
2.	Input: Arithmetic expression in postfix notation 
(see Exercise 45 in Sec­tion 4.1)
	
Output: Value of the expression
3.	Input: Arithmetic expression in infix notation (see 
Exercise 45 in Section 4. 1)
	
Output: Postfix form of the expression
	
Do this problem in two ways: 
a.	 Assume that the input is fully parenthesized.
b.	 Do not assume that the input is fully parenthe-
sized, but apply the proper order of precedence 
of operators within the program (order of prece-
dence of operators is parenthesized expressions 
first, then exponentiation, then multiplication and 
division, then addition and subtraction).
4.	Input: Values for n and r, 0 ≤ r ≤ n
	
Output: Value of P(n, r)
5.	Input: Values for n and r, 0 ≤ r ≤ n 
	
Output: Value of C(n, r)
6.	Input: Value for n
	
Output: All values of C(n, r), 0 ≤ r ≤ n

Chapter 4   Review	
325
  7.	Input: Value for n
	
	 Output: All permutations of the integers 1, … , n
Here is an outline for an alternative to the algorithm 
given in Section 4.4 to generate the n! permutations 
of the integers {1, … , n}. Use a recursive algorithm. 
Once a permutation A of the integers 1, … , k − 1 
exists, permutations of the integers 1, … , k can be 
obtained by inserting integer k into every possible 
­position in A. Every time k = n, any permutation so 
obtained can be written out. Initiate the process by 
sending 1 to an empty permutation list. For the case  
n  =  3, for example, this algorithm successively  
traverses the branches of the tree and prints out the 
leaves.
1
2, 1
1, 2
3, 2, 1
2, 3, 1 2, 1, 3 3, 1, 2
1, 3, 2
1, 2, 3
  8.	Input: Values for a, b, and n
	
	 Output: Value of (a + b)n
	a.	 Use the binomial theorem to compute your 
­result.
	b.	Compute a  +  b and raise this value to the 
nth power; compare your answer with that of  
part (a).
  9.	Input: Values for a, b, n, and r, 1 ≤ r ≤ n + 1
	
	 Output: rth term in the expansion of (a + b)n
10.	Input: A random variable and a probability distri-
bution for a finite sample space.
	
	 Output: The expected value of the random ­variable.
11.	Write a program that allows the user to enter a 
value for n, 1 ≤ n ≤ 10, and then queries the user 
for the values needed on the right side of Equation 
(4) of Section 4.3 (the principle of inclusion and 
exclusion) and computes the value of
0  A1 c c c An0
12.	Write a program to generate a given number of 
rows of Pascal’s triangle. Do this problem in two 
ways.
a.	 Use the definition of Pascal’s triangle (and 
­perhaps use your answer to compute Exercise 
5 as a function).
b.	 Use recursion and Pascal’s formula.
13.	Benford’s law, also called the first-digit law, 
states that in many (but not all) large numerical 
data sets, the first digit is not equally likely to be 
1 through 9. In fact, the probability that the first 
digit equals 1, p(1), is about 30%, and the prob-
ability for each successive value of the first digit 
goes down until p(9) is about 4.6%. The formula 
for Benford’s law is
p(d ) = log10a1 + 1
db
	
	Evidence based on Benford’s law is admissible in 
court and has been used to help detect fraudulent 
data in accounting, economics, scientific research, 
and other areas.
a.	 Use the given formula to compute the prob-
ability of occurrence in the first digit of digits 
1−9.
b.	 Write a program to generate the first 200 Fibo-
nacci numbers and determine whether the first 
digits follow Benford’s law.

This page intentionally left blank 

Chapter Objectives
After studying this chapter, you will be able to:
•	 Identify ordered pairs related by a binary relation.
•	 Test a binary relation for the reflexive, symmetric, transitive, and antisymmet-
ric properties. 
•	 Find the reflexive, symmetric, and transitive closures of a binary relation.
•	 Recognize partial orderings and construct Hasse diagrams for them.
•	 Recognize an equivalence relation on a set and describe how it partitions the 
set into equivalence classes.
•	 Draw a PERT chart from a task table.
•	 Find the minimum time-to-completion and a critical path in a PERT chart.
•	 Extend a partial ordering on a finite set to a total ordering by doing a topologi-
cal sort.
•	 Understand the entity-relationship model and the relational model for an  
enterprise.
•	 Perform restrict, project, and join operations in a relational database.
•	 Create relational database queries in the languages of relational algebra, SQL, 
and relational calculus.
•	 Determine whether a binary relation is a function.
•	 Test a function for the onto and one-to-one properties.
•	 Create composite functions.
•	 Decide whether a function has an inverse function and what the inverse 
­function is.
•	 Manipulate cycle notation for permutation functions.
•	 Compute the number of functions, onto functions, and one-to-one functions 
from one finite set to another.
•	 Understand order of magnitude as a relative measure of function rate of growth.
•	 Build a hash table using a modulo hash function.
•	 Encode and decode messages using RSA public key encryption.
•	 Use the mod function to compute check digits for various identification codes.
•	 Perform matrix arithmetic on matrices of appropriate dimensions.
•	 Solve systems of linear equations using Gaussian elimination.
•	 Perform Boolean arithmetic operations on Boolean matrices of appropriate 
­dimensions. 
5
Relations, Functions,  
and Matrices
Chapter
327

328	
Relations, Functions, and Matrices 
Your company has developed a program for use on a small parallel processing 
­machine. According to the technical documentation, the program executes ­processes 
P1, P2, and P3 in parallel; these processes all need results from process P4, so they 
must wait for Process P4 to complete execution before they begin. Processes P7 and 
P10 execute in parallel but must wait until processes P1, P2, and P3 have finished. 
Process P4 requires results from P5 and P6 before it can begin execution. P5 and 
P6 execute in parallel. Processes P8 and P11 execute in parallel, but P8 must wait 
for Process P7 to complete and P11 must wait for process P10 to complete. Process 
P9 must wait for results from P8 and P11. You have been assigned to convert the 
­software for use on a single processor machine.
	
Question:	
In what order should the processes be executed?
Here various pairs of processes are related to one another by a “prerequisite” 
­relation. This is a special case of a binary relation, a relationship between pairs of 
elements within a set. We will study the various properties of binary relations in 
Section 5.1. One type of binary relation is called a partial ordering; elements re-
lated by a partial ordering can be represented graphically. Another type of binary 
relation is an equivalence relation; elements related by an equivalence relation can 
be grouped into classes.
A topological sort extends a partial ordering to a total ordering. For a par-
tial ordering of prerequisite tasks, a corresponding total ordering identifies the 
sequential order in which the tasks would have to be done, which is the solution 
to the parallel processing conversion problem. Topological sorting is presented in 
Section 5.2.
A generalization of a binary relation forms the basis for relational databases, 
considered in Section 5.3. Using operations of restrict, project, and join on the 
relations in a database, we can make various queries of the database.
A function is a special kind of binary relation. Functions, as well as relations, 
describe a number of real-world situations. Functions can also have special prop-
erties, as discussed in Section 5.4. Order of magnitude, presented in Section 5.5, 
provides a way to compare the growth rate of two functions and is useful in the 
analysis of algorithms. A simple function called the modulo function has a sur-
prising number of applications, ranging from encryption algorithms for computer 
security to the basis for artistic design patterns. Some of these applications are 
mentioned in Section 5.6.
In Section 5.7, we consider matrices and develop an arithmetic for manipulat-
ing them. Matrices provide a mechanism for solving systems of linear equations. 
We will later use matrices to represent relations and graphs. 
	
S e c t i o n  5 .1 	 Relations
Binary Relations
If we learn that two people, Henrietta and Horace, are related, we understand that 
there is some family connection between them—that (Henrietta, Horace) stands 
out from other ordered pairs of people because there is a relationship (cousins, sis-
ter and brother, or whatever) that Henrietta and Horace satisfy. The ­mathematical 

Section 5.1   Relations	
329
analogue is to distinguish certain ordered pairs of objects from other ordered pairs 
because the components of the distinguished pairs satisfy some relationship that 
the components of the other pairs do not.
	
Example 1	
Remember (Section 4.1) that the Cartesian product of a set S with itself, S × S 
or S2, is the set of all ordered pairs of elements of S. Let S = 51, 2, 36; then
S × S = 5(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)6
If we were interested in the relationship of equality, then (1, 1), (2, 2), (3, 3) would 
be the distinguished elements of S × S, that is, the only ordered pairs whose com-
ponents are equal. If we were interested in the relationship of one number being 
less than another, we would choose (1, 2), (1, 3), and (2, 3) as the distinguished 
ordered pairs of S × S.	
In Example 1, we could pick out the distinguished ordered pairs (x, y) by say-
ing that x = y or that x < y. Similarly, the notation x r y indicates that the ordered 
pair (x, y) satisfies a relation r. The relation r may be defined in words or by an 
equation or simply by listing the ordered pairs that satisfy r.
As in Example 2, one way to define the binary relation r is to specify a subset 
of S × S. Formally, this is the definition of a binary relation on a set.
	
Example 2	
Let S = 51, 2, 46. On the set S × S = 5(1, 1), (1, 2), (1, 4), (2, 1), (2, 2), (2, 4), 
(4, 1), (4, 2), (4, 4)6, a relation r can be defined by x r y if and only if x = y∙2, 
abbreviated x r y  4  x = y∙2 Thus (1, 2) and (2, 4) satisfy r. Alternatively, the 
same r could be defined by ­saying that 5(1, 2), (2, 4)6 is the set of ordered pairs 
satisfying r.	
	
Definition	
Binary Relation on a Set S
A binary relation on a set S is a subset of S × S (a set of ordered pairs of 
­elements of S ).
Now that we know that a binary relation r is a subset, we see that
x r y 4 (x, y) [ r
Generally, a binary relation is defined by describing the relation rather than by list-
ing the ordered pairs. The description gives a characterizing property of elements 
of the relation; that is, it is a binary predicate satisfied by certain ordered pairs. 
A binary relation implies a yes/no result—an ordered pair either does or does not 
satisfy the binary predicate and either does or does not belong to the relation.

330	
Relations, Functions, and Matrices 
	
Example 3	
Let S = 51, 26. Then S × S = 5(1, 1), (1, 2), (2, 1), (2, 2)6. Let r on S be ­given 
by the description x r y 4 x + y is odd. Then (1, 2) [ r and (2, 1) [ r. The 
­ordered pair (1, 1) o r because 1 + 1 is not odd. Similarly (2, 2) o r.	
	
Example 4	
Let S = 51, 26. Then S × S = 5(1, 1), (1, 2), (2, 1), (2, 2)6. If r is defined on S by 
r = 5(1, 1), (2, 1)6, then 1 r 1 and 2 r 1 hold, but not, for instance, 1 r 2. Here r 
seems to have no obvious verbal description.
In this section we will be concerned almost exclusively with binary relations 
on a single set, but more generally, relations can be defined on multiple sets.
	
Definition	
Relations on Multiple Sets
Given two sets S and T, a binary relation from S to T (also called a binary 
­relation on S × T) is a subset of S × T. Given n sets S1, S2, … , Sn, n > 2, an 
n-ary relation on S1 × S2 × c× Sn is a subset of S1 × S2 × c× Sn.
	
Example 5	
Let S = 51, 2, 36 and T = 52, 4, 76. Then the set
5(1, 2), (2, 4), (2, 7)6
consists of elements from S × T. It is a binary relation from S to T.	
■
Practice 1	 For each of the following binary relations r on N, decide which of the given ordered 
	
pairs belong to r.
a.	 x r y 4 x = y + 1; (2, 2), (2, 3), (3, 3), (3, 2)
b.	 x r y 4 x divides y; (2, 4), (2, 5), (2, 6)
c.	 x r y 4 x is odd; (2, 3), (3, 4), (4, 5), (5, 6)
d.	x r y 4 x > y2; (1, 2), (2, 1), (5, 2), (6, 4), (4, 3)	
If r is a binary relation on S, then r will consist of a set of ordered pairs of the 
form (s1, s2). A given first component s1 or second component s2 can be paired in 
various ways in the relation. The relation is one-to-one if each first component and 
each second component appears only once in the relation. The relation is one-to-
many if some first component s1 appears more than once; that is, one s1 is paired 
with more than one second component. It is many-to-one if some second compo-
nent s2 is paired with more than one first component. Finally, it is many-to-many 
if at least one s1 is paired with more than one second component and at least one 
s2 is paired with more than one first component. Figure 5.1 illustrates these four 
possibilities. Note that not all values in S need be components in ordered pairs of r.

Section 5.1   Relations	
331
S
S
S
S
S
S
S
S
One-to-one
One-to-many
Many-to-one
Many-to-many
Figure 5.1
These ideas extend to relations from a set S to a set T. The relation of Example 5 
is one-to-many because the first component 2 appears more than once; 2 from set 
S is associated with both 4 and 7 from set T.
Suppose B is the set of all binary relations on a given set S. If r and s belong 
to B, then they are subsets of S × S. As such, we can perform set operations 
of union, intersection, and complementation that result in new subsets of S × S, 
that is, new binary relations, which we will denote by r c s, r d s, and r′, 
­respectively. Thus
x (r c s)
 y 4 x r y or x s y
x (r d s) y 4 x r y and x s y
x r′ y 4  not x r y
Practice 3	 Let r and s be two binary relations on N defined by x r y 4 x = y and x s y 4 x < y. 
Give verbal descriptions for parts (a), (b), and (c); give a set description for part (d). 
a.	 What is the relation r c s?
b.	What is the relation r′?
c.	 What is the relation s′?
d.	What is the relation r d s?	
■
■
Practice 2	 Identify each of these relations on S, where S = 52, 5, 7, 96, as one-to-one, one-to-many, 
many-to-one, or many-to-many.
a.	 5(5, 2), (7, 5), (9, 2)6
b.	 5(2, 5), (5, 7), (7, 2)6
c.	 5(7, 9), (2, 5), (9, 9), (2, 7)6	

332	
Relations, Functions, and Matrices 
The following facts about the operations c , d and ′ on relations are immedi-
ate consequences of the basic set identities found in Section 4.1. The set S2 (which 
is, after all, a subset of S2) is being viewed here as a binary relation on S.
 la. r c  s = s c  r	
lb. r d s = s d r
2a. (r c  s) c  g = r c  (s c  g)	
2b. (r d s) d g = r d (s d g)
3a. r c (s d g) = (r c  s) d (r c  g)	 3b. r d (s c  g) = (r d s) c  (r d g)
4a. r c  [ = r	
4b. r d S2 = r
5a. r c  r′ = S2	
5b. r d r′ = [
Properties of Relations
A binary relation on a set S may have certain properties. For example, the 
­relation r of equality on S, (x, y) [ r 4 x = y, has three properties: (1) for 
any x [ S, x = x, or (x, x) [ r; (2) for any x, y [ S, if x = y then y = x, or 
(x, y) [ r S ( y, x) [ r; and (3) for any x, y, z [ S, if x = y and y = z, then 
x = z, or 3(x, y) [ r and (y, z) [ r4 S (x, z) [ r. These three properties make 
the equality relation reflexive, symmetric, and transitive.
REMINDER
Reflexive—Every x is 
related to itself.
Symmetric—If x is related 
to y, then y is related to x.
Transitive—If x is related 
to y and y is related to z, 
then x is related to z.
	
Definition	
Reflexive, Symmetric, and Transitive Relations
Let r be a binary relation on a set S. Then
r is reflexive means	
(4x)(x [ S S (x, x) [ r)
r is symmetric means	 (4x)(4y)(x [ S ` y [ S ` (x, y) [ r S (y, x) [ r)
r is transitive means	 (4x)(4y)(4z)(x [ S ` y [ S ` z [ S `  
	
	
(x, y) [ r ` (y, z) [ r S (x, z) [ r)
	
Example 6	
Consider the relation ≤on the set N. This relation is reflexive because for any 
nonnegative integer x, x ≤x. It is also a transitive relation because for any non-
negative integers x, y, and z, if x ≤y and y ≤z, then x ≤z. However, ≤is 
not symmetric; 3 ≤4 does not imply 4 ≤3. In fact, for any x, y [ N, if both 
x ≤y and y ≤x, then x = y. This characteristic is described by saying that ≤is 
­antisymmetric.	
	
Definition	
Antisymmetric Relation
Let r be a binary relation on a set S. Then r is antisymmetric means
(4x)(4y)(x [ S ` y [ S ` (x, y) [ r ` ( y, x) [ r S x = y)
	
Example 7	
Let S = `(N). Define a binary relation r on S by A r B 4 A # B. Then r is ­reflexive 
because every set is a subset of itself. Also, r is transitive because if A is a subset of 
B and B is a subset of C, then A is a subset of C. Finally, r is antisymmetric because 
if A is a subset of B and B is a subset of A, then A and B are equal sets.	

Section 5.1   Relations	
333
All four relational properties involve the implication connective. The univer-
sal quantifiers mean that the implications must be true for arbitrary choices of 
variables. Recall that to prove an implication true, we assume that the antecedent 
is true and prove that the consequent must also be true. For the reflexive property, 
the antecedent just chooses an arbitrary element in S; the consequent says that 
this element must be related to itself. For a relation r on a set to be reflexive, then, 
every element in the set must be related to itself, which specifies certain ordered 
pairs that must belong to r.
However, in the symmetric, transitive, and antisymmetric properties, the an-
tecedent does not say only that the elements are in S. To prove that a relation is 
symmetric, for example, we must show that if x and y are arbitrary elements in S 
and if in addition x is related to y, then it must be the case that y is related to x. This 
says that if certain ordered pairs are found in r, then certain other ordered pairs 
must also be in r in order for r to be symmetric. In other words, knowledge of the 
set S is critical to determining whether reflexivity holds, while to determine the 
other properties, it is sufficient just to look at the ordered pairs in r.
At any rate, the question of whether a given relation on a set S has a certain prop-
erty requires a yes or no answer. The property either holds or it doesn’t.	
REMINDER
Antisymmetric—If x is re-
lated to y and y is related 
to x, then x = y.
Practice 4	 Let S = 51, 2, 36. 
a.	 If a relation r on S is reflexive, what ordered pairs must belong to r?
b.	If a relation r on S is symmetric, what ordered pairs must belong to r? (This is a trick question; see 
the answer at the back of the book.)
c.	 If a relation r on S is symmetric and if (a, b) [ r, then what other ordered pair must belong to r?
d.	If a relation r on S is antisymmetric and if (a, b) and (b, a) belong to r, what must be true?
e.	Is the relation r = 5(1, 2)6 on S transitive? (Hint: Remember the truth table for implication.)	
■
The properties of symmetry and antisymmetry for binary relations are not 
precisely opposites. Antisymmetric does not mean “not symmetric.” A relation 
is not symmetric if some (x, y) belongs to the relation but (y, x) does not. More 
formally, not symmetric means
((4x)(4y)3x [ S ` y [ S ` (x, y) [ r S (y, x) r4)′
	
 4 (Ex)(Ey)3x [ S ` y [ S ` (x, y) [ r S (y, x) r4′
	
 4 (Ex)(Ey)3(x [ S ` y [ S ` (x, y) [ r)′ ~ (y, x) [ r4′
	
 4 (Ex)(Ey)3(x [ S ` y [ S ` (x, y) [ r) ` (y, x) o r4
Relations can therefore be symmetric and not antisymmetric, antisymmetric and 
not symmetric, both, or neither.
The equality relation on a set S is both symmetric and antisymmetric. However, 
the equality relation on S (or a subset of this relation) is the only relation ­having 
both these properties. To illustrate, suppose r is a symmetric and antisymmet-
ric relation on S, and let (x, y) [ r. By symmetry, it follows that ( y, x) [ r. But 
by antisymmetry, x = y. Thus, only equal elements can be related. The relation 
r = 5(1, 2), (2, 1), (1, 3)6 on the set S = 51, 2, 36 is neither symmetric—(1, 3) be-
longs but (3, 1) does not—nor antisymmetric—(1, 2) and (2, 1) belong, but 1 ∙2.

334	
Relations, Functions, and Matrices 
Closures of Relations
If a relation r on a set S fails to have a certain property, we may be able to extend 
r to a relation r* on S that does have that property. By “extend,” we mean that the 
new relation r* will contain all the ordered pairs in r plus the additional ordered 
pairs needed for the desired property to hold. Thus r # r*. If r* is the smallest 
such set, then r* is called the closure of r with respect to that property.
Practice 5	 Test each binary relation on the given set S for reflexivity, symmetry, antisymmetry, and 
transitivity.
a.	 S = N; x r y 4 x + y is even
b.	 S = Z+(positive integers); x r y 4 x divides y
c.	 S = set of all lines in the plane; x r y 4 x is parallel to y or x coincides with y
d.	 S = N; x r y 4 x = y2
e.	 S = 50, 16; x r y 4 x = y2
f.	 S = 5x 0  x is a person living in Peoria6; x r y 4 x is older than y
g.	 S = 5x 0  x is a student in your class6; x r y 4 x sits in the same row as y
h.	 S = 51, 2, 36; r = 5(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)6	
■
	
Example 8	
The discussion on recursion in Prolog (Section 1.5) noted that a recursive rule 
should be used when the predicate being described is one that is inherited from one 
object to the next. The predicate in-food-chain used there has this property because
in-food-chain-(x, y) ` in-food-chain ( y, z) S  in-food-chain (x, z)
Now we see that this is simply the transitive property.	
	
Definition	
Closure of a Relation
A binary relation r* on a set S is the closure of a relation r on S with respect to 
property P if
	
1.	 r* has property P.
	
2.	 r # r*.
	
3.	 r* is a subset of any other relation on S that includes r and has property P.
We can look for the reflexive closure, the symmetric closure, and the transi-
tive closure of a relation on a set. Of course, if the relation already has a property, 
it is its own closure with respect to that property.
	
Example 9	
Let S = 51, 2, 36 and r = 5(1, 1), (1, 2), (1, 3), (3, 1), (2, 3)6. Then r is not ­reflex- 
ive, not symmetric, and not transitive. The closure of r with respect to ­reflexivity is
r* = 5(1, 1), (1, 2), (1, 3), (3, 1), (2, 3), (2, 2), (3, 3)6

Section 5.1   Relations	
335
This relation is reflexive and contains r. Furthermore, any reflexive relation on S 
would have to contain the new ordered pairs we’ve added—(2, 2) and (3, 3)—so 
no smaller reflexive relation can exist; that is, any reflexive relation containing r 
must have the relation above as a subset.
The closure of r with respect to symmetry is
r* = 5(1, 1), (1, 2), (1, 3), (3, 1), (2, 3), (2, 1), (3, 2)6
Here it is also clear that we have added just those new pairs required—(2, 1) and 
(3, 2)—for the relation to be symmetric.
For both reflexive closure and symmetric closure, we only had to inspect the 
ordered pairs already in r to find out what ordered pairs we needed to add (assum-
ing we knew what the set S was). The reflexive or symmetric closure of the rela-
tion could be found in one step. Transitive closure may require a series of steps. 
Inspecting the ordered pairs in our example r, we see that we need to add (3, 2) 
(because of (3, 1) and (1, 2)), (3, 3) (because of (3, 1) and (1, 3)), and (2, 1) (be-
cause of (2, 3) and (3, 1)). This gives the relation
5(1, 1), (1, 2), (1, 3), (3, 1), (2, 3), (3, 2), (3, 3), (2, 1)6
However, this relation is still not transitive. Because of the new pair (2, 1) and the 
old pair (1, 2), we need to add (2, 2). This gives the relation
5(1, 1), (1, 2), (1, 3), (3, 1), (2, 3), (3, 2), (3, 3), (2, 1), (2, 2)6
which is transitive and also the smallest transitive relation containing r. It is the 
transitive closure of r.	
As in Example 9, one way to find the transitive closure of a relation is to ­inspect 
the ordered pairs in the original relation, add new pairs if necessary, inspect the 
resulting relation, add new pairs if necessary, and so on, until a transitive relation is 
achieved. This is a rather ad hoc procedure, and we will give a better algorithm in 
Chapter 7. There we will also see that the transitive closure of a binary relation is 
related to “reachability in a directed graph,” which has many applications.
Practice 6	 Does it make sense to look for the antisymmetric closure of a relation on a set? Why or why 
not?
■
Practice 7	 Find the reflexive, symmetric, and transitive closure of the relation
5(a, a), (b, b), (c, c), (a, c), (a, d), (b, d), (c, a), (d, a)6
on the set S = 5a, b, c, d6.
■

336	
Relations, Functions, and Matrices 
For the rest of this section we will concentrate on two types of binary relations 
that are characterized by which properties (reflexivity, symmetry, antisymmetry, 
and transitivity) they satisfy.
Partial Orderings
	
Definition	
Partial Ordering
A binary relation on a set S that is reflexive, antisymmetric, and transitive is 
called a partial ordering on S.
From previous examples and Practice 5, we have the following instances of 
partial orderings:
On N, x r y 4 x ≤y.
On `(N), A r B 4 A # B.
On Z+, x r y 4 x divides y.
On 50, 16, x r y 4 x = y2.
If r is a partial ordering on S, then the ordered pair (S, r) is called a partially 
­ordered set (also known as a poset). We will denote an arbitrary, partially ordered 
set by (S, d); in any particular case, d has some definite meaning such as “less 
than or equal to,” “is a subset of,” “divides,” and so on. (The symbol for a generic 
partial ordering, d, is designed to resemble the inequality symbol #, which, as 
we’ve just noted, is a partial ordering on the set N or on any other set in which a 
less-than-or-equal-to relation makes sense.)
Let (S, d) be a partially ordered set, and let A # S. Then d is a set of or-
dered pairs of elements of S, some of which may be ordered pairs of elements 
of A. If we select from d the ordered pairs of elements of A, this new set is called 
the restriction of d to A and is a partial ordering on A. (Do you see why the 
three required properties still hold?) For instance, once we know that the relation  
“x divides y” is a partial ordering on Z+, we automatically know that “x divides y” is 
a partial ordering on 51, 2, 3, 6, 12, 186.
We want to introduce some terminology about partially ordered sets. Let  
(S, d) be a partially ordered set. If x d y, then either x = y or x ∙y. If x d y 
but x ∙y, we write x a y and say that x is a predecessor of y or y is a successor 
of x. A given y may have many predecessors, but if x a y and there is no z with 
x a z a y, then x is an immediate predecessor of y.
Practice 8	 Consider the relation “x divides y” on 51, 2, 3, 6, 12, 186.
a.	 Write the ordered pairs (x, y) of this relation.
b.	Write all the predecessors of 6.
c.	 Write all the immediate predecessors of 6.	
■
If S is finite, we can visually depict a partially ordered set (S, d) by using 
a Hasse diagram. Each of the elements of S is represented by a dot, called a  

node, or vertex, of the diagram. If x is an immediate predecessor of y, then the 
node for y is placed above the node for x and the two nodes are connected by a 
straight-line segment.
	
Example 10	
Consider `(51, 26) under the relation of set inclusion. This is a partially ordered set, 
a restriction of the partially ordered set (`(N), #). The elements of `(51, 26) are 
[, 516, 526, and 51, 26. The binary relation # consists of the following ordered 
pairs:
([, [), (516, 516), (526, 526), (51, 26, 51, 26), ([, 516),
([, 526), ([, 51, 26), (516, 51, 26), (526, 51, 26)
The Hasse diagram of this partially ordered set appears in Figure 5.2. Note that 
although [ is not an immediate predecessor of 51, 26, it is a predecessor of  51, 26 
(shown in the diagram by the chain of upward line segments connecting [ with 
51, 26).	
Practice 9	 Draw the Hasse diagram for the relation “x divides y” on 51, 2, 3, 6, 12, 186.
■
REMINDER
Two nodes in a Hasse 
diagram should never be 
joined by a horizontal line.
Figure 5.2
{1}
{1, 2}
{2}
Ø
The Hasse diagram of a partially ordered set conveys all the information 
about the partial ordering. We can reconstruct the set of ordered pairs making up 
the partial ordering just by looking at the diagram. The lines in the diagram tell 
us immediate (predecessor, successor) pairs. We can fill in the rest by using the 
reflexive and transitive properties. Thus, given the Hasse diagram in Figure 5.3 of 
a partial ordering d on a set 5a, b, c, d, e, f 6, we can conclude that d is the set
5(a, a), (b, b), (c, c), (d, d ), (e, e), ( f, f ), (a, b), (a, c), (a, d ), (a, e), (d, e)6
Section 5.1   Relations	
337
b
c
e
d
a
f
Figure 5.3

338	
Relations, Functions, and Matrices 
Two elements of S may be unrelated in a partial ordering of S. In Example 10, 
516 and 526 are unrelated; so are 2 and 3, and 12 and 18 in Practice 9. In Figure 5.3, 
f is not related to any other element. A partial ordering in which every element of 
the set is related to every other element is called a total ordering, or chain. The 
Hasse diagram for a total ordering on a four-element set looks like Figure 5.4. 
The relation ≤on N is a total ordering, although we can’t draw a Hasse diagram 
because N is an infinite set.
Figure 5.4
…
…
Again, let (S, d) be a partially ordered set. If there is a y [ S with y d x for 
all x [ S, then y is a least element of the partially ordered set. A least ­element, 
if it exists, is unique. To show its uniqueness, assume that y and z are both least 
elements. Then y d z because y is least and z d y because z is least; by anti-
symmetry, y = z. An element y [ S is minimal if there is no x [ S with x a y
. In the Hasse diagram, a least element is below all others, while a minimal 
element has no elements below it. Similar definitions apply for greatest element 
and maximal elements.
Practice 10	 Define greatest element and maximal element in a partially ordered set (S, d).
■
	
Example 11	
In the partially ordered set of Practice 9, 1 is both least and minimal; 12 and 18 are 
both maximal, but there is no greatest element.	
A least element is always minimal and a greatest element is always maximal, 
but the converses are not true (see Example 11). In a totally ordered set, however, 
a minimal element is the least element and a maximal element is the greatest 
­element.
Practice 11	 Draw the Hasse diagram for a partially ordered set with four elements in which there are 
two minimal elements but no least element, two maximal elements but no greatest element, 
and each element is related to exactly two other elements.
■
Partial orderings satisfy the properties of reflexivity, antisymmetry, and tran-
sitivity. Another type of binary relation, which we study next, satisfies a different 
set of properties. 

Section 5.1   Relations	
339
Equivalence Relations
	
Definition	
Equivalence Relation
A binary relation on a set S that is reflexive, symmetric, and transitive is called an 
equivalence relation on S.
REMINDER
A partial ordering is anti-
symmetric; an equivalence 
relation is symmetric.
We have already come across the following examples of equivalence relations:
On any set S, x r y 4 x = y.
On N, x r y 4 x + y is even.
On the set of all lines in the plane, x r y 4 x is parallel to y or coincides with y.
On 50, 16, x r y 4 x = y2.
On 5x 0  x is a student in your class6, x r y 4 x sits in the same row as y.
On 51, 2, 36, r =  5(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)6.
We can illustrate an important feature of an equivalence relation on a set 
by looking at S = 5x 0  x is a student in your class6, x r y 4 “x sits in the same row 
as y.” Let’s group together all those students in set S who are related to one an-
other. We come up with Figure 5.5. We have partitioned the set S into subsets in 
such a way that everyone in the class belongs to one and only one subset.
Figure 5.5
row 1
row 3
row 2
row 4
row 5
S
	
Definition	
Partition of a Set
A partition of a set S is a collection of nonempty disjoint subsets of S whose 
union equals S.
Any equivalence relation, as we will see, partitions the set on which it is 
defined. The subsets making up the partition, often called the blocks of the parti-
tion, are formed by grouping together related elements, like the students in the 
classroom.
For r an equivalence relation on a set S and x [ S, we let 3x4 denote the set 
of all members of S to which x is related, called the equivalence class of x. Thus,
3x4 = 5 y 0  y [ S ` x r y6
(Because r is symmetric, we could just as well have said that 3x4 = 5 y 0  y [ S
` y r x6.)

340	
Relations, Functions, and Matrices 
	
Example 12	
In the case where x r y 4  “x sits in the same row as y,” suppose that John, Chuck, 
Jose, Judy, and Ted all sit in row 3. Then 3John4 = 5John, Chuck, Jose, Judy, Ted6. 
Also 3John4 = 3Ted4 = 3Judy4, and so on. These are not distinct classes, but the 
same class with multiple names. An equivalence class can take its name from any 
of the elements in it.	
Now we state the result about equivalence relations and partitions. For some 
practice with formal theorems and proofs, we give this result as a formal ­theorem, 
then analyze the structure of the proof and complete part of the proof.
	
Theorem	
On Equivalence Relations and Partitions
An equivalence relation r on a set S determines a partition of S, and a partition of 
a set S determines an equivalence relation on S.
Partial Proof : The theorem makes two separate statements:
	
a.	 An equivalence relation on S determines a partition of S.
	
b.	 A partition of S determines an equivalence relation on S.
To prove part (a), we must show that the distinct equivalence classes of members 
of S under equivalence relation r satisfy the definition of a partition. To satisfy the 
definition of a partition, we must show that
	
i.	 the union of these distinct classes equals S.
	
ii.	 the distinct classes are disjoint.
To prove part (a. i), we must show something about the union of the distinct 
equivalence classes formed by r. Equivalence classes are sets of elements of S, so 
their union is a set; let’s denote this set by U. We must show that U = S, which is 
a set equality. To prove this set equality, we will prove set inclusion in each direc-
tion; in other words,
	
1.	 U # S
	
2.	 S # U
For this part of the proof, we are finally down to two small statements that are 
easy to prove, as follows:
a.i.1: Let x [ U. Then x belongs to an equivalence class. Every equivalence 
class is a subset of S, so x [ S.
a.i.2: Let x [ S. Then x r x (reflexivity of r); thus, x [ 3x4, and every member 
of S belongs to some equivalence class, hence to the union of classes U.
This completes the proof of part (a.i). For part (a.ii), let 3x4 and 3z4 be two 
equivalence classes. We want to show that distinct classes are disjoint, or
	
3x4 ∙3z4 S 3x4 d 3z4 = [	
(a.ii)

Section 5.1   Relations	
341
If we assume that 3x4 ∙3z4, we must then show that 3x4 d 3z4 does not contain any-
thing, which might be hard to do. So instead, we’ll prove the contrapositive of a. ii:
	
 3x4 d 3z4 ∙[ S 3x4 = 3z4	
(contrapositive of a.ii)
Therefore, we assume that 3x4 d 3z4 ∙[ and that there is a y [ S such that 
y [ 3x4 d 3z4. What does this tell us?
y [ 3x4 d 3z4	
(assumption)
y [ 3x4, y [ 3z4	
(definition of  d)
x r y, z r y	
(definition of 3x4 and 3z4)
x r y, y r z	
(symmetry of r)
x r z		
(transitivity of r)
Now we can show that 3x4 = 3z4 by proving set inclusion in each direction:
	
3.	 3z4 # 3x4
	
4.	 3x4 # 3z4
To show (3), 3z4 # 3x4, let q [ 3z4 (we know 3z4 ∙[ because y [ 3z4.) Then
z r q		
(definition of 3z4)
x r z		
(from above)
x r q		
(transitivity of r)
q [ 3x4	
(definition of 3x4)
3z4 # 3x4	
(definition of #)
Practice 12 asks for a proof of (4), 3x4 # 3z4. Once this proof is supplied, it 
completes (3) and (4), which leads to the conclusion 3x4 = 3z4. This completes the 
proof of the contrapositive of part (a. ii) and therefore proves part (a. ii), which in 
turn completes the proof of part (a). Whew!
Practice 13 asks for a proof of part b.
End of Partial Proof
Practice 12	 For the foregoing argument, supply the proof that 3x4 # 3z4.
■
Practice 13	 Prove part (b) of the theorem. Given a partition of a set S, define a relation r by
x r y 4 x is in the same block of the partition as y
and show that r is an equivalence relation on S, that is, show that r is reflexive, symmetric, and transitive.
■
	
Example 13	
The equivalence relation on N given by
x r y 4 x + y is even

342	
Relations, Functions, and Matrices 
partitions N into two equivalence classes. If x is an even number, then for any even 
number y, x + y is even and y [ 3x4. All even numbers form one class. If x is an 
odd number and y is any odd number, x + y is even and y [ 3x4. All odd numbers 
form the second class. The partition can be pictured as in Figure 5.6. Notice again 
that an equivalence class may have more than one name, or representative. In this 
example, 324 = 384 = 310484, and so on; 314 = 3174 = 39474, and so on.
evens
odds
N
Figure 5.6
Partitioning a set into equivalence classes is helpful because it is often conve-
nient to go up one level of abstraction and treat the classes themselves as entities. 
We will conclude this section with two important examples where this is the case 
(you actually saw the first example somewhere around the fourth grade). 
Practice 14	 For each of the following equivalence relations, describe the corresponding equivalence 
classes.
a.	 On the set of all lines in the plane, x r y 4 x is parallel to y or x coincides with y.
b.	On the set N, x r y 4 x = y.
c.	 On 51, 2, 36, r = 5(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)6.	
■
	
Example 14	
Let S = 5a∙b 0  a, b [ Z, b ∙06. S is therefore the set of all fractions. The fractions 
1∙2 and 2∙4 are different fractions—they have different numerators and different 
denominators, but they are said to be “equivalent.” Formally, a∙b is equivalent 
to c∙d, denoted by a∙b ∼c∙d, if and only if ad = bc. We will show that the bi-
nary relation ∼ on S is indeed an equivalence relation. First, a∙b ∼a∙b because 
ab = ba. Also, if a∙b ∼c∙d then ad = bc, or cb = da and c∙d ∼a∙b. Hence, 
∼ is reflexive and symmetric. To show that ∼ is transitive, let a∙b ∼c∙d and 
c∙d ∼e∙f . Then ad = bc and cf = de. Multiplying the first equation by f and the 
second by b, we get adf = bcf  and bcf = bde. Therefore, adf = bde, or af = be 
(why is it legitimate to divide by d here?). Thus, a∙b ∼e∙f , and ∼ is transitive. 
Some sample equivalence classes of S formed by this equivalence ­relation are
c1
2 d = e c, −3
−6, −2
−4, −1
−2, 1
2, 2
4, 3
6, cf
c 3
10 d = e c, −9
−30, −6
−20, −3
−10, 3
10, 6
20, 9
30, cf
The set Q of rational numbers can be regarded as the set of all equivalence 
classes of S. A single rational number, such as 31∙24, has many fractions represent-
ing it, although we customarily use the reduced fractional representation. When 
we add two rational numbers, such as 31∙24 + 33∙104, we look for representatives 

Section 5.1   Relations	
343
from the classes having the same denominator and add those representatives. Our 
answer is the class to which the resulting sum belongs, and we usually name the 
class by using a reduced fraction. Thus, to add 31∙24 + 33∙104, we represent 31∙24 
by 5∙10 and 33∙104 by 3∙10. The sum of 5∙10 and 3∙10 is 8∙10, and 38∙104 is 
customarily named 34∙54. This procedure is so familiar that it is generally writ-
ten as 1∙2 + 3∙10 = 4∙5; nonetheless, equivalence classes of fractions are being 
­manipulated by means of representatives.	
	
Example 15	
We will define a binary relation of congruence modulo 4 on the set Z of inte-
gers. An integer x is congruent modulo 4 to y, symbolized by x ≡4 y, or x ≡y 
(mod 4), if x −y is an integral multiple of 4. Congruence modulo 4 is an 
­equivalence relation on Z. To construct the equivalence classes, note that 304, for 
example, will contain all integers differing from 0 by a multiple of 4, such as 4, 8, 
−12, and so on. The distinct equivalence classes are
304 = 5…, −8, −4, 0, 4, 8, …6
314 = 5…, −7,  −3, 1, 5, 9, …6
324 = 5…, −6, −2, 2, 6, 10, …6
334 = 5…, −5, −1, 3, 7, 11, …6
There is nothing special about the choice of 4 in Example 15; we can give a 
definition for congruence modulo n for any positive integer n.
	
Definition	
Congruence modulo n
For integers x and y and positive integer n,
x ≡y (mod n) if x −y is an integral multiple of n
This binary relation is an equivalence relation on Z for any positive inte-
ger n (see Exercise 46). This equivalence relation and the resulting equivalence 
classes can be used for integer arithmetic on a computer. An integer is stored as 
a sequence of bits (0s and 1s) within a single memory location. Each computer 
allocates a fixed number of bits for a single memory location (this number varies 
depending on the architecture of the computer—how its memory space is laid 
out). The larger the integer, the more bits required to represent it. Therefore each 
machine has some limit on the size of the integers it can store. Suppose that n − 1  
is the maximum size and that x and y are integer values with 0 ≤x ≤n −1, 
0 ≤y ≤n −1. If the sum x + y exceeds the maximum size, it cannot be stored. 
As an alternative, the computer may perform addition modulo n and find the 
remainder r when x + y is divided by n.

344	
Relations, Functions, and Matrices 
The equation
x + y = qn + r, 0 ≤r < n
symbolizes this division, where q is the quotient and r is the remainder. This 
­equation may be written as
(x + y) −r = qn
which shows that (x + y) −r is an integral multiple of n, or that (x + y) ≡r 
(mod n). The integer r may not be x + y, but it is in the equivalence class 3x + y4, 
and since 0 ≤r < n, it is also in the range of integers that can be stored. (The 
system may or may not issue an integer overflow message if x + y is too large to 
store and addition modulo n must be used.) The situation is analogous to your car’s 
odometer, which records mileage modulo 100,000; when mileage reaches 102,758, 
for example, it is displayed on the odometer as 2,758.
Practice 15	 What are the equivalence classes corresponding to the relation of congruence modulo 5  
on Z?
■
Practice 16	
If 4 is the maximum integer that can be stored on a (micromicro) computer, what will 
be stored for the value 3 + 4 if addition modulo 5 is used?
Table 5.1 summarizes important features of partial orderings and equivalence 
relations.
Table 5.1
Partial Orderings and Equivalence Relations
Type of Binary Relation
Reflexive
Symmetric
Antisymmetric
Transitive
Important Feature
Partial ordering
Yes
No
Yes
Yes
Predecessors and 
­successors
Equivalence relation
Yes
Yes
No
Yes
Determines a partition
S e c t i o n  5 .1 	
Review
Techniques
•	 Test an ordered pair for membership in a binary 
­relation.
•	 Test a binary relation for reflexivity, symmetry, 
­antisymmetry, and transitivity.
•	 Find the reflexive, symmetric, and transitive 
­closure of a relation.
•	 Draw the Hasse diagram for a finite partially 
­ordered set.
•	 Find least, minimal, greatest, and maximal ­elements 
in a partially ordered set.
•	 Find the equivalence classes associated with an 
equivalence relation.
W
W
■

Section 5.1   Relations	
345
Exercises 5.1
	 1.	 For each of the following binary relations r on N, decide which of the given ordered pairs belong to r.
	
a.	 x r y 4 x + y < 7; (1, 3), (2, 5), (3, 3), (4, 4)
	
b.	 x r y 4 x = y + 2; (0, 2), (4, 2), (6, 3), (5, 3)
	
c.	 x r y 4 2x + 3y = 10; (5, 0), (2, 2), (3, 1), (1, 3)
	
d.	 x r y 4 y is a perfect square; (1, 1), (4, 2), (3, 9), (25, 5)
	 2.	 For each of the following binary relations r on Z, decide which of the given ordered pairs belong to r.
	
a.	 x r y 4 x 0  y; (2, −6), (3, 5), (8, 4), (4, 8)
	
b.	 x r y 4 x and y are are relatively prime; (5, 8), (9, 16), (6, 8), (8, 21)
	
c.	 x r y 4 gcd(x, y) = 7; (28, 14), (7, 7), (10, 5), (21, 14)
	
d.	 x r y 4 x2 + y2 = z2 for some integer z; (1, 0), (3, 9), (2, 2), (−3, 4)
	
e.	 x r y 4 x is a number from the Fibonacci sequence; (4, 3), (7, 6), (7, 12), (20, 20)
	 3.	 Decide which of the given items satisfy the relation.
	
a.	 r a binary relation on Z, x r y 4 x = −y; (1, −1), (2, 2), (−3, 3), (−4, −4)
	
b.	 r a binary relation on N, x r y 4 x is prime; (19, 7), (21, 4), (33, 13), (41, 16)
	
c.	 r a binary relation on Q, x r y 4 x ≤1∙y; (1, 2), (−3, −5), (−4, 1∙2), (1∙2, 1∙3)
	
d.	 r a binary relation on N × N, (x, y) r  (u, v) 4 x + u = y + v; ((1, 2), (3, 2)), ((4, 5), (0, 1)) 
	 4.	 Decide which of the given items satisfy the relation.
	
a.	 r a binary relation on S × C, where S = 5states in the United States6, C = 5cities in the United States6, 
x r y 4 y is the capital of x; (Indiana, Indianapolis), (Illinois, Chicago), (Kansas, Kansas City),  
(Kentucky, Louisville), (North Dakota, Bismarck)
	
b.	 r a binary relation on A × P, where A = 5artists6, P = 5paintings6, x r y 4 x painted y; (DaVinci, 
Mona Lisa), (Grant Wood, American Gothic), (Remington, Ridden Down), (Picasso, Blue Dancers), 
(van Gogh, Starry Night)
	
c.	 r a binary relation on C × M, where C = 5composers6, M = 5music6, x r y 4 x composed y; 
(­Bernstein, West Side Story), (Presley, Blue Suede Shoes), (Gershwin, Rhapsody in Blue), (Beethoven, 
Moonlight ­Sonata), (Rogers and Hammerstein, Phantom of the Opera)
	
d.	 r a binary relation on A × B, where A = 5authors6, B = 5books6, x r y 4 x wrote y; (Hemingway, 
The Old Man and the Sea), (Sawyer, Huckleberry Finn) (Poe, Moby Dick), (Orwell, 1984), (Tolstoy, 
Crime and Punishment)
	 5.	 For each of the following binary relations on R, draw a figure to show the region of the plane it describes.
	
a.	 x r y 4 y ≤2
	
b.	 x r y 4 x = y −1
	
c.	 x r y 4 x2 + y2 ≤25
	
d.	 x r y 4 x ≥y
Main Ideas
•	 A binary relation on a set S is formally a subset of 
S × S; the distinctive relationship satisfied by the 
relation’s members often has a verbal description 
as well.
•	 Operations on binary relations on a set include 
union, intersection, and complementation.
•	 Binary relations can have properties of reflexivity, 
symmetry, transitivity, and antisymmetry.
•	 Finite partially ordered sets can be represented 
graphically.
•	 An equivalence relation on a set S determines a 
partition of S, and conversely. The blocks of the 
partition are equivalence classes, which may them-
selves be treated as entities.

346	
Relations, Functions, and Matrices 
	 6.	 For each of the accompanying figures, give the binary relation on R that describes the shaded area.
	
3
2
1
–1
1
2
3
–2
–3
–2
–3
x
y
–1
	
3
2
(0, 2)
(2, 0)
1
–1
–1
1
2
3
–2
–3
–2
–3
x
y
	
2
1
–1
–1
1
2
–2
–3
–2
x
y
	
(2, 0)
(0,  –1)
x
(–2, 0)
(0, 1)
y
	 7.	 Identify each relation on N  as one-to-one, one-to-many, many-to-one, or many-to-many.
	
a.	 r = 5(1, 2), (1, 4), (1, 6), (2, 3), (4, 3)6
	
b.	 r = 5(9, 7), (6, 5), (3, 6), (8, 5)6
	
c.	 r = 5(12, 5), (8, 4), (6, 3), (7, 12)6
	
d.	 r = 5(2, 7), (8, 4), (2, 5), (7, 6), (10, 1)6
	 8.	 Identify each of the following relations on S as one-to-one, one-to-many, many-to-one, or many-to-many.
	
a.	 S = N
	
	
x r y 4 x = y + 1
	
b.	 S = set of all women inVicksburg
	
	
x r y 4 x is the daughter of y
	
c.	 S = `(51, 2, 36)
	
	
A r B 4 0A0 = 0B0
	
d.	 S = R
	
	
x r y 4 x = 5
	 9.	 Let r and s be binary relations on N defined by x r y 4 “x divides y,” x s y 4 5x ≤y. Decide which of  
the given ordered pairs satisfy the following relations.
	
a.	 r c s; (2, 6), (3, 17), (2, 1), (0, 0)
	
b.	 r d s; (3, 6), (1, 2), (2, 12)
	
c.	 r′; (1, 5), (2, 8), (3, 15)
	
d.	 s′; (1, 1), (2, 10), (4, 8)
a.
b.
c.
d.

Section 5.1   Relations	
347
	 10.	Both r and s are binary relations from P to C where P = 5people in theUnited States6, C = 5cities in the 
United States6, x r y 4 x lives in y, and x s y 4 x works in y. Describe each of the ­following relations.
	
a.	 r d s	
c.	 r d s′
	
b.	 r c s	
d.	 r′ d s
	 11.	Let S = 51, 2, 36. Test the following binary relations on S for reflexivity, symmetry, antisymmetry, and 
transitivity.	
	
a.	 r = 5(1, 3), (3, 3), (3, 1), (2, 2), (2, 3), (1, 1), (1, 2)6
	
b.	 r = 5(1, 1), (3, 3), (2, 2)6
	
c.	 r = 5(1, 1), (1, 2), (2, 3), (3, 1), (1, 3)6
	
d.	 r = 5(1, 1), (1, 2), (2, 3), (1, 3)6
	 12.	Let S = 50, 1, 2, 4, 66. Test the following binary relations on S for reflexivity, symmetry, antisymmetry, 
and transitivity.
	
a.	 r = 5(0, 0), (1, 1), (2, 2), (4, 4), (6, 6), (0, 1), (1, 2), (2, 4), (4, 6)6
	
b.	 r = 5(0, 1), (1, 0), (2, 4), (4, 2), (4, 6), (6, 4)6
	
c.	 r = 5(0, 1), (1, 2), (0, 2), (2, 0), (2, 1), (1, 0), (0, 0), (1, 1), (2, 2)6
	
d.	 r = 5(0, 0), (1, 1), (2, 2), (4, 4), (6, 6), (4, 6), (6, 4)6
	
e.	 r = [
	 13.	Test the following binary relations on the given sets S for reflexivity, symmetry, antisymmetry, and transitivity.
	
a.	 S = Q	
	
	
x r y 4 0x0 ≤0y0	
	
	
b.	 S = Z
	
	
x r y 4 x −y is an integral multiple of 3
	
c.	 S = N	
	
	
x r y 4 x # y is even	 	
	
d.	 S = N
	
	
x r y 4 x is odd
	
e.	 S = set of all squares in the plane
	
	
S1r S2 4 length of side of S1 = length of side of S2
	 14.	Test the following binary relations on the given sets S for reflexivity, symmetry, antisymmetry, and 
­transitivity.
	
a.	 S = set of all finite-length strings of characters
	
	
x r y 4 number of characters in x = number of characters in y
	
b.	 S = 50, 1, 2, 3, 4, 56
	
	
x r y 4 x + y = 5
	
c.	 S = `(51, 2, 3, 4, 5, 6, 7, 8, 96)
	
	
A  r B 4 0A0 = 0B0
	
d.	 S = `(51, 2, 3, 4, 5, 6, 7, 8, 96)
	
	
A r B 4 0A0 ∙0B0
	
e.	 S = N × N
	
	
(x1, y1) r (x2, y2) 4 x1 ≤x2 and y1 ≥y2

348	
Relations, Functions, and Matrices 
	 15.	Which of the binary relations of Exercise 13 are equivalence relations? For each equivalence relation, 
describe the associated equivalence classes.
	 16.	Which of the binary relations of Exercise 14 are equivalence relations? For each equivalence relation, 
describe the associated equivalence classes.
	 17.	Test the following binary relations on the given sets S for reflexivity, symmetry, antisymmetry, and 
­transitivity.
	
a.	 S = Z
	
	
x r y 4 x + y is a multiple of 5
	
b.	 S = Z
	
	
x r y 4 x < y
	
c.	 S = set of all finite-length binary strings
	
	
x r y 4 x is a prefix of y
	
d.	 S = set of all finite-length binary strings
	
	
x r y 4 x has the same number of 1s as y
	 18.	Test the following binary relations on the given sets S for reflexivity, symmetry, antisymmetry, and 
­transitivity.
	
a.	 S = Z
	
	
x r y 4 x = ky for some integer k
	
b.	 S = Z  
	
	
x r y 4  there is a prime number p such that p 0  x and p 0  y
	
c.	 S = `(51, 2, 3, 4, 5, 6, 7, 8, 96)
	
	
A r B 4 A d B = [
	
d.	 S = `(51, 2, 3, 4, 5, 6, 7, 8, 96)
	
	
A r B 4 A = B′
	 19.	Let S be the set of people in the United States. Test the following binary relations on S for reflexivity, sym-
metry, antisymmetry, and transitivity.
	
a.	 x r y 4 x is at least as tall as y.
	
b.	 x r y 4 x is taller than y.
	
c.	 x r y 4 x is the same height as y.
	
d.	 x r y 4 x is a child of y.
	 20.	Let S be the set of people in the United States. Test the following binary relations on S for reflexivity, 
­symmetry, antisymmetry, and transitivity.
	
a.	 x r y 4 x is the husband of y.
	
b.	 x r y 4 x is the spouse of y.
	
c.	 x r y 4 x has the same parents as y.
	
d.	 x r y 4 x is the brother of y.
	 21.	For each case, think of a set S and a binary relation  r  on S (different from any in the examples or prob-
lems) satisfying the given conditions.
	
a.	  r  is reflexive and symmetric but not transitive.
	
b.	  r  is reflexive and transitive but not symmetric.
	
c.	  r  is not reflexive or symmetric but is transitive.
	
d	
 r  is reflexive but neither symmetric nor transitive.

Section 5.1   Relations	
349
	 22.	Let r and s be binary relations on a set S.
	
a.	 If r and s are reflexive, is r c s reflexive? Is r d s reflexive?
	
b.	If r and s are symmetric, is r c s symmetric? Is r d s symmetric?
	
c.	 If r and s are antisymmetric, is r c s antisymmetric? Is r d s antisymmetric?
	
d.	If r and s are transitive, is r c s transitive? Is r d s transitive?
	 23.	Find the reflexive, symmetric, and transitive closure of each of the relations in Exercise 11.
	 24.	Find the reflexive, symmetric, and transitive closure of each of the relations in Exercise 12.
	 25.	Given the following binary relation
S = set of all cities in the country
x r y 4 Take-Your-Chance Airlines flies directly from x to y
	
	 describe in words what the transitive closure relation would be.
	 26.	Two additional properties of a binary relation r are defined as follows:
r is irreflexive	
means: (4x)(x [ S S (x, x) o r)
r is asymmetric	
means: (4x)(4y)(x [ S ` y [ S ` (x, y) [ r S (y, x) o r)
	
a.	 Give an example of a binary relation r on set S = 51, 2, 36 that is neither reflexive nor irreflexive.
	
b.	Give an example of a binary relation r on set S = 51, 2, 36 that is neither symmetric nor asymmetric.
	
c.	 Prove that if r is an asymmetric relation on a set S, then r is irreflexive.
	
d.	Prove that if r is an irreflexive and transitive relation on a set S, then r is asymmetric.
	
e.	 Prove that if r is a nonempty, symmetric, and transitive relation on a set S, then r is not irreflexive.
	 27.	Does it make sense to look for the irreflexive closure of a relation? (See Exercise 26.) Why or why not?
	 28.	Does it make sense to look for the asymmetric closure of a relation? (See Exercise 26.) Why or why not?
	 29.	Let S be an n-element set. How many different binary relations can be defined on S? (Hint: Recall the 
formal definition of a binary relation.)
	 30.	Let r be a binary relation on a set S.	 For A # S, define
[A = 5x 0  x [ S ` (4y)(y [ A S x r y)6
A[ = 5x 0  x [ S ` (4y)(y [ A S y r x)6
	
a.	 Prove that if r is symmetric, then [A = A[.
	
b.	Prove that if A # B then [B # [A and B[ # A[.
	
c.	 Prove that A # ([A)[.
	
d.	Prove that A # [(A[).
	 31.	Draw the Hasse diagram for the following partial orderings.
	
a.	 S = 5a, b, c6
	
	
r = 5(a, a), (b, b), (c, c), (a, b), (b, c), (a, c)6
	
b.	 S = 5a, b, c, d6
	
	
r = 5(a, a), (b, b), (c, c), (d, d ), (a, b), (a, c)6
	
c.	 S = 5[, 5a6, 5a, b6, 5c6, 5a, c6, 5b66
	
	
A r B 4 A # B

350	
Relations, Functions, and Matrices 
	 32.	For Exercise 31, name any least elements, minimal elements, greatest elements, and maximal elements.
	 33.	Let (S, d) be a partially ordered set, and let A # S. Prove that the restriction of d to A is a partial 
­ordering on A.
	 34.	a.	 Draw the Hasse diagram for the partial ordering “x divides y” on the set 52, 3, 5, 7, 21, 42, 105, 2106. 
Name any least elements, minimal elements, greatest elements, and maximal elements. Name a totally 
ordered subset with four elements.
	
b.	 Draw the Hasse diagram for the partial ordering “x divides y” on the set 53, 6, 9, 18, 54, 72, 108, 1626. 
Name any least elements, minimal elements, greatest elements, and maximal elements. Name any 
unrelated elements.
	 35.	Draw the Hasse diagram for each of the two partially ordered sets.
	
a.	 S = 51, 2, 3, 5, 6, 10, 15, 306	
b.	 S = `(51, 2, 36)
	
	
x r y 4 x divides y	
	
A r B 4 A # B
	
	 	What do you notice about the structure of these two diagrams?
	 36.	For each Hasse diagram of a partial ordering in the accompanying figure, list the ordered pairs that belong 
to the relation.
	
	
d
a
e
b
f
c
5
1
4
3
2
2
1
3
4
5
	 37.	Let (S, r) and (T, s) be two partially ordered sets.  A relation m on S × T is defined by  
(s1, t1) m (s2, t2) 4 s1 r s2 and t1 s t2. Show that m is a partial ordering on S × T.
	 38.	Let r be a binary relation on a set S. Then a binary relation called the inverse of r, denoted by r−1, is 
defined by x r−1 y 4 y r x.
	
a.	 For r = 5(1, 2), (2, 3), (5, 3), (4, 5)6 on the set N, what is r−1?
	
b.	Prove that if r is a reflexive relation on a set S, then r−1 is reflexive.
	
c.	 Prove that if r is a symmetric relation on a set S, then r−1 is symmetric.
	
d.	Prove that if r is an antisymmetric relation on a set S, then r−1 is antisymmetric.
	
e.	 Prove that if r is a transitive relation on a set S, then r−1 is transitive.
	
f.	 Prove that if r is an irreflexive relation on a set S (see Exercise 26), then r−1 is irreflexive.
	
g.	Prove that if r is an asymmetric relation on a set S (see Exercise 26), then r−1 is asymmetric.
	 39.	Prove that if a binary relation r on a set S is reflexive and transitive, then the relation r d r−1 is an 
­equivalence relation (see Exercise 38 for the definition of r−1).
	 40.	a.	 Let (S, r) be a partially ordered set. Then r−1 can be defined as in Exercise 38. Show that (S, r−1) is a 
partially ordered set, called the dual of (S, r).
a.
b.
c.

Section 5.1   Relations	
351
	
b.	If (S, r) is a finite, partially ordered set with the Hasse diagram shown, draw the diagram of the dual of 
(S, r).
	
	
	
c.	 Let (S, r) be a totally ordered set and let X = 5(x, x) 0  x [ S6. Show that the setdifference r−1 −X  
equals the set r′.
	 41.	A computer program is to be written that will generate a dictionary or the index for a book. We will  
assume a maximum length of n characters per word. Thus, we are given a set S of words of length at most 
n, and we want to produce a linear list of these words arranged in alphabetical order. There is a natural 
total ordering d on alphabetic characters (a a b, b a c, etc.), and we will assume our words contain 
only alphabetic characters. We want to define a total ordering d on S called a lexicographical ordering 
that will arrange the members of S alphabetically. The idea is to compare two words X and Y character by 
character, passing over equal characters. If at any point the X character alphabetically precedes the corre-
sponding Y character, then X precedes Y; if all characters in X are equal to the corresponding Y characters 
but we run out of characters in X before characters in Y, then X precedes Y. Otherwise, Y precedes X.
Formally, let X = (x1, x2, … , xj) and Y = (y1, y2, … , yk) be members of S with j ≤k. Let b (for 
blank) be a new symbol, and fill out X with k −j blanks on the right. X can now be written (x1, x2, …, xk). 
Let b precede any alphabetical character. Then X d Y if
	
x1 ∙y1 and x1 d y1
	
	 or
	
x1 = y1, x2 = y2, …, xm = ym(m ≤k)
	
xm+1 ∙ym+1 and xm+1 d ym+1
	
	 Otherwise, Y d X .
Note that because the ordering d on alphabetical characters is a total ordering, if Y d X  by “other-
wise,” then there exists m ≤k such that x1 = y1, x2 = y2,…, xm = ym, xm+1 ∙ym+1 and ym+1 d xm+1.
Show that d on S as defined above is a total ordering.
	 42.	Apply the total ordering described in Exercise 41 to the words boo, bug, be, bah, and bugg. Note why each 
word precedes the next.
	 43.	Exercise 41 discusses a total ordering on a set of words of length at most n that will produce a linear list 
in alphabetical order. Suppose we want to generate a list of all the distinct words in a text (for example, 
a compiler must create a symbol table of variable names). As in Exercise 41, we assume that the words 
contain only alphabetical characters because there is a natural precedence relation already existing  
(a a b, b a c, and so on). If numeric or special characters are involved, they must be assigned a  

352	
Relations, Functions, and Matrices 
precedence relation with alphabetical characters (the collating sequence must be determined). If we 
list words alphabetically, it is a fairly quick procedure to decide whether a word currently being pro-
cessed is new, but to fit the new word into place, all successive words must be moved one unit down 
the line. If the words are listed in the order in which they are processed, new words are simply tacked 
onto the end and no rearranging is ­necessary, but each word being processed has to be compared with 
each member of the list to determine if it is new. Thus, both logical linear lists have disadvantages.
We describe a structure called a binary search tree; using this structure, a search process called a 
binary tree search can usually determine quickly whether a word is new and, if it is, no juggling is re-
quired to fit it into place, thus eliminating the disadvantages of both linear list structures described earlier. 
­Suppose we want to process the phrase “when in the course of human events.” The first word in the text 
is used to label the first node of a graph. Once a node is labeled, it drops down a left and right arc, putting 
two unlabeled nodes below the one just labeled.
when
when
When the next word in the text is processed, it is compared with the first node. When the word being pro-
cessed alphabetically precedes the label of a node, the left arc is taken; when the word follows the label 
alphabetically, the right arc is taken.	 The word becomes the label of the first unlabeled node it reaches. 
(If the word equals a node label, it is a duplicate, so the next word in the text is processed.) This procedure 
continues for the entire text. Thus,
when
in
	
	 then
when
in
the
	
	 then
when
in
course
the

Section 5.1   Relations	
353
	
	 until finally
when
in
course
human
events
of
the
	
	 By traversing the nodes of this graph in the proper order (described by always processing the left nodes 
below a node first, then the node, then the right nodes below it), an alphabetical listing “course, events, 
human, in, of, the, when” is produced.
	
a.	 This type of graph is called a tree.	(Unlabeled nodes and arcs to unlabeled nodes usually are not 
shown.) Turned upside down, the graph can be viewed as the Hasse diagram of a partial ordering d. 
What would be the least element? Would there be a greatest element? Which of the following ordered 
pairs would belong to d: (in, of), (the, of), (in, events), (course, of)?
	
	
	
Here the tree structure contains more information than the partial ordering, because we are inter-
ested in not only whether a word w1 precedes a word w2 in the partial ordering sense but also whether 
w2 is to the left or right of w1.
	
b.	Build a binary search tree for the phrase “Old King Cole was a merry old soul.” Eliminate unla-
beled nodes. Considering the upside-down graph as the Hasse diagram of a partial ordering, name the 
­maximal elements.
	 44.	The alphabetical ordering defined in Exercise 41 can be applied to words of any finite length. If we define 
A* to be the set of all finite-length “words” (strings of characters, not necessarily meaningful) from the 
English alphabet, then the alphabetical ordering on A* has all words composed only of the letter A preced-
ing all other words. Thus, all the words in the infinite list
a, aa, aaa, aaaa, …
	
	 precede words such as “b” or “aaaaaaab.” Therefore this list does not enumerate A*, because we can 
never count up to any words with any characters other than a. However, the set A* is denumerable. Write 
a partial enumeration of A* by ordering words by length (all words of length 1 precede all words of length 
2, and so on) and then alphabetically ordering words of the same length.
	 45.	a.	 For the equivalence relation r = 5(a, a), (b, b), (c, c), (a, c), (c, a)6, what is the set [a]? Does it have 
any other names?
	
b.	For the equivalence relation r = 5(1, 1), (2, 2), (1, 2), (2, 1), (1, 3), (3, 1), (3, 2), (2, 3), (3, 3), (4, 4), 
(5, 5), (4, 5), (5, 4)6 what is the set [3]? What is the set [4]?
	 46.	Prove that for any positive integer n, congruence modulo n is an equivalence relation on the set Z.
	 47.	For the equivalence relation of congruence modulo 2 on the set Z, what is the set [1]?
	 48.	For the equivalence relation of congruence modulo 5 on the set Z, what is the set [−3]?
	 49.	Assume that x ≡y (mod n)  and z ≡w (mod n) for some positive integer n. Prove that
	
a.	 x + z ≡y + w (mod n)
	
b.	 x −z ≡y −w (mod n)
	
c.	 x # z ≡y # w (mod n)
	
d.	 xs ≡ys (mod n) for s ≥1, n ≥2

354	
Relations, Functions, and Matrices 
	 50.	Let p be a prime number. Prove that x2 ≡y2 (mod p) if and only if x ≡y (mod p) or x ≡−y (mod p).
	 51.	a.	 Given the partition 51, 26 and 53, 46 of the set S = 51, 2, 3, 46, list the ordered pairs in the correspond-
ing equivalence relation.
	
b.	Given the partition 5a, b, c6 and 5d, e6 of the set S = 5a, b, c, d, e6, list the ordered pairs in the cor-
responding equivalence relation.
	 52.	Let S be the set of all books in the library. Let r be a binary relation on S defined by x r y 4 “the color of 
x’s cover is the same as the color of y’s cover.” Show that r is an equivalence relation on S and describe 
the resulting equivalence classes.
	 53.	Let S = N and let r be a binary relation on S defined by x r y 4 x2 −y2 is even. Show that r is an equiva-
lence relation on S and describe the resulting equivalence classes.
	 54.	Let S = R and let r be a binary relation on S defined by x r y 4 x −y is an integer.	
	
a.	 Show that r is an equivalence relation on S.
	
b.	List 5 values that belong to [1.5].
	 55.	Let S = N × N and let r be a binary relation on S defined by (x, y) r (z, w) 4 y = w. Show that r is an 
equivalence relation on S and describe the resulting equivalence classes.
	 56.	Let S = N × N and let r be a binary relation on S defined by (x, y) r (z, w) 4 x + y = z + w. Show that 
r is an equivalence relation on S and describe the resulting equivalence classes.
	 57.	Let S be the set of all binary strings of length 8 and let r be a binary relation on S defined by x r y 4  
y starts with the same bit value (0 or 1) as x and y ends with the same bit value (0 or 1) as x.
	
a.	 Show that r is an equivalence relation on S.
	
b.	How many strings are in the set S?
	
c.	 Into how many equivalence classes does r partition S? Explain your answer.
	
d.	How many strings are in each equivalence class?
	 58.	The documentation for the Java programming language recommends that when a boolean “equals method” 
is defined for an object, it should be an equivalence relation. That is, if r is defined by x r y 4 x.equals(y) 
for all objects in the class, then r should be an equivalence relation. In a graphics application, a ­programmer 
creates an object called a point, consisting of two coordinates in the plane. The programmer defines an 
equals method as follows: If p and q are any two points in the plane, then
	
p.equals(q) 4 the distance from p to q is ≤c
	
	 where c is a small positive number that depends on the resolution of the computer display. Is the program-
mer’s equals method an equivalence relation? Justify your answer.
	 59.	Let S be the set of all propositional wffs with n statement letters. Let r be a binary relation on S defined 
by P r Q 4 “P 4 Q is a tautology.” Show that r is an equivalence relation on S and describe the resulting 
equivalence classes. (We have used the notation P 3 Q for P r Q.)
	 60.	Given two partitions p1 and p2 of a set S, p1 is a refinement of p2 if each block of p1 is a subset of a block 
of p2. Show that refinement is a partial ordering on the set of all partitions of S.
Exercises 61–72 all deal with partitions on a set.
	 61.	Let Pn denote the total number of partitions of an n-element set, n ≥1. The numbers Pn are called Bell 
numbers. Compute the following Bell numbers.
	
a.	 P1
	
b.	 P2
	
c.	 P3
	
d.	 P4

Section 5.1   Relations	
355
	 62.	From Exercise 61, you might be looking for a closed-form formula giving the value of Pn. Although Bell 
numbers have been extensively studied, no closed-form formula has been found. Bell numbers can be 
computed via a recurrence relation. Let P0 have the value 1. Prove that for n ≥1,
Pn = ∙
n−1
k=0
C(n −1, k)Pk
	
	 (Hint: Use a combinatorial proof instead of an inductive proof. Let x be a fixed but arbitrary member 
of a set with n elements. In each term of the sum, n −k represents the size of the partition block that 
contains x.)
	 63.	Use the formula of Exercise 62 to compute P1, P2, P3, and P4, and compare your answers to those in 
­Exercise 61.
	 64.	Use the formula of Exercise 62 to compute P5 and P6.
	 65.	Let S(n, k) denote the number of ways to partition a set of n elements into k blocks. The numbers S(n, k) 
are called Stirling numbers.
	
a.	 Find S(3, 2).
	
b.	Find S(4, 2).
	 66.	Prove that for all n ≥1, S(n, k) satisfies the recurrence relation
S(n, 1) = 1
S(n, n) = 1
S(n + 1, k + 1) = S(n, k) + (k + 1)S(n, k + 1) for 1 ≤k ≤n
	
	 (Hint: Use a combinatorial proof instead of an inductive proof. Let x be a fixed but arbitrary member of 
a set with n + 1 elements, and put x aside. Partition the remaining set of n elements. A partition of the 
original set could be obtained either by adding 5x6 as a separate block or by putting x in one of the existing 
blocks.)
	 67.	Use the formula of Exercise 66 to rework Exercise 65.
	 68.	The recurrence relation of Exercise 66 is similar to Pascal’s formula, Equation (1) of Section 4.5. Use this 
relation to compute the numeric values in the first five rows of Stirling’s triangle, which begins
S(1, 1)
S(2, 1)   S(2, 2)
S(2, 1)  S(3, 2)  S(3, 3)
(
	 69.	Prove that
Pn = ∙
n
k=1
 S(n,  k)
	 70.	Use the formula of Exercise 69 and Stirling’s triangle (Exercise 68) to compute P1, P2, P3, and P4.
	 71.	Find the number of ways to distribute 4 different-colored marbles among 3 identical containers so that no 
container is empty.
	 72.	Find the number of ways in which 5 different jobs can be assigned to 3 identical processors so that each 
processor gets at least 1 job.

356	
Relations, Functions, and Matrices 
	 73.	Binary relations on a set S are ordered pairs of elements of S. More generally, an n-ary relation on a set S 
is a set of ordered n-tuples of elements of S. Decide which of the given items satisfy the relation.
	
a.	 r a unary relation on Z, x [ r 4 x is a perfect square
	
	
25, 39, 49, 62
	
b.	 r a ternary relation on N, (x, y, z) [ r 4 x2 + y2 = z2
	
	
(1, 1, 2), (3, 4, 5), (0, 5, 5), (8, 6, 10)
	
c.	 r a 4-ary relation on Z, (x, y, z, w) [  r  4  y = 0x0 and w ≥x + z2
	
	
(−4, 4, 2, 0), (5, 5, 1, 5), (6, −6, 6, 45), (−6, 6, 0, −2)
	 74.	A ternary relation r is defined on the set S = (2, 4, 6, 8) by (x, y, z) [  r 4 x + y = z.	 List the 3-tuples 
that belong to r.
	 75.	If x is a real number, x ∙0, then a number y such that x # y = 1 is called the multiplicative inverse of 
x. Given positive integers x and n, a positive integer y such that x # y ≡1 (mod n) is called the modular 
multiplicative inverse of x modulo n. But
x # y ≡1 (mod n)
 4 x # y −1 = kn where k is an integer
 4 xy −kn = 1
 4 1 is a linear combination of x and n
 4 gcd (x, n) = 1
 4 x and n are relatively prime
	
	 Thus, if x and n are not relatively prime, the modular inverse of x does not exist. If they are relatively 
prime, the modular inverse of x is the positive coefficient of x in the linear combination of x and n that 
equals 1.
Use the Euclidean algorithm to find the modular multiplicative inverse of 21 modulo 25 (note that 21 
and 25 are relatively prime).
	 76.	Use the Euclidean algorithm to find the modular multiplicative inverse of 68 modulo 15 (see Exercise 75).
	
Example 16	
Ernie and his brothers run a woodworking shop in the hills of New Hampshire 
that manufactures rocking chairs with padded cushion seats. The manufacturing 
process can be broken down into a number of tasks, some of which have certain 
other tasks as prerequisites. The following table shows the manufacturing tasks for 
a rocking chair, the prerequisite tasks, and the number of hours required to perform 
each task.
	
S e c t i o n  5 . 2 	 Topological Sorting
If r is a partial ordering on a set S, then some elements of S are predecessors of 
other elements. If S is a set of tasks that are to be done, then the idea of x as a pre-
decessor of y can be interpreted literally to mean that task x must be done before 
task y. Thus partial orderings and Hasse diagrams are natural ways to represent 
problems in task scheduling.

Section 5.2   Topological Sorting	
357
Task
Prerequisite Tasks
Hours to Perform
   1. Selecting wood
None
3. 0
   2. Carving rockers
1
4. 0
   3. Carving seat
1
6. 0
   4. Carving back
1
7. 0
   5. Carving arms
1
3. 0
   6. Selecting fabric
None
1. 0
   7. Sewing cushion
6
2. 0
   8. Assembling back and seat
3, 4
2. 0
   9. Attaching arms
5, 8
2. 0
10. Attaching rockers
2, 8
3. 0
11. Varnishing
9, 10
5. 0
12. Adding cushion
7, 11
0. 5
We can define a partial ordering on the set of tasks by
x d  y  4 task x = task y or task x is a prerequisite to task y
It is easy to see that this relation is reflexive, antisymmetric, and transitive. Also,
x a y 4 task x is a prerequisite to task y
In the Hasse diagram for this partial ordering, the nodes are tasks; we’ll add 
to each node the information about the time to perform the task. Also, as is tradi-
tional, we’ll orient the diagram so that if x a y, then x is to the left of y rather than 
below y. Thus the entire diagram runs from left to right rather than from bottom to 
top. Such a diagram for task scheduling is often called a PERT(program evalu-
ation and review technique) chart, first developed for tracking the construction 
of Navy submarines but useful for managing any complex project with a num-
ber of subtasks. The PERT chart for manufacturing rocking chairs is shown in  
Figure 5.7, with task numbers substituted for task names and arrows pointing to 
a task from its prerequisite task(s). The numbers in parentheses indicate the time 
required to perform the task.
2(4.0)
10(3.0)
3(6.0)
4(7.0)
8(2.0)
1(3.0)
9(2.0)
5(3.0)
6(1.0)
7(2.0)
12(0.5)
11(5.0)
Figure 5.7

358	
Relations, Functions, and Matrices 
A project represented by a PERT chart must begin with the tasks at the left-
most edge of the PERT chart and end with the tasks at the rightmost edge. An 
upper limit on the time required to complete the project can be obtained by adding 
the times for performing each task, but this does not take into account the fact 
that perhaps some tasks can be performed in parallel, such as tasks 2 through 5 in 
Example 16. To obtain the minimum time required to complete the project, we can 
move through the chart from left to right, computing for each node the minimum 
time to complete the work from the beginning through the work at that node. If a 
node x has multiple nodes as prerequisites, all the prerequisite tasks must be com-
pleted before we can begin work on x; thus we must add the time for task x to the 
maximum completion time of the prerequisite nodes. 
Practice 17	 Construct the PERT chart for building a house from the following task table.
Task 
Prerequisite Tasks
Days to Perform
1. Clearing lot
None
4
2. Pouring pad
1
3
3. Doing framing
2
7
4. Shingling roof
3
6
5. Adding outside siding
3
4
6. Installing plumbing and wiring
4, 5
6
7. Hanging windows and doors
3
5
8. Installing wallboard
6
5
9. Painting interior
7, 8
5
■
	
Example 17	
Let’s compute the time for completing each task in Example 16.
Task 1:	
3. 0
Task 2:	
3. 0 + 4. 0 = 7. 0
Task 3:	
3. 0 + 6. 0 = 9. 0
Task 4:	
3. 0 + 7. 0 = 10. 0
Task 5:	
3. 0 + 3. 0 = 6. 0
Task 6:	
1. 0
Task 7:	
1. 0 + 2. 0 = 3. 0
Task 8:	
max(time to complete task 3, time to complete task 4)
	 	
+ time to perform task 8
	
	
= max(9. 0, 10. 0) + 2. 0 = 10. 0 + 2. 0 = 12. 0

Section 5.2   Topological Sorting	
359
Task 9:	
max(time to complete task 5, time to complete task 8)
	 	
+ time to perform task 9
	
	
= max(6.0, 12.0) + 2.0 = 12.0 + 2.0 = 14.0
Task 10:	
max(time to complete task 2, time to complete task 8)
	 	
+ time to perform task 10
	
	
= max(7.0, 12.0) + 3.0 = 12.0 + 3.0 = 15.0
Task 11:	
max(time to complete task 9, time to complete task 10)
	 	
+ time to perform task 11
	
	
= max(14.0, 15.0) + 5.0 = 15.0 + 5.0 = 20.0
Task 12:	
max(time to complete task 7, time to complete task 11)
	 	
+ time to perform task 12
	
	
= max(3.0, 20.0) + 0.5 = 20.0 + 0.5 = 20.5
Therefore the minimum number of hours to manufacture a rocking chair is 20.5. 
From node 12, we can travel back in the chart, selecting at each point of mul-
tiple prerequisites the node that contributed the maximum value. This gives the 
sequence of nodes
12, 11, 10, 8, 4, 1
or, reversing this sequence,
1, 4, 8, 10, 11, 12
The sum of the times to perform each task in this sequence is 20.5. If any of 
these tasks takes longer to perform than its allotted time, the entire project will 
take longer than 20.5 hours. This sequence of nodes is a critical path through the 
PERT chart—performing these tasks in the allotted time is critical to completing 
the ­entire project on time.	
The critical path in a PERT chart represents the minimum time to completion 
of the entire project. If a task not on the critical path takes longer than its allotted 
time to perform, then the critical path may shift to include this node, because it 
then becomes the bottleneck slowing down completion of the total project. In a 
complex project, the critical path must continually be recomputed to determine 
where best to allocate resources to move the project forward.
Practice 18	 Compute the minimum time to completion and the nodes on the critical path for the house-
building project of Practice 17.
Given a partial ordering r on a finite set, there is always a total ordering s that 
is an extension of r, meaning that if x r y, then x s y. The process of topological 
sorting finds such a total ordering from a partial ordering. This is indeed a sorting 
process in the sense that the objects end up being totally ordered, but since they 
must be partially ordered to begin with, it is a very specialized sorting process.
Recall that in a finite partially ordered set, an element is minimal if it has 
no predecessors. In a finite nonempty partially ordered set, at least one minimal 
■

360	
Relations, Functions, and Matrices 
element must exist. To see this, let x belong to the set. If x is not minimal, then 
there is a y in the set with y r x, y ∙x. If y is not minimal, then there is a z in the 
set with z r y, z ∙y, and so on. Because the set is finite, this process cannot go on 
indefinitely, so one such element must be minimal. A minimal element in a Hasse 
diagram has no elements below it; a minimal element in a PERT chart has no ele-
ments to its left.
The accompanying pseudocode algorithm for topological sorting operates on 
a partially ordered set (S, r). Minimal elements (picked at random if there is a 
choice of minimal elements at any stage) are repeatedly removed from the ordered 
set until the set is empty. Each removal of a minimal element leaves a finite par-
tially ordered set, so that another minimal element may be found.
	
Algorithm	
TopologicalSort
TopSort(finite set S; partial ordering r on S )
//find a total ordering on S that is an extension of r
Local variable
integer i	
//enumerates tasks in total ordering
i = 1
while S ∙[
pick a minimal element xi from S;
S = S −5xi6
i = i + 1
end while
∙∙x1 a x2 a x3 a ca xn is now a total ordering that extends r 
write(x1, x2, x3, …  , xn)
end function TopSort
The ordering x1 a x2 a x3 a ca xn produced by this algorithm is a total 
ordering. To see that it is an extension of r, suppose that xi  r  xj. Then xi precedes 
xj and xi must be chosen as a minimal element and removed from the set before xj 
can be chosen as a minimal element. Therefore i < j and xi a xj.
	
Example 18	
One topological sort of the partial ordering of Example 16 is
6, 1, 7, 2, 3, 5, 4, 8, 10, 9, 11, 12
In Figure 5.7, either 6 or 1 is minimal and may be chosen as the first element. If 6 
is chosen and removed from the set, then, as shown in Figure 5.8, either 1 or 7 is 
minimal. If 1 is then chosen and removed from the set (Figure 5.9), then 2, 3, 4, 5, 
and 7 are all minimal and any one can be chosen next. The process continues until 
all nodes have been chosen. If Ernie’s brothers all move to the city and he is left 
to build rocking chairs alone, the topological sort gives an order in which he can 
perform tasks sequentially.

Section 5.2   Topological Sorting	
361
2(4.0)
10(3.0)
3(6.0)
4(7.0)
8(2.0)
1(3.0)
9(2.0)
5(3.0)
7(2.0)
12(0.5)
11(5.0)
Figure 5.8
2(4.0)
10(3.0)
3(6.0)
4(7.0)
8(2.0)
9(2.0)
5(3.0)
7(2.0)
12(0.5)
11(5.0)
Figure 5.9
Practice 20	 Find a topological sort for the partial ordering of Practice 17.
Practice 19	 Find another topological sort for the partial ordering of Example 16.
The algorithm given here for topological sorting is still somewhat imprecise, 
as we have not given a mechanical method for finding a minimal element. Another 
algorithm will be described in Section 7.4.
S e c t i o n  5 . 2 	 Review
Techniques
•	 Construct a PERT chart from a task table. 
•	 Find the critical path in a PERT chart. 
•	 Do a topological sort on a partially ordered set.
Main Ideas
•	 PERT charts are diagrams of partially ordered 
sets representing tasks and prerequisites among 
tasks.
•	 A topological sort extends a partial ordering on a 
finite set to a total ordering.
W
W
■
■

362	
Relations, Functions, and Matrices 
Exercises 5.2
	 1.	 The following tasks are required in order to assemble a bicycle. As the manufacturer, you must write a 
list of sequential instructions for the buyer to follow. Will the sequential order given below work? Give 
another sequence that could be used.
Task 
Prerequisite Tasks
1. Tightening frame fittings
None
2. Attaching handle bars to frame
1
3. Attaching gear mechanism
1
4. Mounting tire on wheel assembly
None
5. Attaching wheel assembly to frame
1, 4
6. Installing brake mechanism
2, 3, 5
7. Adding pedals
6
8. Attaching seat
1
9. Adjusting seat height
7, 8
	 2.	 Give a list of tasks and prerequisite tasks for cooking and serving a hamburger.
	 3.	 Construct a PERT chart from the following task table.
Task 
Prerequisite Tasks
Time to Perform
A
E
3
B
C, D
5
C
A
2
D
A
6
E
None
2
F
A, G
4
G
E
4
H
B, F
1
	 4.	 Construct a PERT chart from the following task table.
Task 
Prerequisite Tasks
Time to Perform
1
2
4
2
3
2
3
8
5
4
3
2
5
4 , 7
2
6
5
1
7
3
3
8
None
5

Section 5.2   Topological Sorting	
363
	 5.	 Compute the minimum time to completion and the nodes on the critical path for the problem in Exercise 3.
	 6.	 Compute the minimum time to completion and the nodes on the critical path for the problem in Exercise 4.
	 7.	 For the problem in Exercise 3, great improvements in productivity have knocked down the time to per-
form task D from 6 units to 1 unit. Recompute the minimum time to completion and the nodes on the 
critical path.
	 8.	 For the problem in Exercise 4, an extra quality-control step has been added to task 4, which now requires 
4 units of time to perform. Recompute the minimum time to completion and the nodes on the critical path.
	 9.	 Do a topological sort on the partially ordered set shown.
H
G
D
A
C
F
B
E
	 10.	Do a topological sort on the partially ordered set shown.
E
G
F
C
A
B
D
	 11.	Find a topological sort for the problem in Exercise 3.
	 12.	Find a topological sort for the problem in Exercise 4.
	 13.	Given the following task chart for fixing an Asian dinner, find a total ordering in which the tasks can be 
performed sequentially.
Task
Prerequisite Tasks
   1. Chop onions 
9
   2. Wash lettuce
11
   3. Make dressing
11
   4. Do stir fry
10
   5. Toss salad
2, 3
   6. Cut up chicken
None
   7. Grate ginger
9
   8. Chop bok choy
9
   9. Marinate chicken
6
10. Heat wok
1, 7, 8, 11
11. Prepare rice
None

364	
Relations, Functions, and Matrices 
	 14.	A U.S. journalist, on being posted to a bureaucratic foreign country, was faced with the following tasks 
before she could begin work.
Task 
Prerequisite Tasks
1. Obtain a residence permit from the Public Security Bureau
2, 3, 7
2. Obtain a health certificate from the local hospital
None
3. Obtain a journalist work card from the Foreign Ministry
None
4. Obtain a customs certificate from the Customs Office
1, 3, 9
5. Post an announcement in the local newspaper about the pres-
ence of her news company in the country
None
6. Obtain a journalist visa from the Public Security Bureau 
2, 3, 7
7. Obtain a foreign journalist housing contract from the local 
housing authority
None
8. Pick up her shipment of belongings from the United States
1, 4, 6
9. Obtain a news organization permit from the Foreign Ministry. 
5
	
	 Find a total ordering in which the tasks can be performed sequentially.
	 15.	Recall the problem posed at the beginning of this chapter:
Your company has developed a program for use on a small parallel processing machine. According to 
the technical documentation, the program executes processes P1, P2, and P3 in parallel; these processes 
all need results from process P4, so they must wait for Process P4 to complete execution before they 
begin. Processes P7 and P10 execute in parallel but must wait until Processes P1, P2, and P3 have 
finished. Process P4 requires results from P5 and P6 before it can begin execution. P5 and P6 execute 
in parallel. Processes P8 and P11 execute in parallel but P8 must wait for Process P7 to complete, and 
Process P11 must wait for P10 to complete. Process P9 must wait for results from P8 and P11. You have 
been assigned to convert the software for use on a single processor machine.
	
	 Use a topological sort to determine the order in which the processes should be executed sequentially.
	 16.	Given the following task chart for conducting a water quality study, find a total ordering in which the tasks 
can be performed sequentially.
Task
Prerequisite Tasks
   1. Plan schedule
7
   2. Collect new data
1, 10
   3. Assemble team
7
   4. Collect prior water quality data
6
   5. Obtain equipment
7
   6. Identify streams
None
   7. Decide on readings needed
4, 8
   8. Review federal and state guidelines
None
   9. Write report
11
10. Distribute equipment
3, 5
11. Analyze new data
2

Section 5.3   Relations and Databases	
365
	
S e c t i o n  5 . 3 	 Relations and Databases
A database is a storehouse of associated information about some enterprise. The 
user of a database can certainly retrieve some specific fact stored in the database. 
But a well-designed database is more than simply a list of facts. The user can per-
form queries on the database to retrieve information not contained in any single 
fact. The whole becomes more than the sum of its parts.
To design a useful and efficient computerized database, it is necessary 
to model or represent the enterprise with which the database is concerned. A 
­conceptual model attempts to capture the important features and workings of 
the enterprise. Considerable interaction with those who are familiar with the 
enterprise may be required to obtain all the information necessary to formulate 
the model.
Entity-Relationship Model
One high-level representation of an enterprise is the entity-relationship model. 
In this model, important objects, or entities, in the enterprise are identified, 
together with their relevant attributes or properties. Then the relationships be-
tween these various entities are noted. This information is represented graphi-
cally by an entity-relationship diagram, or E-R diagram. In an E-R diagram, 
rectangles denote entity sets, ellipses denote attributes, and diamonds denote 
relationships.
	
Example 19	
The Pet Lovers of America Club (PLAC) wants to set up a database. PLAC has 
bought mailing lists from commercial sources, and it is interested in people who 
own pets and in some basic information about those pets, such as the name, type 
of pet (dog, cat, and so on), and the breed.
Figure 5.10 shows an E-R diagram for the PLAC enterprise. This diagram 
says that persons and pets are the entities. Persons have the attributes of Name, 
­Address, City, and State. Pets have the attributes of PetName, PetType, and Breed. 
The diagram also shows that persons own pets. Thinking of the entities as sets, the 
Person set and the Pet set, the relationship “owns” is a binary relation from Person 
to Pet—the ownership relation is captured by (person, pet) ordered pairs. The “1” 
and “N” on the connecting lines indicate that this binary relation is one-to-many; 
that is, in this particular enterprise, one person can own many pets, but no pet has 
multiple owners. (Pets with multiple owners would result in a many-to-many rela-
tion.) Also, in this example, some persons may own no pets, and some pets may 
have no owners.
The fact that no pet has multiple owners is one of the “business rules” of 
the enterprise. Such business rules are important to identify when designing 
a database, because they can determine various features of the database, as we  
will see.

366	
Relations, Functions, and Matrices 
1
N
Name
Address
City
State
Person
Owns
Pet
Breed
PetType
PetName
Figure 5.10
Relational Model
Another representation of an enterprise, called a relational model, can be devel-
oped from the E-R model. Both the entity sets and the relationships of the E-R 
model become relations (in the mathematical sense) in the relational model. The 
relations are described by tables. A relational database consists of collections of 
such tables.
An entity set table is named for the entity set. Each row in the table contains 
the values of the n attributes for a specific instance of that entity set. Thus the rela-
tional table may be thought of as a set of n-tuples (rows), and an individual row is 
called a tuple. True to the idea of a set, no duplicate tuples exist, and no ordering 
of the tuples is assumed. The ordering of the attributes is unimportant, except that 
consistency must be maintained; that is, each column in the table contains values 
for a specific attribute in all of the tuples. The number of attributes (columns) 
is called the degree of the relation. The number of n-tuples (rows) is called the 
cardinality of the relation; it is the cardinality (in the set-theoretic sense) of the 
set of rows.
More formally, a database relation is a subset of D1 × D2 × c× Dn, where 
Di is the domain from which attribute Ai takes its values. This means that the 
database use of the word relation is consistent with our definition of an n-ary 
relation on multiple sets (page 330). Beyond the data in the table itself, additional 
information, sometimes called metadata—data about data—is needed to specify 
the domain for each attribute. Is the domain the set of all possible strings, or do 
these strings have to follow a specific format? Is the domain the set of integers or 
does it have to be the set of integers within some specific range? Does the attribute 
represent a date? If so, the domain has to specify the specific date format to be 
used, for example, March 13, 2014 or 3/13/14 or 3/13/2014, and so forth. In addi-
tion, each attribute domain Di is assumed to contain a special NULL value (empty 

Section 5.3   Relations and Databases	
367
value), so a given tuple could have a NULL value for one or more of its attributes. 
Any tuple (x1, x2, …, xn) in a relation table must satisfy the n-ary predicate of the 
form (4xi)(xi [ Di).
	
Example 20	
The Person relation in the PLAC database might contain the following data.
Person
Name
Address
City
State
Patrick, Tom 
2425 Samset
Sarasota
FL
Smith, Mary 
1121 Ridge Rd. 
Rockville
IL
Collier, Jon 
429 Via Rivio
Venice
IL
Jones, Kate 
345 Forest St. 
Cleveland
OH
Smith, Bob 
1201 45th St. 
Falls City
MA
White, Janet 
110 Toledo Rd. 
Brookville
GA
Garcia, Maria 
24 E. 56th St. 
New York City
NY
The four attributes for each tuple are Name, Address, City, and State. The meta-
data specify that the domain for the Name attribute is the set of strings of the form 
LastName, FirstName; the domain for the State attribute is the set of legitimate 
two-character state abbreviations. The Pet relation could be
Pet
PetName
PetType
Breed
Spot
Dog
Hound
Twinkles
Cat
Siamese
Lad
Dog
Collie
Lassie
Dog
Collie
Mohawk
Fish
Moorish idol
Tweetie
Bird
Canary
Tiger
Cat
Shorthair
Because there are no duplicate tuples in a relation, giving the value of all n 
attributes of a tuple clearly distinguishes that tuple from all others. However, there 
may be a minimal subset of the attributes that can be used to uniquely identify 
each tuple. This subset is called the primary key of the relation; if the subset con-
sists of more than one attribute, then it is a composite primary key. In the table 
describing the relation (and in the E-R diagram), the primary key is underlined in 
the row of attribute names. No component of the primary key should ever have a 
NULL (empty) value. This entity integrity constraint merely confirms that each 

368	
Relations, Functions, and Matrices 
tuple must have a primary key value in order to distinguish that tuple and that all 
attribute values of the primary key are needed in order to identify a tuple uniquely.
Another business rule of the PLAC enterprise is that all people have unique 
names; therefore Name is sufficient to identify each tuple and was chosen as the 
primary key in the Person relation. Note that for the Person relation as shown in this 
example, State could not serve as a primary key because there are two tuples with 
State value “IL.” However, just because Name has unique values in this instance 
does not preclude the possibility of duplicate names. It is the business rule that 
determines that names will be unique. (There is no business rule that says that ad-
dresses or cities are unique, so neither of these attributes can serve as the primary 
key, even though there happen to be no duplicates in the Person relation shown.)
The assumption of unique names is a somewhat simplistic business rule. The 
primary key in a relation involving people is often an identifying number that is a 
unique attribute. This used to be a Social Security number, but due to privacy con-
cerns, institutions now often generate a local unique identifier such as a student ID 
number or employee ID number, or they use a driver’s license number. Because 
PetName is the primary key in the Pet relation of Example 20, we can surmise 
the even more surprising business rule that in the PLAC enterprise, all pets have 
unique names. A more realistic scenario would call for creating a unique attribute 
for each pet, sort of a pet Social Security number, to be used as the primary key. 
This key would have no counterpart in the real enterprise, so the database user 
would never need to see it; such a key is called a blind key or surrogate key. Blind 
keys are often generated automatically by the database system using a simple se-
quential numbering scheme.
An attribute in one relation (called the “child” relation) may have the same 
domain as the primary key attribute in another relation (called the “parent” rela-
tion). Such an attribute is called a foreign key (of the child relation) into the parent 
relation. A relation for a relationship (that is, for a diamond in the E-R diagram) 
between entities uses foreign keys to establish connections between those entities. 
There will be one foreign key in the relationship relation for each entity participat-
ing in the relationship.
	
Example 21	
The PLAC enterprise has identified the following instance of the Owns relation-
ship. The Name attribute of Owns is a foreign key into the Person relation where 
Name is a primary key; PetName of Owns is a foreign key into the Pet relation, 
where PetName is a primary key. The first tuple establishes the Owns relationship 
between Bob Smith and Spot; that is, it indicates that Bob Smith owns Spot.
Owns
Name
PetName
Smith, Bob
Spot
Smith, Mary
Twinkles
Jones, Kate
Lad
Jones, Kate
Lassie
Collier, Jon
Tweetie
White, Janet
Tiger

Section 5.3   Relations and Databases	
369
Persons who do not own pets are not represented in Owns, nor are pets with 
no owners. The primary key of Owns is PetName. Recall the business rule that 
no pet has multiple owners. If any pet could have multiple owners, the composite 
primary key Name/PetName would have to be used. Name alone cannot serve as 
the primary key because people can have more than one pet (for example, Jones, 
Kate, does not identify a unique tuple.)	
In a one-to-one or one-to-many relationship such as our example, a separate 
relationship table (like Owns), while not incorrect, is also not necessary.
	
Example 22	
Because PetName in the Owns relation is a foreign key into the Pet relation, 
the two relations can be combined (using an operation called outer join over  
PetName) to form the PetOwner relation.
PetOwner
Name 
PetName
PetType
Breed
Smith, Bob
Spot
Dog
Hound
Smith, Mary
Twinkles
Cat
Siamese
Jones, Kate
Lad
Dog
Collie
Jones, Kate 
Lassie
Dog
Collie
NULL
Mohawk
Fish
Moorish idol
Collier, Jon
Tweetie
Bird
Canary
White, Janet
Tiger
Cat
Shorthair
This PetOwner relation can replace both the Owns relation and the Pet relation 
with no loss of information. PetOwner contains a tuple with a NULL value for 
Name. This tuple does not violate entity integrity because Name is not a compo-
nent of the primary key but instead is still a foreign key into Person.	
Operations on Relations
Two unary operations that can be performed on relations are restrict and project. 
The restrict operation creates a new relation made up of those tuples of the origi-
nal relation that satisfy certain conditions. The project operation creates a new 
relation made up of certain attributes from the original relation, eliminating any 
duplicate tuples. The restrict and project operations can be thought of in terms 
of subsets. The restrict operation creates a subset of the rows that satisfy certain 
conditions; the project operation creates a subset of the columns that represent 
certain attributes.

370	
Relations, Functions, and Matrices 
	
Example 23	
The operation
Restrict PetOwner where PetType = “Dog” giving DogOwner
results in the relation DogOwner.
DogOwner
Name 
PetName
PetType
Breed
Smith, Bob 
Spot
Dog
Hound
Jones, Kate
Lad
Dog
Collie
Jones, Kate
Lassie
Dog
Collie
The operation
Project PetOwner over (Name, PetType) giving Preference
results in the relation Preference.
Preference
Name
PetType
Smith, Bob 
Dog
Smith, Mary
Cat
Jones, Kate
Dog
NULL
Fish
Collier, Jon
Bird
White, Janet
Cat
Practice 21	 Write the relation that results from the operation
Project Person over (Name, State) giving Locale
■
Because relations are sets of n-tuples, the binary operations of union, inter-
section, and set difference can be applied to two relations with the same basic 
structure. Thus in our example, two different tables containing information about 
pet owners, both laid out with the same structure, could be intersected to produce 
a relation containing all the common 4-tuples.
Another binary operation, join, can be performed on two relations with a 
common attribute (column). Theoretically, this operation initially forms the Car-
tesian product of all n-tuples (rows) in the first relation with all k-tuples (rows) in 
the second relation. It views the result as a set of (n + k)-tuples and then restricts 
to the subset of those where the common attribute has the same value, writing the 

Section 5.3   Relations and Databases	
371
result as a set of (n + k −1)-tuples (the common attribute is written only once). 
Join is therefore not really a separate operation but is defined as the result of doing 
a Cartesian product followed by a restrict.
	
Example 24	
The operation
Join Person and PetOwner over Name giving Listing
results in the Listing relation.
Listing
Name 
Address
City
State
PetName
PetType
Breed
Smith, Mary 1121 Ridge Rd. Rockville
IL
Twinkles
Cat
Siamese
Collier, Jon 
429 Via Rivio
Venice
IL
Tweetie
Bird
Canary
Jones, Kate
345 Forest St.
Cleveland
OH
Lad
Dog
Collie
Jones, Kate
345 Forest St. 
Cleveland
OH
Lassie
Dog
Collie
Smith, Bob
1201 45th St.
Falls City
MA
Spot
Dog
Hound
White, Janet
110 Toledo Rd.
Brookville
GA
Tiger
Cat
Shorthair 
The restrict, project, and join operations can be applied in various combina-
tions to formulate queries that the user wishes to perform on the database. For 
example, suppose the query is
Give the names of all cats whose owners live in Illinois.	
(1)
If the only existing relations are Person and PetOwner, the following sequence of 
operations will produce a relation that answers this query:
Restrict PetOwner where PetType = “Cat” giving Results1
Results1
Name 
PetName
PetType
Breed
Smith, Mary
Twinkles
Cat
Siamese
White, Janet
Tiger
Cat
Shorthair
Restrict Person where State = “IL” giving Results2
Results2
Name 
Address
City
State
Smith, Mary
1121 Ridge Rd.
Rockville
IL
Collier, Jon
429 Via Rivio
Venice
IL

372	
Relations, Functions, and Matrices 
Join Results2 and Results1 over Name giving Results3
Results3
Name 
Address 
City
State
PetName
PetType
Breed
Smith, Mary
1121 Ridge Rd. 
Rockville
IL
Twinkles
Cat
Siamese
Project Results3 over PetName giving FinalResults
FinalResults
PetName
Twinkles
This query could also be performed by first doing the join operation of Example 
24 followed by the restrict and project operations, but the join table would be much 
larger.
	
Example 25	
Relational algebra is a theoretical relational database language in which the re-
strict, project, and join operations can be combined. The relational algebra equiva-
lent of the sequence of operations we did to find the names of cats whose owners 
live in Illinois would be the statement
project (join(restrict PetOwner where PetType = “Cat”) and  
(restrict Person where State = “IL”) over Name)  
over PetName giving Final_Results.	
(2)
SQL is an international standard relational database language; the preceding 
query would appear as the following SQL statement, where the lines are numbered 
only for discussion purposes:
1.  SELECT PetName
2.  FROM PetOwner, Person
3.  WHERE PetOwner. Name = Person. Name
4.  AND PetType = “Cat”
5.  AND State = “IL”;	
(3)
SQL’s SELECT statement can actually perform relational algebra restricts, proj-
ects, and joins, as shown here. Lines 4 and 5 represent the two restrict ­operations. 
Line 2 represents the Cartesian product between the two relations and line 3 iden-
tifies the common attribute. Therefore lines 2 and 3 together represent the join. 
Line 1 represents the project operation. AND, OR, and NOT connectives are also 
available.	
Instead of using the relational algebra approach, in which the restrict, project, 
and join operations are used to process a query, we can use the relational calculus 
approach. In relational calculus, instead of specifying the operations to be done 

Section 5.3   Relations and Databases	
373
in order to process a query, we give a set-theoretic description of the desired result 
of the query. We specify what we want, not how to get it. Sounds like Prolog (see 
Section 1.5). In fact, the description of the set may involve notation from predicate 
logic; remember that predicate logic is also called predicate calculus, hence the 
name relational calculus. Relational algebra and relational calculus are equivalent 
in their expressive power; that is, any query that can be formulated in one lan-
guage can be formulated in the other.
	
Example 26	
The relational calculus expression for the query asking for the names of all cats 
whose owners live in Illinois is
Range of x is PetOwner
Range of y is Person
5x.PetName 0 x.PetType = “Cat” and
exists y(y.Name = x.Name and y.State = “IL”)6	
(4) 
Here “Range of x is PetOwner” specifies the relation from which the tuple x may 
be chosen, and “Range of y is Person” specifies the relation from which the tuple 
y may be chosen. (The use of the term range is unfortunate. We are really talking 
about domain in the same sense we talked about the domain of an interpretation in 
predicate logic—the pool of potential values.) The notation “exists y” stands for 
the existential quantifier (Ey).	
Expressions (1) through (4) all represent the same query expressed in English 
language, relational algebra, SQL, and relational calculus, respectively.
Practice 22	 Using the relations Person and PetOwner, express the following query in relational algebra, 
SQL, and relational calculus form:
Give the names of all cities where dog owners live.
■
NULL Values and Three-valued Logic
The value of an attribute in a particular tuple may be unknown, in which case the 
attribute is assigned a NULL value. For example, we might have the tuple
Bruno, Dog, NULL
in the Pet table if Bruno is a dog of unknown breed. (Note that Bruno’s breed 
might be unknown in some absolute sense, or it might simply be unknown to the 
person entering the data.)
Because NULL means “unknown value,” any comparisons between a NULL 
value and any other value must result in NULL. Thus
“Poodle” = NULL
results in NULL; since the NULL value is unknown, it is also unknown whether 
it has the value “Poodle.”
REMINDER
Any comparison involving 
a NULL value results in 
NULL. 

374	
Relations, Functions, and Matrices 
Ordinary comparisons (does 2 = 2? does 2 = 5?) result in True or False 
values, but when a NULL value is involved, the result, as we have seen, will be 
NULL. This introduces a three-valued logic where expressions can have values 
of True, False, or NULL. Truth tables can be written for three-valued logic (see 
Exercise 53 of Section 1.1).
A
B
A ` B
T
T
T
T
F
F
T
N
N
F
T
F
F
F
F
F
N
F
N
T
N
N
F
F
N
N
N
   
A
B
A ~ B
T
T
T
T
F
T
T
N
T
F
T
T
F
F
F
F
N
N
N
T
T
N
F
N
N
N
N
   
A
A′
T
F
F
T
N
N
Most database management systems follow these rules of three-valued logic 
until a final truth value decision must be made, and then a NULL value gets set to 
False. But this can have unexpected consequences. For example, if Bruno is added 
to the Pet table and the following SQL query is executed
SELECTPetName
FROM Pet
WHERE PetType = “Dog”
AND NOT (Breed = “Collie”);
we may expect to see Bruno’s name in the resulting relation, since Bruno’s breed 
is not “Collie.” But as Bruno’s attribute values are compared with the criteria 
specified in the SQL statement, we get
PetType = “Dog”AND NOT (Breed = “Collie”)
“Dog” = “Dog”AND NOT (NULL = “Collie”)
True AND NOT NULL
True AND NULL
NULL
which then is set to False, so Bruno does not satisfy this query. On second thought, 
because Bruno’s breed is NULL, he might actually be a collie; this query result 
reflects the fact that it cannot be said with certainty that Bruno is a noncollie dog.
But consider the SQL query
SELECT PetName
FROM Pet
WHERE PetType = “Dog”
AND Breed = NULL;

Section 5.3   Relations and Databases	
375
Surely this describes Bruno. However, remember that the result of any compari-
son involving NULL is NULL, so
PetType = “Dog” AND Breed = NULL
“Dog = “Dog” AND NULL = NULL
True AND NULL
NULL
which then is set to False. Contrary to intuition, Bruno does not satisfy this query 
either. The only true fact about Bruno is that he is a dog.
The SQL query
SELECTPetName
FROM Pet
WHERE PetType = “Dog”
AND Breed Is NULL;
is a completely different query from the preceding one. The WHERE clause is 
asking whether the Breed attribute for any tuple has the value NULL. This query 
would produce the following result because Bruno is the only tuple in the Pet table 
with a NULL value for Breed.
IsNull
PetName
Bruno
Database Integrity
New information must be added to a database from time to time, obsolete infor-
mation deleted, and changes or updates made to existing information. In other 
words, the database will be subjected to add, delete, and modify operations. An 
add operation can be carried out by creating a second relation table with the new 
information and performing a set union of the existing table and the new table. 
Delete can be accomplished by creating a second relation table with the tuples to 
be deleted and performing a set difference that subtracts the new table from the 
existing table. Modify can be achieved by a delete (of the old tuple) followed by an 
add (of the modified tuple).
These operations must be carried out so that the information in the database 
remains in a correct and consistent state that agrees with the business rules. En-
forcing three “integrity rules” will help. Data integrity requires that the values 
for an attribute do indeed come from that attribute’s domain. In our example, for 
instance, values for the State attribute of Person must be legitimate two-letter 
state abbreviations (or the NULL value). Entity integrity, as we discussed earlier, 
requires that no component of a primary key value be NULL. These integrity 
constraints clearly affect the tuples that can be added to a relation.
Referential integrity requires that any values for foreign keys of child rela-
tions into parent relations either be NULL or have values that match values in the 
corresponding primary keys of the parent relations. The referential integrity con-
straint affects both add and delete operations (and therefore modify ­operations). 

376	
Relations, Functions, and Matrices 
For instance, we could not add a tuple to PetOwner with a non-NULL Name value 
that does not exist in the Person relation, because this would violate the Owns 
relation as a binary relation on Person × Pet. Also, if the Bob Smith tuple is de-
leted from the Person relation, then the Bob Smith tuple must be deleted from the 
PetOwner relation or the Name value “Bob Smith” changed to NULL (a business 
rule must specify which is to occur) so that PetOwner’s foreign key Name does not 
violate referential integrity. This prevents the inconsistent state of a reference to 
Bob Smith in PetOwner when Bob Smith no longer exists as a “Person.”
S e c t i o n  5 . 3 	
Review
Techniques
•	 Carry out restrict, project, and join operations in a 
relational database.
•	 Formulate relational database queries using rela-
tional algebra, SQL, and relational calculus.
Main Ideas
•	 A relational database uses mathematical relations, 
described by tables, to model objects and relation-
ships in an enterprise.
•	 The database operations of restrict, project, and 
join are operations on relations (sets of tuples).
•	 Queries on relational databases can be formulated 
using the restrict, project, and join operations, SQL 
statements, or notations borrowed from set theory 
and predicate logic.
Exercises 5.3
Exercises 1–4 refer to the Person, Pet, and PetOwner relations of Examples 20 and 22.
	 1.	 Consider the following operation:
	
	 Restrict Pet where PetType = “Cat” giving Kitties
	
a.	 Write a query in English that would result in the information contained in Kitties.
	
b.	What is the cardinality of the relation obtained by performing this operation?
	
c.	 Write an SQL query to obtain this information.
	 2.	 Consider the following operation:
	
	 Project Person over (Name, City, State) giving Census
	
a.	 Write a query in English that would result in the information contained in Census.
	
b.	What is the degree of the relation obtained by performing this operation?
	
c.	 Write an SQL query to obtain this information.
	 3.	 Write the results of the following operation:
	
	 Project Pet over (PetName, Breed ) giving What Am I
	 4.	 Write the results of the following operation:
	
	 Restrict PetOwner where PetType = “Bird” OR PetType = “Cat” giving SomeOwners
W
W

Section 5.3   Relations and Databases	
377
Exercises 5–28 are all related to the same enterprise.
	 5.	 A library maintains a database about its books. Information kept on each author includes the author’s 
name and country of origin. Information kept on each book includes the ISBN, title, publisher, and sub-
ject. Authors and books are the entities in this enterprise, and “writes” is a relationship between these enti-
ties. Sketch an E-R diagram for the enterprise. In the absence of any business rules, what must be assumed 
about the binary relation “writes” regarding whether it is one-to-one, one-to-many, and so on?
	 6.	 In a relational model of the library database, there is an author relation, a book relation, and a writes rela-
tion. Give the table heading for each of the relation tables, underlining the primary key. Business rules 
state that authors are uniquely identified by name and books are uniquely identified by ISBN. Explain your 
choice of primary key for the Writes relation table.
For Exercises 7–16, use the following relation tables and write the results of the operations. These tables are 
sorted by primary key (or in the case of the Writes table, by the first component of the primary key), which is 
not required but is useful for Exercise 25. Many database systems maintain data in sorted order by primary key 
using a tree structure (see Section 5.1, Exercise 43).
Author
Name
Country
Chan, Jimmy
China
East, Jane
U. S.
King, Dorothy
England
Kovalsco, Bert
U.S.
Lau, Won
China
Nkoma, Jon
Kenya
Quercos, Tom
Mexico
Book
ISBN
Title
Publisher
Subject
0-115-01214-1
Birds of Africa
Loraine
Nature
0-364-87547-X
Early Tang Paintings
Bellman
Art
0-56-000142-8
Springtime Gardening
Swift-Key
Nature
0-816-35421-9
Springtime Gardening
Harding
Nature
0-816-53705-4
Baskets for Today
Harding
Art
0-816-88506-0
Autumn Annuals
Harding
Nature

378	
Relations, Functions, and Matrices 
Writes
Name
ISBN
Chan, Jimmy
0-364-87547-X
East, Jane
0-56-000142-8
King, Dorothy
0-816-35421-9
King, Dorothy
0-816-88506-0
Kovalsco, Bert
0-816-53705-4
Lau, Won
0-364-87547-X
Nkoma, Jon
0-115-01214-1
	 7.	 Restrict Author where Country = “U. S.” giving Results7
	 8.	 Restrict Writes where Name = “Dorothy King” giving Results8
	 9.	 Restrict Book where Publisher = “Bellman” or Publisher = “Swift Key” giving Results9
	 10.	Restrict Book where Publisher = “Harding” and Subject = “Art” giving Results10
	 11.	Project Author over Name giving Results11
	 12.	Project Author over (Name, Country) giving Results12
	 13.	Project Book over (Publisher, Subject) giving Results13
	 14.	Project Book over (ISBN, Title, Subject) giving Results14
	 15.	Join Book and Writes over ISBN giving Results15
	 16.	Join Author and Writes over Name giving Results16
For Exercises 17–23, using the relation tables given before Exercise 7, express each query in relational algebra, 
SQL, and relational calculus forms. Also give the result of each query.
	 17.	Give the titles of all books about art.
	 18.	Give the titles of all books published by Harding.
	 19.	Give the names of all authors who publish with Harding.
	 20.	Give the names of all authors who have written nature books.
	 21.	Give the titles of all books written by U.S. authors.
	 22.	Give the titles, ISBNs, and publishers of all art books whose authors live in the United States.
	 23.	Give the authors’ names and book titles for all art books written by English authors.
	 24.	If the tuple
	
	 Fleur, Suzanne   NULL
	
	 gets added to the Author table, write the results of the SQL query
	
	 SELECT Name
	
	 FROM Author
	
	 WHERE Country = “U. S.”
	
	 OR Country = NULL;

Section 5.3   Relations and Databases	
379
	 25.	Suppose a join operation over some attribute is to be done on two tables of cardinality p and q,  
respectively.
	
a.	 The first step is usually to form the Cartesian product of the two relations and then examine the result-
ing tuples to find those with a common attribute value. How many tuples result from the Cartesian 
product that then have to be examined to complete the join operation?
	
b.	Now suppose that the two tables have each been sorted on the common attribute. Explain how the join 
operation can be done more cleverly, avoid the Cartesian product, and examine (read) at most only 
(p + q) rows.
	
c.	 To accomplish a join operation of Author and Writes over Name, how many rows must be examined?
	
d.	To accomplish a join operation of Book and Writes over ISBN, how many rows must be examined? 
(See Exercise 26 for why this operation would not be a good idea anyway.)
	 26.	One rule of thumb about good database design is “one fact, one place.” Suppose you try to combine the 
Book and Writes tables over ISBN into a single relation as was done with the PetName and Owns relation. 
This table would have a heading of the form
ISBN
Title
Publisher
Subject
Name
	
	 How would the resulting table violate the “one fact, one place” rule? How many tuples have to be updated 
if the publisher “Bellman” changes its name to “Bellman-Boyd”?
For Exercises 27 and 28, suppose that an additional attribute called RoyaltyPercent with a domain of integers 
between 0 and 100 is added to the Writes relation. The new Writes table appears here. Because the domain of 
RoyaltyPercent is numerical, arithmetic comparisons can be done on a given RoyaltyPercent value.
Writes
Name
ISBN
RoyaltyPercent
Chan, Jimmy
0-364-87547-X
20
East, Jane
0-56-000142-8
100
King, Dorothy
0-816-35421-9
100
King, Dorothy
0-816-88506-0
100
Kovalsco, Bert
0-816-53705-4
100
Lau, Won
0-364-87547-X
80
Nkoma, Jon
0-115-01214-1
100
	 27.		a.	Write an SQL query to give the author’s name, the title and ISBN of the book, and the royalty percent 
for all authors with a royalty percent of less than 100.
	
b.	Write the results of the query.
	 28.	What database integrity errors would be caused by attempting each of the following actions?
	
a.	 Adding a tuple in the Writes table: Wilson, Jermain 	 0-115-01214-1 	
40
	
b.	Modifying a tuple in the Writes table: Chan, Jimmy 	 0-364-87547-X	
Sixty

380	
Relations, Functions, and Matrices 
Exercises 29–36 are all related to the same enterprise.
	 29.	A corporation sponsors a yearly campaign to solicit monetary contributions from its employees for a lo-
cal charity, and the company decides to use a database to keep track of the data. Employee data already 
include employee ID, first name, last name, and department. Employees sign a contribution pledge on 
a particular date, that specifies the total amount they wish to donate and the number of equal biweekly 
payroll deductions (starting with the next pay period) they want to use to pay off the total. The payroll 
department needs to know details about each payment, including the contribution pledge the payment is 
for, the payment date and the amount deducted. An employee can make multiple pledges.
	
a.	 Do you agree that the following “data decomposition” is consistent with the enterprise description?  
If not, what should be added or what should be removed?
Entity
Attributes
Employee
EmployeeID
FirstName
LastName
Department
Contribution
ContributionID
EmployeeID
ContributionDate
TotalAmount
NumberofPayments
Payment
ContributionID
PaymentDate
PaymentAmount
	
b.	Identify a primary key for each of the Employee, Contribution, and Payment entities and explain your 
choice.
	 30.	Draw an E-R diagram based on Exercise 29.
	 31.	A “universal relation” contains all the data values in one relation. The table represents a report that might 
be distributed to the campaign manager. The universal relation as of 1/16/2014 is shown here.
Employee 
ID
First 
Name
Last 
Name
Department
Contribution 
ID
Contribution 
Date
Total 
Amount
Number 
of  
Payments
Payment  
Date
Payment 
Amount
1
Mary
Black
Accounting
101
1/1/2013
$300.00
3
1/15/2013
$100.00
1
Mary
Black
Accounting
101
1/1/2013
$300.00
3
1/31/2013
$100.00
1
Mary
Black
Accounting
101
1/1/2013
$300.00
3
2/15/2013
$100.00
1
Mary
Black
Accounting
105
6/1/2013
$210.00
3
6/15/2013
$70.00
1
Mary
Black
Accounting
105
6/1/2013
$210.00
3
6/30/2013
$70.00
1
Mary
Black
Accounting
105
6/1/2013
$210.00
3
7/15/2013
$70.00
2
June
Brown
Payroll
107
6/1/2013
$300.00
2
6/15/2013
$150.00
2
June
Brown
Payroll
107
6/1/2013
$300.00
2
6/30/2013
$150.00
2
June
Brown
Payroll
108
1/1/2014
$600.00
12
1/15/2014
$50.00
3
Kevin
White
Accounting
102
1/1/2013
$500.00
2
1/15/2013
$250.00
3
Kevin
White
Accounting
102
1/1/2013
$500.00
2
1/31/2013
$250.00
3
Kevin
White
Accounting
109
1/1/2014
$500.00
2
1/15/2014
$250.00
4
Kelly
Chen
Payroll
104
4/15/2013
$100.00
1
4/30/2013
$100.00
6
Conner
Smith
Sales
103
1/1/2013
$150.00
2
1/15/2013
$75.00
6
Conner
Smith
Sales
103
1/1/2013
$150.00
2
1/31/2013
$75.00

Section 5.4   Functions	
381
	
a.	 Given this universal relation, create and populate with data the three relation tables for the three entities 
described in Exercise 29. Underline the primary key in each table.
	
b.	Describe any foreign keys in the relation tables.
	
c.	 Consider the form of the Employee IDs. This is probably what kind of key?
	 32.		a.	If Mary Black moves from the Accounting Department to the Sales Department, how many tuples must 
be updated in the universal relation?
	
b.	The three relation tables from Exercise 31 should follow the “one fact, one place” rule (see Exercise 
26). With the same change to Mary Black’s department, how many tuples must be updated in the data-
base using the three relation tables of Exercise 31?
Exercises 33–36 make use of the three relation tables from Exercise 31.
	 33.	Write an SQL query to give the employee ID, pay dates, and payment amounts for all pay dates with 
amounts > $100. Give the result of the query.
	 34.	Write an SQL query to give the contribution ID, pay date, and payment amount for all payments by Mary 
Black. Give the result of the query.
	 35.	Write an SQL query to give the first and last names and payment amount of all employees who had a 
payroll deduction on 1/15/2013. Give the result of the query.
	 36.	Write an SQL query to reproduce the universal relation of Exercise 31 from the three relation tables.
Figure 5.11
	
S e c t i o n  5 . 4 	 Functions
In this section we discuss functions, which are really special cases of binary rela-
tions from a set S to a set T. This view of a function is a rather sophisticated one, 
however, and we will work up to it gradually.
Definition
Function is a common enough word even in nontechnical contexts. A newspaper 
may have an article on how starting salaries for this year’s college graduates have 
increased over those for last year’s graduates. The article might say something 
like, “The salary increase varies depending on the degree program,” or, “The 
salary increase is a function of the degree program.” It may illustrate this func-
tional relationship with a graph like Figure 5.11. The graph shows that each degree 
program has some figure for the salary increase associated with it, that no degree 
program has more than one figure associated with it, and that both the physical 
sciences and the liberal arts have the same figure, 1.5%.
Engineering
Physical
science
Computer
science
Liberal arts
Business
3.0%
2.5%
2.0%
1.5%
1.0%
0.5%
0%

382	
Relations, Functions, and Matrices 
Of course, we also use mathematical functions in algebra and calculus. The 
equation g(x) = x3 expresses a functional relationship between a value for x and 
the corresponding value that results when the value for x is used in the equation. 
Thus an x value of 2 has the number 23 = 8 associated with it. (This number 
is expressed as g(2) = 8.) Similarly, g(1) = 13 = 1, g(−1) = (−1)3 = −1, and 
so on. For each x value, the corresponding g(x) value is unique. If we were to 
graph this function on a rectangular coordinate system, the points (2, 8), (1, 1), and 
(−1, −1) would be points on the graph. If we allow x to take on any real number 
value, the resulting graph is the continuous curve shown in Figure 5.12.
(–1, –1)
(1, 1)
(2, 8)
g(x)
x
The function in the salary increase example could be described as follows. We set 
the stage by the diagram in Figure 5.13, which indicates that the function always 
starts with a given degree program and that a particular salary increase is associ-
ated with that degree program. The association itself is described by the set of or-
dered pairs 5(engineering, 2. 25%), (physical sciences, 1. 5%), (computer science, 
2. 75%), (liberal arts, 1. 5%), (business, 2. 0%)6.
Computer science
Degree
%
2.75%
Real numbers
Real numbers
g(x)
g
x
For the algebraic example g(x) = x3, Figure 5.14 shows that the function 
­always starts with a given real number and associates a second real number with it. 
Figure 5.12
Figure 5.13
Figure 5.14
Degree programs
Salary increases by percent

Section 5.4   Functions	
383
The association itself is described by 5(x, g (x)) 0  g(x) = x36, or simply g (x) = x3. 
This set includes (2, 8), (1, 1), (−1,−1), but because it is an infinite set, we cannot 
list all its members; we have to describe them.
From the above examples, we can conclude that there are three parts to a 
function: (1) a set of starting values, (2) a set from which associated values come, 
and (3) the association itself. The set of starting values is called the domain of the 
function, and the set from which associated values come is called the codomain 
of the function. Thus both the domain and codomain represent pools from which 
values may be chosen. (This usage is consistent with our use of the word domain 
when discussing predicate wffs in Section 1.2. There the domain of an interpreta-
tion is a pool of values that variables can assume and to which constant symbols 
may be assigned. Similarly, the domain Di of an attribute Ai in a database relation, 
discussed in Section 5.3, is a pool of potential values for the attribute.)
The picture for an arbitrary function f is shown in Figure 5.15. Here f is a 
function from S to T, symbolized f: S S T. S is the domain and T is the codo-
main. The association itself is a set of ordered pairs, each of the form (s, t) where 
s [ S, t [ T, and t is the value from T that the function associates with the value 
s from S; t = f(s). Hence, the association is a subset of S × T (a binary relation 
from S to T). But the important property of this relation is that every member of 
S must have one and only one T value associated with it, so every s [ S will ap-
pear exactly once as the first component of an (s, t) pair. (This property does not 
prevent a given T value from appearing more than once.)
Domain S
Codomain T
f(s) = t
f
s
We are now ready for the formal definition of a function.
Figure 5.15
	
Definitions	
Terminology for Functions
Let S and T be sets. A function (mapping) f from S to T, f: S S T, is a subset of 
S × T where each member of S appears exactly once as the first component of 
an ordered pair. S is the domain and T is the codomain of the function. If (s, t) 
belongs to the function, then t is denoted by f (s); t is the image of s under  
f, s is a preimage of t under f, and f is said to map s to t. For A # S, f (A) denotes 
5  f (a) 0  a [ A6.
A function from S to T is a subset of S × T with certain restrictions on the 
ordered pairs it contains. That is why we spoke of a function as a special kind of 
binary relation. By the definition of a function, a binary relation that is one-to-
many (or many-to-many) cannot be a function. Also, each member of S must be 
used as a first component.
We have talked a lot about values from the sets S and T, but as our example 
of salary increases shows, these values are not necessarily numbers, nor is the as-
sociation itself necessarily described by an equation.

384	
Relations, Functions, and Matrices 
Practice 23	 Which of the following formulas are functions from the domain to the codomain indi-
cated? For those that are not, why not?
a.	 f: S S T where S = T = 51, 2, 36, f = 5(1, 1), (2, 3), (3, 1), (2, 1)6
b.	 g: Z S N where g is defined by g(x) = 0x0 (the absolute value of x)
c.	 h: N S N where h is defined by h(x) = x −4
d.	 f: S S T where S is the set of all people in your hometown, T is the set of all automobiles, and f  
associates with each person the automobile that person owns
e.	 g: S S T where S = 52013, 2014, 2015, 20166, T = 5$20,000, $30,000, $40,000, $50,000, 
$60,0006, and g is defined by the graph in Figure 5.16. 
f.	 h: S S T where S is the set of all quadratic polynomials in x with integer coefficients, T = Z, and 
h is defined by h(ax2 + bx + c) = b + c
g.	 f: R S R where f is defined by f (x) = 4x −1
h.	 g: N S N where g is defined by
g (x) = e x + 3 if x ≥5
x      if x ≤5
2013
2014
2015
Year
2016
60
50
40
30
Profit in thousands of dollars
20
10
0
Figure 5.16  Profits of the American Earthworm Corp. 
■
Practice 24	 Let f: Z S Z be defined by f (x) = x2.
a. 	What is the image of −4?
b. 	What are the preimages of 9?	
■
	
Example 27	
When we studied recursive definitions in Section 3.1, we talked about sequences, 
where a sequence S was written as
S(1), S(2), S(3), …
Changing the notation to
f (1), f (2), f (3), …
we see that a sequence is nothing but a list of functional values for a function f 
whose domain is the positive integers, and this is how a sequence is often defined. 

Section 5.4   Functions	
385
Indeed, the algorithms we gave for computing the values in such sequences were 
pseudocode that computes the function.
Also in Section 3.1, we talked about recursive operations such as an where a 
is a fixed nonzero real number and n ≥0. This is also simply a function f(n) = an 
whose domain is N. 	
The definition of a function includes functions of more than one variable. We 
can have a function f: S1 × S2 × c× Sn S T that associates with each ordered 
n-tuple of elements (s1, s2, …, sn), si [ Si, a unique element of T.
	
Example 28	
f: Z × N × 51, 26 S Z is given by f (x, y, z) = xy + z. Then f (−4, 3, 1) =  
(−4)3 + 1 = −64 + 1 = −63.	
	
Example 29	
In Section 4.1 we defined a unary operation on a set S as associating a unique 
member of S, x#, with each member x of S. This means that a unary operation on 
S is a function with domain and codomain S. We also defined a binary operation 
+ on a set S as associating a unique member of S, x + y, with every (x, y) pair of 
elements of S. Therefore a binary operation on S is a function with domain S × S 
and codomain S.	
Again, domain values and codomain values are not always numbers.
	
Example 30	
Let S be the set of all character strings of finite length. Then the association that pairs 
each string with the number of characters in the string is a function with domain S and 
codomain N (we allow the “empty string,” which has zero characters).	
	
Example 31	
Any propositional wff with n statement letters defines a function with domain 
5T, F6n and codomain 5T, F6. The domain consists of all n-tuples of T-F values; 
with each n-tuple is associated a single value of T or F. The truth table for the wff 
gives the association. For example, if the wff is A ~ B′, then the truth table
A
B
B∙
A ~  B′
T
T
F
T
T
F
T
T
F
T
F
F
F
F
T
T
says that the image of the 2-tuple (F, T) under this function is F. If we call this 
­function f, then f (F, T ) = F.	

386	
Relations, Functions, and Matrices 
The next example defines two functions that are sometimes useful in analyz-
ing algorithms.
Practice 25	 Let the function defined by the wff A ` (B ~ C′) be denoted by f. What is f (T, T, F )? 
What is f (F, T, F )?
	
Example 32	
The floor function :x; associates with each real number x the greatest integer less 
than or equal to x. The ceiling function <x= associates with each real number x the 
smallest integer greater than or equal to x. Thus :2.8; = 2, <2.8= = 3, :−4.1; = −5, 
and <−4.1= = −4. Both the floor function and the ceiling function are functions 
from R to Z.	
Practice 26	
a.	 Sketch a graph of the function :x;.	
b.	Sketch a graph of the function <x=.	
■
	
Example 33	
For any integer x and any positive integer n, the modulo function, denoted by 
f(x) = x mod n, associates with x the nonnegative remainder when x is divided by 
n. We can write x as x = qn + r, 0 ≤r < n, where q is the quotient and r is the 
remainder, so the value of x mod n is r.
25 = 12 # 2 + 1 so 25 mod 2 = 1
21 = 3 # 7 + 0 so 21 mod 7 = 0
15 = 3 # 4 + 3 so 15  mod  4 = 3
−17 = (−4) # 5 + 3 so −17  mod  5 = 3	
(it is true that 
−17 = (−3)5 + (−2) 
but remember that the 
­remainder must be 
­nonnegative)
Section 5.6 discusses some of the many applications of the modulo function.	
The definition of a function f: S S T includes three parts—the domain set S, 
the codomain set T, and the association itself. Is all this necessary? Why can’t we 
simply write an equation, like g(x) = x3, to define a function?
The quickest answer is that not all functional associations can be described by 
an equation (see Example 30, for instance). But there is more to it—let’s limit our 
attention to situations where an equation can be used to describe the association, 
such as g: R S R where g(x) = x3. Even in algebra and calculus, it is common to 
say “consider the function g(x) = x3,” implying that the equation is the function. 
Technically, the equation only describes a way to compute associated values. The 
function h: R S R given by h(x) = x3 −3x + 3(x + 5)−15 is the same func-
tion as g because it contains the same ordered pairs. However, the equation is 
different in that it says to process any given x value differently.
■

Section 5.4   Functions	
387
On the other hand, the function f: Z S R given by f (x) = x3 is not the same 
function as g. The domain has been changed, which changes the set of ordered 
pairs. The graph of f(x) would consist of discrete (separate) points (Figure 5.17). 
Most of the functions in which we are interested have this feature. Even in situa-
tions where one quantity varies continuously with another, in a digital computer 
we approximate by taking data at discrete, small intervals, much as the graph of 
g(x) (see Figure 5.12) is approximated by the graph of f (x) (see Figure 5.17).
(–1, –1)
(1, 1)
(2, 8)
f(x)
x
Finally, let’s look at the function k: R S C given by k(x) = x3. The equa-
tion and domain is the same as for g(x); the codomain has been enlarged, but 
the change does not affect the ordered pairs. Is this function considered the same 
function as g(x)? It is not, but to see why, we’ll have to wait until we discuss the 
onto property of functions. Then we will see that g has the onto property while k 
does not, so we do not want to consider them the same function.
In summary, a complete definition of a function requires giving its domain, 
its codomain, and the association, where the association may be given by a verbal 
description, a graph, an equation, or a collection of ordered pairs.
Figure 5.17
	
Definition	
Equal Functions
Two functions are equal if they have the same domain, the same codomain, and 
the same association of values of the codomain with values of the domain.
Suppose we are trying to show that two functions with the same domain and 
the same codomain are equal. Then we must show that the associations are the 
same. This can be done by showing that, given an arbitrary element of the domain, 
both functions produce the same associated value for that element; that is, they 
map it to the same place.
Practice 27	 Let S = 51, 2, 36 and T = 51, 4, 96. The function 
f: S S T is defined by 
f = 5(1, 1), (2, 4), (3, 9)6. The function g: S S T is defined by the equation
g(n) =
∙
n
k=1
(4k −2)
2
Prove that f = g.
■

388	
Relations, Functions, and Matrices 
Properties of Functions
Onto Functions
Let f: S S T be an arbitrary function with domain S and codomain T (Figure 
5.18). Part of the definition of a function is that every member of S has an image 
under f and that all the images are members of T; the set R of all such images is 
called the range of the function f. Thus, R = 5 f (s) 0  s [ S6, or R = f (S). Clearly, 
R # T; the range R is shaded in Figure 5.19. If it should happen that R = T, that 
is, that the range coincides with the codomain, then the function is called an onto 
function.
Domain S
Codomain T
f(s) = t
f
s
Domain S
Codomain T
f(s) = t
R = f(S)
f
s
Figure 5.18
Figure 5.19
	
Definition	
Onto (Surjective) Function
A function f: S S T is an onto or surjective function if the range of f equals the 
codomain of  f.
In every function with range R and codomain T, R # T. To prove that a given 
function is onto, we must show that T # R; then it will be true that R = T. We 
must therefore show that an arbitrary member of the codomain is a member of the 
range, that is, that it is the image of some member of the domain. On the other 
hand, if we can produce one member of the codomain that is not the image of any 
member of the domain, then we have proved that the function is not onto.
REMINDER
To show that a function 
is onto, pick an arbitrary 
element in the codomain 
and show that it has a 
preimage in the domain.
	
Example 34	
The function g: R S R defined by g(x) = x3 is an onto function. To prove that 
g(x) is onto, let r be an arbitrary real number, and let x = !
3 r. Then x is a real 
number, so x belongs to the domain of g and g(x) = (!
3 r)3 = r. Hence, any mem-
ber of the codomain is the image under g of a member of the domain. The function 
k: R S C given by k(x) = x3 is not onto. There are many complex numbers (i, for 
example) that cannot be obtained by cubing a real number. Thus, g and k are not 
equal functions.	

Section 5.4   Functions	
389
One-to-One Functions
The definition of a function guarantees a unique image for every member of the 
domain. A given member of the range may have more than one preimage, how-
ever. In our very first example of a function (salary increases), both physical sci-
ences and liberal arts were preimages of 1.5%. This function was not one-to-one.
	
Example 35	
Let f: Q S Q be defined by f (x) = 3x + 2. To test whether f is onto, let q [ Q. 
We want an x [ Q such that f (x) = 3x + 2 = q. When we solve this equation for 
x, we find that x = (q −2)∙3 is the only possible value and is indeed a member 
of Q. Thus, q is the image of a member of Q under f, and f is onto. However, the 
function h: Z S Q defined by h(x) = 3x + 2 is not onto because there are many 
values q [ Q, for example 0, for which the equation 3x + 2 = q has no integer 
solution.	
Practice 28	 Which of the functions found in Practice 23 are onto functions?
■
Practice 29	 Suppose a function f: 5T, F6n S 5T, F6 is defined by a propositional wff P (see Example 31).
Give the two conditions on P under each of which f will fail to be an onto function.
■
	
Definition	
One-to-One (Injective) Function
A function f: S S T is one-to-one, or injective, if no member of T is the image 
under f of two distinct elements of S.
The one-to-one idea here is the same as for binary relations in general, as 
discussed in Section 5.1, except that every element of S must appear as a first com-
ponent in an ordered pair. To prove that a function is one-to-one, we assume that 
there are elements s1 and s2 of S with f(s1) = f(s2) and then show that s1 = s2. To 
prove that a function is not one-to-one, we produce a counterexample, an element 
in the range with two preimages in the domain.
REMINDER
To show that a function 
f is one-to-one, assume 
f(s1) = f(s2) and show that 
s1 = s2.
	
Example 36	
The function g: R S R defined by g(x) = x3 is one-to-one because if x and y are 
real numbers with g(x) = g( y), then x3 = y3 and x = y. The function f: R S R 
given by f (x) = x2 is not one-to-one because, for example, f (2) = f (−2) = 4. 
However, the function h: N S N given by h(x) = x2 is one-to-one because if x 
and y are nonnegative integers with h(x) = h( y), then x2 = y2; because x and y are 
both nonnegative, x = y.	
Practice 30	 Which of the functions found in Practice 23 are one-to-one functions?
■

390	
Relations, Functions, and Matrices 
	
Example 37	
The floor function and the ceiling function of Example 32 are clearly not one-to-
one. This is evident also in the graphs of these functions (Practice 26), which have 
a number of horizontal sections, indicating that many different domain values in R 
are mapped by the function to the same codomain value in Z.	
Figure 5.20 gives simple illustrations about functions and their properties. In 
each case, the domain is on the left and the codomain is on the right.
Function, not one-to-one, onto
Function, one-to-one, not onto
Function, one-to-one, onto
Not a function
Not a function
Function, not one-to-one, not onto
Bijections
Figure 5.20
	
Definition	
Bijective Function
A function f: S S T is bijective (a bijection) if it is both one-to-one and onto.
REMINDER
To prove that a function is 
a bijection requires prov-
ing two things—onto and 
one-to-one.
	
Example 38	
The function g: R S R given by g(x) = x3 is a bijection. The function in part 
(g) of Practice 23 is a bijection. The function f: R S R given by f (x) = x2 is 
not a ­bijection (not one-to-one), and neither is the function k: R S C given by 
k(x) = x3 (not onto).	
Composition of Functions
Suppose that f and g are functions with f: S S T and g: T S U. Then for any 
s [ S, f (s) is a member of T, which is also the domain of g. Thus, the function g 
can be applied to f (s). The result is g (  f (s)), a member of U (Figure 5.21). Taking 
an arbitrary member s of S, applying the function f, and then applying the function 
g to f(s) is the same as associating a unique member of U with s. In short, we have 
created a function S S U, called the composition function of f and g and denoted 
by g + f  (Figure 5.22).
S
T
U
g(f(s))
f(s)
s
Figure 5.21

Section 5.4   Functions	
391
S
T
U
g(f(s))
f(s)
s
g ° f
Figure 5.22
	
Definition	
Composition Function
Let f: S S T and g: T S U. Then the composition function, g + f , is a function 
from S to U defined by ( g + f   )(s) = g (  f (s)).
Note that the function g + f  is applied right to left; function f is applied first 
and then function g.
The diagram in Figure 5.23 also illustrates the definition of the composition 
function. The corners indicate the domains and codomains of the three functions. 
The diagram says that, starting with an element of S, if we follow either path g + f  
or path f followed by path g, we get to the same element in U. Diagrams illustrating 
that alternate paths produce the same effect are called commutative diagrams.
g
f
g ° f
S
T
U
Figure 5.23
It is not always possible to take any two arbitrary functions and compose 
them; the domains and ranges have to be “compatible.” For example, if f: S S T 
and g:W S Z, where T and W are disjoint, then ( g + f  )(s) = g (  f(s)) is undefined 
because f(s) is not in the domain of g.
Practice 31	 Let f: R S R be defined by f(x) = x2. Let g: R S R be defined by g(x) = :x;.
a.	 What is the value of (g + f ) (2.3)?
b.	What is the value of ( f + g)(2.3)?
■
From Practice 31 we see that order is important in function composition, 
which should not be surprising. If you make a deposit in your checking account 
and then write a large check, the effect is not the same as if you write a large check 
and later make a deposit! Your bank is very sensitive to these differences.

392	
Relations, Functions, and Matrices 
Function composition preserves the properties of being onto and being one-
to-one. Again, let f: S S T and g: T S U, but also suppose that both f and g 
are onto functions. Then the composition function g + f  is also onto. Recall that  
g + f: S S U, so we must pick an arbitrary u [ U and show that it has a 
preimage under g + f  in S. Because g is onto, there exists t [ T such that 
g(t) = u. And because f is onto, there exists s [ S such that f(s) = t. Then 
(g + f )(s) = g( f (s)) = g(t) = u, and g + f  is an onto function.
Practice 32	 Let f: S S T and g: T S U, and assume that both f and g are one-to-one functions. 
Prove that g + f  is a one-to-one function. (Hint: Assume that (g + f  )(s1) = (g + f  )(s2).)
■
We have now proved the following theorem.
	
Theorem	
On Composing Two Bijections
The composition of two bijections is a bijection.
Inverse Functions
Bijective functions have another important property. Let f: S S T be a bijection. 
Because f is onto, every t [ T has a preimage in S. Because f is one-to-one, that 
preimage is unique. We can associate with each element t of T a unique member of 
S, namely, that s [ S such that f(s) = t. This association describes a function g, 
g: T S S. The picture for f and g is given in Figure 5.24. The domains and codo-
mains of g and f are such that we can form both g + f: S S S and f + g: T S T. If 
s [ S, then (g + f )(s) = g( f (s)) = g(t) = s. Thus, g + f  maps each element of S 
to itself. The function that maps each element of a set S to itself, that is, that leaves 
each element of S unchanged, is called the identity function on S and denoted by 
iS. Hence, g + f = iS.
S
T
f(s) = t
s = g(t)
f
g
Figure 5.24
Practice 33	 Show that f + g = iT.
■

Section 5.4   Functions	
393
We have now seen that if f is a bijection, f: S S T, then there is a ­function 
g: T S S with g + f = iS and f + g = iT. The converse is also true. To prove 
the converse, suppose f: S S T and there exists g: T S S with g + f = iS and 
f + g = iT. We can prove that f is a bijection. To show that f is onto, let t [ T. 
Then t = iT(t) = ( f + g)(t) = f (g(t)). Because g: T S S, g(t) [ S, and g(t) is the 
preimage under f of t. To show that f is one-to-one, suppose f (s1) = f (s2). Then 
g( f (s1)) = g( f (s2)) and (g + f )(s1) = (g + f )(s2) implying iS(s1) = iS(s2), or  
s1 = s2. Thus, f is a bijection.
	
Definition	
Inverse Function
Let f be a function, f: S S T. If there exists a function g: T S S such that 
g + f = iS and f + g = iT, then g is called the inverse function of f, denoted  
by f  −1.
We have proved the following theorem.
	
Theorem	
On Bijections and Inverse Functions
Let f: S S T. Then f is a bijection if and only if f −1 exists.
Actually, we have been a bit sneaky in talking about the inverse function 
of f. What we have shown is that if f is a bijection, this is equivalent to the ex-
istence of an inverse function. But it is easy to see that there is only one such 
inverse function. When you want to prove that something is unique, the stan-
dard technique is to assume that there are two different such things and then 
obtain a contradiction. Thus, suppose f has two inverse functions, f1
 −1 and f2
 −1 
(existence of either means that f is a bijection). Both f1
 −1 and f2
 −1 are functions 
from T to S; if they are not the same function, then they must act differently 
somewhere. Assume that there is a t [ T such that f1
  −1(t) ∙f2
 −1(t). Because f is 
one-to-one, it follows that f (  f1
  −1(t)) ∙f (  f2
 −1(t)), or ( f + f1
 −1)(t) ∙( f + f2
 −1)(t). 
But both f + f1
 −1 and f + f2
 −1 are iT, so t ∙t, which is a contradiction. We are 
therefore justified in speaking of f −1 as the inverse function of f. If f is a bijec-
tion, so that f −1 exists, then f is the inverse function for f −1; therefore, f −1 is 
also a bijection.
Practice 34	  f: R S R given by f (x) = 3x + 4 is a bijection. 
Describe f −1.
■

394	
Relations, Functions, and Matrices 
We’ve introduced a lot of terminology about functions. Table 5.2 gives an 
informal summary of these terms.
Table 5.2
Term
Meaning
function
Mapping from one set to another that associates with each member of the starting 
set exactly one member of the ending set
domain
Starting set for a function
codomain
Ending set for a function
image
Point that results from a mapping
preimage
Starting point for a mapping
range
Collection of all images of the domain
onto (surjective)
Range is the whole codomain; every codomain element has a preimage
one-to-one (injective)
No two elements in the domain map to the same place
bijection
One-to-one and onto
identity function
Maps each element of a set to itself
inverse function
For a bijection, a new function that maps each codomain element back where it 
came from
Permutation Functions
Bijections that map a set to itself are given a special name.
	
Definition	
Permutations of a Set
For a given set A, SA = 5  f 0   f: A S A and f is a bijection6. SA is thus the set of 
all bijections of set A into (and therefore onto) itself; such functions are called 
permutations of A.
If f and g both belong to SA, then they each have domain = range = A. There-
fore the composition function g + f  is defined and maps A S A. Furthermore, 
because f and g are both bijections, our theorem on composing bijections says 
that g + f  is a bijection, a (unique) member of SA. Thus, function composition is a 
binary operation on the set SA.
In Section 4.4 we described a permutation of objects in a set as being an or-
dered arrangement of those objects. Is this now a new use of the word “permuta-
tion”? Not exactly; permutation functions represent ordered arrangements of the 
objects in the domain. If A = 51, 2, 3, 46, one permutation function of A, call it 
f, is given by f = 5(1, 2), (2, 3), (3, 1), (4, 4)6. We can also describe function f in 
array form by listing the elements of the domain in a row and, directly beneath, 
the images of these elements under f. Thus,
f = a1
2
3
4
2
3
1
4b
The bottom row is an ordered arrangement of the objects in the top row.

Section 5.4   Functions	
395
A shorter way to describe the permutation f shown in array form is to use 
cycle notation and write f = (1, 2, 3)—understood to mean that f maps each 
element listed to the one on its right, the last element listed to the first, and an 
element of the domain not listed to itself. Here 1 maps to 2, 2 maps to 3, and 3 
maps to 1. The element 4 maps to itself because it does not appear in the cycle. 
The cycle (2, 3, 1) also represents f. It says that 2 maps to 3, 3 maps to 1, 1 maps 
to 2, and 4 maps to itself, the same information as before. Similarly, (3, 1, 2) 
also represents f.
Practice 35	
a.	 Let A = 51, 2, 3, 4, 56, and let f [ SA be given in array form by
f = a1
2
3
4
5
4
2
3
5
1b
Write f in cycle form.
b.	Let A = 51, 2, 3, 4, 56, and let g [ SA be given in cycle form by g = (2, 4, 5, 3). Write g in  
array form.	
■
If  f and g are members of SA for some set A, then g + f [ SA, and the ac-
tion of g + f  on any member of A is determined by applying function f and then  
function g. If f and g are cycles, g + f  is still computed the same way.
	
Example 39	
If A = 51, 2, 3, 46 and f, g [ SA are given by f = (1, 2, 3) and g = (2, 3), then 
g + f = (2, 3) + (1, 2, 3). But what does this composition function look like? Let’s 
see what happens to element 1 of A. Working from right to left (first f, then g), 
1 S 2 under f and then 2 S 3 under g, so 1 S 3 under g + f . If we want to write 
g + f  as a cycle, we see that it can start with 
(1, 3
and we next need to see what happens to 3. Under f, 3 S 1 and then under g, 
1 S 1 (because 1 does not appear in the cycle notation for g), so 3 S 1 under 
g + f . Thus we can close the above cycle, writing it as (1, 3). But what happens to 
2 and 4? If we consider 2, 2 S 3 under f and then 3 S 2 under g, so 2 S 2 under 
g + f . Similarly, 4 S 4 under f and 4 S 4 under g, so 4 S 4 under g + f . We con-
clude that g + f = (1, 3). 	
In Example 39, if we were to compute f + g = (1, 2, 3) + (2, 3), we would get 
(1, 2). (We already know that order is important in function composition.) If, how-
ever, f and g are members of SA and f and g are disjoint cycles—the cycles have 
no elements in common—then f + g = g + f .

396	
Relations, Functions, and Matrices 
Let A = 51, 2, 3, 46 and consider the cycle f [ SA given by f = (1, 2). If we 
compute f + f = (1, 2) + (1, 2), we see that each element of A is mapped to itself. 
The permutation that maps each element of A to itself is the identity function on 
A, iA, also called the identity permutation.
If A is an infinite set, not every permutation of A can be written as a cycle. But 
even when A is a finite set, not every permutation of A can be written as a cycle; 
for example, the permutation g + f  of Practice 36(b) cannot be written as a cycle. 
However, every permutation on a finite set that is not the identity permutation can 
be written as a composition of one or more disjoint cycles. The permutation
a1
2
3
4
5
4
2
5
1
3b
of Practice 36(b) is (1, 4) + (3, 5) or (3, 5) + (1, 4).
Practice 36	 Let A = 51, 2, 3, 4, 56. Compute g + f  and f + g for the following cycles in SA.
a.	 f = (5, 2, 3); g = (3, 4, 1). Write the answers in cycle form.
b.	 f = (1, 2, 3, 4); g = (3, 2, 4, 5). Write the answers in array form.
c.	 f = (1, 3); g = (2, 5). Write the answers in array form.	
■
Practice 37	 Write
a1
2
3
4
5
6
2
4
5
1
3
6b
as a composition of disjoint cycles.	
■
Among the permutations of A, some will map certain elements of A to them-
selves, while others will so thoroughly mix elements around that no element in A 
is mapped to itself. A permutation on a set that maps no element to itself is called 
a derangement.
	
Example 40	
The permutation f on A = 51, 2, 3, 4, 56 given in array form by
a1
2
3
4
5
2
5
4
1
3b
is a derangement. Members of SA that are not derangements, if written as a cycle 
or a product of cycles, will have at least one element of A that is not listed. Thus 
g [ SA defined as g = (1, 4) + (3, 5) maps 2 to itself, so g is not a derangement.	

Section 5.4   Functions	
397
How Many Functions
Suppose S and T are finite sets, say 0S 0 = m and 0T 0 = n. What can we say about 
the number of functions with various properties that map S to T? First, let’s just 
count the number of functions f: S S T, assuming no special properties about 
the functions. The multiplication principle can be used here because we can think 
of defining a function by assigning an image to each of the m elements of S. This 
gives us a sequence of m tasks. Each task has n outcomes because each element of 
S can map to any element in T. Therefore the number of functions is
0 n × n × n × c× n 0 = nm
0
m factors
How many one-to-one functions are there from S to T? We must have m ≤n 
or we can’t have any one-to-one functions at all. (All the elements of S must be 
mapped to T, and if m > n there are too many elements in S to allow for a one-
to-one mapping. Actually, this is the pigeonhole principle at work.) We can again 
solve this problem by carrying out the sequence of tasks of assigning an image to 
each element in S, but this time we cannot use any image we have used before. By 
the multiplication principle, we have a product that begins with the factors
n(n −1)(n −2) c
and must contain a total of m factors, so the result is
n(n −1)(n −2) c  3n −(m −1)4 = n(n −1)(n −2) c (n −m + 1)
=
n!
(n −m)! = P(n,m)
How many onto functions are there from S to T? This time we must have 
m ≥n so that there are enough values in the domain to provide preimages for 
every value in the codomain. (By the definition of a function, an element in S can-
not be a preimage of more than one element in T.) Our overall plan is to subtract 
the number of non-onto functions from the total number of functions, which we 
know. To count the number of non-onto functions, we’ll use the principle of inclu-
sion and exclusion.
Enumerate the elements of set T as t1, … , tn. For each i, 1 ≤i ≤n, let Ai de-
note the set of functions from S to T that do not map anything to element ti. (These 
sets are not disjoint, but every non-onto function belongs to at least one such set.) 
By the principle of inclusion and exclusion, we can write
 0  A1 c cc  An 0  = ∙
1≤i≤n
 0  Ai 0  −
∙
1≤i<j≤n
 0  Ai dA j 0  +
∙
1≤i<j<k≤n
 0  Ai d Aj d Ak 0  
 
 
−c+ (−1)n+1
 0  A1 d c d An 0  	
(1)

398	
Relations, Functions, and Matrices 
For any i, 0Ai0 is the number of functions that do not map anything to ti but 
have no other restrictions. By the multiplication principle, we can count the num-
ber of such functions by counting for each of the m domain elements its n −1 
possible images. The result is that 0Ai0 = (n −1)m. Therefore the first summation 
in Equation (1) adds together terms that are all of the same size. There is one such 
term for each distinct individual set Ai out of the n sets, so there are C(n, 1) such 
terms.
For any i and j, 0Ai d Aj0 is the number of functions that do not map anything 
to ti or tj, leaving n −2 possible images for each of the m elements of S. Thus 
0Ai d Aj0 = (n −2)m. The second summation adds one such term for each distinct 
group of two sets out of n, so there are C(n, 2) such terms.
A similar result holds for all the intersection terms. If there are k sets in the 
intersection, then there are (n −k)m functions in the intersection set and there are 
C(n, k) distinct groups of k sets to form the intersection. Equation (1) can thus be 
written as
0A1 c c c An0 = C(n, 1)(n −1)m −C(n, 2)(n −2)m + C(n, 3)(n −3)m
                 −c+ (−1)n+1C(n, n)(n −n)m	
(2)
Now the expression on the left of Equation (2) represents the number of all func-
tions that fail to map to at least one of the elements of T, that is, all the non-onto 
functions. If we subtract the value of this expression from the total number of 
functions, which we know is nm, we will have the number of onto functions. Thus 
the number of onto functions is
nm −C(n, 1)(n −1)m + C(n, 2)(n −2)m −C(n, 3)(n −3)m
+ c+ (−1)n−1C(n, n −1)3n −(n −1)4m + (−1)nC(n, n)(n −n)m
where we’ve added the next-to-last term. The last term is zero, so the final answer is
nm −C(n, 1)(n −1)m + C(n, 2)(n −2)m −C(n, 3)(n −3)m
                                  + … + (−1)n−1 C(n, n −1)(1)m
We’ll summarize these results.
	
Theorem	
On the Number of Functions with Finite Domains  
	
	
and Codomains
If 0S 0 = m and 0T 0 = n, then
	
1.	 The number of functions f: S S T is nm.
	
2.	 The number of one-to-one functions f: S S T, assuming that m ≤n, is
n!
(n −m)!
	
3.	 The number of onto functions f: S S T, assuming that m ≥n, is
nm −C(n, 1)(n −1)m + C(n, 2)(n −2)m −C(n, 3)(n −3)m
                               
+ … + (−1)n−1C(n, n −1)(1)m 

Section 5.4   Functions	
399
If A is a set with 0A0 = n, then the number of permutations of A is n!. This 
number can be obtained by any of three methods:
	
1.	 A combinatorial argument (each of the n elements in the domain must map 
to one of the n elements in the range with no repetitions)
	
2.	 Thinking of such functions as permutations on a set with n elements and 
noting that P(n, n) = n!
	
3.	 Using result (2) in the previous theorem with m = n
We propose to count the number of derangements on A. Our plan is similar 
to the one we used in counting onto functions. We’ll use the principle of inclusion 
and exclusion to compute the number of permutations that are not derangements 
and then subtract this value from the total number of permutation functions.
Enumerate the elements of set A as a1, … , an. For each i, 1 ≤i ≤n, let Ai 
be the set of all permutations that leave ai fixed. (These sets are not disjoint, but 
every permutation that is not a derangement belongs to at least one such set.) By 
the principle of inclusion and exclusion, we can write
0A1 c  c c  An0 = ∙
1≤i≤n
0Ai0 −
∙
1≤i<j≤n
0Ai d Aj0 +
∙
1≤i<j<k≤n
0Ai d Aj d Ak0 
               
−c+ (−1)n+10A1 d c  d An0	
(3)
For any i, 0Ai0 is the number of permutations that leave ai fixed. By the mul-
tiplication principle we can count the number of such functions by counting for 
each of the n domain elements, beginning with ai, its possible images. There is 
only one choice of where to map ai because it must map to itself; the next element 
can map anywhere except to ai, so there are n −1 outcomes; the next element can 
map anywhere except the two images already used, so there are n −2 outcomes, 
and so on. Continuing, there are
(1)(n −1)(n −2) c (1) = (n −1)!
	
Example 41	
Let S = 5A, B, C6 and T = 5a, b6. Find the number of functions from S onto T.
Here m = 3 and n = 2. By our theorem on the number of functions, there are
23 −C(2, 1)(1)3 = 8 −2 # 1 = 6
such functions.	
Practice 38	 One of the six onto functions in Example 41 can be illustrated by the following diagram:
A
B
C
a
b
Draw diagrams for the remaining five onto functions.
■

400	
Relations, Functions, and Matrices 
elements in Ai for each i. Therefore the first summation in equation (3) adds to-
gether terms that are all of the same size. The number of such terms equals the 
number of ways to pick one set Ai out of the n such sets, or C(n, 1).
In the second summation, the terms count the number of permutations on n 
elements that leave two of those elements fixed. There are
(1)(1)(n −2) c (1) = (n −2)!
such functions in a given Ai d Aj, and C(n, 2) ways to choose the two sets out of 
n. In general, if there are k sets in the intersection, then k elements must be held 
fixed, so there are (n −k)! functions in the intersection set, and there are C(n, k) 
ways to choose the k sets to form the intersection. Therefore equation (3) becomes
0A1 c  c c An0 = C(n, 1)(n −1)! −C(n, 2)(n −2)! + C(n, 3)(n −3)!
                     −c+ (−1)n+1C(n, n)(n −n)!
This expression represents the number of all possible nonderangement permu-
tations. We subtract this value from the total number of permutation functions, 
which is n!:
n! −C(n, 1)(n −1)! + C(n, 2)(n −2)! −C(n, 3)(n −3)!
                             
+ c+ (−1)nC(n, n)(n −n)!
Rewriting this expression,
n! −
n!
1!(n −1)! (n −1)! +
n!
2!(n −2)! (n −2)! −
n!
3!(n −3)! (n −3)!
	
+ c+ (−1)n n!
n!0! 0!
	
= n! −n!
1! + n!
2! −n!
3! + c+ (−1)n n!
n!
	
= n! c1 −1
1! + 1
2! −1
3! + c+ (−1)n 1
n! d 	
(4)
	
Example 42	
For n = 3, Equation (4) says that the number of derangements is
3!a1 −1
1! + 1
2! −1
3!b = 3!
2! −3!
3! = 3 −1 = 2
Written in array form, the two derangements are
	
a1
2
3
2
3
1b 	
and 	
a1
2
3
3
1
2b

Section 5.4   Functions	
401
Equivalent Sets
	
Definitions	
Equivalent Sets and Cardinality
A set S is equivalent to a set T if there exists a bijection f: S S T. Two sets that 
are equivalent have the same cardinality.
The notion of equivalent sets allows us to extend our definition of cardinality 
from finite to infinite sets. The cardinality of a finite set is the number of elements 
in the set. If S is equivalent to T, then all the members of S and T are paired off 
by f in a one-to-one correspondence. If S and T are finite sets, this pairing off can 
happen only when S and T are the same size. With infinite sets, the idea of size 
gets a bit fuzzy, because we can sometimes prove that a given set is equivalent to 
what seems to be a smaller set. The cardinality of an infinite set is therefore given 
only in a comparative sense; for example, we may say that an infinite set A has (or 
does not have) the same cardinality as the set N.
Practice 39	 Describe a bijection f: Z S N, thus showing that Z is equivalent to N (Z and N have the 
same cardinality) even though N ( Z.
■
If we have found a bijection between a set S and N, we have established a one-to-
one correspondence between the members of S and the nonnegative integers. We 
can then name the members of S according to this correspondence, writing s0 for 
the value of S associated with 0, s1 for the value of S associated with 1, and so on. 
Then the list
s0, s1, s2, …
includes all the members of S. Since this list constitutes an enumeration of S, S is 
a denumerable set. Conversely, if S is denumerable, then a listing of the members 
of S exists and can be used to define a bijection between S and N. Therefore a set 
is denumerable if and only if it is equivalent to N.
For finite sets, we know that if S has n elements, then `(S ) has 2n elements. 
Of course, 2n > n, and we cannot find a bijection between a set with n elements 
and a set with 2n elements. Therefore S and `(S ) are not equivalent. This result is 
also true for infinite sets.
	
Theorem	
Cantor’s Theorem
For any set S, S and `(S ) are not equivalent.
Proof : We will do a proof by contradiction and assume that S and `(S ) are equiva-
lent. Let f be the bijection between S and `(S ). For any member s of S, f (s) is a 
member of `(S ), so f (s) is a set containing some members of S, possibly contain-
ing s itself. Now we define a set X = 5x [ S 0  x o f (x)6. Because X is a subset of 
S, it is an element of `(S ) and therefore must be equal to f ( y) for some y [ S. 

402	
Relations, Functions, and Matrices 
Then y either is or is not a member of X. If y [ X , then by the definition of X, 
y o f ( y), but since f ( y) = X , then y o X . On the other hand, if y o X , then since 
X = f ( y), y o f ( y), and by the definition of X, y [ X . In either case, there is a 
contradiction, and our original assumption is incorrect. Therefore S and `(S ) are 
not equivalent. End of Proof
The proof of Cantor’s theorem depends on the nature of set X, which was care-
fully constructed to provide the crucial contradiction. In this sense, the proof is 
similar to the diagonalization method (see Example 23 in Chapter 4) used to prove 
the existence of an uncountable set. Indeed, the existence of an uncountable set 
can be shown directly from Cantor’s theorem.
Exercises 5.4
	 1.	 The accompanying figure represents a function.
5
6
4
7
8
8
9
10
11
	
a.	 What is the domain? What is the codomain? What is the range?
	
b.	What is the image of 5? of 8?
	
c.	 What are the preimages of 9?
	
d.	Is this an onto function? Is it one-to-one?
	
Example 43	
The set N is, of course, a denumerable set. By Cantor’s theorem, the set `(N) is 
not equivalent to N and is therefore not a denumerable set, although it is clearly 
infinite.	
S e c t i o n  5 . 4 	
Review
Techniques
•	 Test whether a given relation is a function.
•	 Test a function for being one-to-one or onto. 
•	 Find the image of an element under function com-
position.
•	 Write permutations of a set in array or cycle 
form.
•	 Count the number of functions, one-to-one ­functions, 
and onto functions from one finite set to ­another.
Main Ideas
•	 The concept of function, especially bijective 
­function, is extremely important.
•	 Composition of functions preserves ­bijectiveness.
•	 The inverse function of a bijection is itself a ­bijection.
•	 Permutations are bijections on a set.
W
W

Section 5.4   Functions	
403
	 2.	 The accompanying figure illustrates various binary relations from R to R. Which are functions? For those 
that are functions, which are onto? Which are one-to-one?
(a)
(b)
(c)
(d)
	 3.	 Using the equation f (x) = 2x −1 to describe the functional association, write the function as a set of 
ordered pairs if the codomain is R and the domain is
	
a.	 S = 50, 1, 26.
	
b.	 S = 51, 2, 4, 56.
	
c.	 S = 5"7, 1.56.
	 4.	 Using the equation f (x) = x2 + 1 to describe the functional association, write the function as a set of 
ordered pairs if the codomain is Z and the domain is
	
a.	 S = 51, 56.
	
b.	 S = 5−1, 2, −26.
	
c.	 S = 5−"12, 36.
	 5.	 If f : Z S Z is defined by f(x) = 3x, find f(A) for
	
a.	 A = 51, 3, 56.
	
b.	 A = 5x 0  x [ Z and (Ey)(y [ Z and x = 2y)6.
	 6.	 If f : R S R is defined by f(x) = x2, describe
	
a.	 f (N).
	
b.	 f (Z).
	
c.	 f (R).

404	
Relations, Functions, and Matrices 
	 7.	 The function f: 5all English words6 S Z. In each case, find f (S ).
	
a.	 S = 5dog, cat, buffalo, giraffe6, f (x) = the number of characters in x
	
b.	 S = 5goose, geese, moose, Mississippi6, f (x) = the number of double-letter pairs in x
	
c.	 S = 5cheetah, seal, porpoise, koala6, f (x) = the number of e’s in x
	 8.	 The function f: 5binary strings6 S 5binary strings6. In each case, find f (S ).
	
a.	 S = 5000, 1011, 100016, f (x) = the second bit in x
	
b.	 S = 5111, 100, 01116, f (x) = the binary string that is the sum of the first and last bit
	
c.	 S = 5001, 11, 1016, f (x) = the binary string that is equal to x + 1
	 9.	 True or false:
	
a.	 An onto function means that every element in the codomain must have a unique preimage.
	
b.	A one-to-one function means that every element in the codomain must have a unique preimage.
	
c.	 A one-to-one function means that no two elements in the domain map to the same element in the 
­codomain.
	
d.	An onto function means that (the range) d (the codomain) = [.
	 10.	True or false:
	
a.	 If every element in the domain has an image, it must be an onto function.
	
b.	If every element in the codomain has an image, it must be an onto function.
	
c.	 If every element in the codomain has a preimage, it must be an onto function.
	
d.	If the domain is the larger than the codomain, it can’t be a one-to-one function.
	 11.	Let S = 50, 2, 4, 66 and T = 51, 3, 5, 76. Determine whether each of the following sets of ordered pairs 
is a function with domain S and codomain T. If so, is it one-to-one? Is it onto?
	
a.	 5(0, 2), (2, 4), (4, 6), (6, 0)6
	
b.	 5(6, 3), (2, 1), (0, 3), (4, 5)6
	
c.	 5(2, 3), (4, 7), (0, 1), (6, 5)6
	
d.	 5(2, 1), (4, 5), (6, 3)6
	
e.	 5(6, 1), (0, 3), (4, 1), (0, 7), (2, 5)6
	 12.	For any bijections in Exercise 11, describe the inverse function. 
	 13.	Let S = the set of all U. S. citizens alive today. Which of the following are functions from domain S to the 
codomain given? Which functions are one-to-one? Which functions are onto?
	
a.	 Codomain = the alphabet, f (person) = initial of person’s middle name
	
b.	 Codomain = the set of dates between January 1 and December 31,   f (person) = person’s date of birth
	
c.	 Codomain = 9-digit numbers, f (person) = person’s Social Security number
	 14.	Let S = the set of people at a meeting, let T = the set of all shoes in the room. Let f (x) = the left shoe x 
is wearing.
	
a.	 Is this a function?
	
b.	Is it one-to-one?
	
c.	 Is it onto?

Section 5.4   Functions	
405
	 15.	Which of the following definitions describe functions from the domain to the codomain given? Which 
functions are one-to-one? Which functions are onto? Describe the inverse function for any bijective 
­function.
	
a.	 f: Z S N where f is defined by f (x) = x2 + 1
	
b.	 g: N S Q where g is defined by g(x) = 1∙x
	
c.	 h: Z × N S Q where h is defined by h(z, n) = z∙(n + 1)
	
d.	 f: 51, 2, 36 S 5p, q, r6 where f = 5(1, q), (2, r), (3, p)6
	
e.	 g: N S N where g is given by g(x) = 2x
	
f.	 h: R2 S R2 where h is defined by h(x, y) = (y + 1, x + 1)
	 16.	Which of the following definitions describe functions from the domain to the codomain given? Which 
functions are one-to-one? Which functions are onto? Describe the inverse function for any bijective 
­function.
	
a.	 f: Z2 S N where f is defined by f (x, y) = x2 + 2y2
	
b.	 f: N S N where f is defined by f (x) = e x∙2  if x is even
 x + 1 if x is odd
	
c. 	g: R S R where g is defined by g(x) = 1∙ "(x + 1)
	
d. 	f: N S N where f is defined by f (x) = e x + 1 if x is even
x −1 if x is odd
	
e	 h: N3 S N where h is given by h(x, y, z) = x + y −z
	
f. 	g: N2 S N3 where g is defined by g(x, y) = (y, x, 0)
	 17.	Let f: R S R be defined by f (x) = xn, where n is a fixed, positive integer. For what values of n is f 
­bijective?
	 18.	Let f: R S R be defined by f (x) = n2x, where n is a fixed, positive integer. For what values of n is f an 
onto function?
	 19.	Let A = 5x, y6 and let A* be the set of all strings of finite length made up of symbols from A. A function 
f : A* S Z is defined as follows: For s in A*, f(s) = the length of s. Is f one-to-one? Prove or disprove. 
Is f onto? Prove or disprove.
	 20.	Let A = 5x, y6 and let A* be the set of all strings of finite length made up of symbols from A. A function 
f : A* S Z is defined as follows: For s in A*, f(s) = the number of x’s minus the number of y’s. Is f one-
to-one? Prove or disprove. Is f onto? Prove or disprove.
	 21.	Let A = 5x, y6 and let A* be the set of all strings of finite length made up of symbols from A. A function 
f : A* S A* is defined as follows: For s in A*, f(s) is the string obtained by writing the characters of s in 
reverse order. Is f one-to-one? Prove or disprove. Is f onto? Prove or disprove.
	 22.	Let A = 5x, y6 and let A* be the set of all strings of finite length made up of symbols from A. A function 
f : A* S A* is defined as follows: For s in A*, f(s) = xs (the single-character string x followed by s). Is f 
one-to-one? Prove or disprove. Is f onto? Prove or disprove.
	 23.	Let P be the power set of 5a, b, c6. A function f: P S Z is defined as follows: For A in P, 
f(A) = the number of elements in A. Is f one-to-one? Prove or disprove. Is f onto? Prove or disprove.
	 24.	Let P be the power set of 5a, b6 and let S be the set of all binary strings of length 2. A function f: P S S 
is defined as follows: For A in P, f (A) has a 1 in the high-order bit position (left end of string) if and 
only if a is in A. f (A) has a 1 in the low-order bit position (right end of string) if and only if b is in A. Is f 
­one-to-one? Prove or disprove. Is f onto? Prove or disprove.
	 25.	Let S = 5x 0  x [ R and x ≥16, and T = 5x 0  x [ R and 0 < x ≤16. Find a function f: S S T that is a 
bijection.

406	
Relations, Functions, and Matrices 
	 26.	Let S = 5a, b, c, d6 and T = 5x, y, z6.
	
a.	 Give an example of a function from S to T that is neither onto nor one-to-one.
	
b.	Give an example of a function from S to T that is onto but not one-to-one.
	
c.	 Can you find a function from S to T that is one-to-one?
	 27.	Compute the following values.
	
a.	 :3.4;
	
b.	 <−0.2=
	
c.	 :0.5;
	 28.	Compute the following values.
	
a.	 <−5−1. 2=
	
b.	 <−5−<1.2= =
	
c.	 :2 * 3.7;
	
d.	 <1 + 1∙2 + 1∙3 + 1∙4=
	 29.	What can be said about x if :x; = <x=?
	 30.	Prove that <x= + 1 = <x + 1=.
	 31.	Prove that :x; = −<−x=.
	 32.	The ceiling function f (x) = <x=: R S Z. Prove or disprove:
	
a.	 f is one-to-one
	
b.	f is onto
	 33.	Prove or disprove:
	
a.	 <:x;= = x
	
b.	 :2x; = 2:x;
	 34.	Prove or disprove:
	
a.	 :x; + : y; = :x + y;
	
b.	 :2x; = :x; + :x + 1∙2;
	 35.	Prove that if 2k < n < 2k+1 then k = :log n; and k + 1 = <log n=. (Here log n means log2 n.)
	 36.	Prove that if 2k ≤n < 2k+1 then :log n; + 1 = <log (n + 1)=. (Here log n means log2 n.)
	 37.	Compute the value of the following expressions.
	
a.	 31 mod 11
	
b.	16 mod 8
	
c.	 22 mod 6
	
d.	 −7 mod 3
	 38.	a.	 List five values x such that x mod 7 = 0.
	
b.	List five values x such that x mod 5 = 2.
	 39.	Prove or disprove: For any integers x and y, x mod 10 + y mod 10 = (x + y) mod 10.
	 40.	Prove that x ≡y (mod n) if and only if x mod n = y mod n. (Recall the definition of congruence modulo 
n from Section 5.1.)
	 41.	Let S be a set and let A be a subset of S. The characteristic function of A is a function cA: S S 50, 16 with 
cA(x) = 1 exactly when x [ A.
	
a.	 Let S = 51, 2, 3, 4, 56 and A = 51, 3, 56. Give the ordered pairs that belong to cA.
	
b.	Prove that for any set S and any subsets A and B of S, cA d B(x) = cA(x) # cB(x).

Section 5.4   Functions	
407
	
c.	 Prove that cA(x) = 1 −cA′(x).
	
d.	Is it true that for any set S and any subsets A and B of S, cA c B(x) = cA(x) + cB(x)? Prove or give a 
counterexample.
	 42.	Ackermann’s function1, mapping N2 to N, is a recursive function that grows very rapidly. It is given by
A(0, n) = n + 1 for all n [ N
A(m, 0) = A(m −1, 1) for all m [ N, m > 0
A(m, n) = A(m −1, A(m, n −1)) for all m [ N, n [ N, m > 0, n > 0
	
a.	 Compute (show all steps) the value of A(1, 1).
	
b.	Compute (show all steps) the value of A(2, 1).
	
c.	 The value of A(4, 0) = 13 = 222 −3, still a small value. But A(4,1) = 2222
−3. Compute this value.
	
d.	Write a likely expression for the value of A(4, 2).
	 43.	Another rapidly growing function is the Smorynski function, which also maps N2 to N. The definition is
	
S(0, n) = nn for all n [ N
	
S(m, n) = S(m −1, S(m −1, n)) for all m [ N, n [ N, m > 0
	
a.	 How does S(0, n) compare to A(0, n)? (See Exercise 40.)
	
b.	Find (show all steps) an expression for the value of S(1, n).
	
c.	 A googolplex is a very large number, which if written in standard form (such as 1,000,000 … ), even 
in 1-point font, would take more room to write than the diameter of the known universe. Look up the 
definition of the googolplex and write it as S(m, n) for a specific value of m and n.
	 44.	The Dwyer function also maps N2 to N and grows very rapidly, but it has a closed-form definition:
D(m, n) = n! c(2m + 1)!
2mm!
d
n
	
a.	 Compute the values of D(1, 1), D(2, 1), D(3, 1) and D(4, 1).
	
b.	Verify that D(2, 1) = (2*1 + 3)D(1, 1), that D(3, 1) = (2*2 + 3)D(2, 1), and that D(4, 1) 5
(2*3 + 3)D(3, 1).
	
c.	 Verify that D(m, 1) satisfies the recurrence relation
D(m + 1, 1) = (2m + 3) D (m, 1) with D(0, 1) = 1
	
	 (Hint: When you evaluate D(m + 1, 1) and D(m, 1) do not divide the denominator factorial into the nu-
merator factorial. Instead, think of the numerator factorial as a product of even and odd factors.
	
d. 	Find (use a spreadsheet) the smallest value of m for which
D(m, 1) < mm
1This is the most common of several versions of Ackermann’s function, all of which are recursive with extremely rapid growth rates. To watch the 
tedious recursiveness of computations of Ackermann’s function, go to http://www. gfredericks.com/sandbox/arith/ackermann

408	
Relations, Functions, and Matrices 
	 45.	Let S = 51, 2, 3, 46, T = 51, 2, 3, 4, 5, 66, and U = 56, 7, 8, 9, 106. Also, let 	  
f = 5(1, 2), (2, 4), (3, 3), (4, 6)6 be a function from S to T, and let 	
 
g = 5(1, 7), (2, 6), (3, 9), (4, 7), (5, 8), (6, 9)6 be a function from T to U. Write the ordered pairs in the 
function g + f .
	 46.	a.	 Let f : R S Z be defined by f (x) = :x;. Let g: Z S N be defined by g(x) = x2. What is (g + f )(−4.7)?
	
b.	Let f map the set of books into the integers where f assigns to each book the number of words in its title. 
Let g: Z S Z be given by g(x) = 2x. What is (g + f ) (this book)?
	
c.	 Let f map strings of alphabetical characters and blank spaces into strings of alphabetical consonants 
where f takes any string and removes all vowels and all blanks. Let g map strings of alphabetical 
­consonants into integers where g maps a string into the number of characters it contains. What is (g + f ) 
(abraham lincoln)?
	 47.	Let f: N S N be defined by f (x) = x + 1. Let g: N S N be defined by g(x) = 3x. Calculate the value 
of the following expressions.
	
a.	 (g + f )(5)
	
b.	 ( f + g)(5)
	
c.	 (g + f )(x)
	
d.	 ( f + g)(x)
	
e.	 ( f + f )(x)
	
f.	 ( g + g)(x)
	 48.	The following functions map R to R. Give an equation describing the composition functions g + f  and 
f + g in each case.
	
a.	 f (x) = 6x3, g(x) = 2x
	
b.	 f (x) = (x −1)∙2, g(x) = 4x2
	
c.	 f (x) = <x=, g(x) = :x;
	 49.	Let f: S S T and g: T S U be functions.
	
a.	 Prove that if g + f  is one-to-one, so is f.
	
b.	Prove that if g + f  is onto, so is g.
	
c.	 Find an example where g + f  is one-to-one but g is not one-to-one.
	
d.	Find an example where g + f  is onto but f is not onto.
	 50.	a.	 Let f be a function, f: S S T. If there exists a function g: T S S such that g + f = iS, then g is called a 
left inverse of f. Show that f has a left inverse if and only if f is one-to-one.
	
b.	Let f be a function, f: S S T. If there exists a function g: T S S such that f + g = iT, then g is called 
a right inverse of f. Show that f has a right inverse if and only if f is onto.
	
c.	 Let f: N S N be given by f(x) = 3x. Then f is one-to-one. Find two different left inverse functions  
for f.
	
d.	Let f: N+ S N+ be given by f(x) = lx
2m . Then f is onto. Find two different right inverse functions  
for f.
	 51.	For each of the following bijections f: R S R, find f −1.
	
a.	 f (x) = 2x
	
b.	 f (x) = x3
	
c.	 f (x) = (x + 4)∙3
	 52.	Let f and g be bijections, f: S S T and g: T S U. Then f −1 and g−1 exist. Also, g + f  is a bijection from 
S to U. Show that (g + f )−1 = f −1 + g−1.

Section 5.4   Functions	
409
	 53.	Let A = 51, 2, 3, 4, 56. Write each of the following permutations on A in cycle form.
	
a.	 f = a1
2
3
4
5
3
1
5
4
2b
	
b.	 f = 5(1, 4), (2, 5), (3, 2), (4, 3), (5, 1)6
	 54.	Let A 5a, b, c, d6. Write each of the following permutations on A in array form.
	
a.	 f = 5(a, c), (b, b), (c, d ), (d, a)6
	
b.	 f = (c, a, b, d )
	
c.	 f = (d, b, a)
	
d.	 f = (a, b) + (b, d ) + (c, a)
	 55.	Let A be any set and let SA be the set of all permutations of A. Let f, g, h [ SA. Prove that the functions 
h + (g + f ) and (h + g) + f  are equal, thereby showing that we can write h + g + f  without parentheses to 
indicate grouping.
	 56.	Find the composition of the following cycles representing permutations on A = 51, 2, 3, 4, 56. Write  
your answer as a composition of one or more disjoint cycles.
	
a.	 (2, 4, 5, 3) + (1, 3)
	
b.	 (3, 5, 2) + (2, 1, 3) + (4, 1) (By Exercise 55, we can omit parentheses indicating grouping.)
	
c.	 (2, 4) + (1, 2, 5) + (2, 3, 1) + (5, 2)
	 57.	Find the composition of the following cycles representing permutations on A = 51, 2, 3, 4, 5, 6, 7, 86. 
Write your answer as a composition of one or more disjoint cycles.
	
a.	 (1, 3, 4) + (5, 1, 2)
	
b.	 (2, 7, 8) + (1, 2, 4, 6, 8)
	
c.	 (1, 3, 4) + (5, 6) + (2, 3, 5) + (6, 1)
	
d.	 (2, 7, 1, 3) + (2, 8, 7, 5) + (4, 2, 1, 8)
	 58.	Find the composition of the following cycles representing permutations on N. Write your answer as a 
composition of one or more disjoint cycles.
	
a.	 (3, 5, 2) + (6, 2, 4, 1) + (4, 8, 6, 2)
	
b.	 (1, 5, 13, 2, 6) + (3, 6, 4, 13) + (13, 2, 6, 1)
	
c	 (1, 2) + (1, 3) + (1, 4) + (1, 5)
	 59.	Find the composition of the following cycles representing permutations on A = 5a, b, c, d, e6. Write your 
answer as a composition of one or more disjoint cycles.
	
a.	 (a, d, c, e) + (d, c, b) + (e, c, a, d) + (a, c, b, d )
	
b.	 (e, b, a) + (b, e, d ) + (d, a)
	
c.	 (b, e, d ) + (d, a) + (e, a, c) + (a, c, b, e)
	 60.	Find a permutation on an infinite set that cannot be written as a cycle.
	 61.	The function f written in cycle form as f = (4, 2, 8, 3) is a bijection on the set N. Write f −1 in cycle form.
	 62.	The “pushdown store,” or “stack,” is a storage structure that operates much like a set of plates stacked on 
a spring in a cafeteria. All storage locations are initially empty. An item of data is added to the top of the 
stack by a “push” instruction, which pushes any previously stored items farther down in the stack. Only 
the topmost item on the stack is accessible at any moment, and it is fetched and removed from the stack 
by a “pop” instruction.
Let’s consider strings of integers that are an even number of characters in length; half the characters 
are positive integers, and the other half are zeros. We process these strings through a pushdown store as 

410	
Relations, Functions, and Matrices 
follows: As we read from left to right, the push instruction is applied to any nonzero integer, and a zero 
causes the pop instruction to be applied to the stack, thus printing the popped integer. Thus, processing 
the string 12030040 results in an output of 2314, and processing 12304000 results in an output of 3421.  
(A string such as 10020340 cannot be handled by this procedure because we cannot pop two integers from 
a stack containing only one integer.) Both 2314 and 3421 can be thought of as permutations,
	
a1
2
3
4
2
3
1
4b	
and	
a1
2
3
4
3
4
2
1b
	
	 respectively, on the set A = 51, 2, 3, 46. 
	
a.	 What permutation of A = 51, 2, 3, 46 is generated by applying this procedure to the string 12003400?
	
b.	Name a permutation of A = 51, 2, 3, 46 that cannot be generated from any string where the digits 1, 2, 
3, and 4 appear in order, no matter where the zeros are placed.
	 63.	Let S = 52, 4, 6, 86 and T = 51, 5, 76.
	
a.	 Find the number of functions from S to T.
	
b.	Find the number of onto functions from S to T.
	 64.	Let S = 5P, Q, R6 and T = 5k, l, m, n6.
	
a.	 Find the number of functions from S to T.
	
b.	Find the number of one-to-one functions from S to T.
	 65.	a.	 For 0S 0 = 2, 3, and 4, respectively, use the theorem on the number of functions to show that the number 
of one-to-one functions from S to S equals the number of onto functions from S to S.
	
b.	Argue that for 0S 0 = n, f: S S S is one-to-one if and only if f is onto.
	
c.	 Find an infinite set S and a function f: S S S such that f is one-to-one but not onto.
	
d.	Find an infinite set S and a function f: S S S such that f is onto but not one-to-one.
	 66.	Let A = 5a, b, c, d6. How many functions are in SA? How many of these functions are derangements? 
Write all the derangements in array form.
	 67.	Let 0S 0 = n. In parts a-e, find the number of
	
a.	 functions from S to S.
	
b.	one-to-one functions from S to S.
	
c.	 functions from S onto S (see Exercise 65).
	
d.	permutations from S onto S.
	
e.	 derangements from S onto S.
	
f.	 Order the values obtained in parts (a) through (e) from smallest to largest and explain why this ordering 
is reasonable.
	 68.	a.	 A system development project calls for five different tasks to be assigned to Maria, Jon, and Suzanne. 
In how many ways can the assignment be done if each of the three workers must get at least one task?
	
b.	In how many ways can the projects be assigned if Maria must develop the test plan, which is one of the 
five tasks, but may do other tasks as well? (Hint: Consider the two cases where Maria does and does 
not do any of the other tasks.)
	 69.	In a programming class of seven students, the instructor wants each student to modify the program from a 
previous assignment, but no student should work on his or her own program. In how many ways can the 
instructor assign programs to the students?

Section 5.4   Functions	
411
	 70.	a.	 Find a calculus book and look up the Maclaurin series representation for the function ex.
	
b.	Use the answer to part (a) to find a series representation for e−1.
	
c.	 Use a calculator to compute an approximate value for e−1 to about 5 decimal places.
	
d.	How can the answer to parts (b) and (c) help you approximate the number of derangements of n objects 
when n is large, say, n ≥10? (Hint: Look at Equation (4) in this section.)
	
e.	 Apply this approach to Exercise 69 and compare the results.
	
f.	 Approximately how many derangements are there of 10 objects?
	 71.	Let f be a function, f: S S T.
	
a.	 Define a binary relation r on S by x r y 4 f (x) = f (y). Prove that r is an equivalence relation.
	
b.	What can be said about the equivalence classes if f is a one-to-one function?
	
c.	 For S = T = Z and f (x) = 3x2, what is 344 under the equivalence relation of part (a)?
	 72.	Prove that S(m, n), the number of ways to partition a set of m elements into n blocks, is equal to 1∙n! 
times the number of onto functions from a set with m elements to a set with n elements. (Hint: Consider  
Exercise 71.)
	 73.	By the definition of a function f from S to T, f is a subset of S × T where the image of every s [ S under 
f is uniquely determined as the second component of the ordered pair (s, t) in f. Now consider any binary 
relation r from S to T. The relation r is a subset of S × T in which some elements of S may not appear 
at all as first components of an ordered pair and some may appear more than once. We can view r as a 
nondeterministic function from a subset of S to T. An s [ S not appearing as the first component of an 
ordered pair represents an element outside the domain of r. For an s [ S appearing once or more as a first 
component, r can select for the image of s any one of the corresponding second components.
Let S = 51, 2, 36, T = 5a, b, c6, and U = 5m, n, o, p6. Let r be a binary relation on S × T and s be 
a binary relation on T × U defined by
r = 5(1, a), (1, b), (2, b), (2, c), (3, c)6
s = 5(a, m), (a, o), (a, p), (b, n), (b, p), (c, o)6
Thinking of r and s as nondeterministic functions from S to T and T to U, respectively, we can form 
the composition s + r, a nondeterministic function from S to U.
	
a.	 What is the set of possible images of 1 under s + r?
	
b.	What is the set of possible images of 2 under s + r? of 3?
	 74.	Let f be a function, f: S S T.
	
a.	 Show that for all subsets A and B of S, f (A d B) # f (A) d f(B). 
	
b.	Show that f (A d B) = f (A) d f(B) for all subsets A and B of S if and only if f is one-to-one.
	 75.	Let C be a collection of sets, and define a binary relation r on C as follows: For S, T [ C, S r T 4 S is 
equivalent to T. Show that r is an equivalence relation on C.
	 76.	Group the following sets into equivalence classes according to the equivalence relation of Exercise 75.
A = 52, 46
B = N
 C = 5x 0  x [ N and (Ey)( y [ N and x = 2*y)6
D = 5a, b, c, d6
E = `(51, 26)
F = Q+

412	
Relations, Functions, and Matrices 
Exercises 77 and 78 involve programming with a functional language. Functional programming languages, as 
opposed to conventional (procedural) programming languages such as C++, Java, or Python, treat tasks in 
terms of mathematical functions. A mathematical function such as f (x) = 2x transforms the argument 5 into 
the result 10. Think of a program as a big function to transform input into output. A functional programming 
language contains primitive functions as part of the language, and the programmer can define new functions as 
well. Functional programming languages support function composition, allowing for complex combinations of 
functions. Using the functional programming language Scheme, we can define the doubling function by
	
	 (define (double x)
	
	    (* 2 x)
The user can then run the program and type
	
	 (double 5)
which produces an immediate output of 10.
	 77.	a.	 Write a Scheme function to square a number.
	
b.	What is the output from the following user input?
	
	 (double (square 3))
	 78.	Scheme also supports recursion, plus the usual control structures of procedural languages, such as condi-
tional and iterative statements.
	
a.	 Given the Scheme function
	
	 (define (mystery n)
	
	    (cond ((= n 1) 1)
	
	       (else (*n (mystery (- n 1))))))
	
what is the output of
	
	 (mystery 4)
	
b.	The “mystery” function is better known as _______. 
	
S e c t i o n  5 . 5 	 Order of Magnitude
Function Growth
Order of magnitude is a way of comparing the “rate of growth” of different 
­functions. We know, for instance, that if we compute f (x) = x and g(x) = x2 for 
­increasing values of x, the g values will be larger than the f values by an ever 
increasing amount. This difference in the rate of increase cannot be overcome 
by simply multiplying the f values by some large constant; no matter how large a 
constant we choose, the g values will eventually race ahead again. Our experience 
indicates that the f and g functions seem to behave in fundamentally different 
ways with respect to their rates of growth. In order to characterize this difference 
formally, we define a binary relation on functions.
Let S be the set of all functions with domain and codomain the nonnegative 
real numbers. We can define a binary relation on S by
f r g 4 there exist positive constants n0, c1, and c2 such that, for all x ≥n0, 
c1g(x) ≤f(x) ≤c2g(x)

Section 5.5   Order of Magnitude	
413
Given that r is an equivalence relation, it partitions S into equivalence classes. 
If f is in the same class as g, then f is said to have the same order of magnitude as g, 
denoted by f = Θ(g) and pronounced “f is order g” or sometimes “f is big theta of 
g.” Because of symmetry, this also means that g is the same order of magnitude as 
f, or g = Θ( f ). (The notation f = Θ(g) is a bit of a misuse of the equality symbol 
because Θ(g) is not some function identical to f. It is just a shorthand way of say-
ing that f [ 3g4 under the equivalence relation r defined above.)
	
Example 44	
Let f and g be functions in S where f(x) = 3x2 and g(x) = 200x2 + 140x + 7
Let n0 = 2, c1 =
1
100, and c2 = 1. Then for x ≥2,
1
100 (200x2 + 140x + 7) ≤3x2 ≤(1)(200x2 + 140x + 7)
or
	
2x2 + 1.4x + 0.07 ≤3x2 ≤200x2 + 140x + 7	
(1)
Therefore f r g. 	
Practice 40	
a.	 Verify the inequality in Equation (1) for the following values of x: 2, 3, 4, 5. (Use a calculator.)
b.	In Example 44, can n0 have the value 1 if c1 and c2 remain the same?
c.	 Find a different set of three values n0, c1, and c2 that will also work to show that f r g in  
Example 44.	
■
The relation r is an equivalence relation on S. For example, to prove that  
f r f , we can pick n0 = c1 = c2 = 1 and have
(1) f (x) ≤f (x) ≤(1) f (x)
Practice 41	
a.	 Prove that r is symmetric.
b.	Prove that r is transitive.	
■
	
Definition	
Order of Magnitude
Let f and g be functions mapping nonnegative reals into nonnegative reals. Then 
f is the same order of magnitude as g, written f = Θ(g), if there exist positive 
constants n0, c1, and c2 such that for x ≥n0, c1g (x) ≤f (x) ≤c2g (x).

414	
Relations, Functions, and Matrices 
We will usually try to find the simplest representative of a given equivalence 
class. Thus for the functions f and g of Example 44, we would say f = Θ(x2) and 
g = Θ(x2). A polynomial is always the order of magnitude of its highest-degree 
term; lower-order terms and all coefficients can be ignored. This is not surprising, 
since for large values of x, the highest-degree term will dominate the result.
Practice 42	 Prove (by finding appropriate constants that satisfy the definition of order of magni-
tude) that f = Θ(x2) and g = Θ(x2) for the functions f and g of Example 44.
■
To understand more intuitively what these equivalence classes mean, we’ll 
draw some graphs. Let h(x) [ S, where h(x) = x2. Figure 5.25 shows the graph 
of h(x). Now suppose we multiply the h values by the two constants c1 = 1∙2 and 
c2 = 2. The functions c1h(x) and c2h(x) are shown as dotted lines in Figure 5.26. 
These dotted lines form a kind of envelope around the h(x) values, roughly trac-
ing the shape of h(x). Changing the value of the constants changes the width of 
the envelope but not the basic shape. If h1(x) is a function with h1 = Θ(h), then 
there is some positive constant n0 and some envelope around h such that for all 
domain values to the right of n0, the h1 values must fall within this envelope, as 
shown in Figure 5.27. Therefore the h1 values can never stray too far from the h 
values. The functions h1 and h are roughly the same size—they are the same order 
of magnitude.
x
 h(x) = x2
x
h(x)
c2h(x)
c1h(x)
x
h(x)
c2h(x)
c1h(x)
h1(x)
n0
Figure 5.25
Figure 5.26
Figure 5.27
	
Example 45	
Let f (x) = x and h(x) = x2. Figure 5.28 illustrates that for the constants c1 = 1∙2 
and c2 = 2, f soon falls below the envelope. Reducing the c1 constant (lowering 
the bottom edge of the envelope) only postpones the problem. Formally, we can 
do a proof by contradiction to show that f is not Θ(x2). Suppose f = Θ(x2). Then 
there exist constants n0 and c1 with c1x2 ≤f(x) for x ≥n0. But this would imply 
that c1x2 ≤x or c1x ≤1 or x ≤1∙c1 for all x ≥n0. Because c1 is fixed, we can 
always choose x large enough so that x > 1∙c1, which is a contradiction. Therefore 
f(x) = x is not Θ(x2).

Section 5.5   Order of Magnitude	
415
x
h(x) = x2
f(x) = x
c2h(x)
c1h(x)
Figure 5.28
If we imagine functions representing various forms of transportation, then 
functions that are the same order of magnitude (belong to the same equivalence 
class) represent the same mode of transportation. One class represents travel on 
foot, another class represents travel by automobile, a third represents travel by air. 
Speeds within a given mode are about the same; ignoring coefficients and low-
order terms amounts to ignoring the difference between walking and running or 
between a Jeep and a Jaguar or between a Cessna and a Boeing 787. Walking (at 
any speed) is distinctly different from driving, which is distinctly different from 
flying.
We can imagine a hierarchy of orders of magnitude. For example, the class 
Θ(x) is a lower order of magnitude than the class Θ(x)2 because functions that are 
Θ(x) eventually fall below functions that are Θ(x2). Also, the class Θ(log x) is a 
lower order of magnitude than Θ(x) (see Exercise 15 at the end of this section). In 
our transportation analogy, walking is slower than driving is slower than flying.
A sort of arithmetic can be developed using order of ­magnitude. For example, 
if f1(x) = x and f2(x) = x2, then the function ( f1 + f2)(x) = f1(x) + f2(x) 5 
x + x2 = Θ(x2). In general, if f1 = Θ(g1) and f2 = Θ(g2), then f1 + f2 5
Θ(max (g1, g2)) (see Exercise 8). When ­expressed in abbreviated form,  
this leads to somewhat bizarre equations such as Θ(x) + Θ(x2) = Θ(x2) or 
Θ(x2) + Θ(x2) = Θ(x2).
More on Analysis of Algorithms
Order of magnitude is important in analysis of algorithms, which we discussed in 
Section 3.3. In analyzing an algorithm, we identify the important tasks the algo-
rithm performs. Usually the number of times such tasks must be done in executing 
the algorithm will depend on the size of the input. For example, searching a list of 
n elements or sorting a list of n elements will require more work as n increases. 
Typically, we can express input size as a nonnegative integer, so the functions that 
express the amount of work will be functions with domain N. We found in ­Section 
3.3 that a sequential search of n elements requires n comparisons in the worst case, 
while a binary search requires 1 + log n comparisons in the worst case (assuming 
n is a power of 2). Rather than compute the exact functions for the amount of work 

416	
Relations, Functions, and Matrices 
done, it is easier and often just as useful to settle for order-of-magnitude informa-
tion. Sequential search is Θ(n) and binary search is Θ(log n) in the worst case. 
Thus binary search is an order-of-magnitude improvement over sequential search. 
The order of magnitude of an algorithm is also known as its computational com-
plexity because it reflects the amount of work inherent in the algorithm. Table 5.3 
gives a summary of the worst-case order of magnitude for algorithms discussed in 
the text and exercises of Section 3.3.
Table 5.3
Algorithm
Operation
Worst-Case Order of Magnitude
SequentialSearch on list size n
comparisons
Θ(n) 
BinarySearch on sorted list size n
comparisons
Θ(log n)
Pattern matching of pattern of length m 
in text of length n
comparisons
Θ(mn)
Evaluation of a polynomial of degree n 
multiplications and additions
Θ(n)
BubbleSort of list size n 
comparisons
Θ(n2)
SelectionSort of list size n
comparisons
Θ(n2)
MergeSort of list size n
comparisons
Θ(n log n)
QuickSort of list size n
comparisons
Θ(n2)
To appreciate the effect of order of magnitude in evaluating algorithms, 
­suppose we have two algorithms A and A′ to do the same job but they differ 
in ­order of magnitude—say, A is Θ(n) and A′ is Θ(n2). Even if each step in a 
­computation takes only 0.0001 second, this difference will affect total ­computation 
time as n grows larger. The first two rows of Table 5.4 give total computation 
times for A and A′ for various values of input length. Now suppose a third al-
gorithm A″ exists whose order of magnitude is not even given by a polynomial 
function but by an exponential function, say 2n. The total computation times for  
A″ are shown in the third row of Table 5.4.
Table 5.4
Total Computation Time
Size of Input n
Algorithm 
Order 
10
50 
100
A
n 
0.001 second 
0.005 second 
0.01 second
A′
n2
0.01 second 
0.25 second 
1 second
A″
2n
0.1024 second 
3570 years 
4 × 1016 centuries

Section 5.5   Order of Magnitude	
417
Note that the exponential case grows at a fantastic rate! Even if we assume 
that each computation step takes much less time than 0.0001 second, the relative 
growth rates between polynomial and exponential functions still follow this same 
pattern. Because of this immense growth rate, algorithms not of polynomial order 
are generally not useful for large values of n. In fact, problems for which no poly-
nomial time algorithms exist are called intractable.
Sometimes algorithms that are not polynomial in the worst case may still be 
efficient for “average”—and useful—input cases.2 Nonetheless, in attempting to im-
prove efficiency, we should ask whether a different algorithm of a lower order of 
magnitude exists before we worry about the details of fine-tuning a given algorithm.
If f (n) represents the work done by an algorithm on an input of size n, it may 
be difficult to find a simple function g such that f = Θ(g). Remember that if we 
can find such a g, then f and g are functions that eventually (for large enough n) 
have roughly the same shape. But we may still be able to find a function g that 
serves as an upper bound for f. In other words, while f may not have the same 
shape as g, f will never grow significantly faster than g. Formally, this is expressed 
by saying that f = O(g) (“f is big O of g”).
2This is the case with the well-known simplex method for solving linear programming problems, which are a 
generalization of systems of linear equations to systems of inequalities—see Section 5.7.
	
Definition	
Big Oh
Let f and g be functions mapping nonnegative reals into nonnegative reals. Then 
f is big oh of g, written f = O(g), if there exist positive constants n0 and c such 
that for x ≥n0, f(x) ≤cg(x).
If f = O(g), then g is a ceiling for f and gives us a worst-case picture of the 
growth of f. In Section 3.3, we learned that if E(n) is the number of divisions 
required by the Euclidean algorithm to find gcd(a, b), where b < a = n, then 
E(n) = O(log n)
The big oh notation f = O(g) says that f grows at the same rate or at a slower 
rate than g. But if we know that f definitely grows at a slower rate than g, then we 
can say something stronger, namely that f is little oh of g, written f = o(g). The 
relationship between big oh and little oh is this: If f = O(g), then either f = Θ(g) 
or f = o(g), much like a ≤b says that either a = b or a < b.
The Master Theorem
In Section 3.2, we learned that a solution for divide-and-conquer recurrence rela-
tions of the form
S(n) = cSan
2b + g(n) for n ≥2, n = 2m
is given by
S(n) = clog nS(1) + ∙
log n
i=1
c(log n)−i g(2i)

418	
Relations, Functions, and Matrices 
3A more complicated master theorem gives similar results for the case of Equation (2).	
This type of recurrence relation arises in the analysis of an algorithm that splits 
the input in half and operates recursively on one or more of the halves. A more 
general divide-and-conquer recurrence relation divides the input into subproblems 
that are each of size n∙b and then operates recursively on a of the subproblems. 
Each subproblem requires S(n∙b) work with g(n) representing the work required 
to divide into subproblems or recombine the results of solving the subproblems. 
Such a recurrence relation would have the form
	
S(n) = aS an
bb + g(n) for n ≥2, n = bm	
(2)
We assume that n is an integral power of b so that dividing n by b over and over 
always results in an integer.
A result called the master theorem gives us order-of-magnitude results via a 
cookbook formula for the case when g(n) = nc. Thus, assume the recurrence rela-
tions of interest look like this:3
	
S(n) = aS an
bb +  nc for n ≥2, n = bm	
(3)
	
Theorem	
Master Theorem
Consider the recurrence relation
	
S(1) ≥0
	
S(n) = aS an
bb +  nc for n ≥2
where n = bm, a, and b are integers, a ≥1, b > 1, and c is a nonnegative real 
number. Then
	
1.	 if a < bc	
S(n) = Θ(nc)
	
2.	 if a = bc	
S(n) = Θ(nc log n)
	
3.	 if a > bc	
S(n) = Θ(nlogb a)
	
Example 46	
A recurrence relation of the form
S(n) = 4S an
5b + n3 for n ≥2, n = 5m
matches the form of the recurrence relation shown in the master theorem where 
a = 4, b = 5, and c = 3. Because 4 < 53, Case 1 applies and the master theorem 
says that S(n) = Θ(n3).	

Section 5.5   Order of Magnitude	
419
Note that the master theorem does not give exact solutions; it gives order-of-
magnitude results. Also, the value of S(1) (a constant) plays no part in determin-
ing the result.
	
	
Example 47	
The worst-case recurrence relation for comparisons done by the BinarySearch al-
gorithm on a sorted list of size n (Example 30 in Chapter 3) is
	
C(1) = 1
	
C(n) = Can
2b + 1 for n ≥2, n = 2m
We found the exact solution to be C(n) = 1 + log n, certainly Θ(log n). We can 
find this directly from the master theorem with a = 1, b = 2, c = 0. Because 
a = bc, C(n) = Θ(n0 log n) = Θ(log n).	
Proof of the Master Theorem
To prove the master theorem, we’ll go back to an expansion technique. We apply 
the “recipe” of Equation (3) over and over. The recipe is that S at some value is a 
times S at that value divided by b, plus that value to the c power. Therefore
S(n) = aSan
bb + nc
= acaSa n
b2b + an
bb
c
d + nc = a2Sa n
b2b + aan
bb
c
+ nc
= a2 caSa n
b3b + a n
b2b
c
d + aan
bb
c
+ nc = a3Sa n
b3b + a2a n
b2b
c
+ aan
bb
c
+ nc
(
= akSa n
bkb + ak−1a n
bk−1b
c
+ c+ aan
bb
c
+ nc
 
This expansion must stop when n∙bk = 1, or n = bk, which means k = m. At that 
point, using summation notation,
S(n) = amS(1) + ∙
m−1
i=0
aia n
bib
c
= amS(1) + ∙
m−1
i=0
nca ai
bcib
	
= amS(1) + nc ∙
m−1
i=0
a a
bcb
i
	
(4)
Because n = bm, it follows that m = logb n, so Equation (4) can be written as
S(n) = alogb nS(1) + nc ∙
m−1
i=0
a a
bcb
i

420	
Relations, Functions, and Matrices 
and this equation in turn, using property 11 of the logarithm function (see 
­Appendix C), can be written as
	
S(n) = nlogb aS(1) + nc ∙
m−1
i=0
a a
bcb
i
	
(5)
We’ll see the expression logb a frequently, so we’ll temporarily give it a ­simpler 
name: Let w = logb a. Then, expanding the summation, Equation (5) can be 
­written as
S(n) = nwS(1) + nc c1 + a a
bcb + a a
bcb
2
+ c+ a a
bcb
m−1
d
We can see that the expression in brackets represents the sum of the first m terms 
of a geometric sequence with first term equal to 1 and common ratio r equal to 
(a∙bc). If r ∙1, this sum (see Exercise 27 in Section 2. 2) has the value
1 −a a
bcb
m
1 −a a
bcb
and
	
S(n) = nwS(1) + nc ≥
1 −a a
bcb
m
1 −a a
bcb
¥ 	
(6)
The condition r ∙1 means (a∙bc) ∙1 or a ∙bc. This means that Equation (6) 
holds for both Case 1 and Case 3 of the master theorem, so to prove those cases 
we’ll do some tiresome algebra on Equation (6).
First, note that
nca a
bcb
m
= nca a
bcb
logb n
= ncalogb n
bc logb n = ncnlogb a
blogb nc = ncnlogb a
nc
= nlogb a = nw 
so Equation (6) becomes
S(n) = nwS(1) +
nc −nca a
bcb
m
bc −a
bc
= nwS(1) + bc(nc −nw)
bc −a
or
	
S(n) = nwS(1) +
bc
bc −a
 nc +
bc
a −bc nw	
(7)

Section 5.5   Order of Magnitude	
421
Case 1: a < bc. From a < bc we get (taking logb of both sides)
logb a < c or w < c
In the right side of Equation (7), nc is the highest-power term and has a positive 
coefficient (because bc −a > 0). Therefore S(n) = Θ(nc).
Case 3: a > bc. From a > bc we get (taking logb of both sides)
logb a > c or w > c
In the right side of Equation (7), nw is the highest-power term and has a positive 
coefficient (because a −bc > 0). Therefore S(n) = Θ(nw) = Θ(nlogb a).
Case 2: a = bc. This is an easy case to prove and is left for you to do (see  
Exercise 28).
S e c t i o n  5 . 5 	
Review
Techniques
•	 Determine whether two functions are the same 
­order of magnitude.
•	 Use the master theorem to find an order-of-­
magnitude expression for the solution to certain 
divide-and-conquer recurrence relations.
Main Ideas
•	 Functions can be grouped into equivalence classes 
according to their order of magnitude, which is a 
measure of their growth rate.
•	 Big theta, big oh and little oh (Θ, O, o) are 
­notations for relating the growth rates of two  
functions.
Exercises 5.5
	 1.	 Prove, by finding constants that satisfy the definition of order of magnitude, that f = Θ(g) if f (x) = x and 
g(x) = 17x + 1.
	 2.	 Prove, by finding constants that satisfy the definition of order of magnitude, that f = Θ(g) if 
f (x) = 3x3 − 7x and g(x) = x3∙2.
	 3.	 Prove, by finding constants that satisfy the definition of order of magnitude, that f = Θ(g) if 
f (x) = 29x2 −4x −15 and g(x) = 15x2 + x.
	 4.	 Prove, by finding constants that satisfy the definition of order of magnitude, that f = Θ(g) if 
f (x) = !x + 100 and g(x) = "x.
	 5.	 Prove, by finding constants that satisfy the definition of order of magnitude, that f = Θ(g) if 
f (x) = x3 + log x and g(x) = x3.
	 6.	 Prove, by finding constants that satisfy the definition of order of magnitude, that f = Θ(g) if  
f (x) = log(3x2) and g(x) = log x.
	 7.	 In this section, we noted that h1 = Θ(h) implies that from some point on, h1 is within an “envelope” of h. 
Can this envelope ever be entirely above or entirely below h? Explain. 
	 8.	 Prove that if f1, is a function that is Θ(g1) and f2 is a function that is Θ(g2), then the function f1 + f2, 
defined by ( f1 +  f2)(x) = f1(x) +  f2(x), is Θ(max(g1, g2)), where (max(g1, g2))(x) = max(g1(x), g2(x)).
	 9.	 Find the smallest integer n for which x log x is O(xn).
	 10.	Find the smallest integer n for which (x4 + 4x)∙(x + 2) is O(xn).
W

422	
Relations, Functions, and Matrices 
Exercises 11–18 require familiarity with ideas from calculus. As an alternative to the definition of order of 
magnitude, a limit test can be used to prove that f = Θ(g):
	
f = Θ(g) if lim
xS∞
f (x)
g (x) = p	
where p is a positive real number
As an aid in finding the limit of a quotient, if limxS∞ f (x) = ∞ and limxS∞ g(x) = ∞ and f and g are  
differentiable functions, then L’Hôpital’s rule says that
lim
xS∞
f (x)
g(x) = lim
xS∞
f ′(x)
g′(x)
Thus 2x2 + 7 = Θ(x2) because
lim
xS∞
2x2 + 7
x2
= lim
xS∞
4x
2x = 2
	 11.	Use the limit test to do Exercise 1 again.
	 12.	Use the limit test to do Exercise 2 again.
As another limit test, if
lim
xS∞
f(x)
g(x) = 0
	
	 then f = o(g).
	 13.	Use the second limit test to prove that x = o(x2).
	 14.	Use the second limit test to prove that "x = o(x).
	 15.	Use the second limit test to prove that log x = o(x).
	 16.	Use the second limit test to prove that (ln x)2 = o(x0. 5) where ln x is the natural log of x, loge x.
	 17.	Use both limit tests to group the following functions into classes by order of magnitude and to order those 
classes. Here ln x is the natural log of x, loge x.
17 x log x, 200 log x, 2x −x2, "
4 x, 10x2 −3x + 5, 420x, 41 ln x2
	 18.	Use both limit tests to group the following functions into classes by order of magnitude and to order those 
classes. Here ln x is the natural log of x, loge x.
x, "x, log x, x3, x log x, 2x3 + x, ex, (log x)2, ln x, x3 + log x
	 19.	You ask three different people to give you a worst-case order-of-magnitude expression for the work done 
by a particular algorithm on an input of size n. You receive three answers:
i. O(n3)
ii. o(n3)
iii. Θ(n2)
	
	 Which is the most useful and why?

Section 5.6   The Mighty Mod Function	
423
	 20.	An algorithm to determine whether a propositional wff with n statement letters is a tautology works by 
assigning, one at a time, all possible sets of truth values to the statement letters. The unit of work for this 
algorithm is the examination of one set of truth values. Explain why this algorithm is Θ(2n) in the worst 
case.
For Exercises 21–26, use the master theorem to determine an order-of-magnitude expression for the work done.
	 21.	S(n) = 2S an
4b + n2
	 22.	S(n) = 4S an
3b + n
	 23.	S(n) = 4S an
4b + n
	 24.	S(n) = 4S an
2b + n2
	 25.	S(n) = 3S an
3b + "n
	 26.	S(n) = 2S an
2b + n3
	 27.	The worst-case recurrence relation for comparisons done by the MergeSort sorting algorithm is
C(1) = 0
C(n) = 2Can
2b + (n −1) for n ≥2, n = 2m
	
a.	 Use the master theorem to find an order-of-magnitude expression for the solution to the related recur-
rence relation.
C′(n) = 2C′an
2b +  n for n ≥2, n = 2m
	
b.	Compare the result of part (a) with the exact solution to C(n) (Exercise 22 of Section 3.3).
	 28.	Prove the master theorem for the case where a = bc. (Hint: Start with Equation (5). Also remember that a 
change of base of logarithms only involves multiplication by a constant.)
	
S e c t i o n  5 . 6 	 The Mighty Mod Function
In Section 5.4 we defined the modulo n function as follows:
If x = qn + r, 0 ≤r < n, then x mod n = r.
In other words, x mod n is the nonnegative remainder (also called the residue of x 
modulo n) when x is divided by the positive integer n. This seemingly innocuous 
function turns up in a surprising number of applications, some of which will be 
explored in this section.

424	
Relations, Functions, and Matrices 
	
Example 48	
Military time uses a 24-hour clock, where the hours run from 0 through 23. One 
half hour before midnight in military time is 23:30. Standard time uses am and pm 
for the first half of the day and the second half of the day, respectively, with the 
hours in each half running from 0 through 11. One half hour before midnight in 
standard time is 11:30 pm. Conversion from military time to standard time uses the 
modulo 12 function:
8:00 military time:	
Compute 8 mod 12 = 8 gives 8:00 am standard time
16:00 military time:	
Compute 16 mod 12 = 4 gives 4:00 pm standard time
The am or pm designation is determined by whether the quotient in the division is  
0 (am) or 1 (pm). Counting modulo 12 begins at 0 and wraps around to 0 again 
when 12 is reached:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, …
This counting scheme is sometimes taught to young children as “clock arithmetic.”	
Section 5.1 defined an equivalence relation called congruence modulo n:
x ≡y (mod n) if x −y is an integral multiple of n.
Given the similar terminology, one would expect that congruence modulo n and 
the modulo n function would surely be related.
Practice 43	
a.	 Prove that x ≡y (mod n) if and only if (x −y) mod n = 0.
b.	Prove that x ≡y (mod n) if and only if x mod n = y mod n.	
■
Exercises at the end of this section show how some arithmetic operations  
using mod n can be broken down for simpler calculation. One such result  
(­Exercise 7) is particularly useful:
	
(x # y) mod n = (x mod n # y mod n) mod n	
(1) 
By Equation (1),
220 mod 6 = (22 mod 6 # 10 mod 6) mod 6 = (4 # 4) mod  6 = 16 mod 6 = 4
In addition, spreadsheet software usually contains a mod function that speeds up 
computations.
Hashing
A hash function is a function h: S S T where the domain S is a set of text strings 
or integer values, and the codomain T is the set of integers 50, 1, …, t −16 

Section 5.6   The Mighty Mod Function	
425
where t is some relatively small positive integer. If the domain S consists of text 
strings, we can imagine them encoded in some way into integer values, perhaps 
by an algorithm as simple as converting each individual letter of a text string into 
its position in the alphabet (a = 1, b = 2, and so on) and adding up the resulting 
list of integers to get one integer value. Therefore we can assume that S consists of 
integer values to begin with.
The function h therefore maps a potentially large set of integer values S into 
a relatively small window of integer values T. Consequently h isn’t likely to be a 
one-to-one function because there may be many values x1, x2, x3, … from S such 
that h(x1) = h(x2) = h(x3), in which case we say that x1, x2, and x3 all “hashed” to 
the same value. The term “hash function” came about because the domain value 
x is often chopped up into pieces in the process of computing h(x). Whatever the 
function h(x) does to x, the last step is almost always to apply the mod t function 
so the final value of h(x) falls in the codomain 50, 1, … , t −16.
	
Example 49	
S is a set of positive integers, T is the set of integers 50, … , t −16 and the hash 
function h(x) is given by
h(x) = x mod t
If t = 10, for example, then values are computed modulo 10:
 h(7) = 7 mod 10 = 7
 h(23) = 23 mod 10 = 3
 h(59) = 59 mod 10 = 9
 h(158) = 158 mod 10 = 8
 h(48) = 48 mod 10 = 8
Here 158 and 48 hash to the same value.	
A hash function is often used as part of a search algorithm. We have already 
discussed two search algorithms. In sequential search, n elements are stored in an 
unordered (random) list and a given target value is compared one-by-one with the 
list elements. In binary search, n elements are stored in a sorted list. The given 
target value is compared with the midpoint of the list, the midpoint of half the list, 
and so on. In a search using a hash function, n elements are stored in an array (a 
one-dimensional table) called a hash table, where the array is indexed from 0 
through t −1; the table is of size t. The element x is passed as the argument to 
the hash function and the resulting h(x) value gives the array index at which the 
element is then stored. Later, when a search is carried out, the target value is run 
through the same hash function, giving an index location in the hash table, which 
is where to look for the matching stored element.
However, because the hash function is not one-to-one, things are not quite 
that simple. As the search list is loaded into the hash table, different values may 
hash to the same array index, producing a collision. There are several collision 
resolution algorithms available. One is called linear probing—just keep going in 

426	
Relations, Functions, and Matrices 
	
Example 50	
Using the hash function of Example 49, the elements 7, 23, 59, 158 and 48 are 
loaded in order into the hash table. The size of the hash table is the same as the 
modulo value used (10). With linear probing, the resulting hash table looks like 
Figure 5.29(a); 48 hashes to index 8 (occupied), tries index 9 (occupied), and fi-
nally finds a slot at index 0. With chaining, assuming elements are added to the 
front of the list, the hash table looks like Figure 5.29(b).
0
1
2
3
4
5
6
7
8
9
48
23
7
158
59
(a)
(b)
59
48
158
7
23
0
1
2
3
4
5
6
7
8
9
Figure 5.29
After the hash table is built, we can perform searches for target elements. To 
search for a target element of 48, the linear collision resolution scheme would 
repeat the steps used to store the 48—hash the target 48 to 8, then check index 9 
and then index 0, where the element is found. The target would be compared with 
three different values (158, 59, 48) to reach a successful conclusion. To search for 
a target of 68, the target would hash to index 8 (no match); then the elements at 
index 9 and index 0 would be checked, also with no success. Advancing to index 1, 
the hash table contains an empty slot, so the search concludes (after four compari-
sons, counting comparing the target against an empty cell) that 68 is not stored in 
the hash table. The chaining scheme would hash a target value of 48 to index 8 
and then search (sequentially) the resulting linked list, finding the target value at 
the beginning of the list after one comparison. To search for a target value of 68, 
the search algorithm would search the same linked list but would get to the end, 
concluding that 68 is not stored in the hash table.	
the array (looping back to the top of the array when you get to the bottom) and 
store element x in the next available empty slot. Another method, called chaining, 
builds a linked list for each array index; the list is initially empty but eventually 
contains all elements that hashed to that index value.

Section 5.6   The Mighty Mod Function	
427
Two goals should be kept in mind in designing a hash function:
	
1.	 Given an argument value x, h(x) can be computed quickly.
	
2.	 The number of collisions will be reduced because h(x) does a good job of 
distributing values throughout the hash table.
Use of a modulo function as the hash function accomplishes the first goal. The 
second goal is harder to achieve because data can always be found that produce a 
large number of collisions, but distribution seems to work better on the average if 
the table size (the modulo value) is a prime number.
The average number of comparisons required to search for an element us-
ing hashing depends not on the total number n of elements in the hash table, but 
rather on the ratio of n to the total table size t. If this ratio is low, then (using linear 
probing) there are lots of empty slots, so you won’t have to look very far to find 
a place to insert a new element into the table or, correspondingly, to search for a 
target element that is in the hash table. Similarly, if this ratio is low and chaining 
is used, the average length of any linked list you may have to (sequentially) search 
for a target element should be short. This ratio n/t is called the load factor of the 
hash table. In sequential search or binary search, more elements in the set to be 
searched increases the work (number of comparisons) required. But using hash-
ing, more elements can be searched just as efficiently as fewer provided the hash 
table size grows accordingly so that the load factor stays low.
Computer Security
Computer security (or the more general term information assurance) is a topic 
of critical interest when our economy, defense, and indeed our entire way of life 
depend so much on computers and information. The mod function plays a part in 
many aspects of security.
Cryptography
Children often delight in sending “secret messages” using some encoding/­
decoding scheme that they know and that (they believe) their parents don’t know! 
■
Practice 44	 Show the resulting hash tables if 28 is the next value stored in the hash tables of Figure 
5.29(a) and (b).
	
Example 51	
Voting records for the citizens of a certain precinct are stored in a hash table of 
size 197 using the voter’s Social Security number as a key value (the value that is 
hashed). Using a hash function modulo the hash table size, the index to search first 
for data on a voter with Social Security number
328356770
is
328356770  mod  197 = 125

428	
Relations, Functions, and Matrices 
In the adult world, military information, financial information, and company pro-
prietary information that must be transmitted securely uses the same process. The 
original information (called the plaintext) is encrypted using an encryption key, 
resulting in coded text called the ciphertext. The ciphertext is transmitted and 
when it is received, it can be decoded using the corresponding decryption key. 
Encryption and decryption are inverse functions in the sense that
decryption (encryption (plaintext)) = plaintext
If the message is intercepted by someone with no knowledge of the decryption key, 
it will not be useful unless the encryption scheme can be broken. ­Cryptography 
is the study of various encryption/decryption schemes. The broader term 
­cryptology includes not only cryptography but also the techniques used to ana-
lyze and “break” coded messages. One of the most famous examples of breaking 
coded messages occurred during World War II when a British team that included 
mathematician Alan Turing, working at Bletchley Park, was able to break the 
supposedly invincible German “Enigma” code and decipher the plans of German 
submarine movement.
Military use of cryptographic techniques can be traced back to Julius Caesar 
who sent messages to his generals in the field using a scheme now known as the 
Caesar cipher. Let us assume that plaintext messages use only the 26 capital let-
ters of the alphabet, that spaces between words are suppressed, and that each letter 
is first mapped to its corresponding position in the alphabet:
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
We’ll denote this mapping as the bijection g: 5A, … , Z6 S 50, … , 256. 
Then a positive integer key value k is chosen that shifts each number k posi-
tions to the right with a “wrap-around” back to the beginning if needed (this is 
the mod function). Finally, the function g−1 is applied to translate the resulting 
number back into a letter. This produces the final ciphertext character c that 
corresponds to an original plaintext character p. Informally, we could compute 
c from p by just shifting over, in a circular fashion, k positions in the list of let-
ters, but the conversion to numbers allows us to write a mathematical function 
to carry out the encoding and decoding algorithmically. The encoding function 
is given by
f (p) = g−1(3g(p) + k4 mod 26)
The decoding process is to find the number for c, shift left k positions with a 
“wrap-around” back to the end if needed, then change the resulting digit back into 
a character. The decoding function is
f −1(c) = g−1(3g(c) −k4 mod 26)

Section 5.6   The Mighty Mod Function	
429
Notice that if you intercept a message encoded using a Caesar cipher, you 
need to try only 26 possible key values to break the code (actually only 25 since 
k = 26 shifts each number back to itself). The Caesar cipher is not a very secure 
code; it may have served well, however, in an era when not many people could 
read at all. For additional security, the function g could be a less obvious bijection; 
the number of possible bijections g is 26! This would mean a total of 26!*25 pos-
sibilities to try for g and k, too large a number even if you had your handy laptop 
with you in Gaul. As a cryptanalyst, you would narrow down the possibilities by 
making use of statistical characteristics of the language, such as individual letter 
frequency, frequency of certain letter pairs, and so on.
	
Example 52	
In a Caesar cipher with k = 3,
E encodes to g−1(34 + 34  mod  26) = g−1(7  mod  26) = g−1(7) = H
Y encodes to g−1(324 + 34  mod  26) = g−1(27  mod  26) = g−1(1) = B
And for k = 3,
H decodes to g−1(37 −34  mod  26) = g−1(4  mod  26) = g−1(4) = E
B decodes to g−1(31 −34  mod  26) = g−1(−2  mod  26) = g−1(24) = Y
■
Practice 45	 Decode the following ciphertext that was encoded with a Caesar cipher using a key of 7: 
AOLJHAPUAOLOHA.
The Caesar cipher is a simple substitution cipher, meaning that each plain-
text character is coded consistently into the same single ciphertext character. 
­Encryption techniques where a single plaintext character contributes to several 
ciphertext characters (and one ciphertext character is the result of several plaintext 
characters) introduce diffusion. The advantage to diffusion is that it hides the fre-
quency statistics of individual letters, making analysis of an intercepted ciphertext 
message much more difficult.
DES (Data Encryption Standard) is an internationally standard encryption 
algorithm developed in 1976. DES was developed to safeguard the security of 
digital information, so we may consider the plaintext to be a string of bits (a string 
of 0s and 1s). Unlike the Caesar cipher that encodes each single plaintext charac-
ter individually, DES is a block cipher. A block of 64 plaintext bits is encoded as 
a unit using a 56-bit key. This results in a block of 64 ciphertext bits. However, 
changing one bit in the plaintext or one bit in the key changes about half of the 
resulting 64 ciphertext bits, so DES exhibits high diffusion. One might expect 
this effect to require some extremely complex mathematical encoding function, 
but DES actually uses many simple operations over and over. The DES algorithm 
calls for 16 “rounds” to be done; the original 56-bit key is modified from one 
round to the next, as is the original 64-bit plaintext block. The modifications in-
volve the following, among other things:

430	
Relations, Functions, and Matrices 
•	 Running bit strings through permutation functions f(i) = j such that the 
new bit value at position i in the string is the old bit value at position j
•	 Combining bit strings from the plaintext and the key using a bitwise  
exclusive-ORoperation ! (two 0s or two 1s result in a 0 bit, while a single 
0 and a single 1 result in a 1 bit)
•	 Changing the key by splitting the bit string in half and performing a circu-
lar left shift on each half of 1 bit or 2 bits, depending on the round number
It’s easy to look at a bit string and see informally what the result of a circular 
left shift will be. But, as in the case of the Caesar cipher, we’d like to put the shift 
on a mathematical (algorithmic) footing, and the mod function comes into play. 
	
Example 53	
Consider a 5-bit binary string x, such as 11010. A 1-bit circular left shift of x would 
involve moving bits as follows—
1
1
0
1
0
—resulting in
1
0
1
0
1
Thinking of 11010 as a binary number, each column represents a power of 2, as 
opposed to the powers of 10 that our decimal numbers represent. The decimal 
equivalent of x = 11010 is therefore
1 # 24 + 1 # 23 + 0 # 22 + 1 # 21 + 0 # 20 = 16 + 8 + 2 = 26
and the decimal equivalent of y = 10101 is 16 + 4 + 1 = 21.
To mathematically compute y from x, we can carry out the following steps. 
While all steps are done on binary strings, we will also show the decimal equiva-
lents. Multiplication of a binary string by 2 moves the digits one column to the left, 
padding the rightmost column with 0; multiplication by 2−4 moves the digits four 
columns to the right, padding the four leftmost columns with 0, just as happens 
when multiplying a decimal number by 10 or by 10−4, respectively. 
	
Binary	
Decimal
x = 11010	
26
let p = x mod 24 = 01010	
10 (26 mod 16)
let q = p # 2 = 10100	
20
let s = x ! p = 10000	
16
let t = s # 2−4 = 00001	
1
let y = q + t = 10101	
21

Section 5.6   The Mighty Mod Function	
431
Here y is the result of a 1-bit left circular shift of x. This algorithm generalizes 
to an n-bit string x (p = x mod 2n−1, q = p # 2, s = x ! p, t = s # 2−(n−1), and 
y = q + t). A 2-bit left circular shift can be accomplished by two 1-bit shifts.	
A ciphertext that is the result of a DES encryption can be decoded into plain-
text by reversing all the steps of the encoding process, including applying the keys 
for each round in the reverse order in which they were used for encoding. Because 
the DES algorithm is well-known, the only “secret” part is the 56-bit key that is 
used. Hence a DES ciphertext can be decrypted by a brute force technique of try-
ing all possible 56 bit keys, of which there are 256. Even assuming that on the aver-
age one would hit the right key after trying about half the possibilities, this is still 
255 binary strings to generate and test in the DES algorithm. This number used to 
be considered so impossibly large that DES encoding was deemed perfectly se-
cure, and the U.S. government insisted for many years that it was “unbreakable.” 
But with faster computers and using parallelism, it’s possible to find the key in a 
matter of hours.
In recognition of this potential weakness, a new encoding scheme called AES 
(Advanced Encryption Standard) was adopted by the U.S. National Institute of 
Standards and Technology in 2001 after a five-year design competition. AES is 
also a block encryption scheme, but it uses a key length of 128 bits or more. (AES 
also uses a form of the Euclidean algorithm, discussed in Section 2.3, the idea of 
relatively prime numbers, discussed in Section 2. 4, arithmetic modulo n, illustrat-
ed in the first few exercises at the end of this section, and ideas from Section 9.1.)
A disadvantage of both DES and AES is that they are symmetric encryp-
tion (also called private key encryption) schemes. The same key is used to both 
encode and decode the message; for example, in a Caesar cipher, the key is the 
amount of shift k, and decoding is accomplished by shifting left instead of right. 
In a private key encryption scheme, both the sender and receiver must know the 
key. The problem of securely transmitting a message turns into the problem of 
securely transmitting the key to be used for the encryption and decryption.
Asymmetric encryption (public key encryption) schemes use different 
keys for encoding and decoding. The decryption key cannot be derived in any 
practical way from the encryption key, so the encryption key can be made public. 
Anyone can send a message to the intended receiver in encrypted form using the 
receiver’s public key, but only the intended receiver, who has the decryption key, 
can decode it. The best-known asymmetric encryption scheme is the RSA public 
key encryption algorithm, named for its developers Ron Rivest, Adi Shamir, 
and Len Adleman. RSA uses the mod function, as well as the Euler phi function 
discussed in Section 2.4, to produce secure public keys. The RSA method works 
as follows:
	
1.	 Two large prime numbers p and q (on the order of 200 digits each) are 
chosen at random (such numbers can be found relatively easily), and 
p # q = n is computed.
■
Practice 46	 Use the algorithm of Example 53 to compute the 1-bit circular left shift of 1011 (write the 
bit strings for x, p, q, and so on).

432	
Relations, Functions, and Matrices 
	
2.	 RSA, like DES and AES, is a block cipher, so let us assume that a block 
B of text has been encoded by some invertible function g into an integer T 
(much as is done in the Caesar cipher) where T is an integer, 0 < T < n.
	
3.	 The Euler phi function w(n) is computed. Because n is the prod-
uct of two primes, we know from Equation (2) of Section 2.4 that 
w(n) = (p −1)(q −1).
	
4.	 A value e is chosen with 1 < e < w(n) such that e and w(n) are relatively 
prime, that is, gcd (e, w(n)) = 1. (This will surely be true if e is itself a 
prime number.)
	
5.	 gcd(e, w(n)) = 1 means that 1 can be written as a linear combination of e 
and w(n)
d # e + f # w(n) = 1
	
	 or
d # e ≡1 mod w(n)
	
	 The Euclidean algorithm can be used to find unique values for d (and f ) 
such that 1 < d < w(n).
	
6.	 The public key is the pair of values (n, e). T is encoded by computing 
T  e mod  n.
	
7.	 The private key is the pair of values (n, d ), of which only the “d ” part 
is secret. The received message T e mod n is decoded by computing 
(T  e mod  n)d mod  n.
(T  e mod n)d mod n = (T e)d mod n by Equation (1)
= T  ed mod n with d # e ≡1 mod w(n)
	
	 and it happens that this expression equals T. (The proof depends on two 
classic results from number theory called Fermat’s little theorem and the 
Chinese remainder theorem. See Exercises 37–41.)
	
8.	 Then g−1(T ) = B, the original text block.
Because n and e are public, anyone who could factor n into its prime factors p 
and q could then reconstruct the decryption key d and decode the message. How-
ever, there is no efficient algorithm to find the prime factors of a (large) n. Hence, 
while the RSA cryptosystem is not technically secure, it is practically so, although 
a number of demonstration “factor attacks” have been made using many people 
working together via PCs and the Internet.
Although public key encryption solves the “key distribution” problem of shared 
keys between sender and receiver, it is a relatively slow encryption/decryption 
­method. Hence in applications such as financial transactions over the ­Internet, ­public 
key encryption is often used for secure transmission of keys for private key commu-
nication, which is then used to transmit the actual message. The user’s browser may 
send a request to the Web server for the server’s public encryption key. Upon receipt, 
the browser uses this public key to send an encrypted message back to the server 
that contains a symmetric key for DES encryption. At this point both the browser 
and the server share a secret key that has been securely transmitted, and the rest of 
the transaction can be carried out using the faster DES encryption.

Section 5.6   The Mighty Mod Function	
433
	
Example 54	
Using RSA encryption/decryption, let p = 17 and q = 13. Then n = 221 and 
w(n) = 16 # 12 = 192. Pick e = 11; e and w(n), 11 and 192, are relatively prime. 
Using the Euclidean algorithm, with 11 and 192,
	
192 = 17 # 11 + 5	
or	
5 = 192 −17 # 11
	
11 = 2 # 5 + 1	
or	
1 = 11 −2 # 5
	
5 = 5 # 1 + 0
from which
1 = 11 −2 # 5 = 11 −23192 −17 # 114 = 35 # 11 −2 # 192
which gives a value for d of 35. If the integer T = 8, then 8 is encoded as follows, 
where the tedious modulo arithmetic can be broken down using Equation (1). The 
encoding key is (n, e) and both values are used in the computation.
811 mod 221 = 83 # 83 # 83 # 82 mod 221
= 512 # 512 # 512 # 64 mod 221
= 70 # 70 # 70 # 64 mod 221
= 4900 # 4480 mod 221
= 38 # 60 mod 221
= 2280 mod 221
= 70
 
To decode the encrypted value 70, compute
7035 mod 221 = (702)17 # 70 mod 221 = (4900)17 # 70 mod 221
=  3817 # 70 mod 221 = (382)8 # 38 # 70 mod 221
= (1444)8 # 38 # 70 mod 221 = (118)8 # 38 # 70 mod 221
= 3(118)244 # 38 # 70 mod 221 = (13924)4 # 38 # 70 mod 221
= 14 # 38 # 70 mod 221 = 2660 mod 221 = 8
 
which was the original encoded integer
This is not a realistic example because p and q (and n) are relatively small. 
But even here the computations are quite tedious. Again, a spreadsheet and its mod 
function will be helpful.
■
Practice 47	 Assume you receive a ciphertext message of 166 that was encoded using your public key 
(n, e) from Example 54. Decode the message to obtain the original integer T.
Hashing for Password Encryption
The user of a computer system typically has to enter a user ID and password to 
authenticate him or her as a legitimate user, a person entitled to use these comput-
ing resources. The list of user IDs and corresponding passwords must be stored 

434	
Relations, Functions, and Matrices 
­somewhere in the computer system, and this information is obviously sensitive. 
Anyone with a copy of the password file has open access to the computer and could 
even use the ID/password that has the highest level of computer privileges (such as 
the system administrator ID/password). Therefore the password file, like the se-
cret messages discussed earlier, must be protected. The operating system will, by 
default, store the password file with the highest level of protection so that only a 
system administrator account has access. But as an added protection, the file will 
be encrypted in some way. A password file might have entries something like this:
User ID
Encrypted PW
jgarcia
ax*79%
wbriggs
ee&46#
Unlike secret messages being transmitted, the password file is in constant use. 
The operating system must be able to quickly authenticate a given user by check-
ing that the password the user enters matches the password stored for that user 
ID. When the user ID jgarcia is entered, one approach would be to find ­jgarcia 
in the password file, decrypt the corresponding encrypted password (ax*79% in 
this case) and see if the result matches what the user entered. But this means that, 
however fleetingly, a legitimate “clear” password would be stored within the com-
puter for this user ID, and might be captured by someone hacking the system at 
that moment, perhaps even someone posing as the jgarcia user and guessing at the 
correct password.
A better approach is to apply the encryption key (also stored in the system) to 
the password entered and then check the resulting encrypted password against the 
table entry of ax*79%. A match occurs only if the correct password was entered. If 
a hacker’s attempt fails, he or she does gain the knowledge that what they entered 
is not the jgarcia password, but that is of no help in finding the correct password.
Better still is to use a form of encryption that does not require storing an 
encryption key. A hash function is often used to encrypt passwords. The ideal 
cryptographic hash function h has two characteristics:
	
1.	 Given x, it is easy to compute the hashed value h(x).
	
2.	 Given a hashed value z, it is difficult to find a value x for which h(x) = z.
Because of these characteristics, a hash function is also called a one-way 
­encryption. The password file would now have entries such as
User ID
Hashed PW
jgarcia
h(password 1)
wbriggs
h(password 2)
Property (2) means that if the password file falls into the wrong hands, it is of 
little use in trying to break into the system, even if the hash algorithm being used 
is known. Hence securing the password file is no longer a concern. Property (2) 
also means that a cryptographic hash function is likely to be more complex than a 
hash function used to build a hash table for searching, as discussed earlier. There 
are many well-known encryption/hashing functions, most of which involve use of 
the modulo n function where n is some power of 2.

Section 5.6   The Mighty Mod Function	
435
There is the slight possibility that user A and user B could pick different 
passwords that hash to the same value, or even that A and B pick the same pass-
word. As far as ordinary usage is concerned, this doesn’t matter; both A and B 
will be authenticated as legitimate users. However, if A steals the password file 
(no longer securely protected), A could notice that user B’s password hashes to 
the same value as A’s, and if indeed the passwords are the same, A could log 
in as B and do damage to B’s files. Most password encryption schemes append 
some sort of timestamp to a password when the password is first created, and 
(password + timestamp) is encrypted. If A and B choose the same password, 
their timestamps (and hashed values) will differ. The timestamp is stored in 
the password file along with the user ID and when the user enters his or her 
password, the timestamp is appended and the result hashed and compared to 
the table entry.
Miscellaneous Applications
Identification Codes
Sometimes codes are used for identification purposes, not the “secret code” 
­purposes we discussed earlier.
	
Example 55	
An International Standard Book Number, or ISBN, is a numeric identification 
code associated with a published book. The 10-digit ISBN standard was adopted 
in 1970, but it was replaced by a 13-digit ISBN standard in 2007. Books published 
since 2007 generally carry both a 10-digit code and a 13-digit code.
The ISBN-10 is written as four blocks of digits separated by hyphens or blanks. 
Reading left to right, the first block of digits is a group identifier for a country, area, 
or language area participating in the ISBN system, the second block of digits iden-
tifies the publisher within that group, and the third block is the number assigned by 
the publisher to this particular work. The final block consists of a single digit from 
0–9 or a single X to represent 10. If the first nine digits of the ISBN-10 are
a1a2a3a4a5a6a7a8a9
then the tenth digit, or check digit, C, is computed by the formula
C = c ∙
9
i=1
i(ai)dmod 11
—that is, sum up the product of each digit times its position in the list and to the 
result apply the modulo 11 function.
For example, in the ISBN-10 0-394-80001-X, the 0 indicates the English 
­language group, the 394 identifies the publisher as Random House, the 80001 
identifies the title The Cat in the Hat by Dr. Seuss, and the check digit X (10) is 
computed from
[1 # 0 + 2 # 3 + 3 # 9 + 4 # 4 + 5 # 8 + 6 # 0 + 7 # 0 + 8 # 0 + 9 # 1] mod 11 = 
98 mod 11 = 10
The purpose of the check digit is to detect certain types of errors in the ISBN code, 
such as a mistyped digit or a transposition of two digits.

436	
Relations, Functions, and Matrices 
In the ISBN-13, there is an additional block of three digits in the front that 
identifies the type of industry. For a published book, this block is always 978. The 
next three blocks agree with the ISBN-10, but the final block, again a check digit, 
is computed differently. If the first 12 digits of the ISBN-13 are
a1a2a3a4a5a6a7a8a9a10a11a12
then the 13th digit, the check digit C, is computed from the 12 digits by the formula
c3∙
6
i=1
a2i + ∙
5
i=0
a2i+1 + Cd  mod 10 = 0
—that is, three times the sum of all the even digits + the sum of all the odd digits 
plus the check digit should give a multiple of 10.
The ISBN-13 for The Cat in the Hat is 978-0-394-80001-1. The check digit C 
(digit 13) is computed from
9 + 3 # 7 + 8 + 3 # 0 + 3 + 3 # 9 + 4 + 3 # 8 + 0
+ 3 # 0 + 0 + 3 # 1 + C = 99 + C
so C = 1 to make a total of 100, a multiple of 10.	
Practice 48	
a.	 If an ISBN-10 begins with 0-534-37488, what is the check digit?
b.	If digits in this number are transposed to 0-534-37848, what is the check digit?
■
	
Example 56	
The UPC-A (Universal Product Code) is the common bar code found on all 
goods in stores (food, magazines, and so on). It is an encoding of a 12-digit num-
ber, where the first digit is a sort of classification digit, the next five digits are a 
manufacturer code, the next five digits are the product code, and the last digit is a 
check sum digit. Each digit is assigned a 7-bit binary code, but this is not the usual 
binary number representation; for example, the binary code for 5 is 0110001. The 
7-bit code for any single digit is represented by a pattern of vertical bars and spaces 
(space-bar-space-bar if the digit occurs in the left half of the 12-digit string, bar-
space-bar-space if it occurs in the right half). The spaces and bars can have varying 
widths from 1 to 4, 1 being the thinnest and 4 the thickest. If a 5 occurs in the left half 
of the 12-digit string, its binary code would be represented by a space of width 1, 
a bar of width 2, a space of width 3, and a bar of width 1.
0
1
1
0
0
0
1

Section 5.6   The Mighty Mod Function	
437
If a 5 occurs in the right half, the same binary code would be represented by 
a bar of width 1, a space of width 2, a bar of width 3, and a space of width 4. In 
addition, there are some extra bits inserted at each end and in the middle for a total 
of 95 bits. 
The check digit C (digit 12) is computed from the previous 11 digits as ­follows:
c3∙
5
i=0
a2i+1 + ∙
5
i=1
a2i + Cd  mod 10 = 0
—that is, three times the sum of all the odd digits plus the sum of all the even digits 
plus the check digit should give a multiple of 10. This formula is similar to the one 
for the ISBN-13 check digit except that for the ISBN-13 it is the even digits that 
are multiplied by 3 and for the bar code it is the odd digits.	
	
	
Example 57	
The American Bankers Association (ABA) devised a code to represent a specific 
financial institution. This number was originally designed for paper checks, and 
it does appear on the bottom of paper checks, but today it is also used for such 
transactions as direct deposit or electronic funds transfer. This routing number 
consists of 8 digits plus a check digit. The first four digits represent Federal Re-
serve information connected with the financial institution and the second four  
digits identify the institution itself. The check digit C is computed by
c3∙
2
i=0
a3i+1 + 7∙
2
i=0
a3i+2 + 1∙
1
i=0
a3i+3 + Cd mod 10 = 0
—that is, digits 1, 4, and 7 are multiplied by 3 and added, digits 2, 5, and 8 are 
multiplied by 7 and added, and digits 3 and 6 are multiplied by 1 and added. The 
total plus the check digit should be a multiple of 10.	
Generating and Decomposing Integers
The modulo function provides an easy way to generate integer values within some 
range 0 through n −1 for some positive integer n. Take any positive integer m and 
compute m mod n. If you have a function to generate a random (or pseudorandom) 
integer m, this process generates a random (or pseudorandom) integer within the 
desired range. You may also want to cycle through the integers in this range in a 
controlled fashion.
	
Example 58	
You want to show a sequence of five images on your Web page. The images are 
stored in an arraylike structure as Image(1), …, Image(5), and the actual image 
to be displayed is stored in the variable DisplayImage, which is initialized to  
Image(1):
i = 1
DisplayImage = Image(i)

438	
Relations, Functions, and Matrices 
Image(1) is the first image displayed. After that, at every clock tick (or at pre-
defined intervals), the statements
i = i mod 5 + 1
DisplayImage =  Image(i)
are executed. The effect is to cycle the index i through the values 2, 3, 4, 5, 1, and 
so on, and to cycle the displayed images as Image(2), Image(3), Image(4), Im-
age(5), Image(1), and so on.	
The modulo function can also be used to decompose a multidigit integer into 
its component digits.
	
Example 59	
To decompose a three-digit integer into the ones, tens, and hundreds digits, one can 
use the following algorithm:
temp = number
ones = temp mod 10
temp = (temp −ones)∙10
tens = temp mod 10
temp = (temp −tens)∙10
hundreds = temp
■
Practice 49	 Given the integer 375, walk through the algorithm of Example 59 to separate the digits.
Modular Arithmetic Designs
The mod function can be used to make interesting quiltlike patterns by arranging 
“tile” images (small square images) in tables based on addition modulo n and then 
repeating these tables to form the completed quilt image.4 Addition modulo n is 
defined on the set of integers 50, 1, 2, …, n −16 by
x +n   y = (x + y) mod n
4This section on modular arithmetic designs was adapted with permission from http://britton.disted.­camosun.
bc.ca/modart/jbmodart2.htm; the software used to generate the design is Cayley Quilter, available to down-
load at http://www.wou.edu/~burtonl/cquilter.html
	
Example 60	
In this example we will use addition modulo 6. Addition modulo 6 applies to the 
integers 50, 1, 2, 3, 4, 56 using the rule x +6  y = (x + y) mod 6. The addition ta-
ble follows. It shows, for example,
3 +6 4 = (3 + 4) mod 6 = 7 mod 6 = 1

Section 5.6   The Mighty Mod Function	
439
No values of 6 appear in the table, and each row is a circular left shift of the previ-
ous row.
6
0
1
2
3
4
5
0
0
1
2
3
4
5
1
1
2
3
4
5
0
2
2
3
4
5
0
1
3
3
4
5
0
1
2
4
4
5
0
1
2
3
5
5
0
1
2
3
4
We will need six tile images of various geometric designs:
Tile 0
Tile 1
Tile 2
Tile 3
Tile 4
Tile 5
The tiles are then arranged in a 6 × 6 table according to the addition modulo 6 
pattern, that is, the interior of the addition modulo 6 table. The top row shows im-
ages left to right of 0, 1, 2, 3, 4, 5, the next row shows images left to right of 1, 2, 
3, 4, 5, 0, and so forth.
The final image is composed of four copies of the table arranged in a 2 × 2 grid 
where the original table goes in the upper-left quadrant, its horizontal reflection 
goes in the upper-right quadrant, and the bottom two quadrants are vertical reflec-
tions of the top half.

440	
Relations, Functions, and Matrices 
S e c t i o n  5 . 6 	
Review
Techniques
•	 Perform calculations using the mod function.
•	 Build or search a hash table that uses linear probing 
for collision resolution.
•	 Build or search a hash table that uses chaining for 
collision resolution.
•	 Encode and decode using a Caesar cipher.
•	 Apply the algorithm to compute a circular left shift 
of a binary string.
•	 Perform encryption and decryption using the RSA 
public key encryption algorithm.
•	 Compute the check digit for the ISBN-10,  
ISBN-13, UPC-A, and ABA codes.
Main Ideas
•	 The humble modulo function is useful in many im-
portant applications.
Exercises 5.6
Exercises 1–8 concern modular arithmetic mod n.
	 1.	 25 = 11 + 14. Show by computing each expression that
25 mod 6 = (11 mod 6 + 14 mod 6) mod 6
	 2.	 395 = 129 + 266. Show by computing each expression that
395 mod 4 = (129 mod 4 + 266 mod 4) mod 4
	 3.	 262 = 74 + 188. Show by computing each expression that
262 mod 13 = (74 mod 13 + 188 mod 13) mod 13
W
W

Section 5.6   The Mighty Mod Function	
441
	 4.	 Prove that for any integers x and y,
(x + y) mod n = (x mod n + y mod n) mod n
	 5.	 486 = 18 #  27. Show by computing each expression that
486 mod 5 = (18 mod 5 #  27 mod 5) mod 5
	
6	  7067 = 191 #  37. Show by computing each expression that
7067 mod 8 = (191 mod 8 #  37 mod 8) mod 8
	 7.	 Prove that for any integers x and y,
(x #  y) mod n = (x mod n # y mod n) mod n
	 8.	 Prove or disprove: For any positive integer x, (−x) mod n = −(x mod n).
	 9.	 Using the hash function of Example 51, which of the following Social Security numbers would cause a 
collision with 328356770, the Social Security number of that example?
	
a.	 060357896
	
b.	896137243
	
c.	 712478993
	
d.	659027781
	 10.	Find a set of five numbers in the range 30, 2004 that cause 100% collision using the hash function
h(x) = x mod 13
	 11.	Using a hash table of size 11 and the hash function x mod 11, show the results of hashing the following 
values into a hash table using linear probing for collision resolution:
1, 13, 12, 34, 38, 33, 27, 22
	 12.	Using the completed hash table from Exercise 11, compute the average number of comparisons needed to 
perform a successful search for a value in the table.
	 13.	When a computer program is compiled, the compiler builds a symbol table for storing information about 
the identifiers used in the program. A scheme is needed to quickly decide whether a given identifier has 
already been stored in the table and, if not, to store the new identifier. A hash function is often used to 
locate a position in the table at which to store information about an item. 
For simplicity, assume that the items to be stored are integers, that the hash table can hold 17 items in 
positions 0–16, and that the hash function h(x) is given by h(x) = x mod 17.
Linear probing is used for collision resolution.
	
a.	 Using the hash function and collision resolution scheme described, store the sequence of values 23, 14, 
52, 40, 24, 18, 33, 58, 50. Give the location in the table at which each is stored.
	
b.	After the table of part (a) has been filled, describe the process to search for 58 in the table. Describe the 
process to search (unsuccessfully) for 41 in the table.

442	
Relations, Functions, and Matrices 
	 14.	Explain what problem can arise if an item stored in a hash table is later deleted.
	 15.	A disadvantage of hashing with linear probing for collision resolution is that elements begin to cluster 
together in groups of adjacent array locations. Assume that you have a very good hashing function (it dis-
tributes elements evenly throughout the hash table). Start with an empty hash table of size t that will store 
data using linear probing for collision resolution.
	
a.	 What is the probability of hashing the first element to location p (and storing it there, since it is the first 
item and there will be no collisions)?
	
b.	Once location p is occupied, what is the probability of storing the second item in location p + 1 
(modulo the table size)?
	
c.	 Once locations p and p + 1 are occupied, what is the probability of storing the third item in location 
p + 2 (modulo the table size)?
	 16.	Generalize the answers to Exercise 15 to explain why using linear probing for collision resolution causes 
clustering.
	 17.	Decode the following ciphertext messages that were encoded using a Caesar cipher with the given key.
	
a.	 JUUBFNUUCQJCNWMBFNUU, k = 9
	
b.	XAEWFVMPPMKERHXLIWPMXLCXSZIWHMHKCVIERHKMQFPIMRXLIAEFI, k = 4
	
c.	 IURSAYZGXJCOZNZNKQTOLKOTZNKROHXGXE, k = 6
	 18.	Using a Caesar cipher, encode the following plaintext messages.
	
a.	 ATTACK FROM BEYOND THE RIVER, k = 5
	
b.	WE ARE SHORT OF SUPPLIES, k = 10
	
c.	 BADLY NEED AMMUNITION, k = 8
	 19.	The following ciphertext message is intercepted; you suspect it is a Caesar cipher. Find a value of k that 
decodes the message, and give the corresponding plaintext.
BUNNYWXFFNVJALQXWAXVNCXVXAAXF
	 20.	The following ciphertext message is intercepted; you suspect it is a Caesar cipher. Find a value of k that 
decodes the message, and give the corresponding plaintext. 
EQQKAGAZRMOQNAAWPGPQ
	 21.	Use the algorithm of Example 53 to compute the 1-bit circular left shift of the following binary strings 
(write the bit strings for x, p, q, and so on).
	
a.	 10011
	
b.	0011
	 22.	Use the algorithm of Example 53 to compute the 1-bit circular left shift of the following binary strings 
(write the bit strings for x, p, q, etc.).
	
a.	 10110
	
b.	1110
	 23.	Consider a “short form” of DES that uses 16-bit keys. Given the 16-bit key
1101000101110101
	
	 as input to a DES round that uses a circular left shift of 2 bits, what would be the key for the next round?

Section 5.6   The Mighty Mod Function	
443
	 24.	Describe how to perform a 1-bit right circular shift on a 4-bit binary string x using the left circular shift 
operation.
	 25.	Using RSA encryption/decryption, let p = 5 and q = 3. Then n = 15 and  w(n) = 4 #  2 = 8. Pick e = 3.
	
a.	 Use the Euclidean algorithm to find the value of d.
	
b.	Encode T = 8 using the public key (n, e).
	
c.	 Decode your answer to part (b) to retrieve the 8.
	 26. 	Why is the RSA encryption of Exercise 25 a poor choice?
	 27.	Using RSA encryption/decryption, let p = 5 and q = 11. Then n = 55 and w(n) = 4 #  10 = 40. 
Pick e = 7.
	
a.	 Use the Euclidean algorithm to find the value of d. (Hint: If the Euclidean algorithm produces an equa-
tion 1 = x #  e + f # w(n)where the value of x is negative, add and subtract the product e # w(n) to the 
right side of the equation to get a positive value for d.)
	
b.	Encode T = 12 using the public key (n, e).
	
c.	 Decode your answer to part (b) to retrieve the 12.
	 28.	Using RSA encryption/decryption, let p = 23 and q = 31. Then n = 713 and w(n) = 22 #  30 = 660. 
Pick e = 17.
	
a.	 Use the Euclidean algorithm to find the value of d.
	
b.	Encode T = 52 using the public key (n, e).
	
c.	 Decode your answer to part (b) to retrieve the 52.
	 29.	a.	 All n people in a group wish to communicate with each other using messages encrypted with DES or 
AES. A different secret key must be shared between each pair of users. How many keys are required?
	
b.	All n people in a group wish to communicate with each other using messages encrypted with a public 
key encryption system. How many keys are required?
	 30.	Computer users are notoriously lax about choosing passwords; left to their own devices, they tend to pick 
short or really obvious passwords. At Simpleton University, passwords must contain only lowercase let-
ters, and the campus computer system uses an (unrealistically simple) cryptographic hash function given 
by the following algorithm:
	
	
1. Letters in the password are converted to an integer equivalent (a S 1, b S 2, and so on). 
	
	
2. In the result of step 2, all individual digits are added (for example, 17 becomes 1 + 7) to give an 
integer value x. 
	
	
3. h(x) = x mod 25
	
	 Joe Hack has managed to steal the password table, and he notices that there is a password entry of 20 for 
bsmith. Joe decides to try to hack into the system as bsmith by guessing bsmith’s password. Can you guess 
bsmith’s password?
	 31.	a.	 The ISBN-10 of the sixth edition of this book is 0-7167-6864-C where C is the check digit. What is the 
check digit?
	
b.	What is the ISBN-13 of the sixth edition?
	 32.	A bookstore placed an order for 2000 copies of Harry Potter and the Deathly Hallows, the seventh and 
final volume in the hugely popular Harry Potter series by J. K. Rowling. When placing the order with the 
publisher, the ISBN-13 978-0-545-01022-5 was used. Is this correct?
	 33.	Given the 11 digits 02724911637, compute the check digit for the UPC-A code.

444	
Relations, Functions, and Matrices 
	 34.	A taxpayer wants his tax refund to be deposited directly to his bank. He enters the bank’s routing number, 
including the check digit, as
025107036
	
	 Is this routing number correct?
	 35.	a.	 Write an algorithm to decompose a four-digit integer into the ones, tens, hundreds, and thousands 
­digits.
	
b.	Apply this algorithm to decompose the integer 7426.
	 36.	The following quilt image is based on addition modulo n for what value of n?
Exercises 37–41 involve a proof of step 7 of the RSA method.
	 37.	Prove that if x ≡y (mod n) and c is a constant integer, then xc ≡yc (mod n).
	 38.	This exercise explores the converse of Exercise 37, which is the issue of cancellation under congru-
ence modulo n. In other words, if xc ≡yc (mod n) for some constant integer c, is it then true that  
x ≡y (mod n)? Not always, as it turns out.
	
a.	 Prove that if gcd(c,n) = 1, then xc ≡yc (mod n) implies x ≡y (mod n).
	
b.	Prove that xc ≡yc (mod n) implies x ≡y (mod n) only if gcd (c, n) = 1. To do this, it is easier to 
prove the contrapositive:
If gcd (c, n) ∙1, then there exist integer values x and y for which xc ≡yc (mod n) but x [ y mod n.
	
	
(Hint: Suppose c = m1k and n = m2k with k > 1. Consider x = m2k and y = m2.)
	
c.	 Find values for x, y, c, and n where xc ≡yc (mod n) but x [ y (mod n).
	 39.	If p is a prime number and a is a positive integer not divisible by p, then
ap−1 ≡1(mod p)

Section 5.6   The Mighty Mod Function	
445
	
	 This result is known as Fermat’s little theorem (as opposed to the very famous Fermat’s last theorem men-
tioned in Section 2.4).
Let S = 50, a, 2a, …, (p −1)a6, T = 50, 1, 2, …, (p −1)6. Let f be given by f(ka) = (ka) mod p; 
that is, f computes the residue modulo p.
	
a.	 Prove that f is a one-to-one function from S to T.
	
b.	Prove that f is an onto function.
	
c.	 Prove that 3a # 2a c (p −1)a4 mod p = (p −1)! mod p
	
d.	Prove that ap−1 ≡1 (mod p)
	
e.	 Let a = 4 and p = 7. Compute the set of residues modulo p of 54, 8, 12, …, 246.
	
f.	 Let a = 4 and p = 7. Show by direct computation that 46 ≡1(mod 7).
	 40.	Let m1, m2, …, mn be pairwise relatively prime positive integers (that is, gcd(mi, mk) = 1 for 
1 ≤i, k ≤n, i ∙k), let m = m1m2 c mn, and let a1, a2, c, an be any integers. Then there is an integer 
x such that
x ≡a1 (mod m1)
x ≡a2 (mod m2)
(
x ≡an (mod mn)
	
	 and any other integer y that satisfies these relations is congruent to x modulo m. This result is known as 
the Chinese remainder theorem (based on work done by the Chinese mathematician Sun-Tsu in the first 
century ad). The following steps will prove the Chinese remainder theorem.
	
a.	 Let s and t be positive integers with gcd (s, t) = 1. Prove that there exists an integer w such that 
sw ≡1 (mod t).
	
b.	For each i, 1 ≤i ≤n, let Mi = m∙mi. Prove that gcd(Mi, mi) = 1.
	
c.	 Prove that there is an integer xi such that Mixi ≡1 (mod mi) and aiMixi ≡ai (mod mi).
	
d.	Prove that akMk xk ≡0 (mod mi) for all k ∙i.
	
e.	 Let x = a1M1x1 + a2M2x2 + c+ anMn xn. Prove that for 1 ≤i ≤n, x ≡ai (mod mi).
	
f.	 Let y be such that y ≡ai (mod mi), 1 ≤i ≤n. Prove that x ≡y (mod m). (Hint: Use the fundamental 
theorem of arithmetic and write m as a product of distinct primes, m = pk11 pk22  … pktt ).
	 41.	The remaining step in the proof of the RSA algorithm is to show that if d # e ≡1 mod w(n), then 
T ed mod n = T.
	
a.	 Prove that T ed can be written as T(T p−1)k(q−1) or as T(T q−1)k(p−1) for some integer k.
	
b.	Prove that if T is not divisible by p, then T ed ≡T (mod p), and if T is not divisible by q, then 
T ed ≡T (mod q).
	
c.	 Prove that if p 0  T, then T ed ≡T (mod p) and T is not divisible by q, so  T ed ≡T (mod q) by part (b).
	
d.	Prove that if q 0  T, then T ed ≡T (mod q) and T is not divisible by p, so T ed ≡T (mod p) by part (b).
	
e.	 From parts (b)–(d ) T ed ≡T (mod p) and T ed ≡T (mod q) in all cases. Prove that Ted mod n = T.

446	
Relations, Functions, and Matrices 
	
S e c t i o n  5 . 7 	 Matrices
Terminology
Data about many kinds of problems can often be represented using a rectangular 
arrangement of values; such an arrangement is called a matrix. Thus
A = c1
0
4
3
−6
8d
is a matrix with two rows and three columns. The dimensions of the matrix are 
the number of rows and columns; here A is a 2 × 3 matrix.
Elements of a matrix A are denoted by aij, where i is the row number of the el-
ement in the matrix and j is the column number. In the example matrix A, a23 = 8 
because 8 is the element in row 2, column 3, of A.
	
Example 61	
Average temperatures in three different cities for each month can be neatly sum-
marized in a 3 × 12 matrix. Here we interpret the 3 rows as the 3 cities and the 
12 columns as the 12 months January–December. The average temperature in the 
third city in April, a34, is 67. 
A = £
23
26
38
47
58
71
78
77
69
55
39
33
14
21
33
38
44
57
61
59
49
38
25
21
35
46
54
67
78
86
91
94
89
75
62
51
§
	
Example 62	
In Practice 2(c) of Section 5.1, the binary relation 5(7, 9), (2, 5), (9, 9), (2, 7)6 was 
defined on the set S = 52, 5, 7, 96. Although a set is unordered, we can impose 
an ordering on the elements of S so that 2 is element 1 in S, 5 is element 2, and so 
forth. The matrix R below represents this binary relation by a 1 entry in position 
i,  j if element i in set S is related to element j. Because (7, 9) says that element 3 is 
related to element 4, element r3,4 of R equals 1.
 R = ≥
0
1
1
0
0
0
0
0
0
0
0
1
0
0
0
1
¥
	
Example 63	
Solutions to many problems can be obtained by solving systems of linear equa-
tions. Suppose, for example, that you are placing an order for coffee beans for your 
sidewalk café. You want to order 70 pounds of beans, a mixture of Kona coffee 
beans and Colombian coffee beans. You are willing to spend $1180; Kona cof-
fee costs $24 per pound, and Colombian coffee costs $14 per pound. How many 
pounds of each should you order?

Section 5.7   Matrices	
447
The constraints in this problem are represented by the system of linear 
­equations
 x +
 y =
 70
 24x + 14y = 1180
These are linear equations because each of the two unknowns, x and y, appears 
only to the first power. (Also an equation such as ax + by = c represents a straight 
line when graphed on an x–y coordinate system.) The solution to this system of 
equations is x = 20, y = 50 (you can easily check that this is a solution). The 
matrix
a = c 1
1
24
14d
is the matrix of coefficients for this system of linear equations. As we will see, the 
matrix of coefficients can be used to solve a system of linear equations.	
■
Practice 50	 In the matrix:
 a = c1
4
−6
8
3
0
1
−7d
What is a23? What is a24? What is a13?
In a matrix, the arrangement of the entries is significant. Therefore, for two 
matrices to be equal, they must have the same dimensions and the same entries 
in each location.
	
Example 64	
Let
X = £
x
4
1
y
z
0
§
Y = £
3
4
1
6
2
w
§
If X = Y, then x = 3, y = 6, z = 2, and w = 0.	
We will often be interested in square matrices, in which the number of rows 
equals the number of columns. If A is an n × n square matrix, then the elements 
a11, a22, … , ann form the main diagonal of the matrix. If the corresponding ele-
ments match when we think of folding the matrix along the main diagonal, then 
the matrix is symmetric about the main diagonal. In a symmetric matrix, aij = aji.

448	
Relations, Functions, and Matrices 
A more general way to represent arrangements of data is the array. Arrays are 
n-dimensional arrangements of data, where n can be any positive integer. If n = 1, 
then the data are arranged in a single line, which is therefore a list or finite se-
quence of data items. This one-dimensional version of an array is called a vector. 
If n = 2, the array is a matrix. If n = 3, we can picture layers of two-dimensional 
matrices. For n > 3, we can formally deal with the array elements, but we can’t 
really visualize the arrangement. The array data structure is available in many 
high-level programming languages because it is such a useful way to represent 
data in list form or tabular form. Generally, the number of elements expected in 
each dimension of the array must be declared in the program. The array X of Ex-
ample 64, for instance, would be declared as a 3 × 2 array—a two-dimensional 
array (matrix) with three elements in one dimension and two in the other (that is, 
three rows and two columns).
Matrix Operations
Although matrices are particular arrangements of individual elements, we can 
treat the matrices themselves as objects, just as we can treat sets of elements as 
objects. In each case we are abstracting up one level and looking at the collection 
as an entity, rather than looking at the individual elements that make up the col-
lection. We defined operations on sets (union, intersection, and so forth) that made 
sets useful for solving counting problems. We can define arithmetic operations on 
matrices whose entries are numerical. These operations make matrices interesting 
objects to study in their own right, but they also make matrices more useful for 
certain tasks such as solving systems of equations.
The first operation, called scalar multiplication, calls for multiplying each 
entry of a matrix by a fixed single number called a scalar. The result is a matrix 
with the same dimensions as the original matrix.
	
Example 65	
The square 3 × 3 matrix
a = £
1
5
7
5
0
2
7
2
6
§
is symmetric. The upper triangular part (the portion above the main diagonal) is a 
reflection of the lower triangular part. Note that a21 = a12 = 5.	
	
Example 66	
The result of multiplying matrix
a = c1
  4
5
6
−3
2d
by the scalar r = 3 is
a = c 3
 12
15
18
−9
6 d

Section 5.7   Matrices	
449
Addition of two matrices A and B is defined only when A and B have the 
same dimensions; then it is simply a matter of adding the corresponding elements. 
Formally, if A and B are both n × m matrices, then C = a + b is an n × m 
matrix with entries
cij = aij + bij
Practice 51	 For r = 2,
	
a = £
1
7
−3
4
5
6
§ 	
b = £
4
0
9
2
−1
4
§
find ra + b.	
■
Subtraction of matrices is defined by a −b = a + (−l)b.
In a zero matrix, all entries are 0. If we add an n × m zero matrix, denoted 
by 0, to any n × m matrix A, the result is matrix A. We can symbolize this by the 
matrix equation
0 + a = a
This equation is true because of a similar equation that holds for all the individual 
numerical entries, 0 + aij = aij. Other matrix equations are also true because of 
similar equations that hold for the individual entries. 
	
Example 67	
For
	
a = £
1
3
6
2
0
4
−4
5
1
§ 	
b = £
0
−2
8
1
5
2
2
3
3
§
the matrix a + b is
 a + b = £
1
1
14
3
5
 6
−2
8
 4
§

450	
Relations, Functions, and Matrices 
One might expect that multiplication of matrices would simply involve mul-
tiplying corresponding elements in the two matrices, but the definition is more 
complicated than that. The definition of matrix multiplication is based on the use 
of matrices in mathematics to represent functions called linear transformations, 
which map points in the real-number plane to points in the real-number plane. 
Although we won’t use matrices in this way, we will use the standard definition 
for matrix multiplication.
To compute A times B, a # b, the number of columns in A must equal the 
number of rows in B. (This requirement means that the number of elements in a 
single row of A equals the number of elements in a single column of B.) Thus we 
can compute a # b if A is an n × m matrix and B is an m × p matrix. The result 
is an n × p matrix. An entry in row i, column j of a # b is obtained by multiplying 
all the elements in row i of A by the corresponding elements in column j of B and 
adding the results. Formally, a # b = C, where
cij = ∙
m
k=1
aikbkj
	
Example 69	
Let
	
a = c2
4
3
4
−1
2d 	
b =  £
5
3
2
2
6
5
§
A is a 2 × 3 matrix and B is a 3 × 2 matrix, so the product a # b exists and is a 
2 × 2 matrix C. To find element cl1, we multiply corresponding elements of row 1 
of A and column 1 of B and add the results.
2(5) + 4(2) + 3(6) = 10 + 8 + 18 = 36
c 2
4
3
4
−1
2 d  £  
5
3
2
2
6
5
§ = c 36
—
—
— d
Element c12 is obtained by multiplying corresponding elements of row 1 of A and 
column 2 of B and adding the results.
	
Example 68	
If A and B are n × m matrices and r and s are scalars, the following matrix 
­equations are true:
	
0 + a = a
	
a + b = b + a
	
(a + b) + C = a + (b + C)
	
r (a + b) = ra + rb
	
(r + s)a = ra + sa
	
r (sa) = (rs)a
To prove that a + b = b + a, for instance, it is sufficient to note that 
aij + bij = bij + aij for each entry in matrices A and B.	

Section 5.7   Matrices	
451
c 2
4
3
4
−1
2 d  £
5
3
2
2
6
5
 § = c 36
29
—
— d
The complete product is
c2
4
3
4
−1
2d £
5
3
2
2
6
5
§ = c36
29
30
20d
■
Practice 52	 Compute a # b and b # a for
a = c1
4
6
−2d        b = c3
6
3
4d
From Practice 52 we see that even if A and B have dimensions so that both 
a # b and b # a are defined, a # b need not equal b # a. There are, however, sev-
eral matrix equations involving multiplication that are true.
	
Example 70	
Where a, b, and C are matrices of appropriate dimensions and r and s are scalars, 
the following matrix equations are true:
	
a # (b # C) = (a # b) # C
	
a(b + C) = a # b + a # C
	
(a + b)C = a # C + b # C
	
ra # sb = (rs)(a # b)
Verifying these equations for matrices of particular dimensions is simple, if ­ 
tedious.	
The n × n matrix with 1s along the main diagonal and 0s elsewhere is called the 
identity matrix, denoted by I. If we multiply I times any n × n matrix A, we get 
A as the result. The equation
i # a = a # i = a
holds.

452	
Relations, Functions, and Matrices 
An n × n matrix A is invertible if there exists an n × n matrix B such that
 a # b = b # a = i
In this case B is called the inverse of A, denoted by a−1.
■
Practice 53	 Let
i = c1
0
0
1d       a = ca11
a12
a12
a22
d
Verify that i # a = a # i = a.
	
Example 71	
Let
a = £
−1
  2
−3
    2
  1
  0
    4
−2
  5
§          b = £
−5
    4
−3
10
−7
  6
  8
−6
  5
§
Then, following the rules of matrix multiplication, it can be shown (Practice 54) 
that a # b = b # a = i, so b = a−1.	
	
	
	
	
■
Practice 54	 For the matrices A and B of Example 70,
a.	 Compute a # b.
b.	Compute b # a.
It is easy to write an algorithm for matrix multiplication by simply follow-
ing the definition. A pseudocode version of the algorithm follows, where bracket 
­notation A3i, j4 replaces the subscript notation aij.
	
Algorithm	
MatrixMultiplication
//computes n × p matrix A # B for n × m matrix A, m × p matrix B
//stores result in C
for i = 1 to n do
for j = 1 to p do
C3i, j4 = 0 
for k = 1 to m do
C3i, j4 = C3i, j4 + A3i, k4 * B3k, j4
end for
end for
end for
write out product matrix C

Section 5.7   Matrices	
453
The computational steps done in this algorithm are multiplications and ad-
ditions, one multiplication and one addition each time the statement C3i, j4 5
C3i, j4 + a3i, k4 * b3k, j4 is executed. This statement occurs within a triply nested 
loop and will be executed npm times. (Although this is quite obvious, it can also 
be justified by the multiplication principle as the number of possible outcomes of 
choosing indices i, j, and k.) If A and B are both n × n matrices, then there are 
Θ(n3) multiplications and Θ(n3) additions required. The total amount of work is 
therefore Θ(n3) + Θ(n3) = Θ(n3).
Given the definition of matrix multiplication, it is hard to see how one could 
avoid Θ(n3) steps in computing the product of two n × n matrices, but a suffi-
ciently clever approach does yield an improvement under certain conditions (see 
Exercise 54).
Gaussian Elimination
In Example 63 we encountered the following system of two linear equations in 
two unknowns:
 x +
 y =
 70
 24x + 14y = 1180
The general form for a system of n linear equations in n unknowns is
a11x1 + a12x2 + c+ a1nxn = b1
a21x1 + a22x2 + c+ a2nxn = b2
(
an1x1 + an2x2 + c+  annxn = bn
with a matrix of coefficients
≥
a11
a12
… a1n
a21
a22
… a2n
(
an1
an2
… ann
¥
To solve this system of equations, we first form the augmented n × (n + 1) 
­matrix by adding the column of b’s to the matrix of coefficients:
≥
a11
a12
…
a1n    b1
a21
a22
…
a2n    b2
(
an1
an2
…
ann    bn
¥
(The augmented matrix is simply a convenience to avoid having to write all the 
unknowns.) The next step is to “transform” the augmented matrix into one where 
the matrix-of-coefficients part is an upper triangular matrix, that is, all values 
of this n × n matrix below the main diagonal are 0’s. The result will be a matrix 
of the form

454	
Relations, Functions, and Matrices 
E
c11
c12
…
 
c1n
d1
0
c22
…
c2n
 d1
 
(
 
0
0
…
c(n−1)(n−1)
c(n−1)n
dn−1
0
0
…
0
cnn
 dn
U
Now we can turn this back into a system of equations of the form
E
c11x1
c12x2
…
 
c1nxn
d1
0
c22x2
…
c2nxn
 d1
 
(
 
0
0
…
c(n−1)(n−1)xn−1
c(n−1)nxn
dn−1
0
0
…
0
cnnxn
 dn
U
and solve the equations from the bottom up. We solve
cnnxn = dn
for xn. Knowing the value of xn, we can then solve the next-to-last equation
c(n−1)(n−1)xn−1 + c(n−1)nxn = dn−1
for xn−1 and so forth, back up to the top row.
But how do we do the transformation? The allowable operations to carry out 
this transformation are called elementary row operations, none of which change 
the solution set of the underlying equations. These operations (performed on the 
augmented matrix) are
	
i.	 Switch any two rows of the matrix.
	
ii.	 Multiply all the elements in any one row of the matrix by a non-zero 
­scalar.
	
iii.	 Add a scalar multiple of any one row to another row.
This process for solving systems of linear equations is known as Gaussian 
elimination, named for the famous German mathematician Karl Friedrich Gauss. 
Gauss did not actually invent this process, however; it was demonstrated in a Chi-
nese mathematics treatise of the second century ad, and it was probably known in 
China even earlier.
	
Example 72	
Solving the system of equations
 x +
 y =
 70
 24x + 14y = 1180
using Gaussian elimination, we first form the augmented matrix
c  1
  1
    70
24
14
1180d

Section 5.7   Matrices	
455
	
We multiply row 1 by the scalar −24 and add the result to row 2 (the third elemen-
tary row operation), giving
c1
1
70
0
−10
−500d
The last row represents the equation
−10 y = −500
from which y = 50. The first row represents the equation
x + y = 70
and, because y = 50, this is
x + 50 = 70
so x = 20. The solution, as noted in Example 63, is x = 20, y = 50.	
	
Example 73	
Let’s apply Gaussian elimination to the system of 3 equations in 3 unknowns 
shown here:
	
2x −3y + z = −22
	
7x + 9y −3z = 14
	
6x + 7y + 2z = 91
The augmented matrix is
£
2
−3
1
−22
7
9
−3
14
6
7
2
91
§
A series of elementary row operations, as shown here, will convert the 3 × 3 
­matrix of coefficients to upper triangular form. First, multiply row 1 by 1∙2 to 
produce a 1 in the 1,1 position.
1∙2£
2
−3
 1
−22
7
  9
−3
 14
6
  7
 2
 91
§
Then multiply row 1 by −7 and add it to row 2; also multiply row 1 by −6 and 
add it to row 3.
	
£
1
−3∙2
1∙2
−11
7
   9
−3
   14
6
   7
  2
   91
§ 	
giving	
£
1
−3∙2
    1∙2
−11
39∙2
−13∙2
    91
  16
    −1
157
§
   −7
−6

456	
Relations, Functions, and Matrices 
Now multiply row 2 by 2/39 to produce a 1 in the 2,2 position.
2∙39£
1
−3∙2
    1∙2
−11
39∙2
−13∙2
  91
  16
    −1
157
§
Multiply row 2 by −16 and add it to row 3.
−16       £
1
−3∙2
   1∙2
−11
     1
−1∙3
14∙3
   16
   −1
 157
§
resulting in
£
1
−3∙2
   1∙2
−11
     1
−1∙3
14∙3
13∙3
247∙3
§
We are almost done. The bottom row represents the equation
(13∙3)z = 247∙3
from which z = 19. The second row represents the equation
y −(1∙3)z = 14∙3    or    y −(1∙3)(19) = 14∙3
from which y = 11. Finally, from the top row,
	
x −(3∙2)y + (1∙2)z = −11	
or	
x −(3∙2)(11) + (1∙2)19 = −11
and x = −4. So the solution to this system of equations is x = −4, y = 11, 
z = 19.	
■
Practice 55	 Solve the following system of equations using Gaussian elimination.
3x −5y =  5
7x +  y = 37
Not every system of n linear equations in n unknowns has a solution. As a 
simple case, consider
2x + 4y = 10
4x + 8y = 12

Section 5.7   Matrices	
457
If we assume that there is a solution and proceed with Gaussian elimination, we 
perform the following elementary row operations:
	
1∙2
  c2
4
10
4
8
12d 	
giving	
c1
2
 5
4
8
12d
Then
	
c1
2
5
4
8
12d 	
results in	
c1
2
5
0
−8d
in which row 2 says that 0 = −8. This contradiction says that our assumption 
about the existence of a solution is incorrect. Rewriting the two equations as
y = (−1∙2)x + 5∙2
y = (−1∙2)x + 3∙2
shows that these are two parallel lines that never intersect, so there is no (x, y) pair 
that satisfies both equations.
More generally, systems of linear equations can involve m equations in n un-
knowns where n and m are not necessarily equal. Usually, if there are more equa-
tions than unknowns, the system is overconstrained and there will be no solution. 
And usually, if there are more unknowns than equations, there will be an infinite 
number of solutions.
	
Example 74	
Consider the system of equations
3x −
 y −5z =
 9
 x + 2y −4z = 10
In the augmented matrix, switch rows 1 and 2, then multiply row 1 by −3 and add 
it to row 2:
	
c1
2
−4
10
3
−1
−5
9d 	
giving	
c1
2
−4
10
−7
7
−21d
The last row represents the equation −7y + 7z = −21 or y = z + 3. Substituting 
into equation 1, we get
	
x + 2(z + 3) −4z = 10	
or	
x = 2z + 4
Both x and y have values in terms of a parameter z, which can have any value. The 
number of solutions is therefore infinite.	
Despite the simple examples we have seen, neither the solutions to a system of 
linear equations nor the coefficients are always integers.
−4 
−3 

458	
Relations, Functions, and Matrices 
Boolean Matrices
In Chapter 6 we will be interested in matrices with only 0s and 1s as entries, 
called Boolean matrices (after George Boole, a nineteenth-century English math-
ematician; Boole also lent his name to Boolean algebra, which we will consider 
later in this book). Matrix R of Example 62 is a Boolean matrix. We can define 
an o­peration of Boolean matrix multiplication a × b on Boolean matrices using 
Boolean multiplication and Boolean addition instead of regular multiplication and 
addition. These are defined as follows:
Boolean multiplication: x ` y = min(x, y)
Boolean addition: x ~ y = max(x, y)
Practice 56	 Fill-in the following operation tables for Boolean multiplication and Boolean addition.
	
x
y
x ` y
1
1
1
0
0
1
0
0
	
x
y
x ~ y
1
1
1
0
0
1
0
0
■
	
Example 75	
Let A and B be Boolean matrices,
a = £
1
1
0
0
1
0
0
0
1
§       b = £
1
0
0
1
1
1
0
0
1
§
Now take the tables from Practice 56 and substitute T for 1 and F for 0. They 
become the truth tables for conjunction and disjunction, respectively; for this rea-
son, these operations are often called Boolean and (or logical and) and Boolean 
or (or logical or), which also explains the notation used for these operations. The 
operation of Boolean matrix multiplication a × b (on Boolean matrices of ap-
propriate dimensions) is then defined by
cij = ~
m
k=1
(aik ` bkj)
We can also define two analogues of ordinary matrix addition (on Boolean 
matrices of the same dimensions): A ` B, where corresponding elements are 
combined using Boolean multiplication, and A ~ B, where corresponding ele-
ments are combined using Boolean addition.

Section 5.7   Matrices	
459
Then
a ` b = £
1
0
0
0
1
0
0
0
1
§   a ~ b = £
1
1
0
1
1
1
0
0
1
§
and the Boolean product a × b is
a × b = £
1
1
1
1
1
1
0
0
1
§
■
Practice 57	 In Example 75, does a × b = a # b?
■
Practice 58	 In Example 75, compute b × a.

460	
Relations, Functions, and Matrices 
Special Interest Page
Solve Millions of Equations, Faster than Gauss
Systems of linear equations are used in many areas of 
application, including telecommunications, materials 
analysis, transportation, economics, and medical im-
aging. Instead of systems of 3 or 4 linear equations 
with 3 or 4 unknowns, such as we saw in our Example 
problems, the value of n in such applications can go 
into the millions or billions. In Exercise 55 of Section 
5.7, we see that a worst-case analysis of Gaussian elim-
ination results in Θ(n3) computations (multiplications 
and additions). Such computations on real numbers are 
called floating point operations. The overall implica-
tion of an algorithm of Θ(n3) is that increasing the size 
of n by a factor of 10 increases the work by a factor of 
103 = 1000.
If n has a value of 1 billion, n = 109, then n3 = 1027. 
Suppose we find a way to parallelize the Gaussian 
elimination algorithm and run it on a fast parallel-
processing supercomputer. The Chinese Tianhe-2, 
the world’s fastest supercomputer as of June 2013 can 
crank out about 33.86 petaflops (33.86 × 1015 floating-
point operations per second). The worst-case solution 
would be bounded above by
1027 operations
(33.86) * 1015 operations∙second = over 936 years!
Now Θ(n3) was an upper bound, so maybe the closer 
value is something like (2∙3)Θ(n3), but at any rate it’s 
clear that these are time-consuming problems, and 
faster solution techniques are of interest. 
Gaussian elimination produces exact solutions to 
systems of linear equations. Other solution methods, 
called iterative solvers, produce a series of approxi-
mate solutions that approach the exact solution. This 
method sounds as if it would take even longer, but most 
iterative solvers start out with a sparse matrix (a matrix 
with many 0 entries) for which computations will be 
faster but is nonetheless a good representative of the 
information in the original augmented matrix. Decid-
ing which values can be zeroed out while modifying 
the values of the remaining coefficients so as to pro-
vide a good “preconditioner” for the eventual solution 
is a difficult problem in itself.
A team of researchers at Carnegie Mellon Univer-
sity announced in 2010 that they had found a new al-
gorithm for creating a good preconditioner for a large 
system of linear equations of a certain type, called 
SDD (symmetric and diagonally dominant) systems. 
In a diagonally dominant matrix, the absolute value 
of the diagonal element (aii) of each row of a matrix 
is bigger than the sum of the absolute values of all 
other elements in that row. SDD systems turn out to 
have many important applications, such as maximiz-
ing flow through a network (a computer network, a 
water pipeline system, a transportation system) and 
recommendation systems such as Netflix that suggest 
movies you might like based on your past preferences 
and other user data. The new algorithm, based on so-
phisticated mathematical techniques, is approximately 
Θ(n(log n)2)), nearly linear, promising much faster so-
lutions to these massive problems.
“A Breakthrough in Algorithm Design,” Kroeker, K., Com-
munications of the ACM, September 2011.
“A Fast Solver for a Class of Linear Systems,” Koutis, I., 
Miller, G. L., and Peng, R., Communications of the 
ACM, October 2012.
“Approaching Optimality for Solving SDD Linear Sys-
tems,” Koutis, I., Miller, G. L., and Peng, R., Proceed-
ings of the 2010 IEEE 51st Annual Symposium on 
Foundations of Computer Science, Las Vegas, NV, 
October 23–26, 2010.
Linear Equation Breakthrough, Dr. Dobbs, http://drdobbs. 
com/architecture-and-design/227900457
Chapter 5

Section 5.7   Matrices	
461
S e c t i o n  5 . 7 	
Review
Techniques
•	 Add, subtract, multiply, and perform scalar multi-
plication on matrices.
•	 Solve systems of linear equations using Gaussian 
elimination.
•	 Perform Boolean and, or, and matrix multiplication 
on Boolean matrices.
Main Ideas
•	 Matrices are rectangular arrangements of data that 
are used to represent information in tabular form. 
•	 Matrices have their own arithmetic, with opera-
tions of addition, subtraction, multiplication, and 
scalar multiplication. 
•	 Systems of linear equations can be solved by per-
forming elementary row operations on an augment-
ed matrix (Gaussian elimination). 
•	 Boolean matrices can be manipulated using ­Boolean 
operations of and, or, and Boolean ­multiplication.
Exercises 5.7
	 1.	 For the matrix:
a = £
  1
2
  3
0
−4
1
§
	
	 What is a12? What is a31?
	 2.	 Find x and y if
c1
3
x
x + yd = c1
3
2
6d
	 3.	 Find x, y, z, and w if
cx + y
2x − 3y
z − w
  z + 2wd = c
    4
−7
−6
    6d
	 4.	 If A is a symmetric matrix, find u, v, and w:
a = £
2
 w
u
7
 0
v
1
−3
4
§
For Exercises 5–7, assume the following:
	
	 r = 3, s = −2,
a = £
  2
1
−1
0
  3
4
§         b = £
4
  1
2
6
−1
5
1
  3
2
§   C = c2
  4
6
−1d         D = £
4
−6
1
3
2
−1
§
	 5.	 Compute (if possible)
	
a.	 a + D      b.  a −D      c.  rB      d.  sC      e.  a + rD
W
W

462	
Relations, Functions, and Matrices 
	 6.	 Compute (if possible)
	
a.	 b −rC	
c.	 r(sC)	
e.	 D # C
	
b.	 r(a + D)	
d.	 b # a + D
	 7.	 Compute (if possible)
	
a.	 a # C	
c.	 b # D
	
b.	 C # a	
d.	 C2 = C # C
	 8.	 For
a = £
2
4
0
1
3
−1
3
−2
1
§
	
	 compute A3 = A # a # a.
	 9.	 For
a = c3
−1
2
  5d
b = c4
  1
2
−1d
C = c6
−5
2
−2d
	
	 compute (if possible)
	
a.	 a # b and b # a
	
b.	 a # (b # C) and (a # b) # C
	
c.	 a # (b + C) and a # b + a # C
	
d.	 (a + b) # C and a # C + b # C
	 10.	If
a = c2
3
4
1d     b = cx
3
y
2d
	
	 find x and y if a # b = b # a.
	 11.	Prove that matrix multiplication is associative; that is, prove that if A is an n × p matrix, B is a p × r 
matrix and C is an r × m matrix, then a # (b # C) = (a # b) # C.
	 12.	a.	 Prove that i2 = i for any identity matrix I.
	
b.	Prove that in = i for any identity matrix I and any positive integer n.
	 13.	Let A and B be n × n matrices. 
	
a.	 Prove that if A has one row consisting of all 0’s, then so does a # b.
	
b.	Prove that if B has one column consisting of all 0’s, then so does a # b.

Section 5.7   Matrices	
463
	 14.	An n × n matrix A is diagonal if all elements aij with i ∙j are 0. For example, A below is a 3 × 3 diago-
nal matrix.
a = £
2
0
  0
0
5
  0
0
0
−7
§
	
a.	 Prove that if A and B are n × n diagonal matrices, then a + b is diagonal.
	
b.	Prove that if A is an n × n diagonal matrix and r is a scalar, then rA is diagonal.
	
c	 Prove that if A and B are n × n diagonal matrices, then a # b is diagonal.
	 15.	The transpose of a matrix A, aT, is obtained by interchanging its rows and columns. Thus, if we denote 
the element in row i, column j of A by a(i, j), then aT(i, j) = a( j, i).
	
a.	 Find aT for
a = c1
  3
4
6
−2
1d
	
b.	Prove that if A is a square matrix, then A is symmetric if and only if aT = a.
	
c.	 Prove that (aT)T = a.
	
d.	Prove that (a + b)T = aT + bT.
	
e.	 Prove that (a # b)T = bT # aT.
	 16.	Prove that a # aT is symmetric for any matrix A (see Exercise 15).
	 17.	Find two 2 × 2 matrices A and B such that a # b = 0 but a ∙0 and b ∙0.
	 18.	Find three 2 × 2 matrices A, B, and C such that a # C = b # C, C ∙0, but a ∙b.
	 19.	If A and B are n × n matrices, is it always true that (a + b)2 = a2 +  2(a # b) + b2? Will it ever be 
true?
	 20.	The vector of real numbers U = 3u1  u24 can be visualized on the real-number plane as an arrow from 
the origin to the point (u1, u2). The length of the arrow, also called the magnitude of the vector, is given 
by 0 0U 0 0  = "u2
1 + u2
2. The dot product of two such vectors, U • v, is defined to be the real number 
u1v1 + u2v2. Show that if u is the angle between U and v, 0 ≤u ≤p, then
cos u =
U • v
0 0U 0 0 # 0 0v 0 0
	
	 (Hint: Use the law of cosines.)
	 21.	Prove that if a square matrix A is symmetric, then so is a2, where a2 = a # a.
	 22.	Prove that if a square matrix A is symmetric, then so is a2nfor any integer n ≥1.

464	
Relations, Functions, and Matrices 
	 23.	Let
a = c1
1
1
0d
	
	 For n ≥1, let F(n) equal the nth value in the Fibonacci sequence (see Example 2 in Chapter 3); let 
F(0) = 0. Prove that for any n ≥1, an is given by
cF(n + 1)
  F(n)
F(n)
F(n −1)d
	 24.	a. 	Show that for
a = c1
3
2
2d       b = c−1∙2
  3∙4
  1∙2
−1∙4 d
a # b = b # a = i, so b = a−1.
	
b.	Show that
a = c1
2
2
4d
	
	
is not invertible. 
	
c.	 Show that
a = ca11
a12
a21
a22
d
	
	
is invertible with inverse
b =
1
a11a22 −a12a21 c
  a22
−a12
−a21
  a11
d
	
	
if and only if a11a22 −a12a21 ∙0.
	 25.	Prove that if A is invertible and r is a non-zero scalar, then rA is invertible with
(ra)−1 = (1∙r)a−1.
	 26.	Prove that if A is invertible and a # b = a # C, then b = C.
For Exercises 27–34, use Gaussian elimination to solve the systems of equations, if possible.
	 27.	  x +  5y =
 1
	
	  2x − 3y =  15
	 28.	  x +  5y =  38.7
	
	  4x − 2y =  −1.4

Section 5.7   Matrices	
465
	 29.	 −x +  2y +
 z =  −1
	
	
 3x − 5y −
 z =
 5
	
	
 2x −
 y +  3z =  22
	 30.	  x −
 y +
 z =
 6
	
	
 x +  2y − 3z =  10
	
	  2x +  3y +  5z =  12
	 31.	  x +  2y −
 z =  −1
	
	
 x − 3y +
 z =
 2
	
	  2x +
 y +  2z =
 6
	 32.	 2x − 7y +
 z +  2w =
 5
	
	
 x +
 y − 2z +  3w =
 8
	
	  4x +  2y +
 z − 4w =  12
	
	  5x +  3y −
 z −
 w =  10
	 33.	
 x +  2y −
 z +
 w =
 −3
	
	
 2x −
 y +  4z +  2w =
 33
	
	
 x −
 y +  3z − 7w =
 6
	
	  −3x +  3y +
 z +  4w =  −12
	 34.	  x − 2y +
 3z −
 w =
 7
	
	  2x +  5y −
 7z +  2w =  12
	
	  4x − 3y +  12z +
 w =
 8
	 35.	Find an example of a system of 3 linear equations with 2 unknowns that has a solution. Explain what hap-
pens when you use Gaussian elimination on this system.
	 36.	Find an example of a system of 4 linear equations with 3 unknowns that has a solution. Explain what hap-
pens when you use Gaussian elimination on this system.
	 37.	You purchase an ancient Egyptian medallion at the State Fair from a vendor who swears it is pure gold. 
The medallion weighs 859.4 grams and its volume in cubic centimeters is 52. You suspect that the medal-
lion is actually a mixture of copper and gold. You know that copper weighs 9 grams per cubic centimeter 
and that gold weighs 19.3 grams per cubic centimeter. Set up and solve a system of equations to find the 
percentage of copper by volume in the medallion.
	 38.	Cell phone Plan A charges a flat monthly fee of $30.00 for the first 400 minutes, plus $0.07 for each 
minute > 400. Plan B charges a flat monthly fee of $45.00 for the first 600 minutes, plus $0.19 for each 
minute > 600. You know you will use more than 600 minutes per month.
	
a.	 At what number of minutes do the plans cost the same amount per month, and what is that amount?
	
b.	Above this number of minutes, which plan is more expensive?
	 39.	If A is an n × n invertible matrix, the following method can be used to find a−1.
	
1.	Operate on A using any combination of the two following elementary row operations until the resulting 
matrix is the n × n identity matrix I.
	
i.	 Multiply all the elements in any one row of A by a non-zero scalar.
	
ii.	 Add a scalar multiple of any row to any other row.
	
2.	At the same time, perform exactly the same sequence of operations on the n × n identity matrix I.
	
3.	The matrix that results from I after step 2 is a−1.
	
	 Use this method to find the inverse of matrix A in Exercise 24(a).

466	
Relations, Functions, and Matrices 
	 40.	Use the method of Exercise 39 to find the inverse of matrix A in Example 71.
	 41.	Consider a system of n linear equations in n unknowns, such as the one from Example 63:
 x +
 y =
 70
 24x + 14y = 1180
	
	 If
	
a = c 1
1
24
14d 	
X = cx
yd 	
b = c
70
1180d
	
	 then the system of equations can be represented in matrix form by
a # X = b
	
	 If A, the matrix of coefficients, is invertible, then we can multiply both sides of the above equation by 
a−1, giving
	
a−1 # (a # X) = a−1 # b
	
(a−1 # a) # X = a−1 # b	
(matrix multiplication is associative)
	
i # X = a−1 # b	
(definition of a−1)
	
X = a−1 # b	
(definition of I)
	
Therefore the solution to the system of equations is given by
X = a−1 # b
	
	 Make use of Exercise 39 to find a−1, and use this approach to solve the system of equations.
In Exercises 42–46, solve the systems of equations using the method of Exercise 41. 
	 42.	 x +  2y =  −4
	
	  x +
 y =
 5
	 43.	The system of Exercise 27
	 44.	The system of Exercise 28
	 45.	The system of Exercise 29
	 46.	The system of Exercise 30
	 47.	For Boolean matrices
a = £
1
0
0
1
1
0
0
1
1
§          b = £
1
0
1
0
1
1
1
1
1
§
	
	 find a ` b, a ~ b, a × b, and b × a.

Section 5.7   Matrices	
467
	 48.	For Boolean matrices
a = £
0
0
1
1
1
0
1
0
0
§          b = £
0
1
1
0
0
0
1
0
0
§
	
	 find a ` b, a ~ b, a × b, and b × a.
	 49.	For Boolean matrices
a = £
0
1
0
1
0
1
0
0
1
§           b = £
0
1
1
0
0
1
1
0
0
§
	
	 find a ` b, a ~ b, a × b, and b × a.
	 50.	For Boolean matrices
a = £
1
1
0
0
1
1
0
0
1
§         b = £
1
0
1
0
1
1
1
1
1
§
	
	 find a ` b, a ~ b, a × b, and b × a.
	 51.	For Boolean matrices A and B, can it ever be the case that a ~ b = a ` b? If so, when?
	 52.	For Boolean matrices A and B, prove that a ~ b = b ~ a and that a ` b = b ` a.
	 53.	How many distinct symmetric n × n Boolean matrices are there?
	 54.	Strassen’s algorithm reduces the amount of work to compute the product of two n × n matrices of suffi-
cient size. For simplicity, assume that n = 2m for some m ≥0. First consider a simple case of multiplying 
two 2 × 2 matrices.
a = ca11
a12
a21
a22
d          b = cb11
b12
b21
b22
d
	
	 The product
	
C = ca11b11 + a12b21
a11b12 + a12b22
a21b11 + a22b21
a21b12 + a22b22
d             	
(1)
	
	 can also be written (check the calculations) as
	
C = cp1 + p4 −p5 + p7
p3 + p5
p2 + p4
p1 + p3 −p2 + p6
d                	
(2)
	
	 where
	
 p1 = (a11 + a22)(b11 + b22)           p2 = (a21 + a22)b11
	
 p3 = a11(b12 −b22)                         p4 = a22(b21 −b11)
	
 p5 = (a11 + a12)b22                         p6 = (a21 −a11)(b11 + b12)
	
 p7 = (a12 −a22)(b21 + b22) 
 

468	
Relations, Functions, and Matrices 
	
	 Computing the various pi quantities requires 7 multiplications and 10 additions (counting subtractions as 
additions). Computing the product C once the pi quantities exist takes 0 multiplications and an additional 
8 additions. In total, computing C by this method requires 7 multiplications and 18 additions. Now take 
two n × n matrices A and B and partition each of them into four (n∙2 × n∙2) matrices:
a = ca11
a12
a21
a22
d          b = cb11
b12
b21
b22
d
	
	 The product C = a #  b is still given by Equation (1) using aij and bij instead of aij and bij, respectively. 
Therefore Equation (2) still holds, and the product C requires 7 (n∙2 × n∙2) matrix multiplications. This 
is an example of a divide and conquer algorithm, where the work has been reduced to several instances 
of the same problem on a significantly reduced input size (although there is an additional overhead of 18 
(n∙2 × n∙2) matrix additions).
Let M(n) represent the number of multiplications required for a product of two n × n matrices. Using 
Strassen’s algorithm, we can write
	
M(1) = 1	 	
(one multiplication in the product of two 1 × 1 matrices)
	
M(n) = 7M an
2b	
 
	
a.	 Solve this recurrence relation for M(n).
	
b.	If A(n) represents the number of additions required for a product of two n × n matrices, justify the 
following recurrence relation:
	
A(1) = 0
	
A(n) = 7Aan
2b + 18an
2b
2
	
c.	 Solve this recurrence relation to obtain an order-of-magnitude expression for A(n).
	
d.	Find an approximate order-of-magnitude value for the total work (additions and multiplications) for 
matrix multiplication using Strassen’s algorithm, and compare it with the Θ(n3) work (additions and 
multiplications) for traditional matrix multiplication. (Although Strassen’s algorithm is theoretically an 
improvement for all values of n, the constants that are ignored in an order-of-magnitude argument mean 
that in actual implementation the traditional algorithm may run faster for values of n less than about 
26 = 64).
	 55.	The Gaussian elimination algorithm is labor-intensive. A worst-case analysis can be done simply by count-
ing, where multiplications and additions are the units of work (divisions are counted as multiplications 
and subtractions are counted as additions). Consider a system of n linear equations in n unknowns.
	
a.	 In the worst-case, the first non-zero element of each row of the augmented matrix as it is being trans-
formed into upper triangular form is not 1 and that row must be multiplied by a non-zero scalar to create 
a 1. Show that this requires a total of
(n + 1)(n + 2)
2
−3
	
	
multiplications. (Hint: Consider Practice 7 in Chapter 2.)
	
b.	Aside from the multiplications required in part (a), show that 2n3 + 3n2 −5n
6
 multiplications and 
2n3 + 3n2 −5n
6
 additions are required to transform the augmented matrix into upper triangular form. 
(Hint: Consider Exercise 11 in Section 2.2.)

Section 5.7   Matrices	
469
	
c.	 After the matrix has been reduced to upper triangular form, show that there are n(n + 1)
2
­ multiplica-
tions and (n −1)n
2
 additions to solve for the n unknowns. 
	
d.	Explain why Gaussian elimination is Θ(n3) in the worst case. 
	 56.	DES, discussed in Section 5.6, is an encryption algorithm that is an example of a block cipher, where a 
block of bits is encoded into a block of bits. Matrices can be used to create a simple block cipher. Consider 
a 2 × 2 matrix with integer entries, for example,
a = c2
7
1
4d
	
	 A is an invertible matrix with
a−1 = c
  4
−7
−1
  2d
	
	 because
c2
7
1
4d # c
    4
−7
−1
  2d = c
    4
−7
−1
   2d # c2
7
1
4d = c1
0
0
1d
	
	 Break up the message to be encrypted into blocks of two characters, and apply a function mapping the 
letters of the alphabet into the integers 0–25 as follows:
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
	
	 Thus 3B   R4 S 31   174. The heart of the encryption algorithm consists of multiplying the resulting 1 × 2 
matrix by A using arithmetic modulo 26. Thus
31
174 # c2
7
1
4d = 319
754 S 319
234
	
	 and 319   234 S 3T   X4. Therefore 3B   R4 is encrypted as 3T   X4. To decrypt, convert 3T   X4 back to 
319   234 and multiply the resulting 1 × 2 matrix by a−1, again using modulo 26 arithmetic.
319
234 # c
    4
−7
−1
   2d = 353
−874 S 31
174
	
	 to be converted back to the original message 3B   R4.
	
a.	 Using the encryption matrix A above, encrypt the block [V   I].
	
b.	Decrypt the result from part (a) to recover [V   I].
	
c.	 Explain why the decoding process recovers the original (numerical) block.

470	
Relations, Functions, and Matrices 
C h a p t e r  5 	
Review
Terminology
ABA routing number (p. 437)
add to a database (p. 375)
addition modulo n (p. 343, p. 438)
addition of matrices (p. 449)
AES (Advanced Encryption 
Standard) (p. 431)
antisymmetric relation (p. 332)
array (p. 448)
asymmetric encryption (p. 431)
augmented matrix (p. 453)
big oh (p. 417)
big theta (p. 413)
bijection (p. 390)
binary relation from S to T (p. 330)
binary relation on a set S (p. 329)
binary relation on S × T  (p. 330)
blind key (p. 368)
block (p. 339)
block cipher (p. 429)
Boolean and (logical and) (p. 458)
Boolean matrix (p. 458)
Boolean matrix multiplication  
(A × B) (p. 458)
Boolean or (logical or) (p. 458)
Caesar cipher (p. 428)
Cantor’s theorem (p. 401)
cardinality of a relation (p. 366)
cardinality of a set (p. 401)
ceiling function (p. 386)
chain (p. 338)
chaining (p. 426)
ciphertext (p. 428)
circular left shift (p. 430)
closure of a relation (p. 334)
codomain (p. 383)
collision (p. 425)
commutative diagram (p. 391)
composition function (p. 391)
composite primary key (p. 367)
conceptual model (p. 365)
congruence modulo 4 (p. 343)
congruence modulo n (p. 343)
critical path (p. 359)
cryptographic hash function  
(p. 434)
cryptography (p. 428)
cryptology (p. 428)
data integrity (p. 375)
database (p. 365)
degree of relation (p. 366)
delete from a database (p. 375)
derangement (p. 396)
DES (Data Encryption Standard) 
(p. 429)
diffusion (p. 429)
dimensions of a matrix (p. 446)
disjoint cycles (p. 395)
domain (p. 383)
elementary row operations (p. 454)
entities (p. 365)
entity integrity (pp. 367, 375)
entity-relationship diagram (E-R 
diagram) (p. 365)
entity-relationship model (p. 365) 
equal functions (p. 387)
equal matrices (p. 447)
equivalence class (p. 339)
equivalence relation (p. 339)
equivalent sets (p. 401)
floor function (p. 386)
foreign key (p. 368)
function (p. 383)
Gaussian elimination (p. 454)
greatest element (p. 338)
hash function (p. 424)
hash table (p. 425)
Hasse diagram (p. 336)
identity function (p. 392)
identity matrix (p. 451)
identity permutation (p. 396)
image (p. 383)
immediate predecessor in a partial 
ordering (p. 336)
intractable problem (p. 417)
inverse function (p. 393)
inverse of a matrix (p. 452)
invertible matrix (p. 452)
International Standard Book 
Number (ISBN) (p. 435)
join (p. 370)
least element (p. 338)
linear equation (p. 447)
linear probing (p. 425)
little oh (p. 417)
load factor (p. 427)
main diagonal (p. 447)
many-to-many relation (p. 330)
many-to-one relation (p. 330)
mapping (p. 383)
master theorem (p. 418)
matrix (p. 446)
matrix of coefficients (p. 447)
maximal element (p. 338)
metadata (p. 366) 
minimal element (p. 338)
modify a database (p. 375)
modulo function (p. 386)
multiplication of matrices (p. 450)
n-ary relation on 
S1 × S2 × c× Sn (p. 330)
node (p. 337)
one-to-many relation (p. 330)
one-to-one (injective) function  
(p. 389)
one-to-one relation (p. 330)
one-way encryption (p. 434)
onto (surjective) function (p. 388)
order of magnitude (p. 413)
partial ordering (p. 336)
partially ordered set (poset) 
(p. 336)
partition (p. 339)
permutation function (p. 394)
PERT chart (p. 357)
plaintext (p. 428)
poset (p. 336)
predecessor in a partial ordering 
(p. 336)
preimage (p. 383)
primary key (p. 367)
private key encryption (p. 431)
project (p. 369)
public key encryption (p. 431)
range (p. 388)
referential integrity (p. 375)
reflexive closure (p. 334)
reflexive relation (p. 332)
relational algebra (p. 372)

Chapter 5   Review	
471
relational calculus (p. 372)
relational database (p. 366)
relational model (p. 366)
residue of x modulo n (p. 423)
restrict (p. 369)
restriction of a partial ordering  
(p. 336)
RSA public key encryption 
algorithm (p. 431)
scalar (p. 448)
scalar multiplication (p. 448)
SELECT (p. 372)
simple substitution cipher (p. 429)
SQL (p. 372)
subtraction of matrices (p. 449)
successor in a partial ordering  
(p. 336)
surrogate key (p. 368)
symmetric closure (p. 334)
symmetric encryption (p. 431)
symmetric matrix (p. 447)
symmetric relation (p. 332)
topological sorting (p. 359)
total ordering (p. 338)
transitive closure (p. 334)
transitive relation (p. 332)
tuple (p. 366)
UPC-A (Universal Product Code) 
(p. 436)
upper triangular matrix (p. 453)
vector (p. 448)
vertex (p. 337)
zero matrix (p. 449)
Self-Test 
Answer the following true-false questions.
Section 5.1
1.	In a one-to-many binary relation, at least one first 
component must appear in two different ordered 
pairs.
2.	If an antisymmetric binary relation contains (x, y), 
then (y, x) will not belong to the relation.
3.	A least element of a partially ordered set precedes 
all elements except itself.
4.	An equivalence relation cannot also be a partial 
­ordering.
5.	A partial ordering on a set determines a partition of 
that set.
Section 5.2
1.	If a task is not on the critical path in a PERT chart, 
then that task is optional.
2.	A topological sort turns a partially ordered set into 
a totally ordered set.
3.	If x precedes y after a topological sort on a finite 
partially ordered set, then x preceded y in the origi-
nal partial ordering.
4. 	The times to complete parallel tasks are added to-
gether in determining a critical path in a PERT chart.
5.	A given set of data results in a unique topological 
sort.
Section 5.3
1.	A relation in a relational database is a set of n tuples 
of attribute values.
2.	A primary key in a relation is a minimum subset of 
attribute values that will uniquely identify each tuple.
3.	The restrict operation can be achieved by doing a 
union followed by an intersection.
4.	The join operation can be achieved by doing a 
­Cartesian product followed by a restrict.
5.	Deleting a tuple from a relation may result in addi-
tional deletions being done in order to satisfy data 
integrity.
Section 5.4
1.	A binary relation on S × T that is not one-to-many 
or many-to-many is a function from S to T.
2.	To prove that a function is onto, begin with an ar-
bitrary element of the range and show that it has a 
preimage.
3.	To prove that a function is one-to-one, assume 
f (s1) = f (s2) for some s1 and s2 in the domain and 
show that s1 = s2.
4. The composition of two permutation functions on a 
set is a permutation function on the set.
5. Any one-to-one function has an inverse function.
Section 5.5
1.	If f is Θ(g), then beyond some point the values for 
f(x) must fall between 1
2 g(x) and 2g(x).
2.	If f = O(g), then either f = Θ(g) or g = o( f ).
3.	If f(x) = 3x2 + 15x −2 and g(x) = 5000x3∙
(x −1) then f = Θ(g).
4.	An intractable problem is one that only has solution 
algorithms of the form Θ(nc) where c ≥5.
5.	In a recurrence relation of the form
S(n) = aS an
bb + nc    for n ≥2
	
	the order of magnitude of the solution, as deter-
mined by the master theorem, depends on the ratio 
of a to bc.

472	
Relations, Functions, and Matrices 
Section 5.6
1.	 37 ≡15 (mod 11)
2.	When searching a hash table for a particular target 
value, first apply the hash function to the value to 
obtain the hash table index, then examine the table 
entry at that index. If the table entry stored there 
matches the target value, the search was successful; 
if not, the search fails.
3.	A Caesar cipher with a shift k = 5 will encode “W” 
as “B.” 
4.	In the RSA algorithm, the public key is (n, e). Se-
curity derives from the difficulty of computing 
w(n).
5.	The check digit in the ISBN-10 0-321-18059-3 is 
correct.
Section 5.7
1.	Two matrices that do not have the same dimensions 
cannot be added.
2. 	If A and B are square matrices, then a # b = b # a.
3.	The usual algorithm for matrix multiplication is 
Θ(n3).
4.	The process of Gaussian elimination reduces the 
augmented matrix of a system of n linear equations 
in n unknowns to the n × n identity matrix.
5.	If A and B are square Boolean matrices, then 
a × b = b × a, where a × b denotes the Bool-
ean product.
O n  t h e  C o m p u t e r
For Exercises 1–17, write a computer program that 
produces the desired output from the given input. 
1.	Input: The elements in a finite set S and a list of 
ordered pairs representing a binary relation on S	 
Output: Statement indicating whether the relation 
is one-to-one, one-to-many, many-to-one, or many-
to-many
2.	Input: The elements in a finite set S and two lists of 
ordered pairs representing two binary relations on S
Output: The ordered pairs in the union and in the 
intersection of the two relations, and the ordered 
pairs in the complements of each relation
3.	Input: The elements in a finite set S and a list of 
ordered pairs representing a binary relation on S	 
Output: Statement of which properties—reflexive, 
symmetric, transitive, and/or antisymmetric—the 
relation has
4.	Input: The elements in a finite set S and a list of 
ordered pairs representing a binary relation on S	 
Output: Reflexive, symmetric, and transitive clo-
sures of the relation
5.	Input: The elements in a finite set S and a list of or-
dered pairs representing a partial ordering on S	  
Output: A list of all minimal and maximal ­elements
  6. Input: The elements in a finite set S and a list of 
ordered pairs representing a partial ordering on S
Output: A list of any least or greatest elements. 
Note that this task is more difficult than that in Ex-
ercise 5. 
  7. Input: The elements in a finite set S, a list of or-
dered pairs representing an equivalence relation 
on S, and an element x of S
Output: The members of [x]
  8. Input: Array representations of relation tables and 
appropriate input data for restrict, project, and join 
operations
Output: Array representations of the resulting rela-
tion tables
  9. Input: The elements in a finite set S and a list of 
ordered pairs representing a partial ordering on S
Output: Sequence representing the total ordering 
that results from doing a topological sort (Hint: 
Reuse some of your code from Exercise 5.)
10. Input: The elements in a finite set S and in a finite 
set T, and a list of ordered pairs representing a bi-
nary relation on S × T
Output: An indication of whether the relation is a 
function from S to T and if so, whether it is onto or 
one-to-one or both

Chapter 5   Review	
473
11. Input: The number of elements in two finite sets 
S and T
Output: The number of functions from S to T, the 
number of one-to-one functions from S to T (or 
an indication that none exist), and the number of 
onto functions from S to T (or an indication that 
none exist)
12. Input: Two lists of ordered pairs representing func-
tions f and g from S to S
Output: List of ordered pairs representing the com-
position function g + f
13. Input: The elements in a finite set S and two lists 
that represent (in cycle form) permutations f and 
g on S
Output: One or more lists that represent the com-
position function g + f in cycle or product-of-cycle 
form
14. Input: The number of elements in a finite set S
Output: The number of derangements on S
15. Input: n and the entries in two n × n matrices A 
and B
Output: Sum a + b and products a # b and b # a
16. Input: Dimensions of a matrix A and the entries 
in A
Output: aT (see Exercise 15 in Section 5.7)
17. Input: The augmented matrix of a system of n lin-
ear equations in n unknowns with a unique set of 
n solutions
Output: The n solutions, determined by using 
Gaussian elimination
18. The determinant of an n × n matrix can be used 
in solving systems of linear equations, as well 
as for other purposes. The determinant of A can 
be defined in terms of minors and cofactors. The 
minor of element aij is the determinant of the 
(n −1) × (n −1) matrix obtained from A by 
crossing out the elements in row i and column j; 
denote this minor by Mij. The cofactor of element 
aij, denoted by Cij, is defined by
Cij = (−1)i+jMij
The determinant of A is computed by multiplying 
all the elements in some fixed row of A by their 
respective cofactors and summing the results. For 
example, if the first row is used, then the determi-
nant of A is given by
∙
n
k=1
(a1k)(C1k)
Write a program that, when given n and the entries 
in an n × n array A as input, computes the deter-
minant of A. Use a recursive algorithm.

This page intentionally left blank 

Chapter Objectives
After studying this chapter, you will be able to:
•	 Understand and use the many terms associated with graphs, directed graphs, 
and trees.
•	 Appreciate the use of graphs, directed graphs, and trees as representation tools 
in a wide variety of contexts.
•	 Prove that two given graphs are isomorphic or give a reason why they are not.
•	 Use Euler’s formula for a simple, connected, planar graph.
•	 Understand the role of the two specific graphs K5 and K3,3 in graph planarity.
•	 Prove elementary properties about graphs and trees.
•	 Use adjacency matrix and adjacency list representations for graphs and ­directed 
graphs.
•	 Do preorder, inorder, and postorder tree traversal.
•	 Use array and pointer representations for binary trees.
•	 Use decision trees to represent the steps a searching or sorting algorithm car-
ries out.
•	 Build a binary search tree and conduct a binary tree search.
•	 Express lower bounds on the worst-case number of comparisons for searching 
or sorting on a list with n elements.
•	 Find Huffman codes for characters whose frequency of occurrence is given.
You work in the Information Systems Department at World Wide Widgets (WWW), the 
leading widget manufacturer. Widgets are extremely complex devices made up of an 
enormous number of very simple parts. Each part is one of the following types: Bolt 
(B), Component (C), Gear (G), Rod (R), or Screw (S). There are many different varia-
tions of each basic type. Part numbers consist of a leading character B, C, G, R, or S 
to identify the part type, followed by an 8-digit number. Thus
C00347289
B11872432
S45003781
are all legitimate part numbers. Using the multiplication principle, there are 5 × 108 
different potential part numbers! WWW maintains a data file of the part numbers 
it uses, which, as it turns out, is most of the potential numbers. Most computers, 
6
Graphs and Trees
Chapter
475

476	
Graphs and Trees
­including those at WWW, use the ASCII encoding scheme for converting characters 
into binary form, under which each character requires 1 byte (8 bits) of storage. Be-
cause each different part number consists of 9 characters, the WWW parts data file 
is approximately 9 × 5 × 108 bytes, or 4.5 Gb.
	
Question:	
How can you compress this data file so that it takes less storage space?
One answer to this question involves working with binary tree structures. A tree 
is a visual representation of data items and the connections between some of these 
items. It is a special case of a more general structure called a graph. Graphs or 
trees can be used to represent a surprising number of real-world situations—­
organization charts, road maps, transportation and communications networks, 
and so forth. Later we will see other uses of graphs and trees to represent logic 
networks, finite-state machines, and formal-language derivations.
Graph theory is an extensive topic. Sections 6.1 and 6.2 present some of the 
considerable terminology connected with graphs and trees and some elementary 
results about these structures. To represent a graph or a tree in computer memory, 
data must be arranged in a way that preserves all the information contained in the 
visual representation. Several approaches to representing graphs and trees within 
a computer are discussed.
Decision trees are graphical representations of the activities of certain types 
of algorithms. In Section 6.3, decision trees are presented and used to find lower 
bounds on the worst-case behavior of searching and sorting algorithms. In Sec-
tion 6.4, an algorithm is given for constructing binary trees that allow for data 
compression of large files.
	
S e c t i o n  6 .1 	 Graphs and Their Representations
Definitions of a Graph
One way to while away the hours on an airplane trip is to look at the literature in 
the seat pockets. This material almost always includes a map showing the routes 
of the airline you are flying, such as the one in Figure 6.1. All this route informa-
tion could be expressed in paragraph form; for example, there is a direct route be-
tween Chicago and Nashville but not between St. Louis and Nashville. However, 
the paragraph would be rather long and involved, and we would not be able to 
assimilate the information as quickly and clearly as we can from the map. There 
are many cases where “a picture is worth a thousand words.”
Chicago
Nashville
Miami
St. Louis
Dallas
Albuquerque
Phoenix
Denver
Los Angeles
San Francisco
Figure 6.1

Section 6.1   Graphs and Their Representations	
477
The term “graph” is often used informally for any visual representation of 
data, such as that in Figure 6.1; other forms include the bar graph, picture graph, 
and pie chart, which are shown in Figure 6.2. We have also talked about graphs 
of functions on rectangular coordinate systems. We will use two definitions of a 
graph; one relies on a visual representation like that of Figure 6.1, and the other is 
a more formal definition that actually says nothing about a visual representation.
	
Definition	
Graph	
(Informal)	
A graph is a nonempty set of nodes (vertices) and a set of arcs (edges) such that 	
each arc connects two nodes.
Our graphs will always have a finite number of nodes and arcs.
2014 expenditures
2012 2013 2014 2015
Profits
18%
Taxes
23%
New
equipment
25%
Overhead
34%
Each figure represents
100,000
New York
Philadelphia
Parts per million
Bar Graph
Picture Graph
Pie Chart
Figure 6.2
	
Example 1	
The set of nodes in the airline map of Figure 6.1 is EChicago, Nashville, Miami, 
Dallas, St. Louis, Albuquerque, Phoenix, Denver, San Francisco, Los AngelesF. 
There are 16 arcs; Phoenix-Albuquerque is an arc (here we are naming an arc by 
the nodes it connects), Albuquerque-Dallas is an arc, and so on.	
The informal definition of a graph works quite well if we have the visual 
representation of the graph before us to show which arcs connect which nodes. 
Without the picture, however, we need a concise way to convey this information. 
Hence our second definition of a graph.
	
Example 2	
In the graph of Figure 6.3, there are five nodes and six arcs. Arc a1 connects nodes 
1 and 2, arc a3 connects node 2 and 2, and so forth.
1
3
4
5
a1
2
a2
a3
a4
a5
a6
Figure 6.3

478	
Graphs and Trees
	
Definition	
Graph
(Formal)	
A graph is an ordered triple (N, A, g) where
N = a nonempty set of nodes (vertices)
A = a set of arcs (edges)
g = a function associating with each arc a an unordered pair x–y of nodes 
called the endpoints of a
We might want the arcs of a graph to begin at one node and end at another, in 
which case we would use a directed graph.
	
Definition	
Directed Graph
A directed graph (digraph) is an ordered triple (N, A, g) where
N = a nonempty set of nodes 
A = a set of arcs
g = a function associating with each arc a an ordered pair (x, y) of nodes 
where x is the initial point and y is the terminal point of a.
In a directed graph, then, there is a direction associated with each arc.
	
Example 3	
For the graph of Figure 6.3, the function g associating arcs with endpoints ­performs 
the following mapping: g(a1) = 1–2, g(a2) = 1–2, g(a3) = 2–2, g(a4) = 2–3, 
g(a5) = 1–3, and g(a6) = 3–4.	
	
Example 4	
Figure 6.4 shows a directed graph. There are 4 nodes and 5 arcs. The function g 
­associating arcs with endpoints performs the mapping g(a1) = (1, 2), ­meaning that 
arc a1 begins at node 1 and ends at node 2. Also, g(a3) = (1, 3), but g(a4) = (3, 1).
2
1
4
3
a1
a2
a5
a3
a4
Figure 6.4
Besides imposing direction on the arcs of a graph, we may want to modify the 
basic definition of a graph in other ways. We often want the nodes of a graph to car-
ry identifying information, like the names of the cities in the map of airline routes. 
Practice 1	 Sketch a graph having nodes 51, 2, 3, 4, 56, arcs 5a1, a2, a3, a4, a5, a66, and function 
g(a1) = 1–2, g(a2) = 1–3, g(a3) = 3–4, g(a4) = 3–4, g(a5) = 4–5, and g(a6) = 5–5.
■

Section 6.1   Graphs and Their Representations	
479
This map would be a labeled graph. We may want to use a weighted graph, where 
each arc has some numerical value, or weight, associated with it. For example, we 
might want to indicate the distances of the various routes in the airline map.
In this book, the term “graph” will mean an undirected graph. To refer to a 
directed graph, we will always say “directed graph.”
Applications of Graphs
Although the idea of a graph is very simple, an amazing number of situations 
have relationships between items that lend themselves to graphical representa-
tion. Not surprisingly, there are many graphs in this book. Graphical representa-
tions of partially ordered sets (Hasse diagrams) were introduced in Chapter 5. A 
PERT chart (for example, Figure 5.7) is a directed graph. The E-R diagram (for 
example, Figure 5.10) is a graph. The commutative diagram illustrating composi-
tion of functions (Figure 5.23) is a directed graph. Chapter 8 will introduce logic 
networks and represent them as directed graphs. Directed graphs will also be used 
to describe finite-state machines in Chapter 9.
We saw that the airline route map was a graph. A representation of any net-
work of transportation routes (a road map, for example), communications lines (as 
in a computer network), or product or service distribution routes such as natural 
gas pipelines or water mains is a graph. The chemical structure of a molecule is 
represented graphically.
Practice 2	 Draw the underlying graph in each of the following cases.
a.	 Figure 6.5 is a road map for part of Arizona.
b.	Figure 6.6 is a representation of an ozone molecule with three oxygen atoms.
O
O
O
Figure 6.6
Winslow
Flagstaff
Strawberry
Carefree
Payson
Apache
Junction
Sedona
Phoenix
Tempe
Casa Grande
Chandler
Mesa
Scottsdale
Rimrock
Figure 6.5
■

480	
Graphs and Trees
	
Example 5	
A high-level view of the information flow in a state automobile licensing office 
is prepared as the first step in developing a new computerized licensing system. 
Figure 6.7 shows the resulting directed graph, often called a data flow diagram.
Bureau of
Motor Vehicles
State
Revenue Division
Customer
Process
application
Request
payment
Process
payment
Issue
plate
Customer request
Invoice
Payment
Receipt
Plate
Registration copy
Plate
authorization
Credit notification
Validation
Figure 6.7
	
Example 6	
Figure 6.8 shows a graph representation of a local area network of computers in an 
office complex. In this “star topology,” all machines communicate through a central 
server. The graph representation highlights one of the weaknesses of such a network 
design, namely its reliance on continued, dependable operation of the central server.
Figure 6.8
	
Example 7	
Neural networks, tools used in artificial intelligence for such tasks as pattern rec-
ognition, are represented by weighted directed graphs. Figure 6.9 shows a multi-
layer network consisting of input units, output units, and a “hidden layer” of units. 
Weights on the arcs of the graph are adjusted as the neural network “learns” how 
to recognize certain trial patterns.

Section 6.1   Graphs and Their Representations	
481
Graph Terminology
Before proceeding, we need some terminology about graphs. Surprisingly, al-
though there is a large body of literature in graph theory, the terminology is not 
completely standard. Therefore other books may give slightly different variations 
of some of these terms.
Two nodes in a graph are adjacent if they are the endpoints associated with an 
arc. For example in the graph of Figure 6.3 (reproduced here), 1 and 3 are adjacent 
nodes but 1 and 4 are not. Node 2 is adjacent to itself. A loop in a graph is an arc 
with endpoints n–n for some node n; in Figure 6.3, arc a3 is a loop with endpoints 
2–2. A graph with no loops is loop-free. Two arcs with the same endpoints are 
parallel arcs; arcs a1, and a2 in Figure 6.3 are parallel. A simple graph is one 
with no loops or parallel arcs. An isolated node is adjacent to no other node; in 
Figure 6.3, 5 is an isolated node. The degree of a node is the number of arc ends 
at that node. In Figure 6.3, nodes 1 and 3 have degree 3, node 2 has degree 5, node 
4 has degree 1, and node 5 has degree 0.
1
3
4
5
a1
2
a2
a3
a4
a5
a6
Because the function g that relates arcs to endpoints in the formal definition of 
a graph is indeed a function, each arc has a unique pair of endpoints. If g is a one-to-
one function, then there is at most one arc associated with a pair of endpoints; such 
Input units
Hidden layer
Output units
w1
1, 1
w1
1, 2
w1
2, 1
w1
1, j
w1
2, j
w1
i, 1
w1
i, 2
w1
i, j
w2
j, k
w2
j, 1
w2
2, k
w2
2, 1
w2
1, k
w2
1, 1
w1
2, 2
Figure 6.9

482	
Graphs and Trees
graphs have no parallel arcs. A complete graph is one in which any two distinct 
nodes are adjacent. In this case, g is almost an onto function—every pair x–y of 
distinct nodes is the image under g of an arc—but there does not have to be a loop at 
every node. Consequently, pairs of the form x–x need not have a preimage.
A subgraph of a graph consists of a set of nodes and a set of arcs that are sub-
sets of the original node set and arc set, respectively, in which the endpoints of an 
arc must be the same nodes as in the original graph. In other words, it is a graph 
obtained by erasing part of the original graph and leaving the rest unchanged. 
Figure 6.10 shows two subgraphs of the graph in Figure 6.3. Note that the graph in 
Figure 6.10a is simple and also complete.
1
3
a1
2
a2
a3
a5
1
3
a1
a4
2
a5
(a)
(b)
Figure 6.10
A path from node n0 to node nk is a sequence
n0, a0, n1, a1, … , nk−1, ak−1, nk
of nodes and arcs where for each i, the endpoints of arc ai are ni–ni+1. In the 
graph of Figure 6.3, one path from node 2 to node 4 consists of the sequence 
2, al, 1, a2, 2, a4, 3, a6, 4. The length of a path is the number of arcs it contains; if 
an arc is used more than once, it is counted each time it is used. The length of the 
path just described from node 2 to node 4 is 4.
A graph is connected if there is a path from any node to any other node. The 
graphs in Figure 6.10 are each connected, but the graph of Figure 6.3 is not con-
nected. A cycle in a graph is a path from some node n0 back to n0 where no arc 
appears more than once in the path sequence, n0 is the only node appearing more 
than once, and n0 occurs only at the ends. (Nodes and arcs may be repeated in a 
path but not, except for node n0, in a cycle.) In the graph of Figure 6.3,
1, a1, 2, a4, 3, a5, 1
is a cycle. A graph with no cycles is acyclic.
Practice 3	 Refer to the graph created in Practice 1.
a.	 Find two nodes that are not adjacent.
b.	Find a node adjacent to itself.
c.	 Find a loop.
d.	Find two parallel arcs.
e.	 Find the degree of node 3.
f.	 Find a path of length 5.
g.	Find a cycle.
h.	Is this graph complete?
i.	 Is this graph connected?	
■

Section 6.1   Graphs and Their Representations	
483
Now consider the simple graph in Figure 6.12. It is not a complete graph 
because it is not true that every node is adjacent to every other node. However, 
the nodes can be divided into two disjoint sets, 51, 26 and 53, 4, 56, such that 
any two nodes chosen from the same set are not adjacent but any two nodes 
chosen one from each set are adjacent. Such a graph is a bipartite complete 
graph.
3
4
1
2
5
Figure 6.12
	
Example 8	
Figure 6.11 illustrates the simple, complete graphs with 1, 2, 3, and 4 vertices. The 
simple, complete graph with n vertices is denoted by Kn.
K1
K2
K3
K4
Figure 6.11
Practice 4	 Draw K5.
■
Practice 5	 Draw K3,3.
■
The concept of a path extends to a directed graph, as we might expect: A path 
from node n0 to node nk in a directed graph is a sequence
n0, a0, n1, a1, … , nk−1, ak−1, nk
where for each i, ni is the initial point and ni+1 is the terminal point of ai. If a path 
exists from node n0 to node nk, then nk is reachable from n0. The definition of a 
cycle also carries over to directed graphs.
	
Definition	
Bipartite Complete Graph
A graph is a bipartite complete graph if its nodes can be partitioned into two dis-
joint nonempty sets N1 and N2 such that two nodes x and y are adjacent if and only 
if x [ N1 and y [ N2. If 0N10 = m and 0N20 = n, such a graph is denoted by Km,n.
Figure 6.12 therefore illustrates K2,3.

484	
Graphs and Trees
We can prove some (fairly trivial) statements about graphs that follow directly 
from the definitions.
	
Example 9	
In the directed graph of Figure 6.13, there are many paths from node 1 to node 3: 
1, a4, 3 and 1, a1, 2, a2, 2, a2, 2, a3, 3 are two possibilities. Node 3 is certainly 
reachable from 1. Node 1, however, is not reachable from any other node. The 
cycles in this graph are the loop a2 and the path 3, a5, 4, a6, 3.
1
3
4
a7
2
a2
a3
a1
a4 a5
a6
Figure 6.13
	
Example 10	
Prove that an acyclic graph is simple.
We’ll use a proof by contraposition. If a graph is not simple, it has either 
parallel arcs or a loop. The parallel arcs and their endpoints, or the loop and its 
endpoints, then constitute a cycle, and the graph is not acyclic.	
Note that the converse to the statement in Example 10 is not true: Figure 6.10a 
is a simple graph, but it contains a cycle.
Practice 6
a.	 Prove that every complete graph is connected.
b.	Find a connected graph that is not complete.	
■
Isomorphic Graphs
Two graphs may appear quite different in their visual representation but still be the 
same graph according to our formal definition. We want to distinguish between 
two graphs that have cosmetic visual differences and those that have fundamen-
tally different structures. The graphs in Figures 6.14 and 6.15 are the same—they 
have the same nodes, the same arcs, and the same arc-to-endpoint function. (In 
a representation of a graph, arcs can intersect at points that are not nodes of the 
graph.) The graph in Figure 6.16 is essentially the same graph as well. If we rela-
beled the nodes and arcs of the graph of Figure 6.14 by the following mappings, 
the graphs would be the same:
	
f1:1 S a	
f2: a1 S e2
	
2 S c	
a2 S e1
	
3 S b
	
4 S d

Section 6.1   Graphs and Their Representations	
485
Structures that are the same except for relabeling are called isomorphic struc-
tures. To show that two structures are isomorphic, we must produce a relabeling 
(one-to-one, onto mappings between the elements of the two structures) and then 
show that the important properties of the structures are “preserved” (maintained) 
under this relabeling. In the case of graphs, the elements are nodes and arcs. The 
“important property” in a graph is which arcs connect which nodes.
The given mappings f1 and f2 are one-to-one, onto functions from the nodes 
and arcs, respectively, of the graph in Figure 6.14 to the nodes and arcs of the graph 
in ­Figure 6.16. Furthermore, if an arc a in the graph of Figure 6.14 has endpoints x–y, 
then the arc f2(a) in the graph of Figure 6.16 has endpoints f1(x) –f1( y), and vice versa. 
For example, arc a1 in Figure 6.14 has endpoints 1–3, while its corresponding arc e2 in 
Figure 6.16 has endpoints a–b, which are the nodes in Figure 6.16 that correspond to 
nodes 1 and 3 in Figure 6.14. We can formalize this idea.
1
3
a1
4
2
a2
Figure 6.14
a1
2
3
1
4
a2
Figure 6.15
e2
a
b
d
c
e1
Figure 6.16
	
Definition	
Isomorphic Graphs
Two graphs (N1, A1, g1,) and (N2, A2, g2) are isomorphic if there are bijections 
f1: N1 S N2 and f2: A1 S A2 such that for each arc a [ A1, g1(a) = x–y if and 
only if g23
  f2(a)4 = f1(x) –f1(  y).
	
Example 11	
The graphs shown in Figure 6.17 are isomorphic. The bijections that establish the 
isomorphism are partially given here:
	
f1: 1 S c	
f2:  a1 S e1
	
2 S e	
a2 S e4
	
3 S d	
a3 S e2
	
4 S b	
…
	
5 S a
a1
a
b
e5
e7
e8
e6
d e3
e1
c
e4
e2
e
a2
a3
a6
a5
a7
a4
a8
1
2
3
4
5
Figure 6.17

486	
Graphs and Trees
Graph isomorphism is easier to establish if we restrict our attention to simple 
graphs. If we can find an appropriate function f1 mapping nodes to nodes, then a 
function f2 mapping arcs to arcs is trivial because there is at most one arc between 
any pair of endpoints. Hence the following theorem is true.
Using these bijections, g1(a3) = 1–3 and g23f2(a3)4 = g2(e2) = c–d = f1(1)–f1(3). 
We can see that the arc-to-endpoint relationship is preserved under the relabeling 
for the case of arc a3. To prove that the graphs are isomorphic, we would have to 
complete the definition of the f2 function and then demonstrate that the arc-to-
endpoint relationship is preserved under these mappings by examining all possible 
cases.	
Practice 7	 Complete the definition of the function f2 in Example 11.
■
	
Theorem	
On Simple Graph Isomorphism
Two simple graphs (N1, A1, g1) and (N2, A2, g2) are isomorphic if there is a bijec-
tion f: N1 S N2 such that for any nodes ni and nj of N1, ni and nj are adjacent if 
and only if f(ni) and f(nj) are adjacent. (The function f is called an isomorphism 
from graph 1 to graph 2.)
Practice 8	 Find an isomorphism from the graph of Figure 6.18a to that of Figure 6.18b.
d
c
a
e
b
f
(b)
(a)
6
4
2
5
3
1
Figure 6.18
■
Proving that two graphs are isomorphic requires finding the bijection (or, for non-
simple graphs, bijections) and then showing that the adjacency property (or arc-to-end-
point relationship) is preserved. To prove that two graphs are not isomorphic, we must 
prove that the necessary bijection(s) do not exist. We could try all possible bijections 
(because there is a finite number of nodes and arcs, there is a finite number of bijec-
tions). However, this method would quickly get out of hand in graphs of any size at 
all. Instead, we can try to find some other reason that such bijections could not exist. 
Although this task is not always easy, there are certain conditions under which it is clear 
that two graphs are not isomorphic (see Exercise 21). These include the following:
	
1.	 One graph has more nodes than the other.
	
2.	 One graph has more arcs than the other.

Section 6.1   Graphs and Their Representations	
487
	
3.	 One graph has parallel arcs and the other does not.
	
4.	 One graph has a loop and the other does not.
	
5.	 One graph has a node of degree k and the other does not.
	
6.	 One graph is connected and the other is not.
	
7.	 One graph has a cycle and the other does not.
Practice 9	 Prove that the two graphs in Figure 6.19 are not isomorphic.
Figure 6.19
■
Again, graphs that are isomorphic are considered to be “the same” regardless of 
cosmetic differences in how they are drawn or labeled, whereas nonisomorphic 
graphs have fundamental structural differences.
Planar Graphs
A planar graph is one that can be represented (on a sheet of paper, that is, in 
the plane) so that its arcs intersect only at nodes. Designers of integrated circuits 
want all components in one layer of a chip to form a planar graph so that no con-
nections cross. The graph of Figure 6.14 is clearly planar. However, we know that 
it is isomorphic to the graph of Figure 6.15, so the graph of Figure 6.15 is also 
planar. The key word in the definition of a planar graph is that it can be drawn in 
a certain way.
	
Example 12	
The two graphs of Figure 6.20 are not isomorphic. Note that each graph has six 
nodes and seven arcs. Neither has parallel arcs or loops. Both are connected. Both 
have three cycles, four nodes of degree 2, and two nodes of degree 3. Therefore 
none of the obvious nonisomorphism tests apply. However, the graph in Figure 
6.20b has a node of degree 2 that is adjacent to two nodes of degree 3; this is not 
the case in Figure 6.20a, so the graphs are not isomorphic.
(a)
(b)
Figure 6.20 
Practice 10	 Prove that K4 is a planar graph.
■

488	
Graphs and Trees
	
Example 13	
Consider K5, the simple, complete graph with five vertices. We will try to construct 
K5 with no intersecting arcs by starting with some of the arcs and then adding as 
many new arcs as possible without crossing existing arcs. We’ll first lay out five 
vertices and connect them as shown in Figure 6.21a. (Because all the vertices in Kn 
are symmetric, it doesn’t matter how we label them.) 
(c)
1
2
5
4
3
(b)
1
2
5
4
3
(a)
1
2
5
4
3
Figure 6.21
Next we connect 1 to 3 and 1 to 4, as shown in Figure 6.21b. Now 2 must be connect-
ed to both 4 and 5. This can be accomplished while still preserving the planarity of the 
graph by putting these new arcs on the outside, as in Figure 6.21c. The final connec-
tion is between nodes 3 and 5. But there is no way to draw an arc from node 3 to node 
5 without crossing either the 2-4 arc or one or more of the interior arcs, such as 1-4.
We did have a choice of how to place arcs 1-3 and 1-4; we made them interior 
arcs. We could explore whether making these arcs exterior would change anything, 
but it turns out that it does not (see Practice 11). Thus it appears that K5 is not a pla-
nar graph. However, we’d still like a proof of this with a firmer foundation—this 
sounds too much like an “I can’t do it so it can’t be done” argument. Such a proof 
will be given shortly.	
Practice 11	 Show that adding arcs 1-3 and 1-4 as exterior arcs when constructing K5 still leads to a 
­situation where arcs must intersect.
■
Practice 12	 Present a construction-type argument that K3,3 is not a planar graph.
■
One fact about planar graphs was discovered by the eighteenth-century Swiss 
mathematician Leonhard Euler (pronounced “oiler”). A simple, connected, planar 
graph (when drawn in its planar representation, with no arcs crossing) divides the 
plane into a number of regions, including totally enclosed regions and one infinite 
exterior region. Euler observed a relationship between the number n of nodes, the 
number a of arcs, and the number r of regions in such a graph. This relationship is 
known as Euler’s formula:
	
n −a + r = 2
(1)
Practice 13	 Verify Euler’s formula for the simple, connected, planar graph in Figure 6.18b.
■
To prove Euler’s formula, we will do a proof by induction on a, the number of arcs. 
In the base case, a = 0 and the graph consists of a single node; the only region is the 
exterior region (Figure 6.22a). Here n = 1, a = 0, and r = 1, and Equation (1) holds. 

Section 6.1   Graphs and Their Representations	
489
Now assume that the formula holds for the planar representation of any simple, con-
nected, planar graph with k arcs, and consider such a graph with k + 1 arcs. As usual, 
we must somehow relate the “k + 1 instance” to a “k instance” so that we can make use 
of the inductive hypothesis. Here we consider two cases for the graph with k + 1 arcs.
(b)
(c)
(a)
Figure 6.22
Case 1. The graph has a node of degree 1. Temporarily erasing this node and its 
connecting arc (Figure 6.22b) leaves a simple, connected, planar graph with k 
arcs, some number n of nodes, and some number r of regions for which (by the 
inductive hypothesis)
n −k + r = 2
In the original graph, there was one more arc and one more node but the same 
number of regions, so the appropriate formula is
(n + 1) −(k + 1) + r = 2
which, by the inductive hypothesis, is true.
Case 2. The graph has no nodes of degree 1. Then temporarily erase one arc that 
helps define an enclosed region (Figure 6.22c). (If no arcs help define an enclosed 
region, the graph is a chain and there is a node of degree 1.) This leaves a simple, 
connected, planar graph with k arcs, some number n of nodes, and some number r 
of regions for which (by the inductive hypothesis)
n −k + r = 2
n the original graph, there was one more arc and one more region, but the same 
number of nodes, so the appropriate formula is
n −(k + 1) + (r + 1) = 2
which, by the inductive hypothesis, is true.
Practice 14	 In the proof of Euler’s formula, explain why in case 2 the arc to be erased must help define 
an enclosed region. Give two reasons.
■
There are two consequences of Euler’s formula if we place further restrictions on 
the graph. Suppose we require that the graph not only be simple, connected, and pla-
nar but also have at least three nodes. In a planar representation of such a graph, we 

490	
Graphs and Trees
can count the number of edges that are adjacent to (form the boundaries of) each re-
gion, including the exterior region. Arcs that are wholly interior to a region contribute 
two edges to that region; for example, if we trace the boundary of the interior region 
shown in Figure 6.22b, we travel six edges, including the arc out to the node of degree 
1 and then back again. Arcs that separate two regions contribute one edge to each 
region. Therefore, if there are a arcs in the graph, the number of region edges is 2a.
There are no regions with exactly one adjacent edge, because there are no 
loops in the graph. There are no regions with exactly two adjacent edges, because 
there are no parallel arcs and the graph consisting entirely of one arc joining two 
nodes (which would have two edges adjacent to the exterior region) is excluded. 
Therefore each region has at least three adjacent edges, so 3r is the minimum 
number of region edges. Thus
2a ≥3r
or, from Equation (1),
2a ≥3(2 −n + a) = 6 −3n + 3a
and finally
	
a ≤3n −6
(2)
If a final restriction that there are no cycles of length 3 is placed on the graph, 
then each region has at least four adjacent edges, so 4r is the minimum number of 
region edges. This leads to the inequality
2a ≥4r
which becomes
	
a ≤2n −4
(3)
These results are summarized in the following theorem.
	
Theorem	
On the Number of Nodes and Arcs
For a simple, connected, planar graph with n nodes and a arcs:
	
1.	 If the planar representation divides the plane into r regions, then
	
n −a + r = 2
(1)
	
2.	 If n ≥3, then
	
a ≤3n −6
(2)
	
3.	 If n ≥3 and there are no cycles of length 3, then
	
a ≤2n −4
(3)
Note that inequality (3) places a tighter bound on the number of arcs than ­inequality 
(2), but an additional condition has been imposed on the graph.
We can use this theorem to prove that certain graphs are not planar.

Section 6.1   Graphs and Their Representations	
491
A graph that is planar cannot be turned into a nonplanar graph by elementary 
subdivisions, and a graph that is nonplanar cannot be turned into a planar graph 
by elementary subdivisions (see Exercise 32). As a result, homeomorphic graphs 
are either both planar or both nonplanar. The following theorem, due to the Polish 
mathematician Kazimierz Kuratowski, characterizes nonplanar graphs.
	
Example 14	
K5 is a simple, connected graph with 5 nodes (and 10 arcs). If it were a planar graph, 
inequality (2) of our theorem would hold, but 10 > 3(5) −6. Therefore, just as our 
construction argument showed, K5 is not planar. K3,3 is a simple, connected graph 
with 6 nodes (and 9 arcs). It has no cycles of length 3, because this would require two 
nodes in one of the two subsets to be adjacent. If it were a planar graph, inequality 
(3) would hold, but 9 > 2(6) −4. Therefore K3,3 is not planar.
Practice 15	 Show that inequality (2) does hold for K3,3, which shows that this inequality is a necessary 
but not sufficient condition for planarity in graphs with n ≥3.
■
The nonplanar graphs K5 and K3,3 play a central role in all nonplanar graphs. 
To state what this role is, we need one more definition.
	
Definition	
Homeomorphic Graphs
Two graphs are homeomorphic if both can be obtained from the same graph by 
a sequence of elementary subdivisions, in which a single arc x–y is replaced by 
two new arcs x–v and v–y connecting to a new node v.
	
Example 15	
The graphs in parts (b) and (c) of Figure 6.23 are homeomorphic because each can 
be obtained from the graph of Figure 6.23a by a sequence of elementary subdivi-
sions. (However, neither can be obtained from the other by a sequence of elemen-
tary subdivisions.)
(c)
(b)
(a)
Figure 6.23
	
Theorem	
Kuratowski Theorem
A graph is nonplanar if and only if it contains a subgraph that is homeomorphic 
to K5 or K3,3.
We won’t prove this theorem, although one direction is easy to see. If a graph has a 
subgraph homeomorphic to the nonplanar graphs K5 or K3,3, then the subgraph—
and hence the entire graph—is nonplanar.

492	
Graphs and Trees
	
Example 16	
Figure 6.24a shows the “Petersen graph.” We will prove that this graph is not 
planar by finding a subgraph homeomorphic to K3,3. By looking at the top of the 
graph, we can see that node a is adjacent to nodes e, f, and b, none of which are 
adjacent to each other. Also, node e is adjacent to nodes d and j as well as a, and 
nodes a, d, and j are not adjacent to each other. This information is incorporated 
in the graph of Figure 6.24b, which is also a subgraph of K3,3. The arcs needed 
to complete K3,3 are shown as dotted lines in Figure 6.24c. These arcs are not 
in the Petersen graph; for example, no j–f  arc is present. However, there is a 
path in the Petersen graph from j to f using the intermediate node h, that is, j–h 
and h–f . Similarly, there are paths j–g and g–b, d–i and i–f , and d–c and c–b. 
Adding these paths to Figure 6.24b results in Figure 6.24d, which is a subgraph 
of the ­Petersen graph and is also obtainable from Figure 6.24c by a sequence of 
­elementary subdivisions.
Computer Representation of Graphs
We have said that the major advantage of a graph is its visual representation of 
information. What if we want to store a graph in digital form? Although it is pos-
sible to store a digital image of a graph, it takes a lot of space. Furthermore, such 
an image remains but a picture—the data it represents can’t be manipulated in any 
way. What we need to store are these essential data that are part of the definition 
of a graph—what the nodes are and which nodes have connecting arcs. From this 
information a visual representation could be reconstructed if desired. The usual 
computer representations of a graph involve one of two data structures, either an 
adjacency matrix or an adjacency list.
Adjacency Matrix
Suppose a graph has n nodes, numbered n1, n2, … , nn. This numbering imposes 
an arbitrary ordering on the set of nodes; recall that a set is an unordered collec-
tion. However, this is done merely as a means to identify the nodes—no signifi-
cance is attached to one node appearing before another in this ordering. Having 
ordered the nodes, we can form an n × n matrix where entry i, j is the number of 
arcs between nodes ni and nj. This matrix is called the adjacency matrix A of the 
graph with respect to this ordering. Thus,
aij = p where there are p arcs between ni and nj
a
b
f
e
j
g
d
c
h
i
(a)
j
a
d
e
f
b
(b)
j
a
d
e
f
b
(c)
j
g
h
c
a
d
e
f
b
i
(d)
Figure 6.24

Section 6.1   Graphs and Their Representations	
493
The adjacency matrix in Practice 16 is symmetric, which will be true for the 
adjacency matrix of any undirected graph—if there are p arcs between ni and nj, 
there are certainly p arcs between nj and ni. The symmetry of the matrix means 
that only elements on or below the main diagonal need to be stored. Therefore, all 
the information contained in the graph in Figure 6.25 is contained in the “lower 
triangular” array shown, and the graph could be reconstructed from this array. 
(The “upper triangular” version could also be used.)
1
1
0
1
0
1
0
0
2
0
In a directed graph, the adjacency matrix A reflects the direction of the arcs. 
For a directed matrix,
aij = p where there are p arcs from ni to nj
An adjacency matrix for a directed graph will not necessarily be symmetric, 
­because an arc from ni to nj does not imply an arc from nj to ni.
	
Example 17	
The adjacency matrix for the graph in Figure 6.25 with respect to the ordering 
1, 2, 3, 4 is a 4 × 4 matrix. Entry 1,1 is a 1 due to the loop at node 1. All other 
elements on the main diagonal are 0. Entry 2,1 (second row, first column) is a 1 
because there is one arc between node 2 and node 1, which also means that entry 
1, 2 is a 1.
3
2
1
4
Figure 6.25
So far we have
a = D
1
1
−
−
1
0
−
−
−
−
0
−
−
−
−
0
T
Practice 16	 Complete the adjacency matrix for Figure 6.25.
■

494	
Graphs and Trees
In a simple weighted graph, the entries in the adjacency matrix can indicate 
the weight of an arc by the appropriate number rather than just indicating the 
­presence of an arc by the number 1.
Adjacency List
Many graphs, far from being complete graphs, have relatively few arcs. Such 
graphs have sparse adjacency matrices; that is, the adjacency matrices contain 
many zeros. Yet if the graph has n nodes, it still requires n2 data items to represent 
the adjacency matrix (or more than n2∙2 if a triangular matrix is used), even if 
many of these items are zero. Any algorithm or procedure in which every arc in 
the graph must be examined requires looking at all n2 items in the matrix, since 
there is no way of knowing which entries are nonzero without examining them. To 
find all the nodes adjacent to a given node ni requires scanning the entire ith row 
of the adjacency matrix, a total of n items.
A graph with relatively few arcs can be represented more efficiently by stor-
ing only the nonzero entries of the adjacency matrix. This representation consists 
of a list for each node of all the nodes adjacent to it. Pointers are used to get us 
from one item in the list to the next. Such an arrangement is called a linked list. 
There is an array of n pointers, one for each node, to get each list started. This 
­adjacency list representation, although it requires extra storage for the pointers, 
may still be more efficient than an adjacency matrix. To find all the nodes ­adjacent 
to ni requires traversing the linked list for ni, which may have far fewer than the 
n elements we had to examine in the adjacency matrix. However, there are trade-
offs; if we want to determine whether one particular node nj is adjacent to ni, we 
may have to traverse all of ni’s linked list, whereas in the adjacency matrix we 
could access element i, j directly.
	
Example 18	
Consider the directed graph of Figure 6.26.
3
2
4
1
Figure 6.26
The adjacency matrix is
a = ≥
1
1
0
0
0
0
1
1
0
1
0
0
0
0
1
0
¥

Section 6.1   Graphs and Their Representations	
495
	
Example 19	
The adjacency list for the graph of Figure 6.25 contains a four-element array of 
pointers, one for each node. The pointer for each node points to an adjacent node, 
which points to another adjacent node, and so forth. The adjacency list structure is 
shown in Figure 6.27.
1
1
2
1
1
2
3
4
2
3
4
3
4
4
3
Figure 6.27
In the figure the dot indicates a null pointer, meaning that there is nothing more to be 
pointed to or that the end of the list has been reached. We have dealt with parallel arcs 
by listing a given node more than once on the adjacency list for ni if there is more than 
one arc between ni and that node. Note that the arrow in list 1 from the 2 node to the 4 
node does not mean that there is an arc from node 2 to node 4; all the elements in the 
node 1 list are adjacent to node 1, not necessarily to each other.
Practice 17	 Draw the adjacency list representation for the graph shown in Figure 6.28.
2
4
3
1
Figure 6.28
■
In an undirected graph, each arc is represented twice. If nj is on the adjacency 
list of ni, then ni is also on the adjacency list of nj. The adjacency list representation 
for a directed graph puts nj on the list for ni if there is an arc from ni to nj; ni would 
not necessarily be on the adjacency list for nj. For a labeled graph or a weighted 
graph, additional data items can be stored with the node name in the adjacency list.
	
Example 20	
Figure 6.29a shows a weighted directed graph. The adjacency list representation 
for this graph is shown in Figure 6.29b. For each record in the list, the first data 
item is the node, the second is the weight of the arc to that node, and the third is the 
pointer. Note that entry 4 in the array of startup pointers is null because there are 
no arcs that begin at node 4.

496	
Graphs and Trees
496	
Graphs and Trees
1
2
3
4
5
3
2
1
4
2
1
4
1
4
2
2
3
(b)
(a)
4
3
5
2
4
1
1
3
2
2
1
Figure 6.29
In a programming language that does not support pointers, we can still achieve 
the effect of an adjacency list by using a multicolumn array (or an array of records), 
where one column contains the nodes and another column contains the array index 
of the next node on the adjacency list—a “pseudopointer.” The disadvantage of this 
approach is that the maximum amount of storage space that might be needed for an 
n-node graph must be set aside for the array; once we start to fill the array, new space 
cannot be dynamically created if we learn that there are still more adjacent nodes.
	
Example 21	
The array-pointer representation of the graph of Figure 6.29a is shown in  
Figure 6.30. A null pointer is indicated by an array index of 0.
1
2
3
4
5
6
7
8
9
10
11
Node
Pointer
Weight
3
1
4
2
4
2
2
4
2
1
1
3
6
7
9
0
10
0
8
0
0
11
0
Figure 6.30
In this array, row 2, representing node 2, has a pointer to index 7. At index 7 
of the array, we find node 1 with weight 4, representing the arc of weight 4 from 
node 2 to node 1. The pointer to index 8 says that the adjacency list for node 2 has 
more entries. At index 8, we learn that there is an arc from 2 to 4 of weight 2, and 
that this completes the adjacency list for node 2.

Special Interest Page
Isomorphic Protein Graphs
The question of whether two graphs are isomorphic 
may seem to be of only academic interest, but in fact it 
is an important question in modern biological research. 
We are all familiar with the concept that the DNA in 
our cells carries our genetic information. But each cell 
also contains thousands of proteins, long chains of var-
ious kinds of amino acids. There are up to 20 different 
kinds of amino acids, and the sequence of amino ac-
ids determines the three-dimensional shape of a given 
protein as well as its function within the cell. Common 
categories of proteins according to their functions in-
clude the following:
Enzymes: Initiate chemical processes within the 
cell and form new molecules
Antibodies: Recognize and defend against foreign 
particles such as bacteria
Transport: Carry molecules such as oxygen 
throughout the cell and the body
Structural: Give the cell its shape and structure
Hormones: Transmit signals throughout the body 
to coordinate biological processes
Proteins within a cell do not act in isolation; 
rather, they interact with other proteins in the cell to 
carry out complex tasks such as DNA replication or 
to transport oxygen throughout the cell. Protein-to-
protein interactions (PPI) are therefore what make a 
cell function, and any change, however minor, in a 
given protein could affect the PPIs for that protein and 
thus affect the entire cell. Knowledge of cell biology 
at the PPI level is of great interest for identifying the 
underlying cause of disease and development of thera-
peutics.
Now consider the various proteins within a 
­given cell as nodes, and two proteins that interact as 
­connected by an arc. Voilà—we have a graph! And 
given the number of proteins within a cell and the num-
ber and complexity of their interactions, it is a huge 
graph. A number of experiments have been done to 
determine what this graph looks like in various organ-
isms, but the data gained seem to have low reliabil-
ity. This problem has promoted interest in comparing 
PPIs across species to find commonalities that would 
reinforce information about the functionality of those 
interactions. Basically, researchers are looking for iso-
morphic graphs (or subgraphs) between cells from two 
different species.
The general problem of determining whether two 
graphs are isomorphic has no known polynomial-time 
solution—there is no known efficient algorithm. The 
performance of an inefficient algorithm might improve 
if certain conditions on the graphs are met: Are they 
both planar? Are they both trees? Such simplifications 
are unlikely to occur in the biological world of cell pro-
teins. Consequently, various “heuristic” approaches 
(read “educated guesses”) are used. One of these ap-
proaches ranks the similarities between the sequences 
of amino acids forming the proteins, one from each 
species, that might be considered as matching pairs 
for a graph isomorphism. This ranking algorithm is 
based on the iterative PageRank algorithm (invented 
by Google cofounder Larry Page) that ranks Web page 
x based on the number of pages that link to x and the 
PageRank value of those pages.
“Comparative Analysis of Protein Networks: Hard Prob-
lems, Practical Solutions,” Atias. N., and Sharan, R., 
Communications of the ACM, May 2012.
http://www.ncbi.nlm.nih.gov/About/primer/genetics_ 
genome.html
http://ghr.nlm.nih.gov/handbook/howgeneswork/protein
Chapter 6

498	
Graphs and Trees
Exercises 6.1
	 1.	 Give the function g that is part of the formal definition of the directed graph shown.
a
d
c
b
1
3
2
	 2.	 Use the graph in the figure to answer the questions that follow.
	
a.	 Is the graph simple?
	
b.	Is the graph complete?
	
c.	 Is the graph connected?
	
d.	Can you find two paths from 3 to 6?
	
e.	 Can you find a cycle?
	
f.	 Can you find an arc whose removal will make the graph acyclic?
	
g.	Can you find an arc whose removal will make the graph not connected?
	 3.	 Sketch a picture of each of the following graphs.
	
a.	 Simple graph with three nodes, each of degree 2
	
b.	Graph with four nodes, with cycles of length 1, 2, 3, and 4
	
c.	 Noncomplete graph with four nodes, each of degree 4
	 4.	 Use the directed graph in the figure to answer the questions that follow.
	
a.	 Which nodes are reachable from node 3?
	
b.	What is the length of the shortest path from node 3 to node 6?
	
c.	 What is a path from node 1 to node 6 of length 8?
	 5.	 Draw K6.
	 6.	 Draw K3,4.
	 7.	 For each of the following characteristics, draw a graph or explain why such a graph does not exist.
	
a.	 Four nodes of degree 1, 2, 3, and 4, respectively
	
b.	Simple, four nodes of degree 1, 2, 3, and 4, respectively
	
c.	 Four nodes of degree 2, 3, 3, and 4, respectively
	
d.	Four nodes of degree 2, 3, 3, and 3, respectively
S e c t i o n  6 .1 	
Review
Techniques
•	 Use graph terminology.
	
Prove or disprove that two graphs are isomorphic.
•	 Find a planar representation of a simple graph or 
prove that none exists.
	
Construct adjacency matrices and adjacency lists 
for graphs and directed graphs.
Main Ideas
•	 Diverse situations can be modeled by graphs.
•	 Graphs can be represented in a computer by matri-
ces or by linked lists.
W
W
1
4
3
7
2
6
5
a5
a2
a3
a4
a1
a6
a7
1
2
3
5
6
4

Section 6.1   Graphs and Their Representations	
499
	 8.	 For each of the following characteristics, draw a graph or explain why such a graph does not exist.
	
a.	 Simple graph with seven nodes, each of degree 3
	
b.	Four nodes, two of degree 2 and two of degree 3
	
c.	 Three nodes of degree 0, 1, and 3, respectively
	
d.	Complete graph with 4 nodes each of degree 2
	 9.	 An acquaintanceship graph is an undirected graph in which the nodes represent people and nodes a and b 
are adjacent if a and b are acquainted.
	
a.	 The acquaintanceship graph for the IT department and the marketing department of a major corporation 
is an unconnected graph. What does this imply?
	
b.	The following figure represents an acquaintanceship graph for residents of an apartment building. Are 
Carl and Fletcher acquainted? How many people is SiuYin acquainted with?
Carl
Yvonne
Fletcher
Katrina
SiuYin
Moku
Yuri
	
c.	 The length of the shortest path between node a and node b in an acquaintanceship graph is sometimes 
called the degree of separation between a and b. What is the degree of separation between Carl and Yuri?
	 10.	The “small world effect” states that the average degree of separation (see Exercise 9) in an acquaintance-
ship graph of the whole world is 6. In other words, a path of acquaintance relationships from you to any 
other person on earth exists with, on the average, a path length of 6 (5 intermediate persons). Experiments 
in delivering hard-copy letters and e-mail messages have empirically confirmed this theory.1
	
a.	 What are the potential implications for e-mail traffic if the small world effect holds for computer networks?
	
b.	What are the potential implications for epidemiology if the small world effect holds for physical con-
tact between humans?
	 11.	The small world effect (see Exercise 10) has been found to be true between root words (that is, basic 
words found in a thesaurus) in the English language, with an average degree of separation equal to 3. Here 
“adjacent words” are those that are listed as synonyms in an English thesaurus. For example, “gate” and 
“commotion” are related by 3 degrees of separation, as follows:
gate S door S flap S commotion
	
	 Can you think of 3 degrees of separation between the following pairs of words?
	
a.	 “star” and “sculpture”
	
b.	“burden” and “influence”
	
c.	 “piano” and “significance”
1But more recent analyses of 721 million Facebook users, a much larger community than was available to earlier studies, suggests that the average 
number of intermediaries between persons A and B is 3.74. It’s a small world indeed, at least for Facebook users.

500	
Graphs and Trees
	 12.	An idea closely related to the average degree of separation in a graph is that of clustering. The global 
clustering coefficient for a given graph is given by
C = 3 * T
t
	
	 where T =  the number of triangles in the graph and t =  the number of connected node triples.
A connected node triple is a “center” node adjacent to an unordered pair of other nodes. For example, in the 
graph of Exercise 2, 3–4–5 (or 5–4–3) and 4–5–6 (6–5–4) are two such triples. Nodes that make up a triangle 
demonstrate transitivity; if a is adjacent to b and b is adjacent to c, then a is adjacent to c. Therefore c is a ratio of 
nodes in a transitive threesome to all nodes in a threesome. (One might think of this in terms of a social network 
as the probability that if you are a “friend” of mine and x is a “friend” of yours, then x is also a “friend” of mine.)
	
a.	 Consider the graph in Figure 6.28 and the graph for Exercise 2. Which do you think has the higher 
clustering coefficient?
	
b.	Compute the clustering coefficient for the graph in Figure 6.28
	
c.	 Compute the clustering coefficient for the graph for Exercise 2.
	 13.	Which of the following graphs is not isomorphic to the others, and why?
(b)
(c)
(a)
	 14.	Which of the following graphs is not isomorphic to the others, and why?
(a)
(c)
(d)
(e)
(b)
For Exercises 15–20, decide if the two graphs are isomorphic. If so, give the function or functions that establish 
the isomorphism; if not, explain why.
	 15.	
1
2
3
a5
a7
a6
a1
a
d
c
b
a4
4
(a)
(b)
a2
e5
e4
e1
e2
e7
e3
e6
a3

Section 6.1   Graphs and Their Representations	
501
	 16.	
5
1
2
3
4
(a)
a2
a6
a3
a4
a9
a8
a1
a7
e1
e3
e6
e7
d
c
a
b
e
e2
e4
e5
e8
e9
(b)
a5
	 17.	
a
b
e
d
c
1
2
5
4
3
(b)
(a)
	 18.	
1
4
2
3
6
5
(a)
a
b
c
f
e
d
(b)
	 19.	
(a)
1
3
2
6
5
4
(b)
a
f
c
d
b
e

502	
Graphs and Trees
	 20.	
2
1
5
6
7
8
3
4
(a)
(b)
a
h
b
f
g
c
d
e
	 21.	Prove that two graphs are not isomorphic if one of them
	
a.	 has more nodes than the other.
	
b.	has more arcs than the other.
	
c.	 has parallel arcs and the other does not.
	
d.	has a loop and the other does not.
	
e.	 has a node of degree k and the other does not.
	
f.	 is connected and the other is not.
	
g.	has a cycle and the other does not.
	 22.	Draw all the nonisomorphic, simple graphs with two nodes.
	 23.	Draw all the nonisomorphic, simple graphs with three nodes.
	 24.	Draw all the nonisomorphic, simple graphs with four nodes.
	 25.	Find an expression for the number of arcs in Kn and prove that your expression is correct.
	 26.	Verify Euler’s formula for the following simple, connected, planar graph.
	 27.	Prove that K2,3 is a planar graph.
	 28.	Prove that the following graph is a planar graph.
	 29.	If a simple, connected, planar graph has six nodes, all of degree 3, into how many regions does it divide 
the plane?

Section 6.1   Graphs and Their Representations	
503
	 30.	If all the nodes of a simple, connected, planar graph have degree 4 and the number of arcs is 12, into how 
many regions does it divide the plane?
	 31.	Does Euler’s formula (Equation (1) of the theorem on the number of nodes and arcs) hold for nonsimple 
graphs? What about inequalities (2) and (3) of the theorem?
	 32.	What is wrong with the following argument that claims to use elementary subdivisions to turn a nonplanar 
graph into a planar graph?
In a nonplanar graph there must be two arcs ai and aj that intersect at a point v that is not a node. Do 
an elementary subdivision on ai with an inserted node at v and an elementary subdivision on aj with an 
inserted node at v. In the resulting graph, the point of intersection is a node. Repeat this process with any 
non-node intersections; the result is a planar graph.
For Exercises 33–36, determine whether the graph is planar (by finding a representation where arcs intersect 
only at nodes) or nonplanar (by finding a subgraph homeomorphic to K5 or K3,3.
	 33.	
	
35.	
	 34.	
	
	
36.	
2
1
5
3
7
4
6
For Exercises 37–42, write the adjacency matrix for the given graph.
	 37.	
5
2
3
4
1
	
39.	
2
4
5
1
3
6
7
	 38.	
1
2
4
5
3
	
40.	
1
4
5
2
3
6
	

504	
Graphs and Trees
	 41.	
3
1
2
4
	
42.	
1
3
4
2
For Exercises 43–46, draw the graph represented by the adjacency matrix.
	 43.	
£
0
2
0
2
0
2
0
2
0
§
	
45.	
E
0
1
1
1
0
1
0
0
0
1
1
0
0
0
1
1
0
0
0
1
0
1
1
1
0
U
 
	 44.		
F
0
1
0
0
0
0
1
0
1
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
2
0
0
0
0
2
0
V
	
46.	
E
0
1
0
0
1
1
0
1
0
0
0
1
0
1
0
0
0
1
0
1
1
0
0
1
0
U
	 47.	The adjacency matrix for an undirected graph is given in lower triangular form by
2
1
0
0
0
1
1
1
2
0
	
	 Draw the graph. 
	 48.	The adjacency matrix for a directed graph is given by
E
0
1
1
0
0
0
0
0
0
0
0
0
1
1
0
0
0
1
0
2
1
0
0
0
0
U
	
	 Draw the graph.
	 49.	Describe the graph whose adjacency matrix is In, the n × n identity matrix.
	 50.	Describe the graph whose adjacency matrix is 0n, the n × n matrix of all 0’s.
	 51.	Describe the adjacency matrix for Kn, the simple, complete graph with n nodes.

Section 6.1   Graphs and Their Representations	
505
	 52.	Given the adjacency matrix A for a directed graph G, describe the graph represented by the adjacency 
matrix aT (see Exercise 15 in Section 5.7).
For Exercises 53–58, draw the adjacency list representation for the indicated graph.
	 53.	Exercise 37
	 54.	Exercise 38
	 55.	Exercise 39
	 56.	Exercise 40
	 57.	Exercise 41
	 58.	Exercise 42
	 59.	Refer to the accompanying graph.
	
a.	 Draw the adjacency list representation.
	
b.	How many storage locations are required for the adjacency list? (A pointer takes 
one storage location.)
	
c.	 How many storage locations would be required in an adjacency matrix for this graph?
	 60.	Draw the adjacency list representation for the following weighted directed graph.
1
1
3
2
4
2
1
2
3
	 61.	For the directed graph of Exercise 42, construct the array-pointer representation.
	 62.	For the weighted directed graph of Exercise 60, construct the array-pointer representation.
	 63.	Draw the undirected graph represented by the following adjacency list.
2
1
1
2
1
2
3
4
3
4
3
2
2
3
4
4
3
	 64.	Draw the directed graph represented by the following adjacency list.
1
2
1
1
2
3
4
4
2
3
6
4
5
1
2

506	
Graphs and Trees
Exercises 65–72 refer to the complement of a graph. If G is a simple graph, the complement of G, denoted G′, 
is the simple graph with the same set of nodes as G, where nodes x–y are adjacent in G′ if and only if they are 
not adjacent in G.
	 65.	Draw G′ for the graph of Figure 6.18a.
	 66.	Draw K 4r  .
	 67.	Show that if two simple graphs G1 and G2 are isomorphic, so are their complements G1 r and G2r  .
	 68.	A simple graph is self-complementary if it is isomorphic to its complement. Prove that in a self-­complementary 
graph with n nodes (n > 1), n = 4k or n = 4k + 1 for some integer k. (Hint: Use the result of Exercise 25.)
	 69.	Prove that in any simple graph G with at least two nodes, if G is not connected, then G′ is connected. 
(Hint: If G is not connected, then G consists of a collection of “disjoint” connected subgraphs.)
	 70.	Find a simple graph G with at least two nodes where both G and G′ are connected, thus showing that the 
converse of Exercise 69 is false.
	 71.	Given an adjacency matrix A for a simple graph G, describe the adjacency matrix for G′.
	 72.	Prove that if 0N 0 ≥11 in a simple, connected graph G, then not both G and G′ can be planar.
	 73.	Prove that in any simple graph G with n nodes and a arcs, 2a ≤n2 −n.
	 74.	Prove that a simple, connected graph with n nodes has at least n −1 arcs. (Hint: Show that this can be 
restated as “A simple, connected graph with m arcs has at most m + 1 nodes.” Then use the second prin-
ciple of induction on m.)
	 75.	Prove that a simple graph with n nodes (n ≥2) and more than C(n −1, 2) arcs is connected. (Hint: Use 
Exercises 69 and 74.)
	 76.	Euler’s formula is stated for simple, connected planar graphs, but in fact the word 
“simple” could be ­omitted.
	
a.	 A non-simple graph is a simple graph with loops or parallel arcs added. Prove that 
any simple connected planar graph remains a connected planar graph if parallel 
arcs or loops are added. (Hint: Temporarily erase the parallel arcs and loops.)
	
b.	Prove that the graph in the figure is a planar graph.
	
c.	 Prove that Euler’s formula holds for the graph of part (b) when drawn in its 
­planar form.
	
d.	Prove that a connected planar graph with parallel arcs or loops obeys Euler’s formula when drawn in 
its planar form.
Exercises 77–86 refer to the problem of graph colorability. The origin of graph-coloring problems is a map-
coloring problem: Suppose that a map of various countries, drawn on a sheet of paper, is to be colored so that 
no two countries with a common border have the same color. (We need not worry about countries that meet 
only at a point, and we will assume that each country is “connected.”) What is the minimum number of colors 
required to carry out this task for any map?
	 77.	Show that a coloring of the accompanying map requires three colors and no more than three colors.
	 78.	Draw a map that requires four colors.

Section 6.1   Graphs and Their Representations	
507
	 79.	Associated with any map is a graph, called the dual graph for the map, formed as follows: Put one node 
in each region of the map and an arc between two nodes representing adjacent countries.
	
a.	 Draw the dual graph for the map of Exercise 77.
	
b.	Draw the dual graph for the following map.
	
c.	 Draw a map for which the following graph would serve as the dual.
	 80.	A coloring of a graph is an assignment of a color to each node of the graph in such a way that no two adja-
cent nodes have the same color. The chromatic number of a graph is the smallest number of colors needed 
to achieve a coloring. Find the chromatic number of the following graphs.
a.
b. 
	 81.	At least four colors are required to solve the general map-coloring problem (see Exercise 78). Because no 
one could produce a map requiring more than four colors, the conjecture was formulated that four colors 
are indeed sufficient. This conjecture became known as the four-color problem. It was first proposed to 
the mathematician Augustus De Morgan by one of his students in 1852, and it subsequently received 
much attention. It remained unproved, however, for over a hundred years. In 1976 two mathematicians at 
the University of Illinois, Wolfgang Haken and Kenneth Appel, used a computer to work through a large 
number of cases in a proof by contradiction, thus verifying the four-color conjecture.
The dual graph for a map (see Exercise 79), by the way it is constructed, will always be simple, con-
nected, and planar. In addition, any simple, connected, planar graph can be viewed as the dual graph of 
a map. Restate the four-color conjecture in terms of the chromatic number (see Exercise 80) of a graph.
	 82.	Prove that in a simple, connected, planar graph with three or more nodes, there is at least one node with 
degree less than or equal to 5. (Hint: Use a proof by contradiction.)
	 83.	(Challenging problem) The five-color theorem states that the chromatic number for any simple, con-
nected, planar graph is at most 5. While the four-color theorem (Exercise 81) is very difficult to prove, the 
five-color theorem can be proved by induction on the number of nodes in the graph. Prove the five-color 
theorem, making use of the result in Exercise 82.

508	
Graphs and Trees
	 84.	The six-color theorem can be proved as a map-coloring problem without using the dual graph. Instead 
of creating the dual graph, put nodes at the intersections of boundaries and straighten the boundaries 
of regions so that the problem of coloring the map shown in figure (a) is represented by the problem of 
coloring the enclosed regions of the graph in figure (b). First assume that no country has a hole in 
it. Then the graph will be loop-free, planar, and connected. Also, every node will have degree at  
least 3.
	
(a)
	
(b)
	
a.	 Show that the graph can be assumed to be simple by proving that if six colors are sufficient for coloring 
a simple graph, they are sufficient for a graph with parallel arcs as well. (Hint: Use temporary small 
countries at nodes.)
	
b.	Prove that in a simple, connected, planar graph with R enclosed regions, n −a + R = 1.
	
c.	 Consider a simple, connected, planar graph and assume that every enclosed region has at least six edges 
adjacent to it. Show that 2a ≤3n −3.
	
d.	Now consider a simple, connected, planar graph where every node has degree at least 3. Show that such 
a graph has at least one enclosed region with no more than five adjacent edges.
	
e.	 Prove that six colors are sufficient to color any planar map where no country has a hole in it.
	
f.	 Prove that six colors are sufficient to color any planar map. (Hint: Cut some temporary slits in the 
map.)
	 85.	Five political lobbyists are visiting seven members of Congress (labeled A through G) on the same day. 
The members of Congress the five lobbyists must see are
	
1.	A, B, D
	
2.	B, C, F 
	
3.	A, B, D, G 
	
4.	E, G 
	
5.	D, E, F
	
	 Each member of Congress will be available to meet with lobbyists for one hour. What is the minimum 
number of time slots that must be used to set up the one-hour meetings so that no lobbyist has a conflict? 
(Hint: Treat this as a graph-coloring problem.) What if lobbyist 3 discovers that she does not need to see 
B and lobbyist 5 discovers that he does not need to see D?
	 86.	In a multiprocessor machine, six processors labeled A through F share blocks in a common data store. Two 
processors cannot simultaneously write to the same block. The following table shows which processors 
will write to the data store at the same time. How many distinct blocks are needed? (Hint: Treat this as a 
graph-coloring problem.)
A, F, C
B, D
F, D, A
B, E
F, C, E

	Section 6.2   Trees and Their Representations	
509
	
S e c t i o n  6 . 2 	 Trees and Their Representations
Tree Terminology
A special type of graph called a tree turns out to be a very useful representation 
of data.
Figure 6.31 pictures two trees. Perversely, computer scientists like to draw 
trees with the root at the top. An acyclic connected graph with no designated root 
node is called a nonrooted tree or a free tree. (Again, terminology is nonstan-
dard. Some books define trees as acyclic, connected graphs and then call them 
“rooted trees” when there is a designated root node.)
r
r
(a)
(b)
Figure 6.31
A tree can also be defined recursively. A single node is a tree (with that node 
as its root). If T1, T2, … , Tt are disjoint trees with roots r1, r2, … , rt, the graph 
formed by attaching a new node r by a single arc to each of r1, r2, … , rt, is a 
tree with root r. The nodes r1, r2 … , rt are children of r, and r is a parent of 
r1, r2, … , rt. Figure 6.32 shows the final step in the recursive construction of the 
tree in Figure 6.31b. It is often helpful to process a tree structure by working with 
it recursively, treating the subtrees as smaller tree objects.
	
Definition	
Tree
A tree is an acyclic, connected graph with one node designated as the root of the 
tree.
r
r2
r1
T1
T2
Figure 6.32

510	
Graphs and Trees
Because a tree is a connected graph, there is a path from the root to any 
other node in the tree; because the tree is acyclic, that path is unique. The depth 
of a node in a tree is the length of the path from the root to the node; the root 
itself has depth 0. The depth (height) of the tree is the maximum depth of any 
node in the tree; in other words, it is the length of the longest path from the root 
to any node. A node with no children is called a leaf of the tree; all non-leaves 
are internal nodes. A forest is an acyclic graph (not necessarily connected); 
thus a forest is a disjoint collection of trees. Figures 6.31a and 6.31b together 
form a forest.
Binary trees, where each node has at most two children, are of particular 
interest. In a binary tree, each child of a node is designated as either the left child 
or the right child. A full binary tree occurs when all internal nodes have two 
children and all leaves are at the same depth. Figure 6.33 shows a binary tree of 
height 4, and Figure 6.34 shows a full binary tree of height 3. A complete binary 
tree is an almost full binary tree; the bottom level of the tree is filling from left to 
right but may not have its full complement of leaves. Figure 6.35 shows a complete 
binary tree of height 3. (Note that while a tree is a graph, a complete tree is not a 
complete graph!)
r
Figure 6.33
r
Figure 6.34
r
Figure 6.35
 	
	
Practice 18	 Answer the following questions about the binary tree shown in Figure 6.36. (Assume that 
node 1 is the root.)
1
2
3
4
5
Figure 6.36
a.	 What is the height?
b.	What is the left child of node 2?
c.	 What is the depth of node 5?	
■

	Section 6.2   Trees and Their Representations	
511
Applications of Trees
Decision trees were used to solve counting problems in Chapter 4 and will be used 
in Section 6.3 to help establish lower bounds on the work for certain algorithms. 
Exercise 43 of Section 5.1 describes the organization of data into a binary tree 
structure. By using these trees, a collection of records can be efficiently searched 
to locate a particular record or to determine that a record is not in the collection. 
Examples of such a search would be checking for a volume in a library, for a 
patient’s medical record in a hospital, or for an individual’s credit record at the 
bank. We will also look at binary tree search in Section 6.3. The derivations of 
words in certain formal languages will be shown as trees in Chapter 9 (these are 
the parse trees generated by a compiler while analyzing a computer program).
A family tree is usually, indeed, a tree, although if there were intermarriages, 
it would be a graph but not a tree in the technical sense. (Information obtained 
from a family tree is not only interesting but also useful for research in medical 
genetics.) The organization chart indicating who reports to whom in a large com-
pany or other enterprise is usually a tree (Figure 6.37).
Board of
Regents
University
President
Academic Vice
President
Administrative
Vice President
Dean of Arts
and Sciences
Dean of
Business
History Chair
Computer
Science Chair
Computer Science
Faculty Member
Dean of
Engineering
Dean of
Agriculture
Figure 6.37
Folders and files on your computer are organized in a hierarchical (treelike) 
structure. In Figure 6.38, the CSCI 34000 tree (folder) has been expanded to show 
two subtrees; the Web Materials subtree has been expanded to show additional 
folders, the Activities subtree has not been expanded.

512	
Graphs and Trees
	
 Figure 6.38
	
Example 22	
A computer virus is spread via e-mail. Each second, 4 new machines are ­infected. 
A 4-ary tree structure (Figure 6.39) represents the spread of the virus. By the 
­multiplication principle, 4n machines have been infected after n seconds.
Figure 6.39
	
Example 23	
Algebraic expressions involving binary operations can be represented by la-
beled binary trees. The leaves are labeled as operands, and the internal nodes 
are labeled as binary operations. For any internal node, the binary operation of 
its label is performed on the expressions associated with its left and right sub-
trees. Thus the binary tree in Figure 6.40 represents the algebraic expression 
(2 + x) −(  y * 3).
x
y
2
3
*
+
–
Figure 6.40
Practice 19	 What is the expression tree for (2 + 3) * 5?
■

	Section 6.2   Trees and Their Representations	
513
Binary Tree Representation
Because a tree is also a graph, the representations discussed in Section 6.1 for graphs 
in general can also be used for trees. Binary trees, however, have special character-
istics that we want to capture in the representation, namely, the identity of the left 
and right child. The equivalent of an adjacency matrix is a two-column array (or 
an array of records) where the data values for each node are the left and right child 
of that node. The equivalent of the adjacency list representation is a collection of 
records with three fields containing, respectively, the current node, a pointer to the 
record for the left-child node, and a pointer to the record for the right-child node.
	
Example 24	
For the binary tree shown in Figure 6.41, the left child-right 
child array representation is given in Figure 6.42a. Zeros again 
indicate null pointers. The pointer representation is given in 
­Figure 6.42b.
1
2
3
4
5
6
(a)
(b)
1
2
3
4
5
6
2
4
0
0
0
0
3
5
6
0
0
0
Left child
Right child
Figure 6.42
4
5
6
3
2
1
Figure 6.41
Practice 20	 For the binary tree in Figure 6.43
a.	 Give the left child-right child array representation.
b.	Give the pointer representation.
1
2
4
3
5
Figure 6.43
■

514	
Graphs and Trees
Tree Traversal Algorithms
If a tree structure is being used to store data, it is often helpful to have a systematic 
mechanism for writing out the data values stored at all the nodes, which can be 
accomplished by traversing the tree, that is, visiting each of the nodes in the tree 
structure, The three common tree traversal algorithms are preorder, inorder, and 
postorder traversal.
In the three traversal methods, it is helpful to use the recursive view of a 
tree, where the root of a tree has branches down to roots of subtrees. We will 
therefore assume that a tree T has a root r; any subtrees are labeled left to right as 
T1, T2, … , Tt (Figure 6.44). Because we are using a recursive definition of a tree, 
it will be easy to state the tree traversal algorithms in recursive form.
T2
Tt
T1
r2
rt
r1
r
. . .
Figure 6.44
The terms preorder, inorder, and postorder refer to the order in which the root 
of a tree is visited compared to the subtree nodes. In preorder traversal, the root 
of the tree is visited first and then the subtrees are processed left to right, each in 
preorder.
	
ALGORITHM	
Preorder
Preorder (tree T )
//Writes the nodes of a tree with root r in preorder
write(r)
for i = 1 to t do 
	
Preorder(Ti) 
end for
end Preorder

	Section 6.2   Trees and Their Representations	
515
In inorder traversal, the left subtree is processed by an inorder traversal, 
then the root is visited, and then the remaining subtrees are processed from left to 
right, each in inorder. If the tree is a binary tree, the result is that the root is visited 
between processing of the two subtrees. In a nonbinary tree, if there is a single 
subtree joined to its parent by a vertical arc, that is considered the left subtree and 
there are no additional subtrees.
Finally, in postorder traversal, the root is visited last, after all subtrees have 
been processed from left to right in postorder.
	
ALGORITHM	
Postorder
Postorder (tree T) 
//Writes the nodes of a tree with root r in postorder
for i = 1 to t do
	
Postorder(Ti)
end for
write(r)
end Postorder
	
Example 25	
For the binary tree of Figure 6.45, the preorder traversal algorithm (root, left, 
right) says to write the root first, a, and then process the left subtree. At the left 
subtree, rooted at b, a preorder traversal writes the root, b, and moves again to the 
left subtree, which is the single node d. This single node is the root of a tree, so 
it is written out. Then d’s left subtree (empty) and d’s right subtree (empty) are 
traversed. Backing up to the tree rooted at b, its left subtree has been traversed, 
so now the right subtree is traversed, producing node e. The subtree rooted at  
	
ALGORITHM	
Inorder
Inorder (tree T )
//Writes the nodes of a tree with root r in inorder
Inorder(T1)
write(r)
for i = 2 to t do 
	
Inorder(Ti) 
end for
end Inorder

516	
Graphs and Trees
b has now been completely traversed. Backing up to a, it is time to traverse a’s 
right subtree. A preorder traversal of the tree rooted at c causes c to be written, 
then traversal goes to c’s left subtree, which results in f, h, and i being written. 
Backing up to c, traversing c’s right subtree produces g. The subtree rooted at c 
has now been completely traversed, and the algorithm terminates. The preorder 
traversal produced
a, b, d, e, c, f, h, i, g
a
c
b
d
e
g
i
h
f
Figure 6.45
	
Example 26	
Using the tree of Figure 6.45 again, an inorder traversal (left, root, right), travels 
down to the farthest left subtree, rooted at d. An inorder traversal here traverses the 
left subtree (empty), writes out the root, d, then traverses the right subtree (empty). 
Backing up the tree to b, b’s left subtree has been traversed, so it is time to write 
out the root, b. Proceeding then to b’s right subtree, e is written. Backing up to a, 
a’s left subtree has been traversed, so the root, a, is written out. Proceeding to a’s 
right subtree, an inorder traversal says to go to the farthest left subtree first, which 
would cause the h to be written. After that, f and i are written, then the root c, then 
the right subtree of c, which is g. The nodes are therefore written as
d, b, e, a, h, f, i, c, g
A postorder traversal (left, right, root) would produce
d, e, b, h, i, f, g, c, a
	
Example 27	
Consider the tree shown in Figure 6.46, which is not a binary tree. A preorder tra-
versal first writes the root a and then does a preorder traversal on the left subtree, 
rooted at b. The preorder traversal of this subtree writes out b and then proceeds 
to a preorder traversal of the left subtree of b, which is rooted at d. Node d is 
written and then a preorder traversal of the left (the only) subtree of d, which 
is rooted at i, is done. After writing out i, the traversal backs up to consider any 
other subtrees of d; there are none.
Backing up to b, there are other subtrees of b. Processing these left to right, 
nodes e and then f are written. All the subtrees of b have now been traversed; back-
ing up to node a to look for subtrees farther to the right reveals a subtree rooted at 
c. The algorithm writes out the root c, then moves to its leftmost subtree rooted at 
REMINDER
For a binary tree:
Preorder traversal is root, 
left, right.
Inorder traversal is left, 
root, right.
Postorder traversal is left, 
right, root.

	Section 6.2   Trees and Their Representations	
517
Practice 21	 Do a preorder, inorder, and postorder traversal of the tree in Figure 6.47.
a
d
b
e
c
f
g
i
h
Figure 6.47
■
g and writes out g. Processing the subtrees of g, the nodes j and k are written; then 
backing up to c, its remaining subtree is processed, producing h. Node c has no 
other subtrees; backing up to a, a has no other subtrees, and the algorithm termi-
nates. The list of nodes in preorder traversal is
a, b, d, i, e, f, c, g, j, k, h
To do an inorder traversal of the tree in Figure 6.46, process left subtrees 
first, leading down to node i, which has no subtrees. Therefore i is written out. 
Backing up to d, the left (only) subtree of d has been traversed, so d is written out. 
Since node d has no further subtrees, the algorithm backs up to b. The left subtree 
of b has been processed, so b is written out and then its remaining subtrees are 
traversed, writing out e and f. Backing up to a, a is written out, and then the right 
subtree of a is processed, leading to nodes j, g, k, c, and h, in that order, and we are 
done. Thus the inorder list of nodes is
i, d, b, e, f, a, j, g, k, c, h
The following list of nodes results from a postorder traversal:
i, d, e, f, b, j, k, g, h, c, a
a
c
b
d
e
f
g
i
j
k
h
Figure 6.46

518	
Graphs and Trees
2Named for the Polish logician J. Lukasiewicz, who first used it.
	
Example 28	
Example 23 showed how algebraic expressions can be represented as binary trees. 
If we do an inorder traversal of the expression tree, we retrieve the original alge-
braic expression. For the expression tree of Figure 6.48, for example, an inorder 
traversal gives the expression
(2 + x) * 4
where the parentheses are added as we complete the processing of a subtree. This 
form of an algebraic expression, where the operation symbol appears between the 
two operands, is called infix notation. Parentheses are necessary here to indicate the 
order of operations. Without parentheses, the expression becomes 2 + x *  4, which 
is also an infix expression but, because of the order of precedence of ­multiplication 
over addition, is not what is intended.
2
x
4
+
*
Figure 6.48
A preorder traversal of Figure 6.48 gives the expression
* + 2 x 4
Here the operation symbol precedes its operands. This form of an expression is 
called prefix notation, or Polish notation.2 The expression can be translated into 
infix form as follows:
* + 2 x 4 S * (2 + x) 4 S (2 + x) * 4
A postorder traversal gives the expression
2 x + 4 *
where the operation symbol follows its operands. This form of an expression is 
called postfix notation, or reverse Polish notation (or just RPN). The expression 
can be translated into infix form as follows:
2 x + 4 * S (2 + x) 4 * S (2 + x) * 4
Neither prefix nor postfix form requires parentheses to avoid ambiguity. These 
notations therefore provide more efficient, if less familiar, representations of alge-
braic expressions than infix notation. Such forms can be evaluated sequentially, 
with no need for “look-ahead” to locate parenthesized expressions. Compilers 
­often change algebraic expressions in computer programs from infix to postfix 
notation for more efficient processing.

	Section 6.2   Trees and Their Representations	
519
Results about Trees
Trees are fertile ground (no pun intended) for proofs by induction, either on the 
number of nodes or arcs or on the height.
Practice 22	 Write the expression tree for
a + (b * c −d)
and write the expression in prefix and postfix notation.	
■
	
Example 29	
After drawing a few trees and doing some counting, it appears that the number 
of arcs in a tree is always one less than the number of nodes. More formally, it 
­appears that
A tree with n nodes has n −1 arcs.
We will prove this statement using induction on n, n ≥1. For the base case, n = 1, 
the tree consists of a single node and no arcs (Figure 6.49), so the number of arcs 
is 1 less than the number of nodes.
n = 1, a = 0
Figure 6.49
Assume that any tree with k nodes has k −1 arcs, and consider a tree with 
k + 1 nodes. We want to show that this tree has k arcs. Let x be a leaf of the tree 
(a leaf must exist since the tree is finite). Then x has a unique parent. Remove from 
the tree the node x and the single arc a connecting x and its parent (Figure 6.50).
The remaining graph is still a tree and has k nodes. Therefore, by the induc-
tive hypothesis, it has k −1 arcs, and the original graph, containing arc a, had 
(k −1) + 1 = k arcs. The proof is complete.
x
a
Figure 6.50
Notice that in the inductive proof of Example 29 we had to support the proof 
with many more words than we used in some of our early inductive proofs. In 
Example 15 in Chapter 2, for instance, the inductive proof that
1 + 2 + 22 + c+ 2n = 2n+1 −1
consisted mainly of manipulating the mathematical expressions in this equation, 
but now we have to do more verbal reasoning. Words are not only acceptable in a 
proof, they may form the major part of the proof.

520	
Graphs and Trees
The inductive proof of Example 29 differs in another way from proofs like that 
of Example 15 in Chapter 2. In those proofs, there was always a single term in the 
series (the last term) whose removal would lead to the “P(k) case,” the inductive hy-
pothesis. In proofs involving trees with k + 1 nodes, which node should be removed 
to generate the P(k) case? Usually the node to remove is not unique, but it is not com-
pletely arbitrary either. In the proof of Example 29, for instance, removing a non-leaf 
node (and the arcs attached to it) from a tree with k + 1 nodes would result in a graph 
with k nodes, but not a tree with k nodes, so the inductive hypothesis would not apply.
Practice 23	 Prove that in any tree with n nodes, the total number of arc ends is 2n −2. Of course this 
result follows directly from Example 29 because n −1 arcs means 2(n −1) = 2n −2 
arc ends, but do a proof by induction on the number of nodes.
	
Example 30	
Recall that a tree T can also be constructed recursively by hooking a root node to a 
collection of subtrees T1, … , Tt (see Figure 6.44). This allows us to use structural 
induction, discussed in Chapter 3, to prove certain results about trees. We’ll use 
structural induction to prove the result of Example 29, namely
A tree with n nodes has n −1 arcs.
The base case where n = 1 is the same as before. Assume that any subtree Ti with 
ni nodes has ni −1 arcs. The tree T constructed from subtrees T1, … , Tt has n 
nodes where
n = 1 + ∙
t
i=1
ni
(The extra 1 is the root node.) Also, T has a arcs where
a = t + ∙
t
i=1
ai
(The extra t counts the arcs from the root of T to the t subtrees.)
By the inductive hypothesis, ai = ni −1 for each subtree, so
a = t + ∙
t
i=1
ai = t + ∙
t
i=1
(ni −1) = t + ∙
t
i=1
ni −∙
t
i=1
1 = t + ∙
t
i=1
ni −t
	
= ∙
t
i=1
ni = n −1	
■
Practice 24	 	Prove that in any tree with n nodes, the total number of arc ends is 2n −2. Use structural 
induction.
■

	Section 6.2   Trees and Their Representations	
521
	
Example 31	
Sometimes a clever observation can take the place of an inductive proof. Every arc 
of a tree connects one node to its parent. Each node of the tree except the root has 
a parent, and there are n −1 such nodes, therefore n −1 arcs. Each arc has two 
arc ends, so there are 2(n −1) arc ends.	
S e c t i o n  6 . 2 	
Review
Techniques
•	 Construct expression trees.
•	 Construct array and pointer representations for  
binary trees.
•	 Conduct preorder, inorder, and postorder traversals 
of a tree.
Main Ideas 
•	 Binary trees can be represented by arrays and by 
linked structures.
•	 Recursive procedures exist to systematically visit 
every node of a tree.
W
Exercises 6.2
	 1.	 Which of the following graphs are trees with root r? If a graph is a tree, draw it in a more conventional 
way. If not, say what property fails.
	
a.	
r	
c.	
r
	
b.		
d.	
r
	 2.	 Which of the following graphs are binary trees with root r? If the graph is not a binary tree, say what 
property fails.
	
a.	
r 	
b.	
r
	
c.	
r
	
d.	 r
	 3.	 Sketch a picture of each of the following trees.
	
a.	 Tree with five nodes and depth 1
	
b.	Full binary tree of depth 2
	
c.	 Tree of depth 3 where each node at depth i has i + 1 children
r

522	
Graphs and Trees
	 4.	 Answer the following questions about the accompanying graph with node a as the root.
	
a.	 Is it a binary tree?
	
b.	Is it a full binary tree?
	
c.	 Is it a complete binary tree?
	
d.	What is the parent of e?
	
e.	 What is the right child of e?
	
f.	 What is the depth of g?
	
g.	What is the height of the tree?
In Exercises 5–8, draw the expression tree.
	 5.	 3(2 * x −3 * y) + 4 * z4 + 1
	 6.	 3(x −2) * 34 + (5 + 4)
	 7.	 1 −(2 −33 −(4 −5)4)
	 8.	 3(6∙2) * 44 + 3(1 + x) * (5 + 3)4
	 9.	 Write the left child–right child array representation for the binary tree in the figure.
1
3
2
4
7
5
6
	 10.	Write the left child–right child array representation for the binary tree in the figure.
1
3
2
8
9 10 11 12 13 14 15
4
5
6
7
	 11.	Draw the binary tree corresponding to the left child–right child representation that follows. (1 is the root.)
Left child
Right child
2
3
4
0
5
0
6
7
0
0
0
0
0
0
1
2
3
4
5
6
7
a
c
b
e f
g
h
i
d

	Section 6.2   Trees and Their Representations	
523
	 12.	Draw the binary tree corresponding to the left child–right child representation that follows. (1 is the root.)
Left child
Right child
2
0
3
4
0
0
5
6
0
0
0
0
1
2
3
4
5
6
	 13.	Write the left child–right child array representation for the binary search tree that is created by processing 
the following list of words: “All Gaul is divided into three parts” (see Exercise 43 of Section 5.1). Also 
store the name of each node.
	 14.	Write the left child–right child array representation for the binary search tree that is created by processing 
the following list of words: “We hold these truths to be self-evident, that all men are created equal” (see 
Exercise 43 of Section 5.1). Also store the name of each node.
	 15.	In the following binary tree representation, the left child and parent of each node are given. Draw the 
binary tree. (1 is the root.)
Left child        Parent
2
0
4
1
0
1
0
2
0
2
0
3
1
2
3
4
5
6
	 16.	The following represents a tree (not necessarily binary) where, for each node, the leftmost child and the 
closest right sibling of that node are given. Draw the tree. (1 is the root.)
Left child
Right sibling
2
0
5
3
0
4
8
0
0
6
0
7
0
0
0
0
1
2
3
4
5
6
7
8

524	
Graphs and Trees
	 17.	a.	For the following tree, write the leftmost child–right sibling array representation described in 
­Exercise 16.
1
2
3
4
5
6
10
7
8
9
11
	
b.	Now draw the binary tree that results from treating the answer to part (a) as a left child–right 
child ­binary tree representation. An arbitrary tree can thus be thought of as having a binary tree 
­representation.
	 18.	The following binary tree is the representation of a general tree (as in part (b) of Exercise 17). Draw the 
tree.
1
3
2
4
7
6
8
5
9
For Exercises 19–24, write the list of nodes resulting from a preorder traversal, an inorder traversal, and a 
­postorder traversal of the tree.
	 19.	
a
b
d
e
f
g
c
h
	
20.	
a
b
d
e
f
c
g
h
	

	Section 6.2   Trees and Their Representations	
525
21.	
a
b
c
e
f
g
h
i
d
j
	
23.	
a
d
c
b
e
f
g
h
22.	
a
b
c
e
f
g
h
i
d
	
24.	
a
b
c
d
e
f
g
h
i
	 25.	Write in prefix and postfix notation: 3∙4 + (2 −y).
	 26.	Write in prefix and postfix notation: (x * y + 3∙z) * 4.
	 27.	Write in infix and postfix notation: − * + 2 3 * 6 x 7.
	 28.	Write in infix and postfix notation: −+ − x y z w.
	 29.	Write in prefix and infix notation: 4 7 x −*  z + .
	 30.	Write in prefix and infix notation: x 2 w + y z * −∙.
	 31.	Evaluate the postfix expression 8 2 ∙ 2 3 * + .
	 32.	Evaluate the postfix expression 5 3 + 1 3 + ∙ 7 *.
	 33.	Draw a single tree whose preorder traversal is
a, b, c, d, e 
and whose inorder traversal is
b, a, d, c, e 
	 34.	Draw a single tree whose inorder traversal is
f, a, g, b, h, d, i, c, j, e 
and whose postorder traversal is
f, g, a, h, i, d, j, e, c, b
	 35.	Find an example of a tree whose inorder and postorder traversals yield the same list of nodes.
	 36.	Find two different trees that have the same list of nodes under a preorder traversal.
	 37.	Informally describe a recursive algorithm to compute the height of a binary tree, given the root node.
	 38.	Informally describe a recursive algorithm to compute the number of nodes in a binary tree, given the root node.
	 39.	Prove that a simple graph is a nonrooted tree if and only if there is a unique path between any two nodes.

526	
Graphs and Trees
	 40.	What is the minimum number of nodes and arcs that need to be deleted to reduce a full binary tree of 
height ≥2 to a forest of 4 binary trees?
	 41.	Let G be a simple graph. Prove that G is a nonrooted tree if and only if G is connected and if the removal 
of any single arc from G makes G unconnected.
	 42.	Let G be a simple graph. Prove that G is a nonrooted tree if and only if G is connected and the addition of 
one arc to G results in a graph with exactly one cycle.
	 43.	Prove that a binary tree has at most 2d nodes at depth d.
	 44.	Prove that a tree with n nodes, n ≥2, has at least two nodes of degree 1.
	 45.	a.	 Draw a full binary tree of height 2. How many nodes does it have?
	
b.	Draw a full binary tree of height 3. How many nodes does it have?
	
c.	 Conjecture how many nodes there are in a full binary tree of height h.
	 46.	Prove your conjecture from Exercise 45(c) three different ways.
	
a.	 Use induction on the height h of the full binary tree. (Hint: Use Exercise 43.)
	
b.	Add up the nodes at each level of the tree (Hint: Use Exercise 43).
	
c.	 Use structural induction.
	 47.	a.	 Prove that a full binary tree with x internal nodes has 2x + 1 total nodes.
	
b.	Prove that a full binary tree with x internal nodes has x + 1 leaves.
	
c.	 Prove that a full binary tree with n nodes has  (n −1)∙2 internal nodes and (n + 1)∙2  leaves.
	 48.	Prove that the number of leaves in any binary tree is 1 more than the number of nodes with two children.
	 49.	Find an expression for the height of a complete binary tree with n nodes. (Hint: Use Exercise 45.)
	 50.	Prove that in the pointer representation of a binary tree with n nodes there are n + 1 null pointers.  
(Hint: Use Exercise 48).
	 51.	Find the chromatic number of a tree (see Section 6.1, Exercise 80).
	 52.	Let E be the external path length of a tree, that is, the sum of the path lengths to all the leaves. Let I be the 
internal path length, that is, the sum of the path lengths to all the internal nodes. Let i be the number of 
internal nodes. Prove that in a binary tree where all internal nodes have two children, E = I + 2i.
	 53.	Let B(n) represent the number of different binary trees with n nodes.
	
a.	 Define B(0) to have the value 1 (there is one binary tree with 0 nodes). Prove that B(n) is given by the 
recurrence relation
B(1) = 1
B(n) = ∙
n−1
k=0
B(k)B(n −1 −k)
	
b.	Compare the sequence B(n) to the sequence of Catalan numbers  (Exercise 97, Section 4.4). Write the 
closed-form expression for B(n).
	
c.	 Compute the number of different binary trees with 3 nodes. Draw all these trees.
	
d.	Compute the number of different binary trees with 6 nodes.
	 54.	In the data structure known as a B-tree of order 5, each node of the tree can contain multiple data values, 
maintained in sorted order. Between and around the data values at an internal node are arcs that lead to 
children of the node. New data values are inserted into the leaf nodes of the tree, but when a leaf (or in-
ternal node) gets up to five values, it splits in two and the median value pops up to the next level of the 
tree. The figure shows the tree at various points as the data values 1 through 8 are inserted into an initially 
empty tree.

	Section 6.2   Trees and Their Representations	
527
	
a.	 The minimum number of data values to insert into a B-tree of order 5 to force it to have two levels is 5. 
Find the minimum number of data values required to force the tree to have three levels.
	
b.	Prove that when a B-tree of order 5 has the minimum number of data values to force it to have n levels, 
n ≥2, the bottom level contains 2(3n−2) nodes.
	
c.	 Find (and justify) a general expression for the minimum number of data values required to force a  
B-tree of order 5 to have n levels. aHint: 30 + 31 + c+ 3n−2 = a3n −3
6
b.b
In Exercises 55 and 56, two trees are isomorphic if there is a bijection f: N1 S N2, where f maps the root of 
one tree to the root of the other and where f (y) is a child of f (x) in the second tree when y is a child of x in the 
first tree. Thus the two trees shown are isomorphic graphs but not isomorphic trees (in part (a) the root has two 
children and in part (b) it does not). These are the only two nonisomorphic trees with three nodes.
r
r
(b)
(a)
	 55.	Draw all the nonisomorphic trees with four nodes.
	 56.	Draw all the nonisomorphic trees with five nodes.
	 57.	One of the most efficient sorting algorithms is HeapSort, which sorts an array of values into increasing 
order. To understand how the HeapSort algorithm works, it is best to imagine that the array elements are 
stored in level order as the nodes of a binary tree. Thus the values in a 7-element array that is indexed from 
0 through 6 would be stored in a binary tree with element 0 at the root, elements 1 and 2 at depth 1, and 
so on.
1
3
4
5
2
6
0
A heap is a binary tree in which the value at every node is greater than the value at its two child nodes. 
HeapSort is a two-phase process. The first phase is to reorganize the tree elements into a heap (more on 
this later), and the second is to sort the heap. The key idea is that in a heap, the largest element is the root of 
the tree; its proper place in the sorted array is at the end of the unsorted section of the array (at the lowest, 
rightmost tree element not yet in its sorted position). The tree root gets thrown to the last unsorted posi-
tion, and the element that formerly occupied that position must be inserted back into the unsorted section 
in such a way as to preserve the heap property. Consider the following binary tree, which is a heap—each 
node value is larger than the values at the two child nodes.
1, 2, 3, 4
1, 2
1, 2
4, 5
4, 5
3
3, 6
7, 8

528	
Graphs and Trees
f
k
m
p
c
a
s
	
	 The root value, s, belongs at the bottom right of the tree (the position of the last array element), and once 
positioned there, s will never be looked at again. The previous value, m, has been temporarily displaced.
f
k
m
p
c
a
s
To insert m back into the heap, there is a series of “competitions” between the displaced element and 
the child nodes of the empty node so that the largest value is promoted to fill the empty slot. Here m, k, 
and p compete, and p is the winner.
f
k
m
p
c
a
s
	
	 Now m and f compete (remember that s is no longer considered), the largest value is m, and once m is 
inserted, the heap has been reestablished.
f
k
m
p
c
a
s
	
a.	 Complete phase 2 of the process so that the array is sorted. (Hint: The next step is to throw the root 
value, p, into the position currently occupied by f. The displaced value f must then be reinserted into 
the tree.)
	
b.	For phase 1, to construct the heap, put the original random elements into the binary tree. Consider the 
leaf nodes to be temporarily in place, since their relative order does not matter. Beginning with the 
rightmost node in the level above the leaves and working up level-by-level to the root, temporarily 
displace that node element and then insert it using the “competition” rules described. Beginning with 
the array r, w, f, g, k, y, d, construct a heap.

Section 6.3   Decision Trees	
529
Although we have used decision trees, we haven’t given a formal definition of 
what a decision tree is.
	
Definition	
Decision Tree
A decision tree is a tree in which the internal nodes represent actions, the arcs 
represent outcomes of an action, and the leaves represent final outcomes.
Sometimes useful information can be obtained by using a decision tree to rep-
resent the activities of a real algorithm; actions that the algorithm performs take 
place at internal nodes, the children of an internal node represent the next action 
taken, based on the outcome of the previous action, and the leaves represent some 
sort of circumstance that can be inferred upon algorithm termination. Note that, 
unlike the trees we talked about in Section 6.2, a decision tree is not a data struc-
ture; that is, the nodes of the tree have no data values associated with them. Nor 
are the algorithms we are representing necessarily acting on a tree structure. In 
fact, we will use decision trees in this section to learn more about algorithms for 
searching and sorting, and these algorithms act on lists of data items.
Searching
A search algorithm either finds a target element x within a list of elements or de-
termines that x is not in the list. Such an algorithm generally works by making  
	
S e c t i o n  6 . 3 	 Decision Trees
We used decision trees in Chapter 4 to solve counting problems. Figure 6.51 shows 
the tree used in Example 39 of Chapter 4 to represent the various possibilities for 
five coin tosses under the constraint that two heads in a row do not occur. Each 
internal node of the tree represents an action (a coin toss), and the arcs to the chil-
dren of internal nodes represent the outcomes of that action (heads or tails). The 
leaves of the tree represent the final outcomes, that is, the different ways that five 
tosses could occur.
T
H
T
T
T
H
H
T
H
T
H
H
T
H
T
T
H
T
T
T
H
H
T
T
H
T
H
T
T
T
T
H
T
T
T
H
T
T
H
T
T
H
T
H
T
H
T
T
H
T
T
T
H
T
T
T
H
H
T
T
T
H
T
T
H
T
H
T
T
H
T
T
T
T
T
T
H
T
T
T
H
T
T
T
T
T
T
H
T
T
T
H
H
T
H
T
Toss 1
Toss 2
Toss 5
Toss 4
Toss 3
Figure 6.51

530	
Graphs and Trees
successive comparisons of x to the list items. We have already seen two such algo-
rithms, sequential search and binary search. We can model the activities of these 
algorithms by using decision trees. The nodes represent the actions of comparing x 
to the list items, where the comparison of x to the ith element in the list is denoted 
by x:L3i4.
Sequential search only distinguishes between two possible outcomes of a com-
parison of x to L3i4. If x = L3i4, the algorithm terminates because x has been found 
in the list. If x ∙L3i4, the next comparison performed is x:L3i + 14, regardless of 
whether x was less than or greater than L3i4. The leaves of this decision tree corre-
spond to the final outcomes, where either x is one of the list items or x is not in the list.
	
EXAMPLE 32	
Figure 6.52 shows the decision tree for the sequential search algorithm acting on a 
list of five elements.
x:L[1]
x = L[1]
=
≠
x:L[2]
x = L[2]
=
≠
x:L[3]
x = L[3]
=
≠
x:L[4]
x = L[4]
=
≠
x:L[5]
x = L[5]
x ∉L
=
≠
Figure 6.52	
From the decision tree for a given search algorithm, we can see that the number 
of comparisons required to reach any particular outcome (leaf of the tree) is the 
number of internal nodes from the root to that leaf. This number equals the length of 
the path from the root to that leaf. The worst case, that is, the maximum number of 
comparisons, is the maximum length of any such path, which is the depth of the tree.
Because every decision tree for sequential search looks like Figure 6.52, it is 
clear that the depth of such a tree, for an n-element list, is n. This agrees with what 
we already know, namely, that the worst case for sequential search on a list of n 
elements is n.
The decision tree for the binary search algorithm is more interesting. Binary 
search acts on a sorted list and distinguishes between three possible outcomes of 
the comparison:

Section 6.3   Decision Trees	
531
x = L3i4: algorithm terminates, x has been found
x < L3i4: algorithm proceeds to the left half of the list
x > L3i4: algorithm proceeds to the right half of the list
We will follow the usual custom and not write the leaf that corresponds to the 
“middle branch,” x = L3i4 (see Exercise 21 for a discussion of the consequences of 
this convention). If x < L3i4, the next comparison the algorithm performs is found 
at the left child of this node; if x > L3i4, the algorithm’s next comparison is found 
at the right child. If no child exists, the algorithm terminates because x is not in 
the list. The tree we’ve described is a binary tree whose leaves represent all the 
possible outcomes where x is not in the list. There are many more failure leaves 
in binary search than in sequential search, because binary search indicates how x 
fails to be in the list (e.g., x < L314 or L314 < x < L324).
	
Example 33	
Figure 6.53 shows the decision tree for the binary search algorithm acting on a 
sorted list of eight elements.
The worst case, that is, the maximum number of comparisons, will again be 
the depth of the tree, which is 4 in Figure 6.53. In Chapter 3 we solved a recurrence 
relation to get the worst-case behavior for binary search where n is a power of 2 
and found this to be 1 + log n (remember that we are using base 2 logarithms). 
Note that 1 + log 8 = 4, so the decision tree agrees with our previous result. The 
restriction of n to a power of 2 made the arithmetic of solving the recurrence re-
lation simpler. If n is not a power of 2, then the depth of the tree is given by the 
expression 1 + :log n; .
<
>
x > L[8]
x:L[8]
L[7] < x < L[8]
<
>
x:L[6]
<
>
<
>
x:L[7]
x:L[5]
L[6] < x < L[7]
L[4] < x < L[5]
<
<
>
>
x:L[2]
x:L[4]
<
>
<
>
x:L[3]
x:L[1]
L[2] < x < L[3]
x < L[1]
L[1] < x < L[2]
L[3] < x < L[4]
L[5] < x < L[6]
Figure 6.53	

532	
Graphs and Trees
Practice 25	
a.	 Draw the decision tree for the binary search algorithm on a sorted list of five elements.
b.	Find the depth of the tree and compare to 1 + :log 5;.	
■
Lower Bounds on Searching
We have used decision trees to represent the actions of two particular search al-
gorithms. Such a tree could be used to represent the actions of any algorithm that 
solves the search problem by comparing the target element to the list elements. 
The internal nodes of such a tree would represent the comparisons done, and the 
depth of the tree would be the worst-case number of comparisons over all possible 
cases. What can be said about such a tree when we don’t know the particulars of 
the algorithm involved? We can say that x must be compared to every element 
in the list at least once (perhaps more than once if the algorithm is quite stupid). 
For if there is some list element that escapes being compared to x, the algorithm 
cannot say whether that element equals x and thus cannot decide with certainty 
whether x belongs to the list. Comparisons are internal nodes in the decision tree. 
Therefore, if m is the number of internal nodes in the decision tree T1 for any 
search algorithm acting on an n-element list, then m ≥n.
Before proceeding further with decision trees, we need some additional facts 
about binary trees in general. The number of nodes at each level in a full binary tree 
follows a geometric progression: 1 node at level 0, 21 nodes at level 1, 22 nodes at ­level 
2, and so on. In a full binary tree of depth d, the total number of nodes is therefore
1 + 2 + 22 + 23 + c+  2d = 2d+1 −1
(see Example 15 of Chapter 2). A full binary tree has the maximum number of 
nodes for a given depth of any binary tree. This gives us fact 1:
	
1.	 Any binary tree of depth d has at most 2d+1 −1 nodes.
Fact 2, which we’ll prove momentarily, is
	
2.	 Any binary tree with m nodes has depth ≥:log m;.
To prove fact 2, we’ll use a proof by contradiction. Suppose a binary tree has m 
nodes and depth d < :log m;. Then d ≤:log m; −1. From fact 1,
 m ≤2d+1 −1 ≤2(:log m;−1) +1 −1
 = 2:log m; −1 ≤2log m −1 = m −1
or
m ≤m −1 
—a contradiction. Therefore d ≥:log m;.
Now back to decision trees representing search algorithms on n-element 
lists. Temporarily strip the leaves from tree T1 (with m internal nodes) to create a 
new tree T2 with m nodes, m ≥n. By fact 2, T2 has depth d ≥:log m; ≥:log n;. ­ 

Section 6.3   Decision Trees	
533
Therefore tree T1 has depth ≥:log n; + 1. Because the depth of the decision 
tree gives the worst-case number of comparisons, we can state the following 
theorem.
	
Theorem	
On the Lower Bound for Searching
Any algorithm that solves the search problem for an n-element list by comparing 
the target element x to the list items must do at least :log n; + 1 comparisons in 
the worst case.
This theorem gives us a lower bound on the number of comparisons required 
in the worst case for any algorithm that uses comparisons to solve the search prob-
lem. Since binary search does no more work than this required minimum amount, 
binary search is an optimal algorithm in its worst-case behavior.
Binary Tree Search
The binary search algorithm requires that data already be sorted. Arbitrary data 
can be organized into a structure called a binary search tree, which can then be 
searched using a different algorithm called binary tree search. To build a binary 
search tree, the first item of data is made the root of the tree. Successive items are 
inserted by comparing them to existing nodes, beginning with the root. If the item 
is less than a node, the next node tested is the left child; otherwise it is the right 
child. When no child node exists, the new item becomes the child.
	
Example 34	
The data items
5, 8, 2, 12, 10, 14, 9
are to be organized into a binary search tree. Figure 6.54 shows the successive 
stages of constructing the tree.
8
2
5
8
12
2
5
8
12
10
2
5
8
12
10
14
2
5
8
14
12
10
9
2
5
8
5
5
Figure 6.54	

534	
Graphs and Trees
A binary search tree, by the way it is constructed, has the property that 
the value at each node is greater than all values in its left subtree (the subtree 
rooted at its left child) and less than all values in its right subtree. A binary 
tree search compares item x with a succession of nodes beginning with the 
root. If x equals the node item, the algorithm terminates; if x is less than the 
item, the left child is checked next; if x is greater than the item, the right 
child is checked next. If no child exists, the algorithm terminates because x 
is not in the list. Thus the binary search tree, except for the leaves, becomes 
the decision tree for the binary tree search algorithm. (Here is a case where 
the algorithm itself is described in terms of a tree.) The worst-case number of 
comparisons equals the depth of the tree plus 1 (for the missing leaves). How-
ever, a binary search tree for a given set of data is not unique; the tree (and 
hence the depth of the tree) depends on the order in which the data items are 
inserted into the tree.
The actions performed in a binary tree search certainly resemble those in 
the “regular” binary search algorithm; in both cases the procedure is to make a 
comparison and, if unsuccessful, to look left or right (in the tree if it is a binary 
tree search or in the list if it is a binary search). It is possible to order the data for a 
binary tree search such that the search tree built from these data matches the deci-
sion tree (minus the leaves) for a binary search of the same data in sorted order. 
This match is illustrated in Example 35 (note that the tree was not built from data 
items in sorted order). Here the binary search tree has the minimum depth and 
requires the least amount of work in the worst case.
The depth of a binary search tree for a given set of data items can vary. The 
depth of the tree in Figure 6.54 is 4, while that of Figure 6.55 is 2. Thus the worst-
case number of comparisons to search for an item can also vary. The tree-building 
process can be modified to keep the tree more “balanced,” that is, short and wide 
rather than tall and skinny; such a modification reduces the depth of the tree and 
therefore the search time. Of course, we know from the theorem on the lower 
bound for searching that a certain minimum amount of work is required no matter 
how clever we are in building the tree.
	
Example 35	
The data in Example 34 entered in the order
9, 12, 10, 5, 8, 2, 14
produce the binary search tree of Figure 6.55.
9
12
5
2
8
10
14
Figure 6.55	

Section 6.3   Decision Trees	
535
Sorting
Decision trees can also model algorithms that sort a list of items by a sequence of com-
parisons between two items from the list. The internal nodes of such a decision tree 
are labeled L3i4:L3   j4 to indicate a comparison of list item i to list item j. To simplify 
our discussion, let’s assume that the list does not contain duplicate items. Then the 
outcome of such a comparison is either L3i4 < L3   j4 or L3i4 > L3   j4 . If L3i4 < L3   j4, 
the algorithm proceeds to the comparison indicated at the left child of this node; if 
L3i4 > L3   j4, the algorithm proceeds to the right child. If no child exists, the algo-
rithm terminates because the sorted order has been determined. The tree is a binary 
tree, and the leaves represent the final outcomes, that is, the various sorted orders.
Practice 26	
a.	 Construct the binary search tree for the data of Example 34 entered in the order
12, 9, 14, 5, 10, 8, 2
b.	What is the depth of the tree?	
■
	
Example 36	
Figure 6.56 shows the decision tree for a sorting algorithm acting on a list of 
three elements. This algorithm is not particularly astute because it ignores the 
transitive property of < and therefore performs some unnecessary compari-
sons. The leaves of the tree indicate the various final outcomes, including two 
cases (marked with an X ) that result from contradictory information. For ex-
ample, one X results from the following inconsistent sequence of outcomes:  
L314 < L324, L324 < L334, L314 > L334.
<
>
<
>
<
>
L[2] < L[3] < L[1]
L[2] < L[1] < L[3]
X
X
<
<
>
>
L[1]:L[2]
<
>
<
>
L[1]:L[3]
L[1]:L[3]
L[2]:L[3]
L[2]:L[3]
L[2]:L[3]
L[1]:L[3]
L[1] < L[3] < L[2]
L[1] < L[2] < L[3]
L[3] < L[1] < L[2]
L[3] < L[2] < L[1]
Figure 6.56	
Practice 27	 Draw the decision tree that would result if the algorithm of Example 36 were modified to 
eliminate unnecessary comparisons.
■

536	
Graphs and Trees
A decision tree argument can also be used to establish a lower bound on the 
worst-case number of comparisons required to sort a list of n elements. As we did 
for the search problem, let us see what we can say about a decision tree for sort-
ing based on comparisons, regardless of the algorithm it represents. The leaves of 
such a tree represent the final outcomes, that is, the various ordered arrangements 
of the n items. There are n! such arrangements, so if p is the number of leaves in 
the decision tree, then p ≥n!. The worst case will equal the depth of the tree. But 
it is also true that if the tree has depth d, then p ≤2d (Exercise 43 of Section 6.2). 
Taking the base 2 logarithm of both sides of this inequality, we get log p ≤d or, 
because d is an integer, d = <log p=. Finally, we obtain
d = <log p= ≥<log n!=
This result proves the following theorem.
	
Theorem	
On the Lower Bound for Sorting
Any algorithm that sorts an n-element list by comparing pairs of items from the 
list must do at least <log n!= comparisons in the worst case.
It can be shown (Exercise 23) that log n! = Θ(n log n). Therefore we have 
proved that sorting n elements by comparing pairs of list items is bounded below 
by Θ(n log n), whereas searching by comparing the target element to the list items 
is bounded below by Θ(log n). As expected, it takes more work to sort than to 
search.
S e c t i o n  6 . 3 	
Review
Techniques
•	 Draw decision trees for sequential search and bi-
nary search on n-element lists.
•	 Create a binary search tree.
Main Ideas
•	 Decision trees represent the sequences of possible 
actions for certain algorithms.
•	 Analysis of a generic decision tree for algorithms 
that solve a certain problem may lead to lower 
bounds on the minimum amount of work needed to 
solve the problem in the worst case.
•	 The task of searching an n-element list for a target 
value x, if done by comparing x to elements in the 
list, requires at least :log n; + 1 comparisons in the 
worst case.
•	 The task of sorting an n-element list, if done by 
comparing pairs of list elements, requires at least 
:log n!; comparisons in the worst case.
W
W
Exercises 6.3
	 1.	 Draw the decision tree for sequential search on a list of three elements.
	 2.	 Draw the decision tree for sequential search on a list of six elements.
	 3.	 Draw the decision tree for binary search on a sorted list of seven elements. What is the depth of the tree?
	 4.	 Draw the decision tree for binary search on a sorted list of four elements. What is the depth of the tree?

Section 6.3   Decision Trees	
537
	 5.	 Consider a search algorithm that compares an item with the last element in a list, then the first element, 
then the next-to-last element, then the second element, and so on. Draw the decision tree for searching a 
six-element sorted list. What is the depth of the tree? Does it appear that this is an optimal algorithm in the 
worst case?
	 6.	 Consider a search algorithm that compares an item with an element one-third of the way through the list; 
based on that comparison, it then searches either the first one-third or the second two-thirds of the list. 
Draw the decision tree for searching a nine-element sorted list. What is the depth of the tree? Does it ap-
pear that this is an optimal algorithm in the worst case?
	 7.	 a.	 Given the data
9, 5, 6, 2, 4, 7
	
	
construct the binary search tree. What is the depth of the tree?
	
b.	Find the average number of comparisons done to search for an item that is known to be in the list 
using binary tree search on the tree of part (a). (Hint: Find the number of comparisons for each of the 
items.)
	 8.	 a.	 Given the data
g, d, r, s, b, q, c, m
	
	
construct the binary search tree. What is the depth of the tree?
	
b.	Find the average number of comparisons done to search for an item that is known to be in the list 
using binary tree search on the tree of part (a). (Hint: Find the number of comparisons for each of the 
items.)
	 9.	 a.	For a set of six data items, what is the minimum worst-case number of comparisons a search algorithm 
must perform?
	
b.	Given the set of data items 5a, d, g, i, k, s6, find an order in which to enter the data so that the corre-
sponding binary search tree has the minimum depth.
	 10.	a.	For a set of nine data items, what is the minimum worst-case number of comparisons a search algorithm 
must perform?
	
b.	Given the set of data items 54, 7, 8, 10, 12, 15, 18, 19, 216, find an order in which to enter the data so 
that the corresponding binary search tree has the minimum depth.
	 11.	An inorder tree traversal of a binary search tree produces a listing of the tree nodes in alphabetical or 
­numerical order. Construct a binary search tree for “To be or not to be, that is the question,” and then do 
an inorder traversal.
	 12.	Construct a binary search tree for “In the high and far-off times the Elephant, O Best Beloved, had no 
trunk,” and then do an inorder traversal. (See Exercise 11.)
	 13.	Use the theorem on the lower bound for sorting to find lower bounds on the number of comparisons 
­required in the worst case to sort lists of the following sizes:
	
a.	 4	
b.	8	
c.	16
	 14.	Contrast the number of comparisons required for selection sort and merge sort in the worst case with the 
lower bounds found in Exercise 13 (see Exercise 23 in Section 3.3). What are your conclusions?
Exercises 15–20 concern the problem of identifying a counterfeit coin (one that is two heavy or too light) from 
a set of n coins. A balance scale is used to weigh a group of any number of coins from the set against a like 
number of coins from the set. The outcome of such a comparison is that group A weighs less than, the same as, 
or more than group B. A decision tree representing the sequence of comparisons done will thus be a ternary tree, 
where an internal node can have three children.

538	
Graphs and Trees
 15. One of five coins is counterfeit and is lighter than the other four. The problem is to identify the counterfeit coin.
 
a. What is the number of final outcomes (the number of leaves in the decision tree)?
 
b. Find a lower bound on the number of comparisons required to solve this problem in the worst case.
 
c. Devise an algorithm that meets this lower bound (draw its decision tree).
 16. One of five coins is counterfeit and is either too heavy or too light. The problem is to identify the counter-
feit coin and determine whether it is heavy or light.
 
a. What is the number of final outcomes (the number of leaves in the decision tree)?
 
b. Find a lower bound on the number of comparisons required to solve this problem in the worst case.
 
c. Devise an algorithm that meets this lower bound (draw its decision tree).
 17. One of four coins is counterfeit and is either too heavy or too light. The problem is to identify the counter­
feit coin but not to determine whether it is heavy or light.
 
a. What is the number of final outcomes (the number of leaves in the decision tree)?
 
b. Find a lower bound on the number of comparisons required to solve this problem in the worst case.
 
c. Devise an algorithm that meets this lower bound (draw its decision tree).
 18. One of four coins is counterfeit and is either too heavy or too light. The problem is to identify the counter­
feit coin and determine whether it is heavy or light.
 
a. What is the number of final outcomes (the number of leaves in the decision tree)?
 
b. Find a lower bound on the number of comparisons required to solve this problem in the worst case.
 
c. Prove that no algorithm exists that can meet this lower bound. (Hint: The first comparison can be made 
with either two coins or four coins. Consider each case.)
 19. Devise an algorithm to solve the problem of Exercise 18 using three comparisons in the worst case.
 20. One of eight coins is counterfeit and is either too heavy or too light. The problem is to identify the counter­
feit coin and determine whether it is heavy or light.
 
a. What is the number of final outcomes (the number of leaves in the decision tree)?
 
b. Find a lower bound on the number of comparisons required to solve this problem in the worst case.
 
c. Devise an algorithm that meets this lower bound (draw its decision tree).
 21. In the decision tree for the binary search algorithm (and the binary tree search algorithm), we have ­counted 
each internal node as one comparison. For example, the top of Figure 6.53 looks like this:
 
 To get to either of the child nodes of the root, we have assumed that one comparison has been done. 
­However, the outcome of the comparison at each internal node is really a three-way branch:
x = node element
x < node element
x > node element
 
 Think about how this three-way branch would be implemented in most programming languages, and write 
a more accurate expression than 1 + :log n;  for the number of comparisons in the worst case.

	Section 6.4   Huffman Codes	
539
	 22.	Our existing binary search algorithm (Chapter 3, Example 13) contains the pseudocode instruction
find the index k midway between i and j
	
	 after which the target x is compared to the list item at index k, the “midpoint item.” Suppose that this in-
struction is replaced by
	
	 if i = j then
k =  j
	
	 else
k = i + 1 
	
	 end if
	
a.	 Draw the decision tree that results from using the modified algorithm on a sorted list with n = 8.
	
b.	Give the exact number of comparisons required (see Exercise 21) in the worst case for n = 8.
	
c.	 Give a worst-case order-of-magnitude expression for the number of comparisons required as a func-
tion of n, and justify your expression. Comment on the use of this algorithm as opposed to the original 
binary search algorithm, which is Θ(log n).
	 23.	To prove that log n! = Θ(n log n), we can use the definition of order of magnitude (see 
­Section 5 of Chapter 5) and show that there exist positive constants n0, c1, and c2  such that for 
n ≥n0, c1(n log n) ≤log n! ≤c2(n log n).
	
a.	 Show that for n ≥1,log n! ≤n log n. (Hint: Use the definition of n! and properties of logarithms.)
	
b.	Show that for n ≥4, log n! ≥(14)(n log n). (Hint: Use the definition of n! and properties of 
­logarithms, but stop at log<n2= .)
	
S e c t i o n  6 . 4 	 Huffman Codes
Problem and Trial Solution
Character data consist of letters of the alphabet (both uppercase and lowercase), 
punctuation symbols, and other keyboard symbols such as @ and %. Computers 
store character data in binary form, as a sequence of 0s and 1s, usually by  fixing 
some length n so that 2n is at least as large as the number of distinct characters 
and then encoding each distinct character as a particular sequence of n bits. Each 
character must be encoded into its fixed binary sequence for electronic storage, and 
then the binary sequence must be decoded when the character is to be displayed. 
The most common encoding scheme for many years was ASCII (American Stan-
dard Code for Information Interchange), which uses n = 8, so that each character 
requires 8 bits to store. However, 28 = 256, so a maximum of 256 characters could 
be encoded. This was enough for the English alphabet, punctuation, and special 
characters, but as electronic data storage spread around the world, it was not enough 
to include characters found in other languages such as Russian, Japanese, Arabic, 
Greek, and many others. Unicode (in general) uses 16 bits to encode a single char-
acter, so that 216 = 65536 character encodings are now available. But whatever 
value is chosen for n, each character requires the same amount of storage space.
Suppose a collection of character data to be stored in a file in binary form is 
large enough that the amount of storage required is a consideration. Suppose also 
that the file is archival in nature, and its contents will not often be changed. Then 

540	
Graphs and Trees
Practice 28	 Using the variable-length code of Example 37, decode each of the following strings:
a.	 11111111010100
b.	1101010101100
c.	 100110001101100
■
it may be worthwhile to invest some extra effort in the encoding process if the 
amount of storage space required for the file could be reduced.
Rather than using a fixed number of bits per character, an encoding scheme could 
use a variable number of bits and store frequently occurring characters as sequences 
with fewer bits. To store all the distinct characters, some sequences will still have to be 
long, but if the longer sequences are used for characters that occur less frequently, the 
overall storage required should be reduced. This approach requires knowledge of the 
particular file contents, which is why it is best suited for a file whose contents will not 
be frequently changed. We will study such a data compression or data compaction 
scheme here, because it is best described as a series of actions taken on binary trees.
	
Example 37	
As a trivial example, suppose that a collection of data contains 50,000 instances 
of the six characters a, c, g, k, p, and ?, which occur with the following percent 
frequencies:
Character	
a	
c	
g	
k	
p	
?
Frequency	
48	
9	
12	
4	
17	
10
Because six distinct characters must be stored, the fixed-length scheme would 
­require at a minimum three bits for each character (23 = 8 ≥6). The total storage 
required would then be 50,000 * 3 = 150,000  bits. Suppose instead that the fol-
lowing encoding scheme is used:
Character	
a	
c	
g	
k	
p	
?
Encoding scheme	
0	
1101	
101	
1100	
1l1	
100
Then the storage requirement (number of bits) is
50,000 (0.48 * 1 + 0.09 * 4 + 0.12 * 3 + 0.04 * 4 + 0.17 * 3 + 0.10 * 3) = 108,500
which is roughly two-thirds of the previous requirement.	
In the fixed-length storage scheme with n bits for each character, the long 
string of bits within the encoded file can be broken up into the code for successive 
characters by simply looking at n bits at a time. This makes it easy to decode the 
file. In the variable-length code, there must be a way to tell when the sequence for 
one character ends and the sequence for another character begins.
In Practice 28 the strings can be broken into the representation of characters 
in only one way. As each new digit is considered, the possibilities are narrowed 
as to which character is being represented until the character is uniquely identi-
fied by the end of that character’s representation. There is never any need to guess 

	Section 6.4   Huffman Codes	
541
at what the character might be and then backtrack if our guess proves wrong. 
This ability to decode uniquely without false starts and backtracking comes about 
­because the code is an example of a prefix code. In a prefix code, the code for any 
character is never the prefix of the code for any other character. (A prefix code is 
therefore an “antiprefix” code!)
	
Example 38	
Consider the code
Character	
a	
b	
c
Encoding scheme	
01	
101	
011
which is not a prefix code. Given the string 01101, it could represent either ab 
(01–101) or ca (011–01). Furthermore, in processing the string 011011 digit by 
digit as a computer would do, the decoding could begin with ab (01–101) and only 
encounter a mismatch at the last digit. Then the process would have to go all the 
way back to the first digit in order to recognize cc (011–011).	
As an aside, Morse code is a variable-length code. Morse’s encoding scheme 
for telegraphic communication, invented in 1838, uses strings of dots and dashes 
to represent letters of the alphabet. The most frequently occurring letter of the 
­alphabet in English text is the letter “e,” which is assigned the shortest code, a 
single dot. The Morse code for
“hello world”
is
“.... . .-.. .-.. --- .-- --- .-. .-.. -..”
Here you can see that “e” is a single dot, that “l” is dot-dash-dot-dot, and that “r” 
is dot-dash-dot. Morse code is not a prefix code, however; note that the “r” code is 
the first part of the “l” code. To avoid this kind of ambiguity, Morse code inserts 
a pause between the code for each letter. To decode, you wait for the pause and at 
that point you have the code for exactly one letter.
In our approach to prefix codes, we will build binary trees with the characters 
as leaves. Once the tree is built, a binary code can be assigned to each character 
by simply tracing the path from the root to that leaf, using 0 for a left branch and 1 
for a right branch. Because no leaf precedes any other leaf on some path from the 
root, the code will be a prefix code. The binary tree for the code of Example 37 is 
shown in Figure 6.57.
?
g
a
p
c
k
Figure 6.57

542	
Graphs and Trees
Suppose a code tree T exists, with leaves representing characters. For any 
leaf i, its depth d(i) in T equals the number of bits in the code for the corre-
sponding character. Let f(i) denote the percentage frequency of that character 
in the data to be stored, and let S be the total number of characters to be stored. 
Then, just as in Example 37, the total number of bits required is given by the 
expression
S * c ∙
all leaves i
(d(i)f(i))d
We seek to build an optimal tree T, one for which the expression
	
E(T ) = c ∙
all leaves i
(d(i)f(i))d 	
(1)
is a minimum and hence the file size is a minimum.
This process could be done by trial and error, because there is only a finite 
number of characters and thus only a finite number of ways to construct a tree and 
assign characters to its leaves. However, the finite number quickly becomes very 
large! Instead we will use the algorithm known as Huffman encoding.
Huffman Encoding Algorithm
Suppose, then, that we have m characters in a file and we know the percentage 
frequency of each character. The algorithm to build the tree works by maintain-
ing a list L of nodes that are roots of binary trees. Initially L will contain m roots, 
each labeled with the frequency of one of the characters; the roots will be ordered 
according to increasing frequency, and each will have no children. A pseudocode 
description of the algorithm follows.
	
Algorithm	
HuffmanTree
HuffmanTree (node list L; integer m) 
//Each of the m nodes in L has an associated frequency f, and L is
//ordered by increasing frequency; algorithm builds the Huffman tree
for (i = 1 to m −1) do
create new node z
let x, y be the first two nodes in L	
//minimum frequency nodes
f(z) = f(x) + f( y) 
insert z in order into L
left child of z = node x
right child of z = node y	
//x and y are no longer in L
end for
end HuffmanTree

	Section 6.4   Huffman Codes	
543
When this algorithm terminates, L consists of just one node, which is the root 
of the final binary tree. Codes can then be assigned to each leaf of the tree by trac-
ing the path from the root to the leaf and accumulating 0s for left branches and 
1s for right branches. By the way the tree is constructed, every internal node will 
have exactly two children.
	
Example 39	
We’ll use algorithm HuffmanTree to build the tree of Figure 6.57, which is based 
on the data of Example 37. L initially contains the six nodes, ordered by frequency:
4
9
10
12
17
48
Following the algorithm, we enter the for loop for the first time. The x and y nodes 
are those with frequencies 4 and 9, respectively. A new node z with frequency 
4 + 9 = 13  is created and inserted in order into L, with the x node as its left child 
and the y node as its right child The new L looks like the following:
This process is repeated four more times. The resulting L at each stage follows:
13
17
4
9
22
48
10
12
4
9
30
48
13
17
22
10
12
4
9
30
22
52
48
13
17
0
1
2
1
52
30
22
48 (a)
10 (?)
13
17 (p)
12 (g)
4 (k)
9 (c)
100
and then
At this point the tree is complete and the codes can be assigned. The code for c, for 
example, is 1101 (right branch, right branch, left branch, right branch).	

544	
Graphs and Trees
Table 6.1 shows the steps in Huffman encoding/decoding for data compression.
Practice 30	 Find the Huffman codes for the characters of Practice 29.
■
PRACTICE 29	 Construct the Huffman tree for the following characters and frequencies:
Character	
w	
q	
h	
e
Frequency	
10	
12	
20	
58
■
Table 6.1
Encoding Step 1
On the original CLEARTEXT file, perform a frequency analysis; that is, create a file  
FREQUENCY that contains data of the form
a—18
b—7
and so forth.
Encoding Step 2
Using FREQUENCY, create a file CODETABLE that contains the Huffman code for each 
character, i.e.,
a—001
b—1110
and so forth.
Encoding Step 3
Using CLEARTEXT and CODETABLE, create a file called CODED that contains the 
compressed data.
Decoding
Using CODED and CODETABLE, decode the data to recover CLEARTEXT.
The CODED file is the data-compressed version of CLEARTEXT, and presum-
ably it requires less storage space. However, the CODETABLE file must also be 
stored in order to be able to decode the file.
Justification
Although the algorithm to construct the Huffman tree T is easy enough to ­describe, 
we must justify that it gives us the minimum possible value for E(T).
First, if we have an optimal tree T for m characters, the nodes with the low-
est frequencies can always be assumed to be the left and right children of some 
node. To prove this assumption, label the two nodes with the lowest frequencies 
x and y. If x and y are not siblings in the tree, then find two siblings p and q at 
the lowest level of the tree, and consider the case where x and y are not at that 
level (Figure 6.58a). Because f(x) is one of the two smallest values, we know that 
f(x) ≤f(  p). If f(x) <  f(  p), then interchanging x and p in the tree would result in a 
new tree T′ with E(T′) < E(T  ) (Figure 6.58b: the larger frequency is now at a less-
er depth—see Exercise 20a), but this would contradict the fact that T was optimal. 
Therefore f(x) =  f(  p), and x and p can be interchanged in the tree with no effect 
on E(T). Similarly, y and q can be interchanged, resulting in Figure 6.58c, in which 
x and y are siblings. If x or y are at the same level as p and q to begin with, they can 
certainly be interchanged with p or q without affecting E(T  ) (Figure 6.58d).

	Section 6.4   Huffman Codes	
545
x
y
p
q
(a)
p
y
x
q
(b)
p
q
x
y
p
q
x
(c)
y
(d)
Figure 6.58
(a)
y
T
T'
B'
B
x
(b)
y
x
(c)
frequency f(x) + f(y)
frequency f(x) + f(y)
(d)
Figure 6.59
Now again let f (x) and f ( y) be the minimum frequencies, and suppose we 
have a tree T that is optimal for the other frequencies together with the sum 
f (x) + f ( y) (Figure 6.59a). This sum will be the frequency of a leaf node; cre-
ate a tree T ′ that has this node as an interior node with children x and y hav-
ing frequencies f (x) and f ( y) (Figure 6.59b). T ′ will be optimal for frequencies 
f (x), f ( y), and the rest. The proof of this fact begins with some optimal tree B′ for 
frequencies f (x), f ( y), and the rest. We know such an optimal tree exists (since 
it could be found by trial and error), and from the preceding paragraph, we can 
assume that x and y are siblings in B′ (Figure 6.59c). Now create a tree B by strip-
ping nodes x and y from B′ and giving frequency f (x) + f ( y) to their parent node, 
now a leaf (Figure 6.59d). Because T is optimal for the other frequencies together 
with f (x) + f ( y), we have
	
E(T) ≤E(B)     
(1)
But the difference between E(B) and E(B′) is one arc each for x and y; that 
is, E(B′) = E(B) + f ( x) + f (  y) (see Exercise 20b). Similarly, we have 
E(T ′) = E(T) + f (x) + f (  y). Thus, if we add f (x) + f (  y) to both sides of (1), we get
	
E(T ′) ≤E(B′)
(2)

546	
Graphs and Trees
Because B′ was optimal, it cannot be the case that E(T ′) < E(B′), so E(T ′) = E(B′), 
and T ′ is optimal.
Finally, a tree with a single node whose frequency is the sum of all the fre-
quencies is trivially optimal for that sum. We can repeatedly split up this sum 
and drop down children in such a way that we end up with the Huffman tree. 
By the preceding paragraph, each such tree, including the final Huffman tree, is 
optimal.
	
Example 40	
If we applied the process that preserves optimality to the tree of Figure 6.57, we 
would begin with a single node with frequency 100 and “grow” that tree down-
ward, as shown in Figure 6.60.
100
52
48
100
52
48
30
22
100
52
48
30
22
17
13
100
52
48
30
22
13
10
17
4
9
12
100
52
48
30
22
10
17
12
13
100
Figure 6.60	
Application of Huffman Codes
The cost of data storage has certainly declined in recent years, and the relatively low 
cost makes it seem as if practically unlimited storage should be available to all. But 
“relatively inexpensive” doesn’t mean “free,” and during the same period in which 
data storage costs have decreased, the legal requirements on many businesses and 
other organizations to keep electronic records have increased. Much of this infor-
mation is archival in nature and suitable for data compression. As just one example, 
the Sarbanes–Oxley Act became United States federal law in 2002. This law was 
enacted as a reaction to a series of high-profile scandals about accounting irregulari-
ties and irresponsible corporate governance that shook financial markets and public 
trust. Congress authorized the Securities and Exchange Commission (SEC) to set up 
rules regarding retention of documents concerned with financial audits or reviews. 
The final SEC rule requires that all publicly traded companies must retain electronic 
records of all financial transactions for seven years. These records are to include not 
just formal documents but any e-mail, memos, working papers, and so forth, sent or 
received, that contain opinions, conclusions, analyses, or financial data.

	Section 6.4   Huffman Codes	
547
As a more specific application of Huffman codes, let’s look at JPEG, a 
standardized image compression mechanism for photographic-quality images. 
JPEG stands for Joint Photographic Experts Group, the name of the group that 
developed this international standard. The need for improved image compres-
sion was largely fueled by the desire to transmit images over the Internet. There 
are actually two versions of JPEG encoding, lossy and lossless, but the lossy 
version is by far the more common. A lossy compression scheme means that 
once the compressed data has been unencoded, it does not precisely match 
the original—some information has been “lost.” In the case of lossy JPEG 
­compression, data loss comes from the preprocessing of the image before Huff-
man encoding is applied; the Huffman encoding/decoding faithfully restores 
the data it starts with.
JPEG compression is intended for images to be viewed by humans, and it 
takes advantage of the fact that the human eye is much more sensitive to gra-
dients of light and dark than it is to small changes in color. The first step in the 
JPEG process is therefore to take the color image information, which is usually 
given as 24 bits per pixel, 8 bits for each of the red, green, and blue components, 
and transform each pixel into components that capture the luminance (lightness/ 
darkness) with reduced information about the color components. Next, pixels 
with similar color information are grouped together and an “average” color 
value is used, while more accurate luminance data are maintained. The data 
are then transformed into frequency data (that is, the data are represented as a 
combination of cosine waves of varying frequencies), which in turn go through 
a “quantization” process (basically rounding the results of a computation) to 
end up in integer form. Higher-frequency variations, to which the human eye is 
less sensitive, are lost in this process, but again the luminance data are treated 
at a finer grain than the color data. Huffman encoding is applied to the result. 
Areas of the image whose representations occur often will encode to smaller bit 
strings.
A JPEG image file contains not only the compressed data but also the infor-
mation needed to reverse the compression process (including the information to 
reverse the Huffman encoding). The resulting image has lost the high-frequency 
changes and color variations that were eliminated in the stages before the Huffman 
coding was applied. Parameters in the JPEG encoding process allow tradeoffs to 
be made between the amount of compression to be obtained and the faithfulness 
of the restored image to the original. Because of the nature of the algorithms used, 
JPEG encoding has little or no effect on black-and-white line drawings where 
there are no data to throw away.
S e c t i o n  6 . 4 	
Review
Technique
•	  Find Huffman codes, given a set of characters and 
their frequencies.
Main Idea
•	 Given the frequency of characters in a collection of 
data, a binary encoding scheme can be found that 
minimizes the number of bits required to store the 
data but still allows for easy decoding.
W

548	
Graphs and Trees
Exercises 6.4
	 1.	 Is the following code a prefix code? Why or why not?
	
Character	
m	
b	
d	
w
	
Encoding scheme	
01	
100	
011	
101
	 2.	 Using the code of Exercise 1, decode the string 01101.
	 3.	 Given the codes
	
Character	
a	
e	
i	
o	
u
	
Encoding scheme	
00	
01	
10	
110	
111
	
	 decode the sequences
	
a.	 11011011101
	
b.	1000110111
	
c.	 010101
	 4.	 Given the codes
	
Character	
b	
h	
q	
w	
%
	
Encoding scheme	
1000	
1001	
0	
11	
101
	
	 decode the sequences
	
a.	 10001001101101
	
b.	11110
	
c.	 01001111000
	 5.	 Given the codes
	
Character	
a	
p	
w	
(	
)
	
Encoding scheme	
001	
1010	
110	
1111	
1110
	
	 decode the sequences
	
a.	 111110101101110001
	
b.	1010001110
	
c.	 1111111100111101110
	 6.	 Given the nonprefix codes
	
Character	
1	
3	
5	
7	
9
	
Encoding scheme	
1	
111	
101	
10	
10101
	
	 give all possible decodings of the sequence 111110101.
	 7.	 Write the Huffman codes for a, b, c, and d in the binary tree shown.
d
c
b
a

	Section 6.4   Huffman Codes	
549
	 8.	 Write the Huffman codes for r, s, t, u in the binary tree shown.
r
s
t
u
	 9.	 a.	 Construct the Huffman tree for the following characters and frequencies.
	
Character	
c	
d	
g	
m	
r	
z
	
Frequency	
28	
25	
6	
20	
3	
18
	
b.	Find the Huffman codes for these characters.
	 10.	a.	 Construct the Huffman tree for the following characters and frequencies.
	
Character	
b	
n	
p	
s	
w
	
Frequency	
6	
32	
21	
14	
27
	
b.	Find the Huffman codes for these characters.
	 11.	a.	 Construct the Huffman tree for the following characters and frequencies.
	
Character	
a	
z	
t	
e	
c
	
Frequency	
27	
12	
15	
31	
15
	
b.	Find the Huffman codes for these characters.
	 12.	a.	 Construct the Huffman tree for the following characters and frequencies.
	
Character	
?	
x	
w	
e	
t	
s	
a
	
Frequency	
14	
3	
11	
27	
18	
22	
5
	
b.	Find the Huffman codes for these characters.
	
c.	 A file consisting of 100,000 instances of these seven characters is stored using a fixed-length binary 
encoding scheme. How many bits are required for each code and what is the total number of bits 
needed?
	
d.	Storing the same file using the Huffman code of part (b), how many bits are needed?
In Exercises 13–14, the integers could represent the results of the “quantization” step in a JPEG image com-
pression, and the number of occurrences of each in the image. (Note that these are instances of occurrence 
rather than percent frequencies; this simply means that the Huffman tree will not end up with the root value 
equal to 100.)
	 13.	Construct the Huffman tree and find the Huffman codes for the following integers and occurrences.
	
Integer	
82	
664	
327	
349	
423	
389
	
Occurrences	
416	
97	
212	
509	
446	
74
	 14.	Construct the Huffman tree and find the Huffman codes for the following integers and occurrences.
	
Integer	
190	
205	
514	
333	
127	
901	
277
	
Occurrences	
52	
723	
129	
233	
451	
820	
85

550	
Graphs and Trees
	 15.	JPEG can achieve various compression levels; the higher the compression, the lower the quality of the 
reconstructed image.
	
a.	 A compression ratio of 10:1 results in virtually imperceptible loss of image quality. A file of 850,000 
bytes that is compressed with a 10:1 compression ratio results in a compressed file of what size?
	
b.	At a compression ratio of 25:1, some degradation is visible in the reconstructed image. A file of 850,000 
bytes that is compressed with a 25:1 compression ratio results in a compressed file of what size?
	 16.	Explain why JPEG encoding results in less compression for gray-scale images than for full-color images.
	 17.	Someone does a global substitution on the text file of Exercise 11, replacing all instances of “z” with “sh.” 
Find the new Huffman codes.
	 18.	Consider the following paragraph.
However, in my thoughts I could not sufficiently wonder at the intrepidity of these diminutive mortals 
who durst venture to mount and walk upon my body, while one of my hands was at liberty, without 
trembling at the very sight of so prodigious a creature as I must appear to them.3
	
	 If this paragraph were to be compressed using a Huffman code, what single character, aside from punctua-
tion or uppercase characters, would be apt to have one of the longest codes? Which would have one of the 
shortest?
	 19.	Recall the problem posed at the beginning of this chapter.
You work in the Information Systems Department at World Wide Widgets (WWW), the leading widget 
manufacturer. Part numbers consist of a leading character B, C, G, R, or S to identify the part type, fol-
lowed by an 8-digit number. Thus
C00347289
B11872432
S45003781
are all legitimate part numbers. WWW maintains a data file of the part numbers it uses, which, as it 
turns out, is most of the potential numbers. 
	
	 How can you compress this data file so it takes less storage space than the approximately 4.5 Gb required 
using the ASCII encoding scheme of eight bits per character?
	
a.	 Running a frequency count on the WWW data file reveals the following information:
Character	 	
B	
C	
G	
R	
S	
0	
1	
2	
3	
4	
5	
6	
7	
8	
9
Frequency	 	
2	
5	
1	
2	
1	
18	
13	
7	
12	
9	
6	
11	
7	
2	
4
	
	
Construct a Huffman code for these characters.
	
b.	Compute the space requirements of the compressed file as a percent of the uncompressed file.
	 20.	In the justification that the Huffman algorithm produces an optimal tree, the following two assertions were 
made. Prove that each is true.
	
a. E(T ′) < E(T) 
	
b. E(B′) = E(B) +  f (x) + f ( y)
3From Gulliver’s Travels by Jonathan Swift, London, 1726.

Chapter 6   Review	
551
C h a p t e r  6 	
Review
Terminology
acyclic graph (p. 482)
adjacency list (p. 494)
adjacency matrix (p. 492)
adjacent nodes (p. 481)
arc (edge) (p. 477, 478)
binary search tree (p. 534)
binary tree (p. 510)
binary tree search (p. 534)
bipartite complete graph (p. 483)
children nodes (p. 509)
complete binary tree (p. 510)
complete graph (p. 482)
connected graph (p. 482)
cycle (p. 482)
data compression (data 
compaction) (p. 540)
data flow diagram (p. 480)
decision tree (p. 529)
degree of a node (p. 481)
depth of a node (p. 510)
depth (height) of a tree (p. 510)
directed graph (digraph) (p. 478)
endpoints (p. 478)
Euler’s formula (p. 488)
five-color theorum (p. 507)
forest (p. 510)
full binary tree (p. 510)
graph (p. 477, 478)
graph colorability (p. 506)
height of a tree (p. 510)
homeomorphic graphs (p. 491)
Huffman encoding (p. 542)
infix notation (p. 518)
initial point (p. 478)
inorder traversal (p. 515)
internal node (p. 510)
isolated node (p. 481)
isomorphic graphs (p. 485)
isomorphism (p. 486)
labeled graph (p. 479)
leaf (p. 510)
left child (p. 510)
length of a path (p. 482)
linked list (p. 494)
loop (p. 481) 
loop-free graph (p. 481)
map-coloring problem (p. 506)
node (vertex) (p. 477, 478)
nonrooted (free) tree (p. 509)
null pointer (p. 495)
optimal algorithm (p. 533)
parallel arcs (p. 481)
parent node (p. 509)
path (pp. 482, 483)
planar graph (p. 487)
Polish notation (p. 518)
postfix notation (p. 518)
postorder traversal (p. 515)
prefix code (p. 541)
prefix notation (p. 518) 
preorder traversal (p. 514)
reachable node (p. 483)
reverse Polish notation  
(RPN) (p. 518)
right child (p. 510)
root of a tree (p. 509)
simple graph (p. 481)
sparse matrix (p. 494)
subgraph (p. 482)
terminal point (p. 478)
tree (p. 509)
tree traversal (p. 514)
weighted graph (p. 479)
Self-Test
Answer the following true–false questions.
Section 6.1
1.	A connected graph has an arc between any two 
nodes.
2.	If graph G1 is isomorphic to graph G2, then a node 
of degree 5 in G1 will be mapped to a node of de-
gree 5 in G2.
3.	No matter how a planar graph is drawn, its arcs will 
intersect only at nodes.
4.	If part of the adjacency list representation of a 
graph contains
2
3
4
then node 2 is adjacent to node 3 and node 3 is 
adjacent to node 4.
5.	The adjacency matrix of a directed graph is not 
symmetric.
Section 6.2
1.	The depth of any node in a tree is less than or equal 
to the height of the tree.
2.	Because a tree is a graph, a complete tree is also a 
complete graph.
3.	In the left child–right child array representation of 
a binary tree, any row of the array that corresponds 
to a leaf will have all zero entries.
4.	Postorder traversal of an expression tree results in 
an algebraic expression in reverse Polish notation.
5.	In preorder tree traversal, the root is always the first 
node visited.

552	
Graphs and Trees
Section 6.3
1.	The root of a decision tree for the binary search 
algorithm acting on a sorted list of 11 items would 
represent the comparison of the target element with 
the sixth list item.
2.	Searching for any target element x in a list of n ele-
ments requires at least 1 + :log n;  comparisons.
3.	A binary tree search is done with a target element 
of 14 on a binary search tree whose root has the 
value 10; the right subtree will be searched next.
4.	A binary search tree is unique for any given set of 
data.
5.	A decision tree for sorting n elements must have a 
depth of at least n!
Section 6.4
1.	The ASCII encoding scheme requires 8 bits to store 
each character.
2. In a prefix code, each code word is the prefix of 
another code word.
3. In a Huffman code, characters that occur most fre-
quently have the most 0s in their binary string rep-
resentation.
4.	The maximum number of bits for any encoded 
character using a Huffman code will be the depth 
of the Huffman tree. 
5. To be able to decode an encoded file, a frequency 
count from the original file must be stored along 
with the encoded file.
O n  t h e  C o m p u t e r
For Exercises 1–4, write a computer program that pro-
duces the desired output from the given input.
1.	Input: Adjacency list for a graph
Output: Adjacency matrix for the graph
2.	Input: Adjacency matrix for a graph
Output: Adjacency list for the graph
3.	Input: Adjacency list for a graph and the name of a 
node n in the graph
Output: Adjacency list for the graph with node n 
and its associated arcs removed
4.	Input: List of n characters and their (integer) fre-
quencies
Output: Huffman code for the characters
(Hint: Maintain a sorted linked list of records that rep-
resent the roots of binary trees. Initially there will be n 
such records, each with no children; at the end, there 
will be one such record, the root of the Huffman tree.)
5.	Write a program that allows the user to enter a list 
of integers and constructs a binary search tree with 
those integers as nodes. The user can then enter one 
integer at a time, and the program will do a binary 
tree search and indicate whether the given integer 
is in the list.
6.	Write a program that allows the user to enter a list 
of integers and then constructs a binary search tree 
with those integers as nodes. The user can then en-
ter the type of traversal desired (inorder, preorder, 
or postorder), and the program will write out the 
nodes in the appropriate order.
7. Write a program that carries out the first three steps 
in Table 6.1. That is, beginning with a text file, the 
program should produce a frequency count file, then 
a code table file, then an encoded version of the origi-
nal file. Write a second program that uses the encod-
ed file and the code table, and recreates the original 
file. 

Chapter Objectives
After studying this chapter, you will be able to:
•	 Convert between adjacency matrix, adjacency relation, and directed graph 
­representations.
•	 Use the reachability matrix of a directed graph to determine whether one node 
is reachable from another.
•	 Compute the reachability matrix of a directed graph either directly or by using 
Warshall’s algorithm.
•	 Test a graph for the existence of an Euler path (solve the highway inspector 
problem).
•	 Understand the Hamiltonian circuit problem (and the traveling salesman prob-
lem) and how they are fundamentally different from the Euler path problem.
•	 Use Dijkstra’s algorithm to find the shortest path between two nodes in a simple, 
weighted, connected graph.
•	 Use Prim’s algorithm to find the minimal spanning tree in a simple, weighted, 
connected graph.
•	 Carry out depth-first search and breadth-first search in a simple, connected graph.
•	 Understand how depth-first search can be used to test for reachability in a di-
rected graph, perform a topological sort on a partially ordered set represented 
by a directed graph, and find the connected components of an unconnected 
graph.
•	 Identify articulation points in a simple connected graph.
You are the network administrator for a wide-area backbone network that serves your 
company’s many offices across the country. Messages travel through the network by 
being routed from point to point until they reach their destination. Each node in the 
network therefore acts as a switching station to forward messages to other nodes ac-
cording to a routing table maintained at each node. Some connections in the network 
carry heavy traffic, while others are less used. Traffic may vary with the time of day; 
in addition, new nodes occasionally come on line and existing nodes may go off line.
Therefore you must periodically provide each node with updated information so that 
it can forward messages along the most efficient (that is, the least heavily traveled) 
route.
	
Question:	
How can you compute the routing table for each node?
7
Graph Algorithms
Chapter
553

554	
Graph Algorithms
If the network described is viewed as a graph, your task as network administrator is to 
find the “shortest” path from one node to another in the graph. Because graphs have so 
many applications, there is a great deal of interest in finding efficient algorithms to an-
swer certain questions about graphs, directed graphs, or trees, and to perform certain 
tasks on them, such as finding shortest paths. All graph algorithms use one of the con-
venient representations (adjacency matrix or adjacency list) ­presented in Chapter 6.
This chapter covers many of the “classical” graph algorithms. Section 7.1 first 
relates directed graphs to binary relations, and reachability in a graph to the transi-
tive closure of a binary relation. Then two different algorithms pertaining to reach-
ability are given.
In Section 7.2 we will look at algorithms that answer two historically interest-
ing questions about graphs. These questions are known as the highway inspector 
problem and the traveling salesman problem. The highway inspector problem asks 
whether there is a path through a given graph that uses each arc exactly once, 
thereby providing an efficient way for a highway inspector to check all roads with-
out going over the same road twice. The traveling salesman problem asks whether 
there is a cycle in a given graph that visits each node of the graph and, if so, which 
such cycle requires the minimum distance to travel. Recall that a cycle is a path 
that ends where it started and does not use any other node more than once; thus 
such a cycle would provide an efficient way for a salesperson to visit all cities in 
the sales territory only once and end up at home.
Section 7.3 provides algorithmic solutions to the two problems of finding the 
minimum path between two nodes in a simple, connected graph and of minimizing 
the number of arcs used to connect all nodes in a simple, connected graph. Section 7.4 
discusses algorithms for traversing simple graphs—“visiting” all the nodes in some 
systematic way. Section 7.5 uses one of these traversal algorithms to detect articulation 
points in a simple connected graph, points whose removal would ­disconnect the graph.
	
S e c t i o n  7.1 	 Directed Graphs and Binary Relations;  
Warshall’s Algorithm 
In this section we confine our attention to (unweighted) directed graphs with no 
parallel arcs. (In a directed graph, two arcs from node a to node b would be par-
allel, but one arc from a to b and another from b to a are not parallel arcs.) Con-
sider the adjacency matrix of the graph (assuming some arbitrary ordering of the 
n nodes, which we always assume when discussing the adjacency matrix of a 
graph). This will be an n × n matrix, not necessarily symmetric. Furthermore, 
because there are no parallel arcs in the graph, the adjacency matrix will be a 
Boolean matrix, that is, a matrix whose only elements are 0s and 1s. Conversely, 
given an n × n Boolean matrix, we can reconstruct the directed graph that the 
matrix represents, and it will have no parallel arcs. Thus there is a one-to-one 
­correspondence, which we can picture as
	
Directed graphs
with n nodes,
no parallel arcs
n × n Boolean
matrices

(1)
Now we will see how binary relations tie in to this correspondence.

	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
555
Directed Graphs and Binary Relations
Suppose G is a directed graph with n nodes and no parallel arcs. Let N be the set 
of nodes. If (ni, nj) is an ordered pair of nodes, then there either is or is not an arc 
in G from ni to nj. We can use this property to define a binary relation on the set N:
ni  r  nj 4 there is an arc in G from ni  to  nj
This relation is the adjacency relation of the graph.
	
Example 1	
For the directed graph of Figure 7.1, the adjacency relation is 5(1, 2), (1, 3), (3,3),
 (4, 1), (4, 2), (4,3)6.
2
4
1
3
Figure 7.1
Conversely, if r is a binary relation on a set N, we can define a directed graph G 
with N as the set of nodes, and an arc from ni to nj if and only if ni r nj. G will have 
no parallel arcs.
	
Example 2	
For the set N = 51, 2, 3, 46 and the binary relation 5(1, 4), (2, 3), (2, 4), (4, 1)6 on 
N, we obtain the associated directed graph shown in Figure 7.2.
4
1
3
2
Figure 7.2
We now have another one-to-one correspondence:
	
Binary
relations on
n-element sets
Directed graphs
with n nodes,
no parallel arcs

(2)

556	
Graph Algorithms
Of course, a one-to-one correspondence means the existence of a bijection. If 
function composition is carried out on the bijections in (1) and (2), the result is a 
bijection that gives us a one-to-one correspondence between binary relations and 
matrices. Thus we have three equivalent sets:
Binary
relations on
n-element sets
Directed graphs
with n nodes,
no parallel arcs
n × n Boolean
matrices

(3)
An item from any of the three sets has corresponding representations in the other 
two sets.
Practice 1	 Give the collection of ordered pairs in the adjacency relation for the following Boolean 
matrix; also draw the directed graph.
≥
0
0
0
0
1
1
0
0
1
0
0
1
0
0
0
0
¥
Recall the reflexive, symmetric, antisymmetric, and transitive properties of a 
binary relation on a set that we studied in Chapter 5. If a binary relation on a set 
N has a certain property, it will be reflected in the corresponding graph and the 
corresponding Boolean matrix. Conversely, certain characteristics of a directed 
graph or of a Boolean matrix imply certain properties of the corresponding adja-
cency relation.
	
Example 3	
If r is a reflexive relation on a set N, then for each ni [ N, ni r ni. In the corre-
sponding directed graph there will be a loop at each node, and in the corresponding 
Boolean matrix there will be 1s on the main diagonal.
Practice 2	 Explain why the corresponding binary relation is not antisymmetric for the directed 
graph in Figure 6.13 reproduced here.
1
2
a2
a1
a3
a2
a6
a5
a4
3
4
■
■

In Chapter 5 we represented partial orderings on a set by using a Hasse 
­diagram. How does this representation differ from the directed graph representa-
tion? The Hasse diagram is a simplification of the directed graph representation. 
Suppose that G is the directed graph representation of a partial ordering. Because 
a partial ordering is reflexive, G will have a loop at each node. We can eliminate 
these loops in the Hasse diagram without losing any information because we 
know that each node has a loop; that is, each node is related to itself. Because a 
partial ordering is transitive, if a r b and b r c, then a r c. In the directed graph 
there would be an arc from a to b, an arc from b to c, and an arc from a to c. In 
the Hasse diagram we can eliminate the arc from a to c without losing any in-
formation if we keep the transitive property in mind. Finally, the Hasse diagram 
is not a directed graph at all, but we did impose the convention that if a is an 
immediate predecessor of b, then node a will appear below node b in the Hasse 
diagram. Thus we could achieve a directed graph from the Hasse diagram by 
making all the arc directions point upward. The antisymmetry property prevents 
any potential conflict where node a should be below node b and node b should be 
below node a.
In Chapter 5 we also noted set operations that could be performed on two 
binary relations r and s on a set N, r c s and r d s. The relation r c s is the 
union of the ordered pairs in r or s, while r d s is the intersection of the ordered 
pairs in r and s. Let R and S be the Boolean matrices for r and s, respectively. 
The Boolean matrix for r c s will have a 1 in position i, j if and only if there is a 
1 in position i, j of R or a 1 in position i, j of S. Each entry in the Boolean matrix 
for r c s is thus the maximum of the two corresponding entries in R and S, so 
the Boolean matrix for r c s is r ~ s (see the discussion of Boolean matrix op-
erations in Section 5.7). Similarly, the Boolean matrix for r d s will have a 1 in 
position i, j if and only if there is a 1 in position i, j of both R and S. Therefore the 
Boolean matrix for r d s is r ` s.
Reachability
The “reachability” property has an interesting interpretation in each of the three 
equivalent forms in (3)—directed graph, adjacency relation, and adjacency ma-
trix. We already have a definition for this term for directed graphs from Section 6.1, 
which we’ll restate now.
	
Definition	
Reachable Node
In a directed graph, node nj is reachable from node ni if there is a path from ni  
to nj.
In a system modeled by a directed graph (a data flow diagram, for example) 
with a “start node,” any node that is unreachable from the start node can never af-
fect the system and thus can be eliminated. If the directed graph represents some-
thing like airline routes or communication paths in a computer network, it would 
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
557
	
Example 4	
In the directed graph of Figure 7.2, node 3 is not reachable from node 4 or node 1. 
Node 1 is reachable from node 2 by the path 2–4–1.

558	
Graph Algorithms
be undesirable to have some node be unreachable from some other node. Thus the 
ability to test reachability has very practical applications.
The adjacency matrix A of a directed graph G with n nodes and no parallel 
arcs will have a 1 in position i, j if there is an arc from ni to nj. This would be a 
path of length 1 from ni to nj. The adjacency matrix by itself therefore tells us 
about a limited form of reachability, via length-1 paths. However, let us perform 
the Boolean matrix multiplication a × a. We’ll denote this product by a(2) to 
distinguish it from a2, the result of a # a using ordinary matrix multiplication. 
Recalling from Section 5.7 the definition of Boolean matrix multiplication, the  
i, j entry of a(2) is given by
	
a(2)3i, j4 = ~
n
k=1(aik ` akj)
(4)
If a term such as ai2 ` a2j in this sum is 0, then either ai2 = 0 or a2j = 0 (or 
both), and there is either no path of length 1 from ni to n2 or no path of length 1 
from n2 to nj (or both). Thus there are no paths of length 2 from ni to nj passing 
through n2. If ai2 ` a2j is not 0, then both ai2 = 1 and a2j = 1. Then there is a path 
of length 1 from ni to n2 and a path of length 1 from n2 to nj, so there is a path of 
length 2 from ni to nj passing through n2. A path of length 2 from ni to nj will exist 
if and only if there is a path of length 2 passing through at least one of the nodes 
from 1 to n, that is, if and only if at least one of the terms in the sum (4) is 1 and 
therefore a(2)3i, j4 = 1. Therefore the entries in a(2) tell us about reachability via 
length-2 paths.
REMINDER
To compute A(2) [i, j] write 
two copies of A side by 
side. Run a left-hand 
finger along row i of the 
left copy and a right-hand 
finger down column j of 
the right copy. The value 
is 1 if and only if both 
fingers hit a 1 at the same 
time.
Practice 3	 Find A for the graph of Figure 7.2 and compute a(2). What does the 2,1 entry indicate?
The matrix a(2) indicates the presence or absence of length-2 paths. We might 
surmise that this result holds for arbitrary powers and path lengths.
	
Theorem	
On Boolean Adjacency Matrices and Reachability
If A is the Boolean adjacency matrix for a directed graph G with n nodes and no 
parallel arcs, then a(m)3i, j4 = 1 if and only if there is a path of length m from 
node ni to node nj.
Proof: A proof by induction on m is called for. We have already shown the result 
true for m = 1 (and m = 2). Suppose that a(
 p)3i, j4 = 1 if and only if there is a 
path of length p from ni to nj. We know that
a(
 p+1)3i, j4 = ~
n
k=1(a(
 p)3i, k4 ` akj)
which will equal 1 if and only if at least one term, say a(
 p)3i, q4 ` aq j = 1, or 
a(p)3i, q4 = 1 and aq j = 1. This condition will be true if and only if there is a path 
■

If node nj is reachable from node ni, it is by a path of some length. Such a 
path will be shown by a 1 as the i, j entry in A or a(2) or a(3) and so on, but we 
cannot compute an infinite number of matrix products. Fortunately, there is a 
limit to how far in this list we have to look. If there are n nodes in the graph, then 
any path with n or more arcs, and therefore n + 1 or more nodes, must have a 
repeated node. This is a consequence of the pigeonhole principle—there are n 
“bins” (distinct nodes) into which we are putting more than n objects (the nodes 
in a path with n or more arcs). The section of a path lying between the repeated 
nodes is a cycle. If ni ∙nj, the cycle can be eliminated to make a shorter path; 
then if a path exists from ni to nj, there will be such a path of length at most n −1. 
If ni = nj, then the cycle could be the entire path from ni to ni with maximum 
length n; although we could eliminate this cycle (noting that any node may be 
considered reachable from itself), we will retain it to show that a nontrivial path 
does exist from ni to ni.
Consequently, whether ni = nj or ni ∙nj, we need never look for a path from 
ni to nj of length greater than n. Therefore to determine reachability, we need only 
consult element i, j in A, a(2), … , a(n). Alternatively, we can define a reachability 
matrix R by
r = a ~  a(2) ~  c ~  a(n)
Then nj is reachable from ni if and only if entry i, j in R is positive.
We now see how reachability in a graph can be expressed in terms of the ad-
jacency matrix. How is reachability represented in terms of the adjacency relation 
that corresponds to the graph?
If r is the adjacency relation for a graph G, we let rr denote the binary rela-
tion of reachability; that is, (ni, nj) [ rr exactly when there is a path in G from 
ni to nj. Then we can show that rr is the transitive closure of r. Recall from the 
definition of closure of a relation that the transitive closure of r is a relation that is 
transitive, contains r, and is a subset of any transitive relation containing r.
To see that rr is transitive, let (ni, nj) and (nj, nk) belong to rr. Then there is 
a path in G from ni to nj and a path in G from nj to nk. Therefore there is a path 
in G from ni to nk, and (ni, nk) belongs to rr. To see that rr contains r, let (ni, nj) 
belong to r. Then there is an arc from ni to nj in G, which means there is a path of 
length 1 from ni to nj, and (ni, nj) belongs to rr. Finally, suppose s is any transi-
tive relation on the nodes of G that includes r, and let (ni, nj) belong to rr. This 
means that there is a path from ni to nj using, say, nodes ni, nx, ny, … , nw, nj. Then 
there is an arc from each node in this path to the next, and the ordered pairs (ni, nx), 
(nx, ny), … , (nw, nj), all belong to r, and therefore all belong to s. Because s is 
Practice 4	 From the graph of Figure 7.2, what would you expect for the value of entry 2,1 in a(4)? 
Compute a(4) and check this value.
of length p from ni to nq (by the inductive hypothesis) and there is a path of length 1 
from nq to nj, which means there is a path of length p + 1 from ni to nj. End of proof.
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
559
■

560	
Graph Algorithms
transitive, (ni, nj) belongs to s, and rr is a subset of s. Therefore rr is the transitive 
closure of r.
To summarize, corresponding to the three equivalent representations of adja-
cency relation r, directed graph G, and adjacency matrix A, we have
	
(ni, nj) belongs  
	
to the transitive	
4	
nj is reachable	
4 	
r3i, j4 = 1where 
	
closure of r
	
	
from ni in G	
	
r = a ~ a(2) ~  c ~ a(n)
	
Example 5	
Let G be the directed graph in Figure 7.3; G has 5 nodes.
2
5
3
1
4
Figure 7.3
The adjacency matrix A for G is
a = E
0
1
0
0
0
0
0
1
0
0
1
0
0
1
0
0
0
0
0
0
1
0
1
0
0
U
The adjacency relation r is r = 5(1, 2), (2, 3), (3, 1), (3, 4), (5, 1), (5, 3)6.
The successive powers of A are
	
a(2) = E
0
0
1
0
0
1
0
0
1
0
0
1
0
0
0
0
0
0
0
0
1
1
0
1
0
U     
	
a(3) = E
1
0
0
1
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
0
0
U
	
a(4) = E
0
1
0
0
0
0
0
1
0
0
1
0
0
1
0
0
0
0
0
0
1
0
1
1
0
U	
a(5) = E
0
0
1
0
0
1
0
0
1
0
0
1
0
0
0
0
0
0
0
0
1
1
0
1
0
U
REMINDER
Don’t try to compute 
matrix products without 
writing the two matrices 
side by side; you’ll surely 
make a mistake.

These matrices indicate, for example, that there is a path of length 2 from 2 to 1 
because a(2)32, 14 = 1 (the path is 2–3–1), and there is a path of length 4 from 5 to 
3 because, a(4)35, 34 = 1 (the path is 5–3–1–2–3), but there is no path of length 3 
from 1 to 3 because a(3)31, 34 = 0.
The reachability matrix R is the Boolean sum of a,  a(2),  a(3),  a(4), and a(5):
r = E
1
1
1
1
0
1
1
1
1
0
1
1
1
1
0
0
0
0
0
0
1
1
1
1
0
U
The 1 values in R indicate that there are paths in G from nodes 1, 2, 3, and 5 to 
every node except 5, but no path from node 4 to anywhere, which can be confirmed 
by looking at Figure 7.3.
We have proved that the 1 entries in R mark the ordered pairs of nodes that 
belong to the transitive closure of r. The transitive closure will therefore be the 
following set of ordered pairs:
5(l, 1), (1, 2), (1, 3), (1, 4), (2, 1), (2, 2), (2, 3), (2, 4),
(3, 1), (3, 2), (3, 3), (3, 4), (5, 1), (5, 2), (5, 3), (5, 4)6
Beginning with r and following the ad hoc procedure described in Chapter 5 for 
finding the transitive closure of a relation, we see that to obtain transitivity, we must 
first add the pairs (1, 3), (2, 1), (2, 4), (3, 2), (5, 2), and (5, 4). Reviewing the new set, 
we see that we must also add (1, 1), (1, 4), (2, 2), and (3, 3). The resulting collection 
of ordered pairs is transitive (and agrees with what we obtained earlier).
Practice 5	 Compute R for the directed graph of Figure 7.2. What information does column 2 convey?
In Chapter 5, we promised a better algorithm to find the transitive closure 
of a relation. Here it is. Write the binary relation in adjacency matrix form and 
compute
r = a ~ a(2) ~ c~ a(n)
How much work is required to carry out this algorithm? The expression for R 
indicates that Boolean matrix operations are to be done, but matrix operations in 
turn require Boolean and and Boolean or operations on matrix elements. We will 
therefore use Boolean and and Boolean or as the measure of work. In Section 5.7,  
we noted that ordinary matrix multiplication of two n × n matrices requires  
Θ(n3) multiplications and additions; by a similar argument, Boolean matrix 
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
561
■

562	
Graph Algorithms
­multiplication of two n × n Boolean matrices requires Θ(n3) Boolean and/or 
­operations. The algorithm to compute R requires n −1 Boolean matrix multipli-
cations (to find the products a(2), a(3), … , a(n)). To compute n −1 such products 
require (n −1)Θ(n3) = Θ(n4) Boolean operations. To compute C ~ D where C 
and D are two n × n Boolean matrices requires n2 Boolean or operations. To com-
pute R, n −1 such matrix operations are required, so (n −1)n2 = Θ(n3) Boolean 
or operations are performed. The total amount of work is Θ(n4) + Θ( n3) = Θ(n4).
Next we discuss a more efficient algorithm for computing the transitive 
­closure of a relation (or the reachability matrix of a graph).
Warshall’s Algorithm
For a graph G with n nodes, Warshall’s algorithm computes a sequence of n + 1 
matrices M0, M1, M2, … , Mn. For each k, 0 ≤k ≤n, Mk3i, j4 = 1 if and only if 
there is a path in G from ni to nj whose interior nodes (i.e., nodes that are not the 
endpoints of the path) come only from the set of nodes 5n1, n2, … , nk6.
Let us examine the “end conditions.” When k = 0, the set 5n1, n2, … , n06 is 
the empty set, so M03i, j4 = 1 if and only if there is a path in G from ni to nj whose 
interior nodes come from the empty set; that is, there are no interior nodes. The 
path from ni to nj must then consist only of the endpoints and one connecting arc, 
so ni and nj are adjacent nodes. Thus M0 = a. The other end condition occurs 
when k = n. Then the set 5n1, n2, … , nn6 consists of all the nodes in G, so there is 
really no restriction at all on the interior nodes in the path and Mn3i, j4 = 1 if and 
only if there is a path from ni to nj, which means that Mn = r.
Therefore Warshall’s algorithm begins with a = M0 and successively com-
putes M1, M2, … , Mn = r. This computation can be defined inductively. The 
base case is to let M0 = a. Now assume that Mk has been computed, and consider 
how to compute Mk+1 or, more specifically, Mk+13i, j4. We have Mk+13i, j4 = 1 
if and only if there is a path from ni to nj whose interior nodes come only from the 
set 5n1, n2, … , nk+16. This can happen in two ways:
	
1.	 All the interior nodes come from 5n1, n2, … , nk6, in which case 
Mk3i, j4 = 1. We should therefore carry forward any 1 entries in Mk into 
Mk+1.
	
2.	 Node nk+1 is an interior node. We can assume that nk+1 is an interior node 
only once, because cycles can be eliminated from a path. Then there must 
be a path from ni to nk+1 whose interior nodes come from 5n1, n2, … , nk6 
and a path from nk+1 to nj whose interior nodes come from 5n1, n2, … , nk6. 
This means that Mk3i, k + 14 = 1 and Mk3k + 1, j4 = 1, which is to say 
that Mk3i, k + 14 ` Mk3k + 1, j4 = 1; this condition can be tested be-
cause our assumption is that Mk has already been computed.
In the following pseudocode version of Warshall’s algorithm, the initial value 
of matrix M is A. Each pass through the outer loop computes the next matrix in 
the sequence M1, M2, … , Mn = r.

	
Algorithm	
Warshall’s Algorithm
Warshall(n × n Boolean matrix M) 
//Initially, M = adjacency matrix of a directed graph G with no parallel arcs
for k = 0 to n −1 do
for i = 1 to n do
for j = 1 to n do
M3i, j4 = M3i, j4 ~ (M3i, k + 14 ` M3k + 1,  j4)
end for
end for
end for
//at termination, M = reachability matrix of G
end Warshall
This pseudocode gives a nice neat description of Warshall’s algorithm, which can 
be implemented as computer code rather easily. These steps are confusing to do by 
hand, however, requiring some bookkeeping to keep track of all the indices. We can 
write the algorithm more informally, making it easier to do manually. Suppose again 
that matrix Mk in the sequence exists and we are trying to write row i of the next 
matrix in the sequence. For the various values of j, we must evaluate the expression
	
M3i, j4 ~ (M3i, k + 14 ` M3k + 1, j4)
(5)
If entry M3i, k + 14 is 0, then M3i, k + 14 ` M3k + 1, j4 = 0 for all j. Expression 
(5) then reduces to
M3i, j4 ~ 0 = M3i, j4
In other words, row i of the matrix remains unchanged. If, on the other hand, 
entry M3i, k + 14 is 1, then M3i, k + 14 ` M3k + 1, j4 = M3k + 1, j4 for all j. 
Expression (5) then becomes
M3i, j4 ~ M3k + 1, j4
In other words, row i of the matrix becomes the Boolean or of the current row i 
and the current row k + 1.
Table 7.1 describes the (informal) steps to compute entries in Mk+1 from 
­matrix Mk.
Table 7.1
1. Consider column k + 1 in mk.
2. For each row with a 0 entry in this column, copy that row to mk+1.
3. For each row with a 1 entry in this column, or that row with row k + 1 and write 
the resulting row in mk+1.
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
563

564	
Graph Algorithms
	
Example 6	
For the graph of Example 5, the initial matrix M0 is the adjacency matrix.
M0 = E
0
1
0
0
0
0
0
1
0
0
1
0
0
1
0
0
0
0
0
0
1
0
1
0
0
U
We know M0 (so k = 0) and we want to compute M1 (k + 1 = 1). Using step 1 of 
Table 7.1, we consider column 1 of M0. Using step 2 of Table 7.1, rows 1, 2, and 4 
of M0 contain 0s in column 1, so these rows get copied directly to M1:
M1 = E
0
1
0
0
0
0
0
1
0
0
0
0
0
0
0
U
Now we finish up by using step 3 of Table 7.1 Row 3 of column 1 of M0 contains a 
1, so row 3 of M0 is or-ed with row 1 of M0 and the result becomes the new row 3:
M1 = E
0
1
0
0
0
0
0
1
0
0
1
1
0
1
0
0
0
0
0
0
U
Row 5 of column 1 of M0 contains a 1, so row 5 is or-ed with row 1 and the result 
becomes the new row 5:
M1 = E
0
1
0
0
0
0
0
1
0
0
1
1
0
1
0
0
0
0
0
0
1
1
1
0
0
U
To compute the entries in M2, consider column 2. Rows 2 and 4 (the 0 posi-
tions in column 2) will be copied unchanged. Row 1 will be or-ed with row 2 to 
give the new row 1, row 3 will be or-ed with row 2 to give the new row 3, and row 
5 will be or-ed with row 2 to give the new row 5:
M2 = E
0
1
1
0
0
0
0
1
0
0
1
1
1
1
0
0
0
0
0
0
1
1
1
0
0
U

M3 is computed in a similar fashion:
M3 = E
1
1
1
1
0
1
1
1
1
0
1
1
1
1
0
0
0
0
0
0
1
1
1
1
0
U
M4 and M5 will be the same as M3; row 4 is all 0s, so any row that gets or-ed 
with it will be unchanged, and column 5 is all 0s so all rows are copied directly. In 
terms of the graph, no new 1 entries are produced because there are no paths from 
4 to any node or from any node to 5. Thus M3 = M4 = M5 = R, as computed in 
Example 5. Note, however, that the matrices computed by Warshall’s algorithm, 
except for M0 = A and Mn = R, do not agree with the matrices that are powers of 
A used in our previous algorithm for R.
Each pass through the outer loop of Warshall’s algorithm modifies in place 
the matrix that existed at the end of the previous pass. Warshall’s algorithm re-
quires no additional storage for other matrices, even though we wrote down new 
matrices in our example. There is one more point we need to check. Because we 
are modifying the (only) matrix as we go along, during any one pass through 
the outer loop, some of the entries will belong to Mk+1 while others still belong 
to Mk. Specifically, on pass k + 1, we may consider M3i, k + 14 ` M3k + 1, j4 
in Expression (5), where these values have already been computed on this pass 
and therefore represent Mk+l3i, k + 14 and Mk+13k + 1, j4 rather than the values 
Mk3i, k + 14 and Mk3k + 1, j4 we used in our justification for this algorithm. Can 
there be a case where the values Mk+13i, k + 14 and Mk+13k + 1, j4 are 1, so that 
a 1 value goes into Mk+13i, j4, whereas the values Mk3i, k + 14 and Mk3k + 1, j4 
are 0? No—if Mk+13i, k + 14 = 1, there is a path from ni to nk+1 with interior 
nodes drawn from the set 5n1, n2, … , nk+16. However, because nk+1 is an end-
point and cycles can be eliminated, there must also be a path with interior nodes 
drawn from the set 5n1, n2, … , nk6 so that Mk3i, k + 14 = 1. A similar argument 
holds for Mk+13k + 1, j4.
Practice 6	 Use Warshall’s algorithm (formally or informally) to compute R for the graph of Figure 7.2. 
Compare your answer with that for Practice 5.
How much work does Warshall’s algorithm require as measured by the num-
ber of Boolean and/or operations? Consider the formal algorithm. The single as-
signment statement in the algorithm lies within a triply nested loop; it will be 
executed n3 times. Each execution of the assignment statement requires one and 
and one or; therefore, the total amount of work is 2n3 = Θ(n3). Recall that our 
previous algorithm for computing R was an Θ(n4) algorithm.
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
565
■

566	
Graph Algorithms
S e c t i o n  7.1 	
Review
Techniques
•	 Find any two of the adjacency relation, directed 
graph, or adjacency matrix representation, given 
the third.
•	 Compute the reachability matrix R for a graph G 
(or, equivalently, find the transitive closure of the 
adjacency relation on G) by using the formula 
r = a ~ a(2) ~ c~ a(n)  and by using War-
shall’s algorithm.
Main Ideas
•	 There is a one-to-one correspondence between a di-
rected graph G with no parallel arcs, the adjacency 
relation on G, and the adjacency matrix for G (with 
respect to some arbitrary ordering of the nodes).
•	 The reachability matrix of a graph G also represents 
the transitive closure of the adjacency relation on G.
•	 The reachability matrix for a graph can be com-
puted with Θ(n4) Boolean and/or operations by 
summing powers of the adjacency matrix A or with 
Θ(n3) Boolean and/or operations by using War-
shall’s algorithm.
W
Exercises 7.1
	 1.	 Find the adjacency matrix and adjacency relation for the following graph.
3
2
1
	 2.	 Find the adjacency matrix and adjacency relation for the following graph.
3
4
1
2
	 3.	 Find the corresponding directed graph and adjacency relation for the following adjacency matrix.
a = E
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
0
1
1
0
U

	 4.	 Find the corresponding directed graph and adjacency relation for the following adjacency matrix.
A = E
0
0
0
0
0
1
0
0
0
1
0
1
0
1
0
0
1
0
0
0
0
0
0
1
0
U
	 5.	 Given the adjacency relation r = 5(1, 4), (1, 5), (1, 6), (6, 2), (6, 3), (6, 5)6 on the set N = 51, 2, 3, 4, 5, 66, 
find the corresponding directed graph and adjacency matrix.
	 6.	 Given the adjacency relation r = 5(2, 1), (3, 2), (3, 3), (3, 4), (4, 5), (6, 3), (6, 6)6 on the set N = 51, 2, 3,
4, 5, 66, find the corresponding directed graph and adjacency matrix.
	 7.	 Let r be a binary relation defined on the set 50, 1, 2, 3, 4, 5, 66 by x r y  4  y = x + 2. Draw the associ-
ated directed graph.
	 8.	 Let r be a binary relation defined on the set 50, ±1, ±2, ±4, ±166 by x r y  4  y = x2. Draw the ­associated 
directed graph.
	 9.	 Describe a property of a directed graph whose adjacency matrix is symmetric.
	 10.	Describe the directed graph whose adjacency matrix has all 0s on the main diagonal and 1s everywhere 
else.
	 11.	Describe the directed graph whose adjacency matrix has all 1s in row 1 and column 1, and 0s else-
where.
	 12.	Describe the directed graph whose adjacency matrix has 1s in positions (i, i + 1) for 1 ≤i ≤n −1, a  
1 in position (n, 1), and 0s elsewhere.
	 13.	Describe a property of a directed graph whose adjacency relation is irreflexive (see Exercise 26,  
Section 5.1).
	 14.	Describe a property of the adjacency matrix of a graph whose adjacency relation is antisymmetric.
	 15.	Adjacency relations r and s have the following associated adjacency matrices R and S. Find the adja-
cency matrices associated with the relations r c s and r d s.
R = £
1
0
1
1
1
0
0
0
1
§       S = £
1
0
0
1
0
1
0
0
1
§
	 16.	Adjacency relations r and s have the following associated adjacency matrices R and S. Find the adja-
cency matrices associated with the relations r c s and r d s. 
R = ≥
0
1
1
0
0
0
0
1
1
1
0
0
1
0
0
1
¥       S = ≥
0
1
0
0
0
0
1
0
1
0
0
1
1
0
0
0
¥
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
567

568	
Graph Algorithms
	 17.	The two directed graphs that follow have adjacency ­relations r and s. Draw the graphs associated with 
the relations r c s and r d s.
3
2
1
3
2
1
	 18.	The two directed graphs that follow have adjacency relations r and s. Draw the graphs associated with 
the relations r c s and r d s.
1
2
3
4
5	
1
2
3
4
5
	 19.	Let A be the matrix
a = £
0
1
1
1
1
1
0
0
1
§
	
	 Find the products a2 and a(2).
	 20.	Let A be the matrix
a = ≥
1
1
0
1
0
0
1
0
1
0
0
1
1
0
1
0
¥
	
	 Find the products a2 and a(2).
	 21.	The definition of a connected graph can be extended to directed graphs. Describe the reachability matrix 
R for a connected, directed graph.
	 22.	Describe the directed graph with the following reachability matrix R.
r = F
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
V

	 23.	For the following graph, write the reachability matrix R by simply inspecting the graph.
2
3
4
1
	 24.	For the following graph, write the reachability matrix R by simply inspecting the graph.
5
4
2
1
3
For Exercises 25–30, compute the reachability matrix R by using the formula r = a ~ a(2) ~ c~ a(n)
	
	
Section 7.1   Directed Graphs and Binary Relations; Warshall’s Algorithm	
569
	 25.	Exercise 1
	 26.	Exercise 2
	 27.	Exercise 3
	 28.	Exercise 4
	 29.	Exercise 5
	 30.	Exercise 6
For Exercises 31–36, compute the reachability matrix R by using Warshall’s algorithm.
	 31.	Exercise 1
	 32.	Exercise 2
	 33.	Exercise 3
	 34.	Exercise 4
	 35.	Exercise 5
	 36.	Exercise 6
	 37.	Given the binary relation r = 5(1, 3), (3, 2), (2, 3)6 on the set 51, 2, 36, use Warshall’s algorithm to find 
the transitive closure of r.
	 38.	Given the binary relation r = 5(1, 2), (2, 3), (4, 1)6 on the set 51, 2, 3, 46, use Warshall’s algorithm to 
find the transitive closure of r.
	 39.	Use Warshall’s algorithm to find the transitive closure of the following binary relations on the set 51, 2, 36 
(see Exercise 23 in Section 5.1).
	
a.	 r = 5(1, 3), (3, 3), (3, 1), (2, 2), (2, 3), (1, 1), (1, 2)6
	
b.	 r = 5(1, 1), (3, 3), (2, 2)6
	
c.	 r = 5(1, 1), (1, 2), (2, 3), (3, 1), (1, 3)6
	
d.	 r = 5(1, 1), (1, 2), (2, 3), (1, 3)6
	 40.	Use Warshall’s algorithm to find the transitive closure of the following binary relations on the set 
50, 1, 2, 4, 66 (see Exercise 24 in Section 5.1).
	
a.	 r = 5(0, 0), (1, 1), (2, 2), (4, 4), (6, 6), (0, 1), (1, 2), (2, 4), (4, 6)6
	
b.	 r = 5(0, 1), (1, 0), (2, 4), (4, 2), (4, 6), (6, 4)6
	
c.	 r = 5(0, 1), (1, 2), (0, 2), (2, 0), (2, 1), (1, 0), (0, 0), (1, 1), (2, 2)6
	
d.	 r = 5(0, 0), (1, 1), (2, 2), (4, 4), (6, 6), (4, 6), (6, 4)6
	
e.	 r = [  

570	
Graph Algorithms
	 41.	The following directed graph represents a binary relation r on the nodes. Draw the directed graph that 
would represent the transitive closure of r.
	 42.	The following directed graph represents a binary relation r on the nodes. Draw the directed graph that 
would represent the transitive closure of r.
Exercises 43–46 use regular matrix multiplication to obtain information about a graph.
	 43.	Let G be a directed graph, possibly with parallel arcs, and let A be its adjacency matrix. Then A may not 
be a Boolean matrix. Prove that the i, j entry of matrix a2 is the number of paths of length 2 from node i 
to node j.
	 44.	Let A be the adjacency matrix of a directed graph G, possibly with parallel arcs. Prove that the i,  j entry 
of matrix an gives the number of paths of length n from node i to node j.
	 45.	For the following graph, count the number of paths of length 2 from node 1 to node 3. Check by ­ 
computing a2.
3
4
2
1
	 46.	For the following graph, count the number of paths of length 4 from node 1 to node 5. Check by ­ 
computing a4.
4
5
2
1
3

	
	
Section 7.2   Euler Path and Hamiltonian Circuit	
571
	
S e c t i o n  7. 2 	 Euler Path and Hamiltonian Circuit
Euler Path Problem
The Euler path problem (the highway inspector problem) originated many years 
ago. Swiss mathematician Leonhard Euler (pronounced “oiler”) (1707–1783) was 
intrigued by a puzzle popular among the townsfolk of Königsberg (an East Prus-
sian city later called Kaliningrad, which is in Russia). The river flowing through 
the city branched around an island. Various bridges crossed the river as shown in 
Figure 7.4.
b
a
c
d
Figure 7.4
The puzzle was to decide whether a person could walk through the city crossing 
each bridge only once. It is possible to answer the question by trial and error, list-
ing (or walking) all possible routes, so some dedicated Königsberger could have 
solved this particular puzzle. Euler solved this problem, and indeed a more general 
version of the problem, by a better mechanism than trial and error. The problem 
is usually represented as a graph (Figure 7.5) where the bridges are arcs and the 
land masses (labeled a through d) are nodes. The more general question is to de-
termine when an Euler path exists in any graph.1
d
a
c
b
Figure 7.5
1Euler did not actually represent the problem as a graph, and such a representation was not connected to 
Euler’s work until over 150 years later. See “The Truth about Königsberg” by Brian Hopkins and Robin 
Wilson, The College Mathematics Journal, May 2004.

572	
Graph Algorithms
	
Definition	
Euler Path
An Euler path in a graph G is a path that uses each arc of G exactly once.
1
2
5
(b)
(a)
4
7
1
2
4
5
3
6
3
Figure 7.6
For this discussion we will assume that all graphs are connected, since an 
Euler path generally cannot exist otherwise. Whether an Euler path exists in a 
given graph hinges on the degrees of its nodes. A node is even if its degree is even 
and odd if its degree is odd. It turns out that every graph has an even number of 
odd nodes. To see this, choose any graph and let N be the number of odd nodes in 
it, N(1) the number of nodes of degree 1, N(2) the number of nodes of degree 2, and 
so on. Then the sum S of the degrees of all the nodes of the graph is
	
S = 1 # N(1) + 2 # N(2) + 3 # N(3) + c+ k # N(k)
(1)
for some k. This sum is, in fact, a count of the total number of arc ends in the 
graph. Because the number of arc ends is twice the number of arcs, S is an even 
number. We will reorganize equation (1) to group together terms for odd nodes 
and terms for even nodes:
 S = 2 # N(2) + 4 # N(4) + c+ 2m # N(2m)
('''''''''''')''''''''''''*
even nodes
	
+1 # N(1) + 3 # N(3) + c+ (2n + 1) # N(2n + 1)
('''''''''''''''')''''''''''''''''*
	
odd nodes
The sum of the terms representing even nodes is an even number. If we subtract it 
from both sides of the equation, we get a new equation—
	
S′ = 1 # N(1) + 3 # N(3) + c+ (2n + 1) # N(2n + 1)
(2)
—where S′ (the difference of two even numbers) is an even number. Now if we 
rewrite equation (2) as
 S′ = 1 + 1 + c+ 1
(''''')''''* + 3 + 3 + c+ 3
(''''')''''* + c
	
N(1) terms	
N(3) terms
 + (2n + 1) + (2n + 1) + c+ (2n + 1)
('''''''''''')''''''''''''''*
N(2n + 1) terms
Practice 7	 Do Euler paths exist for either graph in Figure 7.6? (Use trial and error to answer. This 
is the old children’s game of whether you can trace the whole graph without lifting your 
pencil and without retracing any arcs.)
■

we see that there are N terms altogether in the sum (the number of odd nodes) and 
that each term is an odd number. For the sum of N odd numbers to be even, N 
must be even. (Can you prove this statement?) We have thus proved the following 
theorem.
	
Theorem	
On Odd Nodes in a Graph
The number of odd nodes in any graph is even.
Now suppose a graph has an odd node n of degree 2k + 1 and that an Euler 
path exists in the graph but does not start at n. Then for each arc we use to enter 
n, there is another unused arc for leaving n until we have used k pairs of arcs. The 
next time we enter n, there is no new arc on which to leave. Thus, if our path does 
not begin at n, it must end at n. The path either begins at n or it does not, and in 
the latter case it ends at n, so the path either begins or ends at this arbitrary odd 
node. Therefore, if there are more than two odd nodes in the graph, there can be 
no path. Thus, there are two possible cases where an Euler path may exist—on a 
graph with no odd nodes or on one with two odd nodes.
Consider the graph with no odd nodes. Pick any node m and begin an Euler 
path. Whenever you enter a different node, you will always have another arc on 
which to exit until you get back to m. If you have used up every arc of the graph, 
you are done. If not, there is some node m′ of your path with unused arcs. Then 
construct an Euler path beginning and ending at m′, much as you did the previous 
section of path, using all new arcs. Attach this cycle as a side trip on the original 
path. If you have now used up every arc of the graph, you are done. If not, continue 
this process until every arc has been covered.
If there are exactly two odd nodes, an Euler path can be started beginning at 
one odd node and ending at the other. If the path has not covered all of the arcs, 
extra cycles can be patched in as in the previous case.
We now have a complete solution to the Euler path problem.
	
Theorem	
On Euler Paths
An Euler path exists in a connected graph if and only if there are either no odd 
nodes or two odd nodes. For the case of no odd nodes, the path can begin at any 
node and will end there; for the case of two odd nodes, the path must begin at one 
odd node and end at the other.
The theorem on Euler paths is actually an algorithm to determine whether 
an Euler path exists on an arbitrary connected graph. To make it look more like 
an algorithm, we’ll rewrite it in pseudocode, but first we’ll make a simplifying 
	
	
Section 7.2   Euler Path and Hamiltonian Circuit	
573
Practice 8	 Using the preceding theorem, work Practice 7 again.
Practice 9	 Is the Königsberg walk possible?
■
■

574	
Graph Algorithms
­assumption that the graph has no loops. If the graph G has loops, we can strip 
them off and consider the modified graph H. If H has an Euler path, then so does 
G—whenever we come to a node with a loop, we traverse the loop. If H has no 
Euler path, then neither does G.
In the accompanying algorithm (algorithm EulerPath), the input is a connect-
ed graph with no loops represented by an n × n adjacency matrix A. The essence 
of the algorithm is to count the number of nodes adjacent to each node and to 
determine whether this is an odd or an even number. If there are too many odd 
numbers, an Euler path does not exist. The variable total keeps track of the num-
ber of odd nodes found in the graph. The degree of any particular node, degree, 
is found by adding the numbers in that node’s row of the adjacency matrix. (This 
is why we exclude loops; a loop at node i adds only 1 to the adjacency matrix at 
position 3i, i4, yet such a loop contributes 2 arc ends.) The function odd results in 
a value “true” if and only if the argument is an odd integer.
	
Algorithm	
EulerPath
EulerPath (n × n matrix A)
//Determines whether an Euler path exists in a connected graph with
//no loops and adjacency matrix A
Local variables:
integer total	
//number of odd nodes so far found
integer degree	 //the degree of a node
integer i, j	
//array indices
total = 0
i = 1
while total <= 2 and i <= n do
degree = 0
for j = 1 to n do
degree = degree + a3i, j4	
//find degree of node i (*)
end for
if odd(degree) then
total = total + 1	
//another odd degree node found
end if
i = i + 1
end while
if total > 2 then
write (“No Euler path exists”)
else
write (“Euler path exists”)
end if
end EulerPath

Let us analyze algorithm EulerPath. The important operation done by the al-
gorithm is an examination of the elements of the adjacency matrix, which occurs 
in the line marked at the end with an asterisk (*). In the worst case, the while loop 
in the algorithm is executed n times, once for each row. Within the while loop, the 
for loop, containing line (*), is executed n times, once for each column. EulerPath 
is therefore an Θ(n2) algorithm in the worst case.
At the cost of some extra decision logic, we could modify the algorithm be-
cause we never have to examine the last row of the matrix. We know from the 
theorem on Euler paths that the total number of odd nodes is even. If the number 
of odd nodes after processing the next-to-last row is odd, then the last row must 
represent an odd node; if that number is even, then the last row must represent an 
even node. This modification results in (n −1)n elements to examine in the worst 
case, which is still Θ(n2).
If we represented the graph G by an adjacency list rather than an adjacency ma-
trix, then the corresponding version of the algorithm would have to count the length 
of the adjacency list for each node and keep track of how many are of odd length. 
There would be n adjacency lists to examine, just as there were n rows of the adja-
cency matrix to examine, but the length of each adjacency list might be shorter than 
n, the length of a row of the matrix. It is possible to reduce the order of magnitude 
below n2 if the number of arcs in the graph is small, but the worst case is still Θ(n2).
	
Example 7	
The adjacency matrix for the graph of Figure 7.6a follows.
E
0
2
1
0
0
2
0
1
0
0
1
1
0
1
1
0
0
1
0
2
0
0
1
2
0
U
When the algorithm first enters the while loop, total is 0 and i is 1. Then degree is 
initialized to 0. Within the for loop, the values of row 1 of the adjacency matrix are 
added in turn to degree, resulting in a value for degree of 3. The odd function applied 
to degree returns the value “true,” so the value of total is increased from 0 to 1; one 
node of odd degree has been found. Then i is incremented to 2. Neither the bounds on 
total nor the bounds on the array size have been exceeded, so the while loop executes 
again, this time for row 2 of the array. Once again, degree is found to be odd, so the 
value of total is changed to 2. When the while loop is executed for row 3 of the ar-
ray, the value of degree is even (4), so total does not change, and the while loop is 
executed again with i = 4. Row 4 again produces an odd value for degree, so total 
is raised to 3. This terminates the while loop. The bad news is written that there is no 
Euler path because the number of odd nodes exceeds 2.
	
	
Section 7.2   Euler Path and Hamiltonian Circuit	
575
Practice 10	 Write the adjacency matrix for the Königsberg walk problem and trace the execution of 
algorithm EulerPath.
■

576	
Graph Algorithms
Hamiltonian Circuit Problem
Another famous mathematician, William Rowan Hamilton (1805–1865), posed a 
problem in graph theory that sounds very much like Euler’s. He asked how to tell 
whether a graph has a Hamiltonian circuit.
	
Definition	
Hamiltonian Circuit
A Hamiltonian circuit in a graph is a cycle using every node of the graph.
(Recall that in a cycle, only the node that forms the beginning and the ending of 
the cycle is repeated.)
An Euler path in a graph requires that each and every arc of the graph be used 
once and only once, but nodes can be repeated. A Hamiltonian circuit requires 
that each and every node of the graph be visited once and only once (except for the 
start node, which is also the end node) but there can be unused arcs; no arc can be 
used more than once because that would involve revisiting a node.
Like the Euler path problem, the Hamiltonian circuit problem can be solved 
for a given graph by trial and error. The algorithm is as follows: Start from one 
node of the graph and try some path by choosing various arcs. If the path results 
in a repeated node, it is not a cycle, so throw it away and try a different path. If 
the path can be completed as a cycle, then see whether it visited every node; if not, 
throw it away and try a different path. Continue in this fashion until all possible 
paths have been tried or a Hamiltonian circuit has been found. This will involve 
some careful record keeping so that no path is tried more than once. The trial-and-
error approach is theoretically possible—but it is practically impossible! In all but 
the smallest of graphs, there will simply be too many paths to try.
Euler found a simple, efficient algorithm to determine, for an arbitrary graph, 
if an Euler path exists. Although the Hamiltonian circuit problem sounds very 
similar to the Euler path problem, there is a basic difference. No efficient algo-
rithm has ever been found to determine if a Hamiltonian circuit exists. In fact, 
there is some evidence (see Section 9.3) to suggest that no such algorithm will 
ever be found.
In certain types of graphs we can easily determine whether a Hamiltonian 
circuit exists. For example, an unconnected graph cannot have a Hamiltonian cir-
cuit because there would be no way to construct a path reaching all nodes. A 
complete graph with n > 2 has a Hamiltonian circuit because for any node on 
the path, there is always an arc to travel to any unused node and finally an arc 
to return to the starting point. Exercise 37 describes an additional condition that 
guarantees the existence of a Hamiltonian circuit. But in general—that is, for an 
arbitrary graph—we cannot readily make a determination about the existence of 
a Hamiltonian circuit.
Suppose we are dealing with a weighted graph. If a Hamiltonian circuit ex-
ists for the graph, can we find one with minimum weight? This is the traveling 
Practice 11	
Do Hamiltonian circuits exist for the graphs of Figure 7.6? (Use trial and error to answer.)
■

­salesman problem. Once again it can be solved using trial and error by tracing all 
possible paths and keeping track of the weights of those paths that are Hamilto-
nian circuits, but, again, this is not an efficient algorithm. (Incidentally, the travel-
ing salesman problem for visiting all 48 capitals of the contiguous United States 
has been solved—a total of 10,628 miles is required!)
Exercises 7.2
	 1.	 Rework Example 3 of Chapter 2 using the theorem on Euler paths. Here is the graph, where the nodes 
have been numbered.
1
2
5
4
3
	 2.	 a.	 Add a single arc to the graph of Exercise 1 so that there is an Euler path.
	
b.	 List the nodes in such a path.
For Exercises 3–12, determine whether the given graph has an Euler path by using the theorem on Euler paths. 
If so, list the nodes in such a path.
	 3.	
5
4
3
1
6
2
	
4.	 1
2
4
3
5
6
	
	
Section 7.2   Euler Path and Hamiltonian Circuit	
577
S e c t i o n  7. 2 	
Review
Technique
•	 Using algorithm EulerPath, determine whether an 
Euler path exists in a graph.
Main Ideas
•	 There is a simple criterion for determining whether 
Euler paths exist in a graph but no such criterion 
for whether Hamiltonian circuits exist.
•	 An algorithm that is Θ(n2) in the worst case can 
determine the existence of an Euler path in a con-
nected graph with n nodes.
W

578	
Graph Algorithms
	 5.	
5
4
2
1
6
3
	 6.	
2
1
9
12
10
11
6
3
5
8
4
7
	 7.	
1
2
3
4
5
6
7
	 8.	
2
5
6
1
4
3
	 9.	
3
7
5
2
6
8
4
1
	 10.	
2
1
3
	 11.	
	 12.	
3
4
2
1
	 13.	Draw the adjacency matrix for the graph of Exercise 3. In applying algorithm EulerPath, what is the value 
of total after the second pass through the while loop?
	 14.	Draw the adjacency matrix for the graph of Exercise 5. In applying algorithm EulerPath, what is the value 
of total after the fourth pass through the while loop?
	 15.	Draw the adjacency matrix for the graph of Exercise 7. In applying algorithm EulerPath, what is the value 
of i after the while loop is exited?
	 16.	Draw the adjacency matrix for the graph of Exercise 9. In applying algorithm EulerPath, what is the value 
of i after the while loop is exited?

The definition of an Euler path extends to directed graphs. Instead of just the degree of a node as the total num-
ber of arc ends, we must now keep track of arcs coming into a node and arcs leaving a node. The total number 
of arc ends coming into a node is its in-degree; the total number of arc ends leaving a node is its out-degree. 
Exercises 17–20 talk about Euler paths in directed graphs.
	 17.	Describe two conditions on a connected directed graph, either of which would guarantee the existence of 
an Euler path.
	 18.	Determine whether this graph has an Euler path. If so, list the nodes in such a path.
3
4
2
1
	 19.	Determine whether this graph has an Euler path. If so, list the nodes in such a path.
3
4
2
1
	 20.	Determine whether this graph has an Euler path. If so, list the nodes in such a path.
3
4
2
1
For Exercises 21–28, decide by trial and error whether Hamiltonian circuits exist for the graphs of the given 
exercise. If so, list the nodes in such a cycle.
	
	
Section 7.2   Euler Path and Hamiltonian Circuit	
579
	 21.	Exercise 3
	 22.	Exercise 4
	 23.	Exercise 5
	 24.	Exercise 6
	 25.	Exercise 7
	 26.	Exercise 8
	 27.	Exercise 9
	 28.	Exercise 11
	 29.	Prove that any graph with a Hamiltonian circuit is connected.
	 30.	Find an example of an unconnected graph that has an Euler path. (Hint: Because this seems intuitively 
contradictory, you should look for a trivial case.)

580	
Graph Algorithms
	 31.	Consider a simple, complete graph with n nodes. Testing for a Hamiltonian circuit by trial and error could 
be done by selecting a fixed starting node and then generating all possible paths from that node of length n.
	
a.	 How many paths of length n are there if repetition of arcs and nodes is allowed?
	
b.	 How many paths of length n are there if repetition of arcs and nodes is allowed but an arc may not be 
used twice in succession?
	
c.	 How many paths of length n are there if nodes and arcs cannot be repeated except for the starting node? 
(These are the Hamiltonian circuits.)
	
d.	 To solve the traveling salesman problem in a weighted graph, assume a fixed starting point at node 1 
and generate all possible Hamiltonian circuits of length n to find one with minimum weight. If it takes 
0.000001 seconds to generate a single Hamiltonian circuit, how long will this process take in a simple, 
complete graph with 15 nodes?
	 32.	Is it possible to walk in and out of each room in the house shown in the following figure so that each door 
of the house is used exactly once? Why or why not?
	 33.	Recall that Kn denotes the simple, complete graph of order n.
	
a.	 For what values of n does an Euler path exist in Kn?
	
b.	 For what values of n does a Hamiltonian circuit exist in Kn?
	 34.	Recall that Km, n denotes a bipartite, complete graph with m + n nodes.
	
a.	 For what values of m and n does an Euler path exist in Km, n?
	
b.	 For what values of m and n does a Hamiltonian circuit exist in Km, n?
	 35.	Prove that a Hamiltonian circuit always exists in a connected graph where every node has degree 2.
	 36.	Consider a connected graph with 2n odd vertices, n ≥2. By the theorem on Euler paths, an Euler path 
does not exist for this graph.
	
a.	 What is the minimum number of disjoint Euler paths, each traveling some of the arcs of the graph, 
necessary to travel each arc exactly once?
	
b.	 Show that the minimum number is sufficient.
	 37.	Ore’s theorem (Oystein Ore, 1960) states that a Hamiltonian circuit exists in any graph G with the follow-
ing properties:
	
1.	 G is a simple graph with n nodes, n ≥3.
	
2.	 For any two nonadjacent nodes x and y, degree(x) + degree(y) ≥n.
	
Ore’s Theorem is proved by contradiction in the following steps.
	
a.	 Assume that a graph G with properties 1 and 2 above does not have a Hamiltonian circuit. Beginning 
with G, add new edges to produce a simple graph H that does not have a Hamiltonian circuit but would 
have such a circuit with the addition of any single new arc. Describe a process for creating H.
	
b.	 Prove that H has a Hamiltonian path, that is, a path that visits each node exactly once.
	
c.	 Denote the nodes on the Hamiltonian path by p = x1, x2, x3, … , xn−1, xn = q. Prove that for any node 
xi, 2 ≤i ≤n −1, if an arc exists in H between xi and p, then no arc exists in H between xi−1 and q.

	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
581
	
d.	 Using the result from part (c), prove that in graph H, degree(  p) + degree(q) < n.
	
e.	 Prove that in graph G, degree( p) + degree(q) < n.
	
f.	 Conclude from part (e) that G has a Hamiltonian circuit.
 38. Ore’s theorem (Exercise 37) gives a sufficient condition for a Hamiltonian circuit to exist, but it is not a 
necessary condition. Find a simple graph G with n nodes, n ≥3, that has a Hamiltonian circuit but for 
which condition (2) does not hold.
	
S e c t i o n  7. 3 	 Shortest Path and Minimal Spanning Tree
Shortest-Path Problem
Assume that we have a simple, weighted, connected graph, where the weights are 
positive. Then a path exists between any two nodes x and y. Indeed, there may be 
many such paths. The question is, How do we find a path with minimum weight? 
Because weight often represents distance, this problem has come to be known as 
the “shortest-path” problem. It is an important problem to solve for a computer 
or communications network, where information at one node must be routed to 
another node in the most efficient way possible, or for a transportation network, 
where products in one city must be shipped to another.
The traveling salesman problem is a minimum-weight path problem with such 
severe restrictions on the nature of the path that such a path may not exist at all. 
In the shortest-path problem, we put no restrictions (other than minimum weight) 
on the nature of the path, and because the graph is connected, we know that such 
a path exists. For this reason we may hope for an efficient algorithm to solve the 
problem, even though no such algorithm is known for the traveling salesman prob-
lem. Indeed such an algorithm does exist; it was published in 1959 by Edsger W. 
Dijkstra, a prominent computer scientist of the twentieth century.
The shortest-path algorithm known as Dijkstra’s algorithm works as follows. 
We want to find the minimum-distance path from a given node x to a given node 
y. We build a set (we’ll call it IN) that initially contains only x but grows as the 
algorithm proceeds. At any given time IN contains every node whose shortest 
path from x, using only nodes in IN, has so far been determined. For every node z 
outside IN, we keep track of the shortest distance d3z4 from x to that node, using 
a path whose only non-IN node is z. We also keep track of the node adjacent to z 
on this path, s3z4.
How do we let IN grow; that is, which node should be moved into IN next? 
We pick the non-IN node with the smallest distance d. Once we add that node, 
call it p, to IN, then we have to recompute d for all the remaining non-IN nodes, 
because there may be a shorter path from x going through p than there was before 
p belonged to IN. So we compare the current distance of z from x, d  3z4, with the 
distance of p from x, d  3  p4, plus the distance from p to z, A3  p, z4 where A is the 
adjacency matrix. If there is a shorter path, we must also update s3z4 so that p is 
now shown to be the node adjacent to z on the current shortest path, that is, s3z4 
is the node just before z on this path from x. As soon as y is moved into IN, IN 
stops growing. The current value of d  3  y4 is the distance for the shortest path, and 
its nodes are found by looking at y, s3  y4, s3s3  y4 4, and so forth, until we have traced 
the path back to x.
A pseudocode form of the algorithm is given in the accompanying box. The 
input is the adjacency matrix for a simple, connected graph G with positive weights 

582	
Graph Algorithms
and nodes x and y; the algorithm writes out the shortest path between x and y and 
the distance for that path. Here shortest path means minimum-weight path. We 
actually assume a modified adjacency matrix A, where a3i, j4 is the weight of the 
arc between i and j if one exists and a3i, j4 has the value ∞ if no arc exists (here 
the symbol ∞ denotes a number larger than any weight in the graph).
	
Algorithm	
Dijkstra’s Algorithm
Dijkstra (n × n matrix A; nodes x, y)
//Computes the shortest path between a source node x and a destination node y
//in a simple, connected graph with positive weights. A is a modified adjacency
//matrix. Writes out nodes in the shortest path from x to y, and the
//distance for that path.
Local variables:
set of nodes IN	
//set of nodes whose shortest path from x is known
nodes z, p	
//temporary nodes
array of integers d	
//for each node, the distance from x using nodes in IN
array of nodes s	
//for each node, the previous node in the shortest path
integer OldDistance	
// distance to compare against
//initialize set IN and arrays d and s
IN = 5x6
d 3x4 = 0
for all nodes z not in IN do
d 3z4 = a3x, z4
s 3z4 = x
end for
//process nodes into IN
while y not in IN do
//add minimum-distance node not in IN
p = node z not in IN with minimum d 3z4
IN = IN c 5 p6
//recompute d for non IN nodes, adjust s if necessary
for all nodes z not in IN do
OldDistance = d3z4
d3z4 = min(d3z4, d3  p4 + a3  p, z4)
if d3z4 ∙OldDistance then
s3z4 = p
end if
end for
end while

	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
583
	
Example 8	
Consider the graph in Figure 7.7 and the corresponding modified adjacency matrix 
shown in Figure 7.8.
	
	
x 
 1  
2 
3 
 4  
y 
F
∞
3
8
4
∞
10
 3
∞
∞
6
∞
∞
 8
∞
∞
∞
7
∞
 4
6
∞
∞
1
 3
∞
∞
7
1
∞
 1
10
∞
∞
3
1
∞
V
	
Figure 7.7	
Figure 7.8
Let’s trace Dijkstra’s algorithm on this graph. At the end of the initialization phase, 
IN contains only x, d contains all the direct distances (arc weights) from x to other 
nodes, and x is the immediate predecessor of all nodes except x. (Because of the 
∞ in position a3x, 44, there is no arc from x to 4, so s344 is meaningless here but 
it simplifies the initialization.)
IN = 5x6
	
x	
1	
2	
3	
4	
y
d	
0	
3	
8	
4	
∞	
10
s	
−	
x	
x	
x	
x	
x
//write out path nodes
write (“In reverse order, the path is”)
write (y)
z = y
repeat
write (s3z4)
z = s3z4
until z = x
// write out path distance
write (“The path distance is”, d3  y4 )
end Dijkstra
     x
  1
  2
 3
  4
 y

584	
Graph Algorithms
In Figure 7.9, circled nodes are those in set IN, heavy lines show the current 
­shortest paths, and the d value for each node is written along with the node label. 
Figure 7.9a is the picture after initialization.
(3)
1
(4)
3
(3)
1
(4)
3
4
1 (3)
3
x
8
3
1
1
y (10)
(a)
10
6
3 (4)
2 (8)
7
4 (∞)
4
(3)
3
x
8
3
1
1
y (10)
(b)
10
6
3 (4)
2 (8)
7
4 (∞)
4
3
x
1
(3)
1
(4)
3
8
3
1
y (6)
(d)
10
1
1
6
2 (8)
7
(5)
4 (5)
4
3
x
y
8
3
1
(6)
(e)
10
6
2 (8)
7
4
3
x
8
3
1
1
y (7)
(c)
10
6
2 (8)
7
4 (5)
4
Figure 7.9
We now enter the while loop and search through the d values for the node of 
minimum distance that is not in IN; this turns out to be node 1, with d314 = 3. We 
throw node 1 into IN, and in the for loop we recompute all the d values for the 
remaining nodes, 2, 3, 4, and y.
	
 p = 1
	
 IN = 5x, 16
	
 d324 = min(8, 3 + a31, 24) = min(8, ∞) = 8
	
 d334 = min(4, 3 + a31, 34) = min(4, 9) = 4
	
 d344 = min(∞, 3 + a31, 44) = min(∞, ∞) = ∞
	
 d3  y4 = min(10, 3 + a31, y4) = min(10, ∞) = 10
There were no changes in the d values, so there were no changes in the s values 
(there were no shorter paths from x by going through node 1 than by going directly 
from x). Figure 7.9b shows that 1 is now in IN.
The second pass through the while loop produces the following:
p = 3 (3 has the smallest d value, namely 4, of 2, 3, 4, or y) 
IN = 5x, 1, 36

REMINDER
Distances in Dijkstra’s 
algorithm are always 
recomputed relative to the 
node most recently added 
to IN.
d324 = min(8, 4 + a33, 24) = min(8, 4 + ∞) = 8
d344 = min(∞, 4 + a33, 44) = min(∞, 4 + 1) = 5 (a change, so update s344 to 3)
	
d3  y4 = min(10, 4 + a33, y4) = min(10, 4 + 3) = 7 (a change, so update s3  y4 to 3)
	
x	
1	
2	
3	
4	
y
d	
0	
3	
8	
4	
5	
7
s	
−	
x	
x	
x	
3	
3
	
x	
1	
2	
3	
4	
y
d	
0	
3	
8	
4	
5	
6
s	
−	
x	
x	
x	
3	
4
	
x	
1	
2	
3	
4	
y
d	
0	
3	
8	
4	
5	
6
s	
−	
x	
x	
x	
3	
4
Shorter paths from x to the two nodes 4 and y were found by going through 3, as 
reflected in Figure 7.9c.
On the next pass,
	
 p = 4 (d value = 5)
	
 IN = 5x, 1, 3, 46
	
 d324 = min(8, 5 + 7) = 8
	
 d3  y4 = min(7, 5 + 1) = 6  	
(a change, update s3  y4)
See Figure 7.9d.
Processing the while loop again, we get
	
 p = y
	
 IN = 5x, 1, 3, 4, y6
	
 d324 = min(8, 6 + ∞) = 8
See Figure 7.9e.
Now that y is part of IN, the while loop terminates. The path goes through  
y, s3  y4 = 4, s344 = 3, and s334 = x. Thus the path uses nodes x, 3, 4, and y. (The 
algorithm gives us these nodes in reverse order.) The distance for the path is 
d3  y4 = 6. By looking at the graph in Figure 7.7 and checking all the possibilities, 
we can see that this is the shortest path from x to y.
Dijkstra’s algorithm terminates when y is put into IN, even though there may 
be other nodes in the graph not yet in IN (such as node 2 in Example 8). How do 
we know that a still shorter path cannot be found through one of these excluded 
nodes? If we continue processing until all nodes have been included in IN, the  
d values then represent the shortest path from x to any node, using all the values 
in IN, that is, the shortest path using any nodes of the graph. But new nodes are 
brought into IN in order of increasing d values. A node z that is brought into IN 
later than y must have as its shortest path from x one whose distance is at least as 
	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
585

586	
Graph Algorithms
great as the d value of y when y was brought into IN. Therefore there cannot be a 
shorter path from x to y via z because there is not even a shorter path just between 
x and z.
Practice 12	 Trace Dijkstra’s algorithm on the graph shown in Figure 7.10. Show the values for p and IN 
and the d values and s values for each pass through the while loop. Write out the nodes of 
the shortest path and the distance of the path.
Figure 7.10
When looking for the next node to bring into IN in Dijkstra’s algorithm, more 
than one node p may have a minimum d value, in which case p can be selected ar-
bitrarily. There may also be more than one shortest path between x and y in a graph.
Dijkstra’s algorithm also works for directed graphs if the adjacency matrix is 
in the appropriate form. And it works for unconnected graphs; if x and y are not 
in the same component, then d3  y4 will remain ∞ throughout. After y has been 
brought into IN, the algorithm will terminate, and this value of ∞ for d3  y4 will 
indicate that no path exists between x and y.
We may think of Dijkstra’s algorithm as being a “nearsighted” algorithm. It 
cannot see the entire graph at once to pick out overall shortest paths; it only picks 
out shortest paths relative to the set IN at each step. Such an algorithm is called 
a greedy algorithm—it does what seems best based on its limited immediate 
knowledge. In this case, what seems best at the time turns out to be best overall.
How efficient is Dijkstra’s algorithm? Most of the work seems to take place 
within the for loop that modifies the d and s arrays. Here the algorithm checks 
all n nodes to determine which nodes z are not in IN and recomputes d3z4 for 
those nodes, possibly also changing s3z4. The necessary quantities d3z4, d3  p4, and 
a3   p, z4 for a given z are directly available. Therefore the for loop requires Θ(n) 
operations. In addition, determining the node p to add to IN can also be done in 
Θ(n) operations by checking all n nodes. With the additional small amount of 
work to add p to IN, each execution of the while loop takes Θ(n) operations. In the 
worst case, y is the last node brought into IN, and the while loop will be executed 
n −1 times. Therefore the total number of operations involved in the while loop 
is Θ(n(n −1)) = Θ(n2). Initialization and writing the output together take Θ(n) 
operations, so the algorithm requires Θ(n + n2) = Θ(n2) operations in the worst 
case.
What if we keep IN (or rather the complement of IN) as some sort of linked 
list, so that all the nodes of the graph do not have to be examined to see which 
are not in IN? Surely this would make the algorithm more efficient. Note that the 
number of nodes not in IN is initially n −1, and that number decreases by 1 for 
each pass through the while loop. Within the while loop the algorithm thus has to 
■

perform on the order of n −1 operations on the first pass, then n −2, then n −3, 
and so on. But, as proof by induction will show,
(n −1) + (n −2) + c+ 1 = (n −1)n∙2 = Θ(n2)
Thus the worst-case situation still requires Θ(n2) operations.
Minimal Spanning Tree Problem
A problem encountered in designing networks is how to connect all the nodes effi-
ciently, where nodes can be computers, telephones, warehouses, pumping stations, 
and so on. A minimal spanning tree may provide an economical solution, one that 
requires the least cable, pipeline, or whatever the connecting medium is. For reli-
ability, however, the minimal spanning tree usually would be supplemented with 
additional arcs so that if one connection were broken for some reason, an alterna-
tive route could be found.
	
Definition	
Spanning Tree
A spanning tree for a connected graph is a nonrooted tree whose set of nodes 
coincides with the set of nodes for the graph and whose arcs are (some of) the 
arcs of the graph.
A spanning tree thus connects all the nodes of a graph with no excess arcs (no 
cycles). There are algorithms for constructing a minimal spanning tree, a span-
ning tree with minimal weight, for a given simple, weighted, connected graph. 
One of these algorithms, called Prim’s algorithm, proceeds very much like Dijks-
tra’s algorithm. There is a set IN, which initially contains one arbitrary node. For 
every node z not in IN, we keep track of the shortest distance d3z4 between z and 
any node in IN. We successively add nodes to IN, where the next node added is one 
that is not in IN and whose distance d3z4 is minimal. The arc having this minimal 
distance is then made part of the spanning tree. Because there may be ties between 
minimal distances, the minimal spanning tree of a graph may not be unique. The 
algorithm terminates when all nodes of the graph are in IN.
The key difference in the implementation of the two algorithms comes in the 
computations of new distances for the nodes not yet in IN. In Dijkstra’s algorithm, 
if p is the node that has just been added to IN, distances for non-IN nodes are 
­recalculated by
d3z4 = min(d3z4, d3  p4 +  a3  p, z4)
that is, by comparing the current distance of z from x with the distance of p from 
x plus the distance of z from p. In Prim’s algorithm, if p is the node that has just 
been added to IN, distances for non-IN nodes are recalculated by
d3z4 = min(d3z4, a3  p, z4)
that is, by comparing the current distance of z from IN with the distance of z from p.
We won’t write out the algorithm (which, like Dijkstra’s algorithm, requires 
Θ(n2) operations in the worst case and is a greedy algorithm); we will simply 
­illustrate it with an example.
	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
587

588	
Graph Algorithms
	
Example 9	
We will find a minimal spanning tree for the graph of Figure 7.7. We let node 1 be 
the arbitrary initial node in IN. Next we consider all the nodes adjacent to any node 
in IN, that is, all nodes adjacent to 1, and select the closest one, which is node x. 
Now IN = 51, x6, and the arc between 1 and x is part of the minimal spanning tree. 
Next we consider all nodes not in IN that are adjacent to either 1 or x. The closest 
such node is 3, which is 4 units away from x. The arc between 3 and x is part of the 
minimal spanning tree. For IN = 51, x, 36, the next closest node is node 4, 1 unit 
away from 3. The remaining nodes are added in the order y and then 2. Figure 7.11 
shows the minimal spanning tree.
Figure 7.11
Practice 13	 Find a minimal spanning tree for the graph of Figure 7.10.
	
Example 10	
Seismic sensing instruments are to be distributed at sites along a volcanic rift zone, 
as shown in Figure 7.12a, where the distances in meters between sites are given.  
(Distances between some sites are not shown because of natural hazards that would 
prevent a direct connection.) The most economical way to wire the devices so that 
they are all connected is to create a minimal spanning tree for the graph, as shown 
in Figure 7.12b. The total length of wire involved is 975 meters.
	
186
321
172
404
592
987
1120
844
12347
215
(a)
	
186
321
172
404
592
987
1120
844
12347
215
(b)
	
Figure 7.12
■

Special Interest Page
Pathfinding
Chapter 7
Pathfinding—as the name suggests—seeks to find a path 
from point x to point y, more specifically, the shortest 
path. This is a problem encountered in video games, 
when entities must move to a target point while avoid-
ing obstacles. On a much larger scale, Google Maps and 
other Web mapping sites allow us to enter a source x and 
a destination y and, in a very short time, receive driving 
directions to get from x to y.
Well, don’t we already know how to do that? 
­Dijkstra’s algorithm is the classic shortest-path algo-
rithm, but it’s an Θ(n2 ) algorithm. In the context of a 
real-time video game, quick response is essential. For 
Google maps, an Θ(n2 ) algorithm might not be a prob-
lem for a graph with 50, 500, or 2000 nodes, but scale 
up to the hundreds of thousands of cities and towns, and 
you’ll want to find a way to speed up the search. This 
is an important problem, and much research has been 
directed toward improving shortest-path performance.
One generalization of Dijkstra’s algorithm, called 
the a* algorithm, is used by many video game design-
ers. The exact techniques used by Google and other sites 
aren’t publicly revealed, but the a* algorithm may well 
be part of their arsenal. The a* algorithm generalizes 
Dijkstra’s algorithm by adding ideas borrowed from 
artificial intelligence. In fact, a*, strictly speaking, isn’t 
even an algorithm because there’s a big hole where one 
must plug in a “heuristic” (read an “educated guess”). 
The heuristic function used varies with the specifics of 
the application, and it’s the hard part of using a*.
Here’s an outline of how a* works. The general 
problem is that there is a graph with a source node x 
and a destination node y (for simplicity, assume that it’s 
a connected graph so that a path from x to y exists), and 
the arcs of the graph are weighted with known distances 
between nodes. At any point in time, a “closed set” 
­represents nodes that have been examined and need not 
be considered further. There is also an “open set” that 
represents nodes available for evaluation as the next 
node along the path. Initially, only node x is in the open 
set. Evaluation of a node n consists of three values that 
are maintained for each node in the open set:
G = the distance to get from x to n along the path 
being constructed
H = the result of the heuristic function that “guesses” 
the distance to get from n to y. This is a guess because 
the exact path from n to y is not yet known.
F = G + H
Pseudocode:
Put node x into the open set
Repeat the following process until y gets moved to the 
closed set:
Select the node p from the open set with the lowest F 
value (with some tie-breaking rule)
Move p to the closed set
For each node z that is adjacent to p and not in the 
closed set (you don’t want to go back to a previ-
ous node on the path), do the following:
If z is not in the open set, move z to the open set, 
compute its G, H, and F values (the G value 
is just the G value for p +  the weight of the 
p−z  arc), and set p as z’s parent node.
If z is in the open set, compute a new G value for 
z by going through node p; if this value is 
lower than z’s current G value, then recom-
pute z’s F value (which will also be lower 
than before) and set p as z’s parent node.
Once the target node y is in the closed set, walk back 
through the parents to the start node x. Reversing this 
walk gives the shortest path from x to y.
Note the similarities to Dijkstra’s algorithm (DA). 
There is a closed set (like the IN set of DA) that ­begins 
with the start node and eventually includes the end 
node. There is a next node p that gets moved into the 
closed set (moved into IN in DA). Once p is moved into 
the closed set, G values (distances from x in DA) are 
recomputed to see whether going through node p is an 
improvement. The algorithm terminates when the tar-
get node y is moved into the closed set (moved into IN 
in DA). The path is found by walking backward from y 
to x through a parent list (the s array in DA).
The difference between a* and Dijkstra’s algo-
rithm is that in a* the next node p is chosen based on 
the lowest F value, whereas in Dijkstra’s algorithm p is 
chosen based on the shortest distance from the source 
node (which is the same as the G value). So a* uses 

590	
Graph Algorithms
F to make its choice and Dijkstra’s algorithm uses G, 
but F = G + H. Dijkstra’s algorithm is therefore a* 
with a heuristic function that always returns 0. By us-
ing a non-zero heuristic H value, a* makes smarter 
choices (and therefore closes in on the shortest path 
faster) provided, of course, that the heuristic function 
is a good guess. If the heuristic function consistently 
overestimates the distance to the target, then the path 
computed will not be the shortest path. Another way 
to look at the difference between a* and Dijkstra’s 
­algorithm is to remember that Dijkstra’s algorithm is 
a greedy algorithm—it makes its decisions based on 
the local knowledge of how close adjacent nodes are to  
p. a* uses global knowledge (or assumed global 
knowledge) about not only how close adjacent nodes 
are to p but also how far they are from the target node.
http://www.policyalmanac.org/games/aStarTutorial.htm
http://www.heyes-jones.com/astar.html

S e c t i o n  7. 3 	
Review
Techniques
•	 Find a shortest path from x to y in a graph (using 
Dijkstra’s algorithm).
•	 Find a minimal spanning tree for a graph (using 
Prim’s algorithm).
Main Idea
•	 Algorithms that are Θ(n2) in the worst case can 
find a shortest path between two nodes or a mini-
mal spanning tree in a simple, positively weighted, 
connected graph with n nodes.
W
W
Exercises 7.3
For Exercises 1–4, use the graph that follows. Apply Dijkstra’s algorithm for the pairs of nodes given; show the 
values for p and IN and the d values and s values for each pass through the while loop. Write out the nodes in 
the shortest path and the distance of the path.
	 1.	 From 2 to 5
	 2.	 From 3 to 6
	 3.	 From 1 to 5
	 4.	 From 4 to 7
For Exercises 5 and 6, use the graph that follows. Apply Dijkstra’s algorithm for the pairs of nodes given; show 
the values for p and IN and the d values and s values for each pass through the while loop. Write out the nodes 
in the shortest path and the distance of the path.
3
2
1
1
1
2
1
1
4
a
f
c
d
b
e
	 5.	 From a to e
	 6.	 From d to a
	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
591

592	
Graph Algorithms
For Exercises 7 and 8, use the directed graph that follows. Apply Dijkstra’s algorithm to the nodes given; show 
the values for p and IN and the d values and s values for each pass through the while loop. Write out the nodes 
in the shortest path and the distance of the path.
	 7.	 From 1 to 7
	 8.	 From 3 to 1
	 9.	 a.	 Modify Dijkstra’s algorithm so that it finds the shortest paths from x to all other nodes in the graph.
	
b.	 Does this change the worst-case order of magnitude of the algorithm?
	 10.	Give an example to show that Dijkstra’s algorithm does not work when negative weights are allowed.
Another algorithm for finding shortest paths from a single source node to all other nodes in the graph is the 
Bellman–Ford algorithm. In contrast to Dijkstra’s algorithm, which keeps a set of nodes whose shortest path 
(minimum-weight path) of whatever length (that is, number of hops) has been determined, the Bellman–Ford 
algorithm performs a series of computations that seeks to find successively smaller-weight paths of length 1, 
then of length 2, then of length 3, and so on, up to a maximum of length n −1 (if a path exists at all, then there 
is a path of length no greater than n −1). A pseudocode description of the Bellman–Ford algorithm is given 
in the accompanying box; when using this algorithm, the adjacency matrix A must have a3i, i4 = 0 for all i.
	
Algorithm	
Bellman–Ford Algorithm
Bellman–Ford(n × n matrix A; node x; array of integers d; array of nodes s)
//Computes the shortest path between a source node x and all other nodes in a simple, 
//weighted, connected graph. A is a modified adjacency matrix with a3i, i4 = 0.
//When procedure terminates, the nodes in the shortest path from x to a node y
//are y, s3  y4, s3s3  y4 4, … , x; the distance for that path is d3  y4.
Local variables:
nodes z, p	
	
//temporary nodes
array of integers t	
//temporary distance array created at each iteration
//initialize arrays d and s; this establishes the shortest 1-length paths from x
d3x4 = 0
for all nodes z not equal to x do
d3z4 = a3x, z4
s3z4 = x 
end for
//find shortest paths of length 2, 3, etc.
for i = 2 to n −1 do
t = d	
//copy current array d into array t

//modify t to hold shortest paths of length i
for all nodes z not equal to x do
//find the shortest path with one more link 
p = node in G for which (d3  p4 +  a3  p, z4) is minimum
t3z4 = d3  p4 +  a3  p, z4
if p ∙z  then
s3z4 = p
end if
end for
d = t ;	
//copy array t back into d 
end for
end Bellman–Ford
	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
593
For Exercises 11–14 use the Bellman–Ford algorithm to find the shortest path from the source node to any other 
node. Show the successive d values and s values.
	 11.	Graph for Exercises 1–4, source node = 2 (compare your answer to Exercise 1)
	 12.	Graph for Exercises 1–4, source node = 1 (compare your answer to Exercise 3)
	 13.	Graph for Exercises 7–8, source node = 1 (compare your answer to Exercise 7)
	 14.	a.	 Accompanying graph, source node = 1 (compare your answer to Exercise 10)
	
b.	 What does this say about the Bellman–Ford algorithm as opposed to Dijkstra’s algorithm?
To compute the distance for the shortest path between any two nodes in a graph, Dijkstra’s algorithm could be 
used repeatedly, with each node in turn as the source node. A different algorithm, Floyd’s algorithm, can also 
be used to solve this “all pairs” shortest-path problem, but while Floyd’s algorithm produces the weight of 
all shortest paths, it does not calculate what the shortest paths actually are, that is, what nodes are on a given 
shortest path. Floyd’s algorithm is very similar to Warshall’s algorithm. A description follows, where A is the 
adjacency matrix of the graph with a3i, i4 = 0 for all i.
	
Algorithm	
Floyd’s Algorithm
Floyd (n × n matrix A)
//Computes the shortest path between any two nodes in a simple, weighted,
//connected graph; A is a modified adjacency matrix with a3i,i4 = 0.
//Upon termination, A will contain all the shortest-path distances
for k = 1 to n do
for i = 1 to n do
for j = 1 to n do
if a3i, k4 + a3k, j4 < a3i, j4 then
a3i, j4 = a3i, k4 +  a3k, j4 
end if
end for
end for
end for
end Floyd

594	
Graph Algorithms
For Exercises 15 and 16, use Floyd’s algorithm to find the distances for all the shortest paths. Show the successive 
values of the A matrix for each pass through the outer loop.
	 15.	Figure 7.10
	 16.	Graph for Exercises 1–4
For Exercises 17–20, use Prim’s algorithm to find a minimal spanning tree for the graph in the specified figure.
	 17.	Graph for Exercises 1–4
	
Algorithm	
Kruskal’s Algorithm
Kruskal (n × n matrix A; collection of arcs T )
//Finds a minimal spanning tree; T is initially empty;
//at termination, T = minimal spanning tree
order arcs in G by increasing distance
repeat
if next arc in order does not complete a cycle then
add that arc into T
end if
until T is connected and contains all nodes of G
end Kruskal
	 18.	
	 19.	
	 20.	
Kruskal’s algorithm is another algorithm for finding a minimal spanning tree in a connected graph. Whereas 
Prim’s algorithm “grows” the tree from an arbitrary starting point by attaching adjacent short arcs, ­Kruskal’s 
algorithm adds arcs in order by increasing distance wherever they may be in the graph. Ties are resolved 
­arbitrarily. The only restriction is that an arc is not added if adding it would create a cycle. The algorithm 
terminates when all nodes have been incorporated into a connected structure. A (very informal) pseudocode 
description follows:

For Exercises 21–24 use Kruskal’s algorithm to find the minimal spanning tree.
	
	
Section 7.3   Shortest Path and Minimal Spanning Tree	
595
	 21.	Graph for Exercises 1–4
	 22.	Graph for Exercise 18
	 23.	Graph for Exercise 19
	 24.	Graph for Exercise 20
	 25.	Give an example to show that adding the node closest to IN at each step, as is done in Prim’s minimal 
spanning tree algorithm, will not guarantee a shortest path.
	 26.	Let a be the arc of lowest weight in a weighted graph. Show that a must be an arc in any minimal spanning tree.
	 27.	A city plans to lay out bike paths connecting various city parks. A map with the distances between the parks 
is shown in the figure. (Some direct connections would have to cross major highways, so these distances 
are not shown in the map.) Find which paths to pave so that all parks are connected but the cost is minimal.
3
7
2
5
2
4
6
5
4
4
3
2
	 28.	Assume that arc weights represent distance. Then adding new nodes and arcs to a graph may result in a 
spanning tree for the new graph that has less weight than a spanning tree for the original graph. (The new 
spanning tree could represent a minimal-cost network for communications between a group of cities ob-
tained by adding a switch in a location outside any of the cities.)
	
a.	 Find a spanning tree of minimum weight for the following labeled graph. What is its weight?
	
b.	 Put a node in the center of the square. Add new arcs from the center to the corners. Find a spanning tree 
for the new graph, and compute its (approximate) weight.
	 29.	At the beginning of this chapter, you received the following assignment:
You are the network administrator for a wide-area backbone network that serves your company’s many offices 
across the country. Messages travel through the network by being routed from point to point until they reach 
their destination. Each node in the network therefore acts as a switching station to forward messages to other 
nodes according to a routing table maintained at each node. Some connections in the network carry heavy traf-
fic, while others are less used. Traffic may vary with the time of day; in addition, new nodes occasionally come 
on line and existing nodes may go off line. Therefore you must periodically provide each node with updated 
information so that it can forward messages along the most efficient (that is, the least heavily traveled) route.
How can you compute the routing table for each node?
	
	 You realize that you can represent the network as a weighted graph, where the arcs are the connections 
between nodes and the weights of the arcs represent traffic on the connections. The routing problem then be-
comes one of finding the shortest path in the graph from any node to any other node. Dijkstra’s algorithm can 
be used to give the shortest path from any one node to all other nodes (see Exercise 9), so you could use the 
algorithm repeatedly with different start nodes. Or you could use Floyd’s ­algorithm. Discuss the advantages 
and disadvantages of each approach, including an analysis of the order of ­magnitude of each approach.

596	
Graph Algorithms
	
S e c t i o n  7. 4 	 Traversal Algorithms
So far this chapter has considered various path questions about a graph G. Is there 
a path in G from node x to node y? Is there a path through G that uses each arc 
once? Is there a path through G that ends where we started and uses each node 
once? What is the minimum-weight path between x and y? In this section we deal 
with a simpler problem—we only want to write down all the nodes of a simple, 
connected graph G in some orderly way. This means we must find a path that 
visits each node at least once, but we can visit it more than once if we don’t write 
it down again. We can also retrace arcs on the graph if necessary, and clearly this 
would in general be necessary if we were to visit each node in a tree. This process 
is called graph traversal. We already have several mechanisms for tree traversal 
(Section 6.2). The two algorithms in this section generalize traversal to apply to 
any simple, connected graph. 
Depth-First Search
In the depth-first search algorithm for graph traversal, we begin at an arbitrary 
node a of the graph, mark it visited, and write it down. We then strike out on a 
path away from a, visiting and writing down nodes, proceeding as far as pos-
sible until there are no more unvisited nodes on that path. We then back up the 
path, at each node exploring any new side paths, until finally we retreat back to 
a. We then explore any new paths remaining from a. Figure 7.13 shows a graph 
after the first few nodes (marked by circles) have been visited using depth-first 
search.
	
Figure 7.13
For a more formal description of the depth-first search algorithm we will use 
recursion, where the algorithm invokes itself in the course of its execution. In the 
following algorithm, the input is a simple, connected graph G and a specified node 
a; the output is a list of all nodes in G in depth-first order from a.

	
	
Section 7.4   Traversal Algorithms	
597
	
Algorithm	
DepthFirst
DepthFirst(simple, connected graph G; node a)
//Writes nodes in graph G in depth-first order from node a
mark a visited
write (a)
for each node n adjacent to a do
if n not visited then
DepthFirst(G, n)
end if
end for
end DepthFirst
In the recursive step, the algorithm is invoked with a new node specified as the 
starting point. We have not indicated here how to mark visited nodes or how to 
find those nodes n that are adjacent to a.
	
Example 11	
We will apply depth-first search to the graph of Figure 7.13, where a is the initial 
node. We first mark that we have visited a (it’s helpful in tracing the execution of 
the algorithm to circle a visited node), and then we write out a. Next we search the 
nodes adjacent to a for an unvisited node. We have a choice here (b, e, h, and i); let us 
select node b. (Just so we all get the same answers, let’s agree to choose the node 
that is alphabetically first when we have a choice; in practice, the choice would  
be determined by how the vertices were stored in the graph representation.) Then 
we invoke the depth-first search algorithm beginning with node b.
We go back to the beginning of the algorithm, where the specified node is 
now b rather than a. Thus we first mark b visited and write it out. Then we search 
through nodes adjacent to b to find an unmarked node. Nodes a and c are adjacent 
to b, but node a is marked as already visited. Node c will do, and we invoke the 
depth-first search algorithm beginning with node c.
Node c is marked and written out, and we look for unmarked nodes adjacent to 
c. By our alphabetical convention, we select node d from the set 5d, f  6. Continuing 
in this fashion, after visiting node d we next visit node f and then node g. When we 
get to node g, we have reached a dead end because there are no unvisited adjacent 
nodes. Thus the for loop of the instance of the algorithm invoked with node g is 
complete. (The graph at this point looks like Figure 7.13.)
We are therefore done with the algorithm for node g, but node g was (possibly 
one of) the unmarked nodes adjacent to node f, and we are still in the for loop for the 
instance of the algorithm invoked with node f. As it happens, g is the only unvisited 
node when we are processing f; therefore we complete the for loop and thus the algo-
rithm for node f. Similarly, backing up to node d, the algorithm finds no other adjacent 
unmarked nodes, and it backs up again to the instance of the algorithm invoked with 
node c. Thus, after processing node d and everything that came after it until the dead 
end, we are still in the for loop for the algorithm applied to node c. We look for other 
unmarked nodes adjacent to c and find one—node e. Therefore we apply depth-first 
search to node e, which leads to nodes h, i, and k before another dead end is reached. 
Backing up, we have a final new path to try from node h, which leads to node j. The 
complete list of the nodes, in the order in which they would be written out, is
	
a, b, c, d, f, g, e, h, i, k, j
REMINDER
In a depth-first search, go 
as far as possible, then 
back up, catching any 
paths missed on the way 
down.

598	
Graph Algorithms
Example 11 makes the depth-first search process sound very complex, but it is 
much easier to carry out than to write down, as you will see in Practice 14.
Breadth-First Search
In breadth-first search, beginning at an arbitrary node a, we first fan out from node 
a to visit nodes that are adjacent to a; then we fan out from those nodes, and so on, 
almost like the concentric circles of ripples in a pond. Figure 7.15 shows the first few 
nodes visited in the same graph as Figure 7.13, this time using breadth-first search.
	
Figure 7.15
Practice 14	 Write the nodes in a depth-first search of the graph in Figure 7.14. Begin with node a.
	
Figure 7.14
■

To write the breadth-first search algorithm in an elegant fashion, we will use a 
queue structure. A queue is simply a line in which new arrivals are added at the back 
and departures take place at the front. A checkout line in a grocery store is an example 
of a queue of customers—a new customer joins the line at the back and departures 
take place from the front of the line as customers are checked through. The addition of 
an entry at the back of a queue is called an enqueue operation, and a departure from 
the front of the queue is called a dequeue operation. Thus the notation enqueue(a, Q) 
denotes adding a to the end of a queue called Q, and dequeue(Q) denotes removal of 
the entry currently at the front of Q. We’ll also use a function front(Q), which returns 
the value of the entry currently at the front of Q but does not remove that entry. In the 
following algorithm, the input is a simple, connected graph G and a specified node a; 
the output is a list of all nodes in G in breadth-first order from a.
	
Algorithm	
BreadthFirst
BreadthFirst(simple, connected graph G; node a);
//writes nodes in graph G in breadth first order from node a
Local Variable:
queue of nodes Q
initialize Q to be empty
mark a visited
write(a)
enqueue(a, Q)
while Q is not empty do
for each node n adjacent to front(Q) do
if n not visited then
mark n visited
write(n)
enqueue(n, Q)
end if
end for
dequeue(Q)
end while
end BreadthFirst
	
Example 12	
Let’s walk through the algorithm for a breadth-first search of the graph of Figure 
7.15 beginning at node a (this is the same graph on which we did the depth-first 
search in Example 11). We begin by initializing an empty queue Q, marking node a 
as visited, writing it out, and adding it to the queue. When we first reach the while 
loop, the queue is not empty and a is the entry at the front of the queue. In the for 
loop, we look for unvisited nodes adjacent to a to visit, write them out, and add 
them to the back of the queue. We may have a choice of nodes to visit here; as be-
fore, and purely as a convention, we will agree to visit them in alphabetical order. 
Thus the first time we complete the for loop, we have visited and written out b, e, 
h, and i, in that order, and added them to the queue. The graph at this point looks 
	
	
Section 7.4   Traversal Algorithms	
599

600	
Graph Algorithms
like Figure 7.15. We then remove a from the front of the queue, which as a result 
contains (from front to back)
b, e, h, i
In the next iteration of the while loop, b is the front element in the queue, and the 
for loop searches for unvisited nodes adjacent to b. The only previously unvisited 
node here is c, which gets marked as visited, written out and added to the queue. 
After removing b, the queue contains
e, h, i, c
Performing the while loop again, e is at the front of the queue. A search of the 
nodes adjacent to node e produces one new node, node j. The graph now looks like 
Figure 7.16, and after removing e the queue contains
h, i, c, j
	
Figure 7.16
When searching for nodes adjacent to h, we pick up one new node, node k. When 
searching for nodes adjacent to i, no new nodes are added to the queue. When c 
becomes the first element in the queue, a search for nodes adjacent to c turns up 
two new nodes, d and f. After adding these to the queue (and removing c), the 
queue contains
j, k, d, f
Looking for nodes adjacent to j and then to k adds no new nodes to the queue. 
When the front of the queue is d, a new node g is found, and the queue (after re-
moving d) is
f, g

Processing f and then g yields no new nodes. After g is removed from the queue, 
the queue is empty. The while loop—as well as the algorithm—terminates. The list 
of nodes written out by this process, that is, the nodes in breadth-first order from 
a, are
a, b, e, h, i, c, j, k, d, f, g 
Like the depth-first search, the breadth-first search is not difficult to trace; one 
must just keep track of the nodes that have been visited and the current contents 
of the queue.
Analysis
How much work do the depth-first search and breadth-first searches perform? 
Both algorithms look for all unvisited nodes adjacent to a given node. Suppose 
the graph contains n nodes and m arcs. One of the advantages of representing a 
graph as an adjacency list rather than an adjacency matrix is that this particular 
operation is more efficient; to find nodes adjacent to node i requires traversing i’s 
adjacency list, which may be short, rather than traversing row i of the adjacency 
matrix, which must contain n entries. Therefore we will assume an adjacency list 
representation of the graph.
In breadth-first search, the algorithm searches all at one time the entire ad-
jacency list of the node at the front of the queue, marking, writing out, and en-
queuing the unvisited nodes found. In the depth-first search, the algorithm may be 
interrupted many times while traversing the adjacency list of a given node to go 
off (by virtue of the recursion) and process sections of the adjacency lists of other 
nodes. Eventually, however, every adjacency list is completely covered.
Traversing the adjacency lists of the graph drives the amount of work done in 
either search. There are n adjacency lists, so the amount of work is at least Θ(n) 
because each adjacency list must be checked. Because there are m arcs, the work 
in traversing the total length of all the adjacency lists is at least Θ(m). Therefore 
both depth-first search and breadth-first search are Θ(max(n, m)) algorithms. If 
there are more arcs than nodes (the usual case), then Θ(max(n, m)) = Θ(m).
Applications
Depth-first search and breadth-first search can be used as the basis for performing 
other graph-related tasks, some of which we have solved before. A nonrooted tree 
structure that is a subgraph of the original graph can be associated with each search. 
When traversing node i’s adjacency list, if node j is adjacent to i and is previously 
unvisited, then the i–j arc is added to this subgraph. Because no arc to a previously 
visited node is used, cycles are avoided and the subgraph is a nonrooted tree. Be-
cause all nodes ultimately are visited (for the first time), these trees are spanning 
trees for the graph. Each tree has n −1 arcs, the minimal number of arcs to connect 
n nodes. Here we are assuming that arcs are unweighted, but if we consider them to 
be weighted arcs, each with weight 1, then these trees are minimal spanning trees.
	
	
Section 7.4   Traversal Algorithms	
601
Practice 15	 Write the nodes in a breadth-first search of the graph in Figure 7.14, beginning with node a.
■

602	
Graph Algorithms
The dark lines in Figure 7.13 are part of the depth-first search tree associated 
with the search of Example 11, and the dark lines in Figures 7.15 and 7.16 are part 
of the breadth-first search tree associated with the search of Example 12.
Practice 16
	
a.	 Complete the depth-first search tree for Example 11.
	
b.	Complete the breadth-first search tree for Example 12.
The depth-first search and breadth-first search algorithms apply equally well 
to directed graphs and in the process yield a new algorithm for reachability. To 
determine whether node j is reachable from node i, do a depth-first (or breadth-
first) search beginning at node i; when the algorithm terminates, check whether 
node j has been visited. “All pairs” reachability, that is, which nodes are reach-
able from which nodes, can thus be determined by running depth-first or breadth-
first searches using each node in turn as the source node. This process would 
require Θ(n * max(n, m)) work. If the graph is very sparse, in which case we have 
max(n, m) = n, we would have an Θ(n2) algorithm for reachability. Recall that 
Warshall’s algorithm (Section 7.1) was an Θ(n3) algorithm. The improvement 
comes about because in a sparse graph, most adjacency lists will be short or emp-
ty, whereas Warshall’s algorithm processes entries in the adjacency matrix even if 
those entries are 0s. But if the graph is not sparse, the number of arcs can be Θ(n2), 
in which case Θ(n * min(n, m)) = Θ(n3), the same as Warshall’s algorithm. In ad-
dition, Warshall’s algorithm has the advantage of succinct implementation.
In Section 5.2 we defined a topological sort as a way to extend a partial order-
ing on a finite set to a total ordering. Let the partially ordered set be represented 
by a directed graph. The topological sort will be achieved by counting the nodes, 
so let the initial value of the count be 0. Pick a node as a source node and perform 
a depth-first search from this node. Whenever the search backs up from a node for 
the final time, assign that node the next counting number. When the depth-first 
search algorithm terminates, pick an unvisited node (if one exists) to be the source 
for another depth-first search, and continue to increment the counting number. 
Continue this process until there are no unvisited nodes left in the graph. A to-
pological sort results by ordering the nodes in the reverse order of their counting 
number. This process for topological sorting works because we assign the count-
ing number when we back up from a node for the final time. Its counting number 
will then be higher than the numbers of all the nodes reachable from it, that is, all 
the nodes of which it is a predecessor in the partial ordering,
	
Example 13	
Figure 7.17a is a directed graph that represents a partial ordering. Choosing d 
­(arbitrarily) as the source node and performing a depth-first search, we visit e and 
f, at which point we must back up. Node f is assigned the counting number 1, but 
we are not yet done with e, because we can go on to visit g. Backing up from g, 
g is assigned the counting number 2. At this point we back up from e for the final 
time and assign e the number 3 and then d the number 4. We choose a as the source 
node for another search. We visit node c and then must back up, so c and a are as-
signed the numbers 5 and 6, respectively. Beginning with b as a source node, there 
■

is ­nowhere to go, and b is assigned the number 7. There are no unvisited nodes 
left in the graph, so the process stops. The numbering scheme is shown in Figure 
7.17b.
	
Figure 7.17
In reverse order of the counting numbers, we get
	
7	
6	
5	
4	
3	
2	
1
	
b	
a	
c	
d	
e	
g	
f
which is a topological ordering.
Now consider a graph G (undirected) that may not be a connected graph. A 
connected component of G is a subgraph of G that is both connected and not a 
subgraph of a larger connected subgraph. In Figure 7.19 there are three connected 
components. Of course, if the original graph is connected, then it has only one 
connected component.
	
Figure 7.19
Practice 17	 Use the depth-first search algorithm to do a topological sort on the graph in Figure 7.18. 
Indicate the counting numbers on the graph.
	
Figure 7.18
	
	
Section 7.4   Traversal Algorithms	
603
■

604	
Graph Algorithms
A depth-first or breadth-first search can be used to find the connected com-
ponents of a graph. We pick an arbitrary node as a source node and then conduct 
a search. When the algorithm terminates, all visited nodes belong to one compo-
nent. We then find an unvisited node in the graph to serve as a source for another 
search, which will produce a second component. We continue this process until 
there are no unvisited nodes in the graph.
Although we defined reachability only for directed graphs, the concept also 
makes sense for undirected, unconnected graphs. Let us consider only simple un-
directed, unconnected graphs but impose the convention that, even though there 
are no loops, each node is reachable from itself. Reachability then becomes an 
equivalence relation on the set of nodes of the graph; our convention imposes the 
reflexive property, and symmetry and transitivity follow because the graph is un-
directed. This equivalence relation partitions the nodes of the graph into equiva-
lence classes, and each class consists of the nodes in one connected component 
of the graph. Warshall’s algorithm can be applied to undirected graphs as well as 
directed graphs. Using Warshall’s algorithm results in a matrix from which the 
nodes making up various components of the graph can be determined, but this 
requires more work than using the depth-first search.
As a final remark about depth-first search, we saw in Section 1.5 that the 
­programming language Prolog, when processing a query based on a recursive 
definition, pursues a depth-first search strategy (Example 40).
S e c t i o n  7. 4 	
Review
Techniques
•	 Conduct a depth-first search of a graph.
•	 Conduct a breadth-first search of a graph.
Main Ideas
•	 Algorithms exist to visit the nodes of a graph 
­systematically.
•	 Depth-first and breadth-first searches can serve as a 
basis for other tasks.
W
W
Exercises 7.4
For Exercises 1–6, write the nodes in a depth-first search of the following graph, beginning with the node specified.
	 1.	 a	
2.	 c	
3.	 d	
4.	 g	
5.	 e	
6.	 h

For Exercises 7–10, write the nodes in a depth-first search of the following graph, beginning with the node 
specified.
	 7.	 a	
8.	 e	
9.	 f	
10.	h
For Exercises 11–16, write the nodes in a breadth-first search of the graph for Exercises 1–6, beginning with 
the node specified.
	 11.	a	
12.	c	
13.	 d	
14.	 g	
15.	e	
16.	 h
For Exercises 17–20, write the nodes in a breadth-first search of the graph for Exercises 7–10, beginning with 
the node specified.
	 17.	a	
18.	e	
19.	 f	
20.	 h
For Exercises 21–24, write the nodes in a depth-first search of the following graph, beginning with the node 
specified.
	 21.	a	
22.	 g	
23.	 f	
24.	 e
	
	
Section 7.4   Traversal Algorithms	
605

606	
Graph Algorithms
For Exercises 25–28, write the nodes in a breadth-first search of the graph for Exercises 21–24, beginning with 
the node specified.
	 25.	a	
26.	 g	
27.	 f	
28.	 e
	 29.	In the computer network in the accompanying figure, the same message is to be broadcast from node C 
to nodes A, E, F, and G. One way to do this is to find the shortest path from C to each of these nodes and 
send out multiple copies of the same message. A more efficient approach is to send one copy out from C 
along a spanning tree for the subgraph containing the nodes involved. Use the depth-first search algorithm 
to find a spanning tree for the subgraph.
A
C
B
E
D
F
G
	 30.	Using the graph for Exercise 29, use the breadth-first search algorithm to find a spanning tree for the ­subgraph.
	 31.	Use the depth-first search algorithm to do a topological sort on the following graph. Indicate the counting 
numbers on the graph. Also state the starting node or nodes for the search.
	 32.	Use the depth-first search algorithm to do a topological sort on the following graph. Indicate the counting 
numbers on the graph. Also state the starting node or nodes for the search.
	 33.	The data structure used to implement a breadth-first search is a queue. What is the appropriate data structure 
to implement a depth-first search?
	 34.	Find a way to traverse a tree in level order, that is, so that all nodes at the same depth are listed from left 
to right for increasing depth. (Hint: We already have a way to do this.)
	 35.	Describe how the depth-first search algorithm can be used in a connected (undirected) graph to detect 
the presence of cycles in the graph. (While it is simple to look at Figure 7.13 and see that a–b–c–e–a, for 
example, is a cycle, in a huge graph with thousands of node and arcs, a cycle may be less easy to spot, in 
addition to which you might not even have a visual representation.)

	 36.	a.	Describe the order in which nodes are visited in a breadth-first search of the bipartite complete graph Km,n.
	
b.	Describe the order in which nodes are visited in a depth-first search of the bipartite complete graph Km,n.
	
S e c t i o n  7. 5 	 Articulation Points and Computer Networks
The Problem Statement
In a graph that represents a computer network, the nodes denote the communicat-
ing entities (end-user computers, servers, routers, and so on) and the arcs denote 
the communications medium (coaxial cable, fiber optic, and so on). Such a graph 
should be a connected graph, so that there is a path between every pair of nodes. 
To minimize the length of cable or wire required, we would choose a minimum 
spanning tree. However, if an arc in a minimum spanning tree is removed (for 
example, that section of cable or wire is damaged or broken), then the graph is no 
longer connected. Each arc becomes a single point of failure for the network. That 
is why such a network usually contains more arcs than just those of a minimal 
spanning tree. However, even in a graph sufficiently rich in arcs to withstand the 
loss of a single arc, a node may be a single point of failure. If the node fails (and 
thus is logically removed), the arcs of which that node is an endpoint are disabled 
and the result may be a disconnected graph.
	
Definition	
Articulation Point
A node in a simple, connected graph is an articulation point if its removal 
(along with its attached arcs) causes the remaining graph to be disconnected.
	
Example 14	
Node d in the graph of Figure 7.20a is an articulation point. Removing d results in 
the disconnected graph of Figure 7.20b.
a
a
g
g
b
c
b
c
e
d
f
e
f
(a)
(b)
	
Figure 7.20
	
Definition	
Biconnected Graph
A simple, connected graph is biconnected if it has no articulation points.
	
	
Section 7.5  Articulation Points and Computer Networks	
607

608	
Graph Algorithms
The presence of articulation points is clearly an undesirable feature of a net-
work. Although it is easy to spot an articulation point in a graph as small as that 
of Figure 7.20a, we will develop an algorithm that will detect such points no mat-
ter how large the graph (and, of course, does not require a visual representation 
of the graph). Articulation points separate the graph into biconnected compo-
nents, subgraphs that are biconnected and are not subgraphs of larger biconnected 
­subgraphs. In Figure 7.20, a–b–d–c and d–e–g–f are biconnected components.
The Idea behind the Algorithm
The key to this algorithm is depth-first search. We know from the previous section 
that a depth-first search determines a nonrooted tree. An arc is added to the tree 
whenever the search progresses to a previously unvisited node. Arcs of the graph 
belonging to this tree are called tree arcs. The remaining arcs in the graph are 
called back arcs.
	
Example 15	
In Figure 7.20 a depth-first search from node a visits nodes in the order a, b, d, c, 
e, g, and f. In Figure 7.21 the tree arcs are dark, and the back arcs are light.
a
g
b
c
e
d
f
	
Figure 7.21
The depth-first search tree passes through all nodes. To detect nodes that are 
articulation points, we examine their relative positions in the tree. First consider 
the single node that is the starting point of the depth-first search tree. If only one 
tree arc emanates from the starting node, then as the tree continues, all other 
nodes in the graph can be reached from the node at the other end of that tree arc. 
Therefore, removing the starting node will not disconnect the graph. However, if 
two or more tree arcs emanate from the starting node, then the only way to get 
from one subtree to another is to pass back through the starting node. In this case, 
removing the starting node disconnects the graph.
Thus in Figure 7.21 node a is the starting node of the depth-first search tree, 
and there is a single tree arc emanating from a. Removing node a (and its two arcs) 
does not disconnect the graph. Had we begun a depth-first search at node d, how-
ever, the tree would have looked like Figure 7.22. There would be two tree arcs 
coming from node d, showing that d is an articulation point.

a
g
b
c
e
d
f
	
Figure 7.22
Consider any node n that is a leaf of the depth-first search tree (attached to the 
end of a single tree arc). Such a leaf may be a leaf of the graph itself, that is, a node 
of degree 1, in which case it is clearly not an articulation point. If not, then the 
other arcs emanating from n were not used in the depth-first search, so the nodes 
adjacent to n are reachable through alternative paths that do not go through n. 
Because n is not needed on a path to any other node, its removal does not discon-
nect the graph. Therefore no leaves of the depth-first search tree are articulation 
points. In Figure 7.21 node c, for example, is a leaf of the depth-first search tree; 
the arc from c to a is a back arc, so node a is accessible through another route that 
does not require node c. Node c can be removed without disconnecting the graph.
Now consider a node n that is not a leaf in the depth-first search tree and is 
not the starting node. Because n is not a leaf, there are one or more subtrees below 
n. Suppose there is a single subtree; let x be a node on this subtree. If x has a back 
arc to some node that precedes n in the depth-first search (an “ancestor” of n), then 
this arc provides part of an alternative path for x—and all other nodes in the sub-
tree—to be connected with the rest of the graph without using node n. In this case 
n is not an articulation point. (See Figure 7.23a, where removing n and its attached 
arcs does not disconnect the graph.) If there is more than one subtree below n, then 
n will not be an articulation point if and only if each subtree has such an “escape 
route” allowing it to connect with the rest of the graph—including the other sub-
trees—without going through n. (See Figure 6.23b; note that the back arc from y 
to z does not help because it does not reach back to an ancestor of n.)
n
x
r
n
z
y
x
r
Escape route
Escape route
Escape route
(a)
(b)
	
Figure 7.23
	
	
Section 7.5  Articulation Points and Computer Networks	
609

610	
Graph Algorithms
The Algorithm Itself
The key to the algorithm, as we may guess from the foregoing discussion, is keeping 
track of the destinations of the back arcs. We will assign a tree number to each node 
that corresponds to the order in which that node is visited in the depth-first search. 
Thus the starting node in a depth-first search has tree number 1, the next node visited 
has tree number 2, and so on. In addition, we will maintain a “back number” for each 
node x. The back number will be the minimum tree number of a node (the farthest 
back node) reachable from x using either back arcs from x or from descendants of x in 
the subtree. To incorporate information about back arcs of descendants of x, the back 
number of x is adjusted when the depth-first search backs up to node x from farther 
down in the tree. Node n is an articulation point whenever a subtree of n has no back 
arc to an ancestor of n, and this circumstance is detected when the search backs up to 
n from the subtree. Suppose the search is backing up from x to n. If the back number 
of x at this point is not smaller than the tree number of n, then n is an articulation point.
The following algorithm carries out the depth-first search and builds the 
depth-first search tree. It correctly handles both leaves and nonstarting-node non-
leaves of the depth-first search tree, leaving only the starting node as a special 
case. It also assumes that the graph structure itself contains the tree number and 
back number for each node.
	
Algorithm	
ArtPoint
ArtPoint(graph G; node n; integer TreeNumber)
//detects articulation points in G by depth-first search from n; graph G 
//also maintains a tree number TN and back number BN value for each 
//node;TreeNumber = 0 when first invoked.
Local variable:
node x	
//temporary node
mark n visited	
//first encountering n, assign its numbers
TreeNumber = TreeNumber + 1
TN3n4 = TreeNumber
BN3n4 = TN3n4
for each node x adjacent to n by a nontree edge do
if x not visited then
make n–x a tree edge
ArtPoint(G, x, TreeNumber)
//depth-first search now backing up to n from x
if BN3x4 >= TN3n4then	
//line 1
write(“n is an articulation point”)
else
//adjust back number of n
BN3n4 = min(BN3n4, BN3x4)	
//line 2
end if
else
//arc n–x is a back edge, adjust BN 3n4
BN3n4 = min(BN3n4, TN3x4)	
//line 3
end if
end for
end ArtPoint

	
Example 16	
We will trace the articulation point algorithm on the graph of Figure 7.20a, where 
a is the starting node. The tree begins with arcs a–b, b–d, and d–c. Each new node 
is numbered with a consecutive tree number, and its back number is set equal to 
its tree number (Figure 7.24a; in the figure, the numbers in parentheses are the tree 
number and the back number, respectively). While processing node c, the back 
edge to a is discovered, and the back number of c is adjusted to 1, the tree number 
of a (line 3 in the algorithm description). This action completes the processing of 
node c, and the depth-first search backs up to d. The back number of c is less than 
the tree number of d, so the back number of d is adjusted to equal that of c (line 2). 
The situation at this point is shown in Figure 7.24b.
The depth-first search moves on to nodes e, g, and f (Figure 7.24c). At f the 
back arc to d is found, and the back number of f is set equal to the tree number of d 
(line 3). Backing up from f to g, the back number of g is adjusted to equal the back 
number of f (line 2) and similarly for e (line 2 again). (See Figure 7.24d.)
a (1, 1)
g
g
g (6, 6)
g (6, 3)
g (6, 3)
b (2, 2)
c (4, 4)
e
d (3, 3)
a (1, 1)
b (2, 2)
c (4, 1)
d (3, 1)
a (1, 1)
(a)
(b)
(d)
(e)
(c)
b (2, 2)
c (4, 1)
d (3, 1)
f
e
f
e (5, 5)
f (7, 7)
e (5, 3)
f (7, 3)
e (5, 3)
d = articulation point
f (7, 3)
a (1, 1)
b (2, 2)
c (4, 1)
d (3, 1)
a (1, 1)
b (2, 1)
c (4, 1)
d (3, 1)
	
Figure 7.24
Finally, in backing up from e to d, the back number of e is greater than or equal 
to the tree number of d, so d is declared an articulation point (line 1). The re-
cursion backs up to node b, adjusting the back number of b, and then node a, 
at which point line 1 would seem to apply (Figure 7.24e). But a is the starting 
node of the search and so is not an articulation point, because there is only one 
tree arc from a.
	
	
Section 7.5  Articulation Points and Computer Networks	
611

612	
Graph Algorithms
S e c t i o n  7. 5 	
Review
Technique
•	 Find articulation points in a simple, connected 
graph (using algorithm ArtPoint)
Main Idea
•	 Articulation points represent single points of fail-
ure in a computer network, but an algorithm exists 
to detect their presence.
Practice 18	 In Figure 7.25, the depth-first search began at node a. Explain why each node is marked as 
it is and how it is concluded that c is an articulation point.
c = articulation point
b (2, 1)
a (1, 1)
c (3, 1)
d (4, 4)
	
Figure 7.25
W
Exercises 7.5
For Exercises 1–6, draw the depth-first search trees, where node a is the starting node of the depth-first search. 
Identify the back arcs.
	 1.	
b
a
c
e
d
	 2.	
g
a
c
h
b
e
f
i
d
	 3.	
b
a
c
d
g
e
f
h
	 4.	
e
a
g
f
c
b
	 5.	
d
a
b
g
f
e
c
h
	 6.	
d
a
b
g
e
f
c
h
■

For Exercises 7–12, use algorithm ArtPoint to find the articulation points. Label the tree number and back 
number for each node, both as first assigned and as changed. Draw the biconnected components of the graph.
	 7.	
a
d
b
e
g
f
c
	 8.	
a
c
e
d
b
	 9.	
a
c
e
b
d
f
	 10.	a
b
c
d
e
	 11.	
a
b
c
d
e
f
g
h
	 12.	a
b
c
g
h
d
e
f
i
	
	
Section 7.5  Articulation Points and Computer Networks	
613

614	
Graph Algorithms
C h a p t e r  7 	
Review
Terminology
adjacency relation (p. 555)
articulation point(p. 607)
back arc (p. 608)
biconnected component(p. 608)
biconnected graph(p. 607)
breadth-first search (p. 598)
connected component (p. 603)
depth-first search (p. 596)
dequeue (p. 599)
enqueue (p. 599)
Euler path (p. 572)
even node (p. 572)
graph traversal (p. 596)
greedy algorithm (p. 586)
Hamiltonian circuit (p. 576)
minimal spanning tree (p. 587)
odd node (p. 572)
queue (p. 599)
reachable node (p. 557)
reachability matrix (p. 559)
spanning tree (p. 587)
tree arc (p. 608)
Self-Test
Answer the following true–false questions.
Section 7.1
1.	Any binary relation on a set N has an associated 
adjacency matrix.
2.	Transitive closure is the adjacency relation equiva-
lent of reachability.
3.	The reachability matrix R for a directed graph G 
is computed by taking the powers of the adjacency 
matrix up to n2.
4.	Warshall’s algorithm proceeds by computing, in 
turn, the number of paths of length 1, then length 2, 
and so on, between nodes.
5.	Warshall’s algorithm computes symmetric closure 
in the case of a symmetric adjacency relation.
Section 7.2
1.	A graph with four odd nodes can still be a connected 
graph.
2.	An Euler path exists in any graph with an even 
number of odd nodes.
3.	An Θ(n2) algorithm exists to test the existence of 
an Euler path in a graph with n nodes.
4.	A Hamiltonian circuit uses each arc and node of the 
graph exactly once except for the starting and end-
ing node.
5.	No algorithm to solve the Hamiltonian circuit 
problem is known.
Section 7.3
1.	Dijkstra’s algorithm for the shortest path in a graph 
maintains a set IN and adds at each step the node 
closest to a node in IN.
2.	A greedy algorithm is one that recursively divides 
the problem into as many subproblems as possible.
3.	The minimal spanning tree for a graph may not be 
unique.
4.	Using a linked-list representation for nodes not in 
IN does not improve the order of magnitude of the 
worst-case work done by Dijkstra’s algorithm.
5.	The collection of all arcs that are not in a minimal 
spanning tree for a graph will also form a spanning 
tree, but it may not be minimal.
Section 7.4
1.	The depth-first search visits nodes at the bottom of 
the graph first.
2.	In a breadth-first search beginning with node i, all 
the nodes adjacent to i are visited in order.
3.	An analysis of the depth-first search and the 
breadth-first search shows them to be algorithms of 
the same order of magnitude.
4.	Preorder traversal is the tree equivalent of the 
breadth-first search, using the root as the starting node.
5.	Topological sorting can be done by a succession of 
breadth-first searches on a directed graph.
Section 7.5
1.	If node n is an articulation point in a connected 
graph, then any path between any two nodes in the 
graph must pass through n.
2.	A biconnected graph is a simple, connected graph 
with no articulation points.
3.	When a node n is first reached during a depth-first 
search, any other arcs from n to previously visited 
nodes are back arcs.
4.	A node n where every subtree of n in the depth-first 
search tree has a back arc to a predecessor of n is 
not an articulation point.
5.	The root of a depth-first search is always an articula-
tion point in the graph because any node’s back num-
ber will be greater than or equal to its tree number.

	
	
Chapter 7   Review	
615
O n  t h e  C o m p u t e r
For Exercises 1–5, write a computer program that 
produces the desired output from the given input.
1.	Input: Adjacency matrix A for a directed graph
	
Output: Reachability matrix R for the graph, comput-
ed from the formula r = a ~  a(2) ~ c~  a(n) 
2.	Input: Adjacency matrix A for a directed graph
	
Output: Reachability matrix R for the graph, com-
puted by using Warshall’s algorithm
3.	Input: Adjacency matrix A for a graph
	
Output: Message indicating whether the graph has 
an Euler path
4. Input: Adjacency matrix A for a simple weighted 
graph or directed graph and two nodes in the graph
	
Output: Distance for the shortest path between the 
two nodes or a message that no path exists; verti-
ces in the shortest path if one exists (Hint: You will 
need to find some way of denoting which vertices 
are currently in IN.)
5. Input: Adjacency matrix A for a simple, weighted, 
connected graph
	
Output: Arcs (as ordered pairs) in a minimal 
­spanning tree
For Exercises 6–8, first write a function that collects 
information from the user about a graph and builds an 
adjacency list representation of the graph; incorporate 
this function in the programs requested.
6.	Input: Information about a graph (see instructions 
above) and a node in the graph 
	
Output: Nodes in a depth-first search of the graph 
beginning with the given node
7.	Input: Information about a graph (see instructions 
above) and a node in the graph
	
Output: Nodes in a breadth-first search of the graph 
beginning with the given node
8. Input: Information about a graph (see instructions 
above)
	
Output: Articulation points in the graph

This page intentionally left blank 

Chapter Objectives
After studying this chapter, you will be able to:
•	 Determine whether a given mathematical structure is a Boolean algebra.
•	 Prove properties about Boolean algebras.
•	 Understand what it means for an isomorphism function to preserve the effects 
of a binary operation or other property.
•	 Draw a logic network to represent a Boolean expression.
•	 Write a Boolean expression to represent a logic network.
•	 Write the truth function for a Boolean expression or logic network.
•	 Write a Boolean expression in canonical sum-of-products form for a given 
truth function.
•	 Use NAND and NOR gates as well as AND, OR, and NOT gates to build logic 
networks.
•	 Write a truth function from a description of a logical control device.
•	 Simplify Boolean expressions and logic networks using Karnaugh maps.
•	 Simplify Boolean expressions and logic networks using the Quine–McCluskey 
method.
You have been hired by Rats R Us to build the control logic for the production facilities 
for a new anticancer chemical compound being tested on rats. The control logic must 
manage the opening and closing of two valves, A and B, downstream of the mixing 
vat. Valve A is to open whenever the pressure in the vat exceeds 50 psi (pounds per 
square inch) and the salinity of the mixture exceeds 45 g/L (grams per liter). Valve B is 
to open whenever valve A is closed and the temperature exceeds 53°C and the acidity 
falls below 7.0 pH (lower pH values mean more acidity).
	
Question:	
How many and what type of logic gates will be needed in the circuit?
The answer to this electronics problem lies, surprisingly, in a branch of math-
ematics developed around 1850 by George Boole, an English mathematician. 
Boole was interested in developing rules of “algebra” for logical thinking, 
similar to the rules of algebra for numerical thinking. Derided at the time as 
useless, if harmless, Boole’s work is the foundation for the electronics found in 
computers today.
8
Boolean Algebra and  
Computer Logic
Chapter
617

618	
Boolean Algebra and Computer Logic 
In Section 8.1 we define Boolean algebra as a mathematical model of both 
propositional logic and set theory. The definition requires every Boolean algebra 
to have certain properties, from which many additional properties can be derived. 
This section also discusses what it means for two instances of a Boolean algebra 
to be isomorphic.
Section 8.2 establishes a relationship between the Boolean algebra structure 
and the wiring diagrams for the electronic circuits in computers, calculators, in-
dustrial control devices, telephone systems, and so forth. Indeed, we will see that 
truth functions, expressions made up of variables and the operations of Boolean 
algebra, and these wiring diagrams are all related. As a result, we can effectively 
pass from one formulation to another and still preserve characteristic behavior 
with respect to truth values. We will also find that we can simplify wiring dia-
grams by using properties of Boolean algebras. In Section 8.3 we will look at two 
other procedures for simplifying wiring diagrams.
	
S e c t i o n  8 .1 	 Boolean Algebra Structure
Let us revisit the wffs of propositional logic and associate with them a certain 
type of function. Suppose a propositional wff P has n statement letters. Then each 
row of the truth table for that wff associates a value of T or F with an n-tuple of  
T–F values. The entire truth table defines a function f such that f: 5T, F6n S 5T, F6. 
The function associated with a tautology maps 5T, F6n S 5T6, and the function 
associated with a contradiction maps 5T, F6n S 5F6.
	
Example 1	
We’ve seen this idea before. From Example 31 in Chapter 5, the function 
f: 5T, F62 S 5T, F6 for the wff A ~ B′ is given by the following truth table.
A
B
B∙
A ~  B′
T
T
F
T
T
F
T
T
F
T
F
F
F
F
T
T
Here f (T, F) = T and f (F, T) = F.	
Suppose we agree, for any propositional wff P with n statement letters, to let 
the symbol P denote not only the wff but also the corresponding function defined 
by the truth table. If P and Q are equivalent wffs, then they have the same truth 
tables and therefore define the same function. Then we can write P = Q rather 
than P 3 Q. This simply confirms that a given function has multiple names, al-
though a given wff defines a unique function.
With this agreement, the short list of tautological equivalences from Section 
1.1 can be written as follows, where ~  and `  denote disjunction and conjunc-
tion, respectively, A′denotes the negation of a statement A, 0 stands for any con-
tradiction, and 1 stands for any tautology:

Section 8.1   Boolean Algebra Structure	
619
1a. A ~ B = B ~ A	
 lb. A ` B = B ` A 	
(commutative properties)
2a. (A ~ B) ~ C =  	
2b. (A ` B) ` C = 	
(associative properties)
	 	 A ~ (B ~ C ) 	
	
A ` (B ` C )	
3a. A ~ (B ` C ) = 	
3b. A ` (B ~ C ) = 	
(distributive properties)
	 	 (A ~ B) ` (A ~ C )	 	
(A ` B) ~ (A ` C )	
4a. A ~ 0 = A	
4b.  A ` 1 = A	
(identity properties)
5a. A ~ A′ = 1	
5b. A ` A′ = 0	
(complement properties)
Switching gears a bit, in Section 4.1 we studied set identities among the sub-
sets of a set S (the elements of `(S )). We found the following list of set identities, 
where c and d denote the union and intersection of sets, respectively, A′ is the 
complement of a set A, and [ is the empty set:
1a. A c B = B c A	
 lb. A d B = B d A	
(commutative properties)
2a. (A c B) c C = 	
2b. (A d B) d C = 	
(associative properties)
	 	 A c (B c C)	
	
A d (B d C )
3a. A c (B d C ) = 	
3b. A d (B c C ) = 	
(distributive properties)
	 	 (A c B) d ( A c C )	 	
(A d B) c (A d C )
4a. A c [ = A	
4b. A d S = A	
(identity properties)
5a. A c A′ = S	
5b. A d A′ = [ 	
(complement properties)
These two lists of properties are similar. The disjunction of statements and the 
union of sets seem to play the same roles in their respective environments. So do 
the conjunction of statements and the intersection of sets. A contradiction seems 
to correspond to the empty set and a tautology to S. What should we make of this 
resemblance?
Models or Abstractions
We seem to have found two different examples—propositional logic and set 
theory—that share some common properties. One of the hallmarks of scientific 
thought is to look for patterns or similarities among various observed phenomena. 
Are these similarities manifestations of some underlying general principle? Can 
the principle itself be identified and studied? Could this research shed light on the 
behavior of various instances of this principle? Sometimes, as seems to be the 
case with propositional logic and set theory, similar mathematical properties or 
behavior can be seen in different contexts. A mathematical structure is a formal 
model that serves to embody or explain this commonality, just as in physics the 
law of gravity is a formal model of why apples fall, the ocean has tides, and the 
planets revolve around the sun.
Mathematical principles are models or abstractions intended to capture prop-
erties that may be common to different instances or manifestations. These princi-
ples are sometimes expressed as mathematical structures—abstract sets of objects, 
together with operations on or relationships among those objects that obey certain 
rules. (This concept may give you a clue about why this book is titled as it is.)
We can liken a mathematical structure to a human skeleton. We can think of 
the skeleton as the basic structure of the human body. People may be thin or fat, 
short or tall, black or white, and so on, but stripped down to skeletons they all look  
pretty much alike. Although the outward appearances differ, the inward structure, 
the shape and arrangement of the bones, is the same. Similarly, mathematical 

620	
Boolean Algebra and Computer Logic 
structures represent the underlying sameness in situations that may appear out-
wardly different.
It appears reasonable to abstract the common properties (tautological equiva-
lences and set identities) for propositional wffs and set theory. Thus we will soon 
define a mathematical structure called a Boolean algebra that incorporates these 
properties. First, however, we note that modeling or abstracting is not an entirely 
new idea to us.
	
1.	 We used predicate logic to model reasoning and formally defined an inter-
pretation as a specific instance of predicate logic (Section 1.3).
	
2.	 We defined the abstract ideas of partial ordering and equivalence relation, 
and considered a number of specific instances that could be modeled as 
posets or sets on which an equivalence relation is defined (Section 5.1).
	
3.	 We noted that graph and tree structures can model a great variety of in-
stances (Sections 6.1 and 6.2).
Boolean algebra is just another model or abstraction for which we already have 
two instances.
Definition and Properties
Let us characterize formally the similarities between propositional logic and set 
theory. In each case we are talking about items from a set: a set of wffs or a set 
of subsets of a set S. In each case we have two binary operations and one unary 
operation on the members of the set: disjunction/conjunction/negation or union/
intersection/complementation. In each case there are two distinguished elements 
of the set: 0/1 or [∙S. Finally, there are the 10 properties that hold in each case. 
Whenever all these features are present, we say that we have a Boolean algebra.
	
Definition	
Boolean Algebra
A Boolean algebra is a set B on which are defined two binary operations + and #  
and one unary operation ′ and in which there are two distinct elements 0 and 1 
such that the following properties hold for all x, y, z [ B:
1a. x + y = y + x	
1b. x # y = y # x 	
(commutative properties)
2a. (x + y) + z = 	
2b. (x # y) # z = 	
(associative properties)
	 	 x + ( y + z)	
	
x # ( y # z)
3a. x + ( y # z) = 	
3b. x # ( y +  z) = 	
(distributive properties)
	 	 (x +  y) # (x + z)	
	
(x # y) + (x # z)
4a.  x + 0 = x	
4b. x # 1 = x	
(identity properties)
5a. x + x′ = 1	
5b. x # x′ = 0	
(complement properties)
What, then, is the Boolean algebra structure? It is a formalization that ab-
stracts, or models, the two cases we have considered (and perhaps others as well). 
There is a subtle philosophical distinction between the formalization itself, the 
idea of the Boolean algebra structure, and any instance of the formalization, such 
as these two cases. Nevertheless, we will often use the term Boolean algebra to 
describe both the idea and its occurrences. This usage should not be confusing. 
We often have a mental idea (“chair,” for example), and whenever we encounter a 

Section 8.1   Boolean Algebra Structure	
621
concrete example of the idea, we also call it by our word for the idea (this object 
is a “chair”).
The formalization helps us focus on the essential features common to all 
examples of Boolean algebras, and we can use these features—these facts from 
the definition of a Boolean algebra—to prove other facts about Boolean algebras. 
Then these new facts, once proved in general, hold in any particular instance of 
a Boolean algebra. To use our analogy, if we ascertain that in a typical human 
skeleton, “the thighbone is connected to the kneebone,” then we don’t need to 
reconfirm the fact in every person we meet.
We denote a Boolean algebra by 3B, + , # , ′, 0, 14.
	
Example 2	
Let B = 50, 16 (the set of integers 0 and 1) and define binary operations +  and #  
on B by x + y = max(x, y), x # y = min(x, y). Then we can illustrate the opera-
tions of +  and #  by the following tables.
+
0
1
#
0
1
0
0
1
0
0
0
1
1
1
1
0
1
A unary operation ′ can be defined by means of a table, as follows, instead of by 
a verbal description.
′
0
1
1
0
Thus 0′ = 1and 1′ = 0. Then 3B, + , #  , ′, 0, 14 is a Boolean algebra. We can 
verify the 10 properties by checking all possible cases. Thus, for property 2b, the 
associativity of # , we show that
(0 # 0) # 0 = 0 # (0 # 0) = 0
(0 # 0) # 1 = 0 # (0 # 1) = 0
(0 # 1) # 0 = 0 # (1 # 0) = 0
(0 # 1) # 1 = 0 # (1 # 1) = 0
(1 # 0) # 0 = 1 # (0 # 0) = 0
(1 # 0) # 1 = 1 # (0 # 1) = 0
(1 # 1) # 0 = 1 # (1 # 0) = 0
(1 # 1) # 1 = 1 # (1 # 1) = 1
For property 4a, we show that
0 + 0 = 0
1 + 0 = 1
■
Practice 1	 Verify property 4b for the Boolean algebra of Example 2.

622	
Boolean Algebra and Computer Logic 
Bear in mind that Example 2 illustrates a particular instance of the Boolean 
algebra structure. Any Boolean algebra must, by the definition, have at least two 
elements, a 0 element and a 1 element. The specific Boolean algebra in Example 
2 has just those two elements, the integers 0 and 1. But if you want to do a proof 
about Boolean algebras in general, you cannot assume that 0 and 1 are the only el-
ements. This means that if you know that x and y are two elements in an arbitrary 
Boolean algebra and that x ∙y, that does not mean that y = x′.
	
Example 3	
Let S = 5a, b, c6. Then `(S ) has eight elements:
[, 5a6, 5b6, 5c6, 5a. b6, 5a, c6, 5b, c6, 5a, b, c6
so using those eight elements together with the operations of union, intersec-
tion, and complementation gives an eight-element Boolean algebra. The empty 
set is the 0 element, and 51, 2, 36 is the 1 element. We could show the tables 
for union and intersection, but let’s just look at complementation. Remember that 
x c x′ = 5a, b, c6.
′
[
5a, b, c6
5a6
5b, c6
5b6
5a, c6
5c6
5a. b6
5a. b6
5c6
5a, c6
5b6
5b, c6
5a6
5a, b, c6
[
Here 5a, c6 and 5c6 are two distinct elements of this Boolean algebra, but 5a, c6 is 
not 5c6′.	
There are many other properties that hold in any Boolean algebra. We can 
prove these additional properties by using the properties in the definition.
	
Example 4	
The idempotent (pronounced eye′-dem-po-tent) property
x + x = x
holds in any Boolean algebra because
	
x + x = (x + x) # 1  
	
(4b)
	
= (x + x) # (x + x′)	
(5a)
	
= x + (x # x′)
	
(3a)
	
= x + 0
	
(5b)
	
= x
	
(4a)

Section 8.1   Boolean Algebra Structure	
623
Although ordinary arithmetic of integers has many of the properties of a Bool-
ean algebra, the idempotent property should convince you that arithmetic is not a 
Boolean algebra. The property x + x = x does not hold for ordinary numbers and 
ordinary addition unless x is zero.
In the proof of Example 4, we used property 5a to replace 1 with x + x′. The 
properties of Boolean algebra are equalities, and either side of an equal sign can 
be replaced with the other side. The Boolean algebra properties (rules) are like the 
equivalence rules in logic; to apply the rule, your situation must match exactly the 
pattern of the rule. For example, it is legal to replace 
( y # z) + x
with
x + ( y # z)
using property 1a, because ( y # z) + x matches the right side of 1a where y is the 
Boolean algebra element y # z, and x + ( y # z) matches the left side of 1a under the 
same interpretation of y. We cannot say
x + ( y # z) = (x # y) + (x # z)
using either property 3a or 3b because we have mixed up the two properties. And, 
strictly speaking, we cannot replace
( y # z) + x
with
( y + x) # (z + x)
and claim that we are using property 3a because in property 3a the addition is to 
the left of the multiplication. We must reason as follows:
	
( y # z) + x = x + ( y # z)	
(1a)
	
= (x + y) # (x + z)
	 (3a)
	
= ( y + x) # (z + x)
	 (1a twice)
However, we will sometimes make implicit use of the associative property and 
write
x + y + z
with no parentheses.
Each property in the definition of a Boolean algebra has its dual as part of 
the definition, where the dual is obtained by interchanging +  and # , and 1 and  
0. For example, x + 0 = x and x # 1 = x are duals of each other. Therefore, every 
time a new property P about Boolean algebras is proved, each step in that proof can 
be replaced by the dual of that step. The result is a proof of the dual of P. Thus, once 
we have proved P, we know that the dual of P also holds. It’s a two-for-one deal!
REMINDER
A Boolean algebra 
property may be applied 
only when your expres-
sion exactly matches the 
pattern of one side of the 
property.

624	
Boolean Algebra and Computer Logic 
More properties of Boolean algebras appear in the exercises at the end of 
this section. The most important of these properties are double negation and De 
Morgan’s laws:
	(x′)′ = x	
(double negation—Exercise 7)
	(x + y)′ = x′ # y′  (x # y)′ = x′ + y′	
(De Morgan’s laws—Exercise 8)
Table 8.1 suggests hints that may help when trying to prove a Boolean algebra 
property of the form
some expression = some other expression
	
Example 5	
The dual of the idempotent property (Example 4), x # x = x, is true in any Boolean 
algebra.	
■
Practice 2	
a.	 What does the idempotent property of Example 4 become in the context of propositional logic?
b.	What does it become in the context of set theory?
■
Practice 3	
a.	 Prove that the universal bound property x + 1 = 1 holds in any Boolean algebra. Give a  
reason for each step.
b.	What is the dual property?
Once a property about Boolean algebra is proved, we can use it to prove new 
properties.
Table 8.1
Hints for Proving Boolean Algebra Equalities
Usually the best approach is to start with the more complicated expression and try to show that it reduces to the 
simpler expression.
Think of adding some form of 0 (like x # x′) or multiplying by some form of 1 (like x + x′).
Remember property 3a, the distributive property of addition over multiplication—it is easy to forget because it 
doesn’t look like arithmetic.
Remember the idempotent property x + x = x and its dual x # x = x.
Remember the universal bound property x + 1 = 1 and its dual x # 0 = 0.
	
EXAMPLE 6	
Prove that x′ # y = x′ # y + x′ # y # z in any Boolean algebra.
Following the suggestion in Table 8.1, we start with the more complicated 
expression, x′ # y + x′ # y # z. There is a “common factor” of x′ # y, so we should 

Section 8.1   Boolean Algebra Structure	
625
For x an element of a Boolean algebra B, the element x′ is called the comple-
ment of x (picking up the terminology from set theory). The complement of x 
satisfies
	
x + x′ = 1	
and	
x # x′ = 0
Indeed, x′ is the unique element with these two properties. To prove it, suppose x1 
is an element of B with these same properties,
	
x + x1 = 1	
and	
x # x1 = 0
Then
	
 x1 = x1 # 1
	
(4b)
	
 = x1 # (x + x′)
	
(x + x′ = 1)
	
 = (x1 # x) + (x1 # x′) 	
(3b)
	
 = (x # x1) + (x′ # x1) 	
(1b)
	
 = 0 + (x′ # x1)
	
(x # x1 =  0)
	
 = (x # x′) + (x′ # x1) 	
(x # x′ = 0)
	
 = (x′ # x) + (x′ # x1) 	
(1b)
	
 = x′ # (x + x1)
	
(3b)
	
 = x′ # 1 
	
(x + x1 = 1)
	
 = x′
	
(4b)
Thus x1 = x′, and x′ is unique. (Uniqueness in the context of propositional logic 
means that the truth table is unique, but there can be many different wffs associ-
ated with any particular truth table.)
The following theorem summarizes our observations.
REMINDER
To prove that something 
is unique, assume that 
there are two of them and 
prove that they must be 
the same.
use a distributive property, although it’s not clear at this point how the z is going 
to disappear.
	
x′ # y + x′ # y # z = x′ # y # 1 + x′ # y # z	
(4b)
	
= x′ # y # (1 + z)
	
(3b)
	
= x′ # y # (z + 1)
	
(1a)
	
= x′ # y # (1)
	
(universal bound—and that’s 	
	
	
	
how z disappears)
	
= x′ # y
	
(4b)
REMINDER
If it walks like a duck and 
it quacks like a duck, it 
must be a duck.
If it has the two properties 
of the complement, then 
by uniqueness it must be 
the complement.
	
Theorem	
On the Uniqueness of Complements
For any x in a Boolean algebra, if an element x1 exists such that
	
x + x1 = 1	
and	
x # x1 = 0
then x1 = x′.

626	
Boolean Algebra and Computer Logic 
There are many ways to define a Boolean algebra. Indeed, in our definition 
of Boolean algebra, we could have omitted the associative properties, since these 
can be derived from the remaining properties of the definition. It is much more 
convenient, however, to include them.
Isomorphic Boolean Algebras
What Is Isomorphism?
Two instances of a structure are isomorphic if there is a bijection (called an iso-
morphism) that maps the elements of one instance onto the elements of the other 
so that important properties are preserved. (Isomorphic graphs were discussed in 
Section 6.1.) If two instances of a structure are isomorphic, each is a mirror image 
of the other, with the elements simply relabeled. The two instances are essentially 
the same. Therefore, we can use the idea of isomorphism to classify instances of a 
structure, lumping together those that are isomorphic.
	
Example 7	
Consider the two partially ordered sets
S1 = 51, 2, 3, 5, 6, 10, 15, 306;  x r y 4 x divides y
S2 = `(51, 2, 36); A s B 4 A # B
The Hasse diagram of each partially ordered set appears in Figure 8. 1. These two 
diagrams certainly appear to be mirror images of each other; just by looking at the 
diagrams, an obvious relabeling of the nodes, as shown in Figure 8.2, suggests itself. 
The important properties of a partially ordered set are which elements are related, 
and the Hasse diagram displays this information. For example, Figure 8.1a shows 
that 1, because of its position at the bottom of the graph, is related to every element 
in S1. Is this property preserved under the relabeling of Figure 8.2? Yes, because 
[ is the image of 1 under that relabeling, and [ is related to every element in S2. 
Similarly, all the other “is related to” properties are preserved under the relabeling.
2
Figure 8.1
■
Practice 4	 Prove that 0′ = 1 and 1′ = 0. (Hint: 1′ = 0 will follow by duality from  0′ = 1. To show 
 0′ = 1, use the theorem on the uniqueness of complements.)

Section 8.1   Boolean Algebra Structure	
627
{1, 2, 3}
Ø
30
2
6
15
10
3
5
1
{2, 3}
{3}
{1, 2}
{1, 3}
{2}
{1}
Figure 8.2
More formally, the relabeling is accomplished by the following bijection f 
from the set of nodes in Figure 8.1a onto the set of nodes in Figure 8.1b.
	
f (1) = [ 	
f (2) = 516 	
f (3) = 526 	
 f (5) = 536
	
f (6) = 51, 26	
f (10) = 51, 36 	
f (15) = 52, 36	
 f (30) = 51, 2, 36
The bijection f is an isomorphism from poset (S1, r) to poset (S2, s) Because this 
isomorphism exists, the posets (S1, r) and (S2, s) are isomorphic. (The function 
f −1 would be an isomorphism from (S2, s) to (S1, r).)
In Example 7 it was relatively easy to find an isomorphism because of the 
visual representation that captured the important properties (which elements 
are related). Suppose that instead of a partially ordered set, we have a struc-
ture (like a Boolean algebra) where binary or unary operations are defined on 
a set. Then the important properties pertain to how these operations act. An 
isomorphism must preserve the effects of performing these operations. Each 
instance of two such structures that are isomorphic must be the mirror image 
of the other in the sense that “operate and then map” must equal “map and then 
operate.”
Figure 8.3 illustrates this general idea for a binary operation. In Figure 8.3a, 
the binary operation is performed on a and b, resulting in c, then c is mapped to d. 
In Figure 8.3b, a and b are mapped to e and f, on which a binary operation is 
­performed, resulting in the same element d as before. Remember,
operate and map = map and operate
Still another view of this little equation appears in the commutative diagram of 
Figure 8.4.

628	
Boolean Algebra and Computer Logic 
Isomorphism as Applied to Boolean Algebra
Now let’s determine specifically what is involved when two instances of a Boolean 
algebra are isomorphic. Suppose we have two Boolean algebras, 3B, +, #, ′, 0, 14 
and 3b, &, *, ″, f, 14. This notation means that, for example, if x is in B, x′ is 
the result of performing on x the unary operation defined in B, and if z is an ele-
ment of b, z″ is the result of performing on z the unary operation defined in b. 
How would we define isomorphism between these two Boolean algebras? First, 
we would need a bijection f from B onto b. Then f must preserve in b the effects of 
the various operations in B. There are three operations, so we use three equations 
to express these preservations. To preserve the operation +, we want to be able to 
operate using + on two elements in B and then map the result to b, or to map the 
two elements to b and operate using the corresponding operation & on the results 
there. (Think “operate and map = map and operate.”) Thus, for x and y in B, we 
require
f (x + y) = f (x) & f ( y)
Practice 5	
a.	 Write the equation requiring  f  to preserve the effect of the binary operation  # .
b.	Write the equation requiring  f  to preserve the effect of the unary operation ′.	
■
b
d
e
f
c
a
Map
Operate
Operate
(a)
b
d
a
Map
Map
(b)
Figure 8.3
Figure 8.4

Section 8.1   Boolean Algebra Structure	
629
We already know (it was one of our original inspirations) that for any set 
S, `(S ) under the operations of union, intersection, and complementation consti-
tutes a Boolean algebra. Example 3 talks about this type of Boolean algebra where 
S = 5a, b, c6. If we pick S = 51, 26, then the elements of `(S ) are [, 516, 526, 
and 51, 26. The operations are given by the following tables.
c
[
51, 26
516
526
[
[
51,26
516
526
51, 26
51,26
51, 26
51, 26
51, 26
516
516
51, 26
516
51, 26
526
526
51, 26
51, 26
526
d
[
51, 26
516
526
′
[
[
[
[
[
[
51, 26
51, 26
[
51, 26
516
526
51, 26
[
516
[
516
516
[
516
526
526
[
526
[
526
526
516
A Boolean algebra can be defined on the set B = 50, 1, a, a′6 where the opera-
tions of + , # , and ′ are defined by the following tables (see Exercise 1).
+
0
1
a
a′
#
0
1
a
a′
′
0
0
1
a
a′
0
0
0
0
0
0
1
1
1
1
1
1
1
0
1
a
a′
1
0
a
a
1
a
1
a
0
a
a
0
a
a′
a′
a′
1
1
a′
a′
0
a′
0
a′
a′
a
Here is the definition of an isomorphism for Boolean algebras.
	
Definition	
Isomorphism for Boolean Algebras
Let 3B, +, # , ′, 0, 14 and 3b, &, *, ″, f, 14 be Boolean algebras. A function B S b 
is an isomorphism from 3B, +, # , ′, 0, 14 to 3b, &, *, ″, f, 14 if
	
1.	 f is a bijection
	
2.	 f (x + y) = f (x) & f ( y)
	
3.	 f (x # y) = f (x) * f ( y)
	
4.	 f (x′) = (  f (x))′ ′
■
Practice 6	 Illustrate properties 2, 3, and 4 in the definition by commutative diagrams.

630	
Boolean Algebra and Computer Logic 
We claim that the mapping f : B S `(S ) given by
	
f (0) = [
	
f (1) = 51, 26
	
f (a) = 516
	
f (a′) = 526
is an isomorphism. Certainly it is a bijection. For x, y [ B, we can verify each of 
the equations
f (x + y) = f (x) c f ( y)
f (x # y) = f (x) d f ( y)
f (x′) = (  f (x))′
by examining all possible cases. Thus, for example,
f  (a # 1) = f (a) = 516 = 516 d 51, 26 = f (a) d f (1)
■
Practice 7	 Verify the following equations.
a.	 f (0 + a) = f (0) c f (a)
b.	 f (a + a′) = f (a) c f (a′)
c.	 f (a # a′) = f  (a) d f (a′)
d.	 f (1′) = (  f (1))′
The remaining cases also hold. Even without testing all cases, it is pretty clear 
here that f is going to work because it merely relabels the entries in the tables for 
B so that they resemble the tables for `(S ). In general, however, it may not be so 
easy to decide whether a given f is an isomorphism between two instances of a 
structure. Even harder to answer is the question of whether two given instances of 
a structure are isomorphic; we must either think up a function that works or show 
that no such function exists. One case where no such function exists is when the 
sets involved are not the same size; we cannot have a four-element Boolean alge-
bra isomorphic to an eight-element Boolean algebra.
We just showed that a particular four-element Boolean algebra is isomor-
phic to `(51, 26). It turns out that any finite Boolean algebra is isomorphic to 
the Boolean algebra of a power set. Although we state this as a theorem, we 
will not prove it.
	
Theorem	
On Finite Boolean Algebras
Let B be any Boolean algebra with n elements. Then n = 2m for some m, and B is 
isomorphic to `(51, 2, … , m6).
This theorem gives us two pieces of information. The number of elements in 
a finite Boolean algebra must be a power of 2. Also we learn that finite Boolean 
algebras that are power sets are—in our lumping together of isomorphic things—

Section 8.1   Boolean Algebra Structure	
631
really the only kinds of finite Boolean algebras. In a sense we have come full 
circle. We defined a Boolean algebra to represent many kinds of situations; now 
we find that (for the finite case) the situations, except for the labels of objects, are 
the same anyway!
S e c t i o n  8 .1 	
Review
Techniques
•	 Decide whether something is a Boolean algebra.
•	 Prove properties about Boolean algebras.
•	 Write the equation meaning that a function f pre-
serves an operation from one instance of a struc-
ture to another, and verify or disprove such an 
equation.
Main Ideas
•	 Mathematical structures serve as models or ab-
stractions of common properties found in diverse 
situations.
•	 If there is an isomorphism (a bijection that pre-
serves properties) from A to B, where A and B are 
instances of a structure, then except for labels, A 
and B are the same.
•	 All finite Boolean algebras are isomorphic to 
­Boolean algebras that are power sets.
W
Exercises 8.1
	 1.	 Let B = 50, 1, a, a′6, and let +  and #  be binary operations on B. The unary operation ′ is defined by 
the table
′
0
1
1
0
a
a′
a′
a
	
	 Suppose you know that 3B, + , # , ′, 0, 14 is a Boolean algebra. Making use of  the properties that must 
hold in any Boolean algebra, fill in the following tables defining the binary operations + and # :
+
0
1
a
a′
#
0
1
a
a′
0
0
1
1
a
a
a′
a′
	 2.	 a.	 What does the universal bound property (Practice 3) become in the context of propositional logic?
	
b.	What does it become in the context of set theory?
	 3.	 Define two binary operations + and # on the set Z of integers by x + y = max(x, y) and x # y = min(x, y).
	
a.	 Show that the commutative, associative, and distributive properties of a Boolean algebra hold for these 
two operations on Z.
	
b.	Show that no matter what element of Z is chosen to be 0, the property x + 0 = x  of a Boolean alge-
bra fails to hold.

632	
Boolean Algebra and Computer Logic 
	 4.	 Let M2(Z) denote the set of 2 × 2 matrices with integer entries, and let + denote matrix addition and #  
denote matrix multiplication. Given  
A = ca
b
c
dd then A′ = c−a
−b
−c
−dd. 
Using c0
0
0
0d  and c1
0
0
1d  as the 0 element and the 1 element, respectively, either prove that 
3M2(Z), + , # , ′, 0, 14 is a Boolean algebra or give a reason why it is not.
	 5.	 Let S be the set 50, 16. Then S 2 is the set of all ordered pairs of 0s and 1s; S 2 = 5(0, 0), (0, 1), (1, 0), (1, 1)6. 
Consider the set B of all functions mapping S 2 to S. For example, one such function, f (x,y), is given by
f (0, 0) = 0
f (0, 1) = 1
f (1, 0) = 1
f (1, 1) = 1
	
a.	 How many elements are in B?
	
b.	For f1 and f2 members of B and (x, y) [ S2, define
	
( f1 + f2)(x, y) = max(  f1(x, y), f2(x, y))
	
( f1 # f2)(x, y) = min(  f1(x, y), f2(x, y))
	
f ′(x, y) = e 1 if f1(x, y) = 0
0 if f1(x, y) = 1
	
	
Suppose
	
f1(0, 0) = 1	
f2(0, 0) = 1
	
f1(0, 1) = 0 	
f2(0, 1) = 1
	
f1(1, 0) = 1 	
f2(1, 0) = 0
	
f1(1, 1) = 0 	
f2(1, 1) = 0
	
	
What are the functions f1 + f2,  f1 # f2, and f 1′?
	
c.	 Prove that 3B, + , # , ′, 0, 14 is a Boolean algebra where the functions 0 and 1 are defined by
	
0(0, 0) = 0 	
1(0, 0) = 1
	
0(0, 1) = 0  	
1(0, 1) = 1
	
0(1, 0) = 0 	
1(1, 0) = 1
	
0(1, 1) = 0 	
1(1, 1) = 1
	 6.	 Let n be a positive integer whose decomposition into prime factors has no repeated prime. Let
B = 5x 0  x is a divisor of n6. For example, if n = 21 = 3 # 7, then B = 51, 3, 7, 216. Let the following 
operations be defined on B:
	
x + y = lcm(x, y)	
x # y = gcd(x, y)	
x′ = nx

Section 8.1   Boolean Algebra Structure	
633
	
	 Then +  and #  are binary operations on B and ′ is a unary operation on B.
	
a.	 For n = 21, find
	
(i)	3 # 7
	
(ii)	7 # 21
	
(iii)	1 + 3
	
(iv)	3 + 21
	
(v)	3′
	
b.	Prove that the commutative, associative, and distributive properties hold for both +  and # .
	
c.	 Find the value of the “0” element and the “1” element, then prove properties 4 and 5 for both +  and # .
	
d.	Consider a value for n whose decomposition has repeated primes. In particular, let n = 12 = 2 # 2 # 3. 
Prove that, using the above definitions for +  and # , it’s not possible to define a complement for 6 in 
the set 51, 2, 3, 4, 6, 126. Therefore a Boolean algebra cannot be constructed with n = 12 using the 
process described.
	 7.	 Prove the following property of Boolean algebras. Give a reason for each step. (Hint: Remember the 
uniqueness of the complement.)
	
(x′)′ = x	
(double negation)
	 8.	 Prove the following property of Boolean algebras. Give a reason for each step. (Hint: Remember the 
uniqueness of the complement.)
(x + y)′ = x′ # y′       (x # y)′ = x′ + y′ 	 (De Morgan’s laws)
	 9.	 Prove the following properties of Boolean algebras. Give a reason for each step.
	
a.	 x + (x # y) = x 	
(absorption properties)
	
	
x # (x + y) = x
	
b.	 x # 3  y + (x # z)4 = (x # y) + (x # z)	
(modular properties)
	
	
x + 3  y # (x + z)4 = (x + y) # (x + z)
	
c.	 (x + y) # (x′ + y) = y
	
	
(x # y) + (x′ # y) = y
	
d.	 (x + ( y # z))′ = x′ # y′ + x′ # z′
	
	
(x # ( y + z))′ = (x′ + y′) # (x′ + z′)
	
e.	 (x + y) # (x + 1) = x + (x # y) + y
	
	
(x # y) + (x # 0) = x # (x + y) # y
	 10.	Prove the following properties of Boolean algebras. Give a reason for each step.
	
a.	 (x + y) + ( y # x′) = x + y
	
b.	 ( y + x) # (z + y) + x # z # (z + z′) = y + x # z
	
c.	 ( y′ # x) + x + ( y + x) # y′ = x + ( y′ # x)
	
d.	 (x + y′) # z = 3(x′ + z′) # ( y + z′)4′
	
e.	 (x # y) + (x′ # z) + (x′ # y # z′) = y + (x′ # z)

634	
Boolean Algebra and Computer Logic 
	 11.	Prove the following properties of Boolean algebras. Give a reason for each step.
	
a.	 x + y′ = x + (x′ # y + x # y)′
	
b.	 3(x # y) # z4 + ( y # z) = y # z
	
c.	 x # y + y # x′ = x # y + y
	
d.	 (x + y)′ # z + x′ # z # y = x′ # z
	
e.	 (x # y′) + ( y # z′) + (x′ # z) = (x′ # y) + ( y′ # z) + (x # z′)
	 12.	Prove the following properties of Boolean algebras. Give a reason for each step.
	
a.	 (x + y # x)′ = x′
	
b.	 x # (z + y) + (x′ + y)′ = x
	
c.	 (x # y)′ +  x′ # z + y′ # z = x′ + y′
	
d.	 x # y + x′ = y + x′ # y′
	
e.	 x # y + y # z # x′ = y # z + y # x # z′
	 13.	Prove that in any Boolean algebra, x # y′ + x′ # y = y if and only if x = 0.
	 14.	Prove that in any Boolean algebra, x # y′ = 0 if and only if x # y = x.
	 15.	A new binary operation ! in a Boolean algebra (exclusive OR) is defined by
x ! y = x # y′ + y # x′
	
	 Prove that
	
a.	 x ! y = y ! x
	
b.	 x ! x = 0
	
c.	 0 ! x = x
	
d.	 1 ! x = x′
	 16.	Prove that for any Boolean algebra:
	
a.	 If x + y = 0, then x = 0 and y = 0.
	
b.	 x = y if and only if x # y′ + y # x′ = 0.
	 17.	Prove that the 0 element in any Boolean algebra is unique; prove that the 1 element in any Boolean algebra 
is unique.
	 18.	a.	 Find an example of a Boolean algebra with elements x, y, and z for which x + y = x + z but y ∙z. 
(Here is further evidence that ordinary arithmetic of integers is not a Boolean algebra.)
	
b.	Prove that in any Boolean algebra, if x + y = x + z and x′ + y = x′ + z, then y = z.
	 19.	Let (S, d) and (S′, d′) be two partially ordered sets. (S, d)  is isomorphic to (S′, d′) if there is a bijection 
f: S S S′ such that for x, y in S, x a y S f (x) a
   
 ′f (y) and f (x) a
 
 
 ′f (y) S x a y.
	
a.	 Show that there are exactly two nonisomorphic, partially ordered sets with two elements (use  
diagrams).
	
b.	Show that there are exactly five nonisomorphic, partially ordered sets with three elements.
	
c.	 How many nonisomorphic, partially ordered sets with four elements are there?
	 20.	Find an example of two partially ordered sets (S, d) and (S′, d′) and a bijection f: S S S′ where, for x, y 
in S, x a y S f (x) a
 
   ′f ( y) but f (x) a
 
 ′f ( y) S
∙
 x a y.

Section 8.1   Boolean Algebra Structure	
635
	 21.	Let S = 50, 16 and let a binary operation # be defined on S by
#
0
1
0
1
0
1
0
1
	
	 Let T = 55, 76, and let a binary operation + be defined on T by
+
5
7
5
7
5
7
5
7
	
	 Consider 3S, #4 and [T, +] as mathematical structures.
	
a.	 If a function f is an isomorphism from 3S, #4 to [T, +], what two properties must f satisfy?
	
b.	Define a function f: S S T and prove that it is an isomorphism from 3S, #4 to [T, +].
	 22.	Consider the four-element Boolean algebra defined in Exercise 6 with n = 21. Find an isomorphism 
from this Boolean algebra to the four-element Boolean algebra with set `(51, 26) that was defined in this 
­section.
	 23.	Let R denote the real numbers and R+ the positive real numbers. Addition is a binary operation on R, and 
multiplication is a binary operation on R+. Consider [R, +] and3R+, #4 as mathematical structures.
	
a.	 Prove that the function f defined by f (x) = 2x is a bijection from R to R+.
	
b.	Write the equation that an isomorphism from [R, +] to 3R+, #4 must satisfy.
	
c.	 Prove that the function f of part (a) is an isomorphism from 3R, + 4 to 3R+, #4.
	
d.	What is f −1 for this function?
	
e.	 Prove that f −1 is an isomorphism from 3R+, #4 to [R, +].
	 24.	An isomorphism from the Boolean algebra with set B = 50, 1, a, a′6 to the Boolean algebra with set 
`(51, 26) was defined in this section. Because the two Boolean algebras are essentially the same, an opera-
tion in one can be simulated by mapping to the other, operating there, and mapping back.
	
a.	 Use the Boolean algebra on `(51, 26) to simulate the computation 1 # a′ in the Boolean algebra on B.
	
b.	Use the Boolean algebra on `(51, 26) to simulate the computation (a)′ in the Boolean algebra on B.
	
c.	 Use the Boolean algebra on B to simulate the computation 516 c 526 in the Boolean algebra on 
`(51, 26).
	 25.	Consider the set B of all functions mapping 50, 162 to 50, 16. We can define operations of +, #, and ′ on B by
	
( f1 + f2)(x, y) = max(  f1(x, y), f2(x, y))
	
( f1 # f2)(x, y) = min(  f1(x, y), f2(x, y))
	
f1′(x, y) = e 1 if  f1(x, y) = 0
0 if  f1(x, y) = 1
	
	 Then 3B, +, # , ′, 0, 14 is a Boolean algebra of 16 elements (see Exercise 5). The following table assigns 
names to these 16 functions.

636	
Boolean Algebra and Computer Logic 
(x, y)
0
1
f1
f2
f3
f4
f5
f6
f7
f8
f9
f10
f11
f12
f13
f14
(0, 0)
0
1
1
1
1
1
1
1
0
0
0
1
0
0
0
0
(0, 1)
0
1
0
1
1
0
1
0
1
1
1
0
0
1
0
0
(1, 0)
0
1
1
0
1
0
0
1
1
1
0
0
1
0
1
0
(1, 1)
0
1
0
0
0
0
1
1
1
0
1
1
1
0
0
1
	
	 According to the theorem on finite Boolean algebras, this Boolean algebra is isomorphic to 
3`(51, 2, 3, 46), c, d, ′, [, 51, 2, 3, 464. Complete the following definition of an isomorphism from B to 
`(51, 2, 3, 46).
	
0  S [
	
1  S 51, 2, 3, 46
	
f4  S 516
	
f12 S 526
	
f13 S 536
	
f14 S 546
	 26.	Let P, Q, and R be three statements in propositional logic with statement letters A and B. P, Q, and R 
define the following three functions from 5T, F62 to  5T, F6. Also shown are the contradiction 0 and the 
tautology 1.
A
B
P
Q
R
0
1
T
T
T
F
F
F
T
T
F
F
T
F
F
T
F
T
F
F
T
F
T
F
F
T
F
F
F
T
	
a.	 Let B = 5P, P′, Q, Q′, R, R′, 0, 16. Then 3B, ~, ` , ′, 0, 14 is a Boolean algebra. Write the 8 × 8 
­tables for the ~  and `  operations and the 8 × 1 table for the ′ operation.
	
b.	 3`(51, 2, 36, c, d, ′, [, 51, 2, 364 is a Boolean algebra. Write the 8 × 8 tables for the c  and d op-
erations and the 8 × 1 table for the ′ operation.
	
c.	 Find an isomorphism from the Boolean algebra of part (a) to the Boolean algebra of part (b).
	 27.	Suppose that 3B, +, #, ′, 0, 14 and 3b, &, *, ″, f, 14 are isomorphic Boolean algebras and that f is an iso-
morphism from B to b.
	
a.	 Prove that f(0) = f.
	
b.	Prove that f(1) = 1.
	 28.	According to the theorem on finite Boolean algebras, which we did not prove, any finite Boolean algebra 
must have 2m elements for some m. Prove the weaker statement that no Boolean algebra can have an odd 
number of elements. (Note that in the definition of a Boolean algebra, 0 and 1 are distinct elements of B, 
so B has at least two elements. Arrange the remaining elements of B so that each element is paired with its 
complement.)

Section 8.1   Boolean Algebra Structure	
637
	 29.	A Boolean algebra may also be defined as a partially ordered set with certain additional properties. Let 
(B, d) be a partially ordered set. For any x, y [ B, we define the least upper bound of x and y as an 
­element z such that x d z, y d z, and if there is any element z* with x d z* and y d z*, then z d z*. 
The greatest lower bound of x and y is an element w such that w d x, w d y, and if there is any ­element 
w  
 
     * with w* d  x and w* d  y, then w* d w. A lattice is a partially ordered set in which every two 
­elements x and y have a least upper bound, denoted by x + y, and a greatest lower bound, denoted by x # y.
	
a.	 Prove that in any lattice
	
(i)	 x # y = x if and only if x d y
	
(ii)	 x + y = y if and only if x d y
	
b.	Prove that in any lattice
	
(i)	x + y = y + x
	
(ii)	x # y = y # x
	
(iii)	(x + y) + z = x + ( y + z)
	
(iv)	(x # y) # z = x # ( y # z)
	
c.	 A lattice L is complemented if there exists a least element 0 and a greatest element 1, and for every 
x [ L there exists x′ [ L such that x + x′ = 1 and x # x′ = 0. Prove that in a complemented lattice L,
	
x + 0 = x	
and	
x # 1 = x
	
	
for all x [ L.
	
d.	A lattice L is distributive if
x + ( y # z) = (x + y) # (x + z)
	
	
and
x # ( y + z) = (x # y) + (x # z)
	
	
for every x, y, z [ L. By parts (b) and (c), a complemented, distributive lattice is a Boolean algebra. 
Which of the following Hasse diagrams of partially ordered sets do not represent Boolean algebras? 
Why? (Hint: In a Boolean algebra, the complement of an element is unique.)
2
(a)
(b)
(c)
(d)
1
3
4
6
7
5
1
3
4
2
1
4
3
5
2

638	
Boolean Algebra and Computer Logic 
	 30.	a.	 Let n be a positive integer and consider B to be the set of all positive integer divisors of n. Prove that 
(B, d) is a partially ordered set where x d y means x 0  y.
In the terminology of Exercise 29, the least upper bound of x and y is the least common multiple of x and 
y, and the greatest lower bound is the greatest common divisor. (B, d) is a distributive lattice.
	
b.	Prove that for n = 6, (B, d) is a Boolean algebra. (Hint: 1 is the least element and 6 is the greatest 
­element).
	
c.	 For n = 8, (B, d) is not a Boolean algebra.
	
(i)	Show that this is true by using the definition of a Boolean algebra.
	
	
(ii)	Show that this is true by using Exercise 6.
	
S e c t i o n  8 . 2 	 Logic Networks
Combinational Networks
Basic Logic Elements
In 1938 the American mathematician Claude Shannon perceived the parallel be-
tween propositional logic and circuit logic and realized that Boolean algebra could 
play a part in systematizing this new realm of electronics.
Let us imagine that the electrical voltages carried along wires fall into one 
of two ranges, high or low, which we represent by 1 and 0, respectively. Voltage 
fluctuations within these ranges are ignored, so we are forcing a discrete, indeed 
binary, mask on an analog phenomenon. We also suppose that switches can be 
wired so that a signal of 1 causes the switch to be closed and a signal of 0 causes 
the switch to be open (Figure 8.5). Now we combine two such switches, controlled 
by lines x1 and x2, in parallel. If either or both lines carry a 1 value, one or both 
of the switches will be closed, and the output line will have a value of 1. However, 
values of x1 = 0 and x2 = 0 will cause both switches to be open and thus break the 
circuit, so that the voltage level on the output line will be 0. Figure 8.6 illustrates 
the various cases.
x = 1
x = 0
Closed switch
Open switch
Figure 8.5
x2 = 1
x1 = 1
1
x2 = 1
x1 = 0
1
x1 = 0
x2 = 0
x2 = 0
x1 = 1
1
0
Figure 8.6

Section 8.2   Logic Networks	
639
Table 8.2 summarizes the behavior of the circuit. Substituting T for 1 and  
F for 0 in the table results in the truth table for the logical connective of disjunc-
tion. Disjunction is an example of the Boolean algebra operation + in the realm of 
propositional logic. Thus we may think of the circuit more abstractly as an elec-
tronic device that performs the Boolean operation +. Similarly, conjunction and 
negation are examples of the Boolean algebra operations # and ′, respectively, in 
the realm of propositional logic. Other devices perform these Boolean operations. 
For example, switches connected in series would serve to implement the # operation; 
both switches must be closed (x1 = 1 and x2 = 1) in order to have an output of 1. 
However, we’ll ignore the details of implementing the devices; suffice it to say that 
technology has progressed from mechanical switches through vacuum tubes and 
then transistors to integrated circuits, and now even bacteria and DNA. We will 
simply represent these devices by their standard symbols.
The OR gate, Figure 8.7a, behaves like the Boolean operation +. The AND 
gate, Figure 8.7b, represents the Boolean operation #. Figure 8.7c shows an  
inverter, corresponding to the unary Boolean operation ′. Because of the associativ-
ity property for + and # , the OR and AND gates can have more than two inputs.
x1
x1
x2
x1 + x2
1
1
0
0
1
0
1
0
1
(a)  OR gate
(b)  AND gate
(c)  Inverter
1
1
0
x1 + x2
x2
x1
x1 + x2
1
1
0
0
1
0
1
0
1
0
0
0
x2
x1
1
0
0
1
x'1
x1
x2
x1 . x2
x1
x'1
Figure 8.7
Table 8.2
x1
x2
Output
1
1
1
1
0
1
0
1
1
0
0
0
(The definition of a Boolean expression is another example of a recursive 
definition; rule 1 is the basis step and rule 2 the inductive step.) When there 
is no chance of confusion, we can omit the parentheses introduced by rule 2.  
In addition, we define # to take precedence over + and ′ to take precedence  
over + or #, so x1 + x2 # x3 stands for x1 + (x2 # x3) and x1 + x2′ stands for 
x1 + (x2′); this convention also allows us to remove some parentheses. Finally, we 
will generally omit the symbol # and use juxtaposition, so x1 # x2 is written x1x2.
	
Definition	
Boolean Expression
A Boolean expression in n variables, x1, x2, … , xn, is any finite string of 
­symbols formed by applying the following rules:
	
1.	 x1, x2, … , xn, are Boolean expressions.
	
2.	 If P and Q are Boolean expressions, so are (P + Q), (P # Q), and (P′).
Boolean Expressions

640	
Boolean Algebra and Computer Logic 
	
Example 8	
 x3, (x1 + x2)′x3, (x1x3 + x4′) x2, and (x1′ x2)′x1 are all Boolean expressions.	
Truth Functions
	
Definition	
Truth Function
A truth function is a function f such that f: 50, 16n S 50, 16 for some integer 
n ≥1.
The notation 50, 16n denotes the set of all n-tuples of 0s and 1s. A truth 
­function thus associates a value of 0 or 1 with each such n-tuple.
	
Example 9	
The truth table for the Boolean operation + describes a truth ­function 
f with n = 2. The domain of f is 
5(1, 1), (1, 0), (0, 1), (0, 0)6, and 
f (1, 1) = 1, f (1, 0) = 1, f (0, 1) = 1, and f (0, 0) = 0. Similarly, the Boolean  
operation # describes a different truth function with n = 2, and the Boolean  
operation ′ describes a truth function for n = 1.	
■
Practice 8	
a.	 If we are writing a truth function f: 50, 16n S 50, 16 in tabular form (like a truth table),  
how many rows will the table have?
b.	How many different truth functions are there that take 50, 162 S 50, 16?
c.	 How many different truth functions are there that take 50, 16n S 50, 16?
Any Boolean expression defines a unique truth function, just as do the sim-
ple Boolean expressions x1 + x2, x1x2, and x1′.
	
Example 10	
The Boolean expression x1x2′ + x3 defines the truth function given in Table 8.3. 
(This is just like doing the truth tables of Section 1.1.)
Table 8.3
x1
x2
x3
x1x2′ + x3
1
1
1
1
1
1
0
0
1
0
1
1
1
0
0
1
0
1
1
1
0
1
0
0
0
0
1
1
0
0
0
0

Section 8.2   Logic Networks	
641
Networks and Expressions
It’s time to see how these ideas of logic gates, Boolean expressions, and truth 
functions are related. By combining AND gates, OR gates, and inverters, we can 
construct a logic network representing a given Boolean expression that produces 
the same truth function as that expression.
	
Example 11	
The logic network for the Boolean expression x1x2′ + x3 is shown in Figure 8.8.
Figure 8.8
■
Practice 9	 Design the logic network for the following Boolean expressions.
a.	 x1 + x2′
b.	 x1(x2 + x3)′
Conversely, if we have a logic network, we can write a Boolean expression 
with the same truth function.
	
Example 12	
A Boolean expression for the logic network in Figure 8.9 is
(x1x2 + x3)′ + x3
Figure 8.9
■
Practice 10
a.	 Write a Boolean expression for the logic network in Figure 8.10.
Figure 8.10
b.	Write the truth function (in table form) for the network (and expression) of part (a).

642	
Boolean Algebra and Computer Logic 
Logic networks constructed of AND gates, OR gates, and inverters are also 
called combinational networks. They have several features that we should note. 
First, input or output lines are not tied together except by passing through gates. 
Lines can be split, however, to serve as input to more than one device. There are 
no loops where the output of an element is part of the input to that same element. 
Finally, the output of a network is an instantaneous function of the input; there are 
no delay elements that capture and remember input signals. Notice also that the 
picture of any network is, in effect, a directed graph.
Canonical Form
Here is the situation so far (arrows indicate a procedure that we can carry out):
truth function d Boolean expression 4 logic network
We can write a unique truth function from either a network or an expression. 
Given an expression, we can find a network with the same truth function, and 
conversely. The last part of the puzzle concerns how to get from an arbitrary truth 
function to an expression (and hence a network) having that truth function. An 
algorithm to solve this problem is explained in the next example.
	
Example 13	
Suppose we want to find a Boolean expression for the truth function f of Table 8.4. 
There are four rows in the table (rows 1, 3, 4, and 7) for which f is 1. The basic 
form of our expression will be a sum of four terms
( ) + ( ) + ( ) + ( )
such that the first term has the value 1 for the input values of row 1 and for no oth-
ers, the second term has the value 1 for the input values of row 3 and for no others, 
and so on. Thus, the entire expression has the value 1 for these inputs and for no 
others—precisely what we want. (Other inputs cause each term in the sum, and 
hence the sum itself, to be 0.)
Table 8.4
x1
x2
x3
f(x1, x2, x3)
1
1
1
1
1
1
0
0
1
0
1
1
1
0
0
1
0
1
1
0
0
1
0
0
0
0
1
1
0
0
0
0

Section 8.2   Logic Networks	
643
Each term in the sum will be a product of the form abg where a is ei-
ther x1 or x1′, b is either x2 or x2′, and g is either x3 or x3′. If the input value of 
xi, i = 1, 2, 3, in the row we are working on is 1, then xi itself is used; if the input 
value of xi in the row we are working on is 0, then xi ′ is used. These values will 
force abg to be 1 for that row and 0 for all other rows. Thus, we have
row 1: x1x2x3 
row 3: x1x2′x3  
row 4: x1x2′x3′
row 7: x1′x2′x3
The final expression is
(x1x2x3) + (x1x2′x3) + (x1x2′x3′) + (x1′x2′x3)
The procedure described in Example 13 always leads to an expression that is 
a sum of products, called the canonical sum-of-products form, or the disjunc-
tive normal form, for the given truth function. The only case not covered by 
this procedure is when the function has a value of 0 everywhere. Then we use an 
expression such as
x1x1′
which is also a sum (one term) of products. Therefore, we can find a sum-of-
products expression to represent any truth function. A pseudocode description 
of the algorithm is given in the accompanying box. For this algorithm, the input 
is a truth table representing a truth function on n variables x1, x2, … , xn; the 
output is a Boolean expression in disjunctive normal form with the same truth 
function.
	
Algorithm	
Sum-Of-Products
Sum-Of-Products (truth table; integer n)
//the truth table represents a truth function with n arguments;
//result is the canonical sum-of-products expression for this truth function
Local variables:
sum	
//sum-of-products expression
product	
//single term in sum, a product
i	
//index for the columns of the table
row	
//index for the rows of the table
sum = empty

644	
Boolean Algebra and Computer Logic 
for row = 1 to 2n do
if truth value for row is 1 then
initialize product; 
for i = 1 to n do 
if xi = 1 then
put xi in product
else
put xi′ in product
end if
end for
sum =  sum + product 
end if
end for
if sum is empty then
sum = x1x1′
end if
write (“The canonical sum-of-products expression for this truth function is”, sum)
end Sum-Of-Products
Because any expression has a corresponding network, any truth function has 
a logic network representation. Furthermore, the AND gate, OR gate, and inverter 
are the only devices needed to construct the network. Thus, we can build a net-
work for any truth function with only three kinds of parts—and lots of wire! Later 
we will see that it is necessary to stock only one kind of part.
Given a truth function, the canonical sum-of-products form just described 
is one expression that has this truth function, but it is not the only possible one. 
A method for obtaining a different expression for any truth function is given in 
Exercise 25 at the end of this section.
	
Example 14	
The network for the canonical sum-of-products form of Example 13 is shown in 
Figure 8.11. We have drawn the inputs to each AND gate separately because it 
looks neater, but actually a single x1, x2, or x3 input can be split as needed.
Figure 8.11

Section 8.2   Logic Networks	
645
Minimization
As already noted, a given truth function may be represented by more than one 
Boolean expression and hence by more than one logic network composed of AND 
gates, OR gates, and inverters.
■
Practice 11	
a.	 Find the canonical sum-of-products form for the truth function  
of Table 8.5.
b.	Draw the network for the expression of part (a).
Table 8.5
x1
x2
x3
f(x1, x2, x3)
1
1
1
1
1
1
0
0
1
0
1
1
1
0
0
1
0
1
1
0
0
1
0
0
0
0
1
1
0
0
0
1
	
Example 15	
The Boolean expression
x1x3 + x2′
has the truth function of Table 8.5. The logic network corresponding to this expres-
sion is given by Figure 8.12. Compare this with your network in Practice 11(b)!
Figure 8.12
	
Definition	
Equivalent Boolean Expressions
Two Boolean expressions are equivalent if they have the same truth functions.
We know that
x1x2x3 +  x1x2′x3 + x1x2′x3′ + x1′x2′x3 + x1′x2′x3′

646	
Boolean Algebra and Computer Logic 
and
x1x3 + x2′
for example, are equivalent Boolean expressions.
Clearly, equivalence of Boolean expressions is an equivalence relation on the 
set of all Boolean expressions in n variables. Each equivalence class is associated 
with a distinct truth function. Given a truth function, algorithm Sum-Of-Products 
produces one particular member of the class associated with that function, name-
ly, the canonical sum-of-products form. However, if we are trying to design the 
logic network for that function, we want to find a member of the class that is as 
simple as possible. We would rather build the network of Figure 8.12 than the one 
for Practice 11(b).
How can we reduce a Boolean expression to an equivalent, simpler expres-
sion? We can use the properties of a Boolean algebra because they express the 
equivalence of Boolean expressions. If P is a Boolean expression containing the 
subexpression (x1 + x2)(x1 + x3), for example, and Q is the expression obtained 
from P by replacing (x1 + x2)(x1 + x3) with the equivalent expression x1 + (x2  x3), 
then P and Q are equivalent and Q is simpler than P.
	
ExampLe 16	
Using the properties of Boolean algebra, we can reduce
x1x2x3 + x1x2′x3 + x1x2′x3′ + x1′x2′x3 + x1′x2′x3′
to
x1x3 + x2′
as follows:
x1x2x3 + x1x2′x3 + x1x2′x3′ + x1′x2′x3 + x1′x2′x3′
	
= x1x2x3 + x1x2′x3 + x1x2′x3 + x1x2′x3′ + x1′x2′x3 + x1′x2′x3′
	
(idempotent)
	
= x1x3x2 + x1x3x2′ + x1x2′x3 + x1x2′x3′ + x1′x2′x3 + x1′x2′x3′
	
(1b)
	
= x1x3(x2 + x2′) + x1x2′(x3 + x3′) + x1′x2′(x3 + x3′)	
(3b)
	
= x1x3 # 1 + x1x2′ # 1 + x1′x2′ # 1	
(5a)
	
= x1x3 + x1x2′ + x1′x2′	
(4b)
	
= x1x3 + x2′x1 + x2′x1′	
(1b)
	
= x1x3 + x2′(x1 + x1′)	
(3b)
	
= x1x3 + x2′ # 1	
(5a)
	
= x1x3 + x2′	
(4b)
Unfortunately, one must be fairly clever to apply Boolean algebra properties to 
simplify an expression. In Section 8.3 we will discuss more systematic approaches 
to this minimization problem that require less ingenuity. For now, we should say 

Section 8.2   Logic Networks	
647
a bit more about why we want to minimize. When logic networks were built from 
separate gates and inverters, the cost of these elements was a considerable ­factor 
in the design, and it was desirable to have as few elements as possible. Now, how-
ever, most networks are built using integrated circuit technology, a development 
that began in the early 1960s. An integrated circuit is itself a logic network rep-
resenting a certain truth function or functions, just as if some gates and invert-
ers had been combined in the appropriate arrangement inside a package. These 
integrated circuits are then combined as needed to produce the desired result. 
Because the integrated circuits are extremely small and relatively inexpensive, it 
might seem pointless to bother minimizing a network. However, minimization is 
still important because the reliability of the final network is inversely related to the 
number of connections between the integrated circuit packages.
Moreover, the designers of integrated circuits are highly interested in the 
minimization problem. Integrated circuits are embedded into a substrate of ­silicon 
or other semiconductor material. The resulting chips may be tiny, yet they can 
contain the equivalent of 3 billion transistors for implementing truth functions. 
The distance between two gates may be as small as 45 nanometers (about 1/1000 
of the width of a human hair). Minimizing the number of components and the 
amount of wiring required to realize a desired truth function makes it possible to 
embed more functions in a single chip.
Programmable Logic Devices
Instead of designing a custom chip to implement particular truth functions, a PLD 
(programmable logic device) can be used. A PLD is a chip that is already im-
planted with an array of AND gates and an array of OR gates, together with a rect-
angular grid of wiring channels and some inverters. Once Boolean expressions in 
sum-of-products form have been determined for the truth functions, the required 
components in the PLD are activated. Although this chip is not very efficient and is 
practical only for smaller-scale circuit logic, on the order of hundreds of gates, the 
PLD can be mass-produced, and only a small amount of time (i.e., money) is then 
required to “program” it for the desired functions. A FPGA (field-programmable 
gate array) is a big brother to the PLD. The term “field-programmable” suggests 
that, like a PLD, the user can configure the chip for a specific purpose. An FPGA 
basically connects a number of PLDs in a reconfigurable way, and it can support 
thousands of gates. Often the FPGA also contains hardwired components such as 
multipliers or even processors and memory, thus producing a small reconfigurable 
computer that is “programmed” in hardware rather than software.
	
Example 17	
Figure 8.13a shows a PLD for the three inputs x1, x2, and x3. There are four output 
lines, so four functions can be programmed in this PLD. When the PLD is pro-
grammed, the horizontal line going into an AND gate will pick up certain inputs, 
and the AND gate will form the product of these inputs. The vertical line going 
into an OR gate will, when programmed, allow the OR gate to form the sum of 
certain inputs. Figure 8.13b shows the same PLD programmed to produce the truth 
functions f1 from Example 13 (x1x2x3 +  x1x2′x3 + x1x2′x3′ +  x1′x2′x3) and f2 from 
Practice 11 (x1x2x3 + x1x2′x3 +  x1x2′x3′ +  x1′x2′x3 + x1′x2′x3′). The dots represent ac-
tivation points.

648	
Boolean Algebra and Computer Logic 
Figure 8.13
A Useful Network
We can design a network that adds binary numbers, a basic operation that a com-
puter must be able to perform. The rules for adding two one-bit numbers are sum-
marized in Table 8.6.

Section 8.2   Logic Networks	
649
Table 8.6
x1
x2
Sum
1
1
10
1
0
1
0
1
1
0
0
0
Table 8.7
x1
x2
s
1
1
0
1
0
1
0
1
1
0
0
0
Table 8.8
x1
x2
c
1
1
1
1
0
0
0
1
0
0
0
0
We can express the sum as a single sum bit s (the right-hand bit of the actual sum) to-
gether with a single carry bit c; doing this gives us the two truth functions of Tables 8.7 
and 8.8, respectively. The canonical sum-of-products form for each truth function is
 s = x1′x2 + x1x2′
c = x1x2
An equivalent Boolean expression for s is
s = (x1 + x2)(x1x2)′
Figure 8.14a shows a network with inputs x1 and x2 and outputs s and c. This de-
vice, for reasons that will be clear shortly, is called a half-adder.
x1
x2
s
c
s
(a)  Half-adder
(b)  Full-adder
Half-adder
Half-adder
x1
ci – 1
ci
x2
x1
x2
x1
x2
Figure 8.14

650	
Boolean Algebra and Computer Logic 
To add two n-bit binary numbers, we add column by column from the low-
order to the high-order bits. The ith column (except for the very first column) has 
as input its two bits x1 and x2 plus the carry bit from the addition of column i −1 
to its right. Thus we need a device incorporating the previous carry bit as input. 
Such a device can be accomplished by adding x1 and x2 with a half-adder and then 
adding the previous carry bit ci−1 (using another half-adder) to the result. Again, a 
sum bit s and final carry bit ci are output, where ci is 1 if either half-adder produces 
a 1 as its carry bit. The full-adder is shown in Figure 8.14b. The full-adder is thus 
composed of two half-adders and an additional OR gate.
To add two n-bit binary numbers, the two low-order bits, where there is no input 
carry bit, can be added with a half-adder. The remaining bits are added with full-
adders. All are chained together. Figure 8.15 shows the modules required to add two 
3-bit binary numbers z1 y1x1 and z2  y2x2, resulting in the answer a3a2a1a0, where the 
leading bit a3 is the final carry bit and could be 0 (leading 0s are usually not written) 
or 1.
Full-adder
s
z2
a3 a2 a1 a0
y2 x2
z1 y1 x1
c
c
c
s
s
Full-adder
Half-adder
Figure 8.15
The adder circuit shown in Figure 8.15 is called a “ripple-carry adder” because 
the carry bits have to propagate right to left through each adder in turn. Although 
we have assumed that gates output instantaneously, there is in fact a small time 
delay in an n-bit adder due to this ripple effect that can be appreciable for large n. 
Variations on the basic circuitry that speed up the addition process depend on 
anticipating the higher-order carry bits.
■
Practice 12	 Trace the operation of the circuit in Figure 8.15 as it adds 101 and 111.
Other Logic Elements
The basic elements used in integrated circuits are not really AND and OR gates 
and inverters, but NAND and NOR gates. Figure 8.16 shows the standard sym-
bol for the NAND gate (the NOT AND gate) and its truth function. The NAND 
gate alone is sufficient to realize any truth function because networks using only 
NAND gates can do the job of inverters, OR gates, and AND gates. Figure 8.17 
shows these networks.

Section 8.2   Logic Networks	
651
x1
(x1 + x2)'
1
1
0
0
1
0
1
0
0
1
1
1
x2
x1
x2
Figure 8.16
1Exercises 51 and 52 of Section 1.1 give truth tables for binary connectives that agree with the NAND and 
NOR truth functions. There you were asked to prove that either of these two connectives is sufficient to write 
any propositional wff; that is, you can write ~, `, and ′ in terms of one of these connectives.
(x'1x'2)' =   x1   +  x2
(x1x2)'
(x1x2)'
((x1x2)'(x1x2)')'   =   x1x2   +   x1x2   =   x1x2
(a)
(b)
(c)
(x1 x1)'  =  x'1 
x1
x1
x1
x2
x2
x'2
x'1
Figure 8.17
The NOR gate (the NOT OR gate) and its truth function appear in Figure 8.18. An 
exercise at the end of this section asks you to construct networks using only NOR 
gates for inverters, OR gates, and AND gates.1

652	
Boolean Algebra and Computer Logic 
■
Practice 13	
a.	 Rewrite the network of Figure 8.12 with NAND elements by directly replacing the AND gate,  
OR gate, and inverter, as in Figure 8.17.
b.	Rewrite the Boolean expression x1x3 + x2′  for Figure 8.12 using De Morgan’s laws, and then 
­construct a network using only two NAND elements.
Constructing Truth Functions
We know how to write a Boolean expression and construct a network from a 
given truth function. Often the truth function itself must first be deduced from the 
­description of the actual problem.
	
Example 18	
At a mail-order cosmetics firm, an automatic control device is used to supervise 
the packaging of orders. The firm sells lipstick, perfume, makeup, and nail polish. 
As a bonus item, shampoo is included with any order that includes perfume or any 
order that includes lipstick, makeup, and nail polish. How can we design the logic 
network that controls whether shampoo is packaged with an order?
The inputs to the network will represent the four items that can be ordered. 
We label the items
 x1 = lipstick
x2 = perfume
x3 = makeup
x4 = nail polish
The value of xi will be 1 when that item is included in the order and 0 otherwise. 
The output from the network should be 1 if shampoo is to be packaged with the 
order and 0 otherwise. The truth table for the circuit appears in Table 8.9. The ca-
nonical sum-of-products form for this truth function is lengthy, but the expression 
x1
x1
x2
1
1
0
0
(x1  +  x2)'
0
0
0
1
1
0
1
0
x2
Figure 8.18
Although we can construct a NAND network for a truth function by replacing 
AND gates, OR gates, and inverters in the canonical form or a minimized form 
with the appropriate NAND networks, we can often obtain a simpler network by 
using the properties of NAND elements directly.

Section 8.2   Logic Networks	
653
x1x3x4 + x2  also represents the function. Figure 8.19 shows the logic network for 
this expression.
Table 8.9
x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
1
1
1
1
0
1
1
1
0
1
1
1
1
0
0
1
1
0
1
1
1
1
0
1
0
0
1
0
0
1
0
1
0
0
0
0
0
1
1
1
1
0
1
1
0
1
0
1
0
1
1
0
1
0
0
1
0
0
1
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
Figure 8.19
■
Practice 14	 A hall light is controlled by two light switches, one at each end of the hall. Find (a) a 
truth function, (b) a Boolean expression, and (c) a logic network that allows the light to be 
switched on or off by either switch.
In some problems the corresponding truth functions have certain undefined 
values because certain combinations of input cannot occur (see Exercise 35 at 
the end of this section). Under these “don’t-care” conditions, any value may be 
­assigned to the output.
In a programming language where the Boolean operators AND, OR, and 
NOT are available, designing the logic of a computer program may consist in part 
of choosing appropriate truth functions and their corresponding Boolean expres-
sions (see Exercise 36 of Section 1.1).

654	
Boolean Algebra and Computer Logic 
Special Interest Page 
Pruning Chips and Programs
Computer computations (barring coding errors) are 
generally viewed as the height of accuracy. Translat-
ing truth functions into circuits that produce correct 
outputs for given inputs has been the theme of this 
chapter. But some computer applications do not re-
quire 100% accuracy and can tolerate a certain amount 
of error. Image processing is one such application be-
cause small variations in an image are imperceptible 
to the human eye. (This feature of human eyesight is 
used to advantage in JPEG lossy image compression, 
as discussed in Section 6.4.)
Recently, researchers looking for increased ef-
ficiency in chip design have “pruned” traditional 
­circuits, essentially cutting away the parts that are sel-
dom used. Pruned chips consume less energy and are 
both smaller and faster than the complete chip. We can 
lump these three factors—energy, space, and time—­
together under the general term “efficiency.” Experi-
mental pruning of a chip’s addition circuit produced a 
7.5% gain in overall efficiency. But of course there is 
a tradeoff; some percentage of error is introduced in 
the chip’s operation. The 7.5% efficiency gain came at 
the cost of a 0.25% error rate. For specialized applica-
tions such as image processing, where small amounts 
of error can be tolerated, the tradeoff seems to be a 
good thing. Developers of this technology are looking 
toward applications such as hearing aids, cameras, or 
even tablet computers that could run on solar power.
The same approach is also being tried with soft-
ware. For example, “loop perforation” skips some of 
the iterations in a loop. This is a particularly evocative 
name—“perforating a loop” sounds very much like 
“pruning a chip.” Other approaches may skip entire 
tasks or randomly discard some input values. “Re-
laxed program” is a general title for software that has 
built-in nondeterminism that can dynamically prune 
(skip) some of its instructions or data. The benefit is 
increased runtime efficiency. The penalty is some per-
centage of incorrect results. And the trick, of course, is 
to ensure—and formally verify—that such techniques, 
while increasing efficiency, keep the output within an 
acceptable error range.
“Inexact Design—Beyond Fault Tolerance,” Anthes, G., 
Communications of the ACM, April, 2013.
http://news.rice.edu/2012/05/17/computing-experts-unveil-
superefficient-inexact-chip/
http://web.mit.edu/newsoffice/2010/fuzzy-logic-0103.html
“Proving Acceptability Properties of Relaxed Nondeter-
ministic Approximate Programs,” Carbin, M., Kim, 
D., Misailovic, S., Rinard, M., ACM Conference on 
Programming Language Design and Implementation, 
June 11–16, 2012, Beijing, China.
http://web.mit.edu/newsoffice/2012/loop-perforation-0522.
html
Chapter 8

Section 8.2   Logic Networks	
655
S e c t i o n  8 . 2 	 Review
Techniques
•	 Find the truth function corresponding to a given 
Boolean expression or logic network.
•	 Construct a logic network with the same truth func-
tion as a given Boolean expression.
•	 Write a Boolean expression with the same truth 
function as a given logic network.
•	 Write the Boolean expression in canonical sum-of-
products form for a given truth function.
•	 Find a network composed only of NAND gates that 
has the same truth function as a given network with 
AND gates, OR gates, and inverters.
•	 Find a truth function that satisfies the description of 
a particular problem.
Main Ideas
•	 We can effectively convert information from any of 
the following three forms to any other form:
truth function 4 Boolean expression 4  
logic network
•	 A Boolean expression can sometimes be converted 
to a simpler, equivalent expression using the prop-
erties of Boolean algebra, thus producing a simpler 
network for a given truth function.
W
W
Exercises 8.2
For Exercises 1–4, write a truth function and construct a logic network using AND gates, OR gates, and ­inverters 
for each of the given Boolean expressions.
	 1.	 (x1′ + x2)x3
	 2.	 (x1 + x2′) + x1′x3
	 3.	 x1′x2 + (x1x2)′
	 4.	 (x1 + x2)′x3 + x3′
For Exercises 5–8, write a Boolean expression and a truth function for each of the logic networks shown.
	 5.	
	 6.	
	 7.	

656	
Boolean Algebra and Computer Logic 
	 8.	
x3
x2
x1
	 9.	 a.	 Write the truth function for the Boolean operation x ! y = xy′ + yx′.
	
b.	Draw the logic network for x ! y.
	
c.	 Show that the network of the accompanying figure also represents x ! y. Explain why the network 
illustrates that ! is the exclusive OR operation. (Recall that a bitwise exclusive-OR operation is used 
in DES encoding, as discussed in Section 5.6.)
x
y
x
y
	 10.	a.	 Write the truth function for the Boolean expression
(xy′)′( yx′)′
	
b.	Draw the logic network for this expression.
	
c.	 By looking at either the truth function or the logic network, what propositional logic connective does 
this Boolean expression represent?
For Exercises 11–20, find the canonical sum-of-products form for the truth functions in the given tables.
	 11.	
x1
x2
f( x1, x2)
1
1
0
1
0
0
0
1
0
0
0
1
	 12.		 x1
x2
f( x1, x2)
1
1
1
1
0
0
0
1
1
0
0
0
	 13.	 x1
x2
x3
f( x1, x2, x3)
1
1
1
1
1
1
0
0
1
0
1
0
1
0
0
0
0
1
1
1
0
1
0
0
0
0
1
0
0
0
0
0

Section 8.2   Logic Networks	
657
	
14. 
	
x1
x2
x3
f( x1, x2, x3)
1
1
1
0
1
1
0
1
1
0
1
1
1
0
0
0
0
1
1
1
0
1
0
0
0
0
1
0
0
0
0
1
	 15.
	
x1
x2
x3
f( x1, x2, x3)
1
1
1
0
1
1
0
0
1
0
1
1
1
0
0
1
0
1
1
0
0
1
0
1
0
0
1
0
0
0
0
0
	 16.	 x1
x2
x3
f( x1, x2, x3)
1
1
1
0
1
1
0
1
1
0
1
1
1
0
0
0
0
1
1
0
0
1
0
1
0
0
1
0
0
0
0
0
	 17.	 x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
1
1
1
1
0
0
1
1
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
0
0
1
0
0
1
1
1
0
0
0
0
0
1
1
1
0
0
1
1
0
0
0
1
0
1
0
0
1
0
0
0
0
0
1
1
1
0
0
1
0
1
0
0
0
1
0
0
0
0
0
0
	 18.	 x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
1
1
1
1
0
0
1
1
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
0
1
1
0
0
1
0
1
0
0
0
0
0
1
1
1
1
0
1
1
0
0
0
1
0
1
1
0
1
0
0
0
0
0
1
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0

658	
Boolean Algebra and Computer Logic 
	 19.	 x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
0
1
1
1
0
0
1
1
0
1
0
1
1
0
0
0
1
0
1
1
0
1
0
1
0
1
1
0
0
1
0
1
0
0
0
0
0
1
1
1
1
0
1
1
0
0
0
1
0
1
1
0
1
0
0
0
0
0
1
1
1
0
0
1
0
1
0
0
0
1
1
0
0
0
0
0
	 20.	 x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
1
1
1
1
0
1
1
1
0
1
0
1
1
0
0
1
1
0
1
1
1
1
0
1
0
0
1
0
0
1
0
1
0
0
0
0
0
1
1
1
0
0
1
1
0
1
0
1
0
1
0
0
1
0
0
1
0
0
1
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
	 21.	a.	 Find the canonical sum-of-products form for the truth function in the accompanying table.
	
b.	Draw the logic network for the expression of part (a).
	
c.	 Use properties of a Boolean algebra to reduce the expression of part (a) to an equivalent expression 
whose network requires only two logic elements. Draw the network.
x1
x2
x3
f( x1, x2, x3)
1
1
1
0
1
1
0
1
1
0
1
0
1
0
0
1
0
1
1
0
0
1
0
0
0
0
1
0
0
0
0
0
	 22.	a. 	Find the canonical sum-of-products form for the truth function in the accompanying table.
	
b.	Draw the logic network for the expression of part (a).
	
c.	 Use properties of a Boolean algebra to reduce the expression of part (a) to an equivalent expression 
whose network requires only three logic elements. Draw the network.

Section 8.2   Logic Networks	
659
x1
x2
x3
f( x1, x2, x3)
1
1
1
1
1
1
0
0
1
0
1
0
1
0
0
0
0
1
1
1
0
1
0
1
0
0
1
0
0
0
0
0
	 23.	a.	 Show that the two Boolean expressions
(x1 + x2)(x1′ + x3)(x2 + x3)
	
	
and
(x1x3) + (x1′x2)
	
	
are equivalent by writing the truth function for each.
	
b.	Write the canonical sum-of-products form equivalent to the two expressions of part (a).
	
c.	 Use properties of a Boolean algebra to reduce one of the expressions of part (a) to the other.
	 24.	The accompanying figure shows an unprogrammed PLD for three inputs, x1, x2, and x3. Program this PLD 
to generate the truth functions f1 and f3 represented by
f1:  x1x2x3 + x1′x2x3′ + x1′x2′x3
f3:  x1x2′x3′ + x1′x2′x3 + x1′x2′x3′
f1
x3
x2
x1
f2
f3
f4
Input
Output

660	
Boolean Algebra and Computer Logic 
	 25.	There is also a canonical product-of-sums form (conjunctive normal form) for any truth function. This 
expression has the form
( )( ) c ( )
	
	 with each factor a sum of the form
a + b + c+ v
	
	 where a = x1 or x1′, b = x2 or x2′, and so on. Each factor is constructed to have a value of 0 for the input 
values of exactly one of the rows of the truth function having value 0. Thus, the entire expression has 
value 0 for these inputs and no others. Find the canonical product-of-sums form for the truth functions of 
Exercises 11–15.
	 26.	Consider the truth function given here. Because there are many more 1s than 0s. the canonical sum-of-
products form might seem tedious to compute. Instead, create a Boolean sum-of-products expression us-
ing the same formula as before but on the 0 rows instead of the 1 rows. This expression will give outputs of 
1s for those rows and no others, exactly the opposite of what you want. Then complement the expression 
(equivalent to sticking an inverter on the end of the network).
x1
x2
x3
f(x1, x2, x3)
1
1
1
1
1
1
0
1
1
0
1
1
1
0
0
0
0
1
1
1
0
1
0
1
0
0
1
0
0
0
0
1
	
a.	 Use this approach to create a Boolean expression for this truth function.
	
b.	Prove that the resulting expression is equivalent to the canonical product-of-sums form described in 
Exercise 25.
	 27.	The 2’s complement of an n-bit binary number p is an n-bit binary number q such that p + q equals an 
n-bit representation of zero (any carry bit to column n + 1 is ignored). Thus 01110 is the 2’s complement 
of 10010 because
 10010
+ 01110
 (1)00000
	
	 The 2’s complement idea can be used to represent negative integers in binary form. After all, the negative 
of p is by definition a number that, when added to p, results in zero.
Given a binary number p, the 2’s complement of p is found by scanning p from low-order to high-
order bits (right to left). As long as bit i of p is 0, bit i of q is 0. When the first 1 of p is encountered, say at 
bit j, then bit j of q is 1, but for the remaining bits, j < i ≤n, qi = pi′. For p = 10010, for instance, the 

Section 8.2   Logic Networks	
661
rightmost 0 bit of p stays a 0 bit in q, and the first 1 bit stays a 1 bit. The remaining bits of q, however, are 
the reverse of the bits in p.
	
p = 1 0 0
q = 0 1 1
()*
qi = pi′
	 	
1 0
1 0
()*
qi = pi
	
	 For each binary number p, find the 2’s complement of p, namely q, and then calculate p + q.
	
a.	 1100	
b.	1001	
c.	 001
	 28.	For any bit xi in a binary number p, let ri be the corresponding bit in q, the 2’s complement of p (see 
­Exercise 27). The value of ri depends on the value of xi and also on the position of xi relative to the first 
1 bit in p. For the ith bit, let ci−1 denote a 0 if the bits pj, 1 ≤j ≤i −1, are 0 and a 1 otherwise. A value 
ci must be computed to move on to the next bit.
	
a.	 Give a truth function for ri with inputs xi and ci−1. Give a truth function for ci with inputs xi and ci−1.
	
b.	Write Boolean expressions for the truth functions of part (a). Simplify as much as possible.
	
c.	 Design a circuit module to output ri and ci from inputs xi and ci−1.
	
d.	Using the modules of part (c), design a circuit to find the 2’s complement of a three-bit binary number 
zyx. Trace the operation of the circuit in computing the 2’s complement of 110.
	 29.	a.	 Construct a network for the following expression using only NAND elements. Replace the AND and 
OR gates and inverters with the appropriate NAND networks.
x3′x1 + x2′x1 + x3′
	
b.	Use the properties of a Boolean algebra to reduce the expression of part (a) to one whose network 
would require only three NAND gates. Draw the network.
	 30.	Replace the following network with an equivalent network using one AND gate, one OR gate, and one inverter.
x2
x1
x3
	 31.	Using only NOR elements, construct networks that can replace (a) an inverter, (b) an OR gate, and (c) an 
AND gate.
	 32.	Find an equivalent network for the half-adder module that uses exactly five NAND gates. Draw the ­network.
	 33.	A thermostat controls a heating system that should raise the temperature above 67 °F during working 
hours (between 7:00 am and 6:00 pm). The input values are
	
 x1 = 1 when the temperature is less than 67 °F
	
x1 = 0 otherwise 
	
x2 = 1 when the time is less than 7:00 am or greater than 6:00 pm
	
x2 = 0 otherwise
	
	 Find a truth function, a Boolean expression, and a logic network for when the heating system should be 
on (value 1) or off (value 0).
First 1

662	
Boolean Algebra and Computer Logic 
	 34.	The space shuttle was controlled by three on-board computers; binary output from these three computers 
was compared and a majority vote was required for certain actions to take place. Find a truth function, a 
Boolean expression, and a logic network that outputs the majority vote of the three input values.
	 35.	You have just been hired at Mercenary Motors. Your job is to design a logic network so that a car can be 
started only when the automatic transmission is in neutral or park and the driver’s seat belt is fastened. 
Find a truth function, a Boolean expression, and a logic network. (There is a don’t-care condition to the 
truth function, since the car cannot be in both neutral and park.)
	 36.	Mercenary Motors has expanded into the calculator business. You need to design the circuitry for the 
display readout on a new calculator. This design involves a two-step process.
	
a.	 Any digit 0, 1, … , 9 put into the calculator is first converted to binary form. Part (a) of the accompany-
ing figure illustrates this conversion, which involves four separate networks, one each for x1 to x4. Each 
network has 10 inputs, but only 1 input can be on at any given moment. Write a Boolean expression and 
then draw a network for x2.
	
b.	The binary form of the digit is then converted into a visual display by activating a pattern of seven out-
puts arranged as shown in figure (b). To display the digit 3, for example, y1, y2, y3, y5, and y7 must be 
on, as in figure (c). Thus, the second step of the process can be represented by figure (d), which involves 
seven separate networks, one each for y1 to y7, each with four inputs, x1 to x4. Write a truth function, a 
Boolean expression, and a network for y5 and for y6.
0
1
2
3
4
5
6
7
8
9
y1
x4
x3
x2
x1
x4
x3
x2
x1
y2
y3
y4
y5
y6
y7
Logic
for
binary
encoder
Logic
for
display
readout
(d)
(c)
(b)
(a)
y6
y7
y3
y2
y1
y4
y5

Section 8.3   Minimization	
663
	 37.	A multiplexor is a control circuit with 2n input lines (numbered 0 through 2n −1), n selector lines, and 
exactly one output line. The signal on the output line is to match the signal on one of the input lines; the 
selector lines determine which of the input line signals will be propagated to the output line. Signals on 
the n selector lines determine an n-bit binary number, which can range in value from 0 to 2n −1; hence 
the numeric value on the selector lines identifies exactly one input line. The arithmetic-logic unit of a com-
puter processor contains circuits for various operations (addition, subtraction, comparison, and so forth), 
and when an arithmetic or comparison operation is to be done, the ALU may activate all these circuit. A 
multiplexor then picks out the one desired result.
	
a.	 Write a truth function for a multiplexor where n = 1; that is, there are 2 input lines, 1 selector line and, 
of course, one output line.
	
b.	Draw the logic network (as simple as possible).
	 38.	A decoder is a control circuit with n input lines and 2n output lines (numbered 0 through 2n −1). The pat-
tern of n bits on the input lines represents a binary number between 0 and 2n −1. A decoder activates the 
output line with the corresponding identification number by putting a 1 output on that line and 0 outputs 
on all other output lines. A decoder in a computer can, for example, read input lines that represent a binary 
memory address and then activate the line to that memory cell for a read operation.
	
a.	 Write truth functions for a decoder where n = 2, that is, there are 2 input lines and 22 = 4 output lines 
(hence four truth functions).
	
b.	Draw the logic network that incorporates all four truth functions.
	 39.	At the beginning of this chapter, you were
. . . hired by Rats R Us to build the control logic for the production facilities for a new anticancer 
chemical compound being tested on rats. The control logic must manage the opening and closing 
of two valves, A and B, downstream of the mixing vat. Valve A is to open whenever the pressure 
in the vat exceeds 50 psi (pounds per square inch) and the salinity of the mixture exceeds 45 g/L 
(grams per liter). Valve B is to open whenever valve A is closed and the temperature exceeds 53°C 
and the acidity falls below 7.0 pH (lower pH values mean more acidity).
How many and what type of logic gates will be needed in the circuit?
	
	 Answer this question by finding the canonical sum-of-products form for the logic circuits to control A 
and B.
	
S e c t i o n  8 . 3 	 Minimization
Minimization Process
Remember from Section 8.2 that a given truth function is associated with an 
equivalence class of Boolean expressions. If we want to design a logic network 
for the function, the ideal would be to have a procedure that chooses the simplest 
Boolean expression from the class. What we consider simple will depend on the 
technology employed in building the network, what kind of logic elements are 
available, and so on. At any rate, we probably want to minimize the total number 
of connections that must be made and the total number of logic elements used. (As 
we discuss minimization procedures, keep in mind that other factors may influ-
ence the economics of the situation. If a network is to be built only once, the time 
spent on minimization is costlier than building the network. But if the network 
is to be mass-produced, then the cost of minimization time may be worthwhile.)

664	
Boolean Algebra and Computer Logic 
We have had some experience in simplifying Boolean expressions by apply-
ing the properties of Boolean algebra. However, we had no procedure to use. We 
simply had to guess, attacking each problem individually. What we want now is 
a mechanical procedure that we can use without having to be clever or insightful. 
Unfortunately, we won’t develop the ideal procedure. However, we already know 
how to select the canonical sum-of-products form from the equivalence class of 
expressions for a given truth function. In this section we will discuss two proce-
dures to reduce a canonical sum-of-products form to a minimal sum-of-products 
form. Therefore, we can minimize within the framework of a sum-of-products 
form and reduce, if not completely minimize, the number of elements and con-
nections required.
	
ExAmple 19	
The Boolean expression
x1x2x3 + x1′x2x3 + x1′x2x3′
is in sum-of-products form. An equivalent minimal sum-of-products form is
x2x3 + x2x1′
Implementing a network for this form would require two AND gates, one OR gate, 
and an inverter. Using one of the distributive laws of Boolean algebra, this expres-
sion reduces to
x2(x3 + x1′)
which requires only one AND gate, one OR gate, and an inverter, but it is no lon-
ger in sum-of-products form. Thus, a minimal sum-of-products form may not be 
minimal in an absolute sense.	
■
Practice 15	 Use properties of Boolean algebra to reduce the following expressions as indicated:
a.	 x1x2 + x1′x2 to x2
b.	 x1 + x1′x2 to x1 + x2
There are two extremely useful equivalences in minimizing a sum-of-­products 
form. They are
x1x2 + x1′x2 = x2
and
x1 + x1′x2 = x1 + x2
The equivalence x1x2 + x1′x2 = x2 means, for example, that the expression 
x1′x2x3′x4 + x1′x2′x3′x4 reduces to x1′x3′x4. Thus, when we have a sum of two products 
that differ in only one factor, we can eliminate that factor. However, the canonical 

Section 8.3   Minimization	
665
sum-of-products form for a truth function of, say, four variables might be quite 
long and require some searching to locate two product terms differing by only one 
factor. To help us in this search, we can use the Karnaugh map. The Karnaugh 
map is a visual representation of the truth function so that terms in the canonical 
sum-of-products form that differ by only one factor can be matched quickly.
Karnaugh Map
In the canonical sum-of-products form for a truth function, we are interested in 
values of the input variables that produce ­outputs of 1. The Karnaugh map records 
the 1s of the function in an array that forces products of inputs 
differing by only one factor to be adjacent. The array form for 
a two-variable function is given in Figure 8.20. Notice that the 
square corresponding to x1x2, the upper left-hand square, is ad-
jacent to squares x1′x2 and x1x2′, which differ in one factor from 
x1x2; however, it is not adjacent to the x1′x2′ square, which differs 
in two factors from x1x2.
x2
x2
x1
x1
Figure 8.20
	
Example 20	
The truth function of Table 8.10 is represented by the Karnaugh map of Figure 
8.21. At once we can observe 1s in two adjacent squares, so there are two terms in 
the canonical sum-of-products form differing by one variable; again from the map, 
we see that the variable that changes is x1. It can be eliminated. We conclude that 
the function can be represented by x2. Indeed, the canonical sum-of-products form 
for the function is x1x2 + x1′x2, which, by our basic reduction rule, reduces to x2. 
However, we did not have to write the canonical form—we only had to look at the 
map.
Table 8.10
x1
x2
f( x1, x2)
1
1
1
1
0
0
0
1
1
0
0
0
1
1
x1
x1
x2
x2
Figure 8.21
■
Practice 16	 Draw the Karnaugh map and use it to find a reduced expression for the function in  
Table 8.11.
Table 8.11
x1
x2
f( x1, x2)
1
1
0
1
0
0
0
1
1
0
0
1

666	
Boolean Algebra and Computer Logic 
Maps for Three and Four Variables
The array forms for functions of three and four variables are shown in Figure 8.22. 
In these arrays, adjacent squares also differ by only one variable. However, in 
Figure 8.22a, the leftmost and rightmost squares in a row also differ by one vari-
able, so we consider them adjacent. (They would in fact be adjacent if we wrapped 
the map around a cylinder and glued the left and right edges together.) In Figure 
8.22b, the leftmost and rightmost squares in a row are adjacent (differ by exactly 
one variable), and also the top and bottom squares in a column are adjacent.
(a)
(b)
x1x2
x1x2
x3x4
x3
x1x2
x1x2
x3x4
x3
x1x2
x1x2
x3x4
x1x2
x1x2
x3x4
Figure 8.22
In three-variable maps, when two adjacent squares are marked with 1, one vari-
able can be eliminated; when four adjacent squares are marked with 1 (either in a 
single row or arranged in a square), two variables can be eliminated.
The labelings for two-, three-, and four-variable maps can be done in various 
ways, but they must be done so that adjacent squares differ by one variable. It’s 
probably best to just memorize the labeling schemes we’ve used here.
REMINDER
It is crucial to label the 
Karnaugh map so that 
adjacent squares differ by 
one variable.
	
Example 21	
In the map of Figure 8.23, the squares that combine for a reduction are shown as a 
block. These four adjacent squares reduce to x3 (eliminate the changing variables 
x1 and x2). The reduction uses our basic reduction rule more than once:
x1x2x3 + x1x2′x3 + x1′x2′x3 + x1′x2x3 = x1x3(x2 + x2′) + x1′x3(x2′ + x2)
= x1x3 + x1′x3
= x3(x1 + x1′)
= x3
But, again, you don’t have to go through this process; you can just look at the 
Karnaugh map in Figure 8.23.
1
1
1
1
x1x2
x3
x1x2
x3
x1x2
x1x2
Figure 8.23

Section 8.3   Minimization	
667
In four-variable maps, when two adjacent squares are marked with 1, one 
variable can be eliminated; when four adjacent squares are marked with 1,  
two variables can be eliminated; when eight adjacent squares are marked with  
1, three variables can be eliminated.
Figure 8.24 illustrates some instances of two adjacent marked squares, Figure 8.25 
illustrates some instances of four adjacent marked squares, and Figure 8.26 shows 
instances of eight.
1
1
1
1
1
1
1
1
x1x2
x3
x1x2
x3
x1x2
x1x2
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.24
x3x4
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x1x2
x3x4
1
1
1
1
x1x2
x3
x1x2
x3
x1x2
x1x2
1
1
1
1
x1x2
x3
x1x2
x3
x1x2
x1x2
Figure 8.25
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x1x2
x1x2
x1x2
x1x2
x3x4
x3x4
x3x4
x3x4
x3x4
Figure 8.26

668	
Boolean Algebra and Computer Logic 
Using the Karnaugh Map
How do we find a minimal sum-of-products form from a Karnaugh map (or from 
a truth function or a canonical sum-of-products form)? We must use every marked 
square of the map, and we want to include every marked square in the largest com-
bination of marked squares possible, since doing so will reduce the expression as 
much as possible. Surprisingly, we cannot begin by simply looking for the largest 
blocks of marked squares on the map.
	
Example 22	
In the map of Figure 8.27, the four outside corners reduce to x2x4 and the inside 
square reduces to x2′x4′.
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.27
■
Practice 17	 Find the two terms represented by the map in Figure 8.28.
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.28
	
Example 23	
In the Karnaugh map of Figure 8.29, if we simply looked for the largest block of 
marked squares, we would use the column of 1s and reduce it to x1′x2′. However, 
we would still have four marked squares unaccounted for. Each of these marked 
squares can be combined into a two-square block in only one way (Figure 8.30), 
and each of these blocks has to be included. But when this adjustment is made, 
every square in the column of 1s is used, and the term x1′x2′ is superfluous. The 
minimal sum-of-products form for this map becomes
x2′x3x4 + x1′x3x4′ + x2′x3′x4′ + x1′x3′x4

Section 8.3   Minimization	
669
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.29
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.30
To avoid the redundancy illustrated by Example 23, we analyze the map as 
follows. First, we form terms for those marked squares that cannot be combined 
with anything. Then we use the remaining marked squares to find those that can be 
combined only into two-square blocks and in only one way. Then among the un-
used marked squares—that is, those not already assigned to a block—we find those 
that can be combined only into four-square blocks and in only one way; then we 
look for any unused squares that go uniquely into eight-square blocks. At each step, 
if an unused marked square can go into more than one block, we do nothing with 
it. Finally, we take any unused marked squares that are left (for which there was a 
choice of blocks) and select blocks that include them in the most efficient manner.
Table 8.12 shows the steps involved. Note, however, that this procedure for 
handling Karnaugh maps is not, strictly speaking, an algorithm because it doesn’t 
always produce the correct result. If there are many 1s in the map, thus allowing 
many different blockings, even this procedure may not lead to a minimal form 
(see Example 28).
Table 8.12
Steps in Using Karnaugh Maps
1. Set up the grid, using correct labeling for the number of Boolean variables.
2. Insert 1s in the table for the terms in the canonical sum-of-products expression.
3. Form terms for any isolated marked squares.
4. Combine squares uniquely into two-square blocks, if possible.
5. Combine squares uniquely into four-square blocks, if possible.
6. Combine squares uniquely into eight-square blocks, if possible.
7. Combine any remaining unused marked squares into blocks as efficiently as possible.
	
Example 24	
In Figure 8.31a we show the only square that cannot be combined into a larger 
block. In Figure 8.31b, we have formed the unique two-square block for the x1x2′x3′ 
square and the unique two-square block for the x1′x2′x3 square. All marked squares 
are covered. The minimal sum-of-products expression is
x1x2x3 + x2′x3′ + x1′x2′

670	
Boolean Algebra and Computer Logic 
Formally, the last two terms are obtained by expanding x1′x2′x3′ into x1′x2′x3′ + x1′x2′x3′ 
and then combining it with each of its neighbors.
(a)
1
1
1
1
(b)
1
1
1
1
x1x2
x3
x1x2
x1x2
x3
x1x2
x1x2
x3
x1x2
x1x2
x3
x1x2
Figure 8.31
	
Example 25	
Figure 8.32a shows the unique two-square blocks for the x1′x2′x3x4 square and the 
x1x2′x3′x4′ square. In Figure 8.32b the two unused squares have been combined into 
a unique four-square block. The minimal sum-of-products expression is
x1x3 + x2′x3x4 + x1x2′x4′
1
(a)
1
1
1
1
1
1
(b)
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.32
	
Example 26	
Figure 8.33a shows the unique two-square blocks. We can assign the remaining 
unused marked square to either of two different two-square blocks; these blocks 
are shown in Figure 8.33b. There are two minimal sum-of-products forms,
x1x2′x4′ +  x1′x2x3 + x2′x3x4′
and
x1x2′x4′ + x1′x2x3 + x1′x3x4′
Either can be used, as they are equally efficient.

Section 8.3   Minimization	
671
1
1
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.33
	
Example 27	
Figure 8.34a shows the unique two-square and four-square blocks. The remaining 
two unused marked squares can be assigned to two-square blocks in two different 
ways, as shown in parts (b) and (c). Assigning them together to a single two-square 
block is more efficient because it produces a sum-of-products form with three 
terms rather than four. The minimal sum-of-products expression is
x1x3 + x1′x2x3′ + x2′x3′x4′
1
1
1
1
1
(a)
(b)
1
1
1
1
1
1
1
1
1
1
1
(c)
1
1
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.34
	
Example 28	
Consider the map of Figure 8.35a. Here the two unique four-square blocks deter-
mined by the squares with * have been chosen. In Figure 8.35b, the remaining un-
marked squares, for which there was a choice of blocks, are combined into blocks 
as efficiently as possible. The resulting sum-of-products form is
x1x3 + x1′x3′ + x3x4 + x1′x2 + x1x2′x4′

672	
Boolean Algebra and Computer Logic 
Yet in Figure 8.35c, choosing a different four-square block at the top leads to a 
simpler sum-of-products form,
x2x3 + x1′x3′ + x3x4 + x1x2′x4′
1
1
1
1
1
1
1
1
1
(a)
(b)
1
1
1
1
1
1
1
1
1
*
*
*
*
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
(c)
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.35
■
Practice 18	 Write the minimal sum-of-products expression for the map shown in Figure 8.36.
1
1
1
1
1
1
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
x1x2
x3x4
Figure 8.36
If the Karnaugh map corresponds to a function with don’t-care conditions, 
then the don’t-care squares on the map can be left blank or assigned the value 1, 
whichever aids the minimization process.
We have used Karnaugh maps for functions of two, three, and four variables. 
By using three-dimensional drawings or overlapping transparency sheets, Kar-
naugh maps for functions of five, six, or even more variables can be constructed, 
but the visualization gets too complicated to be worthwhile. The next procedure 
works for any number of variables.

Section 8.3   Minimization	
673
Quine–McCluskey Procedure
Remember that the key to reducing the canonical sum-of-products form for a truth 
function lies in recognizing terms of the sum that differ in only one factor. In the 
Karnaugh map, we see where such terms occur. A second method of reduction, 
the Quine–McCluskey procedure, organizes information from the canonical sum-
of-products form into a table to simplify the search for terms differing by only 
one factor.
The procedure is a two-step process paralleling the use of the Karnaugh map. 
First we find groupings of terms (just as we looped together marked squares in 
the Karnaugh map); then we eliminate redundant groupings and make choices for 
terms that can belong to several groups.
	
Example 29	
Let’s illustrate the Quine–McCluskey procedure by using the truth function for 
Example 23. We did not write the actual truth function there, but the information 
is contained in the Karnaugh map. The truth function is shown in Table 8.13. The 
eight 4-tuples of 0s and 1s producing a function value of 1 are listed in Table 8.14, 
which is separated into four groupings according to the number of 1s. Note that 
terms of the canonical sum-of-products form differing by only one factor must be 
in adjacent groupings, which simplifies the search for such terms.
Table 8.13
x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
0
1
1
1
0
0
1
1
0
1
0
1
1
0
0
0
1
0
1
1
1
1
0
1
0
0
1
0
0
1
0
1
0
0
0
1
0
1
1
1
0
0
1
1
0
1
0
1
0
1
1
0
1
0
0
0
0
0
1
1
1
0
0
1
0
1
0
0
0
1
1
0
0
0
0
1
Table 8.14
Number of 1s
x1
x2
x3
x4
Three
1
0
1
1
Two
0
1
1
0
0
1
0
1
0
0
1
1
One
1
0
0
0
0
0
1
0
0
0
0
1
None
0
0
0
0

674	
Boolean Algebra and Computer Logic 
We compare the first term, 1011, with each of the three terms of the second 
group, 0110, 0101, and 0011, to locate terms differing by only one factor. Such a 
term is 0011. The combination 1011 and 0011 reduces to −011 when the chang-
ing variable x1 is eliminated. We will write this reduced term with a dash in the 
x1 position in the first row of a new table. The new table is Table 8.15b, where 
we’ve just seen how the first row was obtained. We’ve rewritten the original  
Table 8.14 as Table 8.15a, but we have also marked the two terms 1011 and 0011 
in this table with a superscript 1. This superscript 1 is a pointer that indicates 
the row number of the reduced term in Table 8.15b that is formed from these 
two terms (numbering terms corresponds to putting loops in the Karnaugh map).
Table 8.15
Number of 1s
x1
x2
x3
x4
Three
1
0
1
1
1
Two
0
1
1
0
2
0
1
0
1
3
0
0
1
1
1, 4, 5
One
1
0
0
0
6
0
0
1
0
2, 4, 7
0
0
0
1
3, 5, 8
None
0
0
0
0
6, 7, 8
We continue this process with all the terms in Table 8.15a. A numbered term 
may still be used in other combinations, just as a marked square in a Karnaugh 
map can be in more than one loop. When we are done, the result is the completed 
Table 8.15b shown, where the terms in this table are again grouped by the num-
ber of 1s.
We now build still another table by processing the terms in Table 8.15b. 
Here not only the groupings but also the dashes help organize the search pro-
cess, since terms differing by only one variable must have dashes in the same 
location. Tables 8.16a and 8.16b are the same as Tables 8.15a and 8.15b, and  
Table 8.16c is the new table. Again, numbers on terms in Table 8.16b that combine 
serve as pointers to the reduced terms in Table 8.16c. When we have processed 
all the terms in Table 8.16b, the reduction process cannot be continued. The un-
numbered terms are irreducible, so they represent the possible maximum-sized 
loops on a Karnaugh map.
Number of 1s
x1
x2
x3
x4
Two
–
0
1
1
One
0
–
1
0
0
–
0
1
0
0
1
–
0
0
–
1
None
–
0
0
0
0
0
–
0
0
0
0
–
(a)
(b)

Section 8.3   Minimization	
675
Number of 1s
x1
x2
x3
x4
Two
–
0
1
1
One
0
–
1
0
0
–
0
1
0
0
1
–
1
0
0
–
1
1
None
–
0
0
0
0
0
–
0
1
0
0
0
–
1
Number of 1s
x1
x2
x3
x4
None
0
0
–
–
(a)
(b)
(c)
For the second step of the process, we compare the original terms with the 
irreducible terms. We form a table with the original terms as column headers 
and the irreducible terms (the unnumbered terms in the reduction tables just con-
structed) as row labels. A check in the comparison table (Table 8.17) indicates that 
the original term in that column eventually led to the irreducible term in that row, 
which can be determined by following the pointers.
Table 8.17
1011
0110
0101
0011
1000
0010
0001
0000
–011
✓
✓
0–10
✓
✓
0–01
✓
✓
–000
✓
✓
00– –
✓
✓
✓
✓
If a column in the comparison table has a check in only one row, the irreduc-
ible term for that row is the only one covering the original term, so it is an essen-
tial term and must appear in the final sum-of-products form. Thus, we see from 
Table 8.17 that the terms –011, 0–10, 0–01, and –000 are essential and must be 
in the final expression. We also note that all columns with a check in row 5 also  
have checks in another row and so are covered by an essential reduced term al-
ready in the expression. Thus, 00– – is redundant. As in Example 23, the minimal 
sum-of-products form is
x2′x3x4 + x1′x3x4′ + x1′x3′x4 + x2′x3′x4′
Table 8.16
Number of 1s
x1
x2
x3
x4
Three
1
0
1
1
1
Two
0
1
1
0
2
0
1
0
1
3
0
0
1
1
1, 4, 5
One
1
0
0
0
6
0
0
1
0
2, 4, 7
0
0
0
1
3, 5, 8
None
0
0
0
0
6, 7, 8

676	
Boolean Algebra and Computer Logic 
Number of 1s
x1
x2
x3
x4
Two
0
1
1
–
One
–
0
1
0
1
0
–
0
0
–
1
0
In situations where there is more than one minimal sum-of-products form, the 
comparison table will have nonessential, nonredundant reduced terms. A selec-
tion must be made from these reduced terms to cover all columns not covered by 
essential terms.
Table 8.19
0111
1010
0110
0010
1000
011–
✓
✓
–010
✓
✓
10–0
✓
✓
0–10
✓
✓
We see from the comparison table that 011– and 10–0 are essential reduced terms 
and that there are no redundant terms. The only original term not covered by es-
sential terms is 0010, column 4, and the choice of the reduced term for row 2 or for 
row 4 will cover it. Thus, the minimal sum-of-products form, as before, is
x1′x2x3 + x1x2′x4′ + x2′x3x4′
or
x1′x2x3 + x1x2′x4′ + x1′x3x4′
(a)
(b)
	
Example 30	
We will use the Quine–McCluskey procedure on the problem presented in ­Example 
26. The reduction tables are given in Table 8.18, and the comparison table appears 
in Table 8.19.
Table 8.18
Number of 1s
x1
x2
x3
x4
Three
0
1
1
1
1
Two
1
0
1
0
2, 3
0
1
1
0
1, 4
One
0
0
1
0
2, 4
1
0
0
0
3

Section 8.3   Minimization	
677
While the Quine–McCluskey procedure applies to truth functions with any 
number of input variables, for a large number of variables, the procedure is ­extremely 
tedious to do by hand. However, it is exactly the kind of systematic, ­mechanical pro-
cess that lends itself to a computerized solution. In contrast, ­Karnaugh maps make 
use of the human ability to quickly recognize visual patterns.
If the truth function f has few 0 values and a large number of 1 values, it may 
be simpler to implement the Quine–McCluskey procedure for the complement of 
the function, f ′, which will have 1 values where f has 0 values, and vice versa. 
Once a minimal sum-of-products expression is obtained for f ′, it can be comple-
mented to obtain an expression for f, although the new expression will not be in 
sum-of-products form. (In fact, by De Morgan’s laws, it will be equivalent to a 
product-of-sums form.) We can obtain the network for f from the sum-of-products 
network for f ′ by tacking an inverter on the end.
The whole object of minimizing a network is to simplify the internal configu-
ration while preserving the external behavior. In Chapter 9 we will attempt the 
same sort of minimization on finite-state machine structures.
Practice 19	 Use the Quine–McCluskey procedure to find a minimal sum-of-products form for the truth 
function in Table 8.20.
Table 8.20
x1
x2
x3
f( x1, x2, x3)
1
1
1
1
1
1
0
1
1
0
1
0
1
0
0
1
0
1
1
0
0
1
0
0
0
0
1
1
0
0
0
1
■
S e c t i o n  8 . 3 	
Review
Techniques
•	 Minimize the canonical sum-of-products form for 
a truth function by using a Karnaugh map.
•	 Minimize the canonical sum-of-products form for 
a truth function by using the Quine–McCluskey 
procedure.
Main Idea
•	 Algorithms exist for reducing a canonical sum-
of-products form to a minimized sum-of-products 
form.
W
W

678	
Boolean Algebra and Computer Logic 
Exercises 8.3
For Exercises 1–8, write the minimal sum-of-products form for the Karnaugh maps of the given figures.
	 1.	
x1x2
x3
x1x2
x3
x1x2
x1x2
1
1
1
1
1
	 2.	
x1x2
x3
x1x2
x3
x1x2
x1x2
1
1
1
	 3.	
x1x2
x3
x1x2
x3
x1x2
x1x2
1
1
1
1
1
1
	 4.	
x1x2
x3
x1x2
x3
x1x2
x1x2
1
1
1
	 5.	
x1x2
x1x2
x1x2
x1x2
x3x4
' '
'
'
x3x4'
x3x4'
'
x3x4
'
1
1
1
1
1
1
1
1
	 6.	
x1x2
x1x2
x1x2
x1x2
x3x4
' '
'
'
x3x4'
x3x4'
'
x3x4
'
1
1
1
1
1
	 7.	
x1x2
x1x2
x1x2
x1x2
x3x4
' '
'
'
x3x4'
x3x4'
'
x3x4
'
1
1
1
1
1
	 8.	
x1x2
x1x2
x1x2
x1x2
x3x4
' '
'
'
x3x4'
x3x4'
'
x3x4
'
1
1
1
1
1
1
For Exercises 9 and 10, use a Karnaugh map to find the minimal sum-of-products form for the truth functions 
shown.
	 9.	
x1
x2
x3
f( x1, x2, x3)
1
1
1
1
1
1
0
1
1
0
1
0
1
0
0
0
0
1
1
1
0
1
0
0
0
0
1
0
0
0
0
0

Section 8.3   Minimization	
679
	 10.	 x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
1
1
1
1
0
1
1
1
0
1
1
1
1
0
0
1
1
0
1
1
0
1
0
1
0
1
1
0
0
1
0
1
0
0
0
1
0
1
1
1
1
0
1
1
0
1
0
1
0
1
1
0
1
0
0
1
0
0
1
1
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
	 11.	Use a Karnaugh map to find the minimal sum-of-products form for the truth function of Exercise 17, 
Section 8.2.
	 12.	Use a Karnaugh map to find the minimal sum-of-products form for the truth function of Exercise 18, 
Section 8.2.
	 13.	a.	 Use a Karnaugh map to find the minimal sum-of-products form for the truth function of Exercise 19, 
Section 8.2.
	
b.	Draw the logic network for the reduced expression of part (a).
	 14.	a.	 Use a Karnaugh map to find the minimal sum-of-products form for the truth function of Exercise 20, 
Section 8.2.
	
b.	Draw the logic network for the reduced expression of part (a).
	 15.	Use a Karnaugh map to find the minimal sum-of-products form for the following Boolean expression.
x1′x2′x3x4 + x1x2x3′x4 + x1′x2′x3′x4 + x1x2′x3x4′ +  x1′x2x3x4 + x1′x2x3′x4 + x1′x2′x3x4′
	 16.	Use a Karnaugh map to find the minimal sum-of-products form for the following Boolean expression.
x1′x2′x3′x4′ + x1x2x3′x4 + x1′x2′x3′x4 + x1x2x3′x4′ + x1′x2x3x4 + x1x2′x3′x4′

680	
Boolean Algebra and Computer Logic 
	 17.	Use a Karnaugh map to find 
a minimal sum-of-products 
expression for the network of 
three variables shown in the 
figure. Sketch the new net-
work.
	 18.	At Rats R Us, you found a standard sum-of-products form for the logic to control valves A and B 
(­Exercise 39, Section 8.2). Now earn yourself a raise by using Karnaugh maps to minimize these 
­expressions.
	 19.	Use a Karnaugh map to find a minimal sum-of-products form for the truth function in the table. Don’t-
care conditions are shown by dashes.
x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
0
1
1
1
0
1
1
1
0
1
0
1
1
0
0
–
1
0
1
1
0
1
0
1
0
–
1
0
0
1
0
1
0
0
0
0
0
1
1
1
0
0
1
1
0
1
0
1
0
1
0
0
1
0
0
1
0
0
1
1
1
0
0
1
0
0
0
0
0
1
–
0
0
0
0
0
x1x2x3
x1x2x3
x1x2x3
x1x2x3
x1x2x3

Section 8.3   Minimization	
681
	 20.	Use a Karnaugh map to find a minimal sum-of-products form for the truth function in the table. Don’t-
care conditions are shown by dashes.
x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
0
1
1
1
0
1
1
1
0
1
0
1
1
0
0
–
1
0
1
1
–
1
0
1
0
0
1
0
0
1
0
1
0
0
0
0
0
1
1
1
1
0
1
1
0
0
0
1
0
1
1
0
1
0
0
0
0
0
1
1
1
0
0
1
0
0
0
0
0
1
–
0
0
0
0
0
	 21.	Use the Quine–McCluskey procedure to find a minimal sum-of-products form for the truth function il-
lustrated by the map for Exercise 3.
	 22.	Use the Quine–
McCluskey pro-
cedure to find a 
minimal sum-of-
products form for 
the network in 
the figure. Sketch 
the new network.
x1x2x3x4
x1x2x3x4
x1x2x3x4
x1x2x3x4
x1x2x3x4
x1x2x3x4

682	
Boolean Algebra and Computer Logic 
In Exercises 25–28, use the Quine–McCluskey procedure to find the minimal sum-of-products form for the 
Boolean expressions.
	 25.	x1x2′x3x4′ + x1′x2′x3x4 + x1′x2x3x4 + x1′x2′x3′x4′ + x1′x2x3′x4′ + x1′x2′x3′x4
	 26.	x1x2x3x4 + x1x2′x3x4 + x1x2x3x4′ + x1x2′x3x4′ + x1′x2x3x4′ +
	
	 x1x2x3′x4′ + x1′x2x3′x4′ + x1x2x3′x4 + x1′x2x3′x4
	 27.	x1x2x3x4 + x1x2x3x4′ + x1′x2x3x4′ + x1x2x3′x4′ + x1′x2′x3′x4′ +
	
	 x1′x2x3′x4′ + x1x2′x3′x4 + x1′x2′x3′x4 + x1x2x3′x4
	 28.		x1′x2x3′x4x5′ + x1′x2x3x4′x5 + x1x2x3x4x5 + x1′x2′x3x4′x5 +
	
	 x1x2′x3x4x5 + x1′x2′x3′x4′x5 + x1x2′x3x4′x5 + x1x2x3x4′x5′ +
	
	 x1x2x3′x4x5 + x1′x2′x3′x4x5′
	 29.	Use the Quine–McCluskey procedure to find a minimal sum-of-products form for the truth function 
­illustrated by the map in Figure 8.34.
For Exercises 23 and 24, use the Quine–McCluskey procedure to find the minimal sum-of-products form for 
the truth functions in the given tables.
	 23.	
x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
0
1
1
1
0
1
1
1
0
1
0
1
1
0
0
0
1
0
1
1
0
1
0
1
0
1
1
0
0
1
1
1
0
0
0
1
0
1
1
1
0
0
1
1
0
0
0
1
0
1
0
0
1
0
0
1
0
0
1
1
1
0
0
1
0
1
0
0
0
1
0
0
0
0
0
1
	 24.
x1
x2
x3
x4
f( x1, x2, x3, x4)
1
1
1
1
1
1
1
1
0
0
1
1
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
0
0
1
0
0
1
1
1
0
0
0
1
0
1
1
1
1
0
1
1
0
0
0
1
0
1
1
0
1
0
0
1
0
0
1
1
1
0
0
1
0
0
0
0
0
1
1
0
0
0
0
1

C h a p t e r  8 	
Review
Terminology
AND gate (p. 639)
Boolean algebra (p. 620)
Boolean expression  
(p. 639)
canonical sum-of-products form 
(p. 643)
combinational network (p. 642)
complement (of a Boolean algebra 
element) (p. 625)
De Morgan’s laws (for a Boolean 
algebra) (p. 624)
disjunctive normal form (p. 643)
double negation (for a Boolean 
algebra) (p. 624)
dual (of a Boolean algebra 
property) (p. 623)
equivalent Boolean expressions 
(p. 645)
FPGA (p. 647)
full-adder (p. 650)
half-adder (p. 649)
idempotent property (of a Boolean 
algebra) (p. 622)
inverter (p. 639)
isomorphic instances of a structure 
(p. 626)
isomorphism (p. 626)
isomorphism for Boolean algebras 
(p. 629)
NAND gate (p. 650)
NOR gate (p. 651)
OR gate (p. 639)
PLD (p. 647)
truth function (p. 640)
universal bound property (of a 
Boolean algebra) (p. 624)
Self-Test
Answer the following true-false questions.
Section 8.1
1.	In any Boolean algebra, x + x′ = 0.
2.	Set theory is an instance of a Boolean algebra in 
which +  is set union and #  is set intersection.
3.	In any Boolean algebra, x + ( y + x # z) = x + y.
4.	The dual of the equation in the previous statement 
is x # 3  y # (x + z)4 = x # y.
5.	Any two Boolean algebras with 16 elements are 
isomorphic.
Section 8.2
1.	A logic network for the Boolean expression 
(x + y)′ could be built using one AND gate and 
two inverters.
2.	The canonical sum-of-products form for a truth 
function f: 50, 16n S 50, 16 has n terms.
3.	Two single-bit binary numbers can be added using 
a network consisting of two half-adders.
4.	The following two logic networks represent the 
same truth function:
5.	The most efficient way to construct a logic net-
work for a given truth function using only NAND 
gates is to construct the logic network using AND, 
OR, and NOT gates and then replace each of these 
elements with its equivalent form in NAND gates.
	
	
Chapter 8   Review	
683
x
y

684	
Boolean Algebra and Computer Logic 
O n  t h e  C o m p u t e r
For Exercises 1–4, write a computer program that 
produces the desired output from the given input.
1.	Input: n and tables defining two binary operations 
and one unary operation on a set of n objects
	
Output: Indication of whether the structure is a 
Boolean algebra
	
Algorithm: Testing the 10 properties for all cases
2.	Input: n, tables defining a binary operation on each 
of two sets of n elements, and a table defining a 
bijection from one set to the other
	
Output: Indication of whether the function is an 
isomorphism
	
Algorithm: Testing all possible cases
Section 8.3
1.	A Karnaugh map is a device to help change a 
canonical sum-of-products form to a reduced sum-
of-products form.
2.	The 1s in a Karnaugh map correspond to the 1 
values of the truth function.
3.	When using a Karnaugh map to reduce a Boolean 
expression, the largest possible blocks should be 
determined first because they provide the greatest 
reduction.
4.	In the Quine–McCluskey procedure, terms that 
combine must have dashes in the same locations.
5.	In the Quine–McCluskey procedure, a check in 
some row of the comparison table indicates that 
the term for that row is an essential term that must 
appear in the reduced expression.
3.	Input: n and a table representing a truth function 
with n arguments
	
Output: Canonical sum-of-products Boolean ex-
pression for the truth function
4.	Input: n and a table representing a truth function 
with n arguments
	
Output: Minimal sum-of-products Boolean expres-
sion for the truth function
	
Algorithm: Using the Quine–McCluskey procedure

Chapter Objectives
After studying this chapter, you will be able to:
•	 See how algebraic structures, finite-state machines, and Turing machines are 
all models of various kinds of computation, and how formal languages attempt 
to model natural languages.
•	 Recognize certain well-known group structures.
•	 Prove some properties about groups.
•	 Understand what it means for groups to be isomorphic.
•	 Be able to construct group codes for single-error correction of binary m-tuples.
•	 Be able to decode received n-tuples for a single-error correcting perfect code.
•	 Trace the operation of a given finite-state machine on an input string.
•	 Construct finite-state machines to recognize certain sets.
•	 For a given finite-state machine, find an equivalent machine with fewer states 
if one exists.
•	 Build a circuit for a finite-state machine.
•	 Trace the operation of a given Turing machine on an input tape.
•	 Construct Turing machines to perform certain recognition or computation tasks.
•	 Understand the Church–Turing thesis and what it implies for the Turing ma-
chine as a model of computation.
•	 Be aware of the P = NP question regarding computational complexity.
•	 Given a grammar G, construct the derivation of strings in L(G).
•	 Understand the relationship between different classes of formal languages and 
different computational devices.
Your team at Babel, Inc., is writing a compiler for a new programming language, cur-
rently code-named ScrubOak after a tree outside your office window. During the first 
phase of compilation (called the lexical analysis phase) the compiler must break down 
statements into individual units called tokens. In particular, the compiler must be able 
to recognize identifiers in the language, which are strings of letters, and also recog-
nize the two keywords in the language, which are if and in.
	
Question:	
How can the compiler recognize the individual tokens in a statement?
9
Modeling Arithmetic, Computation, 
and Languages
Chapter
685

686	
Modeling Arithmetic, Computation, and Languages
686	
Modeling Arithmetic, Computation, and Languages
A mathematical structure, as discussed in Chapter 8, is a formal model intended 
to capture common properties or behavior found in different contexts. A structure 
consists of an abstract set of objects, together with operations on or relationships 
among those objects that obey certain rules. The Boolean algebra structure of 
Chapter 8 is a model of the properties and behavior common to both propositional 
logic and set theory. As a formal model, it is an abstract entity, an idea; proposi-
tional logic and set theory are two instances, or realizations, of this idea.
In this chapter we study other structures. In Section 9.1, algebraic structures 
are defined that model various types of arithmetic such as addition of integers and 
multiplication of positive real numbers. As an aside, section 9.2 looks at coding 
theory, an important application of one of these algebraic structures. This type of 
encoding (and decoding) is not about secrecy but about detecting and perhaps cor-
recting bit errors in data transmission or storage.
The “arithmetics” of Section 9.1 represent a limited form of computation, but 
we will see models of much broader forms of computation in Sections 9.3 and 9.4. 
Our initial choice for such a model, the finite-state machine, is a useful device for 
certain tasks, such as the lexical analysis task facing your team at Babel. But the 
finite-state machine is ultimately too limited to model computation in the general 
sense. For a model that captures the notion of computation in all its generality, we 
turn to the Turing machine. Using the Turing machine as a model of computation 
will reveal that some well-defined tasks are not computable at all.
Finally, Section 9.5 discusses formal grammars and languages, which were 
developed as attempts to model natural languages such as English. While less 
than completely successful in this regard, formal grammars and languages do 
serve to model many constructs in programming languages and play an important 
role in compiler theory.
	
S e c t i o n  9 .1 	 Algebraic Structures
Definitions and Examples
We begin by analyzing a simple form of arithmetic, namely the addition of in-
tegers. There is a set Z of objects (the integers) and a binary operation on those 
objects (addition). Recall from Section 4.1 that a binary operation on a set must be 
well defined (giving a unique answer whenever it is applied to any two members 
of the set) and that the set must be closed under the operation (the answer must 
be a member of the set). The notation 3Z, +4 will denote the set together with the 
binary operation on that set.
In 3Z, +4, an equation such as
2 + (3 + 5) = (2 + 3) + 5
is true. On each side of the equation the integers remain in the same order, but the 
grouping of those integers, which indicates the order in which the additions are 
performed, changes. Changing the grouping has no effect on the answer. Another 
type of equation that holds in 3Z, +4 is
2 + 3 = 3 + 2

Section 9.1   Algebraic Structures	
687
Section 9.1   Algebraic Structures	
687
Changing the order of the integers being added has no effect on the answer.
Equations such as
2 + 0 = 2
0 + 3 = 3
−125 + 0 = −125
are also true. Adding zero to any integer does not change the value of that integer.
Finally, equations such as
 2 + (−2) = 0
 5 + (−5) = 0
 −20 + 20 = 0
are true; adding the negative of an integer to the integer gives 0 as a result.
These equations represent four properties that occur so often they each have 
a name.
	
Definitions	
Properties of Binary Operations
Let S be a set and let # denote a binary operation on S. (Here # does not necessarily 
denote multiplication but simply any binary operation.)
	
1.	 The operation # is associative if
(4x)(4y)(4z)3x # ( y # z) = (x # y) # z4
	
Associativity allows us to write x # y # z without using parentheses because 
grouping does not matter.
	
2.	 The operation # is commutative if
(4x)(4y)(x # y = y # x)
	
3.	 3S,  #4 has an identity element if
(Ei)(4x)(x # i = i # x = x)
	
4.	 If 3S,  #4 has an identity element i, then each element in S has an inverse 
with respect to # if
(4x)(Ex−1)(x # x−1 = x−1 # x = i)
In the statements of the properties, the universal quantifiers range over the 
set S; if the associative property holds, the equation x # ( y # z) = (x # y) # z is true 
for any x, y, z [ S, and similarly for the commutative property. The existential 
quantifier also applies to the set S, so an identity element i, if it exists, must be an 
element of S, and an inverse element x−1, if it exists, must be an element of S. Note 
the order of the quantifiers: In the definition of an identity, the existential quanti-
fier comes first—there must be one identity element i that satisfies the equation 
x # i = i # x = x for every x in S, just like the integer 0 in 3Z, +4. In the definition 
of the inverse element, the existential quantifier comes second—for each x, there 
is an x−1, and if x is changed, then x−1 can change, just like the inverse of 2 in 
3Z, +4 is −2 and the inverse of 5 is −5. If there is no identity element, then it does 
not make sense to talk about inverse elements.

688	
Modeling Arithmetic, Computation, and Languages
	
Definitions	
Group, Commutative Group
3S, #4 is a group if S is a nonempty set and # is a binary operation on S such that
	
1.	 # is associative.
	
2.	 an identity element exists (in S ).
	
3.	 each element in S has an inverse (in S ) with respect to # .
A group in which the operation # is commutative is called a commutative 
group.
Once again, the dot in the definitions is a generic symbol representing a binary 
operation. In any specific case, the particular binary operation has to be defined. 
If the operation is addition, for example, then the + sign replaces the generic 
symbol, as in 3Z, +4. As an analogy with programming, we can think of the generic 
symbol as a formal parameter to be replaced by an actual argument—the specific 
operation—when its value becomes known. If it is clear what the binary operation 
is, we may refer to “the group S” rather than “the group 3S,  #4.”
From the discussion, it should be clear that 3Z, +4 is a commutative group, 
with an identity element of 0. The idea of a group would not be useful if there 
were not a number of other instances. (Again as an analogy with programming, 
one can think of a group as an abstract data type—a pattern—with many possible 
instances of that data type.)
	
Example 1	
Let R+ denote the positive real numbers, and let #  denote real-number multipli-
cation, which is a binary operation on R+. Then 3R+, #4 is a commutative group. 
Multiplication is associative and commutative. The positive real number 1 serves 
as an identity because
x # 1 = 1 # x = x
for every positive real number x. Every positive real number x has an inverse with 
respect to multiplication, namely the positive real number 1∙x, because
x # 1∙x = 1∙x # x = 1
■
	
Example 2	
Let M2(Z) denote the set of 2 × 2 matrices with integer entries, and let + denote 
matrix addition. Then + is a binary operation on M2(Z) (note that closure holds). 
This is a commutative group because the integers are a commutative group, so 
each corner of the matrix behaves properly. For example, matrix addition is com-
mutative because
Practice 1	 The set in Example 1 is limited to the positive real numbers. Is 3R, #4 a commutative group? 
Why or why not?

Section 9.1   Algebraic Structures	
689
 ca1,1
a1,2
a2,1
a2,2
d + cb1,1
b1,2
b2,1
b2,2
d = ca1,1 + b1,1
a1,2 + b1,2
a2,1 + b2,1
a2,2 + b2,2
d
 = cb1,1 + a1,1
b1,2 + a1,2
b2,1 + a2,1
b2,2 + a2,2
d
 = cb1,1
b1,2
b2,1
b2,2
d + ca1,1
a1,2
a2,1
a2,2
d
The matrix
c0
0
0
0d
is an identity. The matrix
c1
2
−4
5d
is an inverse of the matrix
c−1
−2
4
−5d
REMINDER
It’s important to under-
stand all this new termi-
nology. You can’t prove 
that P S Q if you don’t 
know what you’re starting 
with or where you want 
to go.
	
Example 3	
Consider 3M2(Z), #4 where # denotes matrix multiplication. Closure holds. It can be 
shown (Exercise 2) that matrix multiplication is associative. The matrix
c1
0
0
1d
serves as an identity because
c1
0
0
1d # ca
c
b
dd = ca
c
b
dd # c1
0
0
1d = ca
c
b
dd
Thus 3M2(Z), #4 is at least a monoid.	
■
Practice 2	 Prove that 3M2(Z), #4 is not a commutative monoid.
Practice 3	 Prove that 3M2(Z), #4 is not a group.
■
A structure called a monoid results from dropping the inverse property in the 
definition of a group; thus a monoid has an associative operation and an identity 
element, but in a monoid that is not also a group, at least one element has no in-
verse. A semigroup results from dropping the identity property and the inverse 
property in the definition of a group; thus a semigroup has an associative opera-
tion, but in a semigroup that is not also a monoid, no identity element exists. Many 
familiar forms of arithmetic are instances of semigroups, monoids, and groups.

690	
Modeling Arithmetic, Computation, and Languages
Although the requirements for a structure to be a semigroup are relatively 
modest, not every arithmetic structure qualifies.
Practice 4	 Prove that 3Z, −4 is not a semigroup, where −denotes integer subtraction.
■
Practice 5	 Let S be the set of noninteger rational numbers, and let # denote multiplication. Is 3S, #4  
a semigroup?
■
	
Example 4	
Each of the following is an instance of a commutative semigroup. You should be 
able to verify closure, associativity, and commutativity for each:
3N, +4, 3N, #4, 3Q, #4, 3R+, +4, 3R, +4
	
Example 5	
For any Boolean algebra 3B, +, #, ′, 0, 14, 3B, +4 and 3B, #4 are commutative 
semigroups. Therefore for any set S, 3`(S ), c4 and 3`(S ), d4 are commutative 
semigroups.
Because the requirements that must be satisfied in going from semigroup to 
monoid to group keep getting stiffer, we expect some examples to drop out, but 
those remaining should have richer and more interesting personalities.
Next we look at a selection of other examples of semigroups, monoids, and 
groups where the elements are not just simple numbers or where the operations 
are less familiar.
Practice 6	 Which of the following semigroups are monoids? Name the identities.
3N, +4, 3N, #4, 3Q, #4, 3R+, +4, 3R, +4, 3`(S ), c 4, 3`(S ), d4
■
Practice 7	 Which of the monoids from the list in Practice 6 are groups?
■
	
Example 6	
An expression of the form
anxn +  an−1xn−1 + c+  a0
where ai [ R, i = 0, 1, … , n, and n [ N is a polynomial in x with real-number 
coefficients (or a polynomial in x over R.) For each i, ai is the coefficient of xi. 

Section 9.1   Algebraic Structures	
691
If i is the largest integer greater than 0 for which ai ∙0, the polynomial is of 
degree i; if no such i exists, the polynomial is of zero degree. Terms with zero 
coefficients are generally not written. Thus, px4−2∙3x2 + 5 is a polynomial of 
degree 4, and the constant polynomial 6 is of zero degree. The set of all polynomials 
in x over R is denoted by R3x4.
We define binary operations of +  and # in R3x4 to be the familiar operations 
of polynomial addition and multiplication. For polynomials f(x) and g(x) members 
of R3x4, the products f(x) # g(x) and g(x) # f(x) are equal because the coefficients are 
real numbers, and we can use all the properties of real numbers under multiplica-
tion and addition (properties such as commutativity and associativity). Similarly, 
for f(x), g(x), and h(x) members of R3x4, ( f(x) # g(x)) # h(x) = f(x) # (g(x) # h(x)). 
The constant polynomial 1 is an identity because 1 # f(x) = f(x) # 1 = f(x) for ev-
ery f(x) [ R3x4. Thus, 3R3x4, #4 is a commutative monoid. It fails to be a group 
because only the nonzero constant polynomials have inverses. For example, there 
is no polynomial g(x) such that g(x) # x = x # g(x) = 1, so the polynomial x has no 
inverse. (Note that while x # (1∙x) = 1, 1∙x = x−1 is not a polynomial.) However, 
3R3x4, +4 is a commutative group.
Practice 8	
a.	 For f(x), g(x), h(x) [ R3x4, write the equations saying that R3x4 under + is commutative  
and ­associative.
b.	What is an identity element in 3R3x4, +4?
c.	 What is an inverse of 7x4 − 2x3 +  4 in 3R3x4, +4?
■
Polynomials play a special part in the history of group theory (the study of 
groups) because much research in group theory was prompted by the very practi-
cal problem of solving polynomial equations of the form f (x) = 0, f (x) [ R3x4. 
The quadratic formula provides an algorithm for finding solutions for every f(x) 
of degree 2, and the algorithm uses only the algebraic operations of addition, sub-
traction, multiplication, division, and taking roots. Other such algorithms exist 
for polynomials of degrees 3 and 4. One of the highlights of abstract algebra is 
the proof that no algorithm using only these operations exists for every f(x) of 
degree 5. (Notice that this statement is much stronger than simply saying that no 
algorithm has yet been found; it says to stop looking for one.)
The next example uses modular arithmetic. You may recall from Section 5.1 
(Example 15 and the subsequent discussion) that each computer has some limit 
on the size of the integers that it can store. Although we would like a computer 
to be able to exhibit the behavior of 3Z, +4, the best we can obtain is some finite 
approximation. The approximation is achieved by performing addition modulo n. 
The “answer” to the computation x + y for x, y [ Z is then either the actual value 
x + y if this value falls within the limit that can be stored or a remainder value 
obtained by doing modular arithmetic, which is equivalent to x + y under the 
equivalence relation of congruence modulo n.

692	
Modeling Arithmetic, Computation, and Languages
	
Example 7	
Let Z5 = 50, 1, 2, 3, 46 and define addition modulo 5, denoted by +5, on Z5 by 
x +5 y = r, where r is the remainder when x + y is divided by 5. In other 
words, x +5 y = (x + y) mod 5. For example, 1 +5 2 = 3 and 3 +5 4 = 2. 
Multiplication modulo 5 is defined by x #5 y = (x # y) mod5. Thus, 2 #5 3 = 1 and 
3 #5 4 = 2. Then 3Z5, +54 is a commutative group, and 3Z5, #54 is a commutative 
monoid.
Practice 9	
a.	 Complete the following tables defining +5 and #5 on Z5.
	
+5
0
1
2
3
4
0
1
3
2
3
4
	
# 5
0
1
2
3
4
0
1
2
1
3
2
4
b.	What is an identity in 3Z5, +54? In 3Z5, #54?
c.	 What is an inverse of 2 in 3Z5, +54?
d.	Which elements in 3Z5, +54 have inverses?
As we did on Z5, we can define operations of addition modulo n and mul-
tiplication modulo n on the set Zn = 50, 1, … , n −16 where n is any positive 
integer. Again 3Zn, +n4 is a commutative group and 3Zn, #n4 is a commutative 
monoid. (See Exercise 47 for the relationship between the group 3Zn, +n4 and the 
set of equivalence classes under the binary relation of congruence modulo n.)
Practice 10	
a.	 Give the table for #6 on Z6.
b.	Which elements in 3Z6, #64 have inverses?
■
Notice that when we use a table to define an operation on a finite set, it 
is easy to check for commutativity by looking for symmetry around the main 
diagonal. It is also easy to find an identity element because its row looks like 
the top of the table and its column looks like the side. And it is easy to locate 
an inverse of an element. Look along the row until you find a column where the 
identity appears; then check to see that changing the order of the elements still 
gives the identity. However, associativity (or the lack of it) is not immediately 
apparent from the table.
■

Section 9.1   Algebraic Structures	
693
The next two examples give us algebraic structures where the elements are 
functions, mappings from a domain to a codomain.
REMINDER
In the group 3Z2, +24, the 
set is 50, 16 and the op-
eration is addition modulo 
2. In the group 3Z
 n
2, +24 for 
any n, the set is all binary 
n-tuples and the operation 
is componentwise addi-
tion modulo 2.
	
Example 8	
Let Z n
2 be the set of all binary n-tuples with n ≥1. We’ll usually use a little short-
hand and write, for example, 1101 instead of (1, 1, 0, 1). Using componentwise 
addition modulo 2, +2. it’s easy to see that the addition operation is associative 
and commutative and that the n-tuple of all 0s is an identity. Each n-tuple has an 
inverse. Therefore 3Z n
2, +24 is a commutative group.
	
Example 9	
Let A be a set and consider the set S of all functions f such that f: A S A. The 
binary operation is function composition, denoted by + . Note that S is closed under
+ and that function composition is associative (see Practice 12). Thus 3S, +4 is a 
semigroup, called the semigroup of transformations on A. Actually 3S, +4 is a 
monoid because the identity function iA that takes each member of A to itself has 
the property that for any f [ S,
f + iA = iA + f = f
Practice 12	 Prove that function composition on the set S just defined is associative.
■
	
Example 10	
Again let A be a set and consider the set SA of all bijections f such that f: A S A 
(permutations of A). Bijectiveness is preserved under function composition, func-
tion composition is associative, the identity function iA is a permutation, and for 
any f [ SA, the inverse function f −1 exists and is a permutation. Furthermore,
f + f −1 = f −1 + f = iA
Thus, 3SA, +4 is a group, called the group of permutations on A.
If A = 51, 2, … , n6 for some positive integer n, then SA is called the symmet-
ric group of degree n and denoted by Sn. Thus, S3, for example, is the set of all 
permutations on 51, 2, 36. There are 3! = 6 such permutations, which we name 
as follows (using the cycle notation of Section 5.4):
	
al = i	
a2 = (1, 2)	
a3 = (1, 3)
	
a4 = (2, 3)	
a5 = (1, 2, 3)	
a6 = (1, 3, 2)
Practice 11	 In the group 3Z 5
2, +24, what is
a.	 01101 +2 11011?
b.	 −10100?
■

694	
Modeling Arithmetic, Computation, and Languages
Recall that the notation (1, 2), for example, means that 1 maps to 2, 2 maps to 1, 
and unnamed elements map to themselves. The composition (1, 2) + (1, 3) is done 
from right to left, so
	
By (1, 3)	
By (1, 2)
	
1 S 3 S 3
	
2 S 2 S 1
	
3 S 1 S 2
resulting in (1, 3, 2). Thus a2 + a3 = (1, 2) + (1, 3) = (1, 3, 2) = a6.
■
Practice 13	
a.	 Complete the group table for 3S3, +4.
+
a1
a2
a3
a4
a5
a6
a1
a2
a6
a3
a4
a5
a6
b.	Is 3S3, +4 a commutative group?
3S3, +4 is our first example of a noncommutative group (although 3M2(Z), #4 was a 
noncommutative monoid).
The next example is very simple but particularly appropriate because it ap-
pears in several areas of computer science, including formal language theory and 
automata theory.
	
Example 11	
Let A be a finite set; its elements are called symbols and A itself is called an 
­alphabet. A* denotes the set of all finite-length strings, or words, over A. A* can be 
defined recursively (as in Example 6 in Chapter 3), where # denotes concatenation 
of strings:
	
a.	 The empty string l (the string with no symbols) belongs to A*.
	
b.	Any single member of A belongs to A*.
	
c.	 If x and y are strings in A*, so is x # y.
Thus, if A = 5a, b6, then abbaa, bbbbba, and a are all strings over A, and abbaa # a 
gives the string abbaaa. From the recursive definition, any string over A contains 
only a finite number of symbols. The number of symbols in a string is called its 
length. The empty string l is the only zero-length string. 

Section 9.1   Algebraic Structures	
695
Basic Results about Groups
We will now prove some basic theorems about groups. There are hundreds of 
theorems about groups and many books devoted exclusively to group theory, so 
we are barely scratching the surface here. The results we will prove follow almost 
immediately from the definitions involved.
By definition, a group 3G, #4 (or a monoid) has an identity element, and we 
have tried to be careful to refer to an identity element rather than the identity ele-
ment. However, it is legal to say the identity because there is only one. To prove 
that the identity element is unique, suppose that i1 and i2 are both identity ele-
ments. Then
i1 = i1 # i2 = i2
The empty string l should not be confused with the empty set [; even if A 
itself is [, then A* = 5l6. If A is nonempty, then whatever the size of A, A* is a 
denumerable (countably infinite) set. If A contains only one element, say A = 5a6, 
then l, a, aa, aaa, … , is an enumeration of A*. If A contains more than one ele-
ment, then a lexicographical (alphabetical) ordering can be imposed on the ele-
ments of A. An enumeration of A* is then obtained by counting the empty string 
first, then lexicographically ordering all strings of length 1 (there is a finite number 
of these), then lexicographically ordering all strings of length 2 (there is a finite 
number of these), and so forth. Note also that if A is nonempty, strings of arbitrary 
length can be found in A*.
Concatenation is a binary operation on A*, and it is associative. The empty 
string l is an identity because for any string x [ A*,
x # l = l # x = x
Therefore, 3A*, #4 is a monoid, called the free monoid generated by A.
Practice 14	 For A = 5a, b6
a.	 Is 3A*, #4 a commutative monoid?
b.	Is 3A*, #4 a group?	
REMINDER
To prove that something is 
unique …
Practice 15	 Justify the foregoing equality signs.
■
Because i1 = i2, the identity element is unique. Thus, we have proved the fol-
lowing theorem.
	
Theorem	
On the Uniqueness of the Identity in a Group
In any group (or monoid) 3G, #4, the identity element i is unique.
Each element x in a group 3G, #4 has an inverse element x−1. Therefore, G contains 
many different inverse elements, but for each x, the inverse is unique.
■

696	
Modeling Arithmetic, Computation, and Languages
	
Theorem	
On the Uniqueness of Inverses in a Group
For each x in a group 3G, #4, x−1 is unique.
Practice 16	 Prove the preceding theorem. (Hint: Assume two inverses for x, namely y and z, and let 
i be the identity. Then y = y # i = y # (x # z) = c .)
Practice 17	 Write 10 as 7 +12 3 and use the theorem on the inverse of a product to find (10)−1 in the 
group 3Z12, +124.
If x and y belong to a group 3G, #4, then x # y belongs to G and must have an 
inverse element in G. Naturally, we expect that inverse to have some connection 
with x−1 and y−1, which we know exist in G. We can show that (x # y)−1 = y−1 # x−1; 
thus the inverse of a product is the product of the inverses in reverse order.
Proof: We will show that y−1 # x−1 has the two properties required of (x # y)−1. 
Then, because inverses are unique, ( y−1 # x−1) must be (x # y)−1.
 (x # y) # ( y−1 # x−1) = x # ( y # y−1) # x−1
 = x # i # x−1
 = x # x−1
 = i
Similarly, ( y−1 # x−1) # (x # y) = i. Notice how associativity and the meaning of i 
and inverses all come into play in this proof. End of Proof.
REMINDER
If it walks like a duck …
We know that many familiar number systems such as 3Z, +4 and 3R, +4 are 
groups. We make use of group properties when we do arithmetic or algebra in 
these systems. In 3Z, +4, for example, if we see the equation x + 5 = y + 5, we 
conclude that x = y. We are making use of the right cancellation law, which, we 
will soon see, holds in any group.
	
Definition	
Cancellation Laws
A set S with a binary operation #  satisfies the right cancellation law if for 
x, y, z [ S, x # z = y # z implies x = y. It satisfies the left cancellation law if 
z # x = z # y implies x = y.
	
Theorem	
On the Inverse of a Product
For x and y members of a group 3G, #4, (x # y)−1 = y−1 # x−1.
■
■

Section 9.1   Algebraic Structures	
697
Suppose that x, y, and z are members of a group 3G, #4 and that x # z = y # z. To 
conclude that x = y, we take advantage of z−1. Thus,
x # z = y # z
implies
 (x # z) # z−1 = ( y # z) # z−1
 x # (z # z−1) = y # (z # z−1)
 x # i = y # i
 x = y
Hence, G satisfies the right cancellation law.
Practice 18	 Show that any group 3G, #4 satisfies the left cancellation law.
Practice 19	 Solve the equation x +8 3 = 1 in 3Z8, +84.
We have proved the following theorem.
	
Theorem	
On Cancellation in a Group
Any group 3G, #4 satisfies the left and right cancellation laws.
	
Theorem	
On Solving Linear Equations in a Group
Let a and b be any members of a group 3G, #4. Then the linear equations a # x = b 
and x # a = b have unique solutions in G.
	
Example 12	
We know that 3Z6, #64 is not a group. Here the equation
4 #6 2 = 1 #6 2
holds, but of course 4 ∙1.
Again, working in 3Z, +4, we would solve the equation 6 +  x = 13 by add-
ing −6 to both sides, producing a unique answer of x = (−6) + 13 = 7. The 
property of being able to solve linear equations for unique solutions holds in all 
groups. Consider the equation a # x = b in the group 3G, #4 where a and b belong 
to G and x is to be found. Then x = a−1 # b is an element of G satisfying the equa-
tion. Should x1 and x2 both be solutions to the equation ax = b, then a # x1 = a # x2 
and, by left cancellation, x1 = x2. Similarly, the unique solution to x # a = b is 
x = b # a−1.
The theorem on solving linear equations tells us something about tables for 
finite groups. As we look along row a of the group operation table, does element b 
■
■

698	
Modeling Arithmetic, Computation, and Languages
appear twice? If so, then the table says that there are two distinct ­elements x1 and 
x2 of the group such that a # x1 = b and a # x2 = b. But by the theorem on solving 
linear equations, this double occurrence cannot happen. Thus, a given element of 
a finite group appears at most once in a given row of the group table. However, 
to complete the row, each element must appear at least once. A similar result 
holds for columns. Therefore, in a group table, each element appears exactly once 
in each row and each column. This property alone, however, is not sufficient to 
insure that a table represents a group; the operation must also be associative (see 
Exercise 31).
Practice 20	 Assume that + is an associative binary operation on 51, a, b, c, d 6. Complete the fol-
lowing table to define a group with identity 1,
+
1
a
b
c
d
1
1
a
c
d
1
b
c
d
c
d
a
d
b
c
If 3G, #4 is a group where G is finite with n elements, then n is said to be the order 
of the group, denoted by 0G0. If G is an infinite set, the group is of infinite order.
Practice 21	
a.	 Name a commutative group of order 18.
b.	Name a noncommutative group of order 6.
More properties of groups appear in the exercises at the end of this section.
Subgroups
We know what groups are and we know what subsets are, so it should not be hard 
to guess what a subgroup is. However, we will look at an example before we give 
the definition. We know that 3Z, +4 is a group. Now let A be any nonempty subset 
of Z. For any x and y in A, x and y are also in Z, so x + y exists and is unique. The 
set A “inherits” a well-defined operation, +, from 3Z, +4. The associativity prop-
erty is also inherited, because for any x, y, z [ A, it is also true that x, y, z [ Z 
and the equation
(x + y) + z = x + ( y + z)
holds. Perhaps A under the inherited operation has all the structure of 3Z, +4 and 
is itself a group. Whether this is true depends on A.
■
■

Section 9.1   Algebraic Structures	
699
Suppose that A = E, the set of even integers. E is closed under addition, E 
contains 0 (the identity element), and the inverse of every even integer (its nega-
tive) is an even integer. 3E, +4 is thus a group. But suppose that A = O, the set of 
odd integers. 3O, +4 fails to be a group for several reasons. For one thing, it is not 
closed—adding two odd integers produces an even integer. (Closure depends on 
the set as well as the operation, so it is not an inherited property). For another, a 
subgroup must have an identity with respect to addition; 0 is the only integer that 
will serve, and 0 is not an odd integer.
	
Definition	
Subgroup
Let 3G, #4 be a group and A # G. Then 3A, #4 is a subgroup of 3G, #4 if 3A, #4 is 
itself a group.
For 3A, #4 to be a group, it must have an identity element, which we’ll denote 
by iA. Of course G also has an identity element, which we’ll denote by iG. It turns 
out that iA = iG, but this equation does not follow from the uniqueness of a group 
identity because the element iA, as far as we know, may not be an identity for all of 
G, and we cannot yet say that iG is an element of A. However, iA = iA # iA because 
iA is the identity for 3A, #4, and iA = iA # iG because iG is the identity for 3G, #4. Be-
cause of the left cancellation law holding in the group 3G, #4, it follows that iA = iG.
To test whether 3A, #4 is a subgroup of 3G, #4, we can assume the inherited 
properties of a well-defined operation and associativity, and we check for the three 
remaining properties required.
	
Theorem	
On Subgroups
For 3G, #4 a group with identity i and A # G, 3A, #4 is a subgroup of 3G, #4 if it 
meets the following three tests:
	
1.	 A is closed under # .
	
2.	 i [ A.
	
3.	 Every x [ A has an inverse element in A.
Practice 22	 The definition of a group requires that the set be nonempty. In the theorem on sub-
groups, why isn’t there a specific test that A ∙[?
	
Example 13	
a.	3Z, +4 is a subgroup of the group 3R, +4. Z is closed under addition, 0 [ Z, 
and the negative of every integer is an integer.
b.	 351,46, #54 is a subgroup of the group 351, 2, 3, 46, #54. Closure holds:
# 5
1
4
1
1
4
4
4
1
The identity 1 [ 51, 46, and 1−1 = 1, 4−1 = 4).
■

700	
Modeling Arithmetic, Computation, and Languages
If 3G, #4 is a group with identity i, then it is true that 35i6, #4 and 3G, #4 are sub-
groups of 3G, #4. These somewhat trivial subgroups of 3G, #4 are called improper 
subgroups. Any other subgroups of 3G, #4 are proper subgroups.
■
Practice 23	
a.	 Show that 350, 2, 4, 66, +84 is a subgroup of the group 3Z8, +84.
b.	Show that 351, 2, 46, # 74 is a subgroup of the group 351, 2, 3, 4, 5, 66, # 74.
Practice 24	 Find all the proper subgroups of S3, the symmetric group of degree 3. (You can find 
them by looking at the group table; see Practice 13.)
One point of confusing terminology: The set of all bijections on a set A into it-
self under function composition (like S3) is called the group of permutations on A, 
and any subgroup of this set (such as those in Practice 24) is called a permutation 
group. The distinction is that the group of permutations on a set A includes all bi-
jections on A into itself, but a permutation group may not. Permutation groups are 
of particular importance, not only because they were the first groups to be studied, 
but also because they are the only groups if we consider isomorphic structures to 
be the same. We will see this result shortly.
There is an interesting subgroup we can always find in the symmet-
ric group Sn for n > 1. We know that every member of Sn can be written as a 
composition of cycles, but it is also true that each cycle can be written as the 
composition of cycles of length 2, called transpositions. In S7, for example, 
(5, 1, 7, 2, 3, 6) = (5, 6) + (5, 3) + (5, 2) + (5, 7) + (5, 1). We can verify this by 
computing (5, 6) + (5, 3) + (5, 2) + (5, 7) + (5, 1). Working from right to left,
1 S 5 S 7 S 7 S 7 S 7
so 1 maps to 7. Similarly,
7 S 7 S 5 S 2 S 2 S 2
so 7 maps to 2, and so on, resulting in (5, 1, 7, 2, 3, 6). It is also true that
(5, 1, 7, 2, 3, 6) = (1, 5) + (1, 6) + (1, 3) + (1, 2) + (2, 4) + (1, 7) + (4, 2).
For any n > 1, the identity permutation i in Sn can be written as
i = (a, b) + (a, b) for any two elements a and b in the set 51, 2, … , n6. This 
equation also shows that the inverse of the transposition (a, b) in Sn is (a, b). Now 
we borrow (without proof) one more fact: Even though there are various ways to 
write a cycle as the composition of transpositions, for a given cycle the number 
of transpositions will either always be even or always be odd. Consequently, we 
classify any permutation in Sn, n > 1, as even or odd according to the number 
of transpositions in any representation of that permutation. For example, in  
S7, (5, 1, 7, 2, 3, 6) is odd. If we denote by An the set of all even permutations in  
Sn, then An determines a subgroup of 3S, +4. The composition of even permutations 
produces an even permutation, and i [ An. If a [ An, and a as a product of 
transpositions is a = a1 + a2 + c+ ak, then a−1 = ak
−1 + ak−1
−1 + c+ a1
−1. Each 
inverse of a transposition is a transposition, so a−1 is also even.
■

Section 9.1   Algebraic Structures	
701
The order of the group 3Sn, +4 (the number of elements) is n! What is the order 
of the subgroup 3A, +4? We might expect half the permutations in Sn to be even and 
half to be odd. Indeed, this is the case. If we let On denote the set of odd permuta-
tions in Sn (which is not closed under function composition), then the mapping 
f :  An S On defined by f (a) = a + (1, 2) is a bijection.
Practice 25	 Prove that f :  An S On, given by f (a) = a + (1, 2) is one-to-one and onto.
■
Because there is a bijection from An onto On, each set has the same number of 
­elements. But An d On = [ and An c On =  Sn, so 0An0 = 0Sn0∙2 = n!∙2.
	
Theorem	
On Alternating Groups
For n [ N, n > 1, the set An of even permutations determines a subgroup, called 
the alternating group, of 3Sn, +4 of order n!∙2.
We have now seen several examples of subgroups of finite groups. In Example 
13b and Practice 23, there were three such examples, and the orders of the groups 
and subgroups were
Group of order 4, subgroup of order 2
Group of order 8, subgroup of order 4
Group of order 6, subgroup of order 3
The theorem on alternating groups says that a particular group of order n! has a 
subgroup of order n!∙2.
Based on these examples, one might conclude that subgroups are always half 
the size of the parent group. This conclusion is not always true, but there is a 
relationship between the size of a group and the size of a subgroup. This relation-
ship is stated in Lagrange’s theorem, proved by the great French mathematician 
Joseph-Louis Lagrange in 1771 (we will omit the proof here).
	
Theorem	
Lagrange’s Theorem
The order of a subgroup of a finite group divides the order of the group.
Lagrange’s theorem helps us narrow down the possibilities for subgroups of 
a finite group. If 0G0 = 12, for example, we would not look for any subgroups of 
order 7 because 7 does not divide 12. Also, the fact that 6 divides 12 does not 
imply the existence of a subgroup of G of order 6. In fact, A4 is a group of order 
4!∙2 = 12, but it can be shown that A4 has no subgroups of order 6. Therefore the 
converse to Lagrange’s theorem does not always hold. In certain cases the con-
verse can be shown to be true—for example, in finite commutative groups (note 
that A4 is not commutative).
Finally, we consider subgroups of the group 3Z, +4. For n any fixed element  
of N, the set nZ is defined as the set of all integral multiples of n; nZ = 5nz 0  z [ Z6. 
Thus, for example, 3Z = 50, ± 3, ± 6, ± 9, … 6.

702	
Modeling Arithmetic, Computation, and Languages
Not only is 3nZ, +4 a subgroup of 3Z, +4 for any fixed n, but sets of the form 
nZ are the only subgroups of 3Z, +4 To illustrate, let 3S, +4 be any subgroup of 
3Z, +4. If S = 506, then S = 0Z. If S ∙506, let m be a member of S, m ∙0. 
Either m is positive or, if m is negative, −m [ S and −m is positive. The subgroup 
S, therefore, contains at least one positive integer. Let n be the smallest positive 
integer in S (which exists by the principle of well-ordering). We will now see that 
S = nZ.
First, since 0, n, and −n are members of S and S is closed under +, nZ # S. 
To obtain inclusion in the other direction, let s [ S. Now we divide the integer 
s by the integer n to get an integer quotient q and an integer remainder r with 
0 ≤r <  n. Thus, s = nq + r. Solving for r, r = s + (−nq). But nq [ S; there-
fore −nq [ S, and s [ S, so by closure of S under +, r [ S. If r is positive, we 
have a contradiction of the definition of n as the smallest positive number in S. 
Therefore, r = 0 and s = nq + r = nq. We now have S # nZ, and thus S = nZ, 
which completes the proof of the following theorem.
Practice 26	 Show that for any n [ N, 3nZ, +4 is a subgroup of 3Z, +4.
■
	
Theorem	
On Subgroups of 3Z, +4
Subgroups of the form 3nZ, +4 for n [ N are the only subgroups of 3Z, +4.
Isomorphic Groups
Suppose that 3S, #4 and 3T, +4 are isomorphic groups; what would this mean? From 
the discussion of isomorphism in Section 8.1, isomorphic structures are the same 
except for relabeling. There must be a bijection from S to T that accomplishes the 
relabeling. This bijection must also preserve the effects of the binary operation; 
that is, it must be true that “operate and map” yields the same result as “map and 
operate.” The following definition is more precise.
	
Definition	
Group Isomorphism
Let 3S, #4 and 3T, +4 be groups. A mapping f : S S T is an isomorphism from 
3S, #4 to 3T, +4 if
	
1.	 the function f is a bijection.
	
2.	 for all x, y [ S, f (x # y) = f (x) + f ( y).
Property (2) is expressed by saying that f is a homomorphism.
Practice 27	 Illustrate the homomorphism property of the definition of group isomorphism by a 
­commutative diagram.
■
If isomorphic groups are really the same except for the relabeling accom-
plished by the bijection, then we would expect that the identity of one group maps 

Section 9.1   Algebraic Structures	
703
to the identity of the other, that inverses map to inverses, and that if one group 
is commutative, so is the other. Indeed, we can prove that these expectations are 
correct. (The proofs do not make use of the one-to-one property of the isomor-
phism, so an onto homomorphism also maps the identity to the identity, inverses 
to inverses, and preserves commutativity.)
	 Suppose, then, that f is an isomorphism from the group 3S, #4 to the group 
3T, +4 and that iS and iT are the identities in the respective groups. Under the 
function f, iS maps to an element f (iS) in T. Let t be any element in T. Then, because 
f is an onto function, t = f (s) for some s [ S. It follows that
	
f (iS) + t = f (iS) + f (s)
	
 =  f (iS # s)
	
(because f is a homomorphism)
	
 = f (s)
	
(because iS is the identity in S)
	
 = t
Therefore
f (iS) + t = t
Similarly,
t + f (iS) = t
The element f (iS) acts like an identity element in 3T, +4, and because the identity 
is unique, f (iS) = iT.
Practice 28	 Prove that if f is an isomorphism from the group 3S, #4 to the group T, +4, then for any 
s [ S, f (s−1) = −f (s) (inverses map to inverses). (Hint: Show that f (s−1) acts like the 
inverse of f (s).)
■
Practice 29	 Prove that if f is an isomorphism from the commutative group 3S, #4 to the group 3T, +4, 
then 3T, +4 is a commutative group.
■
	
Example 14	
3R+, #4 and 3R, +4 are both groups. Let b be a positive real number, b ∙1, and let 
f  be the function from R+ to R defined by
f (x) = logb x
Then f is an isomorphism. To prove it, we must show that f is a bijection 
(­one-to-one and onto) and that f is a homomorphism (preserves the operation). 
We can show that f is onto: For r [ R, br [ R+ and f (br ) = logb br = r. Also, f 
is one-to-one: If f (x1) = f (x2), then logb x1 = logb x2. Let p = logb x1 = logb x2. 
Then b p = x1 and b p = x2, so x1 = x2. Finally f is a homomorphism: For 
x1, x2 [ R+, f (x1 # x2) = logb(x1 # x2) = logb x1 +  logb x2 = f (x1) + f (x2). 
Note 
that logb1 = 0, so f maps 1, the identity of 3R+, #4 to 0, the identity of 3R, +4. 

704	
Modeling Arithmetic, Computation, and Languages
Also note that
logb(1∙x) = logb1 −logb x = 0 −logb x = −logb x = −f (x)
so f maps the inverse of x in 3R+, #4 to the inverse of f (x) in 3R, +4. Finally, both 
groups are commutative.	
Because the two groups in Example 14 are isomorphic, each is the mirror 
image of the other, and each can be used to simulate a computation in the other. 
Suppose, for example, that b = 2. Then 3R, +4 can be used to simulate the com-
putation 64 # 512 in 3R+, #4. First, map from R+ to R:
 f (64) = log2 64 = 6
f (512) = log2 512 = 9
Now in 3R, +4 perform the computation
6 + 9 = 15
Finally, use f −1 to map back to R+:
f −1(15) = 215 = 32,768
(In the age bc—before calculators and computers—large numbers were multi-
plied by using tables of common logarithms, where b = 10, to convert a multipli-
cation problem to an addition problem, as addition is less prone to human error.) 
Either of two isomorphic groups can always simulate computations in the other, 
just as in Example 14.
	
Example 15	
Consider the two groups 3S, #4 and 3T, +4 as defined by the following tables:
#
2
5
9
2
9
2
5
5
2
5
9
9
5
9
2
+
0
1
4
0
0
1
4
1
1
4
0
4
4
0
1
+
1
0
4
1
4
1
0
0
1
0
4
4
0
4
1
Both are groups of order 3, so an isomorphism is certainly possible. If f is to be 
an isomorphism, it must map iS to iT. Looking at the operation tables, iS = 5 and 
iT = 0, so let f (5) = 0. As a guess, let f (2) = 1 and f (9) = 4. Now let’s reorga-
nize the 3T, +4 table:

Section 9.1   Algebraic Structures	
705
This table contains exactly the same data that were in the original T table; the rows 
and columns have just been shuffled. Written in this form, it’s clear that the T table 
is just a relabeling (using f ) of the S table, so f is indeed an isomorphism. Note that 
inverses map to inverses:
f (2−1) = f (9) = 4 and −f (2) = −1 = 4
f (9−1) = f (2) = 1 and −f (9) = −4 = 1
And we can simulate the computation 9 # 2 = 5 in S by mapping to T, applying  
the + operation, and mapping back to S:
	
 f (9) = 4, f (2) = 1
	
4 + 1 = 0
f  −1(0) = 5, which is 9 # 2
	
Example 16	
Let f:  M2(Z) S M2(Z) be given by
f  a ca
b
c
dd b = ca
c
b
dd
To show that f is one-to-one, let
f  a ca
b
c
dd b = f a c e
f
 g
hd b
Then
ca
c
b
dd = ce
g
f
hd
so a = e, c = g, b = f, and d = h, or
ca
b
c
dd = ce
f
g
hd
To show that f is onto, let
ca
b
c
dd [ M2(Z)
Then
ca
c
b
dd [ M2(Z)  and   f  a ca
c
b
dd b = ca
b
c
dd

706	
Modeling Arithmetic, Computation, and Languages
Also, f is a homomorphism from 3M2(Z), +4 to 3M2(Z), +4 because
f  a ca
b
c
dd + ce
f
g
hd b = f  a ca + e
b + f
c + g
d + hd b = ca + e
c + g
b + f
d + hd
= ca
c
b
dd + ce
g
f
hd = f  a ca
b
c
dd b + f  a ce
f
g
hd b
The function f is therefore an isomorphism from 3M2(Z), +4 to 3M2(Z), +4.
Practice 30	 Let 5Z = 55z 0  z [ Z6. Then 35Z, +4 is a group. Show that f: Z S 5Z given by f (x) = 5x 
is an isomorphism from 3Z, +4 to 35Z, +4.
■
If f is an isomorphism from 3S, #4 to 3T, +4, then f −1 exists and is a bijec-
tion. Further, f −1 is also a homomorphism, this time from T to S. To see this, let 
t1 and t2 belong to T and consider f −1(t1 +  t2). Because t1, t2 [ T and f is onto, 
t1 = f (s1) and t2 = f (s2) for some s1 and s2 in S. Thus,
f −1(t1 +  t2) = f −1( f (s1) + f (s2))
 = f −1( f (s1 # s2))
 = ( f −1 + f )(s1 # s2)
 = s1 # s2
 = f −1(t1) # f −1(t2)
Therefore we can speak of S and T as being simply isomorphic, denoted by S . T, 
without having to specify that the isomorphism is from S to T or vice versa.
Checking whether a given function is an isomorphism from S to T, as in 
­Practice 30, is not hard. Deciding whether S and T are isomorphic may be harder. 
To prove that they are isomorphic, we must produce a function. To prove that they 
are not isomorphic, we must show that no such function exists. Since we can’t try 
all possible functions, we use ideas such as the following: There is no one-to-one 
correspondence between S and T, S is commutative but T is not, and so on.
We have noted that isomorphic groups are alike except for relabeling and 
that each can be used to simulate the computations in the other. Isomorphism of 
groups is really an equivalence relation, as Practice 31 shows; thus isomorphic 
groups belong to the same equivalence class. Thinking of isomorphic groups as 
“alike except for labeling” is consistent with the idea that elements in an equiva-
lence class represent different names for the same thing.
Practice 31	
a.	 Let f: S S T be an isomorphism from the group 3S, #4 to the group 3T, +4 and g: T S U be an 
­isomorphism from 3T, +4 to the group 3U, *4. Show that g + f  is an isomorphism from S to U.
b.	 Let t be a collection of groups and define a binary relation r on t by S r T 4 S . T. Show that 
r is an equivalence relation on t.	
■

Section 9.1   Algebraic Structures	
707
We will finish this section by looking at some equivalence classes of groups 
under isomorphism. Often we pick out one member of an equivalence class and 
note that it is the typical member of that class and that all other groups in the class 
look just like it (with different names).
A result concerning the nature of very small groups follows immediately 
from Exercise 24 at the end of this section.
	
Theorem	
On Small Groups 
Every group of order 2 is isomorphic to the group whose group table is
#
1
a
1
1
a
a
a
1
Every group of order 3 is isomorphic to the group whose group table is
#
1
a
b
1
1
a
b
a
a
b
1
b
b
1
a
Every group of order 4 is isomorphic to one of the two groups whose group 
tables are
#
1
a
b
c
1
1
a
b
c
a
a
1
c
b
b
b
c
1
a
c
c
b
a
1
#
1
a
b
c
1
1
a
b
c
a
a
b
c
1
b
b
c
1
a
c
c
1
a
b
We can also prove that any group is essentially a permutation group. Suppose 
[G, #] is a group. We want to establish an isomorphism from G to a permutation 
group; each element g of G must be associated with a permutation ag on some 
set. In fact, the set will be G itself; for any x [ G, we define ag(x) to be g # x. We 
must show that 5ag 0 g [ G6 forms a permutation group and that this permutation 
group is isomorphic to G. First we need to show that for any g [ G, ag is indeed 
a permutation on G. From the definition ag(x) = g # x, it is clear that ag:  G S G, 
but it must be shown that ag is a bijection.
Practice 32	 Show that ag as just defined is a permutation (bijection) on G.
■
Now we consider P = 5ag0 g [ G6 and show that P is a group under func-
tion composition. P is nonempty because G is nonempty, and associativity always 
holds for function composition. We must show that P is closed and has an identity 
and that each ag [ P has an inverse in P. To show closure, let ag and ah [ P. For 
any x [ G, (ag + ah)(x) = ag(ah(x)) = ag(h # x) = g # (h # x) = (g # h) # x. Thus,
ag + ah = ag #
 h and ag #
 h [ P.

708	
Modeling Arithmetic, Computation, and Languages
S e c t i o n  9 .1 	
Review
Techniques
•	 Test whether a given set and operation have the 
properties necessary to form a semigroup, monoid, 
or group structure.
•	 Test whether a given subset of a group is a ­subgroup.
•	 Test whether a given function from one group to 
another is an isomorphism.
•	 Decide whether two groups are isomorphic.
Main Ideas
•	 Many elementary arithmetic systems are instances 
of a semigroup, monoid, or group structure.
•	 In any group structure, the identity and inverse 
elements are unique, cancellation laws hold, and 
linear equations are solvable; these and other 
properties follow from the definitions involved.
•	 A subset of a group may itself be a group under the 
inherited operation.
•	 The order of a subgroup of a finite group divides 
the order of the group.
•	 The only subgroups of the group 3Z, +4 are of the 
form 3nZ, +4, where nZ is the set of all integral 
multiples of a fixed n [ N.
•	 If f is an isomorphism from one group to another, 
f maps the identity to the identity and inverses to 
inverses, and it preserves commutativity.
•	 If S and T are isomorphic groups, they are ­identical 
except for relabeling, and each simulates any 
­computation in the other.
•	 Isomorphism is an equivalence relation on groups.
•	 To within an isomorphism, there is only one group 
of order 2, one group of order 3, and two groups of 
order 4.
•	 Every group is essentially a permutation group.
Practice 33	
a.	 Let 1 denote the identity of G. Show that a1 is an identity for P under function composition.
b.	For ag [ P, ag−1 [ P; show that ag−1 = (ag)−1.	
■
We now know that 3P, +4 is a permutation group, and it only remains to show 
that the function f: G S P given by f (g) = ag is an isomorphism. Clearly, f is an 
onto function.
Practice 34	 Show that f: G S P defined by f (g) = ag is
a.	 one-to-one.
b.	a homomorphism.	
■
We have now proved the following theorem, first stated and proved by the 
English mathematician Arthur Cayley in the mid-1800s.
	
Theorem	
Cayley’s Theorem
Every group is isomorphic to a permutation group.
Exercises 9.1
	 1.	 a.	 A binary operation # is defined on the set 5a, b, c, d6 by the table on the left. Is # commutative?  
Is # associative?
	
b.	Let S = 5p, q, r, s6. An associative binary operation # is partly defined on S by the table on the right. 
Complete the table to preserve associativity. Is # commutative?
W

Section 9.1   Algebraic Structures	
709
#
a
b
c
d
a
a
c
d
a
b
b
c
a
d
c
c
a
b
d
d
d
b
a
c
#
p
q
r
s
p
p
q
r
s
q
q
r
s
p
r
p
s
s
q
r
	 2.	 Show that matrix multiplication on M2(Z) is associative.
	 3.	 Each of the following cases defines a binary operation, denoted by #, on a given set. Which are associative? 
Which are commutative?
	
a.	 On Z:  x # y = e x  if x is even
x + 1 if x is odd 
	
b.	 On N:  x # y = (x + y)2
	
c.	 On R+:  x # y = x4
	
d.	 On Q:  x # y = xy∙2
	
e.	 On R+:  x # y = 1∙(x + y)
	 4.	 Define binary operations on the set N that are
	
a.	 commutative but not associative.
	
b.	associative but not commutative.
	
c.	 neither associative nor commutative.
	
d.	both associative and commutative.
For Exercises 5–7, determine whether the structures 3S, #4 are semigroups, monoids, groups, or none of these. 
Name the identity element in any monoid or group structure.
	 5.	 a.	 S = N; x # y = min(x, y)
	
b.	 S = R; x # y = (x + y)2
	
c.	 S = 5a"2 0 a [ N6; # = multiplication
	
d.	 S = 5a + b"2 0 a, b [ Z6; # = multiplication
	
e.	 S = 5a + b"2 0 a, b [ Q, a and b not both 06; # = multiplication
	
f.	 S = 51,−1, i, −i6; # = multiplication (where i2 = −1)
	 6.	 a.	 S = 51, 2, 46; # = # 6
	
b.	 S = 51, 2, 3, 5, 6, 10, 15, 306; x # y = least common multiple of x and y
	
c.	 S = N × N; (x1, y1) # (x2, y2) = (x1, y2)
	
d.	 S = N × N; (x1, y1) # (x2, y2) = (x1 +  x2, y1y2)
	
e.	 S = set of even integers; # = addition
	
f.	 S = set of odd integers; # = addition
	 7.	 a.	 S = set of all polynomials in R3x4 of degree ≤3; # = polynomial addition
	
b.	 S = set of all polynomials in R3x4 of degree ≤3; # = polynomial multiplication
	
c.	 S = e c1
z
0
1d ` z [ Zf ; # = matrix multiplication
	
d.	 S = 51, 2, 3, 46; # = # 5 

710	
Modeling Arithmetic, Computation, and Languages
	
e.	 S = R−5−16; x # y = x + y + xy
	
f.	 S = 5 f 0   f : N S N6; # = function addition, that is, ( f + g)(x) = f (x) + g (x)
	 8.	 Let A = 51, 26.
	
a.	 Describe the elements and write the table for the semigroup of transformations on A.
	
b.	Describe the elements and write the table for the group of permutations on A.
	 9.	 Given an equilateral triangle, six permutations can be performed on the triangle that will leave its image in the 
plane unchanged. Three of these permutations are clockwise rotations in the plane of 120°, 240°, and 360° 
about the center of the triangle; these permutations are denoted R1, R2, and R3, respectively. The triangle 
can also be flipped about any of the axes 1, 2, and 3 (see the accompanying figure); these permutations are 
denoted F1, F2, and F3, respectively. During any of these permutations, the axes remain fixed in the plane. 
Composition of permutations is a binary operation on the set D3 of all six permutations. For example, 
F3 + R2 = F2. The set D3 under composition is a group, called the group of symmetries of an equilateral 
triangle. Complete the group table below for 3D3, +4. What is an identity element in 3D3, +4? What is an 
inverse element for F1? For R2?
+
R1
R2
R3
F1
F2
F3
R1
R2
R3
F1
F2
F3
F2
	 10.	The set S3, the symmetric group of degree 3, is isomorphic to D3, the group of symmetries of an equilat-
eral triangle (see Exercise 9). Find a bijection from the elements of S3 to the elements of D3 that preserves 
the operation. (Hint: R1 of D3 may be considered a permutation in S3 sending 1 to 2, 2 to 3, and 3 to 1.)
	 11.	In each case, decide whether the structure on the left is a subgroup of the group on the right. If not, why 
not? (Note that here S* denotes S −506.)
	
a.	 3Z5*, # 54; 3Z5, +54
	
b.	 3P, +4; 3R3x4, +4 where P is the set of all polynomials in x over R of degree ≥3
	
c.	 3Z*, #4; 3Q*, #4
	
d.	 3K, +4; 3R3x4, +4 where K is the set of all polynomials in x over R of degree ≤k for some fixed k
	 12.	In each case, decide whether the structure on the left is a subgroup of the group on the right. If not,  
why not?
	
a.	 3A, +4; 3S, +4 where S is the set of all bijections on N and A is the set of all bijections on N 
mapping 3 to 3
	
b.	 3Z, +4; 3M2(Z), +4
	
c.	 350, 3, 66, +84; 3Z8, +84
	
d.	 3A, +24;3Z
 5
2, +24 where A = 500000, 01111, 10101, 110106
	 13.	Find all the distinct subgroups of 3Z12, +124.
	 14.	a.	 Show that the subset
	
 al = i
	
 a3 = (1, 4) + (2, 3)
	
 a2 = (1, 2) + (3, 4)	
 a4 = (1, 3) + (2, 4)
	
	
forms a subgroup of the symmetric group S4.

Section 9.1   Algebraic Structures	
711
	
b.	Show that the subset
	
 al = i
	
 a5 = (1, 2) + (3, 4)
	
 a2 = (1, 2, 3, 4)
	
 a6 = (1, 4) + (2, 3)
	
 a3 = (1, 3) + (2, 4)	
 a7 = (2, 4)
	
 a4 = (1, 4, 3, 2)
	
 a8 = (1, 3)
	
	
forms a subgroup of the symmetric group S4.
	 15.	Find the elements of the alternating group A4.
	 16.	Let A = 5p, q, r6. Then 3A*, #4 is the free monoid generated by A.
	
a.	 What is ppqrp # qprr ?
	
b.	Let B = the set of all strings over A with an even number of q’s. Then B # A. Prove that 3B, #4 is also 
a monoid.
	 17.	In each case, decide whether the given function is a homomorphism from the group on the left to the one 
on the right. Are any of the homomorphisms also isomorphisms?
	
a.	 3Z, +4, 3Z, +4; f (x) = 2
	
b.	 3R, +4, 3R, +4; f (x) = 0x0
	
c.	 3R*, #4, 3R*, #4 (where R* denotes the set of nonzero real numbers); f (x) = 0x0
	 18.	In each case, decide whether the given function is a homomorphism from the group on the left to the one 
on the right. Are any of the homomorphisms also isomorphisms?
	
a.	 3R3x4, +4, 3R, +4; f (anxn + an−1xn−1 + c+ a1x + a0) = an + an−1 + c+ a0
	
b.	 3S3, +4, 3Z2, +24;  f (a) = e 1 if a is an even permutation
0 if a is an odd permutation
	
c.	 3Z × Z, +4 where + denotes componentwise addition, 3Z, +4; f (x, y) = x + 2y
	 19.	In each case, decide whether the given groups are isomorphic. If they are, produce an isomorphism 
function. If they are not, give a reason why they are not.
	
a.	 3Z, +4, 312Z, +4 (where 12Z = 512z 0  z [ Z6)
	
b.	 3Z5, +54, 35Z, +4
	
c.	 35Z, +4, 312Z, +4
	
d.	 3S3, +4, 3Z6, +64
	 20.	In each case, decide whether the given groups are isomorphic. If they are, produce an isomorphism func-
tion. If they are not, give a reason why they are not.
	
a.	 35a1x + a0 0
 a1, a0 [ R6, +4, 3C, +4
	
b.	 3Z6, +64, 3S6, +4
	
c.	 3Z2, +24, 3S2, +4
	
d.	 3Z3
2, +24, 3Z8, +84
	 21.	Let M2
 0(Z) be the set of all 2 × 2 matrices of the form
c1
z
0
1d
	
where z [ Z.
	
a.	 Show that 3M2
 0(Z), #4 is a group, where # denotes matrix multiplication.

712	
Modeling Arithmetic, Computation, and Languages
	
b.	Let a function f: M 2
0(Z) S Z be defined by
f a c1
z
0
1d b = z
	
	
Prove that f is an isomorphism from 3M 2
0(Z), #4 to 3Z, +4
	
c.	 Use 3Z, +4 to simulate the computation
c1
7
0
1d # c1
−3
0
1d
	
	
in 3M 2
0(Z), #4.
	
d.	Use 3M 2
0(Z), #4 to simulate the computation 2 + 3 in 3Z, +4.
	 22.	a.	 Let S = 51, −16. Show that  3S, #4 is a group where # denotes ordinary integer multiplication.
	
b.	Let f be the function from the group 3Sn , +4 to the group  3S, #4 given by
f (a) = e −1 if a is even
−1 if a is odd
	
	
Prove that f is a homomorphism.
	 23.	In any group 3G, #4, show that
	
a.	 i−1 = i
	
b.	 (x−1)−1 = x for any x [ G
	 24.	a.	 Show that any group of order 2 is commutative by constructing a group table on the set 51, a6 with 1 
as the identity.
	
b.	Show that any group of order 3 is commutative by constructing a group table on the set 51, a, b6 with 
1 as the identity. (You may assume associativity.)
	
c.	 Show that any group of order 4 is commutative by constructing a group table on the set 51, a, b, c6 with 
1 as the identity. (You may assume associativity.) There will be four such tables, but three of them are 
isomorphic because the elements have simply been relabeled from one to the other. Find these three 
groups and indicate the relabeling. Thus, there are two essentially different groups of order 4, and both 
of these are commutative.
	 25.	Let 3G, #4 be a group and let x, y [ G. Define a relation r on G by x r y  4  g # x # g−1 = y for some g [ G.
	
a.	 Prove that r is an equivalence relation on G.
	
b.	Prove that for each x [ G, 3x4 = 5x6 if and only if G is commutative.
	 26.	For x a member of a group 3G, #4, we can define xn for any positive integer n by x1 = x, x2 = x # x, and 
xn = xn−1 # x for n > 2. Prove that in a finite group 3G, #4, for each x [ G there is a positive integer k such 
that xk = i.
	 27.	Let 3S, #4 be a semigroup. An element iL [ S is a left identity element if for all x [ S, iL # x = x. An  
element iR [ S is a right identity element if for all x [ S, x # iR = x.
	
a.	 Prove that if a semigroup 3S, #4 has both a left identity element and a right identity element, then 3S, #4 
is a monoid.
	
b.	Give an example of a finite semigroup with two left identities and no right identity.
	
c.	 Give an example of a finite semigroup with two right identities and no left identity.
	
d.	Give an example of a semigroup with neither a right nor a left identity.

Section 9.1   Algebraic Structures	
713
	 28.	Let 3S, #4 be a monoid with identity i, and let x [ S. An element xL
−1 in S is a left inverse of x if xL
−1 # x = i. 
An element xR
−1 in S is a right inverse of x if x # xR
−1 = i.
	
a.	 Prove that if every element in a monoid 3S, #4 has both a left inverse and a right inverse, then 3S, #4 is a 
group.
	
b.	Let S be the set of all functions f such that f: N S N. Then S under function composition is a monoid. 
Define a function f [ S by f(x) = 2x, x [ N. Then define a function g [ S by
	
	
g (x) = e x∙2
  if x [ N, x even
1
  if x [ N, x odd
	
	
Prove that g is a left inverse for f. Also prove that f has no right inverse.
	 29.	Let 3S, #4 be a semigroup having a left identity iL (see Exercise 27) and the property that for every x [ S, 
x has a left inverse y such that y # x = iL. Prove that 3S, #4 is a group. (Hint: y also has a left inverse in S.)
	 30.	An element of a semigroup 3S, #4 is idempotent if x # x = x. Prove that a group contains exactly one 
idempotent element.
	 31.	Prove that if 3S, #4 is a semigroup in which the linear equations a # x = b and x # a = b are solvable for any 
a, b [ S, then 3S, #4 is a group. (Hint: Use Exercise 29.)
	 32.	Prove that a finite semigroup that satisfies the left and right cancellation laws is a group. (Hint: Use 
Exercise 29.)
	 33.	Prove that a group 3G, #4 is commutative if and only if (x # y)2 = x2 # y2 for each x, y [ G.
	 34.	Prove that a group 3G, #4 in which x # x = i for each x [ G is commutative.
	 35.	Let 3G, #4 be a commutative group with identity i. For a fixed positive integer k, let Bk = 5x 0  x [ G, xk = i6. 
Prove that 3Bk, #4 is a subgroup of 3G, #4.
	 36.	Let 3G, #4 be a commutative group with subgroups 3S, #4 and 3T, #4. Let ST = 5s # t 0  s [ S, t [ T6. Prove that 
3ST, #4 is a subgroup of 3G, #4.
	 37.	a.	 Let 3G, #4 be a group and let 3S, #4 and 3T, #4 be subgroups of 3G, #4. Prove that 3S d T, #4 is a subgroup 
of 3G, #4.
	
b.	Will 3S c T, #4 be a subgroup of 3G, #4? Prove or give a counterexample.
	 38.	For any group 3G, #4, the center of the group is A = 5x [ G 0  x # g = g # x for all g [ G}.
	
a.	 Prove that 3A, #4 is a subgroup of 3G, #4
	
b.	Find the center of the group of symmetries of an equilateral triangle, 3D3, +4 (see Exercise 9).
	
c.	 Prove that G is commutative if and only if G = A.
	
d.	Let x and y be members of G with x # y−1 [ A. Prove that x # y = y # x.	
	 39.	a.	 Let SA denote the group of permutations on a set A, and let a be a specific element of A. Prove that the 
set Ha of all permutations in SA that map a to a forms a subgroup of SA.
	
b.	If A has n elements, what is 0Ha0?
	 40.	a.	 Let 3G, #4 be a group and A #  G, A ∙[. Prove that 3A, #4 is a subgroup of 3G, #4 if for each 
x, y [  A, x # y−1 [  A. This subgroup test is sometimes more convenient to use than the theorem on 
subgroups.
	
b.	Use the test of part (a) to work Exercise 35.
	 41.	a.	 Let 3G, #4  be any group with identity i. For a fixed a [ G, a0 denotes i and a−n means (a
 n)−1. Let 
A = 5az
 0  z [ Z). Prove that 3A, #4  is a subgroup of G. (Hint: Use Exercise 40.)
	
b.	The group 3G, #4 is a cyclic group if for some a [ G, A = 5az0z [ Z6 is the entire group G. In this  
case, a is a generator of 3G, #4. For example, 1 is a generator of the group 3Z, +4; remember that 
the operation is addition. Thus, 10 = 0, 11 = 1, 12 = 1 + 1 = 2, 13 = 1 +  1 + 1 = 3… .; 1−1 =  
(1)−1 = −1; 1−2 = (12)−1 = −2; 1−3 =  (13)−1 = −3, … . Every integer can be written as an integral  

714	
Modeling Arithmetic, Computation, and Languages
“power” of 1, and 3Z, +4  is cyclic with generator 1. Prove that the group 3Z7, +74  is cyclic with 
generator 2.
	
c.	 Prove that 5 is also a generator of the cyclic group 3Z7, +74.
	
d.	Prove that 3 is a generator of the cyclic group 3Z4, +44.
	 42.	Let 3G, #4  be a cyclic group with generator a (see Exercise 41). Show that G is commutative.
	 43.	a.	 Let 3S, #4 be a semigroup. An isomorphism from S to S is called an automorphism on S. Let Aut(S) be 
the set of all automorphisms on S, and prove that Aut(S) is a group under function composition.
	
b.	For the group 3Z4, +44, find the set of automorphisms and show its group table under + .
	 44.	Let 3G, #4  be a commutative group with identity i. Prove that the function f: G S G given by f (x) = x−1 
is an isomorphism.
	 45.	Let f  be a homomorphism from a group G onto a group H. Show that f is an isomorphism if and only if 
the only element of G that is mapped to the identity of H is the identity of G.
	 46.	Let 3G, #4  be a group and g a fixed element of G. Define f: G S G by f(x) = g # x # g−1 for any x [ G. 
Prove that f is an isomorphism from G to G.
	 47.	a.	 Consider the equivalence relation on the integers of congruence modulo n defined in Section 5.1. If 
n = 5, there are 5 equivalence classes:
 304 = 5… , −10, −5, 0, 5, 10, …6 
 314 = 5… , −9, −4, 1, 6, 11, …6  
 324 = 5… , −8, −3, 2, 7, 12, …6  
 334 = 5… , −7, −2, 3, 8, 13, …6  
 344 = 5… , −6, −1 ,4, 9, 14, …6  
	
	
Let E5 = 5304, 314, 324, 334, 3446. An operation + is defined on E5 by
3x4 + 3y4 = 3x + y4 
	
	
For example, 324 + 344 = 32 + 44 = 364 = 314  (recall that an equivalence class can be named by any 
of its elements). Prove that 3E5, +4 is a commutative group.
	
b.	 3Z5, +54 is a commutative group with elements 50, 1, 2, 3, 46 (see Example 7). Prove that 3Z5, +54 is 
isomorphic to the group 3E5, +4.
	
c.	 Results a and b hold for any value of n. In the group E14, what is the inverse of [10]? What is the preim-
age of [21] under the isomorphism from  Z14 to E14?
	
S e c t i o n  9 . 2 	 Coding Theory
Introduction
We talked about cryptographic codes (codes for secrecy) in Chapter 5. The codes 
we will talk about in this section are designed not to keep data secret but to cope 
with degraded data. Data can degrade over time in a storage device or can be 
corrupted over space, that is, during a transmission from one site to another over 
some medium. Bits are changed from 0 to 1 or vice versa through interference 
(“noise”), hardware failures, media damage, and so forth. The goal is to be able to 
detect, perhaps even to correct, such errors.

Section 9.2   Coding Theory	
715
As an analogy, consider voice transmission over a poor-quality cell phone 
connection. The speaker says the black hat but the receiver hears the black cat. 
Because the received message makes sense and could have been the transmitted 
message, there is no way to detect that an error has occurred. An alternative is to 
encode the message to be transmitted by repeating it. Thus the code word for the 
black hat would be the black hat the black hat, and the code word for the black cat 
would be the black cat the black cat. A received message of the black hat the black 
cat would alert the receiver that an error has occurred in transmission. However, 
the received message is equally close to either of the two code words, so there is no 
way to guess the correct code word. Note that two errors could still go undetected.
Now let’s make the code word three copies of the message: the black hat the 
black hat the black hat and the black cat the black cat the black cat. A received 
message of the black hat the black cat the black hat would signal that either one or 
two errors has occurred. If we assume it to be more likely that only one error has 
occurred, we decode the message to the closest code word, the black hat the black 
hat the black hat. This process is called maximum likelihood decoding and gives 
us the correct code word for a received message where no more than one error has 
occurred. Because we can detect up to two errors and correct the effects of one 
error, we have designed a double-error detecting, single-error correcting code.
	 Here we’ve seen three ideas central to coding theory: redundancy in coding, 
maximum-likelihood decoding, and distance between code words. Redundancy 
uses additional bandwidth or storage space, and it also increases exposure to er-
rors. Yet, as we’ve seen from our little example, it also increases the capability for 
detecting and perhaps correcting such errors. You are probably familiar with the 
idea of a parity bit, where at the end of a binary string one extra bit is added so 
that the total number of 1s in the string, including the parity bit, is even (an even 
parity bit scheme). A single bit error is detectable because it would result in an odd 
number of 1s. But there’s no way to tell which bit is in error. An even number of 
errors is undetectable, and any odd number of errors is indistinguishable from a 
single error. This code is single-error detecting.
The codes we will examine are generalizations of the parity-bit code.  
A ­parity-bit code adds one bit to the end of an m-tuple message to turn it into an 
n-tuple code word where n = m + 1. Our code words will add additional bits to 
the end of an m-tuple message to create an n-tuple code word where the additional 
n −m bits are all special sorts of parity bits. These codes also rely on further 
results from group theory (indeed they are called group codes), so we need some 
additional background first.
Background: Homomorphisms and Cosets
According to the definition, for f to be an isomorphism it must be both a bijection 
and a homomorphism.
	
Example 17	
Consider the following functions from Z to Z:
f (x) = 0
 g(x) = x + 1
The function f is a homomorphism from the group 3Z, +4 to the group3Z, +4 
because f (x + y) = 0 = 0 + 0 = f (x) + f ( y). However, f is not a bijection, 

716	
Modeling Arithmetic, Computation, and Languages
so it is not an isomorphism. The function g is a bijection because g(x) = g( y) 
implies x + 1 = y + 1, or x = y, so g is one-to-one; g is also onto because for 
any z [ Z, z −1 [ Z and g(z −1) = z. But g is not a homomorphism because 
g(x + y) = (x + y) + 1 ∙(x + 1) + ( y + 1) = g(x) + g( y). Hence g is not an 
isomorphism.	
What can be said about functions from a group to a group that are homomor-
phisms but not isomorphisms? More specifically, let 3G, #4  be a group with identity 
iG, 3H, +4 be a group with identity iH, and f  be a homomorphism, f: G S H. The 
range of f, f (G), is a subset of H (remember that f might not be an onto function, so 
it isn’t necessarily true that f (G) = H ). In fact, f (G) is actually a subgroup of H. 
It is easy enough to prove the three properties needed for f (G) to be a subgroup, 
and the proof will show that f (iG) = iH and −f (x) = f (x−1) (Exercise 1). We can 
define a binary relation r on G by
x r  y 4 f (x) = f ( y)
and r  is an equivalence relation.
Practice 35	 Prove that r is an equivalence relation on G.
■
If f is a one-to-one function, x r y would mean that f (x) = f ( y) and therefore 
x = y. The equivalence classes formed by r would then be trivial, each containing 
only a single element of G. But in general, because f is not a bijection, it might not 
be a one-to-one function. Let 3iG4  be the equivalence class determined by r that 
contains the identity of G. Because f (iG) = iH, 3iG4 = 5x [ G 0 f (x) = iH6. This 
set is called the kernel of the homomorphism f.
The kernel K is a subset of G, and in addition it is a subgroup of G. We need 
to prove the three properties necessary for a subgroup:
	
1.	 K is closed: Let x and y be elements in K. Then f (x) = f ( y) = iH. And 
f (x # y) = f (x) + f ( y) = iH + iH = iH, so x # y is in K.
	
2.	 iG belongs to K: Yes, because f (iG) = iH.
	
3.	 Let x be an element in K: Then f (x) = iH. Also f (x−1) = −f (x) =  
−iH = iH so x−1 is in K.
REMINDER
Given a homomorphism f 
from 3G,  #4 to 3H, +4, the 
range f (G) is a subgroup 
of 3H, +4 and the kernel K 
is a subgroup of 3G,  #4.
	
ExaMple 18	
Let R* = R −506  and let R+ be the set of all positive real numbers. Then 
the function f defined by f (x) =  0x0 is a homomorphism from the group 3R*, #4 
to the group3R+, #4. The kernel K of f is 5x [ R* 0  f (x) = 0x0 = 16. Therefore
 K = 51, −16.
Practice 36	 The function f defined by f (x) = x #3 1 is a homomorphism from the group 3Z, +4  to the 
group 3Z3, +34. Find the kernel K.
For our discussion of cosets, we begin with a definition.
■

Section 9.2   Coding Theory	
717
	
Definition	
Coset
Let 3S, +4 be a subgroup of a group 3G, +4. Then for x [ G, sets of the form 
x + S = 5x + s 0  s [ S6 are called left cosets of S in G. Sets of the form 
S + x = 5s + x 0  s [ S6 are called right cosets of S in G.
Of course, if G is commutative, then left cosets and right cosets are identical.
	
ExamPle 19	
Let S = 50, 2, 4, 66. Then 3S, +84 is a subgroup of 3Z8,+84. The left coset 
5 +8 S = 55 +8 0, 5 +8 2, 5 +8  4, 5 +8 66 = 55, 7, 1, 36.
Practice 37	
a.	 Verify that 5 +8  S = 1 +8  S = 3 +8  S = 7 +8  S.
b.	Compute the left coset 2 +8 S. What are its other names?	
■
For 3S, +4 any subgroup of a group 3G, +4, we can define a binary relation r 
on G as follows:
x r y  4  y belongs to x + S, x’s left coset of S in G
Then x r y, which is equivalent to y belonging to x + S, means y can be written as 
x + s for some element s [ S. It turns out that r is an equivalence relation on G:
Reflexive property: x r x because x = x + iG. (Because S is a subgroup of G, the 
identity iG of G is an element of S.)
Symmetric property: if x r y then y = x + s for some s [ S. Then, because S is 
a subgroup, −s is in S and x = y + (−s), which puts x in the same coset as 
y, that is y r x.
Transitive property: if x r y and y r z then y = x + s1 for some s1 [ S and 
z = y + s2 for some s2 [ S. Therefore, z = y + s2 = (x + s1) + s2 =
x + (s1 + s2), which means z is in x’s left coset so x r z.
We have proved the following result.
	
Theorem	
On Coset Partitions
Let 3S, +4 be a subgroup of a group 3G, +4. Then the set of left cosets of S in G 
forms a partition of G. One of these cosets is iG + S = S.
This coset partition will play a key role in decoding our group codes. But first, 
we need to see how we actually create group codes.
Generating Group Codes
Suppose we know how to turn any m-bit binary message into an n-bit code word 
where m < n, and we also know how to reverse this process. There is then a set of 
n-bit code words, one for each m-bit binary string. An n-bit code word is transmit-
ted and the received message is also a binary n-tuple. Two cases can occur:

718	
Modeling Arithmetic, Computation, and Languages
1.	 The received n-tuple is identical to one of the code words. In this case, 
maximum-likelihood decoding will assume that no errors have occurred. 
This is actually based on another assumption, namely that the probability 
of errors occurring is very low, so that the probability of no errors is very 
high. Therefore the probability that a received code word is the same code 
word that was originally transmitted is more likely than that the transmit-
ted code word was scrambled into a different code word.
2.	 The received n-tuple does not match any code word. Maximum-likelihood 
decoding suggests that the received n-tuple should be decoded as the 
closest code word, as this would be the result of the fewest bit errors and 
therefore has the highest probability of giving the correct result.
Keep in mind throughout this section that maximum-likelihood decoding 
does not guarantee 100% accurate results; it guarantees only results with the high-
est probability of being accurate.
To determine the “closest” code word, we need to define what we mean by the 
distance between binary n-tuples. Hamming distance, defined here, is named for 
Richard W. Hamming, an American mathematician who pioneered the study of 
error-detecting and error-correcting codes in 1950.
	
Definition	
Hamming Distance
Let X and Y be binary n-tuples. The Hamming distance between X and Y, 
H(X, Y ), is the number of components in which X and Y differ. The minimum 
distance of a code is the minimum Hamming distance between all possible pairs 
of distinct code words.
Practice 38	 For X = 01011 and Y = 11001, what is H(X, Y )?
■
Each error that occurs in the transmission of a code word adds one unit to the 
Hamming distance between that code word and the received word. Suppose we 
picture the code words as specific binary n-tuples distinguished from the set S of 
all binary n-tuples, as in Figure 9.1. Suppose also that the minimum distance of 
the code is at least d + 1. Then any time a code word X is corrupted by d or fewer 
errors, it will be changed to an n-tuple X ′ that is not another code word, and the 
occurrence of errors can be detected. Conversely, if any combination of d or fewer 
errors can be detected, code words must be at least d + 1 apart.
d   +   1
S
Figure 9.1

Section 9.2   Coding Theory	
719
Now suppose that the minimum distance of the code is at least 2d + 1. Then 
any time a code word X is corrupted by d or fewer errors, the received word X ′ 
will be such that H(X, X ′) ≤d but for any other code word Y, H(X ′, Y) ≥d + 1. 
Therefore X ′ will be correctly decoded as X, the closest code word. Conversely, 
to correct any received word with d or fewer errors, the minimum distance of the 
code must be at least 2d + 1 so that neighborhoods of radius d around code words 
do not intersect (Figure 9.2).
S
2d   +   1
Figure 9.2
As a result, we see that a code is d-error detecting if and only if its minimum 
distance is at least d + 1, and it is d-error correcting if and only its minimum 
distance is at least 2d + 1. As one would expect, it requires a stronger condition 
to correct errors than to merely detect them.
	
Example 20	
Suppose a code has a minimum distance of 6. It can then detect any combination  
of ≤5 errors. It can correct any combination of ≤2 errors. If code words X and 
Y are such that H(X, Y ) = 6, then there will be a word X ′ produced by 4 errors 
on X that will be incorrectly decoded as Y; there will be a word X ″ produced by 3 
errors on X that can be arbitrarily decoded correctly as X or incorrectly as Y. This 
code is double-error correcting, 5-error detecting.
The set of code words will be a subset of the set of all binary n-tuples, Z n
2. 
We want these code words to be sufficiently widely scattered in Z n
2 so that the 
minimum distance is large enough to allow some error correction. The minimum 
distance of the code is easy to compute if the code words form a subgroup of the 
group 3Z n
2, +24. In this case we have a group code; the identity is the n-tuple of all 
0s (we’ll call this 0n), and each code word is its own inverse. Denote by W(X ) the 
weight of a code word X, meaning the number of 1s it contains.
	
Theorem	
On Minimum Distance of Group Code
The minimum distance of a group code equals the minimum weight of all the 
nonzero code words.
To prove this theorem, let d be the minimum distance of a group code; then 
there are two distinct code words X and Y with H(X, Y ) = d. Because it’s a group 
code, closure holds and X +2 Y = Z is a code word. Z ∙0 because X and Y are 
distinct. Z will have 1s in exactly those components where X and Y differ, so 

720	
Modeling Arithmetic, Computation, and Languages
W(Z ) = H(X, Y ) = d. Thus the minimum weight of the code is ≤d. If the mini-
mum weight is < d, let M be a nonzero code word with W(M ) the minimum 
weight. Then (remember that 0n is a code word) H(M, 0n) = W(M ) < d, which 
contradicts the fact that d is the minimum distance of the code. Therefore the 
minimum distance equals the minimum weight.
	
Example 21	
The set 500000, 01111, 10101, 110106 is a group code (you can check closure, 
identity, and inverses) in 3Z 5
2, +24. The minimum distance of the code is 3, so it is 
a single-error correcting code (3 = 2 * 1 + 1).
All well and good, but how can we produce subgroups of Z n
2 to use as code 
words, and how can we control the minimum distance of the code? Algebraic 
ideas again come to our rescue. Let H be any n × r binary matrix with r < n. If 
X [ Z n
2, we can perform the matrix multiplication X # h, where all additions are 
done modulo 2. The result of this multiplication is a binary r-tuple.
	
Example 22	
Let r = 3, n = 5, and
h = E
1
1
0
0
1
1
1
0
1
1
0
0
1
1
0
U
Then
(11101)E
1
1
0
0
1
1
1
0
1
1
0
0
1
1
0
U = (110)
We can think of multiplication by H as a mapping from the group :Z
 
 n
2, +2; to 
the group :Z
 
 r
2, +2;. Moreover, this mapping is a homomorphism (see Exercise 13 at 
the end of this section). We know that the kernel K of this homomorphism is a sub-
group of :Z
 
 n
2, +2; and it consists of all those X in Z n
2 such that X # h = 0r, the zero 
of the group :Z
 
 r
2, +2;.  We’ll take K as the set of code words. Then we can easily 
determine the minimum weight (minimum distance) of the code simply by look-
ing at H. If H has d distinct rows that add to 0r in :Z
 
 r
2, +2;, say i1, … , id, we can 
choose an X in Z n
2 having 1s exactly in the i1, … , id, components. Then X # h = 0r, 
so that X is a code word, and W(X) = d. On the other hand, if X is a code word 
with W(X) = d and X has 1’s exactly in components i1, … , id,, then the equation 
X # h = 0r forces rows i1, … , id, of H to sum to 0r. Therefore, the minimum 
weight of the code equals the minimum number of distinct rows of H that add to 0r. 
In particular, to produce a single-error correcting code, we must have minimum 
distance at least 3, so we would have to choose an H with no row consisting of all 
0s and no two rows that are alike (these would add to 0r).

Section 9.2   Coding Theory	
721
From now on, we will assume that the matrix H has the form
	
h = cb
ir
d 	
(1)
where ir is the r × r identity matrix and B is an arbitrary (n −r) × r binary 
matrix. In computing the product X # h for some X [ Z
 n
2, we multiply elements 
of X by corresponding elements of the columns of H, and then sum modulo 2. For 
each column of H, the pattern of 1s in the column determines which components 
of X contribute to the sum. If the sum is to be 0 (as is true when X # h = 0r), then 
those selected components of X must sum to 0 and therefore must consist of an 
even number of 1s. The ir portion of H has the effect that each column of H selects 
a distinct component from among the last r components of X. Each of the last r 
components of X therefore controls the even parity check for one of the r multipli-
cations that are done. A matrix H that matches Equation (1) is called a canonical 
parity-check matrix.
For X to be a code word, the first n −r components of X can be arbitrary, but 
the final r components will then be determined. The maximum number of code 
words is therefore the maximum number of ways to select binary (n −r)-tuples, 
or 2n−r. Let m = n −r. We can code all members of Z
  m
  2  in Z
  n
  2 by leaving the first 
m components alone and then choosing the last r components so that the even 
parity check works for each column of H. Such a code is called an (n, m) code. 
The first m components of a code word are the information bits, and the last r 
components are the check bits.
	
ExaMple 23	
The code words of Example 21were generated using the matrix H where
h = E
1
0
1
1
1
1
1
0
0
0
1
0
0
0
1
U
H has no row of all 0s and no two rows that are alike, but rows 1, 2, and 4 add to 
(0,0,0). Again, we see that the minimum distance of this code is 3.	
Practice 39	 For each code word X of Example 21, verify that X # h = 03, where H is given in  
Example 23.
■
	
ExaMple 24	
The matrix H of Example 23 is a canonical parity-check matrix where n = 5, r = 3, 
and m = n −r = 2. H can thus generate 2m = 22 =  4 code words. The four 
members of Z
 2
 2 are 00, 01, 10, and 11. Each can be coded as a member of Z
 5
 2 by 
keeping the first two digits and adding the appropriate check digits. To code 10, 
for instance, we have

722	
Modeling Arithmetic, Computation, and Languages
(10C1C2C3)E
1
0
1
1
1
1
1
0
0
0
1
0
0
0
1
U = (000)
Multiplication by the first column of H gives 1 # 1 + 1 # C1; therefore C1 must 
equal 1 to give the sum value of 0. Similarly C2 = 0 and C3 = 1. We encode 10 as 
10101.	
Practice 40	 Use the encoding procedure of Example 24 to code 00, 01, and 11 in Z 5
2. Compare the 
results with Example 21.
■
For a given n × r canonical parity-check matrix H, we know how to encode 
all of Z m
2 = Z n−r
2
 as a subgroup of Z
 n
 2, and we also know how to determine from H 
the minimum distance of the resulting code. Now let’s turn the problem around. 
Suppose we want to encode Z
 m
 2  for some m as, say, a single-error correcting code. 
How big will the code words have to be (what is n) or, equivalently, how many 
check bits must be added (what is r)? Once we know the dimensions of a parity-
check matrix H, how can we find a canonical H that generates the code? We know 
that to produce a single-error correcting code, H must have no row consisting 
of all 0s and no two rows that are alike. That means that in the canonical form 
h = cb
ir
d , B cannot contain the row of all 0s nor can it contain any row with a 
single 1 because this would match one of the rows in ir. The rows are r-tuples, 
so from the 2r possible r-tuples, we have to subtract those that cannot occur in B. 
B can have at most 2r−1−r rows so m, the number of rows in B, must be ≤2r−1−r. 
If m and r are such that
m = 2r−1−r
the resulting code is called a perfect code.
	
Example 25	
A (7, 4) code is a perfect code. Here n = 7, m = 4, r = n −m = 3, and 
4 = 23 −1 −3. The matrix H will be a 7 × 3 matrix of the form
c b
i3
d
where the m = 4 rows of B are all of the 3-tuples with at least two 1s.	
Practice 41	
a.	 Write an H matrix for the (7, 4) perfect code.
b.	A (7, 4) code can encode all of Z 4
2 in Z 7
2. Using your H from part (a), write the set of binary 
4-tuples that H encodes and write the code word for each one.
■

Section 9.2   Coding Theory	
723
Decoding Group Codes
Now suppose that some encoding scheme has been used to encode all members of 
Z
 m
2  in Z
 n
2. There will be 2m of these code words scattered among the 2n binary n-
tuples. These code words are known to us (remember that secrecy is not the issue 
here). When an n-tuple X is received, we have a process for decoding: we decode 
X as the closest code word in terms of Hamming distance, making the assumption 
that the fewest errors have occurred. This process is not truly an algorithm, how-
ever; there may not be a unique closest code word, and even if there is, we might 
still decode incorrectly if enough errors have occurred.
Nonetheless, let’s concentrate on how to find the closest code word(s) for a 
received word X. There is certainly a brute force approach; we can create an array 
of all 2m code words and when an X is received, we just compare X to each one 
in turn to find the closest code word. But wait—this requires storage for an expo-
nential array size as well as an exponential sequential search process. Even for a 
relatively modest m-value of 32, 232 is a very large number. But, suppose our code 
is a group code generated by an n × r canonical parity-check matrix H. Then we 
will ultimately be able to decode by searching an array of only 2r elements. In a 
single-error correcting code with m = 32, r can be as low as 6 (m ≤2r −1 −r), 
and 26 = 64 is an acceptable search array.
	 Here’s how this decoding works. Recall that the set of code words equals the 
kernel K of the homomorphism H induces from 3Z
 n
2, +24 to the group 3Z
 r
2, +24. 
We therefore know that K is a subgroup of 3Z
 n
2, +24 and we also know that the set 
of left cosets of K in 3Z
 n
2, +24 partitions the set Z
 n
2. Cosets have the form X +2 K 
where X [ Z
 n
2. Any given coset
X +2 K = 5X +2 Ci 0  Ci [ K6
K has 2m elements, so the size of each coset is 2m. Because the set of left cosets 
partitions Zn
2, a set of size 2n, there must be 2n∙2m = 2n − m = 2r distinct cosets.
When a word X is received, X belongs to the coset X +2 K. As we just noted, 
each element Ei of this coset has the form X +2 Ci where Ci is a code word. Both Ei 
and Ci are binary n-tuples, so they are each self-inverse (−Ei = Ei and − Ci = Ci). 
Therefore the equation
	
Ei = X +2 Ci	
 (2)
can be written as
	
X +2 Ei = Ci	
(3)
From (2) we can see that 1’s in Ei occur in exactly those components where 
X and Ci differ. Thus the weight of Ei equals the distance between X and Ci, 
and the closest code word to X is the one for which the corresponding Ei has 
minimum weight. To decode X, look for the element in the coset of X having 
minimum weight and, by (3), add that element to X. The result is the code word 
to which we decode X. The coset element having minimum weight is called 
the coset leader, and it may not be unique. If there are two “minimum-weight” 
elements in a given coset, one is chosen arbitrarily as the coset leader. This just 
means that no word in this particular coset can be accurately decoded because 
it has too many errors.

724	
Modeling Arithmetic, Computation, and Languages
	
Theorem	
On Syndromes and Cosets
Let H be an n × r parity-check matrix generating a group code K. Then for 
X, Y [ Z
 
 n
2, X and Y are in the same left coset of K in 3Z n
2, +24 if and only if X and 
Y have the same syndrome.
Summary: To decode a received n-tuple X, find the coset to which X belongs and 
add that coset’s leader to X.
	
Example 26	
Consider the code of Example 21. Here n = 5 and K = 500000, 01111, 10101, 
110106. Suppose the 5-tuple X = 11011 is received. Because the set of code 
words is so small, we can easily pick out the closest code word, which is 11010. 
We would decode X as 11010. (From Example 23 we know that the canonical 
matrix H for this code is 5 × 3, so r = 3. Knocking off the three check bits, the 
original information bits were 11.)
Now let’s try our decoding procedure. The elements of X’s coset are
 11011 +2 00000 = 11011
 11011 +2 01111 = 10100
 11011 +2 10101 = 01110
 11011 +2 11010 = 00001
The coset leader (the element of minimum weight in this coset) is clearly 00001.
Adding this to X we get
11011 +2 00001 = 11010
and we decode X to 11010, as before.	
But we haven’t really solved the efficiency problem. To find all the elements 
of X’s coset requires adding all the code words to X, which still requires knowing 
all 2m code words. For a better approach, we need one new idea.
	
Definition	
Syndrome
In the group code generated by an n × r parity-check matrix H, for any X [ Z n
2, 
the r-tuple X # h is the syndrome of X.
The syndrome is useful because of the following theorem.
Proof: Suppose X and Y are in the same left coset of K in 3Z n
2, +24. Then 
Y = X +2 Ci for some Ci [ K, and Y # h = (X +2 Ci) # h = X # h +2 Ci # h (be-
cause multiplication by H is a homomorphism) = X # h +2 0r (because Ci is in 
the kernel of this homomorphism) = X # h. Therefore Y # h = X # h and X and Y 
have the same syndrome.
Now 
suppose 
that 
Y # h = X # h. 
Then 
Y # h +2 X # h = 0r, 
or  
( Y +2 X ) # h = 0r, which makes Y +2 X  a code word Ci in K. If Y +2 X = Ci, 
then Y = X +2 Ci and Y and X are in the same coset. End of proof.

Section 9.2   Coding Theory	
725
Practice 42	 Example 26 shows four members of one coset. The parity-check matrix that generated the 
code for this example is
h = E
1
0
1
1
1
1
1
0
0
0
1
0
0
0
1
U
Compute the syndrome for each member of the coset.	
■
Now suppose that we somehow have available a list of the 2r coset leaders. It 
is then easy to find which coset leader corresponds to X by making use of the fact 
from the previous theorem that X and the coset leader of X’s coset will have the 
same syndrome.
	
Example 27	
In the (5, 2) code of Example 26, n = 5, m = 2, and r = 3. The size of each coset 
is 2m = 4, and there are 2r = 8 distinct cosets. Here is a list of the coset leaders 
and their corresponding syndromes. The syndromes were computed using the ma-
trix H of Practice 42, and the coset leaders were found by brute force.
	Coset leaders	
Syndromes
	
00000	
000
	
00001	
001
	
00010	
010
	
00011	
011
	
00100	
100
	
10000	
101
	
00110	
110
	
01000	
111
A received word of 10101 is decoded by computing its syndrome: 
(10101)h = 000. The coset leader sharing this same syndrome is 00000. The 
received word is decoded as
10101 +2 00000 = 10101
The received word is a code word, so it is assumed that no errors have occurred.
A received word of 11000 is decoded by computing its syndrome: 
(11000)h = 010.The coset leader sharing this same syndrome is 00010, so the 
received word is decoded as
11000 +2 00010 = 11010
assuming that a single error has occurred.
A received word of 10011 has a syndrome of 110, so it can be decoded as
10011 +2 00110 = 10101
But because its coset leader has weight 2, we might instead generate a flag noting that 
at least two errors have occurred and that decoding cannot be done with certainty.	

726	
Modeling Arithmetic, Computation, and Languages
At this point we have traded one difficulty for another, namely, How do we 
find the list of 2r coset leaders? This isn’t always easy to do. In Example 27, the 
“brute force” involved writing all 2n = 32 binary 5-tuples, computing the 32 syn-
dromes to group the 5-tuples into 8 cosets, and then reviewing the 4 members of 
each coset to find the coset leader. In two cosets, there was a tie for coset leader, 
and one value was picked arbitrarily in each case.
But—if the code is a perfect single-error correcting code, then the coset lead-
ers are easy to find. Recall that in a perfect code, m = 2r −1 −r, and because 
r = n −m, it is also true that n = 2r −1. The n rows of the matrix H are r-tuples 
that are the binary representations of the numbers 1, 2, … , 2r −1 (there’s no 0r 
row in H). The code word 0n is the coset leader corresponding to the syndrome 0r. 
Any other syndrome is a binary r-tuple representing a digit d, 1 ≤d ≤2r −1. 
The value d is also represented by a row of H, say, row q. The coset leader for this 
syndrome is the binary n-tuple with a 1 in component q and 0s elsewhere. In this 
case there is no ambiguity about the coset leader, and every received word is at 
most distance 1 from a code word.
	
ExaMple 28	
A (7, 4) code is a perfect code for which r = 3. One matrix generating such a  
code is
h = G
1
1
0
1
0
1
0
1
1
1
1
1
1
0
0
0
1
0
0
0
1
W
Given the syndrome 101, the row of H that represents this binary number is  
row 2. The coset leader for this syndrome is therefore 0100000 (a 1 in component 2, 
0s elsewhere). You can check that (0100000)h = 101. The table of coset leaders 
and the corresponding syndromes is partially filled in here.
	Coset leaders	
Syndromes
	
0000000	
000
	
	
001
	
	
010
	
	
011
	
	
100
	
0100000	
101
	
	
110
	
	
111
A received word of 1001100 has a syndrome of (1001100)h = 101, so it is de-
coded as
1001100 +2 0100000 = 1101100

Section 9.2   Coding Theory	
727
S e c t i o n  9 . 2 	
Review
Techniques
•	 Find the kernel of a given homomorphism from a 
group 3G, #4 to a group 3H, +4.
•	 Given a canonical n × r parity-check matrix H, 
write the set of binary m-tuples that H encodes and 
write the code word for each one.
•	 Given m such that Z m
2  is to be encoded as a single-
error correcting code, find a canonical parity-check 
matrix to generate the code.
•	 Given a canonical n × r parity-check matrix H for a 
perfect code, be able to decode a received n-tuple by 
computing its syndrome and finding its coset leader.
Main Ideas
•	 If f is a homomorphism from a group 3G, #4 to a 
group 3H, +4, then f (G) is a subgroup of 3H, +4 
and the kernel K (the set of all elements in G map-
ping to iH) is a subgroup of 3G, #4.
•	 If 3S, +4 is a subgroup of the group 3G, +4, then 
the set of left cosets of S in G forms a partition of G.
•	 The error-detecting and error-correcting capabili-
ties of a binary code are functions of the minimum 
distance of the code.
•	 In a group code, the minimum distance is the mini-
mum weight of the nonzero code words.
•	 A parity-check matrix H can be used to generate a 
group code, in which case the minimum distance of 
the code can be determined from H.
•	 A canonical n × r parity-check matrix provides an 
easy procedure to encode Zm
2  in Zn
2 where m = n −r.
•	 For a group code generated by an n × r parity-
check matrix H, each word X in Zn
2 is decoded 
by using its syndrome to locate the coset in Zn
2 to 
which X belongs and adding the coset leader to X. 
If the code is a perfect code, the coset leader can be 
determined from H.
W
W
Exercises 9.2
	 1.	 Let f be a homomorphism from a group 3G,#4 to a group 3H, +4. Prove that 3 f (G), +4 is a subgroup of 
3H, +4.
	 2.	 Let f be a homorphism from the group 3Z, +4 to the group 3Z, +4 given by f (x) = 2x.
	
a.	 Verify that f is a homorphism.
	
b.	Is f an isomorphism? Prove or disprove.
	
c.	 What is the subgroup 3   f (Z), +4 of 3Z, +4?
	 3.	 The function f defined by f (x) = x #8 2 is a homomorphism from 3Z, +4 to 3Z8, +84. Find the ­kernel K.
	 4.	 The function f defined by f (x) = x #8 4 is a homomorphism from 3Z12, +124to 3Z8, +84. Find the kernel K.
	 5.	 A function f: Z × Z S Z is defined by f (x, y) = x + y.
	
a.	 Prove that f is a homomorphism from the group 3Z × Z, +4 (where + means componentwise addi-
tion) to the group 3Z, +4.
	
b.	Find the kernel K.
	 6.	 Let F be the set of all functions f: R S R. For f, g [ F, let f + g be defined as follows: For 
x [ R, (  f + g)(x) = f (x) + g(x).
	
a.	 Prove that 3F, +4 is a group.
	
b.	Let a [ R. Define a function a: F S F by a(   f   ) = f (a). Prove that a is a homorphism from 3F, +4 to 
3R, +4.
	
c.	 Find the kernel K.
	 7.	 Let S = 50, 4, 86. Then 3S, +124 is a subgroup of 3Z12, +124. Find the members of the left coset 7 +12  S.
	 8.	 Let S = 5i,(2, 3)6. Then 3S, +4 is a subgroup of the symmetric group 3S3, +4. Find the members of the left 
coset (1, 2, 3) + S and the right coset S + (1, 2, 3). Explain this result.

728	
Modeling Arithmetic, Computation, and Languages
	 9.	 Consider the canonical parity-check matrix
h = F
1
1
1
0
1
1
1
0
1
1
0
0
0
1
0
0
0
1
V
	
a.	 Prove that the code generated by H is single-
error correcting.
	
b.	Write the set of binary m-tuples H encodes 
and write the code word for each one.
	 10.	Consider the canonical parity-check matrix
h = I
1
1
0
1
0
1
1
1
0
1
0
1
1
0
0
1
1
1
0
0
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
Y
	
a.	 Prove that the code generated by H is single-
error correcting.
	
b.	Write the set of binary m-tuples H encodes 
and write the code word for each one.
	 11.	Give an example of a canonical parity-check matrix that will generate a single-error correcting code for 
the set of words in Z 6
2.
	 12.	Give a canonical parity-check matrix for a single-error correcting (15, 11) code.
	 13.	Let H be an n × r binary matrix mapping :Z n
2, +2; to :Z r
2, +2; by the operation X # h for X in Z n
2. Prove 
that this function is a ­homomorphism by showing that for X, Y in Z n
2, (X +2Y ) # h = X # h +2 Y # h.
	 14.	Which of the following are perfect codes? Which are single-error correcting?
	
a.	 (5, 3)	
b.	(12, 7)	
c.	(15, 11)
	 15.	Complete the coset leader/syndrome table of Example 28.
	 16.	Use your table from Exercise 15 and the matrix H from Example 28 to decode the following received 
words.
	
a.	 1010011	
b.	0001110	
c.	0101101
For Exercises 17 and 18, use a canonical parity-check matrix for the (15, 11) perfect code (see Exercise 12) to 
decode the given received words. (Hint: Because this is a perfect code, you do not need to generate the entire 
coset leader/syndrome table to solve these ­problems.)
	 17.	011000010111001	
18.	110111001010011
	
S e c t i o n  9 . 3 	 Finite-State Machines
The algebraic structures of Section 9.1 served as models for various simple arithmetic 
systems. However, we would surely agree that computation should go beyond mere 
arithmetic. We would like a model that captures the general nature of computation. 
Perhaps looking at a simplified version of a modern digital computer would be a start.
A computer stores information internally in binary form. At any instant, the 
computer contains certain information, so its internal storage is set in certain patterns 
of binary digits, which we’ll call the state of the computer at that instant. Because a 
computer contains a finite amount of storage, there is a finite (although large) num-
ber of different states that the computer can assume. An internal clock synchronizes 

Section 9.3   Finite-State Machines	
729
the actions of the computer. On a clock pulse, input can be read, which can change 
some of the storage locations and thus change the state of the machine to a new state. 
What the new state is will depend on what the input was, as well as what the previous 
state was. If these two factors are known, the change is predictable and nonrandom. 
Because the contents of certain storage cells are available as output, the state of the 
machine determines its output. In this way, over a succession of clock pulses, the 
machine produces a sequence of outputs in response to a sequence of inputs.
Definition
The finite-state machine is a model that captures the characteristics of a computer. 
As you read the definition, look for the following properties in the behavior of our 
abstract machine:
	
1.	 Operations of the machine are synchronized by discrete clock pulses.
	
2.	 The machine proceeds in a deterministic fashion; that is, its actions in 
response to a given sequence of inputs are completely predictable.
	
3.	 The machine responds to inputs.
	
4.	 There is a finite number of states that the machine can attain. At any given 
moment, the machine is in exactly one of these states. Which state it will 
be in next is a function of both the present state and the present input. The 
present state, however, depends on the previous state and input, while the 
previous state depends on its previous state and input, and so on, going all 
the way back to the initial configuration. Thus, the state of the machine at 
any moment serves as a form of memory of past inputs.
	
5.	 The machine is capable of output. The nature of the output is a function of the 
present state of the machine, meaning that it also depends on past inputs.
	
Definition	
Finite-State Machine
M = 3S, I, O, fS, fO4 is a finite-state machine if S is a finite set of states, I is a 
finite set of input symbols (the input alphabet), O is a finite set of output symbols 
(the output alphabet), and fS and fO are functions where fS:  S × I S S and 
fO:  S S O). The machine is always initialized to begin in a fixed starting state s0.
The function fS is the next-state function. It maps a (state, input) pair to a 
state. Thus, the state at clock pulse ti+1, state(ti+1), is obtained by applying the 
next-state function to the state at time ti and the input at time ti:
state(ti+1) = fS(state(ti), input(ti))
The next-state function is indeed a function, so for any (state, input) pair, 
there is a unique next state. The function fO is the output function. When fO is 
applied to a state at time ti, we get the output at time ti:
output(ti) = fO(state(ti))
Notice that the effect of applying function fO is available instantly, but the effect 
of applying function fS is not available until the next clock pulse.
Examples of Finite-State Machines
To describe a particular finite-state machine, we have to define the three sets and 
two functions involved.

730	
Modeling Arithmetic, Computation, and Languages
	
Example 29	
A finite-state machine M is described as follows: S = 5s0, s1, s26, I = 50, 16,
O = 50, 16. Because the two functions fS and fO act on finite domains, they can be 
defined by a state table, as in Table 9.1. The machine M begins in state s0, which 
has an output of 0. If the first input symbol is a 0, the next state of the machine is 
then s1, which has an output of 1.
	
Table 9.1
Present state
Next state
Output
Present input
0  	
1
s0
s1
s0
0
s1
s2
s1
1
s2
s2
s0
1
If the next input symbol is a 1, the machine stays in state s1 with an output of 1. By 
continuing this analysis, we see that an input sequence consisting of the characters 
01101 (read left to right) would produce the following effect:
Time
t0
t1
t2
t3
t4
t5
Input
0
1
1
0
1
–
State
s0
s1
s1
s1
s2
s0
Output
0
1
1
1
1
0
The initial 0 of the output string is spurious—it merely reflects the starting state, 
not the result of any input. In a similar way, the input sequence 1010 produces an 
output of 00111.
Another way to define the functions fS and fO (in fact all of M) is by a directed 
graph called a state graph. Each state of M with its corresponding output is the 
label of a node of the graph. The next-state function is given by directed arcs of 
the graph, each arc showing the input symbol(s) that produces that particular state 
change. The state graph for M appears in Figure 9.3.
	
Figure 9.3
REMINDER
Each input symbol must 
appear on one and only 
one transition arc from 
each state.

Section 9.3   Finite-State Machines	
731
Practice 43	 For the machine M of Example 29, what output sequence is produced by the input ­sequence 
11001?
Practice 44	 A machine M is given by the state graph of Figure 9.4. Give the state table for M.
	
Figure 9.4
■
■
■
The machine of Example 29 is not particularly interesting. If finite-state ma-
chines model real-world computers, they should be able to do something. Let’s try 
to build a finite-state machine that will add two binary numbers. The input will 
consist of a sequence of pairs of binary digits, each of the form 00, 01, 10, or 11. 
Each pair represents one column of digits of the two numbers to be added, least 
significant digits first (so in this particular case, read the inputs column by column 
right to left). Thus to add the two numbers
011
101
the number pairs are 11, 10, and 01. The output gives the least significant digits of 
the answer first. Recall the basic facts of binary addition:
0
0
1
  1
0
1
0
  1
0
1
1
10
(Note that in the fourth addition a carry to the next column takes place.)
Practice 45	 A machine M is described by the state table shown in Table 9.2.
a.	 Draw the state graph for M. 
b.	What output corresponds to an input sequence of 2110?
	
Table 9.2
Present state
Next state
Output
Present input 
0    1    2
s0
s0  s1  s1
0
s1
s1  s0  s0
1

732	
Modeling Arithmetic, Computation, and Languages
A moment’s thought shows us that we can encounter four cases in adding the 
digits in any given column, and we will use states of the machine to represent 
these cases.
•	 The output should be 0 with no carry—state s0.
•	 The output should be 0 but with a carry to the next column—state s1.
•	 The output should be 1 with no carry—state s2.
•	 The output should be 1 with a carry to the next column—state s3.
State s0, as always, is the starting state. We have already indicated the output for 
each state, but we need to determine the next state based on the present state and 
the input. For example, suppose we are in state s1 and the input is 11. The output 
for the present state is 0, but there is a carry, so in the next column we are adding 
1 + 1 + 1, which results in an output of 1 and a carry. The next state is s3.
Practice 46	 In the binary adder under construction:
a.	 What is the next state if the present state is s2 and the input is 11?
b.	What is the next state if the present state is s3 and the input is 10?	
■
After considering all possible cases, we have the complete state graph of 
­Figure 9.5.
	
Figure 9.5
The operation of this machine in adding the two numbers 011 and 101 (read right 
to left, that is, low-order digits first) can be traced as follows:
Time
t0
t1
t2
t3
t4
Input
11
10
01
00
–
State
s0
s1
s1
s1
s2
Output
0
0
0
0
1

Section 9.3   Finite-State Machines	
733
The output (written right to left) is 1000 when we ignore the initial 0, which does 
not reflect the action of any input. Converting this arithmetic to decimal form, we 
have computed 3 + 5 = 8. Note the symmetry of this machine with respect to the 
inputs of 10 and 01, reflecting that binary addition is commutative.
Practice 47	 Compute the sum of 01110110 and 01010101 by using the binary adder machine of  
Figure 9.5.
■
Recognition
We have already noted that a given input signal may affect the behavior of a 
­finite-state machine for longer than just one clock pulse. Because of the (limited) 
memory of past inputs represented by the states of a machine, we can use these 
machines as recognizers. A machine can be built to recognize, say by producing 
an output of 1, when the input it has received matches a certain description. We 
will soon discuss more fully the capabilities of finite-state machines as recognizers. 
Here we will simply construct some examples.
	
Example 30	
When binary data are transmitted (or stored) as strings of bits, an extra bit is often 
tacked onto the end of each string as a parity bit. Under an even parity scheme, the 
parity bit (a 0 or a 1) is chosen so that the total number of 1s in the string, including 
the parity bit, is an even number. Under an odd parity scheme, the parity bit is cho-
sen so that the total number of 1s in the string is odd. When the string is received, 
its parity is checked. Assuming an even parity scheme, if the parity of the received 
string is not even, then an error has occurred in transmitting the string, and a re-
quest for retransmission can be made. A parity bit therefore serves as a simple 
single-error-detection mechanism. (Note that a parity bit does not detect errors in 2 
bits, although it does detect errors in 3 bits.) The machine described in Figure 9.6 is 
a parity check machine. When the input received through time ti contains an even 
number of 1s, then the output at time ti+1 is 1; otherwise, the output is 0.
	
Figure 9.6
	
Example 31	
Suppose we want to design a machine having an output of 1 exactly when the input 
string received to that point ends in 101. As a special case, an input sequence con-
sisting of just 101 could be handled by progressing directly from state s0 to states 
s1, s2, and s3 with outputs of 0 except for s3, which has an output of 1. This much 
of the design results in Figure 9.7a. This figure shows that we want to be in state 
s2 whenever the input has been such that one more 1 takes us to s3 (with an output 

734	
Modeling Arithmetic, Computation, and Languages
of 1); thus we should be in s2 whenever the two most recent input symbols were 
10, regardless of what came before. In particular, a string of 1010 should put us in 
s2; hence, the next-state function for s3 with an input of 0 is s2. Similarly, we can 
use s1 to “remember” that the most recent input symbol received was 1, and that a 
01 will take us to s3. In particular, 1011 should put us in s1; hence, the next-state 
function for s3 with an input of 1 is s1. The rest of the next state function can be 
determined the same way; Figure 9.7b shows the complete state graph.
	
Figure 9.7
Notice that the machine is in state s2 at the end of an input of 0110 and at the end of 
an input of 011010—in fact, at the end of any input ending in 10; yet s2 cannot dis-
tinguish between these inputs. Each state of M represents a class of indistinguishable 
input histories, s3 being the state representing all inputs ending in 101.
Practice 48	 Draw the state graph for a machine producing an output of 1 exactly when the input string 
received to that point ends in 00.
■
Now we want to see exactly what sets finite-state machines can recognize. 
Remember that recognition is possible because machine states have a limited 
memory of past inputs. Even though the machine is finite, a particular input signal 
can affect the behavior of a machine “forever.” However, not every input signal 
can do so, and some classes of inputs require remembering so much information 
that no machine can detect them.
	 To avoid writing down outputs, we will designate those states of a finite-
state machine with an output of 1 as final states and denote them in the state graph 
with a double circle. Then we can give the following formal definition of recogni-
tion, where I* denotes the set of finite-length strings over the input alphabet.
	
Definition	
Finite-State Machine Recognition
A finite-state machine M with input alphabet I recognizes a subset S of I* if M, 
beginning in state s0 and processing an input string a, ends in a final state if and 
only if a [ S.

Section 9.3   Finite-State Machines	
735
Practice 49	 Describe the sets recognized by the machines in Figure 9.8.
	
Figure 9.8
■
In Practice 49d, state s3 is a “dead” state from which there is no recovery. The 
appearance of a 0 in states s0, s1, or s2 irrevocably ruins the pattern the machine 
is able to recognize. In contrast, the machine of Example 31 (or any machine that 
recognizes strings with a certain ending) will never have a dead state because 
there is always hope that subsequent input will match the ending pattern.
Regular Sets and Kleene’s Theorem
We want a compact, symbolic way to describe sets such as those appearing in the 
answer to Practice 49. We will describe such sets by using regular expressions; 
each regular expression describes a particular set. First, we define what regular 
expressions are; then we will see how a regular expression describes a set. We as-
sume here that I is some finite set of symbols; later I will be the input alphabet for 
a finite-state machine.
	
Definition	
Regular Expressions over I
Regular expressions over I are the
	
1.	 symbol [ and the symbol l.
	
2.	 symbol i for any i [ I.
	
3.	 expressions (AB), (A ~ B), and (A)* if A and B are regular expressions.

736	
Modeling Arithmetic, Computation, and Languages
(This definition of a regular expression over I is still another example of a recursive 
definition.)
	
Definition	
Regular Set
Any set represented by a regular expression according to the following conven-
tions is a regular set:
	
1.	 [ represents the empty set.
	
2.	 l represents the set 5l6 containing the empty string.
	
3.	 i represents the set 5i6.
	
4.	 For regular expressions A and B,
	
a.	 (AB) represents the set of all elements of the form ab where a belongs 
to the set represented by A and b belongs to the set represented by B.
	
b.	(AB) represents the union of A’s set and B’s set.
	
c.	 (A)* represents the set of all concatenations of members of A’s set.
In our discussion, we will be a little sloppy and say things like “the regular set AB” 
instead of  “the set represented by the regular expression AB.” Informally, an ­element 
in AB is an item from A followed by an item from B. An element in A ~ B is a single 
item chosen from either A or B. An element in (A)*  is zero or more repetitions of ele-
ments from A. We note that l, the empty string, is a member of the set represented by 
A* for any A because it is the case of zero repetitions of elements from A. In writing 
regular expressions, we can eliminate parentheses when no ambiguity results. The 
regular expression 0* ~  10 therefore consists of l, 0, 00, 000, 0000, … , 10.
	
Example 32	
Here are some regular expressions and a description of the set each one represents.
	
a.	 1*0(01)*	
Any number (including none) of 1s, followed by a 
single 0, followed by any number (including none)  
of 01 pairs.
	
b.	 0 ~ 1*	
A single 0 or any number (including none) of 1s.
	
c.	 (0 ~ 1)*	
Any string of 0s or 1s, including l.
	
d.	 11((10)*11)*(00*)	
A nonempty string of pairs of 1s interspersed with 
any number (including none) of 10 pairs, followed by 
at least one 0. One can see how awkward this verbal 
description is and appreciate the compactness of a 
regular expression description.
Practice 50	 Which strings belong to the set described by the regular expression?
a.	 10100010; (0*10)*
b.	 011100; (0 ~ (11)*)*
c.	 000111100; ((011 ~ 1l)*(00)*)*
■
Practice 51	 Write regular expressions for the sets recognized by the machines of Practice 49.
■

Section 9.3   Finite-State Machines	
737
A regular set may be described by more than one regular expression. For 
example, the set of all strings of 0s and 1s, which we already know from Example 
32(c) to be described by (0 ~ 1)*, is also described by the regular expression 
3(0 ~ 1*)* ~ (01)*4*. We might, therefore, write the equation
(0 ~ 1)* = 3(0 ~ 1*)* ~ (01)*4*
Although we may be quite willing to accept this particular equation, it can be 
difficult to decide in general whether two regular expressions are equal, that is, 
whether they represent the same set. An efficient algorithm that will make this 
decision for any two regular expressions has not been found.
We have introduced regular sets because, as it turns out, these are exactly the 
sets finite-state machines are capable of recognizing. This result was first proved 
by the American mathematician Stephen Kleene in 1956. We state his theorem 
here without proof.
	
Theorem	
Kleene’s Theorem
Any set recognized by a finite-state machine is regular, and any regular set can be 
recognized by some finite-state machine.
Kleene’s theorem outlines the limitations as well as the capabilities of finite state 
machines—there are certainly many sets that are not regular. For example, con-
sider S = 50n1n
 0   n ≥06 where an stands for a string of n copies of a. Strings in 
S have some number of 0s followed by the same number of 1s. S is not regular. 
(Notice that 0*1* does not do the job.) By Kleene’s theorem, there is no finite-
state machine capable of recognizing S. Yet S seems like such a reasonable set, 
and surely we humans could count a string of 0s followed by 1s and see whether 
we had the same number of 1s as 0s. This lapse suggests some deficiency in our 
use of a finite-state machine as a model of computation. We will investigate this 
further in Section 9.4.
Machine Minimization
Although we have treated finite-state machines as abstractions, circuits that act like 
finite-state machines can be built from electronic devices like the logic elements of 
Section 8.2 and others. If we wish to construct a physical machine, the number of 
internal states is a factor in the cost of construction. Minimization is the process 
of finding, for a given finite-state machine M, a machine M′ with two properties:
	
1.	 If M and M′ are both begun in their respective start states and are given 
the same sequence of input symbols, they will produce identical output 
sequences.
	
2.	 M′ has, if possible, fewer states than M (if this is not possible, then M is 
already a minimal machine and cannot be further reduced).
Unreachable States
First, let’s observe that we can remove any unreachable states of M, those states 
that cannot be attained from the starting state no matter what input sequence 
­occurs.

738	
Modeling Arithmetic, Computation, and Languages
	
Example 33	
Let M be given by the state table of Table 9.3. Although the state table contains the 
same information as the state graph (Figure 9.9), the graph shows us at a glance 
that state s2 can never be reached from the starting state s0. If we simply remove 
state s2 and its associated arcs, we have the state graph of Figure 9.10 for a ma-
chine M′ with one less state than M that behaves exactly like M; that is, it gives the 
same output as M for any input string.
Table 9.3
Present state
Next state
Output
Present input
	 0	
1
s0
s1
s3
0
s1
s3
s0
0
s2
s1
s3
1
s3
s0
s1
1
   
	
Figure 9.9	
Figure 9.10
■
Because the state graph of a finite-state machine is a directed graph, it has 
an associated adjacency matrix. Warshall’s algorithm (Section 7.1) can be used to 
detect unreachable states.
Practice 52	 What state(s) is/are unreachable from s0 in the machine of Table 9.4? Try to get your an-
swer directly from the state table.
Table 9.4
Present state
Next state
Output
Present input
	
0	
1
s0
s1
s4
0
s1
s4
s1
1
s2
s2
s2
1
s3
s3
s1
0
s4
s0
s0
1

Section 9.3   Finite-State Machines	
739
Minimization Procedure
Assuming now that all unreachable states have been removed from M, we will 
continue to look for a reduced machine M′. The key to finding a reduced M′, if 
one exists, lies in the notion of equivalent states.
	
Definition	
Equivalent States 
Two states si and sj of M are equivalent if for any a [ I*, fO(si, a) = fO(sj, a), 
where I* again denotes the set of finite-length strings over the input alphabet.
In this definition of equivalent states, the definition of the output function has 
been extended to denote the sequence of output symbols obtained by repeatedly 
applying fO to a sequence a of input symbols. Thus equivalent states of a machine 
produce identical output strings for any input string.
Practice 53	 Prove that state equivalence is an equivalence relation on the states of a machine.
■
For the time being, we will postpone the problem of how to identify equivalent 
states in a given machine M. Let’s simply assume that we have somehow found 
which states are equivalent and have partitioned the states of M into the correspond-
ing equivalence classes. These classes have two properties: (1) All states in the same 
class have the same output, and (2) for each input symbol, all states in the same class 
proceed under the next-state function to states that are all in the same class.
Practice 54	 Show that properties 1 and 2 are satisfied when M is partitioned into classes of equivalent 
states.
■
We define a machine M′ whose states are the equivalence classes of M. M′ has 
the same input and output alphabet as M, and its start state is the class to which 
s0, the start state of M, belongs. The output of a class is the output symbol com-
mon to all states of M in that class (property 1). The next state of class X under 
an input symbol is that class to which all states of M in X proceed under that 
input symbol (property 2). M′ is a well-defined machine. M′ produces the same 
output strings when processing a given input string as does M. Also, the number 
of states of M′ (equivalence classes of M) will be no greater than the number of 
states of M.
The minimization problem for M thus boils down to finding the equivalent 
states of M. Perhaps we should note first that the obvious approach of directly try-
ing to satisfy the definition of equivalent states will not work. Given two states si 
and sj of M, we cannot actually compare the outputs corresponding to each pos-
sible input string. Fortunately, the problem is not as infinite as it sounds; we only 
need to identify k-equivalent states.
	
Definition	
k-Equivalent States
Two states si and sj of M are k-equivalent if for any a [ I* where a has no more 
than k symbols, fO(si, a) = fO(sj, a).

740	
Modeling Arithmetic, Computation, and Languages
It is not hard to see that k-equivalence is an equivalence relation on the states 
of M (check the reflexive, symmetric and transitive properties). It is possible to test 
two states of M for k-equivalence directly, since we can actually produce the finite 
number of input strings having no more than k symbols. However, it turns out 
that we don’t have to do this. We can begin by finding 0-equivalent states. These 
are states producing the same output for 0-length input strings, that is, states hav-
ing the same associated output symbol. Thus, we can identify the 0-equivalence 
classes directly from the description of M.
	
Example 34	
Let M be defined by the state table of Table 9.5. (Here we’ve started writing 
0, 1, 2 … for states instead of s0, s1, s2, … . ) The 0-equivalence classes of the 
states of M are
50, 2, 56 and 51, 3, 4, 66
Table 9.5
Present state
Next state
Output
Present input
	
0	
1
0
2
3
0
1
3
2
1
2
0
4
0
3
1
5
1
4
6
5
1
5
2
0
0
6
4
0
1
Our procedure to find k-equivalent states is a recursive one; we know how to 
find 0-equivalent states, and we will show how to find k-equivalent states once we 
have identified states that are (k −1)-equivalent. Suppose, then, that we already 
know which states are (k −1)-equivalent. If states si and sj are k-equivalent, they 
must produce the same output strings for any input string of length k or less, 
which includes any string of length k −1 or less. Thus, si and sj must at least be  
(k −1)-equivalent. But they also must produce the same output strings for any 
k-length input string.
An arbitrary k-length input string consists of a single arbitrary input symbol 
followed by an arbitrary (k −1)-length input string. If we apply such a k-length 
string to states si and sj (which themselves have the same output symbol), the 
single input symbol moves si and sj to next states si′ and sj′; then si′ and sj′ must 
produce identical output strings for the remaining, arbitrary (k −1)-length string, 
which will surely happen if si′ and sj′ are (k −1)-equivalent. Therefore, to find k-
equivalent states, look for (k −1)-equivalent states whose next states under any 
input symbol are (k −1)-equivalent.

Section 9.3   Finite-State Machines	
741
	
Definition	
Partition Refinement 
Given two partitions p1 and p2 of a set S, p1 is a refinement of p2 if each block 
of p1 is a subset of a block of p2.
	
ExaMple 35	
Consider again the machine M of Example 34. We know the 0-equivalent states. 
To find 1-equivalent states, we look for 0-equivalent states with 0-equivalent next 
states. For example, the states 3 and 4 are 0-equivalent; under the input symbol 
0, they proceed to states 1 and 6, respectively, which are 0-equivalent states, and 
under the input symbol 1 they both proceed to 5, which of course is 0-equivalent 
to itself. Therefore, states 3 and 4 are 1-equivalent. Similarly, states 1 and 3 are 
1-equivalent and states 4 and 6 are 1-equivalent. Therefore the class 51, 3, 4, 66 of 
1-equivalent states is unchanged from the class of 0-equivalent states. But states 
0 and 5, themselves 0-equivalent, proceed under the input symbol 1 to states 3 
and 0, respectively, which are not 0-equivalent states. So states 0 and 5 are not 
1-­equivalent; the input string 1 will produce an output string of 01 from state 0 
and of 00 from state 5. States 0 and 2 are 1-equivalent. Therefore the l-equivalence 
classes for M are
50, 26, 556, 51, 3, 4, 66
To find 2-equivalent states, we look for 1-equivalent states with 1-equivalent 
next states. States 1 and 3, although 1-equivalent, proceed under input 1 to states 
2 and 5, respectively, which are not 1-equivalent states. Therefore, states 1 and 
3 are not 2-equivalent. The states 0 and 2, 1 and 6, and 3 and 4, respectively, are 
2-equivalent. The 2-equivalence classes for M are
50, 26, 556, 51, 66, 53, 46
The 3-equivalence classes for M are the same as the 2-equivalence classes.
In Example 35 each successive partition of the states of M into equiva-
lence classes is a refinement of the previous partition. This refinement will al-
ways happen; k-equivalent states must also be (k −1)-equivalent, so the blocks 
of the (k −1)-partition can only be further subdivided. However, the subdivi-
sion process cannot continue indefinitely (at worst it can go on only until each 
partition block contains only one state); there will eventually be a point where  
(k −1)-equivalent states and k-equivalent states coincide. (In Example 35, 
2-equivalent and 3-equivalent states coincide.) Once this happens, all next states for 
members of a partition block under any input symbol fall within a partition block. 
Thus, k-equivalent states are also (k + 1)-equivalent and (k + 2)-equivalent,  
and so on. Indeed, these states are equivalent.
The total procedure for finding equivalent states is to start with 0-equivalent 
states, then l-equivalent states, and so on, until the partition no longer subdivides. 
A pseudocode description of this algorithm is given. It isn’t nearly as complex as 
it looks, but it does involve checking many pairs of states, just as in Example 35.

742	
Modeling Arithmetic, Computation, and Languages
	
Agorithm	
Minimize
Minimize (finite-state machine table M)
//produces a minimized version of M
Local variable:
boolean flag    //flag for loop exit when nonequivalent states found
find 0-equivalent states of M
repeat
while untested equivalence classes remain do
select untested equivalence class
while untested state pairs in current class remain do
select untested state pair in current class
flag = false
while untried input symbols remain and not flag do
select untried input symbol
for both states in current pair, find next state 
under current input symbol
if next states not equivalent then
flag = true
end if
end while
if flag then
mark current states for different classes;
end if
end while
form new equivalence classes
end while
until set of new equivalence classes = set of old equivalence classes
end Minimize
	
Example 36	
For the machine M of Examples 34 and 35, the reduced machine M′ will have 
states
 A = 50, 26
 B = 556
 C = 51, 66
 D = 53, 46
The state table for M′ (Table 9.6) is obtained from that for M. Machine M′ ­(starting 
state A) will reproduce M’s output for any input string, but it has four states instead 
of seven.

Section 9.3   Finite-State Machines	
743
Table 9.6
Present state
Next state
Output
­Present input
0
1
A
A
D
0
B
A
A
0
C
D
A
1
D
C
B
1
	
Example 37	
We will minimize M where M is given by the state table of Table 9.7.
Table 9.7
Present state
Next state
Output
Present input
0
1
0
3
1
1
1
4
1
0
2
3
0
1
3
2
3
0
4
1
0
1
The 0-equivalence classes of M are
50, 2, 46, 51, 36
States 0 and 2 under input 1 go to states 1 and 0, which are not 0-equivalent. The 
1-equivalence classes of M are
506, 52, 46, 51, 36
No further refinement is possible. Let
A = 506
B = 52, 46
C = 51, 36
The reduced machine is shown in Table 9.8.
Table 9.8
Present state
Next state
Output
Present input
0
1
A
C
C
1
B
C
A
1
C
B
C
0

744	
Modeling Arithmetic, Computation, and Languages
Table 9.10
Present state
Next state
Output
Present input
0
1
0
1
3
1
1
2
0
0
2
1
3
0
3
2
1
0
Sequential Networks and Finite-State Machines
The output of a finite-state machine is a function of its present state, and the pres-
ent state of the machine is a function of past inputs. Thus, the states of a machine 
have certain memory capabilities. In the combinational networks of Chapter 8, 
which use AND gates, OR gates, and inverters, the output is virtually instanta-
neous and a function only of the present input. To build a finite-state machine we 
need one additional element that provides the memory missing from our previous 
logic networks.
A delay element is the simplest of a class of elements known as flip-flops. It 
is regulated by a clock, has a single binary input, and its output at time t + 1 is 
the input signal it received at time t. The delay element is therefore a “memory 
device” that captures input for the duration of one clock pulse. Figure 9.11 repre-
sents the delay element at time t + 1, with the signal propagating from right to 
left. When the delay element is receiving an input of d(t + 1), the output is the 
previous input d(t).
d(t)
d(t1)
Figure 9.11
Practice 55	 Minimize the machines whose state tables are shown in Tables 9.9 and 9.10.
■
Table 9.9
Present state
Next state
Output
Present input
0
1
0
2
1
1
1
2
0
1
2
4
3
0
3
2
3
1
4
0
1
0

Section 9.3   Finite-State Machines	
745
	
Example 38	
The delay element in Figure 9.12 feeds the output from the terminal AND gate of 
the network back into the initial OR gate at the next clock pulse. The initial output 
of the delay element is assumed to be 0. The input sequences x1 = 10010 and 
x2 = 11000 (read left to right) produce the effect shown in the table.
x1x2
Figure 9.12
Time
t0
t1
t2
t3
t4
x1
1
0
0
1
0
x2
1
1
0
0
0
Delay output
0
0
1
1
0
Circuit output
0
1
1
0
0
When one or more delay elements are introduced into a combinational net-
work, the network is known as a sequential network. Unlike a combinational 
network, loops (where output from a circuit becomes part of its input) are allowed, 
provided that at least one delay element is incorporated into the loop. The delay 
element prevents the confusion that results when a circuit tries to act on its current 
output. Input sequences can be run through sequential networks (hence the name) 
provided that the clock pulse synchronizes input signals as well as delay elements.
Any finite-state machine can be built using a sequential network. (We’ll 
­assume that all input and output values are binary; if not, they can be encoded 
in binary form.) The general structure of such a network is shown in Figure 9.13. 
It consists of two parts: (1) a combinational network (no delay elements) and (2) 
some loops containing all the delay elements.
To build the network for a given finite-state machine, we represent each 
machine state as a binary number, beginning with zero (0000, 0001, 0010, 
0011, 0100, and so on); the assignment of states to numbers is arbitrary. At 
any moment, each delay element in the network has a 0 or 1 signal on its 
output line, so the collection of these output signals is a binary number and 
therefore represents one of the states of the machine. As these signals feed into 
the combinational network, they represent the current state; circuits within the 
combinational network compute the next state, which is the pattern of 0s and 1s 
on the input lines to the delay elements.

746	
Modeling Arithmetic, Computation, and Languages
…
…
…
Output
Input
Combinational
network
If the finite-state machine has q states, the binary numbering of the states 
requires a certain number of bits. For example, to represent six different  
states requires 3-bit numbers ranging from 000 to 101. To represent q different 
states requires <log2 q= bits. Each bit in the binary number is the signal from a 
delay element, so the network will require <log2 q= delay elements. The essence 
of the construction is to translate the state table of the finite-state machine into 
truth functions for the outputs and delay elements, and then to construct the logic 
network for each truth function, as we did in Chapter 8.
Figure 9.13
	
ExaMple 39	
Consider the finite-state machine of Example 29, with state table as shown in  
Table 9.11.
Table 9.11
Present state
Next state
Output
Present input
0
1
s0
s1
s0
0
s1
s2
s1
1
s2
s2
s0
1
Because there are only two input symbols and two output symbols, only one input 
line x (taking on values of 0 or 1) and one output line y are needed for the network. 
There are three states, so we need <log2 3= = 2 delay elements. We arbitrarily as-
sociate states with binary numbers (see Table 9.12) represented as signals on the 
inputs or outputs of the delay elements.

Section 9.3   Finite-State Machines	
747
Table 9.12
d1
d2
s0
0
0
s1
0
1
s2
1
0
Now we use the information contained in the state table to write three truth 
functions. One truth function describes the behavior of the output y(t); it is a func-
tion of the two variables d1(t) and d2(t) representing the present state. The other 
two truth functions describe the behavior of d1(t + 1) and d2(t + 1), representing 
the next state; these are functions of x(t), d1(t), and d2(t), the present input and the 
present state. Table 9.13 shows these truth functions.
Table 9.13 
x(t)
d1(t)
d2(t)
y(t)
d1(t + 1)
d2(t + 1)
0
0
0
0
0
1
1
0
0
0
0
0
0
0
1
1
1
0
1
0
1
1
0
1
0
1
0
1
1
0
1
1
0
1
0
0
In constructing the third line of Table 9.13, for example, x(t) = 0, d1(t) = 0, 
and d2(t) = 1, meaning that the present input is 0 and the present state is s1. The 
output associated with state s1 is 1, so y(t) = 1. The next state associated with 
input 0 and present state s1 is s2, so d1(t + 1) = 1 and d2(t + 1) = 0. Notice that 
there are some don’t-care conditions for these functions because the configuration 
d1(t) = 1 and d2(t) = 1 does not occur.
The canonical sum-of-products form for each of these truth functions is
	
 y(t) = d1′d2 + d1d2′
	
( y is not a function of x)
	
d1(t + 1) = x′d1′ d2 + x′ d1d2′
	
d2(t + 1) = x′d1′d2′ + xd1′d2
Using a Karnaugh map and appropriate choices for the don’t-care conditions, these 
expressions can be simplified to
 y(t) = d1 + d2
d1(t + 1) = x′d1 + x′d2 = x′(d1 + d2)
d2(t + 1) = xd2 + x′d1′d2′
The logic networks for these expressions go into the “combinational network” 
box in Figure 9.13. Thus Figure 9.14 is a wiring diagram for the finite-state 
machine.

748	
Modeling Arithmetic, Computation, and Languages
x(t)
y(t)
d1(t)
d2(t)
d2(t)
d1(t)
d1(t1)
d2(t1)
d1(t1)
d2(t1)
xd2
x'd'1d'2
Figure 9.14
Practice 56	 Construct a sequential network for the parity check machine of Example 30.
■

Section 9.3   Finite-State Machines	
749
Special Interest Page
FSMs Behind the Game
Everyone is familiar with the use of storyboards in de-
signing a movie. Storyboards are sequences of illus-
trated panels that set the scene, sketch the action, and 
outline the dialogue. Thumbing rapidly through pages of 
such panels creates a “flipbook,” a primitive animation 
of the movie. So these panels, laid end-to-end, are a one-
dimensional layout of the movie.
What differentiates a video game from a movie? A 
movie (a film) is static in the sense that it always comes 
out the same way; there are no variations in the scenes or 
changes in the ending. A video game incorporates user 
interaction, and based on user input, different outcomes 
can occur at various points throughout the game. Design 
of a video game requires a two-dimensional approach.
If you freeze the video game at some point where 
it is waiting for user input, there is a certain scene on 
the screen with particular characters in place, and these 
characters may have certain attributes at this point in 
time. We can consider this to be the “state” of the game 
at the moment. User input is provided, and based on that 
input and the current state, something happens to move 
the game to a predefined new state. Sound familiar? Yes, 
this is essentially a finite-state machine. “Finite state ma-
chines are the nuts and bolts of game AI.”1
Here’s an outline, written as an English paragraph, 
of a simple video game: The user starts the game by 
Chapter 9
1AI for Game Development, David M Bourg and Glenn Seemann, O’Reilly Media, Inc., 2004, ISBN-13: 978-0-596-00555-9
Start
Level 1
Choose
level 1
Choose
level 2
Lantern
room
Lantern
Book
Find
codeword
Open treasure
chest
Slay
dragon
Plant
tree
Sword
roon
Sword
Book
room
Garden
Door 2
Door 1
Games
ends
Level 2
choosing to play at level 1 or level 2. In this simple 
game, the only entity is the user’s avatar, call it object 
A. A user who chooses level 1 sends A into a room 
where A must pick up one of three objects: a book, a 
sword, or a lantern. If the book is chosen, A enters a 
room where the book can be searched for a secret code 
word. When the code word is found, A moves on to the 
opening screen for level 2. If the sword is chosen, A en-
ters a room with a fearsome dragon. When A slays the 
dragon, A receives the book and enters the book room 
to search for the code word. If the lantern is chosen, 
A enters a room to search for a treasure chest. When 
the treasure chest is opened, it contains a sword and 
A moves on to the room with the fearsome dragon. At 
level 2, A chooses between door 1 and door 2. Choos-
ing door 1 ends the game. Choosing door 2 moves A 
into a garden, where A must find and plant a lilac tree. 
Upon planting the tree, the game ends.
A state graph for a finite-state machine to model the 
game behavior described above looks something like the 
diagram shown. 
Ultimately this design has to be translated into 
computer code. Details will vary with the program-
ming language used, of course, but in any event there 
must be a way to make multiple choices from a given 
state depending on the user action:
if (A.state = level1 and A.pick = lantern)
A.state =  LanternRoom
else if (A.state = level1 and A.pick = sword)
A.state = SwordRoom
else if (A.state = level1 and A.pick = book)
A.state = BookRoom
else if (A.state = level2 and A.pick = Door1)
A.state = GameEnds
and so forth.
In a more complex video game there 
will be many entities, and the computer code 
must go through a similar decision process 
for each one to program its correct action 
based on its current state and user input. The 
environment itself may be an entity, requir-
ing changes of background (from the lantern 
room to the sword room, for example).

750	
Modeling Arithmetic, Computation, and Languages
S e c t i o n  9 . 3 	
Review
Techniques
•	 Compute the output string for a given finite-state 
machine and a given input string.
•	 Draw a state graph from a state table and vice versa.
•	 Construct a finite-state machine to act as a recog-
nizer for a certain type of input.
•	 Find a regular expression given the description of 
a regular set.
•	 Decide whether a given string belongs to a given 
regular set.
•	 Minimize finite-state machines.
•	 Construct sequential networks for finite-state 
­machines.
Main Ideas
•	 Finite-state machines have a synchronous, deter-
ministic mode of operation and limited memory 
capabilities.
•	 The class of sets that finite-state machines can rec-
ognize is the class of all regular sets; hence, their 
recognition capabilities are limited.
•	 Unreachable states can be removed from a machine.
•	 After unreachable states have been removed from a 
machine, a minimized version of that machine can 
be found that produces the same output strings for 
all input strings.
•	 Any finite-state machine can be built using a net-
work of AND gates, OR gates, inverters, and delay 
elements.
Exercises 9.3
	 1.	 For each input sequence and machine given, compute the corresponding output sequence (starting state is 
always s0).
	
a.	 011011010	
	
b.	abccaab
W
Present state
Next state
Output
Present input
a
b
c
s0
s2
s0
s3
a
s1
s0
s2
s3
b
s2
s2
s0
s1
a
s3
s1
s2
s0
c

Section 9.3   Finite-State Machines	
751
	
	
c.	 0100110
	 2.	 a.	 For the machine described in Exercise la, find all input sequences yielding an output sequence of 
0011110.
	
b.	For the machine described in Exercise 1b, find all input sequences yielding an output sequence of 
abaaca.
	
c.	 For the machine described in Exercise 1c, what will be the output for an input sequence a1a2a3a4a5 
where ai [ 50, 16, 1 ≤i ≤5?
In Exercises 3–6, write the state table for the machine, and compute the output sequence for the given input 
sequence.
	 3.	 00110
	
	
	 5.	 01011
	
	
	 6.	 acbabc
	
	
s0/0
s2/0
s1/1
a
b
a
c
a
c
b, c
b
	 4.	 1101100
	
	

752	
Modeling Arithmetic, Computation, and Languages
In Exercises 7–10, draw the state graph for the machine, and compute the output sequence for the given input 
sequence.
	 7.	 10001
Present state
Next state
Output
Present input
0
1
s0
s0
s2
1
s1
s1
s0
0
s2
s0
s1
0
	 8.	 0011
Present state
Next state
Output
Present input
0
1
s0
s2
s3
0
s1
s0
s1
1
s2
s1
s3
0
s3
s1
s2
1
	 9.	 acbbca
Present state
Next state
Output
Present input
a
b
c
s0
s1
s1
s1
0
s1
s2
s2
s1
0
s2
s0
s2
s1
1
	 10.	21021
Present state
Next state
Output
Present input
0
1
2
s0
s3
s1
s2
1
s1
s3
s0
s1
2
s2
s2
s1
s1
0
s3
s1
s4
s0
0
s4
s1
s4
s2
2
	 11.	a.	 Construct a finite-state machine that complements each bit of the binary input string (read left to right).
	
b.	Write the output for the input sequence 01011.
	 12.	a.	 Construct a finite-state machine that will compute x + 1 where x is the input given in binary form, least 
significant digit first (in this case, read the input right to left). You could use the binary adder of Figure 
9.5 by writing 1 as 00 … 01 with the correct number of leading 0s, but that’s much too complicated.
	
b.	Write the output for x = 1101.
	 13.	a.	 Construct a finite-state machine that will compute the bitwise AND of two binary input strings.
	
b.	Write the output for the input sequence consisting of the strings 11011 and 10010 (read left to right).
	 14.	a.	 Construct a finite-state machine that will compute the bitwise OR of two binary input strings.
	
b.	Write the output for the input sequence consisting of the strings 11011 and 10010 (read left to right).
	 15.	a.	 Construct a delay machine having input and output alphabet 50, 16 that, for any input sequence ala2a3… 
produces an output sequence of 00ala2a3… .
	
b.	Explain (intuitively) why a finite-state machine cannot be built that, for any input sequence ala2a3… , 
produces the output sequence 0a10a20a3… .
	 16.	a.	 Construct a finite-state machine that will compute the 2’s complement of p where p is a binary number 
input with the least significant digit first. (See Exercise 27, Section 8.2.) (In this case, read the input 
right to left.)
	
b.	Use the machine of part (a) to find the 2’s complement of 1100 and of 1011.
	 17.	You are designing a Windows-based, event-driven program to handle customers for a small business. 
You design the user interface with three screens. The opening screen contains an exit button to quit the 
program and displays a list box of customer names. Double-clicking on one of the entries in the list box 
brings up a second screen showing complete data for that customer. This screen contains a button to get 
back to the opening screen. The opening screen also contains a button that brings up a form to enter the 
data for a new customer. Draw the state graph for a finite-state machine that describes the high-level user 
interaction with the program.

Section 9.3   Finite-State Machines	
753
	 18.	Whenever a video disk is inserted into a DVR, the machine automatically turns on and plays the disk. At 
the end of the recorded part of the disk, the machine turns off. To program the DVR, you must manually 
turn it on and then select the menu function; when you are finished, you turn the machine off, but its timer 
is set. At the appropriate time, the machine records, then at the appropriate time it turns itself completely 
off. Draw the state graph for a finite-state machine that describes the behavior of the DVR.
	 19.	You have an account at First National Usury Trust (FNUT) and a card to operate their ATM (automated 
teller machine). Once you have inserted your card, the ATM will allow you to process a transaction only 
if you enter your correct code number, which is 417. Draw the state graph for a finite-state machine de-
signed to recognize this code number. The output alphabet should have three symbols: “bingo” (correct 
code), “wait” (correct code so far), and “dead” (incorrect code). The input alphabet is 50, 1, 2, … , 96. 
To simplify notation, you may designate an arc by I−536, for example, meaning that the machine will 
take this path for an input symbol that is any digit except 3. (At FNUT, you get only one chance to enter 
the code correctly.)
	 20.	An elevator in a three-story building services floors 1, 2, and 3. Input consists of a signal to the elevator 
of an up-or-down request (U or D) together with the floor from which the signal originates. The elevator 
responds to an input signal by moving to the correct floor. For example, when the elevator is on floor 1 
and receives a D-3 signal, it moves to floor 3. Draw a state graph for a finite-state machine that describes 
the elevator behavior.
For Exercises 21–24, determine whether the given machine recognizes the given input string.
	 21.	11010
	
	
s0
s1
s2
0
0
0
1
1
1
	 22.	01110111
	
	
s0
s1
0
0
1
1
0
1
s2
	 23.	0101
	
	
s0
s1
s2
0, 1
0
0
1
1
	 24.	01101
	
	
s0
s1
s3
s2
0, 1
0
0
0
1
1
1
For Exercises 25–28, construct finite-state machines that act as recognizers for the input described by produc-
ing an output of 1 exactly when the input received to that point matches the description. The input and output 
alphabet in each case is 50, 16.

754	
Modeling Arithmetic, Computation, and Languages
	 25.	a.	 set of all strings containing an even number of 0s
	
b.	set of all strings consisting of two or more 1s followed by a 0
	
c.	 set of all strings containing two consecutive 0s and the rest 1s
	 26.	a.	 set of all strings ending with one or more 0s
	
b.	set of all strings where the number of 0s is a multiple of 3
	
c.	 set of all strings containing at least four 1s
	 27.	a.	 set of all strings containing exactly one 1
	
b.	set of all strings beginning with 000
	
c.	 set of all strings where the second input is 0 and the fourth input is 1
	 28.	a.	 set of all strings consisting entirely of any number (including none) of 01 pairs or consisting entirely of 
two 1s followed by any number (including none) of 0s
	
b.	set of all strings ending in 110 
	
c.	 set of all strings containing 00
	 29.	A paragraph of English text is to be scanned and the number of words beginning with “con” counted. 
Design a finite-state machine that will output a 1 each time such a word is encountered. The output alpha-
bet is 50, 16. The input alphabet is the 26 letters of the English alphabet, a finite number of punctuation 
symbols (period, comma, and so on), and a special character b for blank. To simplify your description, 
you may use I −5m6, for example, to denote any input symbol not equal to m.
	 30.	a.	 In many computer languages, any decimal number N must be presented in one of the following forms:
	
sd*	
sd*.d*	
d*	
d*.d*
(1)
where s denotes the sign (s [ 5+, − 6), d is a digit (d [ 50, 1, 2, … , 96), and d* denotes a string of 
digits where the string may be of any length, including length zero (the empty string). Thus, the follow-
ing would be examples of valid decimal numbers:
	
+2.74	
 −.58	
129	
 +
	
	
Design a finite-state machine that recognizes valid decimal numbers by producing an output of 1. The 
input symbols are +, −, . , and the 10 digits. To simplify notation, you may use d to denote any digit 
input symbol.
	
b.	Modify the machine of part (a) to recognize any sequence of decimal numbers as defined in part (a) 
separated by commas. For example, such a machine would recognize
+2.74,−.58,129,+
	
	
The input alphabet should be the same as for the machine of part (a) with the addition of the symbol c 
for comma.
	
c.	 Suppose a decimal number must be presented in a form similar to that for part (a) except that any deci-
mal point that appears must have at least one digit before it and after it. Write an expression similar to 
expression (1) in part (a) to describe the valid form for a decimal number. How would you modify the 
machine of part (a) to recognize such a number?
	 31.	Let M be a finite-state machine with n states. The input alphabet is 506. Show that for any input sequence 
that is long enough, the output of M must eventually be periodic. What is the maximum number of inputs 
before periodic output begins? What is the maximum length of a period?

Section 9.3   Finite-State Machines	
755
	 32.	At the beginning of the chapter, we learn:
Your team at Babel, Inc., is writing a compiler for a new programming language, currently code-named 
ScrubOak after a tree outside your office window. During the first phase of compilation (called the lexical 
analysis phase) the compiler must break down statements into individual units called tokens. In particular, 
the compiler must be able to recognize identifiers in the language, which are strings of letters, and also 
recognize the two keywords in the language, which are if and in.
How can the compiler recognize the individual tokens in a statement?
	
	 Construct a finite-state machine that operates on a stream of characters and moves into one of two final 
states representing that a complete keyword has just been processed or that a complete nonkeyword identi-
fier has just been processed. Use b to denote a separating blank between tokens.
For Exercises 33–38, give a regular expression for the set recognized by the finite-state machine.
	 33.	
s1
0
0
1
1
s0
s2
0, 1
	 34.	
	 35.	
	 36.
	

756	
Modeling Arithmetic, Computation, and Languages
For Exercises 39–42, give a regular expression for the set recognized by the finite-state machine.
	 39.	 Present state
Next state
Output
Present input
0
1
s0
s3
s1
0
s1
s1
s2
0
s2
s3
s3
1
s3
s3
s3
0
	 40.	 Present state
Next state
Output
Present input
0
1
s0
s3
s1
1
s1
s1
s2
1
s2
s2
s2
0
s3
s0
s2
0
	 41.	 Present state
Next state
Output
Present input
0
1
s0
s2
s1
1
s1
s3
s1
1
s2
s3
s4
0
s3
s3
s3
0
s4
s5
s3
0
s5
s2
s3
1
	 42.	 Present state
Next state
Output
Present input
0
1
s0
s4
s1
1
s1
s4
s2
0
s2
s4
s3
0
s3
s3
s1
1
s4
s4
s4
0
	 43.	Give a regular expression for each of the following sets.
	
a.	 set of all strings of 0s and 1s beginning with 0 and ending with 1
	
b.	set of all strings of 0s and 1s having an odd number of 0s
	
c.	 5101, 1001, 10001, 100001, …6
	 44.	Give a regular expression for each of the following sets.
	
a.	 set of all strings of 0s and 1s containing at least one 0
	
b.	set of all strings of a’s and b’s where each a is followed by two b’s
	
c.	 set of all strings of 0s and 1s containing exactly two 0s
	 38.	
s0
s2
1
1
s1
0
0
0
1
	 37.	
s0
s1
0
0
0
1
1
1
0,1
s3
s2

Section 9.3   Finite-State Machines	
757
	 45.	Does the given string belong to the given regular set?
	
a.	 01110111; (1*01)*(11 ~ 0*)
	
b.	 11100111; 3(1*0)* ~ 0*114*
	
c.	 011100101; 01*10*(11*0)*
	 46.	Does the given string belong to the given regular set?
	
a.	 1000011; (10* ~ 11)*(0*1)*
	
b.	 011110; 0*11(1* ~ 10)
	
c.	 101110; 3(101)*10*4*
	 47.	Write a regular expression for the set of all arithmetic expressions indicating the addition or subtraction of 
two positive integers.
	 48.	Write a regular expression for the set of all alphanumeric strings beginning with a letter, which is the set 
of legal identifiers in some programming languages.
	 49.	Write regular expressions for each of the strings described in Exercise 25.
	 50.	Write regular expressions for each of the strings described in Exercise 26.
	 51.	Write regular expressions for each of the strings described in Exercise 27.
	 52.	Write regular expressions for each of the strings described in Exercise 28.
	 53.	a.	 Prove that if A is a regular set, then the set AR consisting of the reverse of all strings in A is also regular.
	
b.	For any string a, let a R be the reverse string. Do you think the set 5aa R
 0  a [ I *6 is regular?
	 54.	Prove that if A is a regular set whose symbols come from the alphabet I, then I * −A is a regular set.
A number of programming languages define “regular expressions” somewhat differently than we have done 
in this chapter. In these instances, the regular expression is meant to describe a pattern for a set of strings so 
that an arbitrary string can be matched against the pattern to see whether the string belongs in the set. Examples 
are (a) searching a string to see whether it matches the format of a valid e-mail address and (b) extracting all 
instances of the form href = “…” from an HTML document. Perl (Practical Extraction and Report Language) 
is a language strong in text processing; following are some of the syntax rules for regular expressions in Perl.
	
*	
repeat the preceding character or group 0 or more times [this is familiar]
	
?	
repeat the preceding character or group 0 or 1 times
	
+	
repeat the preceding character or group 1 or more times
	
.	
(period)—matches any single character
	
.*	
(period asterisk)—matches arbitrary string of any length
	
\s	
(backslash lowercase s)—matches any whitespace character (space, tab, newline)
	
\S	
(backslash uppercase s)—matches any nonwhitespace character
For Exercises 55–62, decide which of the given strings match the given regular expression.
	 55.	Regular expression: bet?er 	
Strings: beer, beter, better, bettter
	 56.	Regular expression: bet*er	
Strings: beer, beter, better, bettter
	 57.	Regular expression: bet+er	
Strings: beer, beter, better, bettter
	 58.	Regular expression: b.?t 	
Strings: bit, but, beet, bt
	 59.	Regular expression: b.+t	
Strings: bit, but, beet, bt
	 60.	Regular expression: b\St	
Strings: bit, but, beet, b t
	 61.	Regular expression: b\ st 	
Strings: bit, but, beet, b t
	 62.	Regular expression: b\ s*t	
Strings: bit, bt, b t, b  t

758	
Modeling Arithmetic, Computation, and Languages
	 67.	 Present state
Next state
Output
Present input
0
1
0
1
2
0
1
2
3
1
2
3
4
0
3
2
1
1
4
5
4
1
5
6
7
0
6
5
6
1
7
8
1
0
8
7
3
0
	 63.	Identify any unreachable states of M.
Present state
Next state
Output
Present input
0
1
s0
s2
s0
0
s1
s2
s1
1
s2
s2
s0
1
	 64.	Identify any unreachable states of M.
Present state
Next state
Output
Present input
a
b
c
s0
s1
s0
s3
0
s1
s1
s3
s0
1
s2
s3
s2
s1
0
s3
s1
s1
s0
0
For Exercises 65–74, minimize the given machine.
	 65.	 Present state
Next state
Output
Present input
0
1
0
3
6
1
1
4
2
0
2
4
1
0
3
2
0
1
4
5
0
1
5
3
5
0
6
4
2
1
	 66.	 Present state
Next state
Output
Present input
0
1
0
5
3
1
1
5
2
0
2
1
3
0
3
2
4
1
4
2
0
1
5
1
4
0
	 68.	 Present state
Next state
Output
Present input
0
1
0
7
1
1
1
0
3
1
2
5
1
0
3
7
6
1
4
5
6
0
5
2
3
0
6
3
0
1
7
4
0
0
	 69.	 Present state
Next state
Output
Present input
0
1
0
1
3
0
1
2
4
1
2
5
4
0
3
1
2
2
4
2
1
1
5
4
0
2
	 70.	 Present state
Next state
Output
Present input
0
1
0
1
3
0
1
2
0
0
2
0
3
0
3
2
1
0

Section 9.4   Turing Machines	
759
	 71.	 Present state
Next state
Output
Present input
a
b
c
0
1
4
0
1
1
4
2
3
0
2
3
4
2
1
3
4
0
1
0
4
1
0
2
0
	 72.	 Present state
Next state
Output
Present input
0
1
0
1
3
1
1
2
0
0
2
4
3
1
3
0
1
1
4
2
4
0
	 73.	 Present state
Next state
Output
Present input
0
1
0
3
0
0
1
4
3
1
2
1
4
0
3
0
4
1
4
5
2
0
5
2
3
1
	 74.	 Present state
Next state
Output
Present input
0
1
0
3
5
1
1
1
6
1
2
0
4
0
3
1
6
1
4
5
3
0
5
4
1
0
6
2
5
1
	 75.	Construct a sequential network for the finite-state machine of Exercise 8.
	 76.	Construct a sequential network for the finite-state machine of Exercise 1a. Make use of don’t-care condi-
tions to simplify the network.
	
S e c t i o n  9 . 4 	 Turing Machines
In Section 9.3, we noted that because S = 50n1n
 0  n ≥06 is not a regular set, 
Kleene’s theorem tells us that it is not recognizable by any finite-state machine. 
We didn’t actually prove that S is not a regular set, however; we only noted that 
we were not able to come up with a regular expression for it. Let’s take a slightly 
different approach.
Suppose S is recognized by a finite-state machine M with m states. Then all 
strings from S and only strings from S lead M from its start state to a final state. 
Now let us run M a number of times on successive input strings of l, 0, 02, 03 … , 0m. 
At the end of processing each of these m + 1 strings, M will be in some state. 
Because M has only m distinct states, there must be two strings from this list, 
say 0v and 0w, v ∙w, each of which lead M from the start state to the same state. 
(This is actually a result of the pigeonhole principle of Chapter 4, where the items 
are the input strings and the bins into which we put the items are the states M is 
in after processing the strings.) Because M recognizes S, the input string 0v1v will 
cause M to end in a final state. But because M is in the same state after processing 
0w as after processing 0v, the string 0w1v, which does not belong to S, will take M 
to the same final state. This contradiction proves that no finite-state machine can 
recognize S.

760	
Modeling Arithmetic, Computation, and Languages
We probably consider ourselves to be finite-state machines and imagine that 
our brains, being composed of a large number of cells, can take on only a finite, 
although immensely large, number of configurations, or states. We feel sure, how-
ever, that if someone presented us with an arbitrarily long string of 0s followed by 
an arbitrarily long string of 1s, we could detect whether the number of 0s and 1s 
was the same. Let’s think of some techniques we might use.
For small strings of 0s and 1s, we could just look at the strings and decide. 
Thus, we can tell without great effort that 000111 [ S and that 00011 o S. How-
ever, for the string
0000000000000001111111111111111
we must devise another procedure, probably resorting to counting. We would 
count the number of 0s received, and when we got to the first 1, we would write 
the number of 0s down (or remember it) for future reference; then we would begin 
counting 1s. (This process is what we did mentally for smaller strings.)
However, we have now made use of some extra memory, because when we 
finished counting 1s, we would have to retrieve the number representing the total 
number of 0s to make a comparison. But such information retrieval is what the 
finite-state machine cannot do; its only capacity for remembering input is to have 
a given input symbol send it to a particular state. We have already seen that no 
finite-state machine can “remember” 0n for arbitrarily large n because it runs out 
of distinct states. In fact, if we try to solve this problem on a real computer, we 
encounter the same difficulty. If we set a counter as we read in 0s, we might get an 
overflow because our counter can go only so high. To process 0n1n for arbitrarily 
large n requires an unlimited auxiliary memory for storing the value of our coun-
ter, which in practice cannot exist.
Another way we humans might attack the problem of recognizing S is to wait 
until the entire string has been presented. Then we would go to one end of the 
string and cross out a 0, go to the other end and cross out a 1, and then continue 
this back-and-forth operation until we ran out of 0s or 1s. The string belongs to S 
if and only if we run out of both at the same time. Although this approach sounds 
rather different from the first one, it still requires remembering each of the inputs, 
since we must go back and read them once the string is complete. The finite-state 
machine, of course, cannot reread input.
We have come up with two computational procedures—algorithms—to de-
cide, given a string of 0s and 1s, whether that string belongs to S = 50n1n
 0  n ≥06. 
Both require some form of additional memory unavailable in a finite-state 
­machine. Evidently, the finite-state machine is not a model of the most general 
form of computational procedure.
Definition
To simulate more general computational procedures than the finite-state  
machine can handle, we use a Turing machine, proposed by the British 
­mathematician Alan M. Turing in 1936. A Turing machine is essentially 
a ­finite-state machine with the added ability to reread its input and also to 
erase and write over its input. It also has unlimited auxiliary memory. Thus, 
the Turing machine overcomes the deficiencies we noted in finite-state ma-
chines. Unlimited auxiliary memory makes the Turing machine a hypothetical 
“machine”—a model—not a real device.

Section 9.4   Turing Machines	
761
A Turing machine consists of a finite-state machine and an unlimited tape 
divided into cells, each cell containing at most one symbol from an allowable 
finite alphabet. At any one instant, only a finite number of cells on the tape are 
nonblank. We use the special symbol b to denote a blank cell. The finite-state 
unit, through its read–write head, reads one cell of the tape at any given moment 
(Figure 9.15).
b
...
...
b
b
b
b
1
1
0
0
1
↑

Finite-state unit
Figure 9.15
By the next clock pulse, depending on the present state of the unit and the 
symbol read, the unit either does nothing (halts) or completes three actions:
	
1.	 Print a symbol from the alphabet on the cell read (it might be the same 
symbol that’s already there).
	
2.	 Go to the next state (it might be the same state as before).
	
3.	 Move the read–write head one cell left or right.
We can describe the actions of any particular Turing machine by a set of 
quintuples of the form (s, i, i′, s′, d), where s and i indicate the present state 
and the tape symbol being read, i′ denotes the symbol printed, s′ denotes the 
new state, and d denotes the direction in which the read–write head moves  
(R for right, L for left). 
Thus, a machine in the configuration illustrated by Figure 9.16a, if acting ac-
cording to the instructions contained in the quintuple (2, 1, 0, 1, R), would move to 
b
...
...
...
...
0
1
b
b
b
1
1
0
1
b
(a)
b
0
1
b
b
b
1
1
0
0
b
(b)
↑

2
↑

1
Figure 9.16
	
(s,	
i,	
i′,	
s′,	
d)
	
	
	
	
	
	
Present state	
Present symbol	
Symbol printed	
Next state	
Direction of move

762	
Modeling Arithmetic, Computation, and Languages
the configuration illustrated in Figure 9.16b. The symbol 1 being read on the tape 
has been changed to a 0, the state of the unit has been changed from 2 to 1, and the 
head has moved one cell to the right.
The term “Turing machine” is used both in the generic sense and also as 
the collection of quintuples that describe the actions of any particular ma-
chine. This is the same double usage for both the name of the abstraction 
and any instance of that abstraction that we mentioned for Boolean algebra in 
Chapter 8.
	
Definition	
Turing Machine 
Let S be a finite set of states and I a finite set of tape symbols (the tape alphabet) 
including a special symbol b. A Turing machine is a set of quintuples of the  
form (s, i, i′, s′, d) where s, s′ [ S; i, i′ [ I; and d [ 5R, L6 and no two 
quintuples begin with the same s and i symbols.
The restriction that no two quintuples begin with the same s and i symbols 
ensures that the action of the Turing machine is deterministic and completely 
specified by its present state and symbol read. If a Turing machine gets into a con-
figuration for which its present state and symbol read are not the first two symbols 
of any quintuple, the machine halts.
Just as in the case of ordinary finite-state machines, we specify a fixed start-
ing state, denoted by 0, in which the machine begins any computation. We also 
assume an initial configuration for the read–write head, namely, a position over 
the farthest left nonblank symbol on the tape. (If the tape is initially all blank, the 
read–write head can be positioned anywhere to start.)
	
EXample 40	
A Turing machine is defined by the set of quintuples:
(0, 0, 1, 0, R)
(0, 1, 0, 0, R)
(0, b, 1, 1, L)
(1, 0, 0, 1, R)
(1, 1, 0, 1, R)
The action of this Turing machine when processing a particular initial tape is 
shown by the sequence of configurations in Figure 9.17, which also shows the 
quintuple that applies at each step. Again, which quintuple applies is deter-
mined by the present state and present symbol; as a result, the order in which 
quintuples are applied has nothing to do with the order in which they are pre-
sented in the machine’s definition, quintuples can be used more than once, or 
may not be used at all.

Section 9.4   Turing Machines	
763
b
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
0
1
1
0
b
b
1
1
1
0
b
(0, 0, 1, 0, R)
(0, 1, 0, 0, R)
b
1
0
1
0
b
(0, 1, 0, 0, R)
b
1
0
0
0
b
(0, 0, 1, 0, R)
b
1
0
0
1
b
(0, b, 1, 1, L)
b
1
0
0
1
1
b
(1, 1, 0, 1, R)
b
1
0
0
0
1
b
(1, 1, 0, 1, R)
b
1
0
0
0
0
b
↑

↑

↑

↑

↑

↑

↑

↑

0
0
0
0
0
1
1
1
Figure 9.17

764	
Modeling Arithmetic, Computation, and Languages
Since there are no quintuples defining the action to be taken when in state 1 reading 
b, the machine halts with final tape:
b
1
...
0
0
0
0
b
...
The tape serves as a memory medium for a Turing machine, and in general, 
the machine can reread cells of the tape. Since it can also write on the tape, the 
nonblank portion of the tape can be as long as desired, although there are still only 
a finite number of nonblank cells at any time. Hence the machine has available an 
unbounded, though finite, amount of storage. Because Turing machines overcome 
the limitations of finite-state machines, Turing machines should have consider-
ably higher capabilities. In fact, a finite-state machine is a very special case of a 
Turing machine, one that always prints the old symbol on the cell read, always 
moves to the right, and always halts on the symbol b.
Practice 57	 Consider the following Turing machine:
(0, 0, 0, 1, R)
(0, 1, 0, 0, R)
(0, b, b, 0, R)
(1, 0, 1, 0, R)
(1, 1, 1, 0, L)
a.	 What is the final tape, given the initial tape
b
1
...
0
b
...
	
(Since it is tedious to draw all the little squares, you don’t need to do so; just write down the contents 
of the final tape.)
b.	Describe the behavior of the machine when started on the tape
b
1
...
0
b
...
c.	 Describe the behavior of the machine when started on the tape
b
...
0
0
b
...
■
Parts (b) and (c) of Practice 57 illustrate two ways in which a Turing machine can 
fail to halt: by endlessly cycling or by moving forever along the tape.
Turing Machines as Set Recognizers
Although the Turing machine computations we have seen so far are not ­particularly 
meaningful, we will use the Turing machine to do two kinds of jobs. First, we’ll 

Section 9.4   Turing Machines	
765
use it as a recognizer, much as we considered finite-state machines as recognizers 
in the previous section. We can even give a very similar definition, provided we 
first define a final state for a Turing machine. A final state in a Turing machine 
is one that is not the first symbol in any quintuple. Thus, on entering a final state, 
whatever the symbol read, the Turing machine halts.
	
Definition	
Turing Machine Recognition (Acceptance)
A Turing machine T with tape alphabet I recognizes (accepts) a subset S of I* if 
T, beginning in standard initial configuration on a tape containing a string α of 
tape symbols, halts in a final state if and only a [ S.
Note that our definition of acceptance leaves open two possible behaviors for T 
when applied to a string a of tape symbols not in S. T may halt in a nonfinal state, 
or T may fail to halt at all.
We can now build a Turing machine to recognize our old friend
S = 50n1n
 0  n ≥06. The machine is based on our second approach to this rec-
ognition problem, sweeping back and forth across the input and crossing out 
0–1 pairs.
	
Example 41	
We want to build a Turing machine that will recognize S = 50n1n
 0  n ≥06. We will 
use one additional special symbol, call it X, to mark out (“erase”) the 0s and 1s 
already examined. Thus the tape alphabet is I = 50, 1, b, X6. State 6 is the only 
final state. The quintuples making up T are given below. Each quintuple or group 
of quintuples has a “comment” describing its function. Just like well-written com-
ments in computer code, this makes the Turing instructions much easier to under-
stand. Be sure to include comments in any Turing machine definition.
(0, b, b, 6, R)	
Recognizes the empty tape, which is in S.
(0, 0, X, 1, R)	
Erases the leftmost 0 and begins to move right.
(1, 0, 0, 1, R)
(1, 1, 1, 1, R)
(1, b, b, 2, L)
(1, X, X, 2, L)
(2, 1, X, 3, L)	
Erases the rightmost 1 and begins to move left.
(3, 1, 1, 3, L)	
Moves left over 1s.
(3, 0, 0, 4, L)	
Goes to state 4 if more 0s are left.
(3, X, X, 5, R)	
Goes to state 5 if no more 0s in string.
(4, 0, 0, 4, L)	
Moves left over 0s.
(4, X, X, 0, R)	
Finds left end of binary string and begins sweep again.
(5, X, X, 6, R)	
No more 1s in string; machine accepts.
Reading down the columns in Figure 9.18, we can see the key configurations (skip-
ping some routine steps) in the machine’s behavior on the tape
b
...
0
0
0
1
1
1
b
...
which, of course, it should accept.	
∂
	
Moves right in state 1 until it reaches the end of the binary 
string; then moves left in state 2.

766	
Modeling Arithmetic, Computation, and Languages
b X X 0 1 1 X b
↑
2
b X X X X X X b
↑
6
b X X 0 1 1 X b
↑
1
b X X X X X X b
↑
5
b X 0 0 1 1 X b
↑
0
b X X X X X X b
↑
3
b X 0 0 1 1 X b
↑
4
b X X X 1 X X b
↑
2
b X 0 0 1 1 X b
↑
4
b X X X 1 X X b
↑
1
b X 0 0 1 1 X b
↑
3
b X X 0 1 X X b
↑
0
b X 0 0 1 1 1 b
↑
2
b X X 0 1 X X b
↑
4
b X 0 0 1 1 1 b
↑
1
b X X 0 1 X X b
↑
3
b 0 0 0 1 1 1 b
↑
0
Figure 9.18
Practice 58	 For the Turing machine of Example 41, describe the final configuration after processing the 
following input tapes:
a.	
b
...
0
0
1
1
1
b
...
b.	
b
...
0
0
0
1
1
b
...
c.	
b
...
0
0
0
0
1
1
b
...
■
Notice how each state of the Turing machine in Example 41 is designed to 
accomplish a certain task, as indicated by the comments. The job of state 1, for 

Section 9.4   Turing Machines	
767
example, is to move right until the end of the binary string is found, marked by 
either a blank or an X, then turn the computation over to state 2. A change of state 
should occur only when something significant happens. For example, a Turing 
machine cannot pass right over an indeterminate number of 1s by changing state 
at each move because its behavior would then be tied to a specific input tape. On 
the other hand, if the machine needs to count over a certain fixed number of 1s, 
then changing states at each move would accomplish this.
REMINDER
Give the states of your 
Turing machine big 
enough jobs to do so that 
the machine will work 
in general, not just for 
special cases. Test using 
a variety of input tapes.
Practice 59	 Design a Turing machine to recognize the set of all strings of 0s and 1s ending in 00. (This 
set can be described by the regular expression (0 ~ 1)*00, so you should be able to use a 
Turing machine that changes no tape symbols and always moves to the right.) Be sure to 
include comments.
■
Practice 60	 Modify the Turing machine of Example 41 to recognize 50n12n
 0  n ≥06.
■
Turing Machines as Function Computers
The second job for which we will use the Turing machine is to compute functions. 
Given a particular Turing machine T and a string a of tape symbols, we begin T 
in standard initial configuration on a tape containing a. If T eventually halts with 
a string b on the tape, we may consider b as the value of a function evaluated at 
a. Using function notation, T(a) = b. The domain of the function T consists of 
all strings a for which T eventually halts. We can also think of T as computing 
number-theoretic functions, functions from a subset of Nk into N for any k ≥1. 
We will think of a string of 1s of length n + 1 as the unary representation of the 
nonnegative integer n; we’ll denote this encoding of n by n. (The extra 1 in the 
encoding enables us to distinguish 0 from a blank tape.) Then a tape containing 
the string n1 * n2 *…* nk can be thought of as the representation of the k-tuple 
(n1, n2, … , nk) of nonnegative integers. If T begun in the standard initial configu-
ration on such a tape eventually halts with a final tape that is the representation 
m of a nonnegative integer m, then T has acted as a k-variable function T k, where 
T k(n1, n2, … , nk) = m. If T begun in standard initial configuration on such a tape 
either fails to halt or halts with the final tape not a representation of a nonnegative 
integer, then the function T k is undefined at (n1, n2, … , nk). There is no need to 
identify final states when using the Turing machine as a function computer.
There is thus an infinite sequence T1, T 2, … , T k, … of number-theoretic 
­functions computed by T associated with each Turing machine T. For each k, the 
function T k is a partial function on Nk, meaning that its domain may be a proper 
subset of Nk. A special case of a partial function on Nk is a total function on Nk, 
where the function is defined for all k-tuples of nonnegative integers.
	
ExaMple 42	
Let a Turing machine T be given by the quintuples
(0, 1, 1, 0, R)
(0, b, 1, 1, R)

768	
Modeling Arithmetic, Computation, and Languages
If T is begun in standard initial configuration on the tape
b
...
1
1
1
b
...
then T will halt with final configuration
b
1
1
1
1
b
1
Therefore, T defines a one-variable function T1 that maps 2 to 3. In general, T 
maps n to n + 1, so T
 1(n) = n + 1, a total function of one variable.	
In Example 42, we began with a Turing machine and observed a particular 
function it computed, but we can also begin with a number-theoretic function and 
try to find a Turing machine to compute it.
	
Definition	
Turing-Computable Function
A Turing-computable function is a number-theoretic function computed by 
some Turing machine.
A Turing-computable function f can in fact be computed by an infinite number of 
Turing machines. Once a machine T is found to compute f, we can always include 
extraneous quintuples in T, producing other machines that also compute f.
	
EXample 43	
We want to find a Turing machine that computes the function f defined as follows:
f (n1, n2) = e n2 −1
  if n2 ≠0
undefined
if n2 = 0
Thus f is a partial function of two variables. Let’s consider the Turing machine 
given by the following quintuples.
(0, 1, 1, 0, R)
(0, *, *, 1, R)
	f  Passes right over n1 to n2
(1, 1, 1, 2, R)
(2, b, b, 3, R)
Counts first 1 in n2.
n2 = 0; halts.
Erases last 1 in n2.
(2, 1, 1, 4, R)
(4, 1, 1, 4, R)
(4, b, b, 5, L)
	¶  Finds the right end of n2.
(5, 1, b, 6, L)
(6, 1, 1, 6, L)
(6, *, b, 7, L)
	f  Passes left to n1, erasing *.
(7, 1, b, 7, L)
(7, b, b, 8, L)
Erases n1.
n1 erased; halts with n2 −1  on tape.

Section 9.4   Turing Machines	
769
If T is begun on the tape
b
...
1
*
1
1
1
1
1
b
...
then T will halt with final configuration
b  b  b  b  b  1  1  1  b
8
This configuration agrees with the requirement that f (1, 3) = 2. If T is begun on 
the tape
b
...
*
1
1
1
b
...
then T will halt with final configuration
b  1  1  *  1  b  b
3
Because the final tape is not m for any nonnegative integer m, the function com-
puted by T is undefined at (1, 0)—just as we want. It is easy to see that this Turing 
machine computes f and that f is therefore a Turing-computable function.
Practice 61	 Design a Turing machine to compute the function
f (n) = bn −2
 if n ≥2
1
 if n < 2
■
Church–Turing Thesis
In this chapter we have talked about models of “computation” or of “computa-
tional procedures.” Although we have not defined the term, by a computational 
procedure we mean an algorithm. We have talked about algorithms often in this 
book and have given a number of algorithms for various tasks. Recall that our 
(somewhat intuitive) definition of an algorithm is a set of instructions that can be 
mechanically executed in a finite amount of time in order to solve some problem. 
Given input appropriate to the task, the algorithm must eventually stop (halt) and 
produce the correct answer if an answer exists. (If no answer exists, let us agree 
that the algorithm can either halt and declare that no answer exists, or it can go on 
indefinitely searching for an answer.)
Now we ask: Is the Turing machine a better model of a computational proce-
dure than the finite-state machine? We are quite likely to agree that any Turing 
computable function f is a function whose values can be found by a computational 

770	
Modeling Arithmetic, Computation, and Languages
procedure or algorithm. In fact, if f is computed by the Turing machine T, then 
the set of quintuples of T is itself the algorithm; as a list of instructions that can 
be carried out mechanically, it satisfies the various properties in our notion of an 
algorithm. Therefore, we are probably willing to accept the proposal illustrated by 
Figure 9.19. The figure shows “computable by algorithm” as a “cloudy,” intuitive 
idea and “Turing computable” as a mathematically precise, well-defined idea. The 
arrow asserts that any Turing-computable function is computable by an algorithm.
Given the simplicity of the definition of a Turing machine, it is a little startling 
to contemplate Figure 9.20, which asserts that any function computable by any 
means we might consider to be an algorithm is also Turing computable. Combin-
ing Figures 9.19 and 9.20, we get the Church–Turing thesis (Figure 9.21), named 
after Turing and another well-known mathematician, Alonzo Church.
Computable by
algorithm
Turing
computable
 
Computable by
algorithm
Turing
computable
 
Computable by
algorithm
Turing
computable
	
Figure 9.19 	
Figure 9.20 	
Figure 9.21
	
Thesis	
Church–Turing Thesis
A number-theoretic function is computable by an algorithm if and only if it is 
Turing computable.
Because the Church–Turing thesis equates an intuitive idea with a mathemati-
cal idea, it can never be formally proved and must remain a thesis, not a theorem. 
What, then, is its justification?
One piece of evidence is that whenever a procedure generally agreed to be 
an algorithm has been proposed to compute a function, someone has been able to 
design a Turing machine to compute that function. (Of course, there is always the 
nagging thought that someday this might not happen.)
Another piece of evidence is that other mathematicians, several of them at 
about the same time Turing developed the Turing machine, proposed other models 
of a computational procedure. On the surface, each proposed model seemed quite 
unrelated to any of the others. However, because all the models were formally 
defined, just as Turing computability is, it was possible to determine on a formal, 
mathematical basis whether any of them were equivalent. All the models, as well 
as Turing computability, were proved equivalent; that is, they all defined the same 
class of functions, which suggests that Turing computability embodies everyone’s 

Section 9.4   Turing Machines	
771
concept of an algorithm. Figure 9.22 illustrates what has been done; here solid 
lines represent mathematical proofs and dashed lines correspond to the Church–
Turing thesis. The dates indicate when the various models were proposed.
Computable by
algorithm
Turing
1936
Markov
1954
Church, Kleene
Late 1930s
Post
Early 1940s
Smullyan
1961
Figure 9.22
The Church–Turing thesis is now widely accepted as a working tool by re-
searchers dealing with computational procedures. If, in a research paper, a method 
is set forth for computing a function and the method intuitively seems to be an 
algorithm, then the Church–Turing thesis is invoked and the function is declared 
to be Turing computable (or one of the names associated with one of the equiva-
lent formulations of Turing computability). This invocation means that the author 
presumably could, if pressed, produce a Turing machine to compute the function, 
but again, the Church–Turing thesis is so universally accepted that no one bothers 
with these details anymore.
Although the Church–Turing thesis is stated in terms of number-theoretic 
functions, it can be interpreted more broadly. Any algorithm in which a finite set 
of symbols is manipulated can be translated into a number-theoretic function by 
a suitable encoding of the symbols as nonnegative integers, much as input to a 
real computer is encoded and stored in binary form. Thus, by the Church–Turing 
thesis we can say that if there is an algorithm to do a symbol manipulation task, 
there is a Turing machine to do it.
By accepting the Church–Turing thesis, we have accepted the Turing machine 
as the ultimate model of a computational procedure. Turing machine capabilities 
exceed those of any actual computer, which, after all, does not have the unlim-
ited tape storage of a Turing machine. It is remarkable that Turing proposed this 
­concept in 1936, well before the advent of the modern computer.
Decision Problems and Uncomputability
We have spent quite a bit of time discussing what Turing machines can do. By 
the Church–Turing thesis, they can do a great deal indeed, although not very ef-
ficiently. It is even more important, however, to consider what Turing machines 
cannot do. Because a Turing machine’s abilities to perform tasks exceed those of 
an actual computer, if we find something no Turing machine can do, then a real 
computer cannot do it either. In fact, by invoking the Church–Turing thesis, no 
algorithm exists to do it, and the task is not computable. The type of task we have 
in mind here is generally that of determining the truth value of each of a number 
of related statements.

772	
Modeling Arithmetic, Computation, and Languages
	
Definition	
Decision Problem
A decision problem asks if an algorithm exists to decide whether individual 
statements from some large class of statements are true.
The solution to a decision problem answers the question of whether an 
algorithm exists. A positive solution consists of proving that an algorithm ex-
ists, and it is generally given by actually producing an algorithm that works. A 
negative solution consists of proving that no algorithm exists. Note that this 
statement is much stronger than simply saying that a lot of people have tried 
but no one has come up with an algorithm—this might simply mean that the 
algorithm is hard. It must be shown that it is impossible for anyone ever to come 
up with an algorithm. When a negative solution to a decision problem is found, 
the problem is said to be unsolvable, uncomputable, or undecidable. This ter-
minology can be confusing because the decision problem itself—the question 
of whether an algorithm exists to do a task—has been solved; what must forever 
be unsolvable is the task itself.
Examples of Decision Problems
We will look at some decision problems that have been answered.
	
Example 44	
Does an algorithm exist to decide, given integers a, b, and c, whether a2 = b2 + c2? 
Clearly, this question is a solvable decision problem. The algorithm consists of 
multiplying b by itself, multiplying c by itself, adding the two results, and comparing 
the sum with the result of multiplying a by itself.
Obviously, Example 44 is a rather trivial decision problem. Historically, much 
of mathematics has concerned itself at least indirectly with finding positive solu-
tions to decision problems, that is, producing algorithms. Negative solutions to 
decision problems arose only in the twentieth century.
	
Example 45	
One of the earliest decision problems to be formulated was Hilbert’s tenth prob-
lem, tenth in a list of problems David Hilbert posed to the International Congress 
of Mathematicians in 1900. The problem is: Does an algorithm exist to decide for 
any polynomial equation P(x1, x2, … , xn) = 0 with integral coefficients whether 
it has integral solutions? For polynomial equations of the form ax + by + c = 0, 
where a, b, and c are integers, it is known that integer solutions exist if and only 
if the greatest common divisor of a and b also divides c. Thus, for particular sub-
classes of polynomial equations, there might be algorithms to decide whether in-
teger solutions exist, but the decision problem as stated applies to the whole class 
of polynomial equations with integer coefficients. When this problem was posed 
and for some time after, the general belief was that surely an algorithm existed and 
the fact that no one had found such an algorithm merely implied that it must be 
difficult. In the mid-1930s, a startling result by Kurt Gödel, described in the next 
example, began to cast doubt on this view. It was not until 1970, however, that this 
problem was finally shown to be unsolvable.

Section 9.4   Turing Machines	
773
	
Example 46	
The decision problem for propositional wffs asks whether an algorithm exists to 
decide whether any given propositional wff is a tautology. This is a solvable de-
cision problem; the solution algorithm consists of constructing and examining the 
truth table for the wff. The decision problem for predicate wffs asks whether an 
­algorithm exists to decide the validity of any given predicate wff. This is an undecid-
able problem; such an algorithm does not exist, which is exactly why we resorted to 
the formal derivation rules of predicate logic to help establish validity for any given 
wff. Because of the completeness and correctness of predicate logic, a wff is valid 
if and only if we can produce a proof sequence for it. However, this has only shifted 
one decision problem to an equivalent one—there is no algorithm to decide whether 
a proof sequence exists for any given predicate wff, much less a mechanical way to 
know what steps to use to produce a proof sequence if one does exist.
An alternative formulation to the logic systems we discussed in Chapter 1 
is to identify certain strings of symbols as axioms and to give rules of inference 
whereby a new string can be obtained from old strings. Any string that is the last 
one in a finite list of strings consisting of either axioms or strings obtainable by 
the rules of inference from earlier strings in the list is said to be a theorem. The 
decision problem for such a formal theory is: Does an algorithm exist to decide 
whether a given string in the formal theory is a theorem of the theory?
The work of Church and the famous twentieth-century logician Kurt Gödel 
showed that any formal theory that axiomatizes properties of arithmetic (making 
commutativity of addition an axiom, for example) and is not completely trivial (not 
everything is a theorem) is undecidable. Their work can be considered good news 
for working mathematicians because it means that ingenuity in answering questions 
in number theory will never be replaced by a mechanical procedure.	
	
Example 47	
A particular Turing machine T begun on a tape containing a string a will either 
eventually halt or never halt. The halting problem for Turing machines is a deci-
sion problem: Does an algorithm exist to decide, given a Turing machine T and 
string a, whether T begun on a tape containing a will eventually halt? Turing 
proved the unsolvability of the halting problem in the late 1930s.
Halting Problem
We will prove the unsolvability of the halting problem after two observations. 
First, it might occur to us that “run T on a” would constitute an algorithm to see 
whether T halts on a. If within 25 steps of T’s computation T has halted, then 
we know T halts on a. But if within 25,000 steps T has not halted, what can we 
conclude? T may still eventually halt. How long should we wait? This so-called 
algorithm will not always give us the answer to our question.
A second observation is that the halting problem asks for one algorithm to be 
applied to a large class of statements. The halting problem asks, Does an ­algorithm 
exist to decide, for any given (T, a) pair, whether T halts when begun on a tape 
containing a? The algorithm comes first, and that single algorithm has to give the 
correct answer for all (T, a) pairs. In the notation of predicate logic, the halting 
problem asks about the truth value of a statement in the form
(E algorithm)(4(T, a))( … )

774	
Modeling Arithmetic, Computation, and Languages
Consider the following statement, which seems very similar: Given a par-
ticular (T, a) pair, does an algorithm exist to decide whether T halts when begun 
on a tape containing a? Here, the (T, a) pair comes first and an algorithm is cho-
sen based on the particular (T, a); for a different (T, a), there can be a different 
algorithm. The statement has become (4(T, a))(E algorithm)(…). This problem 
is solvable. Suppose someone gives us a (T, a). Two algorithms are (1) “say yes” 
and (2) “say no.” Since T acting on a either does or does not halt, one of these 
two algorithms correctly answers the question. This solution may seem trivial 
or even sneaky, but consider again the problem statement: Given a particular 
(T, a) pair, does an algorithm exist to decide, and so forth. Such an algorithm 
does exist; it is either to say yes or to say no—we are not required to choose 
which one is correct!
This turnabout of words changes the unsolvable halting problem into a trivi-
ally solvable problem. It also points out the character of a decision problem, asking 
whether a single algorithm exists to solve a large class of problems. An unsolvable 
problem has both a good side and a bad side. That no algorithm exists to solve a 
large class of problems guarantees jobs for creative thinkers who cannot be re-
placed by Turing machines. But that the class of problems considered is so large 
might make the result too general to be of interest.
We will state the halting problem again and then prove its unsolvability.
	
Definition	
Halting Problem
The halting problem asks: Does an algorithm exist to decide, given any Turing ma-
chine T and string a, whether T begun on a tape containing a will eventually halt?
	
Theorem	
On the Halting Problem
The halting problem is unsolvable.
Proof: We want to prove that something does not exist, a situation made to order 
for proof by contradiction. Therefore we assume that the halting problem is solv-
able and that a single algorithm exists that can act on any (T, a) pair as input and 
eventually decide whether T running on a halts. We are asking this algorithm to 
solve a task of symbol manipulation, since we can imagine the set of quintuples 
of T encoded as some unique string sT of symbols; we’ll use (sT, a) to denote the 
string sT concatenated with the string a. The task then becomes transforming the 
string (sT, a) into a string representing a yes (the Turing machine with descrip-
tion sT halts when begun on a tape containing a) or a no (the Turing machine 
with description sT does not halt when begun on a tape containing a). By the 
Church–Turing thesis, because we have assumed the existence of an algorithm 
that performs this task, we can assume the existence of a single Turing machine 
X that performs this task. Thus X acts on a tape containing (sT, a) for any T and 
a and eventually halts, at the same time telling us whether T on a halts. To be 
definite, suppose that X begun on (sT, a) halts with a 1 left on the tape if and only 
if T begun on a halts, and X begun on (sT, a) halts with a 0 left on the tape if and 
only if T begun on a fails to halt; these are the only two possibilities. Figure 9.23 
illustrates Turing machine X.

Section 9.4   Turing Machines	
775
Output
Halts with 0 on tape
exactly when T never
halts on a
Halts with 1 on tape
exactly when T
eventually halts on a
Turing machine X
Input
(sT, a)
	
Figure 9.23
Now we add to X’s quintuples to create a new machine Y. Machine Y modifies 
X’s behavior so that whenever X halts with a 1 on its tape, Y goes to a state that 
moves Y endlessly to the right so that it never halts. If X halts with a 0 on its tape, 
so does Y. Figure 9.24 illustrates the behavior of Y.
Output
Halts with 0 on tape
exactly when T never
halts on a
Never halts
exactly when T
eventually halts on a
Turing machine Y
Input
(sT, a)
	
Figure 9.24
Finally, we modify Y to get a new machine Z that acts on any input b by first 
copying b (see, for example, Exercise 16) and then turning the computation over 
to Y so that Y acts on (b, b). What happens if we run Z on its own description, sZ? 
This situation is shown in Figure 9.25.
Output
Halts with 0 on tape
exactly when Z never
halts on sz
Never halts
exactly when Z
eventually halts on sz
Turing machine Z
Input
sz
(sz, sz)
	
Figure 9.25

776	
Modeling Arithmetic, Computation, and Languages
By the way Z is constructed, if Z acting on sZ halts, it is because Y acting on 
(sZ, sZ) halts, and that happens because X acting on (sZ, sZ) halts with a 0 on the 
tape; but if this happens, it implies that Z begun on sZ fails to halt! Therefore,
	
Z on sZ halts S Z on sZ fails to halt
(1)
This implication is very strange; let’s see what happens if Z on sZ does not 
halt. By the way Z is constructed, if Z acting on sZ does not halt, neither does Y act-
ing on (sZ, sZ). Now Y acting on (sZ, sZ) fails to halt exactly when X acting on (sZ, sZ) 
halts with a 1 on the tape; but this result implies that Z begun on sZ halts! Therefore
	
Z on sZ fails to halt S Z on sZ halts
 (2)
Together, implications (1) and (2) provide an airtight contradiction, so our assump-
tion that the halting problem is solvable is incorrect. End of Proof.
The proof of the unsolvability of the halting problem depends on two ideas. 
One is that of encoding a Turing machine into a string description, and the other 
is that of having a machine look at and act on its own description. Notice also that 
neither (1) nor (2) alone in the proof is sufficient to prove the result. Both are need-
ed to contradict the original assumption of the solvability of the halting problem.
We have previously encountered another proof of this nature, where the 
­observation that makes the proof work is self-contradictory. You might want to 
review here the proof of Cantor’s theorem in Chapter 5.
Computational Complexity
As a model of computation, the Turing machine has provided us with a way to 
prove the existence of unsolvable (uncomputable) problems. Not only does the 
Turing machine help us find the limits of computability, but it can also help us 
classify problems that are computable—that have an algorithm for their solu-
tion—by the amount of work required to carry out the algorithm.
Finding the amount of work required to carry out an algorithm sounds like anal-
ysis of algorithms. We have analyzed a number of real algorithms in this book and 
classified them as Θ(log n), Θ(n), Θ(n2), or what have you. By the Church–Turing 
thesis, any algorithm can be expressed in Turing machine form. In this form, the 
amount of work is the number of Turing machine steps (one per clock pulse) required 
before the Turing machine halts. (We assume here that we are considering only tasks 
that “have answers” so that the Turing machine halts on all appropriate input.)
Turing machine computations are quite inefficient. Therefore if algorithms A 
and A′ both solve the same problem, but A is expressed as a description of a Turing 
machine and A′ as pseudocode for instructions in a high-level programming lan-
guage, then comparing the number of operations each algorithm performs is rather 
meaningless. Therefore we will assume that all algorithms are expressed in Turing 
machine form so that we can readily compare the efficiency of different algorithms.
Rather than discuss whether a Turing machine algorithm is Θ(n) or Θ(n2), 
let us simply note whether it is a polynomial-time algorithm. (Only quite trivial 
algorithms can be better than polynomial time, because it takes a Turing ma-
chine n steps just to examine its tape.) Problems for which no polynomial-time 
­algorithms exist are called intractable. Such problems may be solvable, but only 
by ­inefficient algorithms.

Section 9.4   Turing Machines	
777
	
Definition	
P
P is the collection of all sets recognizable by Turing machines in polynomial time.
Consideration of set recognition in our definition of P is not as restrictive as it 
may seem. Because the Turing machine halts on all appropriate input, it actually 
decides, by halting in a final or nonfinal state, whether the initial string was or was 
not a member of the set. Many problems can be posed as set decision problems by 
suitably encoding the objects involved in the problem.
For example, consider the Hamiltonian circuit problem (Section 7.2) of 
­whether a graph has a cycle that uses every node of the graph. We may define 
some encoding process to represent any graph as a string of symbols. Strings that 
are the representations of graphs become appropriate input, and we want to de-
cide, given such a string, whether it belongs to the set of strings whose associated 
graphs have Hamiltonian circuits. If we can build a Turing machine to make this 
decision in polynomial time, then the Hamiltonian circuit problem belongs to P.
We noted in Section 6.2 that the Hamiltonian circuit problem is solvable by the 
brute-force approach of tracing all possible paths, but this is an exponential solution 
because of the number of paths. We said that there is no known efficient (polynomial) 
algorithm to solve the Hamiltonian circuit problem, so we have no proof that the 
Hamiltonian circuit problem belongs to P. But there is also no proof that the Hamil- 
tonian circuit problem does not belong to P. Might a clever, efficient algorithm some-
day be found? To see why this is unlikely, we’ll consider a new kind of Turing machine.
Ordinary Turing machines act deterministically, due to our restriction that no 
two quintuples begin with the same present state/present symbol pair. A relaxation 
of this requirement results in a nondeterministic Turing machine, which may 
have a choice of actions at any step. A nondeterministic Turing machine recogniz-
es a string on its tape if some sequence of actions leads to halting in a final state.
	
Definition	
NP
NP is the collection of all sets recognizable by nondeterministic Turing machines 
in polynomial time. (NP comes from nondeterministic polynomial time.)
Although a set in P requires that a deterministic Turing machine be able to 
make a decision (in polynomial time) about whether some string on its tape does 
or does not belong to the set, a set in NP requires only that a nondeterministic 
Turing machine be able to verify (in polynomial time) by a fortuitous choice of ac-
tions that an input string is in the set. Given a graph that has a Hamiltonian circuit, 
for example, this fact can be confirmed in polynomial time by a nondeterministic 
Turing machine that picks the correct path, so the Hamiltonian circuit problem 
belongs to NP. Another way to think about a nondeterministic Turing machine is 
to imagine “parallel processing.” At every clock pulse where there is a choice of 
action, new versions of the machine are created, one for each possible action. For 
the Hamiltonian circuit problem, there may be an exponential number of versions 
created, but the one version tracing the Hamiltonian circuit can complete its path 
through the graph in polynomial time.
If a Turing machine can decide in polynomial time whether an arbitrary string 
belongs to a set, it can surely use the same process to verify a member of the set 
in polynomial time. Therefore P 8 NP. However, it is not known whether this 

778	
Modeling Arithmetic, Computation, and Languages
inclusion is proper, that is, whether P ( NP so that there could be NP problems—
including perhaps the Hamiltonian circuit problem—that are intractable.
The Hamiltonian circuit problem belongs to a third class of problems known 
as NP-complete problems, meaning that not only are they in NP, but if a poly-
nomial-time decision algorithm were ever found for any one of them, that is, if 
any of them were ever found to be in P, then indeed we would have P = NP. 
A large number of problems from many different fields have been found to be 
­NP-complete since this idea was formulated in 1971.
	
Example 48	
The problem of deciding, for an arbitrary propositional wff, whether it is a tau-
tology is NP-complete. No efficient algorithm has been found for its solution. A 
brute-force algorithm would explore each of the possible truth assignments to the 
statement letters. Like the Hamiltonian circuit problem, we see the exponential 
(nonpolynomial) nature of this inefficient approach—a wff with n statement letters 
has a truth table with 2n rows. A related problem called the satisfiability problem 
asks for a decision as to whether there exists any truth assignment that can “sat-
isfy” the wff—make it true. This is also an NP-complete problem, and in fact was 
the first problem discovered to be NP-complete. Its brute-force solution algorithm 
also relies on testing all truth value assignments.
The graph-coloring problem (given an arbitrary graph and a positive integer k, 
color the nodes of the graph using k colors so that all adjacent nodes are different 
colors) is NP-complete. Again, no efficient algorithm has been found; the brute-
force approach says to assign colors to nodes so that adjacent nodes are different 
colors, and if you run into a place where this becomes impossible, backtrack and 
modify your color assignments. Basically, this says to try all possible color assign-
ments (similar to trying all truth assignments, but with kn possibilities).
The general Sudoku puzzle consists of an n2 × n2 grid made up of n × n 
blocks where each row, each column, and each block must contain exactly one 
of the digits 1 through n2. (See Exercise 53 in Section 2.4 for an example of the 
popular n = 3 version.) This is an NP-complete problem. No efficient solution 
algorithm is known; a brute-force solution tries all possible number assignments.
Once again, no polynomial-time decision algorithm has been found for any 
of these or the many other NP-complete problems, and if an efficient procedure 
could be found to solve any one of them, such a procedure would exist for all 
other problems in NP. Therefore it is now suspected that P ( NP and that all these 
problems are intractable, but to prove this remains a tantalizing goal in computer 
science research.
S e c t i o n  9 . 4 	
Review
Techniques
•	 Describe the action of a given Turing machine on a 
given initial tape.
•	 Construct a Turing machine to recognize a given set.
•	 Construct a Turing machine to compute a given 
number-theoretic function.
Main Ideas
•	 Turing machines have a deterministic mode of 
­operation, the ability to reread and rewrite input, 
and an unbounded auxiliary memory.
•	 A finite-state machine is a special case of a Turing 
machine.
W
W

Section 9.4   Turing Machines	
779
•	 Turing machines can be used as set recognizers and 
as function computers.
•	 The Church–Turing thesis equates a function 
computable by an algorithm with a Turing-
computable function. Because this thesis expresses 
a relationship between an intuitive idea and a 
formally defined one, it can never be proved but 
has nonetheless been widely accepted.
•	 A decision problem asks if an algorithm exists to 
decide whether individual statements from a large 
class of statements are true; if no algorithm exists, 
the decision problem is unsolvable.
•	 The halting problem is unsolvable.
•	 P # NP, but it is unknown whether P ( NP.
Exercises 9.4
For Exercises 3–26, be sure to include comments with any Turing machine definition.
	 1.	 Consider the Turing machine
(0, 0, 0, 0, L)
(0, 1, 0, 1, R)
(0, b, b, 0, L)
(1, 0, 0, 1, R)
(1, 1, 0, 1, R)
	
a.	 What is its behavior when started on the tape
b
...
0
1
0
1
1
b
...
	
b.	What is its behavior when started on the tape
b
...
1
0
0
1
1
b
...
	 2.	 Consider the Turing machine
(0, 1, 1, 0, R)
(0, 0, 0, 1, R)
(1, 1, 1, 1, R)
(1, b, 1, 2, L)
(2, 1, 1, 2, L)
(2, 0, 0, 2, L)
(2, b, 1, 0, R)
	
a.	 What is its behavior when started on the tape
b
...
1
1
0
0
b
...
	
b.	What is its behavior when started on the tape
b
...
1
0
1
b
...
	 3.	 Find a Turing machine that recognizes the set of all unary strings consisting of an even number of 1s (this 
includes the empty string).

780	
Modeling Arithmetic, Computation, and Languages
	 4.	 Find a Turing machine that recognizes the set of all strings of 0s and 1s containing at least one 1.
	 5.	 Find a Turing machine that recognizes 0*10*1.
	 6.	 Find a Turing machine to accept the set of nonempty strings of well-balanced parentheses. (Note that 
(( )(( ))) is well balanced and (( )(( )) is not.)
	 7.	 Find a Turing machine that recognizes 502n1n22n
 0  n ≥06.
	 8.	 Find a Turing machine that recognizes 5w * w R
 0  w [ 50, 16* and w R is the reverse of the string w}.
	 9.	 Find a Turing machine that recognizes 5w1 * w2 0  w1, w2 [ 50, 16* and w1 ≠w26.
	 10.	Find a Turing machine that recognizes the set of palindromes on {0, 1}*, that is, the set of all strings in  
{0, 1}* that read the same forward and backward, such as 101.
	 11.	Find a bit-inverter Turing machine that replaces every 0 in a string of 0s and 1s with a 1 and every 1 with a 0.
	 12.	Find a Turing machine that changes a unary string to a string of the same length with alternating 1s and 0s.
	 13.	Find a nonhalting Turing machine that begins with a single 1 on its tape and successively generates strings 
of the form 0n10n, n ≥1, that is, such strings appear every so often on the tape.
	 14.	Find a Turing machine that, given an initial tape containing a (possibly empty) string of 1s, adds a single 
0 to the left end of the string if the number of 1s is even and adds two 0s to the left end of the string if the 
number of 1s is odd.
	 15.	Find a Turing machine that converts a string of 0s and 1s representing a nonzero binary number into a 
string of that number of 1s. As an example, the machine should, when started on a tape containing
b
...
1
0
0
b
...
	
halt on a tape containing
b
...
1
1
1
1
b
...
	 16.	Find a Turing machine that, given an initial tape containing a nonempty string of 1s, marks the right end 
of the string with a * and puts a copy of the string to the right of the *. As an example, the machine should, 
when started on a tape containing
b
...
1
1
1
b
...
	
halt on a tape containing
b
...
1
1
1
1
1
1
*
b
...
	 17.	What number-theoretic function of three variables is computed by the following Turing machine?
	
(0, 1, b, 0, R)
	
(0, *, b, 1, R)
	
(1, 1, 1, 2, R)
	
(2, *, *, 3, R)
	
(3, 1, 1, 2, L)
	
(2, 1, 1, 4, R)
	
(4, 1, 1, 4, R)
	
(4, *, 1, 5, R)
	
(5, 1, b, 5, R)
	
(5, b, b, 6, R)

Section 9.4   Turing Machines	
781
	 18.	What number-theoretic function of one variable is computed by the following Turing machine?
(0, 1, 1, 1, R)
(1, b, b, 9, R)
(1, 1, 1, 2, R)
(2, b, b, 3, L)
(3, 1, b, 9, L)
(2, 1, 1, 4, R)
(4, b, b, 5, L)
(5, 1, b, 3, L)
(4, 1, 1, 6, L)
(6, 1, 1, 6, L)
(6, b, 1, 7, L)
(7, b, 1, 8, L)
(8, b, 1, 9, L)
	 19.	Find a Turing machine to compute the function
f (n) = b1
if n = 0
2
if n ∙0
	 20.	Find a Turing machine to compute the function
f (n) = bn
if n is even
n + 1
if n is odd
	 21.	Find a Turing machine to compute the function 
f (n) = 2n
	 22.	Find a Turing machine to compute the function
f (n) = bn∙3
if 3 divides n
undefined
otherwise
	 23.	Find a Turing machine to compute the function
f (n1, n2) = n1 + n2
	 24.	Find a Turing machine to compute the function
f (n1, n2) = bn1
if n1 is even
n2
if n1 is odd
	 25.	Find a Turing machine to compute the function
f (n1, n2) = bn1 −n2
if n1 ≥n2
0
otherwise

782	
Modeling Arithmetic, Computation, and Languages
	 26.	Find a Turing machine to compute the function
f (n1, n2) = max(n1, n2)
	 27.	Do Exercise 21 again, this time making use of the machines T1 and T2 of Exercises 16 and 23, respective-
ly, as “functions.” (Formally, the states of these machines would have to be renumbered as the quintuples 
are inserted into the “main program,” but you may omit this tiresome detail and merely “invoke T1” or 
“invoke T2.”)
	 28.	Describe verbally the actions of a Turing machine that computes the function f (n1, n2) = n1 # n2, that 
is, design the algorithm but do not bother to create all the necessary quintuples. You may make use of 
­Exercises 16 and 23.
	
S e c t i o n  9 . 5 	 Formal Languages
Suppose we come upon the English language sentence, “The walrus talks loudly.” 
Although we might be surprised at the meaning, or semantics, of the sentence, 
we accept its form, or syntax, as valid in the language, meaning that the various 
parts of speech (noun, verb, and so on) are strung together in a reasonable way. In 
contrast, we reject, “Loudly walrus the talks,” as an illegal combination of parts 
of speech, or as syntactically incorrect and not part of the language. We must 
also worry about correct syntax in programming languages, but in these, unlike 
natural languages (English, French, and so on), legal combinations of symbols are 
specified in detail. Let’s give a formal definition of language; the definition will 
be general enough to include both natural languages and programming languages.
	
Definitions	
Alphabet, Vocabulary, Word, Language
An alphabet or vocabulary V is a finite, nonempty set of symbols. A word over 
V is a finite-length string of symbols from V. The set V * is the set of all words 
over V. (See Example 6 in Chapter 3 for a recursive definition of V*.) A ­language 
over V is any subset of V *.
Viewing syntactically correct English language as a subset L of the set of all 
strings over the usual alphabet, we feel that, “The walrus talks loudly,” belongs to 
L while, “Loudly walrus the talks,” does not.
For any given language L, how can we describe L, that is, specify exactly 
those words belonging to L? If L is finite, we can just list its members, but if L is 
infinite, can we find a finite description of L? Not always—there are many more 
languages than possible finite descriptions. Although we will consider only lan-
guages that can be finitely described, we can still think of two possibilities. We 
may be able to describe an algorithm to decide membership in L; that is, given 
any word in V*, we could apply our algorithm and receive a yes or no answer as 
to whether the word belongs to L. Or we may be able to describe a procedure al-
lowing us only to generate members of L, that is, crank out one at a time a list of 
all the members of L. We will settle for languages for which this second option is 
possible and describe such a language by defining its generative process, or giving 
a grammar for the language.

Section 9.5   Formal Languages	
783
Before we give a formal definition of what constitutes a grammar, let’s look 
again at why, “The walrus talks loudly,” seems to be an acceptable sentence by 
seeing how it could be generated. Starting from the notion of sentence, we would 
agree that one legitimate form for a sentence is a noun phrase followed by a verb 
phrase. Symbolically,
sentence S noun-phrase verb-phrase
A legitimate form of noun phrase is an article followed by a noun,
noun-phrase S article noun
and a legitimate form of verb phrase is a verb followed by an adverb,
verb-phrase S verb adverb
We would also agree with the substitutions
 article S the
 noun S walrus
 verb S talks
 adverb S loudly
Thus we can generate the sentence, “The walrus talks loudly,” by making succes-
sive substitutions:
 sentence 1  noun-phrase verb-phrase
 1 article noun verb-phrase
 1 the noun verb-phrase
 1 the walrus verb-phrase
 1 the walrus verb adverb
 1 the walrus talks adverb
 1 the walrus talks loudly
The foregoing boldface terms are those for which further substitutions can be 
made. The nonboldface terms stop or terminate the substitution process. These 
ideas are incorporated in the next definition.
	
Definition	
Phrase-Structure (Type 0) Grammar
A phrase-structure grammar (type 0 grammar) G is a 4-tuple, G = (V, VT, S, P), 
where
V = vocabulary
VT = nonempty subset of V called the set of terminals
S = element of V – VT called the start symbol
P = finite set of productions of the form a S b where a is a word over V 
containing at least one nonterminal symbol and b is a word over V

784	
Modeling Arithmetic, Computation, and Languages
The productions of a grammar allow us to transform some words over V into 
others; the productions can be called rewriting rules.
	
Definition	
Generations (Derivations) in a Language
Let G be a grammar, G = (V, VT, S, P), and let w1 and w2 be words over V. 
Then w1 directly generates (directly derives) w2, written w1 1 w2, if a S b 
is a production of G, w1 contains an instance of a, and w2 is obtained from w1 
by replacing that instance of a with b. If w1, w2, … , wn are words over V and 
w1 1 w2, w2 1 w3, … , wn−1 1 wn, then w1 generates (derives) wn, written 
w1 1* wn. (By convention, w1 1* w1.)
	
Example 49	
Here is a very simple grammar: G = (V, VT, S, P) where V = 50, 1, S6, 
VT = 50, 16, and P = 5S S 0S, S S 16.
	
ExampLe 50	
In the grammar of Example 49, 00S 1 000S because the production S S 0S has 
been used to replace the S in 00S with 0S. Also 00S 1* 00000S.
Practice 62	 Show that in the grammar of Example 49, 0S 1* 00001.
■
	
Definition	
Language Generated by a Grammar
Given a grammar G, the language L generated by G, sometimes denoted L(G), 
is the set
L = 5w [ VT* 0
 S 1* w6
In other words, L is the set of all strings of terminals generated from the start 
symbol.
Notice that once a string w of terminals has been obtained, no productions can 
be applied to w, and w cannot generate any other words.
The following procedure generates a list of the members of L: Begin with 
the start symbol S and systematically apply some sequence of productions until 
a string w1 of terminals has been o btained; then w1 [ L. Go back to S and re-
peat this procedure using a different sequence of productions to generate another 
word w2 [ L, and so forth. Actually, this procedure doesn’t quite work because we 
might start on an infinite sequence of direct derivations that never leads to a string 
of terminals and thus never contributes a word to our list. Instead, we need to run 
a number of derivations from S simultaneously (parallel processing), checking on 
each one after each step and adding the final word to the list of members of L for 
any that terminate. That way we cannot get stuck waiting indefinitely while un-
able to do anything else.
REMINDER
Productions may be used 
in any order. The only 
requirement is that the 
left side of the production 
must appear in the string 
you are processing.

Section 9.5   Formal Languages	
785
Practice 63	 Describe the language generated by the grammar G of Example 49.
■
Languages derived from grammars such as we have defined are called formal 
languages. If the grammar is defined first, the language will follow as an outcome 
of the definition. Alternatively, the language, as a well-defined set of strings, may 
be given first, and we then seek a grammar that generates it.
	
Example 51	
Let L be the set of all nonempty strings consisting of an even number of 1s. Then 
L is generated by the grammar G = (V, VT, S, P) where V = 51, S6, VT = 516, 
and P = 5S S SS, S S 116. A language can be generated by more than one 
grammar. L is also generated by the grammar G′ = (V′, V′T, S′, P′) where 
V′ = 51, S6, V′T = 516, and P′ = 5S S 1S1, S S 116.
Practice 64	
a.	 Find a grammar that generates the language L = 50n10n
 0   n ≥06.
b.	Find a grammar that generates the language L = 50n10n
 0   n ≥16.
■
Trying to describe concisely the language generated by a given grammar and 
defining a grammar to generate a given language can both be quite difficult tasks. 
We’ll look at another example where the grammar is a bit more complicated than 
any we’ve seen so far. Don’t worry about how you might think up this grammar; 
just convince yourself that it works.
	
Example 52	
Let L = 5anbncn
 0  n ≥16. A grammar generating L is G = (V, VT, S, P) where 
V = 5a, b, c, S, B, C6, VT = 5a, b, c6, and P consists of the following productions:
	
1. 	S S aSBC	
3.	 CB S BC	
5.	bB S bb	
7.	cC S cc
	
2.	S S aBC	
4.	 aB S ab	
6.	bC S bc
It is fairly easy to see how to generate any particular member of L using these pro-
ductions. Thus, a derivation of the string a2b2c2 is
S 1 aSBC
 1 aaBCBC
 1 aaBBCC
 1 aabBCC
 1 aabbCC
 1 aabbcC
 1 aabbcc
In general, L # L(G) where the outline of a derivation for any anbncn is given be-
low; the numbers refer to the productions used.

786	
Modeling Arithmetic, Computation, and Languages
S 1*
1 an−1S(BC )n−1
 1
2 an(BC )n
	
 1*
3 anB nC n
 1
4 anbB n−1C n
	
 1*
5 a nb nC n
 1
6 a nb ncC n−1
	
 1*
7 a nb nc n
We must also show that L(G) # L, which involves arguing that some productions 
must be used before others and that the general derivation shown above is the only 
sort that will lead to a string of terminals.	
In trying to invent a grammar to generate the L of Example 52, we might 
first try to use productions of the form B S b and C S c instead of productions 
4 through 7. Then we would indeed have L # L(G), but L(G) would also include 
words such as an(bc)n.
Formal languages were developed in the 1950s by linguist Noam Chomsky 
in an attempt to model natural languages, such as English, with an eye toward 
automatic translation. However, since a natural language already exists and is 
quite complex, defining a formal grammar to generate a natural language is very 
difficult. Attempts to do this for English have been only partially successful.
REMINDER
“Throwing in” produc-
tions to get the language 
L you want often means 
that you generate more 
than L. The productions 
must generate exactly the 
strings in L.
	
EXample 53	
We can describe a formal grammar that will generate a very restricted class of 
English sentences. The terminals in the grammar are the words “the,” “a,” “river,” 
“walrus,” “talks,” “flows,” “loudly,” and “swiftly,” and the nonterminals are the 
words sentence, noun-phrase, verb-phrase, article, noun, verb, and adverb. 
The start symbol is sentence and the productions are
sentence S noun-phrase verb-phrase
noun-phrase S article noun
verb-phrase S verb adverb
article S the
article S a
noun S river
noun S walrus
verb S talks
verb S flows
adverb S loudly
adverb S swiftly
We know how to derive, “The walrus talks loudly,” in this grammar. Here is a 
derivation of, “A river flows swiftly”:

Section 9.5   Formal Languages	
787
sentence 1 noun-phrase verb-phrase
 1 article noun verb-phrase
 1 a noun verb-phrase
 1 a river verb-phrase
 1 a river verb adverb
 1 a river flows adverb
 1 a river flows swiftly
A few other sentences making various degrees of sense, such as, “a walrus 
flows loudly,” are also part of the language defined by this grammar. The difficulty 
of specifying a grammar for English as a whole becomes more apparent when we 
consider that a phrase such as, “time flies,” can be an instance of either a noun fol-
lowed by a verb or of a verb followed by a noun. This phrase is “ambiguous” (see 
Exercises 35 and 36 in this section).	
Programming languages are less complex than natural languages, and their 
syntax often can be described successfully using formal language notation.
	
EXample 54	
A section of formal grammar to generate identifiers in some programming lan-
guage could be presented as follows:
identifier S letter
identifier S identifier letter
identifier S identifier digit
letter S a
letter S b
(
letter S z
digit S 0
digit S 1
(
digit S 9
Here the set of terminals is 5a, b, … , z, 0, 1, … , 96 and identifier is the start 
symbol.	
	
EXample 55	
A shorthand that can avoid a long listing of productions is called Backus-Naur 
form (BNF). The productions of Example 54 can be given in BNF by three lines 
(as in Example 7 of Chapter 3):
<identifier> ::= <letter> 0 <identifier><letter> 0 <identifier><digit>
<letter> ::= a 0 b 0 c 0 … 0 z
<digit> ::= 0 0 1 0 … 0 9

788	
Modeling Arithmetic, Computation, and Languages
In BNF, nonterminals are identified by < >, the production arrow becomes  
::=, and 0 stands for “or,” identifying various productions having the same left-
hand symbol.
In modern times, BNF notation was originally used to define the programming 
language Algol (ALGOrithmic Language) in the early 1960s. However, it appears 
that a similar notation was used between 400 bce and 200 bce to describe the rules 
of Sanskrit grammar.2	
	
Example 56	
The markup language HTML (Hypertext Markup Language) is a specific language 
for writing documents that will be transmitted across a network and displayed by a 
Web browser. The browser parses and interprets the various tags that identify legal 
elements of an HTML document and displays the elements accordingly. The struc-
ture of each HTML element, such as a TABLE element, is fixed; someone writing 
an HTML document using TABLE elements must follow the structure of a TABLE 
element as defined in HTML. XML (Extensible Markup Language) is a gener-
alized language for defining specific markup languages, that is, it’s a language 
for defining languages. The elements of an XML document can have whatever 
structure the user chooses; the user defines these elements in an associated DTD 
(Document Type Definition). The DTD can be part of the XML document, or it can 
be in a separate file referenced by the XML document (and as such, available for 
a number of XML documents to use). The following DTD gives a grammar for an 
XML document about manufactured parts, and defines the structure of a “PART-
SLIST” element, an “ITEM” element, and so forth.
	
<!DOCTYPE PARTSLIST 5
	
<!ELEMENT PARTSLIST (ITEM+)>
	
<!ELEMENT ITEM (PARTNUMBER, USEDINLIST)>
	
<!ELEMENT PARTNUMBER (#PCDATA)>
	
<!ELEMENT USEDINLIST (USEDIN*)>
	
<!ELEMENT USEDIN (MAKE, MODEL)>
	
<!ELEMENT MAKE (#PCDATA)>
	
<!ELEMENT MODEL (#PCDATA)>
	
6>
The DTD uses notation similar to that for regular expressions, where * means 
zero or more instances, + means one or more instances, and ? means zero instances 
or one instance. So in the preceding DTD, a PARTSLIST consists of one or more 
ITEMs, and a USEDINLIST consists of zero or more USEDINs. The notation #PC-
DATA stands for a “parsed character string”. In BNF notation, the grammar becomes
<PARTSLIST> ::5 <ITEM>0<ITEM><PARTSLIST>
<ITEM> ::5 <PARTNUMBER> <USEDINLIST>
<PARTNUMBER> ::5 <identifier>
<USEDINLIST>::5l0 <USEDIN>0<USEDIN><USEDINLIST>
<USEDIN> ::5 <MAKE><MODEL>
<MAKE>::5 <identifier>
<MODEL ::5 <identifier>
<identifier> ::5 [as defined in Example 55]
2 “Panini-Backus Form Suggested,” Ingerman, P. Z ., Communications of the ACM, vol. 10, No. 3, 1967.

Section 9.5   Formal Languages	
789
The preceding grammar allows the erasing productions F S l and A S l. 
To generate any language containing l, we have to be able to erase somewhere. In 
the following grammar types, we will limit erasing, if it occurs at all, to a single 
production of the form S S l, where S is the start symbol; if this production oc-
curs, we will not allow S to appear on the right-hand side of any other productions. 
This restriction allows us to crank out l from S as a special case and then get on 
with other derivations, none of which allow any erasing. Let’s call this the erasing 
convention. The following definition defines three special types of grammars by 
further restricting the productions allowed.
A Web browser parses the XML document to determine whether it is a valid in-
stance of the language defined by its associated DTD, and if so, displays it.	
Classes of Grammars
Before we identify some types of grammars, let’s look at one more example.
	
Example 57	
Let L be the empty string l together with the set of all strings consisting of an 
odd number n of 0s, n ≥3. The grammar G = (V, VT, S, P) generates L where 
V = 50, A, B, E, F, W, X, Y, Z, S6, VT = 506, and the productions are
S S  FA
0X S  X0
0Z S  Z0
S S  FBA
Y0 S 0Y
WBZ S  EB
FB S  F0EB0
FX S  F0W
F S l
EB S 0
YA S  Z0A
A S l
EB S  XBY
W0 S 0W
The derivation S 1 FA 1* ll = l produces l. The derivation
S 1 FBA
 1 F0EB0A
 1 F0XBY0A
	
 1
* FX0B0YA
 1
* F0W0B0Z0A
 1
* F00WBZ00A
 1 F00EB00A
 1 F00000A
	
 1
* 00000
produces five 0s. Notice how X and Y, and also W and Z, march back and forth 
across the strings of 0s, adding one more 0 on each side. This activity is highly 
reminiscent of a Turing machine read-write head sweeping back and forth across 
its tape and enlarging the printed portion.	
REMINDER
The erasing convention 
says how to do erasing 
IF erasing is to be done. 
It does not require the 
production S S l in every 
grammar.

790	
Modeling Arithmetic, Computation, and Languages
	
Definitions	
Context-Sensitive, Context-Free, and Regular Grammars; 
Chomsky Hierarchy
A grammar G is context-sensitive (type 1) if it obeys the erasing convention and 
if, for every production a S b (except S S l), the word b is at least as long as 
the word a. A grammar G is context-free (type 2) if it obeys the erasing conven-
tion and for every production a S b, a is a single nonterminal. A grammar G 
is regular (type 3) if it obeys the erasing convention and for every production 
a S b (except S S l), a is a single nonterminal and b is of the form t or tW, 
where t is a terminal symbol and W is a nonterminal symbol. This hierarchy of 
grammars, from type 0 to type 3, is called the Chomsky hierarchy.
In a context-free grammar, a single nonterminal symbol on the left of a 
production can be replaced wherever it appears by the right side of the pro-
duction. In a context-sensitive grammar, a given nonterminal symbol can per-
haps be replaced only if it is part of a particular string (context)—hence the 
names context-free and context-sensitive. It is clear that any regular grammar 
is also context-free, and any context-free grammar is also context-sensitive. 
The grammar of Example 49 is regular (the two productions have the single 
nonterminal S on the left, and on the right either 1—a terminal—or 0S—a ter-
minal followed by a nonterminal). Both grammars of Example 51 are context-
free but not regular (again the single nonterminal S appears on the left of all 
productions, but the right sides consist of three symbols or two nonterminals 
or two terminals, respectively). The grammar of Example 52 is context-sensi-
tive but not context-free (the productions do not shrink any strings, but some 
left sides have multiple symbols). The grammars of Example 53 and Example 
54 are context-free but not regular (for example, the first three productions of 
Example 54 violate the requirement for a regular grammar). Finally, the gram-
mar of Example 57 is a type 0 grammar, but it is not context-sensitive (for 
example, the production EB S 0 is a “shrinking” production; also, the erasing 
convention is violated).
	
Definition	
Language Types
A language is type 0 (context-sensitive, context-free, or regular) if it can be 
generated by a type 0 (context-sensitive, context-free, or regular) grammar.
Because of the relationships among the four grammar types, we can classify 
languages as shown in Figure 9.26. Thus, any regular language is also context-free 
because any regular grammar is also a context-free grammar, and so on. However, 
although it turns out to be true, we do not know from what we have done that these 
sets are properly contained in one another. For example, the language L described 
in Example 57 was generated in that example by a grammar that was type 0 but 
not context-sensitive, but that does not imply that L itself falls into that category. 
Different grammars can generate the same language.

Section 9.5   Formal Languages	
791
Regular
Context-free
Context-sensitive
Type 0
Formal Language Hierarchy 
Figure 9.26
	
Definition	
Equivalent Grammars
Two grammars are equivalent if they generate the same language.
	
	
Example 58	
Example 57 gave a grammar G to generate a language L, which is l together with all 
odd-length strings of 0s of length at least 3. We will now give three more grammars 
equivalent to G. (See if you agree that each of these grammars also generates L.)
G1 = (V, VT, S, P) where V = 50, A, B, S6, VT = 506, and the productions are
	
S S l	
AB S 00
	
S S ABA	
0A S 000A
	
	
A S 0
G1 is context-sensitive but not context-free.
G2 = (V, VT, S, P) where V = 50, A, S6, VT = 506, and the productions are
	
S S l	
A S 00A
	
S S 00A	
A S 0
G2 is context-free but not regular.
G3 = (V, VT, S, P) where V = 50, A, B, C, S6, VT = 506, and the productions 
are
	
S S l	
B S 0
	
S S 0A	
B S 0C
	
A S 0B	
C S 0B
G3 is regular.
Thus, when all is said and done, L is a regular language.	

792	
Modeling Arithmetic, Computation, and Languages
This is a somewhat confusing point and worth repeating. Because a given 
language can be generated by multiple grammars, if you find a grammar G for a 
language L that is type x but not type y, that does not necessarily make L type x 
but not type y. There might be a different grammar that also generates L and is a 
type y grammar.
Formal Languages and Computational Devices
The language L of Example 57 can be described by the regular expression  
l ~  (000)(00)*, so L is a regular set. From Example 58, L is also a regular language. 
It is not coincidental that a regular set turned out to be a regular language. It can be 
shown that for any finite-state machine, the set it recognizes is a regular language. It 
can also be shown that for any regular language, there is a finite-state machine that 
recognizes exactly that language. (In the proofs of these results, the productions of a 
regular grammar correspond to the state transitions of a finite-state machine.) Hence 
those sets recognized by finite-state machines—the regular sets—correspond to 
regular languages. Therefore the class of sets recognized by a computational device 
of limited capacity coincides with the most restricted class of languages.
On the other end of the spectrum, the most general computational device is 
the Turing machine and the most general language is a type 0 language. As it 
happens, the sets recognized by Turing machines correspond to type 0 languages.
There are computational devices with capabilities midway between those of 
finite-state machines and those of Turing machines. These devices recognize ex-
actly the context-free languages and the context-sensitive languages, respectively.
The type of device that recognizes the context-free languages is called a 
pushdown automaton, or pda. A pda consists of a finite-state unit that reads 
input from a tape and controls activity in a stack. Symbols from some alphabet 
can be pushed onto or popped off of the top of the stack. The finite-state unit in a 
pda, as a function of the input symbol read, the present state, and the top symbol 
on the stack, has a finite number of possible next moves. The moves are of the 
following types:
	
1.	 Go to a new state, pop the top symbol off the stack, and read the next input 
symbol.
	
2.	 Go to a new state, pop the top symbol off the stack, push a finite number 
of symbols onto the stack, and read the next input symbol.
	
3.	 Ignore the input symbol being read, manipulate the stack as above, but do 
not read the next input symbol.
A pda has a choice of next moves, and it recognizes the set of all inputs for which 
some sequence of moves exists that causes it to empty its stack. It can be shown 
that any set recognized by a pda is a context-free language, and conversely.
The type of device that recognizes the context-sensitive languages is called a 
linear bounded automaton, or lba. An lba is a Turing machine whose read-write 
head is restricted to a portion of the tape that is no longer than a constant multiple 
of the length of the original input; in addition, at each step it has a choice of pos-
sible next moves. An lba recognizes the set of all inputs for which some sequence 
Practice 65	 Give the derivation of 00000 in G1, G2, and G3.
■

Section 9.5   Formal Languages	
793
of moves exists that causes it to halt in a final state. Any set recognized by an lba 
can be shown to be a context-sensitive language, and conversely.
Figure 9.27 shows the relationship between the hierarchy of languages and the 
hierarchy of computational devices.
C
o
n
t
e
x
t
-
f
r
e
e
r
e
c
o
g
n
i
z
e
d
b
y
p
d
a
C
o
n
te
x
t-
s
e
n
si
ti
v
e
r
e
c
o
g
n
iz
e
d
b
y
l
b
a
T
y
p
e
0
re
c
o
g
ni
ze
d
b
y
T
ur
in
g
m
ac
hi
n
e
Regular
recognized by
finite-state machine
Figure 9.27
Context-Free Grammars
Context-free grammars are important for three reasons. Context-free grammars 
seem to be the easiest to work with, since they allow replacing only one symbol at 
a time. Furthermore, many programming languages are defined such that sections 
of syntax, if not the whole language, can be described by context-free grammars. 
Finally, a derivation in a context-free grammar has a nice graphical representation 
called a parse tree.
	
Example 59	
The grammar of Example 54 is context-free. The word d2q can be derived  
as follows: identifier 1 identifier letter 1 identifier digit letter 1 letter digit
 letter 1 d digit letter 1 d2 letter 1 d2q. We can represent this derivation as a 
tree with the start symbol for the root. When a production is applied to a node, that 
node is replaced at the next lower level of the tree by the symbols in the right-hand 
side of the production used. A tree for the derivation appears in Figure 9.28.
Figure 9.28

794	
Modeling Arithmetic, Computation, and Languages
Suppose that a context-free grammar G describes a programming language. 
The programmer uses the rules of G to generate legitimate strings of symbols, 
that is, words in the language. Here we may think of a word as corresponding to 
a program instruction. Thus, a word consists of various subwords, for example, 
identifiers, operators, and key words for the language. The program instructions 
are fed into the compiler for the language so that the program can be translated 
into machine language code for the computer. The compiler must decide whether 
each program instruction is legitimate in the language. In a sense, the compiler 
has to undo the process that the programmer used to construct the statement; that 
is, the compiler must start with the statement and decompose it to see whether it 
follows the rules of the language. This really entails two questions: Are the sub-
words themselves legitimate strings? Is the program instruction a legitimate way 
of grouping the subwords together?
	 Usually the set of legitimate subwords of a language can be described by a 
regular expression, and then a finite-state machine can be used to detect the sub-
words; the lexical analysis or scanner portion of the compiler handles this phase of 
compilation. (See Exercise 32 of Section 9.3 for the lexical analysis of ScrubOak.) 
If all goes well, the scanner then passes the program instruction, in the form of a 
string of legitimate subwords, to the syntax analyzer. The syntax analyzer deter-
mines whether the string is correct by trying to parse it (construct its parse tree).
	 Various parsing techniques, which we won’t go into, have been devised. 
Given a string to be tested, one approach is to construct a tree by beginning with 
the start symbol, applying productions (keeping an eye on the “goal”—the given 
string) and ending with the goal string. This procedure is called top-down pars-
ing. The alternative is to begin with the string, see what productions were used 
to create it, apply productions “backwards,” and end with the start symbol. This 
process is called bottom-up parsing. The trick to either approach is to decide 
exactly which productions should be used.
Practice 66	 Draw a parse tree for the word m34s in the grammar of Example 54.
■
	
Example 60	
Consider the context-free grammar G given by G = (V, VT, S, P) where 
V = 5a, b, c, A, B, C, S6, VT = 5a, b, c6, and the productions are
	
S S B	
B S C	
A S abc
	
S S A	
B S ab	
C S c
Suppose we want to test the string abc. A derivation for abc is S 1 A 1 abc. 
If we try a top-down parse, we might begin with
S
B
Then we have to detect that this will not work and try something else. If we try a 
bottom-up parse, we might begin with

Section 9.5   Formal Languages	
795
BC
abc
Then we have to detect that this will not work and try something else. Parsing tech-
niques automate this process and attempt to minimize the amount of false starts 
and backtracking required.	
Notice the distinction between generating members of a set, which the pro-
grammer does, and deciding membership in a set, which the compiler does. Since 
we ask the compiler to decide membership in a set, a decision algorithm must exist 
for the set. It turns out that decision algorithms do exist for context-free languages, 
another point in their favor.
S e c t i o n  9 . 5 	
Review
Techniques
•	 Describe L(G) for a given grammar G.
•	 Define a grammar to generate a given language L.
•	 Construct parse trees in a context-free grammar.
Main Ideas
•	 A grammar G is a generating mechanism for its lan-
guage L(G).
•	 Formal languages were developed in an attempt to 
describe correct syntax for natural languages; al-
though this attempt has largely failed because of the 
complexity of natural languages, it has been quite 
successful for high-level programming languages.
W
Exercises 9.5
	 1.	 Describe L(G) for the grammar G = (V, VT, S, P) where V = 5a, A, B, C, S6, VT = 5a6, and P consists of
	
S S A	
B S A
	
A S BC	
aC S l
	
A S a
	
	 What type of grammar is this?
	 2.	 Describe L(G) for the grammar G = (V, VT, S, P) where V = 50, 1, A, B, S6, VT = 50, 16, and P consists of
	
S S 0A	
A S 1BB	
B S 01
	
S S 1A	
	
B S 11
	
	 What type of grammar is this?
•	 Special classes of grammars are defined by restrict-
ing the allowable productions.
•	 The various types of formal languages correspond 
to the sets recognized by various automata; in par-
ticular, (1) regular languages are the sets recognized 
by finite-state machines, (2) context-free languages 
are the sets recognized by pushdown automata,  
(3) context-sensitive languages are the sets recog-
nized by linear bounded automata, and (4) type 0 
languages are the sets recognized by Turing ma-
chines.
•	 Derivations in context-free grammars can be illus-
trated by parse trees.
•	 A compiler for a context-free programming lan-
guage checks correct syntax by parsing.

796	
Modeling Arithmetic, Computation, and Languages
	 3.	 Describe L(G) for the grammar G = (V, VT, S, P) where V = 50, 1, A, B, S6, VT = 50, 16, and P consists of
	
S S 0	
 A S 1B	
B S 0A
	
S S 0A	
		
B S 0	
	
	 What type of grammar is this?
	 4.	 Describe L(G) for the grammar G = (V, VT, S, P) where V = 50, 1, A, S6, VT = 50, 16, and P consists of
	
S S 0S	
A S 1A
	
S S 11A	
A S 1
	
	 What type of grammar is this?
	 5.	 Find a regular grammar that generates the language of Exercise 1.
	 6.	 Find a regular grammar that generates the language of Exercise 2.
	 7.	 Find a regular grammar that generates the language of Exercise 3.
	 8.	 Find a regular grammar that generates the language of Exercise 4.
	 9.	 Describe L(G) for the grammar G = (V, VT, S, P) where V = 5a, b, A, B, S6, VT = 5a, b6, and P consists of
S  S aA
S  S l
A S bS
	 10.	Describe L(G) for the grammar G = (V, VT, S, P) where V = 50, 1, A, S6, VT = 50, 16, and P consists of
S  S 0
S  S ASA
A S 1
	 11.	Describe L(G) for the grammar G = (V, VT, S, P) where V = 5a, b, A, B, S6, VT = 5a, b6, and P consists of
	
S S AB	
AB S AAB
	
A S a	
 AB S ABB
	
B S b
	
	 What type of grammar is G? Find a regular grammar G′ that generates L(G).
	 12.	Describe L(G) for the grammar G = (V, VT, S, P) where V = 5a, b, c, A, B, C, R, T, S6, VT = 5a, b, c6, 
and P consists of
	
S S ARBT	
T S cT
	
R S ARB	
T S c
	
RB S ACBB	
A S a
	
CB S BC	
B S b
	
CT S cT
	
	 What type of grammar is G? Find a context-free grammar G′ that generates L(G). Explain why it is not 
possible to find a regular grammar that generates L(G).

Section 9.5   Formal Languages	
797
	 13.	Write the productions of the following grammars in BNF:
	
a.	 G in Exercise 2
	
b.	G in Exercise 3
	
c.	 G in Exercise 4
	 14.	Write the productions of the following grammars in BNF:
	
a.	 G in Exercise 10
	
b.	G3 in Example 58
	 15.	A grammar G is described in BNF as
<S> ::= 101<S>0<S> 00
	
a.	 Find a regular expression for L(G).
	
b.	Find a regular grammar for L(G).
	 16.	A grammar G is described in BNF as
<S> ::= 0100<S>0<S> 1
	
a.	 Find a regular expression for L(G).
	
b.	Find a regular grammar for L(G).
	 17.	Find a grammar that generates the set of all strings of well-balanced parentheses.
	 18.	English words are translated into “pig latin” by the following two rules:
	
1.	If a word begins with a vowel, add the suffix “yay”.
	
2.	If a word begins with a string of one or more consonants, move the string of leading consonants to the 
back of the word and then add the suffix “ay”.
	
a.	 What is the pig latin translation of the word “apple”?
	
b.	What is the pig latin translation of the word “monkey”?
	
c.	 What is the pig latin translation of the word “chain”?
	
d.	Find a grammar that generates all legal pig latin words.
	
e.	 Using your grammar from part d, generate the pig latin word that was the answer to part c.
	 19.	A word w in V* is a palindrome if w = w R, where w R is the reverse of the string w. A language L is a 
palindrome language if L consists entirely of palindromes. Find a grammar that generates the set of all 
palindromes over the alphabet 5a, b6.
	 20.	a.	 Let L be a palindrome language (see Exercise 19). Prove that LR = 5wR
 0  w [ L6 is a palindrome  
language.
	
b.	Let w be a palindrome. Prove that the language described by the regular expression w* is a palindrome 
language.
	 21.	Find a regular grammar that generates the language L = 11(0 ~ 1)*.
	 22.	Find a regular grammar that generates the language L = (0 ~ 1)*01.
	 23.	Find a grammar that generates the language L = 512n
 0  n ≥06.
	 24.	Find a regular expression for the language of Exercise 23. Is your grammar from Exercise 23 regular? If 
not, write a regular grammar that generates L.
	 25.	Find a context-free grammar that generates the language L = 50n1n
 0  n ≥06.

798	
Modeling Arithmetic, Computation, and Languages
	 26.	Find a context-free grammar that generates the language L = 5wwR
 0  w [ 50, 16* and wR is the reverse of 
the string w}.
	 27.	Find a context-free grammar that generates the language L where L consists of the set of all nonempty 
strings of 0s and 1s with an equal number of 0s and 1s.
	 28.	Find a context-free grammar that generates the language L where L consists of the set of all nonempty 
strings of 0s and 1s with twice as many 0s as 1s.
	 29.	Find a grammar that generates the language L = 502i
 0  i ≥06.
	 30.	Find a grammar that generates the language L = 50n12n0n
 0  n ≥06.
	 31.	Find a grammar that generates the language L = 5ww 0  w [ 50, 16*6.
	 32.	Find a grammar that generates the language L = 5an2
 0  n ≥16. (By Exercise 38, L is not a context-free 
language, so your grammar cannot be too simple.)
	 33.	Draw parse trees for the following words:
	
a.	 111111 in the grammar G of Example 51
	
b.	111111 in the grammar G′ of Example 51
	 34.	Draw parse trees for the following words:
	
a.	 011101 in the grammar G of Exercise 2
	
b.	00111111 in the grammar G of Exercise 4
	 35.	Consider the context-free grammar G = (V, VT, S, P) where V = 50, 1, A, S6, VT = 50, 16, and P 
consists of
S  S A1A
A S 0
A S A1A
	
	 Draw two distinct parse trees for the word 01010 in G. A grammar in which a word has more than one 
parse tree is ambiguous.
	 36.	Ambiguity in a grammar (see Exercise 35) that describes a programming language is an undesirable trait 
because the compiler is unable to uniquely parse the programming instruction. Ambiguity in a natural 
language can be similarly confusing. The following two instructions were posted beside an escalator.
“Shoes must be worn.”
“Dogs must be carried.”
	
	 Give two possible interpretations for each instruction.
	 37.	Show that for any context-free grammar G there exists a context-free grammar G′ in which for every 
production a S b, b is a longer string than a, L(G′) # L(G) and L(G) −L(G′) is a finite set.
	 38.	Following is the pumping lemma for context-free languages. Let L be any context-free language. Then 
there exists some constant k such that for any word w in L with 0w0 ≥k, w can be written as the string 
w1w2w3w4w5 with 0w2w3w40 ≤k and 0w2w40 ≥1. Furthermore, the word wlw2
iw3w4
iw5 [ L for each i ≥0.
	
a.	 Use the pumping lemma to show that L = 5anbncn
 0  n ≥16 is not context-free.
	
b.	Use the pumping lemma to show that L = 5an2
 0  n ≥16 is not context-free.

C h a p t e r  9 	
Review
Terminology
addition modulo n (p. 692)
alphabet (pp. 694, 782)
alternating group (p. 701)
associative binary operation  
(p. 687)
Backus Naur form (BNF) (p. 787)
bottom-up parsing (p. 794)
cancellation laws (p. 696)
canonical parity-check matrix  
(p. 721)
check bits in a code word (p. 721)
Chomsky hierarchy (p. 790)
coefficient (p. 690)
commutative binary operation  
(p. 687)
commutative group (p. 688)
concatenation (p. 694)
context-free (type 2) grammar  
(p. 790)
context-free language (p. 790)
context-sensitive (type 1) 
grammar (p. 790)
context-sensitive language  
(p. 790)
coset leader (p. 723)
cosets of a subgroup in a group  
(p. 717)
decision problem (p. 772)
degree of a polynomial (p. 691)
delay element (p. 744)
direct generation (derivation) of a 
word (p. 784)
double-error detecting code  
(p. 715)
empty string (p. 694) 
equivalent grammars (p. 791)
equivalent states (p. 739)
erasing convention (p. 789)
even and odd permutations  
(p. 700)
final state (pp. 734, 765)
finite-state machine (p. 729)
formal language (p. 785)
free monoid generated by a set A 
(p. 695)
generation (derivation) of a word 
(p. 784)
group (p. 688)
group code (p. 719)
group of permutations on a set A 
(p. 693)
halting problem (p. 774)
Hamming distance (p. 718)
homomorphism (p. 702)
identity element (p. 687)
improper subgroup (p. 700)
information bits in a code word 
(p. 721)
input alphabet (p. 729)
intractable problem (p. 776)
inverse element (p. 687)
isomorphism (p. 702)
k-equivalent states (p. 739)
kernel of a homomorphism  
(p. 716)
language (p. 782)
language generated by a  
grammar G (p. 784)
left cancellation law (p. 696)
left cosets (p. 717)
length of a string (p. 694)
linear bounded automaton (lba) 
(p. 792)
maximum likelihood decoding  
(p. 715)
minimum distance of a code  
(p. 718)
monoid (p. 689)
multiplication modulo n (p. 692)
negative solution to a decision 
problem (p. 772)
next-state function (p. 729)
nondeterministic Turing machine 
(p. 777)
NP (p. 777)
NP-complete problem (p. 778)
number-theoretic function (p. 767)
order of a group (p. 698)
output alphabet (p. 729)
output function (p. 729)
P (p. 777)
parse tree (p. 793)
partial function (p. 767)
partition refinement (p. 741)
perfect code (p. 722)
permutation group (p. 700)
phrase-structure (type 0) grammar 
(p. 783)
polynomial in x with real number 
coefficients (polynomial in x 
over R) (p. 690)
polynomial of zero degree (p. 691)
positive solution to a decision 
problem (p. 772)
production (p.783)
proper subgroup (p. 700)
pushdown automaton (pda)  
(p. 792)
recognition by a finite-state 
machine (p. 734)
recognition (acceptance) by a 
Turing machine (p. 765)
refinement (p.741)
regular expression (p. 735)
regular (type 3) grammar (p. 790)
regular language (p. 790)
regular set (p. 736)
right cancellation law (p. 696)
right cosets (p. 717)
semigroup (p. 689)
semigroup of transformations on a 
set A (p. 693)
sequential network (p. 745)
single-error correcting code  
(p. 715)
start symbol (p. 783)
state graph (p. 730)
state table (p. 730)
string (p. 694)
subgroup (p. 699)
symbol (p. 694)
symmetric group of degree n  
(p. 693)
syndrome of a binary n-tuple in a 
group code (p. 724)
	
	
Chapter 9   Review	
799

800	
Modeling Arithmetic, Computation, and Languages
tape alphabet (p. 762)
terminal (p. 783)
top-down parsing (p. 794)
total function (p. 767)
transposition (p. 700)
Turing-computable function  
(p. 768)
Turing machine (p. 762)
type 0 language (p. 790)
unreachable state (p. 737)
unsolvable (undecidable) decision 
problem (p. 772)
vocabulary (p. 782)
weight of a code word (p. 719)
word (pp. 694, 782)
Self-Test
Answer the following true–false questions.
Section 9.1
1.	A binary operation is associative if the order of the 
elements being operated upon does not matter.
2.	The identity i in a group 3G, #4 has the property that 
x−1 # i = i # x−1 = x−1 for all x in G.
3.	Every group is also a monoid.
4.	A group of order 10 cannot have a subgroup of  
order 6.
5.	If 3S, #4 and 3T, +4 are two groups, then a function 
f: S S T for which f (x # y) = f (x) + f ( y) is an 
isomorphism.
Section 9.2
1.	A binary single-error correcting code must have 
minimum distance at least 3.
2.	In a canonical n × r parity-check matrix H, the 
bottom r rows form the r × r identity matrix.
3.	A canonical n × r parity-check matrix H maps all 
of Zm
2  to code words in Zn
2.
4.	If the syndrome of a received word X in Zn
2 is 0r, 
then X is assumed to be a code word.
5.	A perfect code is “perfect” because no bit errors 
will occur during transmission.
Section 9.3
1.	The next state of a finite-state machine is determined 
by its present state and the present input symbol.
2.	The set of all binary strings ending in two 0s is 
regular.
3.	A finite-state machine cannot get to a state from 
which there is no exit.
4.	According to Kleene’s theorem, a set that cannot be 
described by a regular expression cannot be recog-
nized by a finite-state machine.
5.	In a finite-state machine, k-equivalent states are 
also (k + 1)-equivalent.
Section 9.4
1.	A Turing machine halts if and only if it enters a 
final state.
2.	A Turing machine that computes the function 
f (n) = n + 1, given input n, will halt with (n + 1) 
1s on its tape.
3.	Church’s thesis says that the halting problem is  
unsolvable.
4.	The halting problem says that, given a Turing ma-
chine and its input, there is no algorithm to decide 
whether the Turing machine halts when run on that 
input.
5.	A set in P is recognizable by a Turing machine in 
no more than a polynomial number of steps.
Section 9.5
1.	The language generated by a type 0 grammar G is 
the set of all strings of terminals generated from the 
start symbol by applying G’s productions a finite 
number of times.
2.	Beginning at the start symbol and applying the 
productions of a grammar G eventually leads to a 
string of terminals.
3.	A language generated by a grammar that is context-
sensitive but not context-free is a context-sensitive 
but not context-free language.
4.	Any regular set is a regular language.
5.	A parse tree will have as many leaves as terminal 
symbols in the word being derived.

O n  t h e  C o m p u t e r
For Exercises 1–11, write a computer program that 
produces the desired output from the given input.
1.	Input: Two words from an alphabet A
	
Output: Their concatenation
2.	Input: Positive integer n and finite alphabet A
	
Output: All words over A of length ≤n
3.	Input: Positive integer n
	
Output: Tables for addition and multiplication 
modulo n
4.	Input: Positive integer n
	
Output: The n! elements of Sn expressed both in 
­array form and in cycle notation, the group table for 
3Sn, +4, and the group table for 3An, +4
5.	Input: n × n array, n ≤10, that purports to repre-
sent a binary operation on the finite set of integers 
from 1 to n
	
Output: Determination of whether the set under this 
operation is a commutative group
6.	Input: Two n × n arrays, n ≤10, that represent 
two groups and an array that represents a function 
from the first group to the second
	
Output: Determination of whether the function is 
an isomorphism
7.	Input: A canonical n × r parity-check matrix H 
for a single-error correcting code with r ≤4 and 
n ≤2r−1
	
Output: The set of binary m-tuples H encodes and 
the code word for each one
8.	Input: A canonical parity-check matrix for a perfect 
single-error correcting code where r ≤5 and any 
binary n-tuple X
	
Output: The binary n-tuple to which X is decoded
9.	Input: Positive integer n, n ≤50, representing the 
number of states of a finite-state machine with in-
put alphabet = output alphabet = 50, 16 and an 
n × 3 array representing the state table description 
of such a machine
	
Output: List of any states unreachable from the 
start state s0
10.	 Input: Positive integer n, n ≤50, representing 
the number of states of a finite state machine with 
input alphabet = output alphabet =50, 16 and an 
n × 3 array representing the state table descrip-
tion of such a machine
	
Output: m × 3 array representing the state table 
of a minimized version of M
11.	 Input: Set of terminals in a grammar and a de-
scription of the productions in a grammar; ability 
for the user to set a maximum number of steps for 
any derivation
	
Output: List of words in the language that can be 
derived within that maximum
12.	 Write a finite-state machine simulator. That is, 
­given
•	a positive integer n, n ≤50, representing the 
number of states of a finite state machine with 
input alphabet = output alphabet = 50, 16
•	an n × 3 array representing the state table 
description of such a machine
	
your program should request input strings and 
write the corresponding output strings as long as 
the user wishes.
13.	 Write a Turing machine simulator. That is, given 
a set of quintuples describing a Turing machine, 
your program should request the initial tape con-
tents and write out a sequence of successive tape 
configurations. Assume that there are at most 100 
quintuples and that the number of cells used on 
the tape is at most 70, and allow the user to set a 
maximum number of steps in case the computa-
tion does not halt before then
	
	
Chapter 9   Review	
801

This page intentionally left blank 

Equivalence Rules
Expression
Equivalent to
Name/Abbreviation for Rule
P ~  Q
P `  Q
Q ~  P
Q `  P
Commutative—comm
(P ~  Q) ~  R
(P `  Q) `  R
P ~  (Q ~  R)
P `  (Q `  R)
Associative—ass
(P ~ Q)′
(P ` Q)′
P′ `  Q′
P′ ~  Q′
De Morgan’s laws—De Morgan
P S Q
P′ ~  Q
Implication—imp
P
(P′)′
Double negation—dn
3(Ex)A(x)4′
(4x)3A(x)4′
Negation—neg
Inference Rules
From
Can Derive 
Name/Abbreviation for Rule
P, P S  Q
Q
Modus ponens—mp
P S Q, Q′
P′
Modus tollens—mt
P, Q
P `  Q
Conjunction—con
P `  Q
P, Q
Simplification—sim
P
P ~ Q
Addition—add
P S Q, Q S R
P S R
Hypothetical syllogism—hs
P ~  Q, P′
Q
Disjunctive syllogism—ds
P S Q
Q′ S P′
Contraposition—cont
Q′ S P′
P S Q
Contraposition—cont
P
P `  P
Self-reference—self
P ~  P
P
Self-reference—self
(P `  Q) S R
P S (Q S R)
Exportation—exp
P, P′
Q
Inconsistency—inc
P `  (Q ~  R)
(P `  Q) ~  (P `  R)
Distributive—dist
P ~  (Q `  R)
(P ~  Q) `  (P ~ R)
Distribution—dist
803
Derivation Rules for Propositional 
and Predicate Logic
A
Appendix

804	
Derivation Rules for Propositional and Predicate Logic
Inference Rules (continued)
From
Can Derive 
Name/Abbreviation for Rule
Restrictions on Use
(4x)P(x)
P(t), where t 
is a variable 
or constant 
symbol
Universal instantiation—ui
If t is a variable, it 
must not fall within 
the scope of a 
quantifier for t.
(Ex)P(x)
P(a) where a 
is a constant 
symbol not 
previously 
used in proof 
­sequence
Existential instantiation—ei
Must be the first rule 
used that introduces 
a.
P(x)
(4x)P(x)
Universal generalization—ug
P(x) has not been 
deduced from any 
hypotheses in which 
x is a free variable 
nor has P(x) been 
deduced by ei from 
any wff in which x is 
a free variable.
P(x) or P(a) 
where a is 
a constant 
symbol
(Ex)P(x)
Existential generalization—eg
To go from P(a) to 
(Ex)P(x), x must not 
appear in P(a).

Summation notation is a shorthand way of writing certain expressions that are 
sums of terms. As an example, consider the sum of the integers from 1 to 5:
1 + 2 + 3 + 4 + 5
This expression can be thought of in the following way: Suppose we have some 
quantity i that initially has the value 1 and then takes on successive values of 2, 3, 
4, and 5. The expression is the sum of i at all its different values. The summation 
notation is
∑
5
i=1
i
The uppercase Greek letter sigma, Σ, denotes summation. Here the number 1 is 
the lower limit of summation, and the number 5 is the upper limit of summation. 
The variable i is called the index of summation. The index of summation is ini-
tially set equal to the lower limit and then keeps increasing its value by 1 until it 
reaches the upper limit. All the values that the index of summation takes on are 
added together. Thus
∑
5
i=1
i = 1 + 2 + 3 + 4 + 5 = 15
Similarly
∑
3
i=1
i = 1 + 2 + 3 = 6
And
∑
8
i=4
i = 4 + 5 + 6 + 7 + 8 = 30
In these examples, the expression after the summation sign is just i, the in-
dex of summation. However, what appears after the summation sign can be any 
expression, and the successive values of the index are simply substituted into the 
expression. Thus
∑
5
i=1
i2 = 12 + 22 + 32 + 42 + 52 = 55
Summation and Product Notation
B
Appendix
805

A way to symbolize summation in general is
∑
q
i=p
ai
Here the lower limit, upper limit, and expression behind the summation are not 
specifically given but merely symbolized. The notation ai is a reminder that the 
expression will be evaluated at the different values i takes on in going from the 
lower to the upper limit.
There are three special cases to consider:
	
1.	 ∑
q
i=p
0 = 0
Here the expression behind the summation is the constant 0, which has the value 
0 no matter what the value of the index of summation. The sum of any number of 
0s is 0.
	
2.	 ∑
n
i=1
1 = n
Here again the expression behind the summation is a constant, and the summation 
says to add n copies of 1, which results in n.
	
3.	 ∑
0
i=1
ai = 0
Here the upper limit is smaller than the lower limit; the usual interpretation of sum-
mation does not apply, but by convention the summation is assigned the value 0.
The index of summation is a dummy variable, meaning that it merely acts as a 
placeholder and that a different variable could be used without changing the value 
of the summation. Thus
∑
3
i=1
i = ∑
3
j=1
j = 6
It may be convenient to change the limits on a summation, which is legitimate 
as long as the final value of the summation remains the same. For example,
∑
3
i=1
i = ∑
2
i=0
(i + 1)
since both have the value
1 + 2 + 3 = 6
Finally, the following three rules hold, as we will see shortly.
806	
Summation and Product Notation

Summation and Product Notation	
807
Rules of Summation
	
1.	 ∑
q
i=p
(ai + bi) = ∑
q
i=p
ai + ∑
q
i=p
bi 
	
2.	 ∑
q
i=p
(ai −bi) = ∑
q
i=p
ai −∑
q
i=p
bi
	
3.	 ∑
q
i=p
cai = c∑
q
i=p
ai   	
where c is a constant
To prove rule 1, note that
	
ap + bp + ap+1 + bp+1 + c+ aq + bq
	
= ap + ap+1 + c+ aq + bp + bp+1 + c+ bq
because of the commutative property of addition. The proof of rule 2 is similar.
To prove rule 3, note that
cap + cap+1 + c+ caq = c(ap + ap+1 + c+ aq)
because of the distributive property. This rule allows a constant to be “moved 
through” a summation.
Sometimes a summation can be represented by an even shorter expression 
that does not involve adding separate terms. For example, according to Exercise 7 
of Section 2.2,
	
∑
n
i=1
i2 = n(n + 1)(2n + 1)
6
	
(1)
so that the value of ∑
5
i=1
i2 can be found by substituting the upper limit, 5, into the 
right side of (1), giving
5(5 + 1)(2*5 + 1)
6
= 55
as before. Section 2.2 and its exercises give a number of other “closed form” ex-
pressions for certain summations, all of them provable by mathematical induction.
Product notation is a shorthand way of writing certain expressions that are 
products of factors. Product notation is very similar to summation notation, except 
it uses the uppercase Greek letter pi, Π and the various items are multiplied rather 
than added. There is an index of multiplication, a lower limit, and an upper limit. 
For example,
q
7
i=3
i = (3)(4)(5)(6)(7) = 2520 

and
q
2
i=1
(2i + 5) = (2*1 + 5)(2*2 + 5) = (7)(9) = 63
Product notation occurs less often than summation notation, but there are still 
special cases to note:
	
1.	 q
q
i=p
0 = 0	
(the product of all 0s equals 0)
	
2.	 q
q
i=p
1 = 1	
(the product of all 1s equals 1)
808	
Summation and Product Notation

The logarithm function is closely related to the exponential function
y = bx
where b, the base, is a constant greater than 1. (Actually b can be any positive 
number, but the only interesting cases occur when b > 1.) Recall the following 
rules of exponents:
	
1.	 bnbm = bn+m	
(when you multiply, you add exponents)
	
2.	 bnbm = bn−m	
(when you divide, you subtract exponents)
	
3.	 (bn)m = bnm	
(when you raise a power to a power, you multiply 
exponents)
If we select a specific base, b = 2 for example, we can plot y = 2x for various 
values of x and fill in the remaining values, getting the graph
y = 2x
(3, 8)
(2, 4)
(1, 2)
(0, 1)
(–1, )
y
x
1_
2
In this function, x can take on any real value, and y will always be positive. An-
other way to say this is that the domain of the function is the set R of real numbers, 
and the range is the set R+ of positive real numbers.
The Logarithm Function
C
Appendix
809

810	
The Logarithm Function
A related function (in fact, the inverse function) is the logarithm function, 
defined by
	
 y = logb x	
meaning	
b y = x
Therefore log216 = 4, for example, because 24 = 16. These two equations are 
the logarithmic form and exponential form of the same fact. Similarly, log2 8 = 3 
and log2 2 = 1.
Following is a graph of y = log2 x.
y = log2 x
(1, 0)
(4, 2)
(2, 1)
(8, 3)
y
x
( , –1)
1_
2
Because the logarithm function y = logb x is the inverse of the exponential func-
tion, its domain (the values x can take on) is the set R+ of positive real numbers 
and the range (the values y can take on) is the set R of real numbers. The logarithm 
function for any base b > 1 has a domain, range, and shape similar to the case 
for b = 2.
Certain properties about the logarithm function are true either because 
of its definition or because of corresponding properties about the exponential 
function, We’ll list all the properties of the logarithm function, and then prove 
them.
Properties of the Logarithm Function y = logb x
	
1.	 If p < q then logb p < logb q	
(the log function is strictly increasing)
	
2.	 If logb p = logb q then p = q	
(the log function is one to one)
	
3.	 logb 1 = 0
	
4.	 logb b = 1
	
5.	 logb (b p) = p
	
6.	 blogb  p = p
	
7.	 logb (  pq) = logb p + logb q	
(the log of a product equals the sum of 
the logs)
	
8.	 logb ( pq) = logb  p −logb q	
(the log of a quotient equals the 
­difference of the logs)
	
9.	 logb ( pq) = q(logb p)	
(the log of something to a power 
equals the power times the log)
	
10.	 loga p = logb p logb a	
(change-of-base formula) 
	
11.	 plogb q = qlogb p

The Logarithm Function	
811
In proving the properties of the logarithm function, we first note that many of 
the properties involve the quantities logb p and logb q. Let us name these quantities 
r and s, respectively, so that
logb  p = r and logb  q = s
This in turn means that
br = p and bs = q
	
1.	 Because b > 1, the larger the power to which b is raised, the larger the ­result. 
Thus if p < q, then br < bs, so r < s and therefore logb  p < logb q.
	
2.	 If logb p = logb q, then r = s, so br =  bs and p = q.
	
3.	 logb 1 = 0 because b0 = 1.
	
4.	 logb b = 1 because b1 = b.
	
5.	 logb (b p) = p because (translating this equation to its exponential form) 
bp = bp.
	
6.	 blogb p = p because (translating this equation to its logarithmic form) 
logb p = logb p.
	
7.	 logb ( pq) = logb p + logb q = r + s because it is true that  
br+s = brbs = pq, which is the exponential form of the equation we are 
trying to prove.
	
8.	 logb ( pq) = logb p −logb q = r −s because it is true that  
br−s = brbs = pq which is the exponential form of the equation we are 
trying to prove.
	
9.	 logb ( pq) = q(logb p) = qr because it is true that bqr = (br)q = pq, which 
is the exponential form of the equation we are trying to prove.
	
10.	 loga p = logb plogb a
Let loga p = w. Then aw = p. Now take the logarithm to the base b of both 
sides of this equation:
logb(aw) = w(logb a) = logb p
or
w = logb plogba
which is the desired result.
	
11.	
 plogb q = qlogb p
 logb( plogb q) = (logb q)(logb p) by Property 9
 = (logb p)(logb q)
 = logb (qlogb p)  by Property 9
Therefore plogb q = qlogb p by Property 2
The three most useful bases for logarithms are
b = 10 (common logarithm)
b = e, e ∼2.7183 (natural logarithm)
b = 2 (what we use throughout this book)

812	
The Logarithm Function
Common logarithms were used as computational aids before calculators and 
computers became commonplace. Property 7 of the logarithm function says that 
to multiply two numbers, one can take the logarithm of each number, add the re-
sults, and then find the number with that logarithm value. Addition was easier than 
multiplication, and tables of common logarithms allowed one to look up a number 
and find its logarithm, or vice versa.
Natural logarithms are useful in calculus and are often written “ln p” rather than 
“loge p.” Base 2 logarithms are sometimes denoted by “lg p” rather than “log2 p.”  
In this book, all logarithms are base 2, so we use log p to denote log2 p.
A final inequality involving base 2 logarithms (used in Section 3.3) is
 1 + log n < n for n ≥3
To prove this, note that
 n < 2n−1 for n ≥3
so by property 1 of logarithms,
 log n < log2n−1
By property 5 of logarithms, log2n−1 = n −1. Therefore
 log n < n −1
or
 1 + log n < n for n ≥3

	
7.	 a.
A
B
A S  B
B S  A
(A S  B) 4 (B S  A)
T
T
T
T
T
T
F
F
T
F
F
T
T
F
F
F
F
T
T
T
Answers to Practice Problems
Note to student: Finish all parts of a practice problem before turning to the  
answers.
Chapter 1
	
1.	 False, false, false
	
2.	
A
B
A ~ B
T
T
T
T
F
T
F
T
T
F
F
F
	
3.	
A
B
A S  B
T
T
T
T
F
F
F
T
T
F
F
T
	
4.	
A
A′
T
F
F
T
	
5.	 a. Antecedent: The rain continues   Consequent: The river will flood
	
b.	Antecedent: The central switch goes down   Consequent: Network failure
	
c.	 Antecedent: The avocados are ripe   Consequent: They are dark and soft
	
d.	Antecedent: A healthy cat   Consequent: A good diet
	
6.	 Answer d. This is negation of A ` B, the same as the negation of “Peter is tall and thin.”
	
b.	
A
B
A′
B′
A ~ A′
B ` B′
(A ~ A′)  S  (B ` B′)
T
T
F
F
T
F
F
T
F
F
T
T
F
F
F
T
T
F
T
F
F
F
F
T
T
T
F
F
813

814	
Answers to Practice Problems
	
c.	
A
B
C
B′
A ~ B′
C′
(A ` B′)  S  C′
3(A ` B′)  S  C′ 4′
T
T
T
F
F
F
T
F
T
T
F
F
F
T
T
F
T
F
T
T
T
F
F
T
T
F
F
T
T
T
T
F
F
T
T
F
F
F
T
F
F
T
F
F
F
T
T
F
F
F
T
T
F
F
T
F
F
F
F
T
F
T
T
F
	
d.	
A
B
A′
B′
A S  B
B′  S  A′
(A S  B) 4 (B′  S  A′)
T
T
F
F
T
T
T
T
F
F
T
F
F
T
F
T
T
F
T
T
T
F
F
T
T
T
T
T
	
8.	
A
1
A′
A ~ A′
A ~ A′ 4 1
T
T
F
T
T
F
T
T
T
T
	
9.	 To prove (P S  Q)  4  (P′ ~  Q), just construct a truth table:
P
Q
P S  Q
P′
P′ ~ Q
(P S  Q) 4 (P′ ~ Q) 
T
T
T
F
T
T
T
F
F
F
F
T
F
T
T
T
T
T
F
F
T
T
T
T
	 10.	(A ` B′)′	
1, 2, mt
	 11.	 3(A ~  B′) S  C4 `  (C S  D) `  A S  D
	
1.	 (A ~  B′) S  C	
hyp
	
2.	 C S  D	
hyp
	
3.	 A	
hyp
	
4.	 A ~  B′	
3, add
	
5.	 C	
1, 4, mp
	
6.	 D	
2, 5, mp
	 12.	(A S  B) `  (B S  C ) S  (A S  C )
	
1.	 A S  B	
hyp
	
2.	 B S  C	
hyp
	
3.	 A	
hyp
	
4.	 B	
1, 3, mp
	
5.	 C	
2, 4, mp

Answers to Practice Problems	
815
	 13.	(A S  B) `  (C′ ~  A) `  C S  B
	
1.	 A S  B	
hyp
	
2.	 C′ ~  A	
hyp
	
3.	 C	
hyp
	
4.	 C S  A	
2, imp
	
5.	 C S  B	
1, 4, hs
	
6.	 B	
3, 5, mp
	 14.	The argument is (S S  R) `  (S′ S  B) S  (R′ S  B). A proof sequence is
	
1.	 S S  R	
hyp
	
2.	 S′ S  B	
hyp
	
3.	 R′	
hyp
	
4.	 S′	
1, 3, mt
	
5.	 B	
2, 4, mp
	 15.	a.	 True (all daffodils are yellow)
 
b. False (not true that all flowers are yellow)
 
c. True (all flowers are plants)
	
d.	False (zero is neither positive nor negative)
	 16.	For example:
	
a.	 The domain is the collection of licensed drivers in the United States; P(x) is the property that x is older 
than 14.
 
b. The domain is the collection of all fish; P(x) is the property that x weighs more than 3 pounds.
	
c.	 No; if all objects in the domain have property P, then (since the domain must contain objects) there is 
an object in the domain with property P.
	
d.	The domain is all the people who live in Boston; P(x) is the property that x is a male. (Not every person 
who lives in Boston is a male, but someone is.)
	 17.	Let x =  1; then x is positive and any integer less than x is ≤ 0, so the truth value of the statement is true. 
For the second interpretation, let A(x) be “x is even,” B(x, y) be “x <  y,” and C( y) be “y is odd”; the 
statement is false because no even integer has the property that all larger integers are odd.
	 18.	a.	 (4x)3S(x) S  I(x)4
	
b.	 (Ex)3I(x) `  S(x) `  M(x)4
	
c.	 (4x)(M(x) S  S(x) `  3I(x)4′)
	
d.	 (4x)(M(x) S  S(x) `  I(x))
	 19.	a.	 (Ex)3V(x) `  (4y)(F( y) S S(x, y))4
	
b.	 (4x)3F(x) S  (4y)(V( y) S  S(x, y))4
	
c.	 (4x)3F(x) S  (Ey)(V( y) `  S(x, y))4
	
d.	 (4x)(4y)3V( y) `  S(x, y) S  F(x)4
	 20.	Answer d. If L(x, y, t) means “x loves y at time t,” the original statement is
(4x)(Ey)(Et)L(x, y, t)

816	
Answers to Practice Problems
	
	 and the negation is
 3(4x)(Ey)(Et)L(x, y, t)4′ 4 (Ex)3(Ey)(Et)L(x, y, t)4′
 4 (Ex)(4y)3(Et)L(x, y, t)4′
 4 (Ex)(4y)(4t)3L(x, y, t)4′
	
	 or, “There is some person who, for all persons and all times, dislikes those persons at those times” or “Some-
body hates everybody all the time.” Answers (a) and (c) can be eliminated because they begin with a univer-
sal quantifier instead of an existential quantifier; answer (b) is wrong because “loves” has not been negated.
	 21.	Invalid. In the interpretation where the domain consists of the integers, P(x) is “x is odd” and Q(x) is “x 
is even,” the antecedent is true (every integer is even or odd), but the consequent is false (it is not the case 
that every integer is even or that every integer is odd).
	 22.	(4x)3P(x) S  R(x)4 `  3R( y)4′ S  3P( y)4′
	
1.	 (4x)3P(x) S  R(x)4	
hyp
	
2.	 3R( y)4′	
hyp
	
3.	 P( y) S  R( y)	
1, ui
	
4.	 3P( y)4′	
2, 3, mt
	 23.	(4x)3P(x) `  Q(x)4 S  (4x)3Q(x) `  P(x)4
	
1.	 (4x)3P(x) `  Q(x)4	
hyp
	
2.	 P(x) `  Q(x)	
1, ui
	
3.	 Q(x) `  P(x)	
2, comm
	
4.	 (4x)3Q(x) `  P(x)4	
3, ug
	 24.	(4y)3P(x) S  Q(x, y)4 S  3P(x) S  (4y)Q(x, y)4
	
1.	 (4y)3P(x) S  Q(x, y)4	
hyp
	
2.	 P(x)	
hyp
	
3.	 P(x) S  Q(x, y)	
1, ui
	
4.	 Q(x, y)	
2, 3, mp
	
5.	 (4y)Q(x, y)	
4, ug
	 25.	(4x)3(B(x) ~  C(x)) S  A(x)4 S  (4x)3B(x) S  A(x)4
	
1.	 (4x)3(B(x) ~  C(x)) S  A(x)4	
hyp
	
2.	 (B(x) ~  C(x)) S  A(x)	
1, ui
	
3.	 B(x)	
temporary hyp
		
4.  B(x) ~  C(x)	
3, add
		
5.  A(x)	
2, 4, mp
	
6.	 B(x) S  A(x)	
temporary hyp discharged
	
7.	 (4x)3B(x) S  A(x)4	
6, ug
	 26.	(Ex)R(x) `  3(Ex)3R(x) `  S(x)4 4′ S  (Ex)3S(x)4′
	
	 The argument is valid. If something has property R but nothing has both property R and property S, then 
something fails to have property S. A proof sequence is
	
1.	 (Ex)R(x)	
hyp
	
2.	 3(Ex)3R(x) `  S(x)4 4′	
hyp

Answers to Practice Problems	
817
	
3.	 (4x)3R(x) `  S(x)4′	
2, neg
	
4.	 R(a)	
1, ei
	
5.	 3R(a) `  S(a)4′	
3, ui
	
6.	 3R(a)4′ ~  3S(a)4′	
5, De Morgan
	
7.	 3 3R(a)4′4′	
4, dn
	
8.	 3S(a)4′ 	
6, 7, ds
	
9.	 (Ex)3S(x)4′	
8, eg
	 27.	The argument is (4x)3R(x) S  L(x)4 `  (Ex)R(x) S  (Ex)L(x)
	
1.	 (4x)3R(x) S  L(x)4	
hyp
	
2.	 (Ex)R(x)	
hyp
	
3.	 R(a)	
2, ei
	
4.	 R(a) S  L(a)	
1, ui
	
5.	 L(a)	
3, 4, mp
	
6.	 (Ex)L(x)	
5, eg
	 28.	deer grass (deer eat grass and grass is a plant)
	 29.	a.	 predator(X  ) <=  eat(X, Y )  and animal(Y )
	
b.	bear
 
 
fish
	
	
raccoon
	
	
bear
	
	
bear
	
	
fox
	
	
bear
	
	
wildcat
	 30.	Responses 7–9 result from in-food-chain(raccoon, Y ); responses 10 and 11 result from  
in-food-chain(fox, Y ); response 12 results from in-food-chain(deer, Y ).
	 31.	 x − 2 =  y, or x =  y +  2
	 32.	Working backwards from the postcondition using the assignment rule,
 5x +  4 =  76
y =  4
 5x +  y =  76
z =  x +  y
 5z =  76
	
	 The first assertion, x +
  4 =  7, is equivalent to the precondition, x =  3. The assignment rule, applied 
twice, proves the program segment correct.
	 33.	The two implications to prove are
 5x =  4 and x <  56 y =  x − 1 5 y =  36
5x =  4 and x ≥ 56 y =  7 5 y =  36

	
	 The first implication is true by the assignment rule. Working backwards from the postcondition,
	
5x − 1 =  36
	
y =  x − 1
	
5 y =  36
	
x − 1 =  3 4 x =  4 4 x =  4 and x <  5
	
	 The second implication is true because the antecedent is false. The program segment is correct by the 
conditional rule.
Chapter 2
	
1.	 Possible answers:
	
a.	 A whale
	
b.	The integer 4. Four is less than 10, but it is not bigger than 5.
	
2.	 a.	 Show that the conjecture is true for all cases:
n
n2
10 + 5n
1
1
15
2
4
20
3
9
25
4
16
30
5
25
35
	
b.	For n =  7, n2 is 49 but 10 +  5n is only 45.
	
3.	 Let x be divisible by 6. Then x =  6k where k is an integer, and 2x =  2(6k) =  12k =  4(3k). Since 3k is 
an integer, 2x is divisible by 4.
	
4.	 a. If the river will not flood, then the rain will not continue.
	
b.	If there is not a network failure, then the central switch does not go down.
	
c.	 If the avocados are not dark or not soft, then they are not ripe.
	
d.	If the diet is not good, the cat is not healthy.
	
5.	 a. If the river will flood, then the rain will continue.
	
b.	If there is network failure, then the central switch goes down.
	
c.	 If the avocados are dark and soft, then they are ripe.
	
d.	If the diet is good, then the cat is healthy.
	
6.	 Let x =  2m +  1 and y =  2n +  1 where m and n are integers, and assume that xy is even. Then
xy =  2k for some integer k
	
	 or
(2m +  1)(2n +  1) =  2k
	
	 Multiplying out the left side,
4mn +  2m +  2n +  1 =  2k
818	
Answers to Practice Problems

Answers to Practice Problems	
819
	
	 Rearranging terms in the equation,
1 =  2k − 4mn − 2m − 2n
	
	 Factoring out 2 on the right side,
 	
1 =  2(k − 2mn − m − n)	
where k − 2mn − m − n is an integer
	
	 This is a contradiction since 1 is not even.
	
7.	 P(1):  1 =  1(1 +  1)∙2, true
	
	 Assume P(k):  1 +  2 + c+  k =  k(k +  1)∙2
	
	 Show P(k + 1): 1 + 2 + c+ (k + 1) =? (k + 1)3(k + 1) + 14
2
	
	  1 + 2 + c+ (k + 1) = 1 + 2 + c+ k + (k + 1)
	
	
 = k(k + 1)
2
+ (k + 1) = (k + 1)ak
2 + 1b
	
	
 = (k + 1)ak + 2
2
b = (k + 1)3(k + 1) + 14
2
	
8.	 The base case is n = 2.
	
	 P(2):  22+1 < 32, or 8 < 9, true
	
	 Assume P(k):  2k+1 < 3k and k > 1
	
	 Show P(k + 1):  2k+2 <? 3k+1
 	
 2k+2 = 2(2k+1)
	
 < 2(3k
 )	
(by the inductive hypothesis)
	
 < 3(3k
 )	
(since 2 < 3)
	
 = 3k+1
	
9.	 a.	 To verify P(k + 1) in implication 2′, we subtract 3 from k + 1. For the inductive hypothesis to hold, it 
must be the case that (k + 1) −3 ≥8, so k + 1 must be ≥11. Therefore implication 2′ cannot be 
used to verify P(9) or P(10).
	
b.	The truth of P(k + 1) cannot be verified from the truth of P(k). For example, in trying to express 11 
as a sum of  3’s, and 5’s, knowing that 10 = 5 + 5 is no help. However, knowing that 8 = 3 + 5 is 
helpful because adding one more 3 gives 11 = 2 * 3 + 5.
	 10.	Q(0):  j0 = x + i0   true since j = x, i = 0 before the loop is entered
	
	 Assume Q(k):  jk = x + ik
	
	 Show Q(k + 1):  jk+1 =? x + ik+1
	
	  jk+1 = jk + 1
	
(by the assignment j = j + 1)
	
	
 = (x + ik) + 1	
(by inductive hypothesis)
	
	
 = x + (ik + 1)
	
	
 = x + ik+1
	
(by the assignment i = i + 1)
	
	 Upon loop termination, i = y and j = x + y.

	 11.	a.	 If d 0  a then a = n1d where n1 is a positive integer. If d 0  b then b = n2d where n2 is a positive integer. 
Therefore
c = ia + jb = i(n1d ) + j(n2d ) = (in1 + jn2)d
	
	
where in1 + jn2 is an integer and d 0  c.
	
b.	If d 0  c then c = nd where n ≥1 because both c and d are positive, so c ≥d.
	 12.	From the Euclidean algorithm to find gcd(21, 16),
	
1 = 16 −3 # 5
	
5 = 21 −1 # 16
	
	 from which
1 = 16 −3 # (21 −1 # 16) = 4 # 16 −3 # 21
	
	 so i = −3, j = 4.
	 13.	Do a proof by mathematical induction.
	
	 Base case: (k = 1). If p 0  a1 then p 0  a1
	
	 Assume that if p 0  a1a2…ak then p 0  aj for some j, 1 ≤j ≤k
	
	 Let p 0  a1a2 … akak+1 = (a1a2 … ak)ak+1. Using the theorem on division by prime numbers,  
either p 0  a1a2 … ak or p 0  ak+1. If p 0  a1a2 … ak then by the assumption p 0  aj for some j, 1 ≤j ≤k.  
Therefore p 0  aj for some j, 1 ≤j ≤k + 1.
	 14.	1176 = 23 # 3 # 72
	 15.	420 = 22 # 3 # 5 # 7 and 66 = 2 # 3 # 11, so gcd(420, 66) = 2 # 3 = 6
	 16.	Because p is a prime number, it has no factors other than itself and 1. Therefore every positive integer less 
than p has only the factor 1 in common with p, so it is relatively prime to p. Therefore w(p) = p −1.
	 17.	 w(n) = 33 # 73w(3)w(5)w(7)4 = 27 # 7 # 2 # 4 # 6 = 9072
Chapter 3
	
1.	 1, 4, 7, 10, 13
	
2.	 1, 1, 2, 3, 5, 8, 13, 21
	
3.	 In proving the k + 1 case, the terms F(k −1) and F(k) are used. If k + 1 = 2, then the value at 2 posi-
tions back, F(k −1), is undefined. Therefore in the inductive step, we must have k + 1 ≥3 and the case 
n = 2 must be done separately. Put another way, the inductive step does not demonstrate the truth of the 
n = 2 case from the truth of the n = 1 case.
	
4.	 A, B, and C are wffs by rule 1. By rule 2, (B′) is a wff, and so then is (A ~  (B′)) and ((A ~  (B′)) S  C ). 
This can be written as (A ~  B′) S  C.
	
5.	 Every parent of an ancestor of James is an ancestor of James.
	
6.	 1011001, 0011011, 00110111011
820	
Answers to Practice Problems

Answers to Practice Problems	
821
	
7.	 1.	 l, 0, and 1 are binary palindromes.
	
2.	If x is a binary palindrome, so are 0x0 and 1x1
	
8.	 1.	 x1 = x
	
2.	 xn = xn−1x for n > 1
	
9.	 if n = 1 then
return 1
else
return T(n −1) + 3
end if
	 10.	10, 7, 8
	 11.	  T(n) = T(n −1) + 3
	
 = 3T(n −2) + 34 + 3 = T(n −2) + 2 * 3
	
 = 3T(n −3) + 34 + 2 * 3 = T(n −3) + 3 * 3
	
	
(
	
In general, we guess that
T(n) = T(n −k) + k * 3
	
	 When n −k = 1, that is, k = n −1,
T(n) = T(1) + (n −1) * 3 = 1 + (n −1) * 3
	
	 Now prove by induction that T(n) = 1 + (n −1) * 3.
	
	 T(1): T(1) = 1 + (1 −1) * 3 = 1, true
	
	 Assume T(k):  T(k) = 1 + (k −1) * 3
	
	 Show T(k + 1):  T(k + 1) =? 1 + k * 3 
 	
	  T(k + 1) = T(k) + 3
	
(by the recurrence relation)
	
	
 = 1 + (k −1) * 3 + 3	
(by the inductive hypothesis)
 = 1 + k * 3
	 12.	The recurrence relation matches equation (6) with c = 1 and g(n) = 3. From equation (8), the ­closed-form 
solution is
T(n) = 1n−1(1) + ∙
n
i=2
1n−i(3)
 = 1 + ∙
n
i=2
3
 = 1 + (n −1)3
	 13.	a. From the base cases and the recurrence relation, the first five terms of the sequence are
S(1) = 3, S(2) = 1, S(3) = 2S(2) + 3S(1) = 11,  
S(4) = 2S(3) + 3S(2) = 25, S(5) = 2S(4) + 3S(3) = 83
	
b.	The formula S(n) = 3n−1 + 2(−1)n−1 generates 3, 1, 11, 25, 83 for n = 1, 2, 3, 4, 5.

	 14.	c1 = 6 and c2 = −5, so the characteristic equation is
t 2 −6t + 5 = 0
	
	 which has roots r1 = 1, r2 = 5. The solution has the form
T(n) = p + q(5)n−1
	
	 where
 p + q = 5
p + q(5) = 13
	
	 Solving this system of equations, p = 3, q = 2 and the solution formula is
 T(n) = 3 + 2(5)n−1
	 15.	This is in the form of equation (16) with c = 2 and g(n) = 1. By equation (21), the solution is
 2log n(1) + ∙
log n
i=1
2(log n)−i(1) = 2log n + 2(log n)−1 + 2(log n)−2 + c+ 20
 = 2(log n)+1 −1
 = (2)2log n −1 = 2n −1
	 16.	
822	
Answers to Practice Problems
n
Sequential 
Search
Binary 
Search
64
64
7
1024
1024
11
32768
32768
16
Chapter 4
	
1.	 a.	 54, 5, 6, 76
	
b.	 5April, June, September, November6
	
c.	 5Washington, D.C.6
	
2.	 a.	 5x0x is one of the first four perfect squares6
	
b.	 5x0x is one of the Three Men in a Tub in the children’s nursery rhyme6
	
c.	 5x0x is a prime number6
	
3.	 a.	 A = 5x0x [ N and x ≥56
	
b.	 B = 53, 4, 56
	
4.	 x [ B
	
5.	 A ( B means (4x)(x [ A S  x [ B) ` (Ey)3 y [ B ` ( y [ A)′4
	
6.	 a, b, d, e, h, i, l

Answers to Practice Problems	
823
	
7.	 Let x [ A. Then x [ R and x2 −4x + 3 = 0, or (x −1)(x −3) = 0, which gives x = 1 or x = 3. In 
either case, x [ N and 1 ≤x ≤4, so x [ B. Therefore A # B. The value 4 belongs to B but not to A, so 
A ( B.
	
8.	 `(A) = 5[, 516, 526, 536, 51, 26, 51, 36, 52, 36, 51, 2, 366.
	
9.	 2n
	 10.	By the definition of equality for ordered pairs,
2x −y = 7 and x + y = −1
	
	 Solving the system of equations,
x = 2, y = −3
	 11.	 (3, 3), (3, 4), (4, 3), (4, 4)
	 12.	a.	 S is not closed under division. (3 ÷ 4 is not a positive integer)
	
c.	 00 is not defined.
	
f.	 x[ is not unique for, say, x = 4 (22 = 4 and (−2)2 = 4).
	 13.	Yes; if x [ A d B, then x [ A (and x [ B, but we don’t need this fact), so x [ A c B.
	 14.	A′ = 5x 0  x [ S and x o A6
A
S
A′ 
	 15.	A −B = 5x 0  x [ A and x o B6
A
B
S
A − B
	 16.	a.	 51, 2, 3, 4, 5, 7, 8, 9, 106
	
b.	 51, 2, 36
	
c.	 51, 3, 5, 106
	 17.	a.	 A × B = 5(1, 3), (1, 4), (2, 3), (2, 4)6
	
b.	 B × A = 5(3, 1), (3, 2), (4, 1), (4, 2)6
	
c.	 A2 = 5(1, 1), (1, 2), (2, 1), (2, 2)6
	
d.	 A3 = 5(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2), (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)6
	 18.	Show set inclusion in each direction. To show A c [ # A, let x [ A c [. Then x [ A or x [ [, but since 
[ has no elements, x [ A. To show A # A c [, let x [ A. Then x [ A or x [ [, so x [ A c [.
	 19.	a.	 3C d (A c B)4 c 3(A c B) d C′4
		
=  3(A c B) d C4 c 3(A c B) d C′4    (lb)
		
= (A c B) d (C c C′)	
(3b)
		
= (A c B) d S	
(5a)
		
= A c B	
(4b)
	
b.	 3C c (A d B)4 d 3(A d B) c C′4 = A d B

	 24.	Although the problem consists of successive events—the five tosses—the number of outcomes of each 
event is not constant but varies between one and two depending on the outcome of the preceding event.
	 25.	
	 26.	A c B
	 27.	Equation (2) gives the result of Example 31 because if A and B are disjoint, then 
	
	 0A d B0  = 0.
	 28.	The reasons for the equalities are
set union is associative
equation (2)
equation (2) and set identity 3b (distributive property)
equation (2)
rearranging terms
824	
Answers to Practice Problems
	 29.	7 (The bins are the 6 possible values.)
	 30.	P(20, 2) = 20!
18! = 380
	 31.	6! = 720 
	 32.	C(12, 3) = 12!
3!9! = 220
	 33.	a.	 18	
b.	 24
	 34.	 9!
3!2!
	 20.	An enumeration of the even positive integers is 2, 4, 6, 8, 10, 12, … .
	 21.	1∙5, 5∙1
	 22.	4(8)(5) = 160
	 23.	7(5) + 9 = 44
	 35.	Here r = 6 and n = 3, with repetitions. C(r + n −1, r) = C(8, 6) = 8!
6!2! = 28
	 36.	cysar, scary, scrva, scyra, yarcs, yarsc
	 37.	Here five digits are being permuted, so n = 5. At this point
d1 = 5, d2 = 1, d3 = 4, d4 = 3, d5 = 2
	
	 In the for loop that generates all permutations after the first, set i = 4, j = 5. Consider pairs of adjacent 
values from right to left as long as di > dj:
d4 > d5	
3 > 2	 true
d3 > d4	
4 > 3	 true
d2 > d	
1 > 4	 false

Answers to Practice Problems	
825
	
	 The value of i at this point is 2, and di = d2 = 1. Set j = 5; consider dj values from right to left as long 
as di > dj.
 d2 > d5	
1 > 2	 false
	
	 The value of j at this point is 5. Swap d2 and d5, giving 52431. Take the descending sequence right of d2, 
namely 431, and swap pairs of values from the outside in to reverse the sequence. Swap 4 and 1, giving 
52134. The indices i from the left and j from the right meet in the middle, at which point the reversal—and 
the new permutation—is complete.
	 38.	The rightmost non-max element is 5, which becomes incremented to 6. The two digits to its right are reset 
to their minimum values of 78. The next combination is therefore 24678.
	 39.	(a + b)3 = a3 + 3a2b + 3ab2 + b3
	
	 Coefficients: 1 3 3 1, which is row n = 3 in Pascal’s triangle
(a + b)4 = a4 + 4a3b + 6a2b2 + 4ab3 + b4
	
	 Coefficients: 1 4 6 4 1, which is row n = 4 in Pascal’s triangle
	 40.	(x + 1)5 = C(5, 0)x5 + C(5, 1)x4 + C(5, 2)x3 + C(5, 3)x2 + C(5, 4)x + C(5, 5)
	
	
 = x5 + 5x4 + 10x3 + 10x2 + 5x + 1
	 41.	C(7, 4)x3y4
	 42.	The sample space consists of all the cards in the deck, so 0S0 = 52. The event of interest is the set of aces, 
so 0E0 = 4. P(E) = 4∙52 = 1∙13.
	 43.	16∙42 = 8∙21; 28∙42 = 14∙21
	 44.	a.	 p(c) = 1 −(p(a) + p(b)) = 1 −(0.2 + 0.3) = 0.5
	
b.	 p(a) + p(c) = 0.2 + 0.5 = 0.7
	 45.	E1 = 5HH, HT, TH6, E2 = 5HH6, E1 d E2 = 5HH6
P(E20E1) = P(E1 d E2)
P(E1)
= 1∙4
3∙4 = 1∙3
	 46.	Let
E1 be the event that the package came from Supplier A
E2 be the event that the package came from Supplier B
F be the event that the package was lettuce
	
	 By Bayes’ theorem,
P(E10F ) =
P(F 0E1)P(E1)
P(F 0  E1)P(E1) + P(F  0  E2)P(E2) =
(57∙100)(1∙2)
(57∙100)(1∙2) + (39∙100)(1∙2) > 0.594
	 47.	 E(X) = 5(2∙8) + 2(3∙8) + 3(2∙8) + 7(1∙8) = 29∙8 = 3.625
	 48.	This is still a Bernoulli trial where n = 200 and p = 1∙2. From the binomial distribution, the probability 
of 100 heads is C(200,100)(1∙2)100(1∙2)100 > 0.056.

Chapter 5
	
1.	 a.	 (3, 2) [ r
	
b.	 (2, 4), (2, 6) [ r
	
c.	 (3, 4), (5, 6) [ r
	
d.	 (2, 1), (5, 2) [ r
	
2.	 a.	 Many-to-one
	
b.	One-to-one
	
c.	 Many-to-many
	
3.	 a.	 x(r c s) y 4 x ≤y
	
b.	 x r′ y 4 x ∙y
	
c.	 x s′ y 4 x ≥y
	
d.	 r d s = [
	
4.	 a.	 (1, 1), (2, 2), (3, 3)
	
b.	Knowing that a relation is symmetric does not by itself give information about any of the ordered pairs 
that might belong to r. If we know that a relation is symmetric and we know some ordered pairs that 
belong to the relation, then we know certain other pairs that must belong to the relation (see part (c)).
	
c.	 (b, a)
	
d.	 a = b
	
e.	 The transitive property says (x, y) [ r ` (y, z) [ r S (x, z) [ r. In this case (1, 2) is the only element 
of r and (2, z) o r for any z in S. Therefore the antecedent of the implication is always false, and the 
implication is true; r is transitive.
	
5.	 a. Reflexive, symmetric transitive
 
b. Reflexive, antisymmetric, transitive
 
c. Reflexive, symmetric, transitive
	
d.	Antisymmetric
 
e. Reflexive, symmetric, antisymmetric, transitive
	
f.	 Antisymmetric (recall the truth table for implication), transitive
 
g. Reflexive, symmetric, transitive
 
h. Reflexive, symmetric, transitive
	
6.	 No. If the relation has the antisymmetry property, then it is its own antisymmetric closure. If the rela-
tion is not antisymmetric, there must be two ordered pairs (x, y) and (y, x) in the relation with x ∙y. 
Extending the relation by adding more ordered pairs will not change this situation, so no extension will 
be antisymmetric.
	
7.	 Reflexive closure: 5(a, a), (b, b), (c, c), (a, c), (a, d), (b, d), (c, a), (d, a), (d, d)6
	
	 Symmetric closure: 5(a, a), (b, b), (c, c), (a, c), (a, d), (b, d), (c, a), (d, a), (d, b)6
	
	 Transitive closure: 5(a, a), (b, b), (c, c), (a, c), (a, d), (b, d), (c, a), (d, a), (d, d), (d, c), (b, a), (b, c), (c, d)6
	
8.	 a.	 (1, 1), (1, 2), (2, 2), (1, 3), (3, 3), (1, 6), (6, 6), (1, 12), (12, 12), (1, 18), (18, 18), (2, 6), (2, 12),  
		
(2, 18), (3, 6), (3, 12), (3, 18), (6, 12), (6, 18)
	
b.	 1, 2, 3
	
c.	 2, 3
826	
Answers to Practice Problems

Answers to Practice Problems	
827
	
9.	
	 10.	 y [ S is a greatest element if  x d y for all x [ S.
	
	 y [ S is a maximal element if there is no x [ S 
with y a x.
	 11.	
	 12.	Let q [ 3x4. Then x r q. Because x r z, by 
­symmetry z r x. By transitivity, z r x together 
with x r q gives z r q. Therefore, q [ 3z4.
	 13.	Reflexive: 
For any x [ S, x is in the same block as itself, so x r x.
	
	 Symmetric:	 If x r y, then x is in the same block as y, so y is in the same block as x, or y r x and r is 
­symmetric.
	
	 Transitive:	
If x r y and y r z, then x is in the same block as y and y is in the same block as z, so x is in 
the same block as z, or x r z.
	
	 Therefore r is an equivalence relation.
	 14.	a.	 The equivalence classes are sets consisting of lines in the plane with the same slope.
	
b.	 3n4 = 5n6; the equivalence classes are all of the singleton sets of elements of N.
	
c.	 314 = 324 = 51, 26, 334 = 536
	 15.	 304 = 5… , −15, −10, −5, 0, 5, 10, 15, …6
314 = 5… , −14, −9, −4, 1, 6, 11, 16, …6
324 = 5… , −13, −8, −3, 2, 7, 12, 17, …6
334 = 5… , −12, −7, −2, 3, 8, 13, 18, …6
344 = 5… , −11, −6, −1, 4, 9, 14, 19, ...6
	 16.	2
	 17.	
	 18.	Minimum time to completion is 36 days. Critical path is 1, 2, 3, 4, 6, 8, 9.
	 19.	For example: 1, 3, 2, 6, 7, 5, 4, 8, 9, 10, 11, 12
	 20.	For example: 1, 2, 3, 7, 5, 4, 6, 8, 9

	 21.	
Locale
Name 
State
Patrick, Tom 
FL
Smith, Mary 
IL
Collier, Jon 
IL
Jones, Kate 
OH
Smith, Bob 
MA
White, Janet 
GA
Garcia, Maria 
NY
	 22.	a.	 project(join(restrict PetOwner where Pet-
Type = “Dog”) and Person over Name) over 
City giving Result
	
b.	SELECT City
	
FROM Person, PetOwner  WHERE Person.
Name = PetOwner.Name  AND PetType =
“Dog”
	
c.	 Range of x is Person 
	
Range of y is PetOwner
	
5x.City 0 exists y( y.Name = x.Name and	 	
	
y.PetType = “Dog”)6
828	
Answers to Practice Problems
	 23.	a.	 Not a function;  2 [ S has two values associated with it.
	
b.	Function
	
c.	 Not a function; for values 0, 1, 2, 3 of the domain, the corresponding h(x) values fall outside the  
codomain.
	
d.	Not a function; not every member of S owns an automobile.
	
e.	 Function (not every value in the codomain need be used)
	
f.	 Function
	
g.	Function
	
h.	Not a function;  5 [ N has two values associated with it.
	 24.	a.	 16	
b.	 ±3
	 25.	T, F
	 26.
	
	 27.	f and g have the same domain and codomain, so we must show that each function has the same effect on 
each member of the domain.
	
f (1) = 1	
 g(1) =
∙
1
k=1
(4k −2)
2
 = 4 # 1 −2
2
= 2
2 = 1
	
f (2) = 4	
 g(2) =
∙
2
k=1
(4k −2)
2
 = (4 # 1 −2) + (4 # 2 −2)
2
= 2 + 6
2
= 4

Answers to Practice Problems	
829
	
f (3) = 9	
 g(3) =
∙
3
k=1
(4k −2)
2
 = (4 # 1 −2) + (4 # 2 −2) + (4 # 3 −2)
2
= 2 + 6 + 10
2
= 9
	
	 Therefore f = g.
	 28.	b, f, g
	 29.	If P is either a tautology or a contradiction.
	 30.	e, g
	 31.	(g + f )(2.3) = g( f (2.3)) = g((2.3)2) = g(5.29) = :5.29; = 5
	
	 ( f + g)(2.3) = f (g(2.3)) = f (:2.3;) = f (2) = 22 = 4
	 32.	Let (g + f )(s1) = (g + f )(s2). Then g( f (s1)) = g( f (s2)) and because g is one-to-one, f (s1) = f (s2). ­Because 
f is one-to-one, s1 = s2.
	 33.	Let t [ T. Then ( f + g)(t) = f(g(t)) = f(s) = t.
	 34.	 f −1:  R S R, f −1(x) = (x −4)∙3
	 35.	a.	 (1, 4, 5) = (4, 5, 1) = (5, 1, 4)
	
b.	 a1
2
3
4
5
1
4
2
5
3b
	 36.	a.	 g + f = (1, 3, 5, 2, 4) = (3, 5, 2, 4, 1) = …
	
	 		
f + g = (1, 5, 2, 3, 4) = (5, 2, 3, 4, 1) = …
	
b.	 g + f = a1
2
3
4
5
4
2
5
1
3b
	
	
f + g = a1
2
3
4
5
2
1
3
5
4b
	
c.	 g + f = f + g = a1
2
3
4
5
3
5
1
4
2b
	 37.	(1, 2, 4) + (3, 5) or (3, 5) + (1, 2, 4)
	 38.
	
	 39.	One possibility: 5(0, 0), (1, 1), (−1, 2), (2, 3), (−2, 4), (3, 5), (−3, 6), …6
	 40.	a.	  10.87 ≤12 ≤1087
	
 22.27 ≤27 ≤2227
	
 37.67 ≤48 ≤3767
	
 57.07 ≤75 ≤5707
	
b.	No
	
c.	 n0 = 1, c1 = 1∙200, c2 = 1
	 41.	a.	 Let f r g. Then there are positive constants n0, c1, and c2 with c1g(x) ≤f(x) ≤c2g(x) for x ≥n0. Then 
for x ≥n0, it is true that (1∙c2)f(x) ≤g(x) ≤(1∙c1)f(x), so g r f .

	
b.	Let f r g and g r h. Then there are positive constants n0, n1, c1, c2, d1, and d2 with c1g(x) ≤f(x) ≤c2g(x) 
for x ≥n0 and d1h(x) ≤g(x) ≤d2h(x) for x ≥n1. Then for x ≥max(n0, n1), c1d1h(x) ≤f(x) ≤c2d2h(x) 
so f r h.
	 42.	3x2 = Θ(x2) using constants n0 = 1, c1 = c2 = 3.
	
	 200x2 + 140x + 7 = Θ(x2) using constants n0 = 2, c1 = 1, c2 = 300.
	 43.	a.	 If x ≡y (mod n) then x −y = kn for some integer k, so x −y = kn + 0 and (x −y) mod n = 0.
	
	
Conversely, if (x −y) mod n = 0 then x −y = kn + 0 for some integer k, or x −y = kn so 
x ≡y (mod n).
	
b.	Let x = q1n + r1, 0 ≤r1 < n and y = q2n + r2, 0 ≤r2 < n, so x mod n = r1 and y mod n = r2. 
Then x −y = (q1n +  r1) −(q2n + r2) = (q1 −q2)n + (r1 −r2) with −n < r1 − r2 < n.
	
	
If x mod n = y mod n, then r1 = r2 so r1 −r2 = 0 and x −y = (q1 −q2)n where q1 −q2 is an 
­integer, so x ≡y (mod n).
	
	
Conversely, if x ≡y (mod n), then x −y = kn for some integer k. Because x −y =  
(q1 −q2)n + (r1 −r2) with −n < r1 −r2 < n, r1 −r2 = 0 and x mod n = y mod n.
	 44.	
0
1
2
3
4
5
6
7
8
9
48
28
23
7
158
59
(a)
(b)
59
48
7
23
0
1
2
3
4
5
6
7
8
9
28
158
	 45.	THE CAT IN THE HAT
	 46.	x = 1011, p = x mod 23 = 0011, q = p # 2 = 0110, s = x ! p = 1000, t = s # 2−3 = 0001, 
y = q + t = 0111
	 47.	(166)35mod 221 = (1662)17 # 166 mod 221 = (27556)17 # 166 mod 221
	
	
= (152)17 # 166 mod 221 = (1522)8 # 152 # 166 mod 221 = (23104)8 # 152 # 166 mod 221
	
	
= (120)8 # 152 # 166 mod 221 = (1202)4 # 152 # 166 mod 221
	
	
= (14400)4 # 152 # 166 mod 221 = (35)4 # 152 # 166 mod 221
	
	
= 352 # 352 # 152 # 166 mod 221 = 120 # 120 # 152 # 166 mod 221
	
	
= 14400 # 25232 mod 221 = 35 # 38 mod 221 = 4
	 48.	a.	 3	
b.	X
830	
Answers to Practice Problems

Answers to Practice Problems	
831
	 51.	 
2A + B = £
6
14
3
10
9
16
§
	
	 52.	
A # B = c15
22
12
28d
	
B # A = c39
0
27
4d
	 53.	
I # A = c1(a11) + 0(a21)
1(a12) + 0(a22)
0(a11) + 1(a21)
0(a12) + 1(a22)d = ca11
a12
a21
a22
d = A
	
Similarly, A # I = A.
	 54.	
A # B = £
−1
2
−3
2
1
0
4
−2
5
§ £
−5
4
−3
10
−7
6
8
−6
5
§ = £
1
0
0
0
1
0
0
0
1
§
	
B # A = £
−5
4
−3
10
−7
6
8
−6
5
§ £
−1
2
−3
2
1
0
4
−2
5
§ = £
1
0
0
0
1
0
0
0
1
§
	 55.	The augmented matrix is
c3
−5
5
7
1
37d
	
	 Multiply row 1 by 1/3: 
1∙3 c3
−5
5
7
1
37d
	
	 Then multiply row 1 by −7 and add it to row 2:
	
−7     c1
−5∙3
5∙3
7
1
37d  resulting in c1
−5∙3
5∙3
38∙3
76∙3d
	
	 Using the second row,
(38∙3)y = 76∙3 or y = 2
	
	 Using the first row,
x −(5∙3)y = 5∙3 or x −(5∙3)(2) = 5∙3 or x = 5.
	
	 The solution is x = 5, y = 2.
	 49.	temp = 375
ones = temp mod 10 = 5
temp = (375 −5)∙10 = 370∙10 = 37
tens = temp mod 10 = 37 mod 10 = 7
temp = (37 −7)∙10 = 30∙10 = 3
hundreds = temp = 3
	 50.	a23 = 1, a24 = −7, a13 = −6

	 56.	
832	
Answers to Practice Problems
x
y
x ` y
1
1
1
1
0
0
0
1
0
0
0
0
x
y
x ~ y
1
1
1
1
0
1
0
1
1
0
0
0
	 57.	
No, A # B = £
2
1
1
1
1
1
0
0
1
§
	 58.	
B × A = £
1
1
0
1
1
1
0
0
1
§
Chapter 6
	
1.	 One possible picture:
	
2.	 a.	
	
b.	

Answers to Practice Problems	
833
	
3.	 Possible answers:
	
a.	 2 and 3	
f.	 2, a1, 1, a2, 3, a3, 4, a4, 3, a3, 4
	
b.	5	
g.	3, a3, 4, a4, 3
	
c.	 a6	
h.	no
	
d.	a3 and a4	
i.	 yes
	
e.	 3
	
4.	
	
5.	
	
6.	 a.	 In a complete graph, any two distinct nodes are adjacent, so there is a path of length 1 from any node 
to any other node; hence the graph is connected.
	
b.	For example, the graph of Figure 6.10b.
	
7.	 f2:  a4 S e3
 a5 S e8
 a6 S e7
 a7 S e5 (or e6)
 a8 S e6 (or e5)
	
8.	 f:  1 S  d
 2 S e
 3 S f
 4 S c
 5 S b
 6 S a
	
9.	 The graph on the left in Figure 6.19 has two nodes of degree 2, but the graph on the right does not; or the 
graph on the left has parallel arcs, but the graph on the right does not.
	 10.	K4 can be represented as 
	 11.	Making 1–3 and 1–4 exterior arcs leads to the graph below, where it is still impossible to make 3 and 5 
adjacent while preserving planarity.

	 12.	An attempt to construct K3,3 as a planar graph leads to the graph below; there is no way to connect nodes 
3 and 5. Any other construction leads to a similar difficulty.
	 13.	n = 6, a = 7, r = 3, and 6 −7 + 3 = 2
	 14.	Without this condition on the arc, a figure such as the one below could result. Then the graph would be 
split into two disconnected subgraphs and the inductive hypothesis would not apply. Also the number of 
regions would not change.
	 15.	In K3,3, a = 9, n = 6, and 9 ≤3(6) −6.
	 16.	
A = ≥
1
1
0
1
1
0
1
0
0
1
0
2
1
0
2
0
¥
	 17.	
834	
Answers to Practice Problems
	 19.	
	 18.	 a.	2	
b.	4 	
c.	2

Answers to Practice Problems	
835
	 20.	a.	
Left child
Right child
1
0
2
2
3
4
3
0
5
4
0
0
5
0
0
	
b.
	
1
2
3
4
5
	 21.	a, b, e, f, c, d, g, i, h
	
	 e, b, f, a, c, i, g, d, h
	
	 e, f, b, c, i, g, h, d, a
	 22.	
Prefix notation: 
+ a − *  b c d
Postfix notation: 
a b c  *  d − +
	 23.	For the base case, n = 1, the tree consists of a single node and no arcs, therefore no arc ends. The number 
of arc ends is 0 = 2(1) −2. Assume that any tree with k nodes has a total number of arc ends of 2k −2. 
Consider a tree with k + 1 nodes, and show that the number of arc ends is 2(k + 1) −2. In this tree, 
remove a leaf node and the arc to that node’s parent. This leaves a tree with k nodes and, by the induc-
tive hypothesis, 2k −2 arc ends. The original graph had one more arc, and two more arc ends, so it had 
2k −2 + 2 = 2k = 2(k + 1) −2 arc ends.
	 24.	The base case is the same as in Practice 23. Assume that tree T is constructed from subtrees T1, … , Tt and 
that any subtree Ti with ni nodes has (2ni −2) arc ends. Let n equal the number of nodes in T. Then, as in 
Example 30,
n = 1 + ∙
t
i=1
ni so 2n = 2 + 2∙
t
i=1
ni
	
	 The number N of arc ends in T is 2t + ∙
t
i=1
(number of arc ends in Ti). (The extra 2t counts the number of 
arc ends contributed by the t arcs from the root of T to the t subtrees.) Then
N = 2t + ∙
t
i=1
(2ni −2) = 2t + 2∙
t
i=1
ni −2t = 2∙
t
i=1
ni = 2n −2

	 25.	a.	
	
b.	Depth of tree = 3 = 1 + :log5;
	 26.	a.
	
b.	 d = 3
836	
Answers to Practice Problems
	 27.	a.
	 28.	a.	ppca?	
b.	cagak	
c.	?kac?
	 29.	
	 30.	w: 010
	
	 q: 011
	
	 h: 00
	
	 e: 1

Answers to Practice Problems	
837
Chapter 7
	
1.	 5(2, 1),(2, 2),(3, 1),(3, 4)6	
	
2.	 There are two distinct nodes, 3 and 4, with 3 r 4  and 4 r 3.
	
3.	
A = ≥
0
0
0
1
0
0
1
1
0
0
0
0
1
0
0
0
¥      A(2) = ≥
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
¥
	
	 A(2)32, 14 = 1 because there is a path from 2 to 1 of length 2 (2–4–1).
	
4.	 There is a length-4 path  (2–4–1–4–1) from 2 to 1, so A(4)32, 14 should be 1.
	
	 A = ≥
0
0
0
1
0
0
1
1
0
0
0
0
1
0
0
0
¥      A(2) = ≥
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
¥
	
	 A(3) = ≥
0
0
0
1
0
0
0
1
0
0
0
0
1
0
0
0
¥      A(4) = ≥
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
1
¥
	
5.	 R = A ~ A(2) ~ A(3) ~ A(4), so performing the Boolean or of the four matrices from Practice 4 gives
 R = ≥
1
0
0
1
1
0
1
1
0
0
0
0
1
0
0
1
¥
	
	 Column 2 is all 0s, so 2 is not reachable from any node.
	
6.	
M0 = ≥
0
0
0
1
0
0
1
1
0
0
0
0
1
0
0
0
¥     M1 = ≥
0
0
0
1
0
0
1
1
0
0
0
0
1
0
0
1
¥     M2 = ≥
0
0
0
1
0
0
1
1
0
0
0
0
1
0
0
1
¥
	
	 M3 = ≥
0
0
0
1
0
0
1
1
0
0
0
0
1
0
0
1
¥     M4 = R = ≥
1
0
0
1
1
0
1
1
0
0
0
0
1
0
0
1
¥
	
7.	 a.	 No	
b.	Yes

	 10.	
    A
B
C
D
	
	
A
B
C
D
≥
0
2
2
1
2
0
0
1
2
0
0
1
1
1
1
0
¥
	
	 After row C, total = 3, the loop terminates, and there is no path.
	 11.	a.	 No	
b.	Yes
838	
Answers to Practice Problems
IN = 5x6
x
1
2
3
y
d
0
1
∞
4
∞
s
−
x
x
x
x
p = 1
IN = 5x, 16
x
1
2
3
y
d
0
1
4
2
6
s
−
x
1
1
1
p = 3
IN = 5x, 1, 36
x
1
2
3
y
d
0
1
4
2
5
s
−
x
1
1
3
p = 2
IN = 5x, 1, 3, 26
x
1
2
3
y
d
0
1
4
2
5
s
−
x
1
1
3
p = y
IN = 5x, 1, 3, 2, y6
x
1
2
3
y
d
0
1
4
2
5
s
−
x
1
1
3
	 13.	
	 14.	a, e, d, b, c, i, f, g, h, l, k, m, j
	 15.	a, e, f, d, i, b, c, g, h, j, k, m, l
	 12.	
	
	 Path: x, 1, 3, y   Distance = 5
b.
	 16.	a.
	
8.	 a.	 No, four odd nodes 	
b.	Yes, no odd nodes
	
9.	 No, all four nodes are odd nodes.

Answers to Practice Problems	
839
	 17.	Choosing node c (arbitrarily) as the start node, we visit e, then have to back up to c. There’s nowhere else 
to go, so start over from node a (again, an arbitrary choice from the unvisited nodes). Traveling from a to 
b to d and then backing up produces the rest of the node numbers.
	
	 Topological sort: a, b, d, c, e
	 18.	The depth-first search progresses from node a to b and then c, with TreeNumbers and BackNumbers as-
signed in sequence. At node c, the back arc to node a causes BackNumber of c to be changed to TreeNum-
ber of a. The search progresses to d, which has a sequential TreeNumber and BackNumber assigned. The 
search then backs up to node c. Because BackNumber(d) > TreeNumber(c), c is recognized as an articula-
tion point. The search backs up to node b, and b’s BackNumber is reduced to that of c. The search backs 
up to a, but a is not an articulation point because it is the starting node with only one tree arc.
Chapter 8
	
1.	 0 # 1 = 0
	
	 1 # 1 = 1
	
2.	 a.	 A ~ A = A 
	
b.	 A c A = A
	
3.	 a.	 x + 1 = x + (x + x′)	
(5a, complement property)
	
	 	
 = (x + x) + x′	
(2a, associative property)
	
	
 = x + x′
	
(idempotent property)
	
	
 = 1
	
(5a, complement property)
	
b.	 x # 0 = 0
	
4.	 To prove that 0′ = 1, show that 1 has the two properties of the complement of 0.
0 + 1 = 1
	
(universal bound)
0 # 1  = 1 # 0	
(1b)
 = 0
	
(dual of universal bound)
	
	 Therefore 1 = 0′ by the theorem on the uniqueness of complements.
	
5.	 a.	 f(x # y) = f(x) * f( y) 
	
b.	 f(x′) = 3 f(x)4′ ′
	
6.	 Property 2: 

840	
Answers to Practice Problems
	
	
Property 3:
 
	
Property 4: 
	
7.	 a.	 f (0 + a) = f (a) = 516 = [ c 516 = f (0) c f (a)
	
b.	 f (a + a′) = f (1) = 51, 26 = 516 c 526 = f (a) c f (a′)
	
c.	 f (a # a′) = f (0) = [ = 516 d 526 = f (a) d f (a′)
	
d.	 f (1′) = f (0) = [ = 51, 26′ = ( f (1))′
	
8.	 a.	 A single truth function on 50, 16n must map each of the elements in the domain to a 0 or a 1, and there 
are 2n n-tuples in the domain 50, 16n. Hence the table for the function will have 2n rows. 
 
b. Any truth function must fill 4 “slots” (corresponding to the 22 = 4 domain elements) with one of 2 
values, a 0 or a 1. There are 24 = 16 different ways to do this.
 
c. Any truth function must fill 2n “slots” (corresponding to the 2n domain elements) with one of 2 values, 
a 0 or a 1. There are 22n different ways to do this.
	
9.	 a.	
	
b.	
	 10.	a.	 (x1′ + x2)x3′
	
b.	
x1
x2
x3
(x1′ + x2)x3′
1
1
1
0
1
1
0
1
1
0
1
0
1
0
0
0
0
1
1
0
0
1
0
1
0
0
1
0
0
0
0
1

Answers to Practice Problems	
841
	 11.	a.	 x1x2x3 +  x1x2′x3 + x1x2′x3′ + x1′x2′x3 + x1′x2′x3′ 
	
b.	
	 12.	
 101
	
	
 111
	
	  (1)100
	 13.	a.	
	
b.	 x1x3 + x2′ = ((x1x3)′x2)′	
	 14.	a	
x1
x2
f(x1, x2)
1
1
0
1
0
1
0
1
1
0
0
0

	
	
Here xi = 0 when the switch is in the “off ” position and f (x1, x2) = 0 when the light is off. The last 
row of the truth table says that when both switches are off, the light is off. Rows 2 and 3 say that when 
one or the other switch is turned on, the light goes on. But the top row says that if the light is on (be-
cause one of the switches has been turned on) then flipping the second switch turns the light off.
	
b.	One possibility is the canonical sum-of-products form, x1x2′ + x1′x2
	
c.	
842	
Answers to Practice Problems
	 15.	a.	 x1x2 + x1′x2 = x2x1 + x2x1′
	
	
 = x2(x1 + x1′)
	
	
 = x2 # 1
	
	
 = x2
	
b.	 x1 + x1′x2 = x1 # 1 + x1′x2
	
	
 = x1(1 + x2) + x1′x2	
(universal bound)
	
	
 = x1 + x1x2 + x1′x2
	
	
 = x1 + x2(x1 + x1′)
	
	
 = x1 + x2 # 1
	
	
 = x1 + x2
	
16.
	
1
1
x2
x'2
x1
x'1
	
	 The reduced expression is x1′
	 17.	 x1x3 (4 squares) and x1′x2x3′ (2 squares)
	 18.	x1x2′x4 + x1x3′x4 + x2′x3′
	
1
1
1
1
1
1
x3x4
x3x'4
x'3x'4
x'3x4
x1x2
x1x'2
x'1x'2
x'1x2
	 19.	The reduction table follows.
Number of 1s
x1
x2
x3
Three
1
1
1
1
Two
1
1
0
1,2
One
1
0
0
2,3
0
0
1
4
None
0
0
0
3,4
Number of 1s
x1
x2
x3
Two
1
1
–
One
1
–
0
None
–
0
0
0
0
–

Answers to Practice Problems	
843
	
	 The comparison table follows.
111
110
100
001
000
11–
✓
✓
1–0
✓
✓
–00
✓
✓
00–
✓
✓
	
	 Essential terms are 11– and 00–. Either 1–0 or –00 can be used as the third reduced term. The minimal 
sum-of-products form is
x1x2 + x1′x2′ + x1x3′     or     x1x2 + x1′x2′ + x2′x3′
Chapter 9
	
1.	 Multiplication in R is associative and commutative, and 1 is an identity. But 3R, #4 is not a commutative 
group because 0 [ R does not have an inverse with respect to multiplication; there is no real number y 
such that 0 # y = y # 0 = 1.
	
2.	 See Practice 52 of Chapter 5.
	
3.	 Many elements of M2(Z) do not have inverses under matrix multiplication. For example, if
c2
0
0
2d
	
	 is to have an inverse
ca
b
c
dd
	
	 under multiplication, then
c2
0
0
2d # ca
b
c
dd = ca
b
c
dd # c2
0
0
2d = c1
0
0
1d
	
	 By the definition of matrix multiplication, the only matrix that satisfies this equation would have 2a = 1 
or a = 1
2 and thus would not be a member of M2(Z).
	
4.	 Subtraction is not associative; for example, 5 −(3 −1) = 3 but (5 −3) −1 = 1.
	
5.	 No, S is not closed under multiplication; for example, 2
3
# 3
2 = 1.
	
6.	 All except 3R+, +4 (which has no identity) are monoids; the identities are, respectively, 0, 1, 1, 0, [, S.
	
7.	 3R, +4
	
8.	 a.	 f (x) + g (x) = g (x) + f (x)
	
	 		
3 f (x) + g (x)4 + h (x) = f (x) + 3g (x) + h (x)4
	
b.	the zero polynomial, 0
	
c.	 −7x4 + 2x3 −4

	
9.	 	a.	
844	
Answers to Practice Problems
+5
0
1
2
3
4
0
0
1
2
3
4
1
1
2
3
4
0
2
2
3
4
0
1
3
3
4
0
1
2
4
4
0
1
2
3
#5
0
1
2
3
4
0
0
0
0
0
0
1
0
1
2
3
4
2
0
2
4
1
3
3
0
3
1
4
2
4
0
4
3
2
1
	
b.	0; 1
	
c.	 3
	
d.	all except 0
	 10.	a.	
#6
0
1
2
3
4
5
0
0
0
0
0
0
0
1
0
1
2
3
4
5
2
0
2
4
0
2
4
3
0
3
0
3
0
3
4
0
4
2
0
4
2
5
0
5
4
3
2
1
	
b.	1 and 5
	 11.	a.	 01101+2 11011 = 10110
	
b.	 −10100 = 10100 because 10100 +2 10100 = 00000
	 12.	Let f, g, h [ S. Then for any x [ A, 3( f + g) + h4(x) = ( f + g)(h(x)) = f ( g3h(x)4) and 3 f + (g + h)4(x) =  
f 3(g + h)(x)4 = f (g3h(x)4). Hence, ( f + g) + h = f + (g + h).
	 13.	a.	
+
a1
a2
a3
a4
a5
a6
a1
a1
a2
a3
a4
a5
a6
a2
a2
a1
a6
a5
a4
a3
a3
a3
a5
a1
a6
a2
a4
a4
a4
a6
a5
a1
a3
a2
a5
a5
a3
a4
a2
a6
a1
a6
a6
a4
a2
a3
a1
a5
	
b.	No, because a2 + a3 = a6 but a3 + a2 = a5.
	 14.	a.	 No, because ab # a = aba but a # ab = aab.
	
b.	No, because no nonempty string has an inverse; for example, there is no string to concatenate with a to 
get l.
	 15.	i1 = i1 # i2 because i2 is an identity	
i1 # i2 = i2 because i1 is an identity
	 16.	Let y and z both be inverses of x. Let i be the identity. Then y = y # i = y # (x # z) = (y # x) # z = i # z = z.
	 17.	 7−1 = 5, 3−1 = 9; so 10−1 = (7 +12 3)−1 = 3−1 +12 7−1 = 9 +12 5 = 2
	 18.	
 z # x = z # y
 implies
	
	 z−1 # (z # x) = z−1 # (z # y)
	
	 (z−1 # z) # x = (z−1 # z) # y
	
	
 i # x = i # y
	
	
 x = y
	 21.	a.	 3Z18, +184
	
b.	 3S3, +4
	 20.	
*
1
a
b
c
d
1
1
a
b
c
d
a
a
b
c
d
1
b
b
c
d
1
a
c
c
d
1
a
b
d
d
1
A
b
c
	 19.	x = 1 +8 (3)−1 = 1 +8 5 = 6

Answers to Practice Problems	
845
	 22.	Requirement 2, i [ A, ensures that A ∙[.
	 23.	a.	 Closure holds:
+8
0
2
4
6
0
0
2
4
6
2
2
4
6
0
4
4
6
0
2
6
6
0
2
4
	
	 0 [ 50, 2, 4, 66; 0−1 = 0, 4−1 = 4, and 2 and 6 are inverses of each other.
	
b.	 Closure holds:
+7
1
2
4
1
1
2
4
2
2
4
1
4
4
1
2
	
	 1 [ 51, 2, 46; 1−1 = 1, and 2 and 4 are inverses of each other.
	 24.	 35al, a5, a66, +4 35a1, a26, +4 35a1, a36, +4 35a1, a46, +4
	 25.	To show that f  is one-to-one, let a and b belong to An and suppose f (a) = f (b). Then a + (1, 2) = b + (1, 2). 
By the cancellation law available in the group Sn, a = b. To show that f is onto, let g [ On. Then 
g + (1, 2) [ An and f (g + (1, 2)) = g + (1, 2) + (1, 2) = g + i = i.
	 26.	For nz1, nz2 [ nZ, nz1 + nz2 = n(z1 + z2) [ nZ, so closure holds; 0 = n # 0 [ nZ; for nz [ nZ, 
−nz = n(−z) [ nZ.
	 27.	
	 28.	 f (s) + f (s−1) = f (s # s−1) = f (iS) = iT. Similarly, f (s−1) + f (s) = iT. Therefore f (s−1) acts like the in-
verse of f (s) in T, and since inverses are unique, f (s−1) = −f (s).
	 29.	Let t1 and t2 be members of T. Because f  is onto, t1 = f (s1) and t2 = f (s2) for some s1, s2 [ S. Then
	
t1 + t2 = f (s1) + f (s2) = f (s1 # s2) = f (s2 # s1)	
(because 3S, #4 is commutative)
= f (s2) + f (s1) = t2 + t1
	
	 so 3T, +4 is commutative.
	 30.	Clearly f  is onto. f  is also on-to-one: Let f (x) = f ( y). Then 5x = 5y and x = y. f  is a homomorphism: 
For x, y [ Z,  f (x + y) = 5(x + y) = 5x + 5y = f (x) + f ( y).
	 31.	a.	 Composition of bijections is a bijection, and for x, y [ S, (g + f )(x # y) = g( f (x # y)) =  
g( f (x) + f ( y)) = g( f (x)) * g( f ( y)) = (g + f )(x) * ( g + f )( y)
	
b.	 S . S by the identity mapping. If f  is an isomorphism from S to T, then f −1 is an isomorphism from 
T to S. If S . T and T . V, then by part (a), S . V.

	 32.	To show that ag is an onto function, let y [ G. Then g−1 # y belongs to G and ag(g−1 # y) =  
g (g−1 # y) = (g # g−1)y = y. To show that ag is one-to-one, let ag(x) = ag( y). Then g # x = g # y, and by 
cancellation, x = y.
	 33.	a.	 For ag [ P, ag + a1 = ag#1 = ag and a1 + ag = al#g = ag
	
b.	 ag + ag−1 = ag#g−1 = a1 and ag−1 + ag = ag−1#g = a1
	 34.	a.	 Let f(g) = f(h). Then ag = ah and, in particular, ag(1) = ah(1), or g # 1 = h # 1 and g = h.
	
b.	For g, h [ G, f (g # h) = ag#h = ag + ah = f (g) + f (h).
	 35.	x r x because f (x) = f (x).
	
	 x r y S  y r x because if f (x) = f ( y) then f ( y) = f (x).
	
	 x r y and y r z S  x r z because if f (x) = f ( y) and f (  y) = f (z), then f (x) = f (z).
	 36.	K = 5x [ Z 0  f(x) = x # 31 = 06. Therefore K = 50, ± 3, ± 6, ± 9, …6 = 3Z.
	 37.	a.	 1 +8 S = 51 +8 0, 1 +8 2, 1 +8 4, 1 +8 66 = 51, 3, 5, 76
 	
	
3 +8 S = 53 +8 0, 3 +8 2, 3 +8 4, 3 +8 66 = 53, 5, 7, 16
	
	
7 +8 S = 57 +8 0, 7 +8 2, 7 +8 4, 7 +8 66 = 57, 1, 3, 56
	
b.	 2 +8 S = 52 +8 0, 2 +8 2, 2 +8 4, 2 +8 66 = 52, 4, 6, 06
	
	
2 +8 S = 0 +8 S = 4 +8 S = 6 +8 S
	 38.	H(X, Y) = 2
	 39.	Straightforward matrix multiplication using addition modulo 2. For example,
(01111)E
1
0
1
1
1
1
1
0
0
0
1
0
0
0
1
U = (000)
	 40.	00 S 00000
	
	 01 S 01111
	
	 11 S 11010
	
	 Together with 10 S 10101, these are the four code words given in Example 21.
	 41.	a.	 For example,
H = G
1
0
1
1
1
1
0
1
1
1
1
0
1
0
0
0
1
0
0
0
1
W
	
	
(There are other possibilities because the order of the rows in B does not matter.)
	
b.	 0000 S 0000000
	
	
0001 S 0001110
	
	
0010 S 0010011
846	
Answers to Practice Problems

Answers to Practice Problems	
847
	 44.	 Present state
Next state
Output
Present input
0
1
s0
s0
s3
0
s1
s0
s2
1
s2
s3
s3
1
s3
s1
s3
2
	
	
0011 S 0011101
	
	
0100 S 0100111
	
	
0101 S 0101001
	
	
0110 S 0110100
	
	
0111 S 0111010
	
	
1000 S 1000101
	
	
1001 S 1001011
	
	
1010 S 1010110
	
	
1011 S 1011000
	
	
1100 S 1100010
	
	
1101 S 1101100
	
	
1110 S 1110001
	
	
1111 S 1111111
	 42.	(11011)H = 001
	
	 (10100)H = 001
	
	 (01110)H = 001
	
	 (00001)H = 001
	 43.	000110
	 45.	a.	
	
b.	01011
	 46.	a.	 s1	
b.	 s1
	 47.	11001011
	 48.	

	 49.	a	 Set consisting of a single 0
	
b.	Set consisting of any number of 0s (including none) followed by 10
	
c.	 Set consisting of a single 0 or a single 1
	
d.	Set consisting of any number (including none) of pairs of 1s
	 50.	The string in part (b) does not belong.
	 51.	a.	 0	
b.	 0*10	
c.	 0 ~ 1	
d.	 (11)*
	 52.	s2, s3
	 53.	A state s produces the same output as itself for any input. If si produces the same output as sj, then sj pro-
duces the same output as si. Transitivity is equally clear.
	 54.	Property 1 is satisfied because all states in the same class have the same output strings for any input 
string, including the empty input string. To see that property 2 is satisfied, assume si and sj are equivalent 
states proceeding under the input symbol i to states si′ and sj′ that are not equivalent. Then there is an in-
put string a such that fO (si′, a) ∙fO (sj′, a). Thus, for the input string ia, si and sj produce different output 
strings, contradicting the equivalence of si and sj.
	 55.	Equivalent states of M in Table 9.9 are A = 50,1,36, B = 526, and C = 546. The reduced machine is
Present state
Next state
Output
Present input
0
1
A
B
A
1
B
C
A
0
C
A
A
0
	
	 Equivalent states of M in Table 9.10 are 506, 516, 526, and 536. M is already minimal.
	 56.	First, write the state table:
Present state
Next state
Output
Present input
0
1
s0
s0
s1
1
s1
s1
s0
0
	
	 The states can be encoded by a single delay element, as shown:
d
s0
0
s1
1
	
	 The truth functions are
x(t)
d(t)
y(t)
d(t + 1)
0
0
1
0
1
0
1
1
0
1
0
1
1
1
0
0
848	
Answers to Practice Problems

Answers to Practice Problems	
849
	
	 The canonical sum-of-products forms are
 y(t) = d′
d(t + 1) = xd′ + x′d
	
	 and the sequential network is
x(t)
d(t)
d(t)
d(t + 1)
d(t + 1)
y(t)
x'd
xd'
	 57.	a.	 …b 0 0 b...
	
b.	The machine cycles endlessly over the two nonblank tape squares.
	
c.	 The machine changes the two nonblank squares to 0 1 and then moves endlessly to the right.
	 58.	a.	 b X X 1 X X b 	
halts without accepting
	
	 		
	
	 		
5
	
b.	 b X X X X X b 	
halts without accepting
	
	 		
	
	 		
2
	
c.	 b X X X 0 X X b	
halts without accepting
	
	 		
	
	 		
2

	 59.	State 3 is the only final state.
(0, 1, 1, 0, R)	
move right,  ignoring 1s
(0, 0, 0, 1, R)	
a 0 has been read,  change state
(1, 0, 0, 2, R)	
a second 0 in succession has been read
(1, 1, 1, 0, R)	
no second 0,  start over
(2, 0, 0, 2, R)	
0s continue to be read
(2, 1, 1, 0, R)	
string of 0s broken before end of input,  start over
(2, b, b, 3, R)	
end of input follows string of at least two 0s,  accept
	
	 If we were not constrained to move only to the right, we could use the following machine, where state 4 
is the only final state.
(0, 0, 0, 1, R)
(0, 1, 1, 1, R)	
0 reads the first symbol so the tape is not blank
(1, 1, 1, 1, R)
(1, 0, 0, 1, R)	
state 1 reads to end of input,  moves left
(1, b, b, 2, L)	
(2, 0, 0, 3, L)	
reads one 0
(3, 0, 0, 4, L)	
reads second 0,  accepts
	 60.	Change (2, 1, X, 3, L) to (2, 1, X, 7, L) and add (7, 1, X, 3, L).
	 61.	One machine that works,  together with a description of its actions:
(0, 1, 1, 1, R) 
reads first 1
(1, b, 1, 6, R)	
n = 0,  changes to 1 and halts
(1, 1, 1, 2, R)	
reads second 1
(2, b, b, 6, R)	
n = 1,  halts
(2, 1, 1, 3, R)	
n ≥2
(3, 1, 1, 3, R)
(3, b, b, 4, L)	
finds right end of n 
(4, 1, b, 5, L)
(5, 1, b, 6, L)	
erases two 1s from n and halts
	 62.	0S 1  00S 1  000S 1  0000S 1  00001
	 63.	L = 50n1 0  n ≥06
	 64.	For example:
	
a.	 G(V, VT, S, P) where V = 50, 1, S6, VT = 50, 16,  and P = 5S S  1, S S  0S06
	
b.	 G = (V, VT, S, P) where V = 50, 1, S, M6, VT = 50, 16,  and P = 5S S  0M0, M S  0M0, M S  16
	 65.	In G1: S 1  ABA 1  00A 1  0000A 1  00000
	
	 In G2:  S 1  00A 1  0000A 1  00000
	
	 In G3:  S 1  0A 1  00B 1  000C 1  0000B 1  00000
850	
Answers to Practice Problems
¶
f
f
f
	 66.	

Answers to Odd-Numbered  
Exercises
(Note that these are answers, not necessarily complete solutions; your instructor 
may require more explanation or justification, as well as a different format, for 
some of these exercises.)
Chapter 1
Exercises 1.1
	
1.	a, c, d, e, f
	
3.	a.	 T        b.  T        c.  T        d.  F
	
5.	a.	 If there is sufficient water, then there is healthy plant growth.
	
	b.	 If there are further technological advances, then there is increased availability of information.
	
	 c.	 If errors were introduced, then there was a modification of the program.
	
	d.	 If there is fuel savings, then there is good insulation or storm windows throughout.
	
7.	a.	 A ~ B        b.  A′ ` B′
	
9.	a.	 1 and 3         b.  2        c.  4
	 11.	a.	 The food is good but the service is poor.
	
	b.	 The food is poor and so is the service.
	
	 c.	 Either the food is poor or the service is poor, but the price is low.
	
	d.	 Either the food is good or the service is excellent.
	
	 e.	 The price is high but either the food is poor or the service is poor.
	 13.	a.	 3A S B ` C4 ` (C′ S B)
	
	b.	 3(A ~ B) S C4 ` (C S B)′
	
	 c.	 (A ~ B) ` (A ` B)′
	
	d.	 (A ~ B) S C
	
	 e.	 A ~ (B S C )
	 15.	a.	 A ` B
	
	b.	 A ` (B ~ C )
	
	 c.	 B S (A ` C )
	
	d.	 A S (B′ ~ C′)
	
	 e.	 A ` 3C′ S (B′ ~ C )4
	 17.	a.	 Violets are blue or sugar is sour.
	
	b.	 Violets are not blue or, if roses are red, then sugar is sweet.
	
	 c.	 Sugar is sweet and roses are not red, if and only if violets are blue.
851

852	
Answers to Odd-Numbered Exercises
	
	d.	 Sugar is sweet, and roses are not red if and only if violets are blue. 
	
	 e.	 If it is false that both violets are blue and sugar is sour, then roses are red. 
	
	 f.	 Roses are red, or violets are blue and sugar is sour. 
	
	g.	 Roses are red or violets are blue, and sugar is sour.
	 19.	a.	 H S K    b.  K S (H ` A)    c.  K S H             d.  K 4 A      e.  (A ~ H) S K
	 21.	a.	 F S B     b.  B S F          c.  B′ S (F′ ` S)      d.  S S B′       e.  S 4 F′
	 23.	a.
A
B
A S B
A′
A′ ~ B
(A S B) 4 A′ ~ B
T
T
T
F
T
T
T
F
F
F
F
T
F
T
T
T
T
T
F
F
T
T
T
T
Tautology
	
	b.	
A
B
C
 A ` B
 (A ` B) ~ C
 B ~ C
 A ` (B ~ C)
(A ` B) ~ C S A ` (B ~ C)
T
T
T
T
T
T
T
T
T
T
F
T
T
T
T
T
T
F
T
F
T
T
T
T
T
F
F
F
F
F
F 
T
F
T
T
F
T
T
F 
F
F
T
F
F
F
T
F
T
F
F
T
F
T
T
F
F
F
F
F
F
F
F
F
T
	
c.	
A
B
  A′
  B′
 A′ ~ B′
(A′ ~ B′)′
 A ` (A′ ~ B′)′
T
T
F
F
F
T
T
T
F
F
T
T
F
F
F
T
T
F
T
F
F
F
F
T
T
T
F
F
	
d.	
A
B
 A′
 A ` B
 A ` B S A′
T
T
F
T
F
T
F
F
F
T
F
T
T
F
T
F
F
T
F
T
	
e.	
A
B
C
 A S B
 A ~ C
 B ~ C
 (A ~ C) S (B ~ C)
 (A S B) S 3(A ~ C) S (B ~ C)4
T
T
T
T
T
T
T
T
T
T
F
T
T
T
T
T
T
F
T
F
T
T
T
T
T
F
F
F
T
F
F
T
F
T
T
T
T
T
T
T
F
T
F
T
F
T
T
T
F
F
T
T
T
T
T
T
F
F
F
T
F
F
T
T
Tautology

Answers to Odd-Numbered Exercises	
853
	 25.	 lb.	
A
B
 A ` B
 B ` A
 A ` B  4  B ` A
T
T
T
T
T
T
F
F
F
T
F
T
F
F
T
F
F
F
F
T
	
2a.	
A
B
C
 A ~ B
(A ~ B) ~ C
 B ~ C
 A ~ (B ~ C)
 (A ~ B) ~ C  4  A ~ (B ~ C)
T
T
T
T
T
T
T
T
T
T
F
T
T
T
T
T
T
F
T
T
T
T
T
T
T
F
F
T
T
F
T
T
F
T
T
T
T
T
T
T
F
T
F
T
T
T
T
T
F
F
T
F
T
T
T
T
F
F
F
F
F
F
F
T
	
2b.
A
B
C
 A ` B
 (A ` B) ` C
 B ` C
 A ` (B ` C)
(A ` B) ` C  4  A ` (B ` C)
T
T
T
T
T
T
T
T
T
T
F
T
F
F
F
T
T
F
T
F
F
F
F
T
T
F
F
F
F
F
F
T
F
T
T
F
F
T
F
T
F
T
F
F
F
F
F
T
F
F
T
F
F
F
F
T
F
F
F
F
F
F
F
T
	
3a.   A
B
C
 B ` C  A ~ (B ` C)  A ~ B  A ~ C (A ~ B) ` (A ~ C)
A ~ (B ` C) 4 (A ~ B) ` (A ~ C)
T
T
T
T
T
T
T
T
T
T
T
F
F
T
T
T
T
T
T
F
T
F
T
T
T
T
T
T
F
F
F
T
T
T
T
T
F
T
T
T
T
T
T
T
T
F
T
F
F
F
T
F
F
T
F
F
T
F
F
F
T
F
T
F
F
F
F
F
F
F
F
T

854	
Answers to Odd-Numbered Exercises
	 27.	a.	 (A ` B′) ` C 3 A ` (B′ ` C) by 2b 3 A ` (C ` B′) by 1b 3 (A ` C) ` B′ by 2b
	
	b.	 (A ~ B) ` (A ~ B′) 3 A ~ (B ` B′) by 3a 3 A ~ 0 by 5b 3 A by 4a
	
	 c.	 A ~ (B ` A′) 3 (A ~ B) ` (A ~ A′) by 3a 3 (A ~ B) ` 1 by 5a 3 A ~ B by 4b
	 29.	If A is F and both B and C are T, then (A ` B) ~ C is T but A ` (B ~ C) is F. These two wffs are not 
equivalent.
	 31.	dogs AND NOT retrievers
	 33.	(novels OR plays) AND AIDS
	 35.	1.0, 2.4, 7.2, 5.3
	 37.	if not (Value1 < Value2) then statement1 else statement2 end if
	 39.	
A
B
 A S B
 A′
 A′ ~ B
 A S B  4  A′ ~ B
T
T
T
F
T
T
T
F
F
F
F
T
F
T
T
T
T
T
F
F
T
T
T
T
	 41.	a.	 Assign B′ ` (A S B) true and A′ false. From the second assignment, A is true. From the first assign-
ment, B′ is true (so B is false), and A S B is true. If A S B is true and A is true, then B is true. B is 
thus both true and false, and 3B′ ` (A S B)4 S A′ is a tautology. 
	
	b.	 Assign (A S B) ` A true and B false. From the first assignment, A is true and A S B is true. If A S B 
is true and A is true, then B is true. B is thus both true and false, and 3(A S B) ` A4 S B is a tautology. 
	
	 c.	 Assign (A ~ B) ` A′ true and B false. From the first assignment, A′ is true (and A is false), and A ~ B 
is true. If A ~ B is true and A is false, then B is true. B is thus both true and false, and (A ~ B) ` A′ S B 
is a tautology.
	 43.	225 = 232
	 45.	
A
B
 A ! B
T
T
F
T
F
T
F
T
T
F
F
F
	 3b.   A
B
C
 B ~ C  A ` (B ~ C)  A ` B  A ` C (A ` B) ~ (A ` C) A ` (B ~ C) 4 (A ` B) ~ (A ` C)
T
T
T
T
T
T
T
T
T
T
T
F
T
T
T
F
T
T
T
F
T
T
T
F
T
T
T
T
F
F
F
F
F
F
F
T
F
T
T
T
F
F
F
F
T
F
T
F
T
F
F
F
F
T
F
F
T
T
F
F
F
F
T
F
F
F
F
F
F
F
F
T
	 5b.	
A
 A′
 A ` A′
0
 A ` A′ 4  0
T
F
F
F
T
F
T
F
F
T
	 4a.	
A
0
 A ~ 0
 A ~ 0  4  A
T
F
T
T
F
F
F
T

Answers to Odd-Numbered Exercises	
855
A
B
 A ~ B
 A′
 B′
 A′ ` B′
 (A′ ` B′)′
 A ~ B 4 (A′ ` B′)′
T
T
T
F
F
F
T
T
T
F
T
F
T
F
T
T
F
T
T
T
F
F
T
T
F
F
F
T
T
T
F
T
	 47.	 a.	
A
B
 B′
 A ` B′
(A ` B′)′
 A S B
 A S B  4  (A ` B′)′
T
T
F
F
T
T
T
T
F
T
T
F
F
T
F
T
F
F
T
T
T
F
F
T
F
T
T
T
	
b.	
	
	 A ~ B is equivalent to A′ S B
A
B
 A ~ B
 A′
 A′ S B
 A ~ B  4  A′ S B
T
T
T
F
T
T
T
F
T
F
T
T
F
T
T
T
T
T
F
F
F
T
F
T
	 51.	 A ` B is equivalent to (A0B)0(A0B)
A
B
 A ` B
 A0B
 (A0B)0(A0B)
 A ` B 4 (A0B)0(A0B)
T
T
T
F
T
T
T
F
F
T
F
T
F
T
F
T
F
T
F
F
F
T
F
T
	
 	A′ is equivalent to A0A
A
 A′
 A0A
 A′  4  A0A
T
F
F
T
F
T
T
T
A
B
 A ` B
 B′
 A S B′
(A S B′)′
 A ` B  4  (A S B′)′
T
T
T
F
F
T
T
T
F
F
T
T
F
T
F
T
F
F
T
F
T
F
F
F
T
T
F
T
	 49.	A ` B is equivalent to (A S B′)′

856	
Answers to Odd-Numbered Exercises
	 53.	a.	 For A ` B to be true, we would want to know that both parts are true; if one part has an unknown truth 
value then it is unknown whether this is the case. For A ~ B to be true, we would want at least one part 
to be true; if one part is false and the other part has an unknown truth value, then it is unknown whether 
this is the case. Finally, if the truth value of A is unknown, then the truth value of A′ is also unknown. 
	
	b.	 N        c.  F        d.  T
	 55.	 3n
	 57.	Machine D is either clean or infected. In either case, by statements 3 and 1, respectively, C is infected. 
Because C is infected, then A is infected by statement 2. By statement 4, B is infected (because C is not 
clean). By statement 3, because B is infected, D is not clean. The conclusion is that all four machines are 
infected.
	 59.	This could include everyone because members are welcome and nonmembers are welcome. Or it could 
include no one because no one is both a member and a nonmember.
	 61.	If Percival is a liar, then his statement is false. Therefore it is false that there is at least one liar, and both 
Percival and Llewellyn must be truth-tellers. But this is impossible because we assumed Percival is a liar. 
Therefore Percival is a truth-teller, and his statement is true. Because he said, “At least one of us is a liar,” 
Llewellyn must be a liar. Therefore Percival is a truth-teller and Llewellyn is a liar.
	 63.	Rothwold’s statement is of the form A ~ B, where A stands for “I am a liar” and B stands for “Grymlin 
is a truth-teller.” If Rothwold is a liar, then his statement A ~ B is false, and the statement (A ~ B)′ must 
be true. By De Morgan's laws, A′ and B′ must both be true. But A′ is the statement that Rothwold is a 
truth-teller, which is not true. Therefore Rothwold must be a truth-teller, and his statement A ~ B is true. 
Statement A, however, is false because it says that Rothwold is a liar. So statement B must be true, and 
Grymlin is a truth-teller. Both are truth-tellers.
Exercises 1.2
	
1.	 mt
	
3.	 sim
	
5.	 By mt, the conclusion is that the car was not involved in the hit-and-run.
	
7.	 By simplification, the conclusion is that you will be paid tomorrow.
	
9.	1.	 hyp
	
	
2.	 hyp
	 	
3.	 hyp (deduction method)
	 	
4.	 2, 3, mp
	 	
5.	 1, 4, con
	 11.	1.	 hyp
	
	
2.	 hyp
	 	
3.	 hyp
	 	
4.	 2, 3, con
	 	
5.	 4, De Morgan
	 	
6.	 1, 5, mt
	 13.		1.	 (A ~ B′)′	
hyp
	2.	 (B S  C)	
hyp
	3.	 A′ ` (B′)′	
1, DeMorgan
	4.	 A′ ` B	
3, dn
	5.	 A′	
4, sim
	6.	B	
4, sim
	7.	C	
2, 6 mp
	8.	 A′ ` C	
5, 7, con
	 15.		1.	 A S B	
hyp
	2.	 A S (B S C)	
hyp
	3.	A	
hyp
	
4.	 B	
1, 3, mp
	
5.	 B S  C	
2, 3, mp
	
6.	 C	
4, 5, mp

Answers to Odd-Numbered Exercises	
857
	
	 1.	 A′	
hyp
	
	 2.	 A ~ B	
hyp
	
	 3.	 (A′)′ ~ B	
2, dn
	
	 4.	 A′ S B	
3, imp
	
	 5.	B	
1, 4, mp
	 17.	
	 19.	
	
	 1.	 A′ S  B′	
hyp
	
	 2.	 B	
hyp
	
	 3.	 A S  C	
hyp
	
	 4.	 (B′)′	
2, dn
	
	 5.	 (A′)′	
1, 4, mt
	
	 6.	 A	
5, dn
	
	 7.	 C	
3, 6, mp
	 21.	
	
	 1.	 A S  (B S  C)	
hyp
	
	 2.	 B	
hyp
	
	 3.	 A	
hyp (using deduction 
method again)
	
	 4.	 B S  C	
1, 3, mp
	
	 5.	 C	
2, 4, mp
	 23.	
	
	 1.	 A S  C	
hyp
	
	 2.	 C S  B′	
hyp
	
	 3.	 B	
hyp
	
	 4.	 (B′)′	
3, dn
	
	 5.	 C′	
2, 4, mt
	
	 6.	 A′	
1, 5, mt
	
	 1.	 A S  C	
hyp
	
	 2.	 C S  B′	
hyp
	
	 3.	 B	
hyp
	
	 4.	 A S  B′	
1, 2, hs
	
	 5.	 (B′)′	
3, dn
	
	 6.	 A′	
4, 5, mt
or
	
	 1.	 P ~ Q	
hyp
	
	 2.	 P′	
hyp
	
	 3.	 (P′)′ ~ Q	
1, dn
	
	 4.	 P′ S  Q	
3, imp
	
	 5.	 Q	
2, 4, mp
	 25.	
	
	 1.	 Q′ S  P′	
hyp
	
	 2.	 P	
hyp
	
	 3.	 (P′)′	
2, dn
	
	 4.	 (Q′)′	
1, 3, mt
	
	 5.	 Q	
4, dn
	 27.	
	 29.	
	
	 1.	 P′ S P′ ` P′	
Exercise 28
	
	 2.	 P′ S (P ~ P)′	
1, De Morgan
	
	 3.	 3P′ S (P ~ P)′4 S 3(P ~ P) S P4	
Exercise 27
	
	 4.	 P ~ P S P	
2, 3, mp
	 31.	
	
	 1.	 P	
hyp
	
	 2.	 P′	
hyp
	
	 3.	 P ~ Q	
1, add
	
	 4.	 Q ~ P	
3, comm
	
	 5.	 (Q′)′ ~ P	
4, dn
	
	 6.	 Q′ S P	
5, imp
	
	 7.	 (Q′)′	
2, 6, mt
	
	 8.	 Q	
7, dn
	 33.	Prove
P ~ (Q ` R) S (P ~ Q)
	
	 Rewriting the conclusion, the argument is
P ~ (Q ` R) S ((P′)′ ~ Q) by dn
or
P ~ (Q ` R) S (P′ S Q) by imp
	
	 1.	 P ~ (Q ` R)	
hyp
	
	 2.	 P′	
hyp
	
	 3.	 (P′)′ ~ (Q ` R)	
1, dn
	
	 4.	 P′ S (Q ` R)	
3, imp
	
	 5.	 Q ` R	
2, 4, mp
	
	 6.	 Q	
5, sim

858	
Answers to Odd-Numbered Exercises
	 35.	
	
	 1.	 P S Q	
hyp
	
	 2.	 P′ S Q	
hyp
	
	 3.	 Q′ S P′	
1, cont
	
	 4.	 Q′ S Q	
2, 3, hs
	
	 5.	 (Q′)′ ~ Q	
imp
	
	 6.	 Q ~ Q	
5, dn
	
	 7.	 Q	
6, self
	 37.	
	
	 1.	 A′ S B	
hyp
	
	 2.	 B S C	
hyp
	
	 3.	 C S D	
hyp
	
	 4.	 A′ S C	
1, 2, hs
	
	 5.	 A′ S D	
3, 4, hs
	
	 1.	 Y S Z′	
hyp
	
	 2.	 Y S Z	
hyp
	
	 3.	 Y	
hyp
	
	 4.	 Z′	
1, 3, mp
	
	 5.	 Z	
2, 3, mp
	
	 6.	 W	
4, 5, inc
	 39.	
	 41.	
	
	 1.	 (A ` B)′	
hyp
	
	 2.	 (C′ ` A)′	
hyp
	
	 3.	 (C ` B′)′	
hyp
	
	 4.	 A′ ~ B′	
1, De Morgan
	
	 5.	 B′ ~ A′	
4, comm
	
	 6.	 B S A′	
5, imp
	
	 7.	 (C′)′ ~ A′	
2, De Morgan
	
	   8.  C′ S A′	
7, imp
	
	   9.  C′ ~ (B′)′	
3, De Morgan
	
	 10.  (B′)′ ~ C′	
9, comm 
	
	 11.  B′ S C′	
10, imp
	
	 12.  B′ S A′	
8, 11, hs
	
	 13.  (B S A′) ` (B′ S A′)	
6, 12, con
	
	 14.  A′	
Exercise 35
	 43.	The argument is (E S Q) ` (E ~ B) ` Q′ S B
	
A proof sequence is
	
	 1.	 E S Q	
hyp
	
	 2.	 E ~ B	
hyp
	
	 3.	 Q′	
hyp
	
	 4.	 Q′ S E′	
1, cont
	
	 5.	 E′	
3, 4, mp
	
	 6.	 (E′)′ ~ B	
2, dn
	
	 7.	 E′ S B	
6, imp
	
	 8.	 B	
5, 7, mp
	 45.	The argument is
(C S F′) ` (F ~ S) S (C S S)
	
A proof sequence is
	
	 1.	 C S F′	
hyp
	
	 2.	 F ~ S	
hyp
	
	 3.	 C	
hyp
	
	 4.	 F′	
1, 3, mp
	
	 5.	 S	
2, 4, ds
	
	 1.	 A S S	
hyp
	
	 2.	 A ~ C	
hyp
	
	 3.	 S′	
hyp
	
	 4.	 A′	
1, 3, mt
	
	 5.	 C	
2, 4, ds
	 47.	The argument is 
	
3(A S S) ` (A ~ C) ` S′4 S C
	
A proof sequence is
The proof for
P ~ (Q ` R) S (P ~ R)
is similar.

Answers to Odd-Numbered Exercises	
859
	 49.	The argument is
	
3(R ` (F′ ~ N)) ` N′ ` (A′ S F)4 S (A ` R)
	
A proof sequence is:
	
1.	 R ` (F′ ~ N)	
hyp
	
2.	 N′	
hyp
	
3.	 A′ S  F	
hyp
	
4.	 R	
1, sim
	
5.	 F′ ~ N	
1, sim
	
6.	 N ~ F′	
5, comm
	
	  7.	 F′	
2, 6, ds
	
	  8.	 F′ S  (A′)′	
3, cont
	
	  9.	 (A′)′	
7, 8, mp
	
	10.	 A	
9, dn
	
	11.	 A ` R	
4, 10, con
	 51.	The argument is
	
3((J ~ L) S  C) ` T′ ` (C S  T  )4 S  J′
	
A proof sequence is
	
	 1.	 (J ~ L) S  C	
hyp
	
	 2.	 T′	
hyp
	
	 3.	 C S  T	
hyp
	
	 4.	 T′ S  C′	
3, cont
	
	 5.	 C′	
2, 4, mp
	
	 6.	 C′ S  (J ~ L)′	
1, cont
	
	 7.	 (J ~ L)′	
5, 6, mp
	
	 8.	 J′ ` L′	
7, De Morgan
	
	 9.	 J′	
8, sim
or
	
	 1.	 (J ~ L) S  C	
hyp
	
	 2.	 T′	
hyp
	
	 3.	 C S  T	
hyp
	
	 4.	 C′	
2, 3, mt
	
	 5.	 (J ~ L)′	
1, 4, mt
	
	 6.	 J′ ` L′	
5, De Morgan
	
	 7.	 J′	
6, sim
	 53.	The argument is 
	
(D S  T) ` (D ~ B) S  (T′ S  B)
	
A proof sequence is
	
	 1.	 D S  T	
hyp
	
	 2.	 D ~ B	
hyp
	
	 3.	 T′	
hyp
	
	 4.	 D′	
1, 3, mt
	
	 5.	 B	
2, 4, ds
	 55.	a.	
A
B
C
 B S  C
 A S  (B S  C)
 A ` B
(A ` B) S  C
 A S  (B S  C)  4  (A ` B) S  C
T
T
T
T
T
T
T
T
T
T
F
F
F
T
F
T
T
F
T
T
T
F
T
T
T
F
F
T
T
F
T
T
F
T
T
T
T
F
T
T
F
T
F
F
T
F
T
T
F
F
T
T
T
F
T
T
F
F
F
T
T
F
T
T
	
b.	A S  (B S  C) 3  A S  (B′ ~ C) 3  A′ ~ (B′ ~ C) 3  (A′ ~ B′) ~ C 3  (A ` B)′ ~ C 3
	
 (A ` B) S  C
	
c.	 By part (a) (or (b)), 3P1 `  P2 ` c` Pn4 S  (R S  S) 3  (P1 `  P2 ` c` Pn `  R) S  S, which 
says to take each of P1, P2, …, Pn, R as hypotheses and deduce S.

860	
Answers to Odd-Numbered Exercises
Exercises 1.3
	
1.	a.	 T    b.  F    c.  F    d.  T
	
3.	a.	 T    b.  T    c.  T    d.  F    e.  F    f.  T    g.  T    h.  F
	
5.	a.	 F    b.  T    c.  T    d.  F    e.  T    f.  T
	
7.	a.	 true: domain is the integers, A(x) is “x is even”, B(x) is “x is odd”, false: domain is the positive inte-
gers, A(x) is “x > 0”, B(x) is “x ≥1”
	
	b.	 true: domain is the collection of lines in the plane, P(x, y) is “x is parallel to y”, false: domain is the 
integers, P(x, y) is “x < y”
	
	 c.	 true: domain is the integers, P(x) is “x is even”, Q(x, y) is “y 0  x” (y divides x), false: domain is the col-
lection of all people, P(x) is “x is male”, Q(x, y) is “y is a brother of x”
	
9.	a.	 scope of (4x) is P(x) S  Q(y); y is a free variable
	
	b.	 scope of (Ex) is A(x) ` (4y)B(y); scope of (4y) is B(y); no free variables
	
	 c.	 scope of (Ex) is (4y)P(x, y) ` Q(x, y); scope of (4y) is P(x, y); y is a free variable
	
	d.	 scope of (Ex) is (Ey)3A(x, y) ` B(y, z) S  A(a, z)4; scope of (Ey) is A(x, y) ` B(y, z) S  A(a, z); z is a 
free variable
	 11.	b and c
Many parts of Exercises 13−24 have multiple equivalent answers, some of which are shown here.
	 13.	a.	 (4x)(D(x) S  S(x))
	
	b.	 (Ex)3D(x) ` (R(x))'4 or 3(4x)(D(x) S  R(x))4′
	
	 c.	 (4x)3D(x) ` S(x) S  (R(x))′4
	
	d.	 (Ex)3D(x) ` S(x) ` R(x)4
	
	 e.	 (4x)3D(x) S  (S(x) ` R(x))′4
	
	 f.	 (4x)3D(x) ` S(x) S  D(x) ` R(x)4
	
	g.	 (4x)3D(x) S  (S(x))′4
	
	h.	 S(M) S  (4x)(D(x) S  S(x))
	
	 i.	 R(M) ` R(T)
	
	 j.	 (Ex)(D(x) ` R(x)) S  (4x)(D(x) S  S(x))
	 15.	a.	 (4x)(M(x) S  T(x))
	
	b.	 (Ex)(W(x) ` T(x))
	
	 c.	 (4x)(M(x) S  T(x)) ` (4x)(W(x) S  3T(x)4′)
	
	d.	 (4x)(T(x) S  W(x))
	
	 e.	 (4x)3M(x) S  (T(x))′4
	
	 f.	 (4x)(M(x) S  T(x)) S  (4x)(W(x) S  T(x))
	
	g.	 (Ex)3W(x) ` (T(x))′4
	
	h.	 (4x)3M(x) S  (T(x))′4 S  (Ex)3W(x) ` (T(x))′4
	 17.	a.	 (Ex)3P(x) ` (4y)(T(y) S  F(x, y))4
	
	b.	 (4x)3P(x) S  (Ey)(T(y) ` F(x, y))4
	
	 c.	 (Ex)(Ey)(P(x) ` T(y) ` (F(x, y)′)
	 19.	a.	 (4x)(4y)(M(x) ` G(y) S  F(x, y))
	
	b.	 3(Ex)(G(x) ` (4y)(M(y) S  F(x, y)))4′ or (4x)(G(x) S  (Ey)(M(y) ` 3F(x, y)4′))
	
	 c.	 (4x)(4y)(M(y) ` F(x, y) S  G(x))
	
	d.	 (4x)(G(x) S  (Ey)(M(y) ` F(x, y))) or (4x)(Ey)(G(x) S  (M(y) ` F(x, y)))
	 21.	a.	 (Ex)(W(x) ` L(x) ` C(x))
	
	b.	 (4x)3W(x) S  (L(x) ` C(x))′4
	
	 c.	 (Ex)3L(x) ` (4y)(A(x, y) S  J(y))4 or (Ex)(4y)3L(x) ` (A(x, y) S  J(y))4

Answers to Odd-Numbered Exercises	
861
	
	d.	 (4x)3J(x) S  (4y)(A(x, y) S  J(y))4 or (4x)(4y)3J(x) S  (A(x, y) S  J(y))4 or 
	
	
	 (4x)(4y)3J(x) ` A(x, y) S  J(y)4
	
	 e.	 (4x)(4y)3(J(y) ` A(x, y)) S  J(x)4
	
	 f.	 (4x)(3W(x) ` L(x)4 S  (Ey)3J(y) ` A(x, y)4) or (4x)(Ey)(3W(x) ` L(x)4 S  3J(y) ` A(x, y)4)
	
	g.	 (Ex)(W(x) ` (4y)3L(y) S (A(x, y))′4) or (Ex)(W(x) ` (4y)3A(x, y) S  (L(y))′4)  or
	
	
	 (Ex)(4y)(W(x) ` 3L(y) S  (A(x, y))′4)
	 23.	a.	 (4x)3B(x) S  (4y)(F(y) S  L(x, y))4 or (4x)(4y)3(B(x) ` F(y)) S  L(x, y)4
	
	b.	 (Ex)3B(x) ` (4y)(F(y) S  L(x, y))4
	
	 c.	 (4x)3B(x) S  (Ey)(F(y) ` L(x, y))4
	
	d.	 (4x)3B(x) S  (4y)((L(x, y))′ S  F(y))4
	
	 e.	 (4y)3F(y) S  (4x)(L(x, y) S  B(x))4 or (4y)(4x)3(F(y) ` L(x, y)) S  B(x)4
	
	 f.	 (4x)3B(x) S  (4y)(L(x, y) S  F(y))4
	
	g.	 3(Ex)3B(x) ` (4y)(L(x, y) S  F(y))4 4′ or (4x)3B(x) S  (Ey)(L(x, y) ` (F(y))′)4
	
	h.	 (Ex)3B(x) ` (Ey)(F(y) ` L(x, y))4 or (Ex)(Ey)3B(x) ` F(y) ` L(x, y)4
	
	 i.	 ((Ex)3B(x) ` (4y)(L(x, y) S  F(y))4
	
	 j.	 (4x)3B(x) S  (Ey)(F(y) ` (L(x, y))′4
	
	k.	 (4x)3B(x) S  (4y)(F(y) S  (L(x, y))′)4 or (4x)(4y)3(B(x) ` F(y)) S  (L(x, y))′4
	
	 l.	 3(Ex)3B(x) ` (4y)(F(y) S  (L(x, y))′)4 4' or (4x)3B(x) S  (Ey)(F(y) ` L(x, y))4
	 25.	a.	 John is handsome and Kathy loves John.
	
	b.	 All men are handsome.
	
	 c.	 All women love only handsome men.
	
	d.	 A handsome man loves Kathy.
	
	 e.	 Some pretty woman loves only handsome men.
	
	 f.	 John loves all pretty women.
	 27.	a.	 2        b.  3        c.  3        d.  1
	 29.	a.	No Web site features audio.
	b.	Some Web site does not have audio or does not have video.
	 c.	Some Web site has neither audio nor video.
	d.	Every Web site has either audio or video.
	 e.	Some Web site does not have text and also either doesn’t have audio or doesn’t have video.
	 31.	a.	Every farmer grows something besides corn.
	b.	Some farmer does not grow corn.
	 c.	Someone besides a farmer grows corn.
	 33.	a.	Both sides are true exactly when A(x, y) holds for all x, y pairs.
	b.	Both sides are true exactly when some x, y pair satisfies the property A(x, y).
	 c.	If there is a single x that is in relation P to all y, then for every y an x exists (this same x) that is in rela-
tion P to y.
	d.	If a has property A, then something in the domain has property A. 
	 e.	If any member of the domain that has property A also has property B, then if all members of the domain 
have property A, all have property B.
	 35.	a.	valid: there is an x in the domain with property A says it is false that everything in the domain fails to 
have property A.
	
	b.	not valid: domain is the integers, P(x) is “x is even”, Q(x) is “x is prime”. Because there are prime in-
tegers, (Ex)Q(x) and therefore (4x)P(x) ~ (Ex)Q(x) is true. But it is false that every integer is even or 
prime, so the implication is false.
	 37.	If something in the domain has either property P or property Q, then something has property P or some-
thing has property Q, and vice versa.

862	
Answers to Odd-Numbered Exercises
Exercises 1.4
	
1.	The conclusion is that pansies are plants. The hypotheses have the form (4x)(F(x) S  P(x)) ` F(p). By 
universal instantiation, F(p) S  P(p), then by modus ponens, P(p).
	
3.	The conclusion is that pansies are red. The hypotheses have the form (4x)3F(x) S  (R(x) ~ P(x))4 `
F(p) ` 3P(p)4′. By universal instantiation, F(p) S  (R(p) ~ P(p)), then by modus ponens, R(p) ~ P(p), 
and finally by disjunctive syllogism, R(p).
	
5.	No conclusion is possible. Just because pansies are flowers, it does not make them either red or purple. 
The hypotheses have the form (Ex)(F(x) ` R(x)), (Ex)(F(x) ` P(x)), F(p). But existential instantiation 
does not allow us to use p in removing the existential quantifiers, so we can say nothing further about 
pansies.
	
7.	 1.	 hyp
	
	2.	 1, ei
	
	3.	 hyp
	
	4.	 3, ui
	
	5.	 2, 4, mp
	
	6.	 5, eg
	
9.	 a.	 The domain is the set of integers, P(x, y) is “x < y”, and Q(x, y) is “x > y”; for every integer x, there is 
some integer that is larger and there is some integer that is smaller. But it is false that for every integer 
x there is some one integer that is both larger and smaller than x. 
	
	b.	 To get to step 2, ei was performed on two different existential quantifiers, neither of which was in front 
with the whole rest of the wff as its scope. Also, both existential quantifiers were removed at once, with 
the same constant a substituted for the variable in each case; this should be done in two steps, and the 
second would then have to introduce a new constant not previously used in the proof. And at step 3, 
the existential quantifier was not inserted at the front of the wff.
	 21.	 1.	 (4x)(P(x))′	
hyp
	
	 2.	 (P(x))′	
1, ui 
	
	 3.	 P(x)	
temporary hyp
	
	 4.	
Q(x)	
2, 3, inc
	
	 5.	 P(x) S  Q(x)	
temporary hyp  
discharged
	
	 6.	 (4x)(P(x) S  Q(x))	
5, ug
	 11.	 1.	 (4x)P(x) 	
hyp
	
	 2.	 P(x)	
l, ui
	
	 3.	 P(x) ~ Q(x)	
2, add
	
	 4.	 (4x)(P(x) ~ Q(x))	
3, ug (note that P(x) ~ Q(x) was deduced from (4x)P(x) in which x is not free
	 13.	 1.	 (Ex)(Ey)P(x, y)	
hyp
	
	 2.	 (Ey)P(a, y)	
1, ei
	
	 3.	 P(a, b)	
2, ei
	
	 4.	 (Ex)P(x, b)	
3, eg
	
	 5.	 (Ey)(Ex)P(x, y)	
4, eg
	 15.	 1.	 (4x)P(x)	
hyp
	
	 2.	 (Ex)3P(x)4′	
hyp
	
	 3.	 3P(a)4′	
2, ei
	
	 4.	 P(a)	
1, ui
	
	 5.	 Q(a)	
3, 4, inc
	
	 6.	 (Ex)Q(x) 	
5, eg
	 17.	 1.	 (Ex)(A(x) ` B(x))	
hyp
	
	 2.	 A(a) ` B(a) 	
1, ei
	
	 3.	 A(a)	
2, sim
	
	 4.	 B(a)	
2, sim
	
	 5.	 (Ex)A(x)	
3, eg
	
	 6.	 (Ex)B(x) 	
4, eg
	
	 7.	 (Ex)A(x) ` (Ex)B(x) 	
5, 6, con
	 19.	Domain is the integers, P(x) is “x is even”, Q(x, y) is “x = 2y + 1” (which means that x is odd). Then 
(Ex)P(x) is true (x = 2) and (Ex)(Ey)Q(x, y) is true (3 = 2 * 1 + 1), but (Ex)(Ey)3P(x) ` Q(x, y)4 is 
false (no x is both even and odd).
	 23.	1.	 (Ex)(4y)Q(x, y)	
hyp
	
	 2.	 (4y)Q(a, y)	
1, ei
	
	 3.	 Q(a, y)	
2, ui
	
	 4.	 (Ex)Q(x, y)	
3, eg
	
	 5.	 (4y)(Ex)Q(x, y)	
4, ug

Answers to Odd-Numbered Exercises	
863
	 25.	1.	 (4x)(A(x) S  B(x))	
hyp
	
	 2.	 (Ex)A(x)	
hyp
	
	 3.	 A(a)	
2, ei
	
	 4.	 A(a) S  B(a)	
1, ui
	
	 5.	 B(a)	
3,4, mp
	
	 6.	 (Ex)B(x)	
5, eg
	 27.	 1.	 P(x) S  (Ey)Q(x, y)	
hyp
	
	 2.	 P(x) 	
temporary hyp
	
	 3.	
(Ey)Q(x, y)	
1, 2, mp
	
	 4.	
Q(x, a) 	
3, ei
	
	 5.	 P(x) S  Q(x, a)	
temporary hyp 		
	
	 	
	
­discharged
	
	 6.	 (Ey)(P(x) S  Q(x, y))	
5, eg
	 29.	1.	 (Ex)3P(x) ` Q(x)4	
hyp
	
	 2.	 (4y)3Q(y) S  R(y)4	
hyp
	
	 3.	 P(a) ` Q(a)	
1, ei
	
	 4.	 P(a)	
3, sim
	
	 5.	 Q(a)	
3, sim
	
	 6.	 Q(a) S  R(a)	
2, ui
	
	 7.	 R(a)	
5, 6, mp
	
	 8.	 P(a) ` R(a)	
4, 7, con
	
	 9.	 (Ex)3P(x) ` R(x)4	
8, eg
	 31.	a.	 (4x)(M(x) S  P(x)) ` (4x)(S(x) S  M(x)) S  (4x)(S(x) S  P(x))
	
	 1.	 (4x)(M(x) S  P(x))	
hyp
	
	 2.	 (4x)(S(x) S  M(x))	
hyp
	
	 3.	 M(x) S  P(x)	
1, ui
	
	 4.	 S(x) S  M(x)	
2, ui
	
	 5.	 S(x) S  P(x)	
3, 4 hs
	
	 6.	 (4x)(S(x) S  P(x))	
5, ug
	
b.	 (4x)(M(x) S  3P(x)4′) ` (4x)(S(x) S  M(x)) S  (4x)(S(x) S  3P(x)4′)
	
	 1.	 (4x)(M(x) S  3P(x)4′)	
hyp
	
	 2.	 (4x)(S(x) S  M(x))	
hyp
	
	 3.	 M(x) S  3P(x)4′	
1, ui
	
	 4.	 S(x) S  M(x)	
2, ui
	
	 5.	 S(x) S  3P(x)4′	
3, 4, hs
	
	 6.	 (4x)(S(x) S  3P(x)4′)	
5, ug
	
c.	 (4x)(M(x) S  P(x)) ` (Ex)(S(x) ` M(x)) S  (Ex)(S(x) ` P(x))
	
	 1.	 (4x)(M(x) S  P(x))	
hyp
	
	 2.	 (Ex)(S(x) ` M(x))	
hyp
	
	 3.	 S(a) ` M(a)	
2, ei
	
	 4.	 M(a)	
3, sim
	
	 5.	 M(a) S  P(a)	
1, ui
	
	 6.	 P(a)	
4, 5, mp
	
	 7.	 S(a)	
3, sim
	
	 8.	 S(a) ` P(a)	
6, 7, con
	
	 9.	 (Ex)(S(x) ` P(x))	
8, eg
	
	 1.	 (4x)(M(x) S  3P(x)4′)	
hyp
	
	 2.	 (Ex)(S(x) ` M(x))	
hyp
	
	 3.	 S(a) ` M(a)	
2, ei
	
	 4.	 M(a) S  3P(a)4′	
1, ui
	
	 5.	 M(a)	
3, sim
	
	 6.	 3P(a)4′	
4, 5, mp
	
	 7.	 S(a)	
3, sim
	
	 8.	 S(a) ` 3P(a)4′	
6, 7, con
	
	 9.	 (Ex)(S(x) ` 3P(x)4′)	
8, eg
	
d.	 (4x)(M(x) S  3P(x)4′) S  (Ex)(S(x) ` M(x)) S  (Ex)(S(x) ` 3P(x)4′)
	 33.	The argument is
(4x)(4y)3C(x) ` A(y) S  B(x, y)4 ` C(s) ` (Ex)(S(x) ` 3B(s, x)4′) S  (Ex)3A(x)4′
	
	 A proof sequence is
	
	  1.	(4x)(4y)3C(x) ` A(y) S  B(x, y)4	
hyp
	
	  2.	 C(s)	
hyp
	
	  3.	 (4y)3C(s) ` A(y) S  B(s, y)4	
1, ui
	
	  4.	 (Ex)(S(x) ` 3B(s, x)4′)	
hyp
	
	  5.	 S(a) ` 3B(s, a)4′	
4, ei
	
	  6.	 C(s) ` A(a) S  B(s, a)	
3, ui
	
	  7.	 3B(s, a)4′	
5, sim
	
	  8.	 3C(s) ` A(a)4′	
6, 7, mt
	
	  9.	 3C(s)4′ ~ 3A(a)4′	
8, De Morgan
	
	10.	 3 3C(s)4′4′	
2, dn
	
	11.	 3A(a)4′	
9, 10, ds
	
	12.	 (Ex)3A(x)4′	
11, eg

864	
Answers to Odd-Numbered Exercises
	 35.	The argument is
(4x)(M(x) S  I(x) ~ G(x)) ` (4x)(G(x) ` L(x) S  F(x)) ` (I(j))′ ` L(j) S  3(M(j) S  F(j))4
	
	 A proof sequence is
	
1.	 (4x)(M(x) S  I(x) ~ G(x))	
hyp
	
2.	 (4x)(G(x) ` L(x) S  F(x))	
hyp
	
3.	 M(j) S  I(j) ~ G(j)
1, ui
	
4.	 G(j) ` L(j) S  F(j)	
2, ui
	
5.	 M(j)	
hyp
	
6.	 I(j) ~ G(j)	
3, 5, mp
	
  7.	(I(j))′	
hyp
	
  8.	G(j)	
6, 7, ds
	
  9.	L(j)	
hyp
	
10.	G(j) ` L(j)	
8, 9, con
	
11.	F(j)	
4,10, mp
	 37.	The argument is
 (4x)(R(x) S  F(x)) ` (Ex)(R(x) ` B(x)) ` (4x)(G(x)′ S  B(x)′) S  (Ex)(G(x) ` F(x))
	
	 A proof sequence is
	
	 1.	 (4x)(R(x) S  F(x))	
hyp
	
	 2.	 (Ex)(R(x) ` B(x))	
hyp
	
	 3.	 (4x)(G(x)′ S  B(x)′)	
hyp
	
	 4.	 R(a) ` B(a)	
2, ei
	
	 5.	 R(a) S  F(a)	
1, ui
	
	 6.	 R(a)	
4, sim
	
	 7.	 B(a)	
4, sim
	  8.	F(a)	
5, 6, mp
	  9.	G(a)′ S  B(a)′	
3, ui
	10.	B(a) S  G(a)	
9, cont
	11.	G(a)	
7, 10, mp
	12.	G(a) ` F(a)	
8, 11, con
	13.	(Ex)(G(x) ` F(x))	
12, eg
	 39.	The argument is
 (4x)(C(x) S  (Ey)W(x, y)) ` (4x)(4y)(W(x, y) S  S(x, y)) ` C(m) S  (Ey)S(m. y) 
	
	 A proof sequence is
	
	 1.	 (4x)(C(x) S  (Ey)W(x, y))	
hyp
	
	 2.	 C(m) S  (Ey)W(m, y)	
1, ui
	
	 3.	 C(m)	
hyp
	
	 4.	 (Ey)W(m, y)	
2, 3, mp
	
	 5.	 (4x)(4y)(W(x, y) S  S(x, y))	
hyp
	
	  6.	 (4y)(W(m, y) S  S(m, y))	
5, ui
	
	  7.	 W(m, a)	
4, ei
	
	  8.	 W(m, a) S  S(m, a)	
6, ui 
	
	  9.	 S(m, a)	
7, 8, mp
	
	10.	 (Ey)S(m, y)	
9, eg
	 41.	The argument is
(Ex)(E(x) ` (4y)(M(y) S  A(x, y))) ` (Ex)(M(x) ` S(x)) S  (Ex)(E(x) ` (Ey)(S(y) ` A(x, y)))
	
	 A proof sequence is
	  1.	(Ex)(E(x) ` (4y)(M(y) S  A(x, y)))	
hyp
	  2.	(Ex)(M(x) ` S(x))	
hyp
	  3.	E(a) ` (4y)(M(y) S  A(a, y))	
1, ei
  	4.	(4y)(M(y) S  A(a, y))	
3, sim
  	5.	M(b) ` S(b)	
2, ei
  	6.	M(b) S  A(a, b)	
4, ui
  	7.	M(b)	
5, sim
  	8.	A(a, b)	
6, 7, mp
  	9.	S(b)	
5, sim
	10.	S(b) ` A(a, b)	
8, 9, con
	11.	(Ey)(S(y) ` A(a, y))	
10, eg
	12.	E(a)	
3, sim
	13.	E(a) ` (Ey)(S(y) ` A(a, y))	
11, 12 con
	14.	(Ex)(E(x) ` (Ey)(S(y) ` A(x, y)))	
13, eg

Answers to Odd-Numbered Exercises	
865
	 43.	 3(Ex)3A(x)4′4′ 4 (4x)3 3A(x)4′4′	
neg, using 3A(x)4′ for A(x)
3(Ex)3A(x)4′4′ 4 (4x)A(x)	
dn
3(4x)A(x)4′ 4 (3(Ex)3A(x)4′4′)′	
cont (each direction)
3(4x)A(x)4′ 4 (Ex)3A(x)4′	
dn
Exercises 1.5
	
1.	yes
	
3.	no
	
5.	fish
	
7.	fox, deer
	
9.	herbivore(X) <= eat(X, Y) and plant(Y)
	
11.	fox
	 13.	a.	anita
	b.	mike, kim
	 c.	judith, sam, mike, kim, joan, hamal, enrique, jefferson
	 15.	a.	?authorof (marktwain, houndofthebaskervilles) 
	b.	?authorof (williamfaulkner, X) 
	 c.	nonfictionauthor(X) <= authorof (X, Y) and not fiction(Y)
	d.	?nonfictionauthor(X) 
	
17.	a.	 fatherof (X, Y) <= parentof (X, Y) and male(X)
	b.	daughterof (X, Y) <= parentof (Y, X) and female(X)
	 c.	ancestorof (X, Y) <= parentof (X, Y), ancestorof (X, Y) <= parentof (X, Z) and ancestorof (Z, Y)
	 19.	a.	?dry(X) and ingredientof (X, Y))
	b.	?perishable(Y) and ingredientof (X, Y) and liquid(X)
	 c.	 foundin(X, Y) <= ingredientof (X, Y), foundin(X, Y) <= ingredientof (X, Z) and foundin(Z, Y)
	 21.	The results should agree with the results for Exercises 13 and 14.
Exercises 1.6
	
1.	x + 1 = y −1 4 x = y −2
	
3.	3x −1 = 2y −1 4 3x = 2y
	
5.	Working backward from the postcondition using the assignment rule, 
5x + 3 = 46  4  x = 1
	
y = x + 3
52y = 8 or y = 46
	
y = 2 * y 
5y = 86
	
7.	Working backward from the postcondition using the assignment rule,
52x + 1 = 16  4  x = 0
	
z = 2x + 1
5z −1 = 0 or z = 16
	
5y = 06

866	
Answers to Odd-Numbered Exercises
	
9.	 Working backward from the postcondition using the assignment rule,
5x(x −1) = x(x −1)6
	
y = x −1 
5xy = x(x −1)6
	
y = x * y
5y = x(x −1)6
	
	 Because the precondition is always true, so is each subsequent assertion, including the postcondition.
	 11.	 Using the conditional rule, the two implications to prove are
5y = 0 and y < 56 y = y + 15y = 16 and5y = 0 and y ≥56 y = 5 5y = 16
	
	 The first is true by the assignment rule. Working backward from the postcondition,
5y + 1 = 16 4 y = 0 
	
y = y + 1
5y = 16
	
	 The second is true because the antecedent is false.
	 13.	 Using the conditional rule, the two implications to prove are
5x ∙0 and x > 06 y = 2 * x 5y > 06 and 5x ∙0 and x ≤06 y = (−2) * x 5y > 06 
The first is true by the assignment rule. Working backward from the postcondition,
52*x > 06 4 x > 0 4 x ∙0 and x > 0
	
y = 2 * x
5y > 06
	
	 The second is true by the assignment rule. Working backward from the postcondition,
5(−2) * x > 06  4  x < 0  4  x ∙0 and x ≤0
	
y = (−2) * x
5y > 06
	 15.	 Using the conditional rule and the definition of absolute value for a nonzero number, the two implications 
to prove are
5x ∙0 and x ≥06 abs = x 5(x > 0 and abs = x)  or (x < 0 and abs5−x)6
5x ∙0 and x < 06 abs = −x 5(x > 0 and abs =  x) or (x < 0 and abs = −x)6
	
	 Using the assignment rule on the first implication gives the precondition
(x > 0 and x = x) or (x < 0 and x = −x)  4  (x > 0 and x = x)  4  (x ∙0and x ≥0).
	
	 Using the assignment rule on the second implication gives the precondition
	
(x > 0 and −x = x) or (x < 0 and −x = −x)  4  (x < 0 and −x = −x)  4  (x ∙0 and x < 0) 
Chapter 2
Exercises 2.1
	
1.	 a.	If there is not healthy plant growth, then there is not sufficient water.
	b.	If there is not increased availability of information, then there are no further technological advances.
	 c.	No modification of the program implies that errors will not be introduced.
	d.	Poor insulation and some windows not storm windows implies no fuel savings.

Answers to Odd-Numbered Exercises	
867
	
3.	For example:
	
	a.	a nonsquare rectangle
	b.	0
	 c.	a short, blue-eyed redhead
	d.	a redhead who is short
	
5.	Half of this statement is true. If n is an odd integer, 3n + 5 is an even integer. However, the converse is 
false. Consider the even integer 6. If 3n + 5 = 6, then 3n = 1 and n = 1∙3, which is not an integer at all, 
much less an odd integer. See Exercise 25.
	
7.	a.	 4 + 6 = 10; 4 and 6 are even but 10 is not a multiple of 4.
	b.	The error lies in choosing both x and y to be equal to 2m. This makes them the same number, which is 
a special case.
	
9.	25 = 52 = 9 + 16 = 32 + 42, 100 = (10)2 = 36 + 64 = 62 + 82, 169 = (13)2 = 25 +144 =
52 + (12)2
	 11.	n = 1, n! = 1, 2n = 2; n = 2, n! = 2, 2n = 4; n = 3, n! = 6,  2n = 8
	 13.	Let x = 2m, y = 2n, where m and n are integers. Then x + y = 2m + 2n = 2(m + n), where m + n is 
an integer, so x + y is even.
	 15.	Let x = 2m + 1, y = 2n + 1, where m and n are integers. Then x + y = (2m + 1) + (2n + 1) =
2m + 2n + 2 = 2(m + n + 1), where m + n + 1 is an integer, so x + y is even.
	 17.	Let x = 2m + 1 and y = 2n where m and n are integers. Then x −y = 2m + 1 −2n = 2(m −n) + 1 
where m −n is an integer, so x −y is odd.
	 19.	For two consecutive integers, one is even and one is odd. The product of an even integer and an odd inte-
ger is even by the proof of Example 9.
	 21.	Let x = 2m where m is an integer. Then x2 = (2m)2 = 4m2, where m2  is an integer, so x2 is divisible by 4.
	 23.	The contrapositive is: if x + 1 ≤0, then x ≤0. If x + 1 ≤0, then x ≤−1 < 0, so x < 0 and therefore 
x ≤0.
	 25.	If n is odd, then n = 2k + 1 for some integer k. Then 3n + 5 = 3(2k + 1) + 5 = 6k + 8. For the con-
verse, if 3n + 5 = 6k + 8 for some integer k, then 3n = 6k + 3 or 3n = 3(2k + 1) and n = 2k + 1 for 
some integer k, so n is an odd integer.
	 27.	If x < y then multiplying both sides of the inequality by the positive numbers x and y in turn gives x2 < xy 
and xy < y2 and therefore x2 < xy < y2 or x2 < y2. For the other direction, if x2 < y2  then y2 −x2 > 0 
by the definition of <, (y + x)(y −x) > 0 by factoring, (y + x) < 0 and (y −x) < 0 or (y + x) > 0 
and (y −x) > 0 because a positive number is the product of two negatives or two positives. But it cannot 
be that (y + x) < 0 because y and x are both positive; therefore (y + x) > 0 and y −x > 0 and y > x.
	 29.	Let n be a prime number with n = 2k, where k is an integer. Then both 2 and k divide n. Because n is 
prime, n is divisible only by itself and 1, so n = 2 and k = 1. Therefore n = 2.
	 31.	Let p and q be divisible by n. Then p = k1n and q = k2n, where k1 and k2 are integers, and 
p + q = k1n + k2n = (k1 + k2)n, where k1 + k2 is an integer. Therefore p + q is divisible by n.
	 33.	Because n 0  m, m = k1n for some integer k1. Because m 0  p, p = k2m for some integer k2. Then 
p = k2m = k2(k1n) = (k2k1)n where k2k1 is an integer, so n 0  p.
	 35.	Let x = 2n + 1. Then x2 = (2n + 1)2 = 4n2 + 4n + 1 = 4n(n + 1) + 1. But n(n + 1) is even (Exer-
cise 19), so n(n + 1) = 2k for some integer k. Therefore  x2 = 4(2k) + 1 = 8k + 1.
	 37.	m2n2 = (mn)2
	 39.	Proof by cases, depending on whether x and y are negative. Case 1: x ≥0, y ≥0. Then 0x0 = x, 0y0 = y. 
Also, x + y ≥0 and 0x + y0 = x + y. Therefore 0x + y0  = x + y =  0x0 + 0y0. Case 2: x ≥0, y < 0. 
Then 0x0  = x, 0y0  = −y. Subcase a: x + y ≥0. Then 0x + y0  = x + y. Therefore 0x + y0  =

868	
Answers to Odd-Numbered Exercises
x + y < x + (−y) (remember that y is negative, so −y is positive) =  0x0 + 0y0. Subcase b: x + y < 0. 
Then 0x + y0 = −(x + y). Therefore 0x + y0  = −(x + y) = (−x) + (−y) ≤x + (−y) (remember that 
x ≥0, so −x ≤0) =  0x0 + 0y0. Case 3: x < 0, y ≥0. Similar to Case 2 with the roles of x and y reversed. 
Case 4: x < 0, y < 0. Then 0x0  = −x, 0y0  = −y. Also, x + y < 0 and 0x + y0  = −(x + y). Therefore 
0x + y0  = −(x + y) = (−x) + (−y) =  0x0 + 0y0.	
	 41.	Proof by contradiction. If x1 < A, x2 < A,  c, and xn < A, then x1 + x2 + c+  xn < A + A +
c+  A = nA, and (x1 + x2 + c+  xn)∙n <  A, which contradicts the definition of A as the ­average of 
x1, …, xn.
	 43.	Assume that "3 is rational. Then "3 = p∙q where p and q are integers, q ∙0, and p and q have no 
common factors (other than ± 1). If "3 = p∙q then 3 = p2∙q2 or 3q2 = p2. Then 3 divides p2  so 3 
divides p. Thus 3 is a factor of p or 9 is a factor of p2 , and the equation 3q2 = p2 can be written 3q2 = 9x 
or q2 = 3x. Then 3 divides q2 so 3 divides q. Therefore 3 is a common factor of p and q, a contradiction.
	 45.	Assume that "
3 2 is rational. Then "
3 2 = p∙q where p and q are integers, q ∙0, and p and q have no com-
mon factors (other than ±1). If "
3 2 = p∙q then 2 = p3∙q3 or 2q3 = p3. Then 2 divides  p3 so 2 ­divides 
p. Thus 2 is a factor of p, or 8 is a factor of  p3, and the equation 2q3 = p3 can be written 2q3 = 8x or 
q3 = 4x. Then 2 divides 4x so 2 divides q3 or 2 divides q. Therefore 2 is a common factor of p and q, a 
contradiction.
	 47.	0 = (0)2, which is an integral multiple of 2.
	 49.	297 is a composite number; 297 = 3*3*3*11 
	 51.	Counterexample: 9 −7 = 2
	 53.	Proof: If x is even, then x = 2n and x(x + 1)(x + 2) = (2n)(2n + 1)(2n + 2) = 23(n)(2n + 1)(2n + 2)4, 
which is even. If x is odd, then x = 2n + 1 and x(x + 1)(x + 2) = (2n + 1)(2n + 2)
(2n + 3) = 23(2n + 1)(n + 1) (2n + 3), which is even.
	 55.	Proof: If x is even, then x = 2n and 2n + (2n)3 = 2n + 8n3 = 2(n + 4n3), which is even. If x is odd, then  
x = 2n + 1 and (2n + 1) + (2n + 1)3 = (2n + 1) + (8n3 + 12n2 + 6n + 1) = 8n3 + 12n2 + 8n +
2 = 2(4n3 + 6n2 + 4n + 1), which is even.
	 57.	Counterexample: 3 × 9 = 27
	 59.	Let n be odd and m be even. Then n2 is odd by Example 9 and m2 is even by Example 5. Then n2 + m2 is 
the sum of an odd and an even, so it is odd by Exercise 16.
	 61.	For n = 1, n + 1
n = 1 + 1
1 = 2. For n ≥2, n + 1
n ≥2 + 1
n > 2 because 1∙n is a positive number.
	 63.	Counterexample: 5 is prime, but 5 + 4 = 9 is not prime.
	 65.	Proof: n2 −1 = (n + 1)(n −1) where n −1 > 1 (because n > 2), which is a nontrivial factorization, 
so the number is not prime.
	 67.	Counterexample: 42 + 4 + 1 = 21 = 3(7), not prime.
	 69.	Proof: Let x and y be rational numbers, x = p∙q, y = r∙s with p, q, r, s integers and q, s ∙0. Then 
x + y = p∙q + r∙s = (ps + rq)∙qs, where ps + rq and qs are integers with qs ∙0, and any common 
factors between q and s can be removed. Thus x + y is rational.
	 71.	Counterexample: "2 is irrational but "2 × "2 = 2, which is rational.
	 73.	Angle 6 plus Angle 5 plus the right angle sum to 180° by the first fact. The right angle is 90° by the fourth 
fact. Therefore Angle 6 plus Angle 5 sum to 90°. Angle 6 is the same size as Angle 3 by the second fact. 
Therefore Angle 3 plus Angle 5 sum to 90°.
	 75.	Assume that Angle 1 and Angle 5 are the same size. As in Exercise 73, Angle 3 plus Angle 5 sum to 90°. 
Because Angle 1 and Angle 5 are the same size, Angle 3 plus Angle 1 sum to 90°. Also, Angle 3 plus Angle 

Answers to Odd-Numbered Exercises	
869
1 plus Angle 2 sum to 180° by the first fact. Therefore 90° plus Angle 2 sum to 180°, or Angle 2 = 90°. 
Angle 2 is a right angle by the fourth fact.
Exercises 2.2
	
1.	a.	P(1): 4(1) − 2 = 2(1)2 or 2 = 2, (true)
	b.	P(k): 2 + 6 + 10 + c + (4k − 2) = 2k2 
	 c.	P(k + 1): 2 + 6 + 10 + c + 34(k + 1) − 24 = 2(k + 1)2
	d.	Left side of P(k + 1) = 2 + 6 + 10 + c + 34(k + 1) − 24 = 2 + 6 + 10 + c + (4k − 2) +
34(k + 1) − 24 (write next-to-last term)  = 2k2 + 4(k + 1) − 2 (using P(k)) = 2k2 + 4k + 2 =  
2(k2 + 2k + 1) = > 2(k + 1)2 which is the right side of P(k + 1).
	
3.	Base case: P(1): 1 = 1(2(1) − 1), (true). Assume P(k): 1 + 5 + 9 + c + (4k − 3) = k(2k − 1). Show 
P(k + 1): 1 + 5 + 9 + c +  34(k + 1) − 34 = (k + 1)32(k + 1) − 14. Left side of P(k + 1) = 1 + 5 
+ 9 + c +  34(k + 1) − 34 = 1 + 5 + 9 + c + (4k − 3) + 34(k + 1) − 34 = k(2k − 1) + 4(k + 1) 
− 3 (using P(k)) = 2k2 − k + 4k + 1 = 2k2 + 3k + 1 = (k + 1)(2k + 1) = (k + 1)32(k + 1) − 14 
which is the right side of P(k + 1).
	
5.	Base case: P(1): 6 − 2 = 133(1) + 14, (true). Assume P(k): 4 + 10 + 16 + c + (6k − 2)  = k(3k  + 1).  
Show P(k + 1): 4 + 10 + 16 + c + 36(k + 1) − 24 = (k + 1)33(k + 1) + 14. 4 + 10 + 16 + c 
+ 36(k + 1) − 24 = 4 + 10 + 16 + c + (6k − 2) + 36(k + 1) − 24 = k(3k + 1) + 6(k + 1) − 2 
(using P(k)) = 3k2 + k + 6k + 4 = 3k2 + 7k + 4 = (k + 1)(3k + 4) = (k + 1)33(k + 1), + 14 which 
is the right side of P(k + 1).
	
7.	Base case: P(1): 12 = 1(1 + 1)(2 + 1)∙6, (true). Assume P(k): 12 + 22 + c + k2 =  k(k + 1)(2k + 1)∙6. 
Show P(k + 1): 12 + 22 + c + (k + 1)2 = (k + 1)(k + 2)(2(k + 1) + 1)∙6. Left side of P(k + 1) = 12 
+ 22 + c +  (k + 1)2 = 12 + 22 + c + k2 + (k + 1)2 = k(k + 1)(2k + 1)∙6 + (k + 1)2 (using P(k)) 
= (k + 1)3k(2k + 1)∙6 + k + 14 = (k + 1)3(2k2 + k + 6k + 6)∙64 = (k + 1)(2k2 + 7k + 6)∙6 
= (k + 1)(k + 2)(2k + 3)∙6 = (k + 1)(k + 2)(2(k + 1) + 1)∙6 which is the right side of P(k + 1)
	
9.	Base case: P(1): 12 = 1(2 − 1)(2 + 1)∙3, (true). Assume P(k): 12 + 32 + c + (2k − 1)2 =  
k(2k − 1)(2k + 1)∙3. Show P(k + 1): 12 + 32 + c + 32(k + 1) − 142 = (k + 1)(2(k + 1) − 1) 
(2(k + 1) + 1)∙3. Left side of P(k + 1) = 12 + 32 + c + 32(k + 1) − 142 = 12 + 32 + c + (2k − 1)2 
+ 32(k + 1) − 142 = k(2k − 1)(2k + 1)∙3 + 32(k + 1) − 142(using P(k)) = k(2k − 1) (2k + 1)∙3 +  
(2k + 1)2 = (2k + 1)3k(2k − 1)∙3 + 2k + 14 = (2k + 1)(2k2 − k + 6k + 3)∙3) = (2k + 1)(2k2 + 5k + 3)∙3 
= (2k + 1)(k + 1)(2k + 3)∙3 = (k + 1)(2(k + 1) − 1) (2(k + 1) + 1)∙3 which is the right side of  
P(k + 1).
	 11.	Base case: P(1): 1 # 3 = 1(2)(9)∙6, (true). Assume P(k): 1 # 3 + 2 # 4 + c +  k(k + 2) = k(k + 1) 
(2k + 7)∙6. Show P(k + 1): 1 # 3 + 2 # 4 + c + (k + 1)(k + 3) = (k + 1)(k + 2)(2(k + 1) + 7)∙6. 
Left side of P(k + 1) = 1 # 3 + 2 # 4 + c + (k + 1)(k + 3) = 1 # 3 + 2 # 4 + c + k(k + 2) +  
(k + 1)(k + 3) = k(k + 1)(2k + 7)∙6 + (k + 1)(k + 3) (using P(k)) = (k + 1)3k(2k + 7) + 6(k + 3)4∙6 
= (k + 1)(2k2 + 13k + 18)∙6 = (k + 1)(k + 2)(2k + 9)∙6 = (k + 1)(k + 2)(2(k + 1) + 7)∙6 which 
is the right side of P(k + 1).
	 13.	Base case: P(1): 1∙(1 # 2) = 1∙(1 + 1), (true). Assume P(k): 1∙(1 # 2) + 1∙(2 # 3) + c + 1∙k(k + 1) =  
k∙(k + 1). Show P(k + 1): 1∙(1 # 2) + 1∙(2 # 3) + c +  1∙(k + 1)(k + 2) = (k + 1)∙(k + 2). Left side of 
P(k + 1) = 1∙(1 # 2) + 1∙(2 # 3) + c + 1∙(k + 1)(k + 2) = 1∙(1 # 2) + 1∙(2 # 3) + c + 1∙k(k + 1) 
+ 1∙(k + 1)(k + 2) = k∙(k + 1) + 1∙(k + 1)(k + 2) (using P(k)) = 3k(k + 2) + 14∙(k + 1)(k + 2) = 
(k2 + 2k + 1)∙(k + 1)(k + 2) = (k + 1)2∙(k + 1)(k + 2) = (k + 1)∙(k + 2) which is the right side of 
P(k + 1).

870	
Answers to Odd-Numbered Exercises
	 15.	Base case: P(1): 12 = (−1)2(1)(2)∙2, (true). Assume P(k): 12 − 22 + c + (−1)k+1k2 = (−1)k+1 
(k)(k + 1)∙2. Show P(k + 1): 12 − 22 + c +  (−1)k+2(k + 1)2 = (−1)k+2(k + 1)(k + 2)∙2. Left side 
of P(k + 1) = 12 − 22 + c +  (−1)k+2(k + 1)2 = 12 − 22 + c +  (−1)k+1k2 + (−1)k+2(k + 1)2 = 
(−1)k+1(k)(k + 1)∙2 + (−1)k+2(k + 1)2 (using P(k)) = 3(−1)k+1(k)(k + 1) + 2(−1)k+2 (k + 1)24∙2 =  
(−1)k+2(k + 1) 3k(−1)−1 + 2(k + 1)4∙2 = (−1)k+2(k + 1)3−k + 2k + 24∙2 = (−1)k+2(k + 1)(k + 2)∙2 
which is the right side of P(k + 1).
	
17.	Base case: P(1): 22 = (2)(1)(2)(2 + 1)∙3 or 4 = (2)(6)∙3, (true). Assume P(k): 22 + 42 + c + (2k)2 
= 2k(k + 1)(2k + 1)∙3. Show P(k + 1): 22 + 42 + c +  32(k + 1)42 = 2(k + 1)(k + 2)32(k + 1) 
+  14∙3. Left side of P(k + 1) = 22 + 42 + c + 32(k + 1)42 = 22 + 42 + c + (2k)2 + 32(k + 1)42 = 
2k(k + 1)(2k + 1)∙3 + 32(k + 1)42 (using P(k)) = 2(k + 1)3k(2k + 1)∙3 + 2(k +1)4  52(k + 1)3k(2k + 1) 
+ 6(k + 1)4∙3 = 2(k + 1)32k2 + 7k + 64∙3 = 2(k + 1)(k + 2)(2k + 3)∙3 = 2(k + 1)(k + 2)32(k + 1) 
+ 14∙3 which is the right side of P(k + 1).
	 19.	Base case: P(1): 1 # 2 = (1)(2)(3)∙3, (true). Assume P(k): 1 # 2 + 2 # 3 + 3 # 4 + c + k(k + 1) =  
k(k + 1)(k + 2)∙3. Show P(k + 1): 1 # 2 + 2 # 3 + 3 # 4 + c + (k + 1)(k + 2) = (k + 1)(k + 2)(k + 3)∙3 
Left side of P(k + 1) = 1 # 2 + 2 # 3 + 3 # 4 + c +  (k + 1)(k + 2) = 1 # 2 + 2 # 3 + 3 # 4 + c +  
k(k + 1) + (k + 1)(k + 2) = k(k + 1)(k + 2)∙3 + (k + 1)(k + 2)(using P(k)) = (k + 1)(k + 2)3k∙3 + 14 
= (k + 1)(k + 2)(k + 3)∙3 which is the right side of P(k + 1).
	 21.	Base case: P(1): 1∙(1 # 4) = 1∙(3 # 1 + 1), (true). Assume P(k): 1∙(1 # 4) + 1∙(4 # 7) + 1∙(7 # 10) + c + 
1∙(3k − 2)(3k + 1) = k∙(3k + 1). Show P(k + 1): 1∙(1 # 4) + 1∙(4 # 7) + 1∙(7 # 10) + c + 1∙(3(k + 1) 
− 2)(3(k + 1) + 1) = (k + 1)∙33(k + 1) + 14. Left side of P(k + 1) = 1∙(1 # 4) + 1∙(4 # 7) + 1∙(7 # 10) + 
c + 1∙(3(k + 1) − 2)(3(k + 1) + 1) = 1∙(1 # 4) +  1∙(4 # 7) + 1∙(7 # 10) + c + 1∙(3k − 2)(3k + 1)  
+ 1∙(3(k + 1) − 2)(3(k + 1) + 1) = k∙(3k + 1) + 1∙(3(k + 1) − 2)(3(k + 1) + 1) (using P(k)) = k∙(3k + 1)  
+ 1∙(3k + 1)(3k + 4) = 3k(3k + 4) + 14∙(3k + 1)(3k + 4) = (3k2 + 4k + 1)∙(3k + 1)(3k + 4) =  
(3k + 1)(k + 1)∙(3k + 1)(3k + 4) = (k + 1)∙33(k + 1) + 14 which is the right side of P(k + 1).
	 23.	Base case: P(1): 1 + 4 = (42 − 1)∙3 or 5 = 15∙3, (true). Assume P(k): 1 + 4 + 42 + c + 4k = (4k+1 − 1)∙3. 
Show P(k + 1): 1 + 4 + 42 + c + 4k+1 = (4k+2 − 1)∙3. Left side of P(k + 1) =  1 + 4 + 42 + c 
+ 4k+1 = 1 + 4 + 42 + c + 4k + 4k+1 = (4k+1 − 1)∙3 + 4k+1 (using P(k)) = (4k+1 − 1 + 3 # 4k+1)∙3 
= (4 # 4k+1 − 1)∙3 = (4k+2  − 1)∙3 which is the right side of P(k + 1).
	 25.	Base case: P(1): 1 = (3 − 1)∙2, (true). Assume P(k): 1 + 4 + 7 + 10 + c + (3k − 2) = k(3k − 1)∙2. 
Show P(k + 1): 1 + 4 + 7 + 10 + c+ (3(k + 1) − 2) = (k + 1)(3(k + 1) − 1)∙2. Left side of P(k + 1) 
= 1 + 4 + 7 + 10 + c + (3(k + 1) − 2) = 1 + 4 + 7 + 10 + c +  (3k − 2) + (3(k + 1) − 2) = k(3k 
− 1)∙2 + (3(k + 1) − 2) (using P(k)) = 3k(3k − 1) + 2(3(k + 1) − 2)4∙2 = (3k2 − k + 6k + 6 − 4)∙2 
= (3k2 + 5k + 2)∙2 = (k + 1)(3k + 2)∙2 = (k + 1)(3(k + 1) − 1)∙2 which is the right side of  
P(k + 1).
	 27.	Base case: P(1): a = (a − ar)∙(1 − r) = a(1 − r)∙(1 − r), (true). Assume P(k): a + ar + c + 
ark−1 = (a − ark)∙(1 − r). Show P(k + 1): a + ar + c + ark = (a − ark+1)∙(1 − r). Left side of  
P(k + 1) = a + ar + c + ark = a + ar + c + ark−1 + ark = (a − ark)∙(1 − r) + ark (using P(k)) 
= 3a − ark + ark(1 − r)4∙(1 − r) = (a − ark+1)∙(1 − r) which is the right side of P(k + 1).
	 29.	a.	 4,882,812
	
	b.	 64,592,673,600	
	
	 c.	 225
	
	d.	 884
	 31.	Base case: P(2): 22 > 2 + 1, (true). Assume P(k): k2 > k + 1. Show P(k + 1): (k + 1)2 > k + 2. Left 
side of P(k + 1) = (k + 1)2 = k2 + 2k + 1 > (k + 1) + 2k + 1 (using P(k)) = 3k + 2 >  k + 2 which 
is the right side of P(k + 1).

Answers to Odd-Numbered Exercises	
871
	 33.	 Base case: P(7): 72 > 5 # 7 + 10 or 49 > 45, (true). Assume P(k): k2 > 5k + 10. Show P(k + 1): 
(k + 1)2 > 5(k + 1) + 10 = 5k + 15. Left side of P(k + 1) = (k + 1)2 = k2 + 2k + 1 > (5k + 10) + 
2k + 1 (using P(k)) = 5k + 2k + 11 > 5k + 12 + 11 (because k > 6) = 5k + 23 > 5k + 15 which 
is the right side of P(k + 1).
	 35.	 Base case: P(4): 4! > 42 or 1 # 2 # 3 # 4 = 24 > 16 (true). Assume P(k): k! > k2. Show P(k + 1): 
(k + 1)! > (k + 1)2. Left side of P(k + 1) = (k + 1)! = k!(k + 1) > k2(k + 1) (using P(k)) > (k + 1) 
(k + 1) (by Exercise 31 because k ≥4) = (k + 1)2 which is the right side of P(k + 1).
	 37.	 Base case: P(4): 4! > 24 or 24 > 16, (true). Assume P(k): k! > 2k. Show P(k + 1): (k + 1)! > 2k+1. 
Left side of P(k + 1) = (k + 1)! = k!(k + 1) > 2k(k + 1) (using P(k)) > 2k(2) (because k ≥4) = 2k+1 
which is the right side of P(k + 1).
	 39.	 Base case: P(1): 1! ≥20, (true). Assume P(k): k! ≥2k−1. Show P(k + 1): (k + 1)! ≥2k. Left side of 
P(k + 1) = (k + 1)! = k!(k + 1) ≥2k−1(k + 1) (using P(k)) ≥2k−1(2) (because k ≥1 so k + 1 ≥2) 
= 2k which is the right side of P(k + 1).
	 41.	 Base case: P(2): (1 + x)2 > 1 + x2 or 1 + 2x + x2 > 1 + x2 (true because x > 0 ­implies 2x > 0). 
Assume P(k): P(k): (1 + x)k > 1 + xk. Show P(k + 1): (1 + x)k+1 > 1 + xk+1. Left side of P(k + 1) = 
(1 + x)k+1 = (1 + x)k(1 + x) > (1 + xk)(1 + x) (using P(k)) = 1 + xk + x + xk+l > 1 + xk+1 which 
is the right side of P(k + 1).
	 43.	 Base case: P(2): 1 + 2 < 22 or 3 < 4, (true). Assume P(k): 1 + 2 + c +  k < k2. Show P(k + 1): 
1 + 2 + c + (k + 1) < (k + 1)2. Left side of P(k + 1) = 1 + 2 + c + (k + 1) = 1 + 2 + c + 
k + (k + 1) < k2 + k + 1 (using P(k)) <  k2 + 2k + 1 = (k + 1)2 which is the right side of P(k + 1).
	 45.	 a.  Base case: P(1): 1 + (1∙2) < 2, (true). Assume P(k): 1 + (1∙2) + c + (1∙2k) < 2. Show  
P(k + 1): 1 + (1∙2) + c + (1∙2k+1) < 2. Left side of P(k + 1) = 1 + (1∙2) + c + (1∙2k+1) = 
1 + (1∙2) + c + (1∙2k) + (1∙2k+1) < 2 + (1∙2k+1) (using P(k)), but 2 + (1∙2k+1) is not less than 2.
	
	 b.  Base case: P(1): 1 + (1∙2) = 2 − (1∙2), (true). Assume P(k): 1 + (1∙2) + c + (1∙2k) = 2 − (1∙2k). 
Show P(k + 1): 1 + (1∙2) + c + (1∙2k+1) = 2 − (1∙2k+1). Left side of P(k + 1) = 1 + (1∙2) + 
c + (1∙2k+1) = 1 + (1∙2) + c + (1∙2k) + (1∙2k+1) = 2 − (1∙2k) + (1∙2k+1) (using P(k)) = 
2 − (2∙2k+1) + (1∙2k+1) = 2 − (1∙2k+1) which is the right side of P(k + 1).
	 47.	 Base case: P(1): 23 − 1 = 8 − 1 = 7 and 707. Assume P(k): 7023k − 1 so 23k − 1 = 7m or 23k = 7m + 1 
for some integer m. Show P(k + 1): 7023(k+1) − 1. 23(k+1) − 1 = 23k+3 − 1 = 23k # 23 − 1 =  (7m + 1)23 
− 1 = 7(23m) + 8 − 1 = 7(23m + 1) where 23m + 1 is an integer, so 7023(k+1) − 1.
	 49.	 Base case: P(1): 7 − 2 = 5 and 505. Assume P(k): 507k − 2k, so 7k − 2k = 5m or 7k = 5m + 2k for some 
integer m. Show P(k + 1): 507k+1 − 2k+1. 7k+1 − 2k+1 = 7 # 7k − 2k+1 = 7(5m + 2k) − 2k+1 = 5(7m) 
+ 2k(7 − 2) = 5(7m + 2k) where 7m + 2k is an integer, so 507k+1 − 2k+1.
	 51.	 Base case: P(1): 2 + (−1)2 = 2 + 1 = 3 and 303. Assume P(k): 302k + (−1)k+1, so 2k + (−1)k+1 = 
3m or 2k = 3m − (−1)k+1 for some integer m. Show P(k + 1): 302k+1 + (−1)k+2. 2k+1 + (−1)k+2 = 
2 # 2k + (−1)k+2 = 2(3m − (−1)k+1) + (−1)k+2 = 3(2m) − 2(−1)k+1 + (−1)k+2 = 3(2m) + (−1)k+1 
(−2 + (−1)) = 3(2m) + (−1)k+1 (−3) = 3(2m −  (−1)k+1) where 2m − (−1)k+1 is an integer, so 
302k+1 + (−1)k+2.
	 53.	 Base case: P(1): 34+2 + 52+1 = 36 + 53 = 729 + 125 = 854 = 61 # 14 and 14061 # 14. Assume P(k): 
14034k+2 + 52k+1, so 34k+2 + 52k+1 = l4m or 34k+2 = 14m − 52k+1 for some integer m. Show P(k + 1): 
14034(k+1)+2 + 52(k+1)+1. 34(k+1)+2 + 52(k+1)+1 = 34k+2 # 34 + 52k+3 = (14m − 52k+1)34 + 52k+3 = 14(m34) 
− 52k+1 # 34 + 52k+1 # 52 = 14(m34) − 52k+1(34 − 52) = 14(m34) − 52k+1(81 − 25) = 14(m34)−52k+1(56) 
= 14(m34 − 4 # 52k+1) where m34 − 4 # 52k+1 is an integer, so 14034(k+1)+2 + 52(k+1)+1.

872	
Answers to Odd-Numbered Exercises
	 55.	 Base case: P(1): 10 + 3 # 43 + 5 = 10 + 192 + 5 = 207 = 9 # 23 and 909 # 23. Assume P(k): 9010k + 
3 # 4k+2 + 5, so 10k + 3 # 4k+2 + 5 = 9m or 10k = 9m − 3 # 4k+2 − 5 for some integer m. Show P(k + 1): 
9010k+1 + 3 # 4k+3 + 5. 10k+1 + 3 # 4k+3 + 5 = 10 # 10k + 3 # 4k+3 + 5 = 10(9m − 3 # 4k+2 − 5) 
+ 3 # 4k+3 + 5 = 9(10m) − 30 # 4k+2 − 50 + 3 # 4k+2 # 4 + 5 = 9(10m) − 45 − 3 # 4k+2(10 − 4) = 
9(10m − 5) − 18 # 4k+2 = 9(10m − 5 − 2 # 4k+2) where 10m − 5 − 2 # 4k+2 is an integer, so 9010k+1 + 
3 # 4k+3 + 5.
	 57.	 Base case: P(1): 13 + 2(1) = 3 and 303. Assume P(k): 30k3 + 2k so k3 + 2k = 3m  for some integer m. 
Show P(k + 1): 30(k + 1)3 + 2(k + 1). (k + 1)3 + 2(k + 1) = k3 + 3k2 + 3k + 1 + 2k + 2 = k3 + 
2k + 3(k2 + k + 1) = 3m + 3(k2 + k + 1) = 3(m + k2 + k + 1) where m + k2 + k + 1 is an integer, 
so 30(k + 1)3 + 2(k + 1). This result also follows directly from Exercise 56: n3 + 2n = n3 − n + 3n = 
3m + 3n  (by Exercise 56)  = 3(m + n).
	 59.	 Base case: P(1): cos u + i sin u = cos u + i sin u. Assume P(k): (cos u + i sin u)k = cos ku + i sin ku. 
Show P(k + 1): (cos u + i sin u)k+1 = cos (k + 1)u + i sin (k + 1)u. (cos u + i sin u)k+1 =  
(cos u + i sin u)k (cos u + i sin u) = (cos ku + i sin ku)(cos u + i sin u) = cos ku cos u +  i sin ku cos u 
+ i cos ku sin u + i2sin ku sin u = cos ku cos u − sin ku sin u + i(sin ku cos u + cos ku sin u) =  
cos (ku + u) + isin (ku + u) = cos (k + 1)u + isin (k + 1)u.
	 61.	 The statement to be proved is that n(n + 1)(n + 2) is divisible by 3 for n ≥1. Base case: P(1): 
1(1 + 1)(1 + 2) = 6 is divisible by 3, (true). Assume P(k): k(k + 1)(k + 2) = 3m for some integer m. 
Show P(k + 1): (k + 1)(k + 2)(k + 3) is divisible by 3. (k + 1)(k + 2)(k + 3) = (k + 1)(k + 2)k + 
(k + 1)(k + 2)3 = 3m + (k + 1)(k + 2)3 = 33m + (k + 1)(k + 2)4.
	 63.	
	
	
65. 
	 67.	 Proof is by induction on n. P(1) is true because 1 line divides the plane into 2 regions, and 
(12 + 1 + 2)∙2 = 2. Assume that P(k) is true: k lines divide the plane into (k2 + k + 2)∙2 regions. 
Show P(k + 1), that k + 1 lines divide the plane into 3(k + 1)2 + (k + 1) + 24∙2 regions. A new line 
creates one more region than the number of lines it crosses. When line k + 1 is added, it will cross k 
lines (because no two lines are parallel and have no common intersection points). Therefore k + 1 new 
regions are created. The total number of regions is therefore k + 1 more than the number present with 
k lines, or (k2 + k + 2)∙2 + (k + 1) = (k2 + k + 2 + 2(k + 1)∙2 = (k2 + 3k + 4)∙2 = ((k + 1)2 +
(k + 1) + 2)∙2.
	 69.	 P(1) is 1 = 1 + 1 which is not true.	
	 71.	 a.	Let P(n) be the property that any word composed of a juxtaposition of n subwords has an even number 
of o’s. Then P(1) is true because the only words with 1 subword are the words moon, noon, and soon, 
all of which have 2 o’s. Assume that P(k) is true and consider P(k + 1). For any word composed of 
k + 1 subwords, break the word into two parts composed of k subwords and 1 subword. By the induc-
tive hypothesis, the part with k subwords has an even number m of o’s. The part with 1 subword has 2 
o’s. The total number of o’s is therefore m + 2, an even number. This verifies P(k + 1) and completes 
the proof.

Answers to Odd-Numbered Exercises	
873
	
	 b.	Let P(n) be the property that any word composed of a juxtaposition of n subwords has an even num-
ber of o’s. Then P(1) is true because the only words with 1 subword are the words moon, noon, and 
soon, all of which have 2 o’s. Assume that P(r) is true for all r, 1 ≤r ≤ k, and consider P(k + 1). 
For any word composed of k + 1 subwords, break the word into two parts composed of r1 and r2 
subwords, with 1 ≤r1 ≤k, 1 ≤r2 ≤k, and r1 + r2 = k + 1. By the inductive hypothesis, r1 con-
tains m1 o’s, an even number, and r2 contains m2 o’s, an even number. Then the original word contains 
m1 + m2 o’s, an even number. This verifies P(k + 1) and completes the proof.
	 73.	 For the base case, a 1-piece puzzle requires 0 steps to assemble. Assume that any block of r pieces, 1 ≤r ≤k, 
requires r −1 steps to assemble. Now consider a puzzle with k + 1 pieces. The last step in assembling the 
puzzle is to fit together two blocks of size r1 and r2 with 1 ≤r1 ≤k, 1 ≤r2 ≤k, and r1 + r2 = k + 1. By 
the inductive hypothesis these blocks required r1 −1 and r2 −1 steps to assemble, so with the final step, 
the total number of steps required is (r1 −1) + (r2 −1) + 1 = (r1 + r2) −1 = k.
	 75.	 For the base case, the simplest such wff is a single statement letter, which has 1 symbol; 1 is odd. Assume 
that for any such wff with r symbols, 1 ≤r ≤k, r is odd. Consider a wff with k + 1 symbols. It must 
have the form (P) ` (Q), (P) ~ (Q), or (P) S (Q) where P has r1 symbols, 1 ≤r1 <  k, and Q has r2  
symbols, 1 ≤r2 < k. By the inductive hypothesis, both r1  and r2  are odd. The number of symbols in the 
original wff is then r1 + r2 + 5 (four parentheses plus one connective), which is odd.
	 77.	 P(2) and P(3) are true by the equations 2 = 2 and 3 = 3. Now assume that P(r) is true for any r, 2 ≤r ≤k, 
and consider P(k + 1). We may assume that k + 1 ≥4, so that (k + 1) −2 ≥2 and by the inductive 
hypothesis can be written as a sum of 2s and 3s. Adding an additional 2 gives k + 1 as a sum of 2s and 3s.
	 79.	 P(14), P(15), and P(16) are true by the equations 14 = 2(3) + 8, 15 = 5(3), 16 = 2(8). Now assume 
that P(r) is true for any r, 14 ≤r ≤ k, and consider P(k + 1). We may assume that k + 1 ≥17, so 
(k + 1) −3 ≥14 and by the inductive hypothesis can be written as a sum of 3s and 8s. Adding an ad-
ditional 3 gives k + 1 as a sum of 3s and 8s.
	 81.	 P(64), P(65), P(66), P(67), and P(68) are true by the equations  64 = 6(5) + 2(17),  65 = 13(5), 
66 = 3(5) + 3(17), 67 = 10(5) + 17, 68 = 4(17). Now assume that  P(r) is true for any r, 64 ≤r ≤k, 
and consider P(k + 1). We may assume that k + 1 ≥69, so (k + 1) −5 ≥64 and by the inductive hy-
pothesis can be written as a sum of 5s and 17s. Adding an additional 5 gives k + 1 as a sum of 5s and 17s.
	 83.	 From Exercise 2,
∙
n
m=1
2m = n(n + 1) = n2 + n. Also, 3
n
0
2x dx = 2x2
2 `
n
0
= n2
	
	 and
3
n+1
1
2x dx = 2x2
2 `
n+1
1
= (n + 1)2 −1 = n2 + 2n. It is true that n2 ≤n2 + n ≤n2 + 2n.
Exercises 2.3
	
1.	 Assume xk
2 > xk + 1. Then x2
k+1 = (xk + 1)2 = x2
k + 2xk + 1 > x2
k + 1 > (xk + 1) + 1 = xk+1 + 1.
	
3.	 Q(0): j0 = (i0 −1)! because j = 1, i = 2 before loop is entered. Assume Q(k): jk = (ik −1)! Then 
Q(k + 1): jk+1 = jk # ik = (ik −1)!ik = (ik)! = (ik+1 −1)! At loop termination, j = (i −1)! and 
i = x + 1, so j = x!
	
5.	 Q(0): j0 = xi0 because j = x, i = 1 before loop is entered. Assume Q(k): jk = xik. Then Q(k + 1): jk+1 =
	
	 jk # x = xik # x = xih+1 = xik+1. At loop termination, j = xi and  i = y, so j = xy.

874	
Answers to Odd-Numbered Exercises
	
7.	 gcd(308, 165) = 11
	
9.	 gcd(735, 90) = 15
	 11.	 gcd(1326, 252) = 6
	 13.	 You want to divide the 792 bars of soap evenly among x packages. Therefore x must be a divisor of 792. 
Similarly, you want to divide the 400 shampoo bottles evenly among the x packages. Therefore x must be 
a divisor of 400. The number of packages is the largest value of x that divides both 792 and 400, which is 
the definition of gcd(792, 400).
	 15.	 Q: j = x * yi. Q(0): j0 = x * yi0 because j = x, i = 0 before loop is entered. Assume Q(k): jk = x * yik. 
Then Q(k + 1): jk+1 = jk * y = x * yik *
 y = x * yik+1 = x * yik+1. At loop termination, j = x * yi and i = n, 
so j = x * yn.
	 17.	 Q: j = (i + 1)2. Q(0): j0 = (i0 + 1)2 because j = 4, i = 1 before loop is entered. Assume Q(k): jk =  
(ik + 1)2. Then Q(k + 1): jk+1 = jk + 2ik + 3 = (ik + 1)2 + 2ik + 3 = ik
2 + 2ik + 1 + 2ik + 3 =  
i2
k + 4ik + 4 = (ik + 2)2 = (ik + 1 + 1)2 = (ik+1 + 1)2. At loop termination, j = (i + 1)2 and i = x, 
so j = (x + 1)2. 
	 19.	 Q: j = x * i!. Q(0): j0 = x * i0! because j = x, i = 1 before loop is entered. Assume Q(k): jk = x * (ik)! 
Then Q(k + 1):  jk+1 = jk * (ik + 1) = x * (ik)!(ik + 1) = x * (ik + 1)! = x * (ik+1)! At loop termina-
tion, j = x * i! and i = n, so j = x * n!
	 21.	 Q: j = max of (a314, …, a3i4). Q(0): j0 = max(a314, …, a3i04) because i0 = 1, so the right side be-
comes max(a314) and j0 = a314. Assume Q(k): jk = max(a314, …, a3ik4). ThenQ(k + 1): jk+1 =
max(jk, a3ik + 14) = max(max(a314,  …, a3ik4), a3ik + 14) = max(a314, …, a3ik + 14) = max(a314, …,
a3ik+14). At loop termination, j = max(a314, …, a3i4) and i = n, so j = max(a314, …, a3n4).
	 23.	 Suppose there exists an integer d such that d 0  a∙2, d 0  b∙2, and d > c, from which 2d > 2c. Then a∙2 = k1d 
and b∙2 = k2d where k1, k2 are integers. Then a = k1(2d) and b = k2(2d), which means that 2d divides 
both a and b but is greater than 2c = gcd(a,b), which is a contradiction.
	 25.	 If a and b are both odd, then a −b is even, in which case by fact 2, gcd(a −b, b) = gcd((a −b)∙2, b)
	 27.	 	308	
165	
Fact 2
	154	
165	
Fact 2
	 77	
165	
Fact 3
	 77	
44	
Fact 2
	 77	
22	
Fact 2
	 77	
11	
Fact 3
	 33	
11	
Fact 3
	 11	
11	
Fact 3
	 0	
11
	gcd(308, 165) = 11
Exercises 2.4
	
1.	 11 = 7 # 308 −13 # 165
	
3.	 15 = 1 # 735 −8 # 90
	
5.	 6 = 100 # 252 −19 # 1326
	
7.	 1729 = 7 # 13 # 19
	
9.	 Because "1171 > 34, we try the primes 2, 3, 5, 7, 11, 13, 17, 23, 29, 31. None of these divide n, so n is prime.
	 11.	 8712 = 23 # 32 # 112

Answers to Odd-Numbered Exercises	
875
	 13.	 308 = 22 *
 7 * 11 and 165 = 3 * 5 * 11, so gcd(308, 165) = 11
	 15.	 735 = 3 * 5 * 72 and 90 = 2 * 32 * 5 so gcd(735, 90) = 3 * 5 = 15
	 17.	 1326 = 2 * 3 * 13 * 17 and 252 = 22 *
 32 *
 7, so gcd (1326, 252) = 2 * 3 = 6
	 19.	 The gcd(a, b) is the product of primes that appear in both a and b to the lowest power to which they appear. 
The lcm(a, b) is the product of primes that appear in either a or b to the highest power to which they appear.
	 21.	 gcd = 2 # 3 # 11, lcm = 22 # 3 # 112 # 13.
	 23.	 gcd = 3 # 5 # 11, lcm = 32 # 53 # 112 # 17
	 25.	 Let gcd(a, b) = c and gcd(a, a + b) = d. Because gcd(a, b) = c, c 0  a and c 0  b, so a = mc and b = nc 
for some integers m and n. Then a + b = mc + nc = (m + n)c, so c0 (a + b). Therefore c is a common 
divisor of a and a + b, and must be ≤ the greatest common divisor of a and a + b, namely d. Be-
cause gcd(a, a + b) = d, d 0  a and d 0(a + b), so a = id and a + b = jd for some integers i and j. Then 
b = jd −a = jd −id = (  j −i)d, so d 0  b. Therefore d is a common divisor of a and b and must be ≤
the greatest common divisor of a and b, namely c. Now c ≤d and d ≤c, so c = d.
	 27.	 For example, 8024 and 24 = 12 # 2 but 8 0 12 and 8 0 2. This does not violate the theorem of division by 
prime numbers because 8 is not prime.
	 29.	 3, 5, 7
	 31.	 w(8) = 4 (the numbers 1, 3, 5, 7)
	 33.	 w(10) = 4 (the numbers 1, 3, 7, 9)
	 35.	 Let w(n) = n −1. Because n is never relatively prime to n, the numbers being counted in w(n) are 
(1, 2, … , n −1). Thus every number between 1 and n −1 is relatively prime to n, so only 1 and n divide 
n, making n prime.
	 37.	 w(24) = 23w(2) = 8 # 1 = 8. The numbers are: 1, 3, 5, 7, 9, 11, 13, 15
	 39.	 35640
	 41.	 1248000
	 43.	 To compute w(pq), count the number of positive integers less than or equal to pq, which is pq, and 
throw out those that are not relatively prime to pq. A positive integer m less than or equal to pq and 
not relatively prime to pq must either contain at least one factor of p or at least one factor of q. We 
count how many integral multiples of p ( p, 2p, 3p, … ,  pq) are less than or equal to pq. This number 
is pq∙p = q. Similarly we count how many integral multiples of q (q, 2q, 3q, … ,  pq) are less than or 
equal to pq, of which there are pq∙q = p. Multiples of p and multiples of q are distinct except for pq, 
which we have counted twice; to compensate, we will add 1 to the final count. The correct expression is 
w( pq) = pq −q −p + 1 = ( p −1)(q −1) = w( p) w(q).
	 45.	 Using the fundamental theorem of arithmetic, let n = pn1
1   pn2
2  c pnkk  so that nm = pn1m
1      pn2m
2  c pnkm
k  and by 
Equation 2,
f(n) = pn1−1
1        pn2−1
2
 c pnk−1
k
3f( p1)f( p2) c f( pk)4
	
	 Then, again by Equation 2,
 w(nm) = pn1m−1
1
 pn2m−1
2
 c pnkm−1
k  
 w( p1)w( p2) c w( pk) = pn1m
1   pn2m
2  c pnkm
k
p1p2 c pk
w( p1)w( p2) c w( pk)
 = pn1m
1  pn2m
2  c pnkm
k
p1p2 c pk
a
w(n)
pn1−1
1
 pn2−1
2
 c pnk−1
k
b = pn1m
1  pn2m
2  c pnkm
k
pn1
1  pn2
2  c pnkk
w(n)
 = nm
n w(n) = nm−1w(n)
	 47.	 5, 7, 31, 127

876	
Answers to Odd-Numbered Exercises
	 49.	 a. 28 = 1 + 2 + 4 + 7 + 14
	b.	28 = 22(23 −1)
	 51.	 The original list is
  1	
2	
3	
  4	
  5	
6	
7	
8	
9	
10
11	
12	
13	
14	
15	
16	
17	
18	
19	
20
21	
22	
23	
24	
25	
26	
27	
28	
29	
30
31	
32	
33	
34	
35	
36	
37	
38	
39	
40
41	
42	
43	
44	
45	
46	
47	
48	
49	
50
51	
52	
53	
54	
55	
56	
57	
58	
59	
60
61	
62	
63	
64	
65	
66	
67	
68	
69	
70
71	
72	
73	
74	
75	
76	
77	
78	
79	
80
81	
82	
83	
84	
85	
86	
87	
88	
89	
90
91	
92	
93	
94	
95	
96	
97	
98	
99	
	
	 After pass one (crossing out multiples of 2):
	
1	
2	
3	
5	
7	
9
11	
	
13	
15	
17	
19	
21	
	
23	
25	
27	
29	
31	
	
33	
35	
37	
39	
41	
	
43	
45	
47	
49	
51	
	
53	
55	
57	
59	
61	
	
63	
65	
67	
69	
71	
	
73	
75	
77	
79	
81	
	
83	
85	
87	
89	
91	
	
93	
95	
97	
99	
	
	 After pass two (crossing out multiples of 3):
	 1	
2	
3	
5	
7	
11	
	
13	
	
17	
19
	 	
	
23	
25	
	
29
31	
	
	
35	
37	
41	
	
43	
	
47	
49
	 	
	
53	
55	
	
59
61	
	
	
65	
67	
71	
	
73	
	
77	
79
	 	
	
83	
85	
	
89
91	
	
	
95	
97	
	
	 After pass three (crossing out multiples of 5):
	 1	
2	
3	
5	
7	
11	
	
13	
	
17	
19	
	 	
	
23	
	
	
29	
31	
	
	
	
37	
41	
	
43	
	
47	
49	
	 	
	
53	
	
	
59	
61	
	
	
	
67	
71	
	
73	
	
77	
79	
	 	
	
83	
	
	
89	
91	
	
	
	
97	

Answers to Odd-Numbered Exercises	
877
	
	 After pass four (crossing out multiples of 7):
	 1	
2	
3	
5	
7	
11	
	
13	
	
17	
19
	 	
	
23	
	
	
29
31	
	
	
	
37	
41	
	
43	
	
47	
	 	
	
53	
	
	
59
61	
	
	
	
67	
71	
	
73	
	
	
79
	 	
	
83	
	
	
89
	 	
	
	
	
97	
	
	 Because 7 is the largest prime less than "100, the process terminates. The remaining numbers (excluding 1) 
are the primes less than 100.
53.	
8
9
5
2
1
7
6
4
3
6
4
7
5
8
3
9
1
2
2
3
1
6
9
4
5
8
7
9
2
4
1
3
5
8
7
6
1
5
8
7
2
6
4
3
9
7
6
3
9
4
8
1
2
5
4
8
2
3
5
9
7
6
1
3
7
9
4
6
1
2
5
8
5
1
6
8
7
2
3
9
4
Chapter 3
Exercises 3.1
	
1.	 l0, 20, 30, 40, 50
	
3.	 2, 1/2, 2, 1/2, 2
	
5.	 1, 1 + 1
2, 1 + 1
2 + 1
3, 1 + 1
2 + 1
3 + 1
4,  1 + 1
2 + 1
3 + 1
4 + 1
5
	
7.	 1, 5, 47, 755, 18879
	
9.	 2, 2, 6, 14, 34
	 11.	 2, 3, 6, 18, 108
	 13.	 F(n + 1) + F(n −2) = F(n −1) + F(n) + F(n −2) = 3F(n −2) + F(n −1)4 + F(n) = F(n) +  
F(n) = 2F(n).
	 15.	 F(n) = F(n −2) + F(n −1) = 3F(n −4) + F(n −3)4 + 3F(n −3) + F(n −2)4 = F(n −4) +  
2F(n −3) + F(n −2) = F(n −4) + 2F(n −3) + 3F(n −4) + F(n −3)4 = 3F(n −3) +  
2F(n −4).
	 17.	 F(n + 3) = F(n + 2) + F(n + 1) = F(n + 1) + F(n) + F(n + 1) = 2F(n + 1) + F(n).
	 19.	 n = 1: F(1) = F(3) −1 or 1 = 2 −1, true. Assume true for n = k: F(1) + c+ F(k) = F(k + 2) −1.  
Then F(1) + c+ F(k + 1) = F(1) + c+ F(k) + F(k + 1) = F(k + 2) −1 + F(k + 1) =  
F(k + 3) −1.

878	
Answers to Odd-Numbered Exercises
	 21.	 n = 1: F(1) = F(2) or 1 = 1, true. Assume true for n = k: F(1) + F(3) + c+ F(2k −1) = F(2k). Then 
F(1) + F(3) + c+ F(2(k + 1) −1) = F(1) + F(3) + c+ F(2k −1) + F(2(k + 1) −1) =
F(2k) + F(2(k + 1) −1) = F(2k) + F(2k + 1) = F(2k + 2) = F(2(k + 1)).
	 23.	 n = 1: F(4) = 2F(2) + F(1) or 3 = 2(1) + 1, true. n = 2: F(5) = 2F(3) + F(2) or 5 = 2(2) + 1, true. 
Assume for all r, 1 ≤r ≤k, F(r + 3) = 2F(r + 1) + F(r). Then F(k + 4) = F(k + 2) + F(k + 3) =
2F(k) + F(k −1) + 2F(k + 1) + F(k) = 23F(k) + F(k + 1)4 + 3F(k −1) + F(k)4 = 2F(k + 2) +
F(k + 1).
	 25.	 n = 1: F(1) < 2 or 1 < 2, true.  n = 2: F(2) < 22 or 1 < 4, true. Assume for all r, 1 ≤r ≤k, F(r) < 2r. 
Then 
F(k + 1) = F(k −1) + F(k) < 2k−1 + 2k = 2k−1(1 + 2) = 3(2k−1) < 4(2k−1) = 22(2k−1) =
2k+1.
	 27.	 F(positive integer n)
//function that recursively computes the value of
//the nth Fibonacci number
	
if n = 1 then
	
return 1
	
else
	
if n = 2 then
	
return 1
	
else
	
return F(n −2) + F(n −1)
	
end if
	
end if
end function F
	 29.	 a.	 i = n 
	b.	 p = F(n −1)
	 31.	 a.	 p2 = (1 + "5)2
22
= 1 + 2"5 + 5
2
= 6 + 2"5
4
= 3 + "5
2
= 2
2 + 1 + "5
2
= 1 + p
	
The proof that 1 + q = q2 is similar.
	
b. n = 1: F(1) = p −q
p −q = 1, true.
n = 2: F(2) = p2 −q2
p −q = (p −q)(p + q)
p −q
= p + q = 1 + "5
2
+ 1 −"5
2
= 2
2 = 1, true.
	
Assume for all r, 1 ≤r ≤k, F(r) = pr −qr
p −q . Then
 F(k + 1) = F(k −1) + F(k) = pk−1 −qk−1
p −q
+ pk −qk
p −q = pk−1(1 + p) −qk−1(1 + q)
p −q
 = pk−1p2 −qk−1q2
p −q
= pk+1 −qk+1
p −q

Answers to Odd-Numbered Exercises	
879
	
c.	 From part (b),
 F(n) = pn −qn
p −q =
a1 + "5
2
b
n
−a1 −"5
2
b
n
a1 + "5
2
b −a1 −"5
2
b
= 2(1 + "5)n
2n(2"5)
−2(1 −"5)n
2n(2"5)
 =
1
"5
a1 + "5
2
b
n
−
1
"5
a1 −"5
2
b
n
= "5
5 a1 + "5
2
b
n
−"5
5 a1 −"5
2
b
n
	 33.	 Yes.
	 35.	 No.
	 37.	 a.	F(1) = F(2) = 1 because the rabbits do not breed until they are 2 months old. F(n) = the number 
of pairs at the end of n months = (the number of pairs at the end of n −1 months) + (the num-
ber of offspring pairs produced during month n, born to the pairs existing at month n −2) =
F(n −1) + F(n −2)
	b.	27 = 1 + 5 + 21, 62 = 2 + 5 + 55
	 39.	 Base cases: S(1), S(2), S(3) are even. Assume for all r, 1 ≤r ≤k, S(r) is even. Then S(k + 1) =
3S(k −2) = 3(even) = even
	 41.	 a.	n = 0: S(0) = 1 is odd, n = 1: S(1) = 1 is odd. Assume for all r, 0 ≤r ≤k, S(r) is odd. Then 
S(k + 1) = 2S(k) + S(k −1) = 2(odd) + odd = even + odd = odd
	b.	n = 4: S(4) < 6S(2) or 17 < 6(3) = 18, true. n = 5: S(5) < 6S(3) or 41 < 6(7) = 42, true. Assume  
for all r, 4 ≤r ≤k, S(r) < 6S(r −2). Then S(k + 1) = 2S(k) + S(k −1) < 236S(k −2)4 +
6S(k −3) = 632S(k −2) + S(k −3)4 = 6S(k −1)
	 43.	 S(1) = a, S(n) = rS(n −1) for n ≥2
	 45.	 a.	 A(1) = 50,000, A(n) = 3A(n −1) for n ≥2
	b.	4.
	 47.	 b and c
	 49.	 a, b, and e
	 51.	 The basis elements are 0 and 3, each of which is a multiple of 3. Assume that x and y are integers that are 
multiples of 3, so x = (n)3 and y = (k)3. Then x + y = (n)3 + (k)3 = (n + k)3, which is a multiple of 3.
	 53.	 1. Any unary predicate in x is a wff. 2. If P and Q are unary predicate wffs in x, so are (P ` Q), (P ~ Q), 
(P S Q), (P′), (P 4 Q), (4x)P, and (Ex)P.
	 55.	 (1) The integer 1 belongs to the set. (2) If x is an odd integer, so are x + 2 and x −2.
	 57.	 (1) The string 0 belongs to the set. (2) If x is a binary string with an odd number of 0s, so is 1x, x1, and 
0x0.
	 59.	 (1) The string 0 belongs to the set. (2) If x is a binary string ending with 0, so is 1x, 0x, x0.
	 61.	 <positive digit> ::5 1|2|3|4|5|6|7|8|9, <digit> ::5 0|<positive digit>, <positive integer> ::5 <posi-
tive digit>|<positive integer><digit>
	 63.	 (1) lR = l (2) If x is a string with a single character, xR = x. (3) If x = yz, then xR = zRyR 
	 65.	 1! = 1, n! = n(n −1)! for n ≥2
	 67.	 a.	  max (a1, a2) = e a1  if a1 ≥a2
a2  if a1 < a2
    max (a1, ..., an) = max (max (a1, ..., an−1), an)  for n > 2 
	
b.	  min (a1, a2) = e a1  if a1 ≤a2
a2  if a1 > a2
    min (a1, ..., an) = min (min (a1, ..., an−1), an) for n > 2  

880	
Answers to Odd-Numbered Exercises
	 69.	 A ~ (B1 ` B2) 3 (A ~ B1) ` (A ~ B2) by equivalence 3a. Assume that A ~ (B1 ` c` Bk) 3
(A ~ B1) ` c` (A ~ Bk). Then A ~ (B1 ` c` Bk+1) = A ~ 3(B1 ` c` Bk) ` Bk+14 by  
Exercise 68 3 (A ~ (B1 ` c` Bk)) ` (A ~ Bk+1) 3 3(A ~ B1) ` c` (A ~ Bk)4 ` (A ~ Bk+1) 3
(A ~ B1) ` c` (A ~ Bk+1) by Exercise 68. The proof of the other statement is similar.
	 71.	 if n = 1 then
	
return 1
else
	
return 3 * S(n −1)
end if
	 73.	 if n = 1 then 
	
return 1
else
	
return S(n −1) + (n −1)
end if
	 75.	 if n = 1 then
	
return a
else
	
if n = 2 then
 	
	
return b 
	
else
 	
	
return S(n −2) + S(n −1)
	
	 	
	 end if
end if
	 77.	 Mystery(n) = n
	 79.	 If the list has 1 element or 0 elements, then we are done; else exchange the first and last element in the list 
and invoke the algorithm on the list minus its first and last elements.
	 81.	 Divide a by b. If the remainder r is 0, then gcd(a, b) = b; else invoke the algorithm on b and r instead of 
a and b.
	 83.	 4,10, −6, 2, 5; 4, 5, −6, 2, 10; 4, 2, −6, 5, 10; −6, 2, 4, 5, 10
	 85.	 New Orleans, Charlotte, Indianapolis
	 87.	 Q: CurrentValue = 2i−1. Q(0):CurrentValue0 = 2i0−1 true because CurrentValue0 = 2 and i0 = 2  
and 2 = 22−1. Assume Q(k): CurrentValuek = 2ik−1 Then CurrentValuek+1 = 2 *
CurrentValuek = 2(2ik−1) = 2ik = 2ik+1−1. At termination, CurrentValue = 2i−1 and i = n + 1, so 
CurrentValue = 2n+1−1 = 2n.
Exercises 3.2
	
1.	 S(n) = n(5)
	
3.	 F(n) = n2n
	
5.	 A(n) = n(n + 1)∙2
	
7.	 T(n) = n(n + 1)(2n + 1)
6
	
9.	 The solution formula does not apply. Using expand, guess, and verify, F(n) = n!
	 11.	 The solution formula does not apply. Using expand, guess, and verify, A(n) = 2n−1(n −1)!
	 13.	 a.	The recurrence relation is T(n) = 0.95T(n −1) with a base case T(1) = X.
	
	 b.	T(n) = (0.95)n−1(X).
	
	 c.	T(21) = 0.358(X), which is slightly more than one-third the original amount X.

Answers to Odd-Numbered Exercises	
881
	 15.	 a.	The recurrence relation is S(n) = 10S(n −1) with a base case of S(1) = 1000.
	
	 b.	S(n) = 10n+2
	
	 c.	At the end of 20 seconds, (the beginning of the 21st second), S(21) = 1023 e-mail messages are sent.
	 17.	 a.	The recurrence relation is A(n) = (1.01)A(n −1) −80 with a base case of A(1) = 5000.
	
	 b.	A(n) = (1.01)n−1(5000) −8031 −(1.01)n−14∙31 −1.014
	
	 c.	 A(19) = $4411.56
	 19.	 a.	The recurrence relation is S(n) = 0.98S(n −1) −10,000 with a base case of S(1) = 1,000,000.
	
	 b.	S(n) = (0.98)n−1(1,000,000) −10,00031 −(0.98)n−14∙(1 −0.98)
	
	 c.	S(10) = 750622
	 21.	 a.	The recurrence relation for the total number of infected machimes each day is T(n) = 6T(n −1) −6n−2 
with a base case of T(1) = 3.
	
	 b.	T(n) = 6n−236 * 3 −(n −1)4
	
	 c.	The virus disappears after 19 days. 
	 23.	 The recurrence relation is P(n) = P(n −1) + n, with P(1) = 1. The solution is P(n) = n(n + 1)∙2.
	 25.	 The recurrence relation is P(n) = P(n −1) + 3n −2 with P(1) = 1. The solution is P(n) =  
(n∙2)(3n −1).
	 27.	 T(n) = 4(2)n−1 + (3)n−1
	 29.	 S(n) = 2 + 2(−2)n−1 
	 31.	 F(n) = 6 + 2(5)n−1
	 33.	 B(n) = 3(2)n−1 +  4(n −1)(2)n−1
	 35.	 A(n) = 4(1 + i)n−1 + 4(1 −i)n−1
	 37.	 The characteristic equation is t2 −t −1 = 0 with roots
r1 = 1 + "5
2
, r2 = 1 −"5
2
	
	 The solution is
F(n) = "5
5 a1 + "5
2
b
n
−"5
5 a1 −"5
2
b
n
	
	 which agrees with the expression given in Exercise 31(c) of Section 3.1.
	 39.	 a.	The recurrence relation is M(n) −M(n −1) = (1∙2)3M(n −1) −M(n −2)4 for n ≥3, with 
M(1) = 200,000, M(2) = 250,000. The solution is M(n) = 300,000 + (−100,000)(1∙2)n−1. 
	b.	M(7) = 298437, which is within $2000 of $300,000.
	 41.	 Let S(n) be the number of binary strings of length n with no two consecutive 0s. Such strings can be 
generated in two ways: (i) Put a 1 on the end of a string of length n −1 that has no two consecutive 0s. 
There are S(n −1) of these strings. (ii) Put a 10 on the end of a string of length n −2 that has no two 
consecutive 0s. There are S(n −2) of these strings. Therefore S(n) = S(n −1) + S(n −2), which is the 
recurrence relation for the Fibonacci numbers. Also S(1) = 2 (both 0 and 1 are 1-length binary strings 
with no two consecutive 0s), S(2) = 3 (01, 10, 11 are 2-length binary strings with no two consecutive 0s). 
So S(1) = 2 = F(3), S(2) = 3 = F(4), S(3) = S(2) + S(1) = 5 = F(5), etc.
	 43.	 Here c2 = 0 so the characteristic equation is t2 −c1t = 0, which has roots r1 = 0, r2 = c1. The solu-
tion is S(n) = p(0)n−1 + q(c1)n−1 = q(c1)n−1 where p + q = S(1), q(c1) = S(2), so q = S(2)∙c1. By the 
recurrence relation S(n) = c1S(n −1), S(2)∙c1 = S(1), so q = S(1). The solution is S(n) = S(1)(c1)n−1, 
which is the solution given by Equation 8 because g(n) = 0.
	 45.	 P(n) = 4n −3
	 47.	 S(n) = (1 + log n)n

882	
Answers to Odd-Numbered Exercises
Exercises 3.3
	
1.	 for i = 1 to n do
low =  roster[i].quiz[1]
high =  roster[i].quiz[1]
sum =  roster[i].quiz[1]
for j =  2 to m do
	
	
sum = sum + roster[i].quiz[j]		
//A
	
	
if roster[i].quiz[j] < low then
	
	
low = roster[i].quiz[j]
	
	
end if
	
	
if roster[i].quiz[j] > high then
	
	
high = roster[i].quiz[j]
	
	
end if
end for
sum = sum −low	
	
	
//S
sum = sum + high	
	
	
//A
write(“Total for student”, i,  “is”, sum)
end for
	
3.	 A total of n2 additions is done.
	
5.	 The overall number of output statements is n(log n)
	
7.	 a.	factorial(integer n)
	
integer i
	
factorial =  1
	
if n = 1 then
	
return 1
	
else
	
for i = 1 to n −1 do
	
factorial =  factorial *(i + 1)
	
end for
	
return factorial
	
end if
	
	 b.	n −1 multiplications are done.
	
9.	 a.	c has the value 4. When i = 1, product = 1 * 4 = 4, sum = −14 + 5 * 4 = 6. When i = 2, 
product = 4 * 4 = 16, sum = 6 + (−7) * 16 = −106. When i = 3, product = 16 * 4 = 64, 
sum = −106 + 2 * 64 = 22, so 22 is the final value, which is correct.
	
	 b.	The total work is 3n.
	 11.	 The best case occurs when the first quiz grade is the lowest quiz grade for each student. Then the condition 
of the if statement is never true and the assignment statement within the if statement executes 0 times. The 
worst case occurs when all the quiz grades go downhill from beginning to end for each student. Then each 
new quiz grade is lower than the previous one, so the assignment statement within the if statement executes 
each time, or n(m −1) times. Total assignments and comparisons in the best case = 3n + 2n(m −1) 
and in the worst case = 3n + 3n(m −1).
	 13.	 a.	After pass 1 the list is 5, 3, 4, 6, 2, 8. After pass 2 the list is 3, 4, 5, 2, 6, 8. After pass 3 the list is 3, 4, 
2, 5, 6, 8. After pass 4 the list is 3, 2, 4, 5, 6, 8. After pass 5 the list is 2, 3, 4, 5, 6, 8.
	
	 b.	B(1) = 0, B(n) = (n −1) + B(n −1) for n ≥2
	
	 c.	 B(n) = (n −1)n∙2
	 15.	 n −1 compares are always needed - every element after the first must be considered a potential new 
maximum.

Answers to Odd-Numbered Exercises	
883
	 17.	 S(n) = (n −1)n∙2
	 19.	 a.	The merged list is 1, 4, 5, 6, 8, 9; 3 comparisons
	
	 b.	The merged list is 1, 2, 3, 4, 5, 8; 4 comparisons
	
	 c.	The merged list is 0, 1, 2, 3, 4, 7, 8, 9, 10; 8 comparisons.
	 21.	 M(1) = 0, M(n) = 2M(n∙2) + (n −1) for n = 2m, n ≥2
	 23.	 	
selectionsort	
mergesort
	
n = 4	
9	
5
	
n = 8	
35	
17
	
n = 16	
135	
49
	
n = 32	
527	
129
	 25.	 Original list: 9, 8, 3, 13. After 1st pass: 8, 3, [9], 13. After 2nd pass: 3, [8], [9], 13 −sorted
	 27.	 6
	 29.	 Q(1) = 0, Q(n) = (n −1) + 2Q(n∙2) for n ≥2
	 31.	 Q(1) = 0, Q(n) = (n −1) + Q(n −1) for n ≥2
	 33.	 If the original list is sorted in increasing order, then the first element of each sublist is the smallest ele-
ment, so for the next pass the list of elements smaller than the pivot element will be empty and the list of 
elements greater than the pivot element will be only one element shorter than the sublist.
	 35.	
Position at which x occurs
Number of comparisons
1
1
2
2
3
3
c
c
n
n
	 37.	 For m = 1, F(m + 2) = F(3) = 2 and F(m + 1) = F(2) = 1. We need to show that if 1 division is 
required to find gcd(a, b), then a ≥2 and b ≥1. Because the Euclidean algorithm applies to posi-
tive integers, b ≥1. Because a > b, a ≥2. Assume that if k divisions are required, a ≥F(k + 2), 
b ≥F(k + 1). Show that if k + 1 divisions are required, then a ≥F(k + 3), b ≥F(k + 2). The 
first step of the algorithm in computing gcd(a, b) is to divide a by b, so a = qb + r, 0 ≤r < b. 
This is 1 division. The algorithm finishes the computation by finding gcd(b, r), which will there-
fore require k divisions. By the inductive hypothesis, b ≥F(k + 2) and r ≥F(k + 1). Then 
a = qb + r ≥b + r (q ≥1 because a > b) ≥F(k + 2) + F(k + 1) = F(k + 3).
	 39.	 From Exercise 38, a3
2b
m+1
< a, so, taking the logarithm to the 3/2 of both sides, m + 1 < log1.5 a or 
m < log1.5 a −1.
Chapter 4
Exercises 4.1
	
1.	 a.	
T        b.  F        c.  F        d.  F
	
3.	 Four: 52, 3, 46 = 5x0x [ N and 2 ≤x ≤46 = 53, 4, 26, 5a, b, c6 = 5x0x is the first letter of cat, bat, or
apple6, [ = 5x0x is the first letter of cat, bat, and apple6, 52, a, 3, b, 4, c6

884	
Answers to Odd-Numbered Exercises
	
5.	a.		 50, 1, 2, 3, 46
	b.	 54, 6, 8, 106
	 c.	 5Washington, Adams, Jefferson6
	d.	[
	 e.	 5Maine, Vermont, New Hampshire, Massachusetts, Connecticut, Rhode Island6
	 f.	 5−3, −2, −1, 0 , 1, 2, 36
	
7.	a.		 5x0x [ N and 1 ≤x ≤56
	b.	 5x0x [ N and x is odd6
	 c.	 5x0x is one of the Three Wise Men6
	d.	 5x0x is a nonnegative integer written in binary form6
	
9.	 If A = 5x0x = 2n for n a positive integer6, then 16 [ A. But if A = 5x0x = 2 + n(n −1) for n a positive 
integer6, then 16 o A. In other words, there is not enough information to answer the ­question.
	 11.	 a.	F        b.  T        c.  F        d.  T        e.  T        f.  T
	 13.	 b, e, and g are true; a is false because 516 [ S but 516 o R; c is false because 516 [ S, but 1 o S; d is false 
because 1 is not a set (the correct statement is 516 # U); f is false because 1 o S
	 15.	 a, b, d, e, g, and i are true; c is false because neither member of C is a member of A; f is false because this 
2-element set is not an element of A; h is false because a o C
	 17.	 Let (x, y) [ A. Then (x, y) lies within 3 units of the point (1, 4), so by the distance formula, 
"(x −1)2 + (y −4)2 ≤3, or (x −1)2 + (y −4)2 ≤9, which means (x −1)2 + (y −4)2 ≤25, so 
(x, y) [ B. The point (6, 4) satisfies the inequality (x −1)2 + (y −4)2 ≤25, so (6, 4) [ B, but (6, 4) is 
not within 3 units of (1, 4), so (6, 4) does not belong to A.
	 19.	 a.	For a = 1, b = −2, c = −24, the quadratic equation is x2 −2x −24 = 0 or (x + 4)(x −6) = 0, 
with solutions 6 and −4. Each of these is an even integer between −100 and 100, so each belongs to E.
	
	 b.	Here Q = 56,−46, but E = 5−4, −2, 0, 2, 46, and Q h E.
	 21.	 a, d, and e
	 23.	 Let x [ A. Then, because A # B, x [ B. Because B # C, x [ C. Thus A # C.
	 25.	 The proof uses mathematical induction. n = 2: A set with 2 elements has exactly 1 subset with 2 elements, 
namely the set itself. Putting n = 2 into the formula n(n −1)∙2 gives the value 1. This proves the base 
case. Assume that any set with k elements has k(k −1)∙2 subsets with exactly 2 elements. Show that 
any set with k + 1 elements has (k + 1)k∙2 subsets with exactly 2 elements. Let x be a member of a set 
with k + 1 elements. Temporarily removing x from the set gives a set of k elements that, by the inductive 
hypothesis, has k(k −1)∙2 subsets with exactly 2 elements. These are all of the 2-element subsets of the 
original set that do not include x. All 2-element subsets of the original set that do include x can be found 
by pairing x in turn with each of the remaining k elements, giving k subsets. The total number of 2-element 
subsets is therefore k(k −1)
2
+ k = (k + 1)k
2
	 27.	 `(S) = 5[, 5a66
	 29.	 For this set of four elements, the power set should have 24 = 16 elements. 
`(S) = 5[, 516, 526, 536, 546, 51, 26, 51, 36, 51, 46, 52, 36, 52, 46, 53, 46, 51, 2, 36, 51, 2, 46, 51, 3, 46, 
52, 3, 46, 51, 2, 3, 466
	 31.	 `(S) = 5[,5[6,55[66, 55[, 5[666, 5[, 5[66, 5[, 5[, 5[666, 55[6, 5[, 5[666, 5[, 5[6, 
5[,5[666 6
	 33.	 A = 5x, y6
	 35.	 Let x [ A. Then 5x6 [ `(A), so 5x6 [ `(B) and x [ B. Thus A # B. A similar argument shows that 
B # A so that A = B.
	 37.	a.	x = 1, y = 5      b.  x = 8, y = 7      c.  x = 1, y = 4

Answers to Odd-Numbered Exercises	
885
	 39.	a.	binary operation
	b.	no; 0 + 0 o N, so closure fails
	 c.	binary operation
	d.	no; ln x is undefined for x ≤0
	 41.	a.	no; operation undefined for x = 0
	b.	binary operation
	 c.	unary operation
	d.	binary operation
	 43.	nn
	 45.	a.	 AB + CD −*  	
b.	 AB ** CD * −  	
c.	 AC * BCDB * +∙+
	 47.	a.	 5t6              	
b.	 5p, q, r, s, t, u6    	
c.	 5q, r, v, w)        d.  [
	 49.	a.	 51, 2, 4, 5, 6, 8, 96	
e.	 52, 6, 86
	b.	 54, 56          	
f.	 50, 1, 3, 7, 96
	 c.	 52, 46          	
g.	 [
	d.	 51, 2, 3, 4, 5, 96
	 51.	a.	 5a6                             	 e.	 5a, 5a66
	b.	 5[, 5a6, 5a, 5a666                 	
f.	 5[, 5a, 5a666
	 c.	 5[, a, 5a6, 55a66, 5a, 5a666 = S    	 g.	 5[6
	d.	[
	 53.	c, e, and f
	 55.	a.	 B′        	 d.	 B′ d C
	b.	B d C  	
e.	 B′ d C′ or (B c C)′ or B′ −C
	 c.	 A d B
	 57.	 a.	C′      b.  B d D      c.  A d B      d.  A d D′
	 59.	D d R′        	
61.  (N c P) d A
	 63.	a, b, d, and f    	
65.  b and c
	 67.	 a.	B # A    b.  A # B    c.  A = [    d.  B # A    e.  A = B    f.  A = B
	 69.	Let x [ A d B. Then x [ A and x [ B, so x [ A.
	 71.	Let C [ `(A) d `(B). Then C [ `(A) and C [ `(B), from which C # A and C # B, so C # A d B or 
C [ `(A d B). Therefore `(A) d `(B) # `( A d B). The same argument works in reverse.
	 73.	Suppose B ∙[. Let x [ B. Then x [ A c B but x o A −B, which contradicts the equality of A c B 
and A −B.
	 75.	Let x [ C. Then x [ B −A = B d A′. Therefore x [ A′, and no element that is in C can also be in A, so 
A d C = [.
	 77.	i. Let A # B and let x [ A. Then x [ B, so x o B′ and no element that is in A can also be in B′. Therefore 
A d B′ = [. ii. Let A d B′ = [ and let x [ A. Then because A d B′ = [, x o B′, so x [ B. Therefore 
any element of A is an element of B, and A # B.
	 79.	 a. 
A
B
	
b.	 52, 4, 6, 7, 96
	 c.	x [ (A c B) −(A d B)  4  x [ (A c B) and x [ (A d B)′ 4  (x [ A or x [ B) and 
x o A d B  4  (x [ A and x o A d B) or (x [ B and x o A d B)   4  (x [ A and x o B) or 
(x [ B and x o A) 4 x [ (A −B) c (B −A)
	 81.	(1a) x [ A c B 4 x [ A or x [ B 4 x [ B or x [ A 4 x [ B c A (1b) x [ A d B 4 x [ A and x [ B 
4 x [ B and x [ A 4 x [ B d A (2a) x [ (A c B) c C 4 x [ (A c B) or x [ C 4 (x [ A or x [ B) 
or x [ C 4 x [ A or x [ B or x [ C 4 x [ A or (x [ B or x [ C) 4 x [ A or x [ (B c C) 4 

886	
Answers to Odd-Numbered Exercises
x [ A c (B c C) (2b) x [ (A d B d C) 4 x [ (A d B) and x [ C 4 (x [ A and x [ B) and x [ C 
4 x [ A and x [ B and x [ C 4 x [ A and (x [ B and x [ C) 4 x [ A and x [ (B d C) 4 
x [ A d (B d C) (3b) x [ A d (B c C) 4 x [ A and x [ (B c C) 4 x [ A and (x [ B or x [ C) 4 
(x [ A and x [ B) or (x [ A and x [ C) 4 x [ (A d B) or x [ (A d C) 4 x [ (A d B) c (A d C) 
(4b) x [ A d S S  x [ A and x [ S S x [ A. Also x [ A S  x [ A and x [ S because A # S S x [ A d S 
(5a) x [ A c A′ S x [ A or x [ A′ S x [ S or x [ S because A # S, A′ # S S  x [ S. Also x [ S S  
(x [ S and x [ A) or (x [ S and x o A) S x [ A or x [ A′ S x [ A c A′ (5b) For any x such that 
x [ A d A′, it follows that x [ A and x [ A′, or x belongs to A and x does not belong to A. This is a con-
tradiction; no x belongs to A d A′, and A d A′ = [. 
	 83.	a.	((A c B) d (A c B′) = A c (B d B′)	
(3a)
	
= A c [	
(5b)
	
= A	
(4a)
	
The dual is (A d B) c (A d B′) = A.
	
b.	 3((A d C) d B) c ((A d C) d B′)4 c (A d C)′
	
= 3(A d C) d (B c B′)4 c (A d C)′	
(3b)
	
= 3(A d C) d S4 c (A d C)′	
(5b)
	
= (A d C) c (A d C)′    	
(4b)
	
= S 	
	
(5b)
	
The dual is 3((A c C) c B) d ((A c C) c B′)4 d (A c C)′ = [.
	
c.	 (A c C) d 3(A d B) c (C′ d B)4
	
= (A c C) d 3(B d A) c (B d C′)4	
(1b)
	
= (A c C) d 3B d (A c C′)4	
(3b)
	
= (A c C) d 3(A c C′) d B4	
(1b)
	
= 3(A c C) d (A c C′)4 d B	
(2b)
	
=  3A c (C d C′)4 d B		
(3a)
	
= (A c [) d B	
	
(5b)
	
= A d B	
	
(4b)
	
The dual is (A d C) c 3(A c B) d (C′ c B)4 = A c B.
	 85. 	a.	 A d (B c A′) = (A d B) c (A d A′)	
(3b)
	
= (A d B) c [	
(5b)
	
= A d B	
(4a)
	
=  B d A	
(1b)
	
b.	(A c B) −C = (A c B) d C′	
(defn. set diff.)
	
= C′ d (A c B)	
(1b)
	
= (C′ d A) c (C′ d B)	
(3b)
	
= (A d C′) c (B d C′)	
(1b)
	
= (A −C) c (B −C)	
(defn. set diff.)
	
c.	 (A −B) −C = (A −B) d C′	
(defn. set diff.)
	
= (A d B′) d C′	
(defn. set diff.)
	
= C′ d (A d B′) 	
(1b)
	
= (C′ d A) d B′	
(2b)
	
= (A d C′) d B′	
(1b)
	
= (A −C) d B′	
(defn. set diff.)
	
= (A −C) −B	
(defn. set diff.)

Answers to Odd-Numbered Exercises	
887
	 87.	 a.	A1 c A2 c cc An = 5x0x belongs to some Ai   for 1 ≤i ≤n6
	b.	 A1 c A2 = 5x0x [ A1 or x [ A26 for n = 2, A1 c A2 c cc An = (A1 c cc An−1) c An for n > 2
	 89.	a.	A1 d A2 d c d An = 5x0x belongs to every Ai for 1 ≤i ≤n6
	
b.	 A1 d  A2 = 5x0x [ A1 and x [ A26  for n = 2, A1 d  A2 d c d An = (A1 d ... d An−1) d  An for n > 2
	 91.	 a.	Proof is by induction on n. For n = 2, B c (A1 d A2) = (B c A1) d (B c A2) by identity 3a.  
Assume that B c (A1 d c d Ak) = (B c A1) d c d (B c Ak). Then B c (A1 d c d Ak+1) =  
B c ((A1 d c d Ak) d Ak+1) by Exercise 89b = (B c (A1 d c d Ak)) d (B c Ak+1) by identity 
3a = ((B c A1) d c d (B c Ak)) d (B c Ak+1) by inductive hyp. = (B c A1) d c d (B c Ak+1) by 
Exercise 89b.
	b.	Proof is by induction on n. For n = 2, B d (A1 c A2) = (B d A1) c (B d A2) by identity 3b. Assume  
that 
B d (A1 c cc Ak) = (B d A1) c cc (B d Ak). 
Then 
B d (A1 c cc Ak+1) = B d 
((A1 c cc Ak) c Ak+1) by Exercise 87b = (B d (A1 c cc Ak)) c (B d Ak+1) by identity 
3b = ((B d A1) c cc (B d Ak)) c (B d Ak+1) by inductive hyp. = (B d A1) c cc (B d Ak+1) 
by Exercise 87b.
	 93.	a.	 d
i[I
Ai = 5x0x [ (−1,1)6; t
i[I
Ai = 506 
	b.	 d
i[I
Ai = 5x0x [ 3−1,146; t
i[I
Ai = 506	
	 95.	 P(1) is true—every member of T is greater than 1; otherwise 1 would be the smallest member of T. As-
sume that P(k) is true, i.e., every member of T is greater than k. Consider P(k + 1), that every member of 
T is greater than k + 1. If P(k + 1) is not true, then there is some member of T ≤k + 1. By the induc-
tive hypothesis, every member of T is greater than k; therefore some member of T equals k + 1, and this 
is the smallest member of T. This is a contradiction, because we assumed that T has no smallest member. 
Therefore P(k + 1) is true. By the first principle of induction, P(n) is true for all n, and T must be empty. 
This contradicts the fact that T is a non-empty set. 
	 97.	 An enumeration of the set is 1, 3, 5, 7, 9, 11, c , 
	 99.	 An enumeration of the set is a, aa, aaa, aaaa, c 
	101.	 An enumeration of the set is shown by the arrow through the array
(2, –2)
(2, –3)     .  .  .
(–1, –2)
(–1, –3)     .  .  .
(1, –2)
(1, –3)     .  .  .
(2, 0)
(–1, 0)
(1, 0)
(0, 0)
(2, 1)
(–1, 1)
(1, 1)
(0, 1)
(2, –1)
(–1, –1)
(1, –1)
(0, –1)
(2, 2)
(–1, 2)
(1, 2)
(0, 2)
(2, 3)
(–1, 3)
(1, 3)
(0, 3)
(0, –2)
(0, –3)     .  .  .
	103.	 Assume that the set has an enumeration
z11, z12, z13, z14, …
z21, z22, z23, z24, …
z31, z32, z33, z34, …
⁞
	 	
Now construct an infinite sequence Z of positive integers with Z = z1, z2, z3, … such that zi ∙zii for all i. 
Then Z differs from every sequence in the enumeration, yet it is a member of the set. This is a contradic-
tion, so the set is uncountable.

888	
Answers to Odd-Numbered Exercises
	105.	 Let A and B be denunmerable sets with enumerations A = a1, a2, a3, c and B = b1, b2, b3, c. Then 
use the list a1, b1, a2, b2, a3, b3, c and eliminate any duplicates. This will be an enumeration of A c B, 
which is therefore denumerable.
	107.	 B = 5S0S is a set and S o S6. Then either B [ B or B o B. If B [ B, then B has the property of all mem-
bers of B, namely B o B. Hence both B [ B and B o B are true. If B o B, then B has the property char-
acterizing members of B, hence B [ B. Therefore both B o B and B [ B are true.
Exercises 4.2
	
1.	 30
	
3.	 92
	
5.	 263 # 102
	
7.	 585
	
9.	 109
	 11.	17,576
	 13.	16
	 15.	286
	 17.	180
	 19.	1680	
	 21.	25,974,000	
	 23.	917
	 25.	15	
	 27.	180	
	 29.	720	
	 31.	45
	 33.	256	
	 35.	192	
	 37.	32	
	 39.	160
	 41.	8	
	 43.	36	
	 45.	6	
	 47.	25
	 49.	648	
	 51.	72	
	 53.	36	
	 55.	60,466,176
	 57.	3,515,625	
	 59.	2704	
	 61.	144
	 63.	208	
	 65.	96	
	 67.	1104
	 69.	
1
1
0
1
0
1
1
0
0
0
1
0
1
0
1
1
1
1
	
	 8 outcomes, which equals F(6)
	 71.	
G
B
R
G
G
B
B
R
R
R
R
G
G
R
R
R
G
G
B
R
B
B
B
G
G
B
B
R
G
B
R
G
B
R
G
B
R
R
R
G
R
G
G
G
B
B
B
B
	
	 33 ways; the outcome that is highlighted is BRGR.
	 73.	 For m = 2, the result follows from the multiplication principle. Assume that for m = k, there are n1 # # # nk 
possible outcomes for the sequence of events 1 to k. Let m = k + 1. Then the sequence of events 1 to 
k + 1 consists of the sequence of events 1 to k followed by event k + 1. The sequence of events 1 to k has 
n1 # # # nk possible outcomes by the inductive hypothesis. The sequence 1 to k followed by event k + 1 
then has ((n1 # # # nk)nk+1 outcomes by the multiplication principle, which equals n1 # # # nk+1.
	 75	 a.	P(1) = 1 (trivial case), P(2) = 1 (only one way to multiply 2 terms). For n > 2, let the last 
multiplication occur at position k, 1 ≤k ≤n −1. The product is then split into two prod-
ucts of k and (n −k) factors, respectively, which can be parenthesized in P(k) and P(n −k) 
ways, respectively. By the multiplication principle, there are P(k)P(n −k) ways to parenthe-
size for a fixed k. Each value for k gives a different set of parentheses, so by the addition principle, 
P(n) = P(1)P(n −1) + P(2)P(n −2) + c+  P(n −1)P(1) = ∙
n−1
k=1
P(k)P(n −k).
	b.	The proof will use the Second Principle of Induction. P(1) = 1 = C(0), P(2) = 1 = C(1). Assume 
that P(r) = C(r −1) for 1 ≤r ≤m. Then P(m + 1) = ∙
m
k=1
P(k)P(m + 1 −k) =  
∙
m
k=1
C(k −1)C(m −k) = C(m).

Answers to Odd-Numbered Exercises	
889
	 15.	 a.	 0A0 + 0B0 + 0C0 + 0D0 −0A d B0 −0A d C0 −0A d D0 −0B d C0 −0B d D0 −0C d D0 +
	
	 	
0A d B d C0 + 0A d B d D0 + 0A d C d D0 + 0B d C d D0 −0A d B d C d D0
	b.	2n −1
Exercises 4.3
	
1.	 19
	
3.	 60
	
5.	 5 parts had all three types of defect.
	
7.	 a.  2    b.  6
	
9.	 a.	
39    b.  14
	 11.	 8
	 13.	 a. 60    b.  40
	 17.	 5     
19.  No     
21.  51     
23.  367
	 25.	 There are 3 pairs—1 and 6, 2 and 5, 3 and 4—that add up to 7. Each element in the set belongs to one of 
these pairs. Apply the pigeonhole principle, where the pairs are the bins, and the numbers are the items.
	 27.	 This follows from the pigeonhole principle, where the n possible remainders (the numbers 0 through 
n −1) are the bins.
Exercises 4.4
	
1.	 a.	
42    b.  6720
	
3.	 362,880
	
5.	 3,628,800
	
7.	 40,320; 15,120
	
9.	 2730
	 11.	 19!
	 13.	 (2!)(11!)(8!) = 2(39,916,800)(40,320)
	 15.	 18!
	 17.	 a.	
120    b.  36    c.  28
	 19.	 C(300, 25)
	 21.	 C(17, 5)C(23, 7)
	 23.	 11,760
	 25.	 427,518
	 27.	 48
	 29.	 22308
	 31.	 792
	 33.	 4
	 35.	 624
	 37.	 5,108
	 39.	 54,912
	 41.	 1,098,240
	 43.	 482,320,623,240
	 45.	 11,662,691,040
	 47.	 902,720
	 49.	 495
	 51.	 40
	 53.	 1770
	 55.	 341,149,446
	 57.	 220
	 59.	 115
	 61.	 14,307,150
	 63.	 4,412,826
	 65.	 8,586,820
	 67.	 3003
	 69.	 2508
	 71.	 19,481
	 73.	 36
	 75.	 20
	 77.	 a.  3360    b.  420
	 79.	 27,720
	 81.	 21
	 83.	 C(81, 48) = very big number
	 85.	 a.  28        b.  7    c.  10
	 87.	 a.  8008    b.  84
	 89.	 286
	 91.	 P(n, n) =
n!
(n −n)! = n!
0! = n! and P(n, n −1) =
n!
(n −(n −1))! = n!
1! = n!
	 93.	 C(n,r) =
n!
r!(n −r)! =
n!
(n −r)!(n −(n −r))! =  C(n,n −r)
	
	 Whenever r objects are chosen from n, n −r objects are not chosen. Therefore the number of ways to 
choose r objects out of n is the same as the number of ways to choose n −r objects out of n.

890	
Answers to Odd-Numbered Exercises
	 95.	 Consider selecting r elements from a set of n and putting those in bucket A, then selecting k of those r to put in 
bucket B. The left side multiplies the number of outcomes from those two sequential tasks. Alternatively, we 
can select k elements from n and place them in bucket B, then r −k elements from the remaining n −k and 
place them in bucket A. The right side multiplies the number of outcomes from these two sequential tasks.
	 97.	 C(2) = 1
3C(4,2) = 1
3 
4!
2! # 2! = 4 # 3
3 # 2 = 2
	
	 C(3) = 1
4C(6,3) = 1
4 
6!
3! # 3! = 6 # 5 # 4
4 # 2 # 3 = 5      
	
	 C(4) = 1
5C(8,4) = 1
5 
8!
4! # 4! = 8 # 7 # 6 # 5
5 # 2 # 3 # 4 = 14
	
	 These results agree with the recurrence relation results.
	 99.	 163452, 163542, 345621, 356421, 634521, 643125
	101.	7431652; reading right to left, the first non-increasing value is 1. Again reading right to left, the first value 
greater than 1 is 2, so swap 1 and 2, giving 7432651. From the right of the 2 value, the numbers decrease; 
swap 6 and 1, giving 7432156.
	103.	3675421; reading right to left, the first non-increasing value is 6. Again reading right to left, the first value 
greater than 6 is 7, so swap 6 and 7, giving 3765421. From the right of the 7 value, the numbers decrease; 
swap 6 and 1, swap 5 and 2, giving 3712456.
	105.	24589, 24678, 24679, 24689, 24789
	107.	Make the initial permutation the largest permutation, n…321. Then just reverse all inequalities in the body 
of algorithm permutation generator.
Exercises 4.5
	
1.	a.	a5 + 5a4b + 10a3b2 + 10a2b3 + 5ab4 + b5
	b.	x6 + 6x5y + 15x4y2 + 20x3y3 + 15x2y4 + 6xy5 + y6
	 c.	a5 + 10a4 + 40a3 + 80a2 + 80a + 32
	d.	a4 −16a3 + 96a2 −256a + 256
	
3.	 120a7b3
	
5.	 −489,888x4
	
7.	 6561y8
	
9.	 2560x3y2
	 11.	 Think of (a + b + c)3 as ((a + b) + c)3. Then ((a + b) + c)3 = C(3, 0)(a + b)3 + C(3, 1)(a + b)2c +
C(3, 2)(a + b)c2 + C(3, 3)c3 = a3 + 3a2b + 3ab2 + b3 + 3a2c + 6abc + 3b2c + 3ac2 + 3bc2 + c3
	 13.	 11,200
	 15.	 C(n + 2, r) = C(n + 1, r −1) + C(n + 1, r) (Pascal’s formula) = C(n, r −2) + C(n, r −1) +
C(n, r −1) + C(n, r) (Pascal’s formula again) = C(n, r) + 2C(n, r −1) + C(n, r −2)
	 17.	 From the binomial theorem with a = 1, b = (−1): C(n, 0) −C(n,1) + C(n,2) −c+  
(−1)nC(n,n) = (1 + (−1))n = 0n = 0
	 19.	 From the binomial theorem with a = 1, b = 2−1:
C(n, 0) + C(n, 1)2−1 + C(n, 2)2−2 + c+ C(n, n)2−n = (1 + 2−1)n
	
	 so, multiplying by 2n,
C(n, 0)2n + C(n, 1)2n−1 + C(n, 2)2n−2 + c+ C(n, n)2n−n = 2n(1 + 2−1)n

Answers to Odd-Numbered Exercises	
891
	
	 or
C(n, 0)2n + C(n, 1)2n−1 + C(n, 2)2n−2 + c+ C(n, n) =
	
2na1 + 1
2b
n
= 2na2 + 1
2
b
n
= 2na3n
2nb = 3n
	 21.	 a.	(1 + x)n = C(n, 0) + C(n, 1)x + C(n, 2)x2 + C(n, 3)x3 + c+ C(n, n)xn 
	b.	Differentiating both sides of the equation in (a) gives n(1 + x)n−1 = C(n, 1) + 2C(n, 2)x + 
3C(n, 3)x2 + c+ nC(n, n)xn−1 c. follows from (b) with x = 1 d. follows from (b) with x = −1
	 23.	a.	Out of all the intersections of m sets, 1 ≤m ≤k, we want the ones that pick all m sets from the k sets 
in B. There are C(k, m) ways to do this.
	b.	For any value of m, 1 ≤m ≤k, an intersection of m sets has C(k, m) that include only sets in B. Count-
ing the intersections in the right side of (1) that contain x (intersections of single sets, intersections of 
2 sets, and so forth) we get C(k, 1) −C(k, 2) + C(k, 3) −c+ (−1)k+1C(k, k)
	 c.	From Exercise 17, C(k, 0) −C(k, 1) + C(k, 2) −c+ (−1)kC(k, k) = 0 or C(k, 1) −C(k,2) + 
c (−1)k+1C(k, k) = C(k, 0), but C(k, 0) = 1. Therefore x is counted only once in the right side of (1).
Exercises 4.6
Some decimal answers in this section are approximations.
	
1.	 8
	
3.	 1∙8
	
5.	 1∙4
	
7.	 36
	
9.	 1∙6
	 11.	 1∙6
	 13.	 1∙12
	 15.	 8
	 17.	 1∙8
	 19.	 1∙4
	 21.	 1∙52
	 23.	 1∙2
	 25.	 1326
	 27.	 > 0.5588
	 29.	 > 0.3824
	 31.	 > 0.0498	
	 33.	 > 0.0023
	 35.	 The answer to Exercise 30 should be the sum of the answers to Exercises 28 and 29 because “at least one 
spade” is either exactly one spade (Exercise 29) or two spades (Exercise 28). Using the probabilities ob-
tained, this arithmetic is correct.
	 37.	a.	1000	
b.  0.001	
c.  0.006	
d.  0.003
	 39.	a.	69,090,840	
b.  > 0.0000017	
c.  > 0.000295	
d.  > 0.0097
	 41.	> 0.0000015
	 43.	 > 0.0002
	 45.	 > 0.002
	 47.	 > 0.021
	 49.	 > 0.423
	 51.	 365n
	 53.	 B = E′, so from Exercise 52, P(B) = 1 −P(E) = 1 −P(365, n)∙365n.
	 55.	 B has a higher probability because B consists of exactly two +  exactly three + c+  exactly n persons 
sharing the same birthday, whereas C consists of exactly two.
	 57.	 38
	 59.	 > 0.026
	 61.	 > 0.105
	 63.	 > 0.00000751
	 65.	 6.29908E-12
	 67.	a.  0.55	
b.  0.68	
c.  0.32
	 69.	a.  0.6	
b.  0.25	
c.  0.65	
d.  0.15	
e.  0.95
	 71.	 > 0.93
	 73.	a.	 > 0.24 	
b.  0.43 	
c.  0.57

892	
Answers to Odd-Numbered Exercises
	 75.	 0.25
	 77.	 0.3125
	 79.	 0.5
	 81.	 0.5
	 83.	 0.375
	 85.	 0.875
	 87.	 0.5
	 89.	 a.	P(Ei 0  F) = P(Ei d F)
P(F)

(1)
	
P(F 0 Ei) = P(F d Ei)
P(Ei)
 or P(F d Ei) = P(F 0 Ei) P(Ei)
(2)
	
	 	 Because P(F d Ei) = P(Ei d F), substitute from Equation (2) into Equation (1), giving
P(Ei 0  F) = P(F 0 Ei) P(Ei) 
P(F)
	
b.	The events Ei,1 ≤i ≤n, are all disjoint; therefore the events F d Ei,1 ≤i ≤n are all disjoint. 
F = F d S = F d (E1 c E2 c … c En) = (F d E1) c (F d E2) c … c (F d En). Because the prob-
ability of the union of disjoint events is the sum of the probabilities of each event,
	
P(F) = ∙
n
k=1
P(F d Ek).
	
c.	 From Equation (2) of part (a), P(F d Ei) = P(F 0 Ei) P(Ei). Substituting into the result of part (b) gives
	
P(F) = ∙
n
k=1
P(F 0 Ek) P(Ek)
	
d.	Substituting the result of part (c) into the result of part (a) gives
 P(Ei 0  F) =
P(F 0 Ei) P(Ei)
∙
n
k=1
P(F 0 Ek) P(Ek)
	 91.	 > 0.40
	 93.	a.	3.5
	b.	 > 3.29
	 c.	Less than (which turns out to be true, 3.29 < 3.5). The reason is that the die is now weighted toward 
a smaller value than the previous expected value, so this smaller value is more likely to occur and will 
drag down the weighted average.
	 95.	 4.75
	 97.	 a. > 0.904	
b.  > 0.999 	
c. > 0.096
	 99.	 > 0.547
	101.	  n2 + 3n
2(n + 1)

Answers to Odd-Numbered Exercises	
893
Chapter 5
Exercises 5.1
	
1.	 a.	(1, 3),(3, 3)	
3.  a.	 (1, −1),(−3, 3)
	
b.	(4, 2),(5, 3)	
b.	 (19, 7),(41, 16)
	
c.	 (5, 0),(2, 2)	
c.	 (−3, −5),(−4, 1∙2),(1∙2, 1∙3)
	
d.	(1, 1),(3, 9)	
d.	 ((1, 2),(3, 2))
	
5.	 a.	
(0, 2)
2
1
3
2
3
1
1
3
3
2
1
x
y
	
b.	
(0, 1)
(1, 0)
1
3
2
3
2
1
y
2
1
3
2
3
1
1
3
2
3
2
1
x
y
	c.	
(0, 5)
(0, 5)
(5, 0)
(5, 0)
x
y
	
d.	
2
1
3
2
3
1
x
(2, 2)
1
3
2
3
2
1
y
(2, 2)
	
7.	 a.	many-to-many
	b.	many-to-one
	 c.	one-to-one
	d.	one-to-many
	
9.	 a.	(2, 6),(3, 17),(0, 0)
	b.	(2, 12)
	 c.	none
	d.	(1, 1),(4, 8)
	 11.	a.	reflexive
	b.	reflexive, symmetric, antisymmetric, transitive
	 c.	none
	d.	antisymmetric, transitive
	 13.	 a.	reflexive, transitive
	b.	reflexive, symmetric, transitive
	 c.	symmetric
	d.	transitive
	 e.	reflexive, symmetric, transitive	
	 15.	(b);	the equivalence classes are 304 = 5…, −9, −6, −3, 0, 3, 6, 9, …6,314 = 5…, −8, −5, −2, 1, 4, 
7, 10, …6, and 324 = 5…, −7, −4, −1, 2, 5, 8, 11, …6. 
	
	(e);	the equivalence classes are sets consisting of squares with equal length sides.

894	
Answers to Odd-Numbered Exercises
	 21.	For example: 
	a.	S = set of all lines in the plane, x r y   4   x coincides with y or x is perpendicular to y. 
	b.	S = set of integers, x r y   4   x2 ≤y2
	 c.	S = set of nonnegative integers, x r y   4   x < y
	d.	S = set of integers, x r y   4   x ≤0y0.
	 23.	a.	reflexive closure = r itself, symmetric closure—add (2,1),(3, 2), transitive closure—add (2, 1),(3, 2)
	b.	reflexive closure =  symmetric closure = transitive closure = r itself
	 c.	reflexive closure—add (2, 2),(3, 3), symmetric closure—add (2, 1),(3, 2), transitive closure—add 
(1, 1), (2, 1), (2, 2), (3, 3)
	d.	reflexive closure—add (2, 2), (3, 3), symmetric closure—add (2, 1), (3, 2), (3, 1), transitive closure 
5r itself
	 25.	 x r* y  4  one can fly from x to y (perhaps by multiple hops) on Take-Your-Chance Airlines
	 27.	 No—if the relation is irreflexive, it is its own irreflexive closure. If the relation is not irreflexive, there 
must be some x [ S with (x, x) in the relation; extending the relation will not remove this pair, so no ex-
tension can be irreflexive.
	 29.	 2n2
	 31.	 a.	
a
b
c	
b.	
a
c
b
d
	
c.	
(a, c)
(c)
(a)
(b)
(a, b)

	 33.	Reflexivity: If x [ A, then x [ S, so (x d x) because d is a reflexive relation on S. Symmetry: if x, y [ A 
and x d y, then x, y [ S and x d y, so y d x because d is symmetric on S. Transitivity: if x, y, z [ A 
and x d y and y d z, then x, y, z [ S, x d y, and y d z, so x d z because d is transitive on S.
	 35.	

1
10
30
2
5
6
15
3
{1, 2}
{1, 3}
{1, 2, 3}
{1}
{2, 3}
{3}
{2}
	The two graphs are identical in structure.
	 37.	 Reflexive: (s1, t1) m (s1, t1) because both s1 r s1 and t1 s t1 due to reflexivity of r and s. Antisymmetric: 
(s1, t1) m (s2, t2) and (s2, t2) m (s1, t1) S  s1 r s2 and s2 r s1, t1 s t2 and t2 s t1 S  s1 = s2 and t1 = t2 due to 
antisymmetry of r and s S  (s1, t1) = (s2, t2). Transitive: (s1, t1) m (s2, t2) and (s2, t2) m (s3, t3) S  s1 r s2 
and s2  r  s3, t1 s t2 and t2 s t3 S  s1 r s3 and t1st3 due to transitivity of r and s S  (s1, t1) m (s3, t3).	
	 39.	 Assume that r is reflexive and transitive on S. Then for all x [ S, (x, x) [ r, which means (x, x) [ r−1, 
so (x, x) [ r d r−1 and r d r−1 is reflexive. Let (x, y) [ r d r−1. Then (x, y) [ r and (x, y) [ r−1, 
which means (x, y) [ r and (y, x) [ r. This implies (y, x) [ r−1 and (y, x) [ r, so (y, x) [ r d r−1 and 
r d r−1 is symmetric. Let (x, y) [ r d r−1 and (y, z) [ r d r−1. Then (x, y) [ r and (x, y) [ r−1 and 
(y, z) [ r and (y, z) [ r−1, so (x, y) [ r and (y, x) [ r and (y, z) [ r and (z, y) [ r. Because r is transi-
tive, (x, z) [ r and (z, x) [ r or (x, z) [ r and (x, z) [ r−1, so (x, z) [ r d r−1 and r d r−1 is transitive.
	 17.	a.	symmetric
	b.	antisymmetric, transitive
	 c.	reflexive, antisymmetric, transitive
	d.	reflexive, symmetric, transitive
	 19.	a.	 reflexive, transitive
	b.	antisymmetric, transitive
	 c.	reflexive, symmetric, transitive
	d.	antisymmetric

Answers to Odd-Numbered Exercises	
895
	 41.	 Reflexive: X d X  because xi = xi, 1 ≤i ≤k. Antisymmetric: Let X d Y and Y d X . If X ∙Y, let 
m + 1 be the first index where xm+1 ∙ym+1. Then xm+1 d ym+1 and ym+1 d xm+1 S xm+1 = ym+1, a 
contradiction. Transitive: Let X d Y and Y d Z. Then xp d yp for some p ≤k and yq d zq for some 
q ≤k. Let m = min(p, q). Then xm d zm and X d Z. Therefore d  is a partial ordering. It is a total 
­ordering by “otherwise”.
	 43.	 a.	when; no; all but the last
	b.	
Old
King
merry soul
was
Cole
a
	
Maximal elements: a, merry, soul
	 45.	 a.	 3a4 = 5a, c6 = 3c4
	b.	 334 = 51, 2, 36, 344 = 54, 56
	 47.	 314 = 5... , −5, −3, −1, 1, 3, 5, ...6
	 49.	 If x ≡y (mod n) then x −y = k1n for some integer k1, or x = k1n + y. If z ≡w (mod n) then z −w = k2n 
for some integer k2, or z = k2n + w.
	a.	x + z = (k1n + y) + (k2n + w) = y + w + (k1 + k2)n, so x + z −(y + w) = (k1 + k2)n where 
k1 + k2 is an integer, and x + z ≡y + w (mod n).
	b.	x −z = (k1n + y) −(k2n + w) = y −w + (k1 −k2)n, so x −z −(y −w) = (k1 −k2)n where 
k1 −k2 is an integer, and x −z ≡y −w (mod n).
	 c.	xz = (k1n + y)(k2n + w) = k1k2n2 + yk2n + wk1n + yw = (k1k2n + yk2 + wk1)n + yw so 
xz −yw = (k1k2n + yk2 + wk1)n where k1k2n + yk2 + wk1 is an integer, and xz ≡yw (mod n).
	
d.	xs −ys = (k1n + y)s −ys = c ∙
s
k=0
C(s, k)(k1n)s−kykd − ys
	
= c ∙
s−1
k=0
C(s, k)(k1n)s−kykd + ys −ys = n∙
s−1
k=0
C(s, k)k1
s−kns−k−1yk = nk2
	
where k2 is an integer and xs ≡ys (mod n).
	 51.	a.	 5(1, 1), (2, 2), (3, 3), (4, 4), (1, 2), (2, 1), (3, 4), (4, 3)6
	b.	 5(a, a), (b, b), (c, c), (d, d), (e, e), (a, b), (b, a), (a, c), (c, a), (b, c), (c, b), (d, e), (e, d)6
	 53.	 Reflexive: x2 −x2 = 0, which is even. Symmetric: If x2 −y2 = 2n then y2 −x2 = −2n, which is even. 
Transitive: if x2 −y2 = 2n and y2 −z2 = 2m, then x2 −z2 = x2 −y2 + y2 −z2 = 2n + 2m = 2(n + m), 
which is even. The equivalence classes are the set of even integers and the set of odd integers.
	 55.	 Reflexive: (x, y) r (x, y) because y = y. Symmetric: If (x, y) r (z, w) then y = w so w = y and (z, w) r (x, y). 
Transitive: If (x, y) r (z, w) and (z, w) r (s, t) then y = w and w = t, so y = t and (x, y) r (s, t). The 
equivalence classes are sets of ordered pairs with the same second components.
	 57.	a.	Reflexive: x r x because x and x start and end with the same bit values. Symmetric: If x r y then y 
starts and ends with the same bits as x, so x starts and ends with the same bits as y and therefore y r x. 
Transitive: If x r y and y r z, then y starts and ends with the same bits as x and z starts and ends with the 
same bits as y, so z starts and ends with the same bits as x and therefore x r z.
	b.	256
	 c.	4; there are 4 start bit-end bit combinations, 0…0, 1…0, 0…1, and 1…1.
	d.	26
	 59.	Clearly P 4 P is a tautology. If P 4 Q is a tautology, then P and Q have the same truth values every-
where, so Q 4 P is a tautology. If P 4 Q and Q 4 R are tautologies, then P, Q, and R have the same 

896	
Answers to Odd-Numbered Exercises
truth values everywhere, and P 4 R is a tautology. The equivalence classes are sets consisting of wffs 
with the same truth values everywhere.
	 61.	 a.	1        b.  2        c.  5        d.  15
	 63.	 Answers agree with Exercise 61.
	 65.	 a.	3        b.  7
	 67.	 Answers agree with Exercise 65.
	 69.	 The number of blocks in a partition can range from 1 (the whole set) to n (a single element in each block). 
The result follows by the definition of S(n, k) and the addition principle.
	 71.	 6
	 73.	 a.	25, 49        b.  (3, 4, 5), (0, 5, 5), (8, 6, 10)        c.  (−4, 4, 2, 0), (−6, 6, 0, −2)
	 75.	 6
Exercises 5.2
	
1.	Yes; for example: 1, 2, 3, 8, 4, 5, 6, 7, 9
	
3.	
E(2)
A(3)
G(4)
C(2)
F(4)
H(1)
B(5)
D(6)
	
5.	Minimum time-to-completion is 17 time units. Critical path: E, A, D, B, H
	
7.	Minimum time to completion is 13 time units. Critical path: E, A, C, B, H
	
9.	For example: G, H, F, D, E, C, A, B
	 11.	For example: E, A, C, D, G, F, B, H
	 13.	 For example, 6, 9, 1, 7, 8, 11, 2, 3, 5, 10, 4
	 15.	 For example, 5, 6, 4, 1, 2, 3, 7, 10, 8, 11, 9
Exercises 5.3
	
1.	 a.	Give the name, type, and breed of all pets that are cats.
	b.	2
	 c.	SELECT PetName, PetType, Breed FROM Pet WHERE PetType = “Cat”;
	
3.	
WhatAmI
PetName 
Breed
Spot 
Hound
Twinkles 
Siamese
Lad 
Collie
Lassie 
Collie
Mohawk 
Moorish idol
Tweetie 
Canary
Tiger 
Shorthair

Answers to Odd-Numbered Exercises	
897
	
5.	
ISBN
Title
Publisher
Subject
N
M
Books
Writes
Author
Name
Country
	
	 The writes relation is many-to-many; that is, one author can write many books, and one book can have 
more than one author.
	
7.	
Results7
Name
Country
East, Jane
U.S.
Kovalsco, Bert
U.S.
	
9.	
Results9
ISBN
Title
Publisher
Subject
0-364-87547-X
Early Tang Paintings
Bellman
Art
0-56-000142-8
Springtime Gardening
Swift-Key
Nature
	 11.	
Results11
Name
Chan, Jimmy
East, Jane
King, Dorothy
Kovalsco, Bert
Lau, Won
Nkoma, Jon
Quercos, Tom
	
	
13.  
Results13
Publisher
Subject
Bellman
Art
Harding
Art
Harding
Nature
Loraine
Nature
Swift-Key
Nature
	
	

In some database systems you have to specify, via something 
like a “DISTINCT” clause or a “Unique Values” property, that 
duplicate tuples should be eliminated. Otherwise in this exam-
ple, (Harding, Nature) would be listed twice.
	 15.	
Results15
ISBN
Name
Title
Publisher
Subject
0-115-01214-1
Nkoma, Jon
Birds of Africa
Loraine
Nature
0-364-87547-X
Lau, Won
Early Tang Paintings
Bellman
Art
0-364-87547-X
Chan, Jimmy
Early Tang Paintings
Bellman
Art
0-56-000142-8
East, Jane
Springtime Gardening
Swift-Key
Nature
0-816-35421-9
King, Dorothy
Springtime Gardening
Harding
Nature
0-816-53705-4
Kovalsco, Bert
Baskets for Today
Harding
Art
0-816-88506-0
King, Dorothy
Autumn Annuals
Harding
Nature

898	
Answers to Odd-Numbered Exercises
	 17.		a.	 project(restrict Book where Subject = “Art”) over Title giving Results 17
	
	 b.	SELECT Title FROM Book WHERE Subject = “Art”;
	 c.	Range of x is Book, 5x.Title0x.Subject = “Art”6
	d.	
Results17
Title
Baskets for Today
Early Tang Paintings
	 19.	 a.	project(join(restrict Book where Publisher = “Harding”) and Writes over ISBN) over Name giving 
Results19
	
	 b.	SELECT Name FROM Writes, Book WHERE Book.ISBN = Writes.ISBN AND Publisher =  
“Harding”;
	 c.	Range of x is Writes, Range of y is Book, 5x.Name0exists y(y.Publisher = “Harding” and
y.ISBN = x.ISBN)6
	
d.	
Results19
Name
King, Dorothy
Kovalsco, Bert
	 21.	 a.	project (join(join(restrict Author where Country = “U.S.”) and Writes over Name) and Book over 
ISBN) over Title giving Results21
	b.	SELECT Title FROM Author, Book,Writes WHERE Author.Name = Writes.Name AND Writes.
ISBN = Book.ISBN AND Country 5 “U.S.”;
	 c.	Range of x is Book, Range of y is Author, Range of z is Writes, 5x.Title 0 exists y, z (y.Country =
“U.S.” and y.Name = z.Name and z.ISBN = x.ISBN6
	
d.	
Results21
Title
Baskets for Today
Springtime Gardening
	 23.	 a.	project(join(join(restrict Author where Country = “England”) and Writes over Name) and 
(restrict Book where Subject = “Art”) over ISBN) over Name, Title giving Results23
	b.	SELECT Author.Name, Title FROM Book, Author, Writes WHERE Author.Name = Writes.Name 
AND Writes.ISBN = Book.ISBN AND Country = “England” AND Subject = “Art”;
	 c.	Range of x is Author, Range of y is Book, Range of z is Writes, 5x.Name and y.  
Title0x.Country = “England” and y.Subject = “Art” and exists z 0  z.Name = x.Name and  
y.ISBN = z.ISBN6
	d.	The empty set; there are no results that match this query.	
	 25.	 a.	p * q
	b.	If the common attribute is sorted in each table, then the join can be performed by doing something 
similar to a merge sort (see Exercise 19 in Section 3.3) on the common attribute, which means at most 
(p + q) rows would need to be examined.
	 c.	14
	d.	42
	 27.	 a.	SELECT Author.Name, Title, Book.ISBN, RoyaltyPercent FROM Author, Book, Writes WHERE 
Author.Name = Writes.Name AND Writes.ISBN = Book.ISBN AND RoyaltyPercent <100;
	b.	 Royalty Less Than 100
Name
Title
ISBN
RoyaltyPercent
Chan, Jimmy
Early Tang Paintings
0-364-87547-X
20
Lau, Won
Early Tang Paintings
0-364-87547-X
80

Answers to Odd-Numbered Exercises	
899
	 29.	 a.	Yes—every attribute described for Employee, Contribution, and Payment is listed and no attributes not 
mentioned have been included.
	b.	The primary key of Employees is EmployeeID, presumably a unique identifer for each employee. 
Likewise, the primary key of Contribution is ContributionID. The primary key of Payment is the com-
posite key ContributionID / PaymentDate. None of the three attributes alone uniquely identifies a pay-
ment, nor does ContributionID / PaymentAmount [a given contribution may result in the same payment 
amount on several different dates] or PaymentDate / PaymentAmount [multiple contributions can pay 
the same amount on the same payment date]. But a given contribution does not have different payment 
amounts on the same date.
	 31.	 a.	The three relation tables are
Employee
EmployeeID
FirstName
LastName
Department
1
Mary
Black
Accounting
2
June
Brown
Payroll
3
Kevin
White
Accounting
4
Kelly
Chen
Payroll
6
Conner
Smith
Sales
Contribution
ContributionID
EmployeeID
ContributionDate
TotalAmount
NumberofPayments
101
1
1/1/2013
$300.00
3
102
3
1/1/2013
$500.00
2
103
6
1/1/2013
$150.00
2
104
4
4/15/2013
$100.00
1
105
1
6/1/2013
$210.00
3
107
2
6/1/2013
$300.00
2
108
2
1/1/2014
$600.00
12
109
3
1/1/2014
$500.00
2
Payment
ContributionID
PaymentDate
PaymentAmount
101
1/15/2013
$100.00
101
1/31/2013
$100.00
101
2/15/2013
$100.00
102
1/15/2013
$250.00
102
1/31/2013
$250.00
103
1/15/2013
$75.00
103
1/31/2013
$75.00
104
4/30/2013
$100.00
105
6/15/2013
$70.00
105
6/30/2013
$70.00
105
7/15/2013
$70.00
107
6/15/2013
$150.00
107
6/30/2013
$150.00
108
1/15/2014
$50.00
109
1/15/2014
$250.00

900	
Answers to Odd-Numbered Exercises
	b.	EmployeeID in the Contribution table is a foreign key into the Employee table. ContributionID in the 
Payment table is a foreign key into the Contribution table.
	 c.	Because the EmployeeID is just a sequence of sequential integer values that are likely to have no mean-
ing outside the database, it is probably a blind key generated automatically by the database ­system.
	 33.	 SELECT Employee.EmployeeID, PaymentDate, PaymentAmount FROM Employee, Contribution,  
Payment WHERE Employee.EmployeeID = Contribution. EmployeeID AND Contribution.
ContributionID = Payment.ContributionID AND PaymentAmount > 100; The result is
EmployeeID
PaymentDate
PaymentAmount
2
6/15/2013
$150.00
2
6/30/2013
$150.00
3
1/15/2013
$250.00
3
1/31/2013
$250.00
3
1/15/2014
$250.00
	 35.	 SELECT FirstName, LastName, PaymentAmount, PaymentDate FROM Employee, Contribu-
tion, Payment WHERE Employee.EmployeeID = Contribution.EmployeeID AND Contribution.
ContributionID = Payment.ContributionID AND PaymentDate = “1∙15∙2013”; (The last equality is 
likely to need a system-dependent additional function to convert the 1/15/2013 to a true date type so the 
equality test will work.) The result is
FirstName
LastName
PaymentAmount
PaymentDate
Mary
Black
$100.00
1/15/2013
Kevin
White
$250.00
1/15/2013
Conner
Smith
$75.00
1/15/2013
Exercises 5.4
	
1.	 a.	Domain = 54, 5, 6, 7, 86 codomain = 58, 9, 10, 116 range = 58, 9, 106
	b.	8, 10
	 c.	6, 7
	d.	no, no
	
3.	a.	5(0, −1), (1, 1), (2, 3)6       
	b.	 5(1, 1), (2, 3), (4, 7), (5, 9)6
	 c.	 5("7, 2"7−1), (1.5, 2)6
	
5.	 a.	 f (A) = 53, 9, 156        b.  f (A) = all integral multiples of 6
	
7.	 a.	 f (S) = 53, 76        b.  f (S) = 51, 36        c.  f (S) = 52, 1, 06
	
9.	 a.	F        b.  F        c.  T        d.  F
	 11.	 a.		not a function      	 b.	function        c.  function; one-to-one and onto
	d.	not a function      	 e.	not a function
	 13.	 a.		not a function      	 b.	function, onto, not one-to-one        c.  function, one-to-one, not onto
	 15.	 a.	function
	b.	not a function
	 c.	function; onto
	d.	bijection; f −1: 5p, q, r6 S  51, 2, 36 where f −1 = 5(q, 1), (r, 2), (p, 3)6
	 e.	function; one-to-one
	 f.	bijection; h−1: R2 S  R2 where h−1(x, y) = (y −1, x −1)

Answers to Odd-Numbered Exercises	
901
	 17.	 Any odd value of n will produce a bijection because the function will look similar to Figure 5.12. For even 
values of n the function is not one-to-one because positive and negative values map to the same result.
	 19.	 f is neither one-to-one nor onto. For example, f (xxy) = f (yyy) = 3, so f is not one-to-one. For any string 
s, f (s) ≥0; there are no strings in A* that map to negative values, so f is not onto.
	 21.	 f is both one-to-one and onto. If f (s1) = f (s2) then s1 = s2 (just reverse the strings again and you get back 
where you started), so f is one-to-one. Given any string s in A*, let y be its reverse. Then y is in A* and 
f(y) = s, so f is onto.
	 23.	 f is neither one-to-one nor onto. For example, f (5a, b6) = f (5b, c6) = 2, so f is not one-to-one. The range 
of f is the set of sizes of all subsets of 5a, b, c6, which is 50, 1, 2, 36, so this is clearly not Z and f is not 
onto.
	 25.	 For example, f(x) = 1∙x. For x ≥1, the value 1∙x is greater than 0 but less than or equal to 1, so 
f: S S  T. If f(x1) = f(x2), then 1∙x1 = 1∙x2 and x1 = x2, so f is one-to-one. Given any value y in T, that 
is, 0 < y ≤1, the value 1/y is in S and f(1∙y) = 1∙(1∙y) = y, so f is onto.
	 27.	 	
a.  3          b.  0          c.  0
	 29.	 The greatest integer ≤x is the same as the smallest integer ≥x; therefore x is an integer.
	 31.	 Let k ≤x < k + 1 where k is an integer. Then k is the greatest integer that is less than or equal to x, so 
:x; = k. Also, multiplying the entire inequality by −1, which reverses the direction of the inequality 
signs, gives −k ≥−x > −k −1 which means that −k is the smallest integer greater than or equal to −x, 
so <−x= = −k. Multiplying both sides of this equation by –1 gives −<−x= = k.
	 33.	 a.	False. Let x = 3.6. Then <:x;= = <3= = 3 ∙x.
	b.	False. Let x = 4.8. Then :2x; = :9.6; = 9 but 2:x; = 2(4) = 8.
	 35.	 If  2k < n < 2k+1 then log(2k) < log n < log(2k+1) or k < log n < k + 1 and :log n; = k, <log n= = k + 1.
	 37.	 a.	9          b.  0          c.  4          d.  2
	 39.	 False. For example, let x = 7 and y = 9. Then x mod 10 + y mod 10 = 7 + 9 = 16 but (x + y) mod 
10 = 16 mod 10 = 6.
	 41.	 a.	 (1, 1), (2, 0), (3, 1), (4, 0), (5, 1)
	b.	cAdB(x) = 1  4 x [ A and x [ B  4  cA(x) = 1 and cB(x) = 1   4   cA(x) # cB(x) = 1
	 c.	If cA′(x) = 1, then x [ A′ and x o A, so cA(x) = 0 = 1 −cA′(x). If cA′(x) = 0. then x o A′ and x [ A 
so cA(x) = 1 = 1 −cA′(x)
	d.	No. Let S = 51, 2, 36, A = 51, 26, B = 52, 36. Then cAcB(2) = 1 but cA(2) + cB(2) = 1 + 1.
	 43.	 a.	 S(0, n) > A(0, n) for n > 1 because nn > n + 1.
	b.	S(1, n) = S(0, S(0, n)) = S(0, nn) = nnnn
	 c.	The googolplex is 1010100 = 10101010
= S(1,10)
	 45.	 g + f = 5(1, 6), (2, 7), (3, 9), (4, 9)6
	 47.	 a.	18      	
b.	16      	
c.	3x + 3
	
	 d.	3x + 1  	
e.	 x + 2    	 f.	 9x
	 49.	 a. If f(s1) = f(s2) then g(f(s1)) = g(f(s2)) so (g + f )(s1) = (g + f )(s2). Because g + f  is one-to-one, s1 = s2 
and therefore f is one-to-one.
	b.	For u [ U, there exists s [ S such that (g + f )(s) = u, because g + f  is onto. Thus g(  f (s)) = u and f(s) 
is a member of T that is a preimage of u under g, and g is onto.
	 c.	Let S = 51, 2, 36, T = 51, 2, 3, 46, U = 51, 2, 36, f = 5(1, 1), (2, 2), (3, 3)6,  g = 5(1, 1), (2, 2), 
(3, 3), (4, 3)6. Then f: S S  T, g: T S  U, g is not one-to-one but g + f = 5(1, 1), (2, 2), (3, 3)6 is  
one-to-one.
	d.	same example as for (c)
	 51.	 a.	 f −1(x) = x∙2          b.  f −1(x) = "
3 x        c.  f −1(x) = 3x −4

902	
Answers to Odd-Numbered Exercises
	 53.	 a.	 (1, 3, 5, 2)               b.  (1, 4, 3, 2, 5)
	 55.	 Both h + (g + f  ) and (h + g) + f  have domain and codomain A. For x [ A, (h + (g + f ))(x) =
h((g + f )(x)) = h(g( f (x))) = (h + g)( f (x)) = ((h + g) + f  )(x).
	 57.	 a.	 (1, 2, 5, 3, 4)
	b.	(1, 7, 8) + (2, 4, 6)
	 c.	(1, 5, 2, 4) + (3, 6)
	d.	(2, 3) + (4, 8) + (5, 7)
	 59.	 a.	(a, d, e, b)          b.  (d, e)          c.  (a, d) + (c, e)
	 61.	 f −1 = (2, 4, 3, 8)
	 63.	 a.	 34        b.  36	
	 65.	 a.	For 0S0 = 2, 2!∙0! = 2 and 22 −C(2, 1)(1)2 = 4 −2 = 2. For 0S0 = 3, 3!∙0! = 6 and 
33 −C(3,1)(2)3 + C(3, 2)(1)3 = 27 −3 # 8 + 3 = 6. For 0S0 = 4, 4!∙0! = 24 and  
44 −C(4, 1)(3)4 + C(4, 2)(2)4 −C(4, 3)(1)4 = 256 −4 # 81 + 6 # 16 −4 = 24.
	b.	Assume f is onto. If two distinct elements of S map to one element of S, then n −2 elements are left to 
map onto n −1 elements, which cannot be done. Therefore f is one-to-one. Now assume f is one-to-
one. Then the n elements of S map to n distinct elements of S; thus every element of S is in the range of 
f, and f is onto.
	 c.	For example, S = N,  f: N S N given by f (x) = 2x.
	d.	For example, S = N, f: N S  N given by f (0) = 0, f (x) = x −1 for x ≥1.
	 67.	 a.	nn
	b.	n!
	 c.	n!
	d.	n!
	
e.	 n! c 1
2! −1
3! + c+ (−1)n 1
n! d
	
	 f.	 The number of derangements (answer d) is < n! c 1
2! d = n! # 1
2 < n! and n! < nn. The total number 
of ­functions, with no restrictions, is the maximum. Only some of these functions are one-to-one and  
onto, but this is the definition of a permutation as well. Not all permutations are derangements, so the 
number of derangements is smaller still.
	 69.	 1854
	 71.	 a.	For x [ S, f (x) = f (x), so x r x and r is reflexive. For x, y [ S, if x r y then f (x) = f (y) and f (y) = f (x), 
so y r x and r is symmetric. For x, y, z [ S, if x r y and y r z, then f (x) = f (y) and f (y) = f (z), so 
f (x) = f (z) and x r z, so r is transitive.
	b.	If f is a one-to-one function, then no two elements of S map to the same value, so the equivalence 
classes each consist of a single element.
	 c.	 344 = 54, −46 because f (4) = f (−4).
	 73.	 a.	 5m, n, o, p6          b.  5n, o, p6; 5o6	
	 75.	 Reflexive: S r S by the identify function. Symmetric: If S r T and f is a bijection from S to T, then 
f −1: T S  S and f −1 is a bijection, so T r S. Transitive: If S r T and T r U, f: S S  T, g: T S  U, f and g 
bijections, then g + f : S S  U and g + f  is a bijection, so S r U.
	 77.	 a.	(define (square x)        b.  18
	
	 	
(* xx))
Exercises 5.5
	
1.	 For example, n0 = 1, c1 = 1∙34, c2 = 1. For x ≥1, (1∙34)(17x + 1) ≤x ≤1(17x + 1)
	
3.	 For example, n0 = 2, c1 = 1, c2 = 2. For x ≥2, 1(15x2 + x) ≤29x2 −4x −15 ≤2(15x2 +  x)
	
5.	 For example, n0 = 1, c1 = 1, c2 = 2. For x ≥1, 1(x3) ≤x3 + log x ≤2x3.

Answers to Odd-Numbered Exercises	
903
	
7.	 Yes. For ­example, in Exercise 1, we could use the constants n0 = 1, c1 = 1∙34, c2 = 1∙10. Then the 
­envelope would be entirely below g(x), but it still follows the general “shape” of g(x).
	
9.	 2	
11.	 lim
xS∞
x
17x + 1 = lim
xS∞
1
17 = 1
17  
	 13.	 lim
xS∞
x
x2 = lim
xS∞
1
2x = 0	
15.	 lim
xS∞
log x
x
= lim
xS∞
1
xlog e
1
= 0
	 17.	 3200 log x4 = 341 ln x24 < 3"
4 x4 < 3420 x4 < 317 x log x4 < 310x2 −3x + 54 < 32x x24
	 19.	 Knowing that the algorithm is O(n3) tells you only that the growth rate is less than or equal to n3; it could 
be n3, n2, n log n, n, etc. Knowing that it is o(n3) tell you that the growth rate is less than n3, but again it 
could be n2, n log n, etc. The most useful information is that the growth rate is Θ(n2), essentially growing 
at a constant times a parabolic 
	 21.	S(n) = Θ(n2)  	
23. S(n) = Θ(n log n) 
	 25.	S(n) = Θ(nlog33) = Θ(n)
	 27.	a.	C′(n) = Θ(n log n).
	b.	The exact solution for C(n) is C(n) = n(log n) − n + 1, which is also Θ(n log n). 
Exercises 5.6
	
1.	 25 mod 6 = 1, 11 mod 6 = 5, 14 mod 6 = 2, and (5 + 2) mod 6 = 1
	
3.	 262 mod 13 = 2, 74 mod 13 = 9,188 mod 13 = 6, and (9 + 6) mod 13 = 2
	
5.	 486 mod 5 = 1, 18 mod 5 = 3, 27 mod 5 = 2, and (3 # 2) mod 5 = 1
	
7.	 Let x = q1n + r1, 0 ≤r1 < n and y = q2n + r2, 0 ≤r2 < n, so x mod n = r1 and y mod n = r2. Then 
x # y = (q1q2n + q2r1 + q1r2)n + (r1 # r2),0 ≤r1 # r2 < n2. Let r1 # r2 = kn + r with 0 ≤r < n. Then 
x # y = (q1q2n + q2r1 + q1r2 + k)n + r with 0 ≤r < n, so (x # y) mod n = r. Also x mod n # y mod 
n = r1 # r2 = kn + r with 0 ≤r < n, so (x mod n # y mod n) mod n = r.
	
9.	 Answer c is correct.
	 11.	
0
33
1
1
2
13
3
12
4
34
5
38
6
27
7
22
8
9
10
	
13.  a.  The values are stored in ­locations 
6, 14, 1, 7, 8, 2, 16, 9, 0. 
0
50
1
52
2
18
3
4
5
6
23 
7
40
8
24
9
58
10
11
12
13
14
14
15
16
33
	
b.	58 hashes to location 7, 
which contains another ele-
ment (40), so, following the 
collision resolution scheme 
under which 58 would have 
been stored, search the next 
table position, 8, which 
contains 24, then search the 
next table position, 9, which 
contains 58. 41 also hashes 
to location 7 in the table; pro-
ceeding as before, locations 
8 and 9 are also checked, and 
do not contain 41. The next 
location to check is 10, which 
is empty. Therefore 41 is not 
in the ­table.

904	
Answers to Odd-Numbered Exercises
	 15.	 a.	1∙t          	 b.  2∙t            c.  3∙t
	 17.	 a.	ALLS WELL THAT ENDS WELL
	b.	TWAS BRILLIG AND THE SLITHY TOVES DID GYRE AND GIMBLE IN THE WABE
	 c.	COL MUSTARD WITH THE KNIFE IN THE LIBRARY
	 19.	 k = 9, SLEEP NOW WE MARCH ON ROME TOMORROW
	 21.	 a.	x = 10011 (5-bit string), p = x mod 24 = 00011, q = p # 2 = 00110, s = x ! p = 10000, 
t = s # 2−4 = 00001, y = q + t = 00111
	b.	x = 0011 
(4-bit 
string), 
p = x 
mod 
23 = 0011, q = p # 2 = 0110, s = x ! p = 0000, 
t = s # 2−4 = 0000, y = q + t = 0110
	 23.	 1010001111101010
	 25.	 a.	 d = 3
	b.	83 mod 15 = 82 # 8 mod 15 = 64 # 8 mod 15 = 4 # 8 mod 15 = 32 mod 15 = 2
	 c.	23 mod 15 = 8 
	 27.	 a.	 d = 23              b.  127 mod 55 = 23              c.  2323 mod 55 = 12
	 29.	 a.	 n(n −1)∙2            b.  n 
	 31.	 a.	X                    b.  7
	 33.	 check digit = 8
	 35.	 a.	 temp = number
	
ones = temp mod 10
	
temp = (temp −one)∙10
	
tens = temp mod 10
	
temp = (temp −tens)∙10
	
hundreds = temp mod 10
	
temp = (temp −hundreds)∙10
	
thousands = temp
	
b.	temp = 7426
	
ones = 6
	
temp = 742
	
tens = 2
	
temp = 74
	
hundreds = 4
	
temp = 7
	
thousands = 7
	 37.	 If x ≡y (mod n) then x −y = kn where k is an integer. Therefore xc −yc = kcn where kc is an integer, 
so xc ≡yc (mod n).
	 39.	 a.	f (ka) = (ka) mod p maps each element of S to a unique value in T. To show that f is one-to-one, sup-
pose f (k1a) = f (k2a) for some k1 and k2, 0 ≤k1, k2 ≤p −1. Then k1a mod p = k2a mod p. By Prac-
tice 43b, k1a ≡k2a (mod p). Because p is a prime number and a is not divisible by p, gcd (a, p) = 1, 
so by Exercise 38 (cancellation under congruence modulo n), k1 ≡k2 (mod p), or k1 −k2 = mp for 
some integer m. But −p < k1 −k2 < p so m = 0 and k1 = k2, so k1a = k2a and f is one-to-one.
	b.	 0S0 = 0T0 = p and f is a one-to-one function. Therefore each of the p distinct elements of S map to dis-
tinct elements of T, making each of the p elements of T the image of an element of S.
	 c.	 3a # 2a c (p −1)a4mod p =  3(a mod p) # (2a mod p) c ((p −1)a)mod p4 mod p by ­Equation 
(1) of this section. Because f is an onto function, the set T is the set of all residues ­modulo p of 
the elements of S. Because 0 mod p = 0, the set 51, 2, c , (p −1)6 is the set of all ­residues 
modulo p of the elements 
5a, 2a, c , (p −1)a6. Therefore 
3(a mod p) # (2a mod p) c 
((p −1)a) mod p4 mod p =  31 # 2 c (p −1)4 mod p =  (p −1)! mod p.
	d.	From part (c), 3ap−1(p −1)!4 mod p = (p −1)! mod p or, by Practice 43b, ap−1(p −1)! ≡
(p −1)! (mod p). Because p is a prime, gcd((p −1)!, p) = 1, so by Exercise 38 (cancellation under 
congruence modulo n), ap−1 ≡1 (mod p).
	 e.	 51, 2, 3, 4, 5, 66
	 f.	46 mod 7 = (43 #  43)mod 7 = 64 #  64 mod 7 = 1 #  1 mod 7 = 1
	 41.	 a.	d #  e ≡1 mod w(n) means d #  e ≡1 mod (p −1)(q −1), so that d #  e = 1 + k(p −1)(q −1) for 
some integer k. Then Ted = T1 + k(p−1)(q−1) = T(T k(p−1)(q−1)) = T(T p−1)k(q−1) or T(T q−1)k( p−1).

Answers to Odd-Numbered Exercises	
905
	b.	If T is not divisible by p, then Tp−1 ≡1 (mod p) by Fermat’s little theorem (Exercise 39). 
Ted mod p = T(Tp−1)k(q−1) mod p = 3T(T p−1)(T p−1) c (T p−1)4 mod p = 3(T mod p) # 1 # 1 c 14 mod p 
by Equation (1) and Practice 43b = T mod p so that Ted ≡T (mod p) by Practice 43b. Similarly if T 
is not divisible by q, then Tq−1 ≡1(mod q). Ted mod q = T(T q−1)k(p−1) mod q and T ed ≡T(mod q).
	 c.	If p0T then T = kp for some integer k and T ed −T = (kp)ed −kp = p(ped−1ked −k) where 
ped−1ked −k is an integer, so Ted ≡T (mod p). If p0T and q0T, then T is a multiple of p and T is a 
multiple of q. Because p and q are primes, T = cpq for some integer c, which is a contradiction because 
T < pq = n.
	d.	The proof is very similar to part c.
	 e.	Ted ≡T (mod p),Ted ≡T (mod q) and p and q are relatively prime. This matches the pattern of the Chi-
nese remainder theorem where a1 = a2 = T and x = Ted. But also, T ≡T (mod p) and T ≡T(mod q). 
By the Chinese remainder theorem, Ted ≡T (mod pq), or Ted ≡T (mod n). By Practice 43b, 
Ted mod n = T mod n = T because T < n.
Exercises 5.7
	
1.	 2, −4
	
3.	 x = 1, y = 3, z = −2, w = 4
	
5.	 a.	 £
6
−5
0
3
5
3
§
	b.	 £
−2
7
−2
−3
1
5
§ 	
	 c.	 £
12
3
6
18
−3
15
3
9
6
§
	d.	 c −4
−8
−12
2d
	 e.	 £
14
−17
2
9
9
1
§
	
	
7.	 a.	 £
10
7
−2
−4
30
8
§
	b.	not possible
	 c.	 £
21
−23
33
−44
11
1
§
	d.	 c28
4
6
25d
	
9.	 a.	A # B = c10
4
18
−3d  B # A = c14
1
4
−7d
	b.	A(B # C) = (A # B)C = c 68
−58
102
−84d
	 c.	A(B + C) = A # B + A # C = c26
−9
40
−23d
	d.	(A + B)C = A # C + B # C = c42
−35
32
−28d

906	
Answers to Odd-Numbered Exercises
	 11.	 Both A # (B # C) and (A # B) # C can be computed and will result in an n  ×  m matrix. The i, j element of 
A # (B # C) looks like
∙
p
s=1
ais(B # C)sj = ∙
p
s=1
aisa ∙
r
k=1
bskckjb = ai1(b11c1j + b12c2j + c+ b1rcrj) + c+
aip(bp1c1j + bp2c2j + c+ bprcrj) = (ai1b11 + ai2b21 + c+ aipbp1)c1j + c+
(ai1b1r + ai2b2r + c+ aipbpr)crj = ∙
r
k=1
a ∙
p
s=1
aisbskbckj = ∙
r
k=1
(A # B)ikckj
	
	 which is the i, j element of (A # B) # C.
	 13.	 a.	Assume that row i of A is all 0s. Then for any j, the element in row i, column j of A # B is given by 
∙
n
k=1
aikbkj. This sum is 0 because aik = 0 for all values of k.
	
	 b.	Assume that column j of B is all 0s. Then for any i, the element in row i, column j of A # B is given by
∙
n
k=1
aikbkj. This sum is 0 because bkj = 0 for all values of k.
	 15.	 a.	AT = £
1
6
3
−2
4
1
§
	b.	If A is symmetric then aij = aji and AT(i, j) = A(j, i) = A(i, j). Therefore AT = A. If AT = A, then 
A(i, j) = AT(i, j) = A(j, i) and A is symmetric.
	 c.	(AT)T = A follows from the definition - two interchanges of row and column gets back to the original.
	d.	Let A + B = C. Then CT(i, j) = C(j, i) = A(j, i) + B(j, i) = AT(i, j) + BT(i, j) and CT = AT + BT.
	 e.	Let A be an n × m matrix and B be an m × p matrix; then AT is m × n and BT is p × m. Let A # B = C. 
Then 
CT(i, j) = C(j, i) = ∙
m
k=1
ajkbki = ∙
m
k=1
AT (k, j)BT(i, k) = ∙
m
k=1
BT (i, k)AT (k, j) = (BT # AT)(i, j)  and 
CT = BT # AT.
	 17.	 For example, c
1
1
−1
−1d c
1
1
−1
−1d = c0
0
0
0d
	 19.	 This is not always true (for example, use the A and B of Practice 52). It is true if A = B = I, for example.
	 21.	 The i, j entry of A2 is ∙
n
k=1
aikakj.The j,i entry of A2 is ∙
n
k=1
ajkaki. But these are the same because aik = aki and 
akj = ajk (A is symmetric).
	 23.	 For n = 1, A = c1
1
1
0d = cF(2)
F(1)
F(1)
F(0)d . Assume that Ak = cF(k + 1)
F(k)
F(k)
F(k −1)d . Then 
Ak+1 = Ak # A = cF(k + 1)
F(k)
F(k)
F(k −1)d c1
1
1
0d = cF(k + 1) + F(k)
F(k + 1)
F(k) + F(k −1)
F(k)d =
	
cF(k + 2)
F(k + 1)
F(k + 1)
F(k)d .
	 25.	 (rA)(1∙r)A−1 = r(1∙r)(A # A−1) = 1I = I and (1∙r)A−1(rA) = (1∙r)(r)(A−1 # A) = 1I = I.
	 27.	 x = 6, y = −1
	 29.	 x = 11, y = 6, z = −2
	 31.	 x = 9∙14, y = 2∙7, z = 31∙14

Answers to Odd-Numbered Exercises	
907
	 33.	 x = 5, y = −3, z = 4, w = 2.
	 35.	 For example,
x + 2y = 3
4x + y = 19
3x −y = 16
	
	 The augmented matrix is £
1
2
3
4
1
19
3
−1
16
§ . The following elementary row operations 
       
£
1
2
3
4
1
19
3
−1
16
§
	
	 result in
	
£
1
2
3
0
−7
7
0
−7
7
§
	
	 Because row 2 of the augmented matrix is the sum of rows 1 and 3, the new rows 2 and 3 represent the 
same equation, so this actually is a system of 2 equations in 2 unknowns. Solving −7y = 7 gives y = −1, 
and solving x + 2y = 3 or x + 2(−1) = 3 gives x = 5.
	 37.	 Let g =  the amount of gold in cubic centimeters, and c =  the amount of copper in cubic centimeters. 
Then c + g = 52 and 9c + 19.3g = 859.4. The solution is g = 38 cc, c = 14 cc.
	
	 The percentage of copper by volume is 14∙52 = 26.9%.
	 39.	 A−1 = c−1∙2
3∙4
1∙2
−1∙4d
	 41.	 A−1 = c−14∙10
1∙10
24∙10
−1∙10d   A−1 # B =  c20
50d = cx
yd
	
	 	so x = 20, y = 50.	
	 43.	 x = 6,  y = −1
	 45.	 x = 11,  y = 6,  z = −2
	 47.	 A ` B = £
1
0
0
0
1
0
0
1
1
§  A ~ B = £
1
0
1
1
1
1
1
1
1
§ 	
A × B = £
1
0
1
1
1
1
1
1
1
§  B × A = £
1
1
1
1
1
1
1
1
1
§
	 49.	 A ` B = £
0
1
0
0
0
1
0
0
0
§  A ~ B = £
0
1
1
1
0
1
1
0
1
§ 	
A × B = £
0
0
1
1
1
1
1
0
0
§  B × A = £
1
0
1
0
0
1
0
1
0
§
	 51.	 In order for A ~ B = A ` B, it must be the case that aij ~ bij = aij ` bij for all i, j. This is true if 
aij = bij = 1 or aij = bij = 0, therefore when A = B.
	 53.	 2
n(n+1)
2
	 55.	 a.	The rows in the augmented matrix as it is being transformed are of length n + 1, n, n −1, …3. (The 
augmented matrix is size n × (n + 1) and the next to last row is the last for which such a multiplication 
is required in order to zero out position n,n −1 in the last row.) Each non-zero element in each row 
must be multiplied by the scalar value, requiring a total of (n + 1) + n + (n −1) + c+ 3 which is 
(n + 1) + n + (n −1) + c+ 3 + 2 + 1 −(2 + 1) multiplications, which is (n + 1)(n + 2)
2
−3.
−3
−4

908	
Answers to Odd-Numbered Exercises
	b.	To zero out the first column, a multiple of the first row (length n + 1) must be added to each row below 
it, requiring (n + 1) multiplications and (n + 1) additions for n −1 rows. To zero out the second col-
umn, a multiple of the second row (length n) must be added to each row below it, requiring n multiplica-
tions and n additions for n −2 rows. The last transformation requires a multiple of the next to last row 
(length 3) to be added to the 1 row below it, requiring 3 multiplications and 3 additions for 1 row. The 
totals are (n + 1)(n −1) + (n)(n −2) + c+ (3)(1) for both multiplications and additions, and this 
expression (from Exercise 11 in Section 2.2) equals (n −1)(n)(2(n −1) + 7)
6
= 2n3 + 3n2 −5n
6
	
c.	 To solve the equations from bottom to top requires
	
Row n: cnnxn = dn	
1 multiplication
	
Row n −1: c(n−1)(n−1)xn−1 + c(n−1)nxn = dn−1	 1 multiplication, 1 addition, 1 multiplication
	
Row n −2:  c(n−2)(n−2)xn−2 + c(n−2)(n−1)xn−1 + c(n−2)nxn = dn−2	
2 multiplications, 2 additions,  
	
	
1 multiplication
	
	
(
	
Row 1: c11x1 + c12x2 + c+ c1nxn = d1	 (n −1) multiplications, (n −1) additions, 1 multiplication
	
	
for a total of 1 + 2 + 3 + c+ n = n(n + 1)
2
 multiplications and 1 + 2 + c+ (n −1) =
(n −1)n
2
 additions.
	
d.	The transformation requires Θ(n2) + 2Θ(n3) operations, and the resulting equation solving requires 
2Θ(n2) operations, so the overall order of magnitude is Θ(n3).
Chapter 6
Exercises 6.1 
	
1.	 g(a) = (1,2), g(b) = (1,3), g(c) = (2,3), g(d) = (2,2)
	
3.	 a. 
	
b.  For example, 
	
c. 
	
	
5.	
	
7.	 a.	For example, 
	
b.	Does not exist; the node of degree 4 would have to have arcs going to 4 distinct other nodes because no 
loops or parallel arcs are allowed, but there are not 4 distinct other nodes.

Answers to Odd-Numbered Exercises	
909
	
c.	
	
d.	Does not exist; in such a graph, the sum of all the degrees would be 11, but the sum of all the degrees 
is the total number of arc ends, which must be twice the number of arcs, i.e., an even number.
	
9.	 a.	Because everyone in a department presumably knows someone in the same department, this would 
mean that no one in the IT department knows anyone in the marketing department (and vice versa).
	b.	Carl and Fletcher are not acquainted. SiuYin is acquainted only with Carl.
	 c.	2
	 11.	 For example: a. star S  idol S  statue S  sculpture
	b.	burden S  load S  weight S  influence
	 c.	piano S  upright S  moral S  significance
	 13.	 (b), because there is no node of degree 0.	
	 15.	 f1: 1 S a, 2 S b, 3 S c, 4 S d, f2: a1 S e2, a2 S e7, a3 S e6, a4 S e1, a5 S e3, a6 S e4, a7 S e5
	 17.	 f: 1 S a, 2 S d, 3 S b, 4 S e, 5 S c
	 19.	 Not isomorphic; graph in (b) has a node of degree 5, graph in (a) does not.
	 21.	a.		There cannot be a bijection between the two node sets if they are not the same size.
	b.	For isomorphic graphs there is a bijection from one arc set to the other, either explicitly or, in the case 
of simple graphs, implicitly by means of the endpoints; this cannot happen if the arc sets are not the 
same size.
	 c.	If the graphs are isomorphic and arcs a1 and a2 in one graph both have endpoints x–y, then their image 
arcs in the second graph must have the same endpoints, which cannot happen if the second graph has 
no parallel arcs.
	d.	If the graphs are isomorphic and an arc in one graph has endpoints x–x, then its image arc in the second 
graph must have endpoints f(x)–f(x), which is not possible if the second graph has no loops.
	 e.	If the graphs are isomorphic and a node of degree k in one graph serves as an endpoint to k arcs, its 
­image in the second graph must serve as an endpoint to the images of those k arcs, which implies it will 
have degree k also.
	 f.	If the graphs are isomorphic and if there is a path n1, a1, n2, a2, ... , nk between two nodes in one graph, 
then f(n1), f(a1), f(n2), f(a2), ... , f(nk) is a path in the second graph. Two nodes in the second graph are 
the images of nodes in the first graph; if the first graph is connected, there is a path between these nodes 
and hence there is a path between the two nodes in the second graph.
	g.	By the answer to part f, in isomorphic graphs paths map to paths, so cycles map to cycles.
	 23.	 4 graphs: 
	
25.  n(n −1)
2
= C(n,2)
	 27.	 If we can draw the graph with arcs that intersect only at nodes, then it is a planar graph. 
	
	
K2,3:	

910	
Answers to Odd-Numbered Exercises
	 29.	 5
	 31.	 The proof for Euler’s formula does not depend on the graph being simple, so the result still holds for non-
simple graphs, but this is not true for inequalities (2) and (3).
	 33.	 Planar 
	 35.	 Nonplanar—subgraph here can be obtained from K3,3 by elementary subdivisions
	
	
	 37.	
E
1
1
0
0
2
1
1
1
1
1
0
1
0
1
0
0
1
1
0
0
2
1
0
0
0
U
	
39. 
G
0
1
1
0
0
0
0
1
0
0
1
0
1
1
1
0
0
0
1
1
1
0
1
0
0
0
1
0
0
0
1
0
0
0
1
0
1
1
1
0
0
1
0
1
1
0
1
1
0
W
	
41. 
≥
0
1
0
0
0
0
1
1
0
0
0
1
0
0
1
0
¥
	 43.	
	
45. 
5
2
4
3
1
	
47. 
4
1
2
3
	 49.	 The graph consists of n disconnected nodes with a loop at each node.
	 51.	 The n × n matrix with 0s down the main diagonal and 1s elsewhere.
	 53.	
1
1
2
3
4
5
2
1
2
2
4
1
1
2
3
2
5
3
5
4
5

Answers to Odd-Numbered Exercises	
911
	 55.	
	
1
2
2
3
4
5
3
1
4
1
5
6
3
7
7
2
6
6
7
6
2
7
3
4
7
2
3
5
6
	 57.	
	
1
2
2
3
4
3
4
4
3
	 59.	 a.	
1
2
2
3
4
5
3
4
5
6
6
	
	 b.	16        c.  36
	 61.	
Node
Pointer
1
5
2
7
3
11
4
0
5
2
6
6
3
0
7
1
8
8
2
9
9
3
10
10
4
0
11
4
0
	
	
63.  1
2
3
4
	
65. 
4
2
3
6
1
5

912	
Answers to Odd-Numbered Exercises
	 67.	 By the definition of isomorphic graphs, nodes x–y are adjacent in G1 if and only if their images are adja-
cent in G2. Therefore nodes are not adjacent in G1 (and therefore are adjacent in G1r) if and only if their 
images are not adjacent in G2 (and therefore are adjacent in G2r). Thus the same function f makes the 
complement graphs isomorphic.
	 69.	 If G is not connected then G consists of two or more connected subgraphs that have no paths between 
them. Let x and y be distinct nodes. If x and y are in different subgraphs, there is no x–y arc in G; hence 
there is an x–y arc in G′, and a path exists from x to y in G′. If x and y are in the same subgraph, then pick 
a node z in a different subgraph. There is an arc x–z in G′ and an arc z–y in G′, hence there is a path from 
x to y in G′.
	 71.	 The matrix for G′ will have 1s where A had 0s and 0s where A had 1s except for diagonal elements, which 
remain 0s.
	 73.	 The maximum number of arcs occurs in a complete graph; the maximum is C(n,2) = n(n −1)2, there-
fore a ≤n(n −1)2 or 2a ≤n2 −n. 
	 75.	 Let G be a simple graph with n nodes, n ≥2, and m arcs, m > C(n −1,2) = (n −1)(n −2)2, 
and suppose that G is not connected. By Exercise 69, G′ is connected. By Exercise 74, the number  
of arcs in G′ is at least n −1. Therefore the number m of arcs in G is (the number of arcs in a com-
plete graph) −(the number of arcs in G′) = n(n −1)2 −(the number of arcs in G′) ≤
n(n −1)2 −(n −1) = (n −1)(n2 −1) = (n −1)(n −2)2 which is a contradiction.
	 77.	 At least three colors are required because of the overlapping boundaries. Once the following assignment 
has been made, the country marked A must be a third color:
yellow
peach
A
	
	 Three colors are sufficient:
yellow
yellow
green
peach
	 79.	a. 
	
b. 
	
c. 
	 81.	 The four-color conjecture is equivalent to the statement that the chromatic number for any simple, con-
nected, planar graph is at most 4.
	 83.	 The proof is by mathematical induction on the number of nodes in the graph. For the basis step of the 
induction process, it is clear that five colors are sufficient if the number of nodes is less than or equal to 
5. Now assume that any simple, connected, planar graph with ≤k nodes can be colored with five colors, 
and consider such a graph with k + 1 nodes. We can assume that k + 1 is at least 6 because 5 or fewer 
nodes are taken care of. By Exercise 82, at least one node n of the graph has degree less than or equal  

Answers to Odd-Numbered Exercises	
913
to 5; temporarily removing n (and its adjoining arcs) from the graph will leave a collection of one or more 
simple, connected, planar subgraphs, each with no more than k nodes (Figures a and b). By the inductive 
hypothesis, each subgraph has a coloring with no more than five colors (use the same palette of five col-
ors for each subgraph). Now look at the original graph again. If n has degree less than 5 or if the 5 nodes 
adjacent to n do not use five different colors, there is a fifth color left to use for n. Thus, we assume that n 
is adjacent to 5 nodes, n1, n2, n3, n4, and n5, arranged clockwise around n and colored, respectively, colors 
1, 2, 3, 4, and 5 (Figure c).
One subgraph
remaining when
n is removed
(a)
n
Two subgraphs
remaining when
n is removed
(b)
(c)
n
n
n1
n2
n3
n4
n5
	
	 Now pick out all the nodes in the graph colored 1 or 3. Suppose there is no path, using just these nodes, 
between n1 and n3. Then, as far as nodes colored 1 and 3 are concerned, there are two separate sections of 
graph, one section containing n1 and one containing n3. In the section containing n1 interchange colors 1 
and 3 on all the nodes. Doing this does not violate the (proper) coloring of the subgraphs, it colors n1 with 
3, and it leaves color 1 for n. Now suppose there is a path between n1 and n3 using only nodes colored 1 
or 3. In this case we pick out all nodes in the original graph colored 2 or 4. Is there a path, using just these 
nodes, between n2 and n4? No, there is not. Because of the arrangement of nodes n1, n2, n3, n4, and n5, 
such a path would have to cross the path connecting n1 and n3. Because the graph is planar, these two paths 
would have to meet at a node, which would then be colored 1 or 3 from the n1–n3 path and 2 or 4 from the 
n2–n4 path, an impossibility. Thus, there is no path using only nodes colored 2 or 4 between n2 and n4, and 
we can rearrange colors as in the previous case. This completes the proof.
	 85.	 four; three
Exercises 6.2
	
1.	a.	 Yes, it is a tree. Put the root at the top.	
b.  Not a tree because there is a cycle.
r
	
c.	 Yes, it is a tree. Put the root at the top 	
d.  Yes, it is a tree. “Shake down” the lower branches. 
and drop down all the branches.
r
	
r

914	
Answers to Odd-Numbered Exercises
	
3.	 a. 
r
	
b. 
	
c. 
	
5.	



y
3
z
4
1
*
*
*
2 x
	
7. 
1
2
3
4
5




	
9.	
Left child
Right child
1
2
3
2
0
4
3
5
6
4
7
0
5
0
0
6
0
0
7
0
0
	
11. 
1
2
4
6
7
5
3
 
	 13.	
Name
Left child
Right child
1
All
0
2
2
Gaul
3
4
3
divided
0
0
4
is
5
6
5
into
0
0
6
three
7
0
7
parts
0
0
	
15. 
1
2
3
4
5
6
	 17.	a.	
Left child
Right sibling
1
2
0
2
5
3
3
8
4
4
9
0
5
0
6
6
0
7
7
0
0
8
0
0
9
0
10
10
0
11
11
0
0
	
b. 
1
2
5
3
6
7
9
10
11
4
8

Answers to Odd-Numbered Exercises	
915
	 19.	 preorder: a b d e h f c g, inorder: d b h e f a g c, postorder: d h e f b g c a
	 21.	 preorder: a b e c f j g d h i, inorder: e b a j f c g h d i, postorder: e b j f g c h i d a
	 23.	 preorder: a b c e f d g h, inorder: e c f b g d h a, postorder: e f c g h d b a
	 25.	 prefix: +∙ 3 4 −2 y, postfix: 3 4 ∙ 2 y −+
	 27.	 infix: ((2 + 3) * (6 * x)) −7, postfix: 2 3 + 6 x * * 7 −
	 29.	 prefix: + * 4 −7 x z, infix: (4 * (7 −x)) + z
	 31.	 10
	 33.	
b
d
e
c
a
	
35. 
d
c
b
a
	 37.	 If the root has no left child and no right child, return 0 as the height, else invoke the algorithm on the left 
child if it exists, invoke the algorithm on the right child if it exists, return the maximum of those two val-
ues plus 1.
	 39.	 Consider a simple graph that is a nonrooted tree. A tree is an acyclic and connected graph, so for any two 
nodes x and y, a path from x to y exists. If the path is not unique, then the two paths diverge at some node 
n1 and converge at some node n2, and there is a cycle from n1 through n2 and back to n1, which is a contra-
diction. Now consider a simple graph that has a unique path between any two nodes. The graph is clearly 
connected. Also, there are no cycles because the presence of a cycle produces a nonunique path between 
two nodes on the cycle. The graph is thus acyclic and connected and is a nonrooted tree.
	 41.	 If G is a nonrooted tree, then G is connected. Suppose we remove an arc a between n1 and n2 and G re-
mains connected. Then there is a path from n1 to n2. Adding a to this path results in a cycle from n1 to n1, 
which contradicts the definition of a tree. On the other hand, suppose G is connected and removing any 
single arc makes G unconnected. If G is not a tree, then it contains a cycle. If a single arc is removed from 
the cycle, the graph is still connected because any path that made use of the removed arc can use the rest 
of the cycle instead. This is a contradiction, so G is a nonrooted tree.
	 43.	 Proof is by induction on d. For d = 0, the only node is the root, and 20 = 1. Assume that there are at most 
2d nodes at depth d, and consider depth d + 1. There are at most two children for each node at depth d, so 
the maximum number of nodes at depth d + 1 is 2 # 2d = 2d+1.
	 45.	 a.	7 nodes	
b.  15 nodes 	
c.  2h+1 −1
	
	
	 47.	 a.	In a full binary tree, all internal nodes have two children, so the total number of “children nodes” is 2x; 
the only “non-child” node is the root, so there is a total of 2x + 1 nodes.
	
b.	From part a, there are 2x + 1 total nodes, x of which are internal, leaving 2x + 1 −x = x + 1 leaves.
	
c.	 Consider a full binary tree with n nodes; let x be the number of internal nodes. From part a, n = 2x + 1. 
Therefore, x = (n −1)∙2. From part b, the number of leaves = x + 1 = (n −1)∙2 + 1 = (n + 1)∙2.
	 49.	 By Exercise 45, a full binary tree of height h −1 has 2h −1 nodes. When n = 2h, this is the begin-
ning of level h. The height h remains the same until n = 2h+1, when it increases by 1. Therefore for 
2h ≤n < 2h+1, the height of the tree remains the same and is given by h = :log n;.

916	
Answers to Odd-Numbered Exercises
	 51.	 2
	 53.	 a.	There is only one binary tree with one node, so B(1) = 1. For a binary tree with n nodes, n > 1, 
the “shape” of the tree is determined by the “shape” of the left and right subtrees; the two subtrees 
have a total of n −1 nodes. Let the left subtree have k nodes; the right subtree then has n −1 −k 
nodes; k can range from 0 to n −1. For each value of k, there are B(k) ways to form the left sub-
tree, then B(n −1 −k) ways to form the right subtree, so by the multiplication principle, there are 
B(k)B(n −1 −k) different trees.
	
b.	B(0) = 1, B(1) = 1, B(n) = ∙
n−1
k=0
B(k)B(n −1 −k), = ∙
n
k=1
B(k −1)B(n −k)
	
	
which is the same as the Catalan sequence, so by Exercise 97 of Section 4.4,
B(n) =
1
n + 1 C(2n, n)
	
c.	 B(3) = 5. The 5 distinct binary trees are
	
	
d.	B(6) = 132
	 55.	
r
r
r
r
	 57.	 a.	
c
a
k
f
p
s
m
	
c
a
k
p
s
f
m
a
c
k
p
s
f
m
a
c
p
s
f
m
k
	
k
a
c
p
s
f
m
a
k
c
f
p
s
m
k
c
p
s
a
m
f

Answers to Odd-Numbered Exercises	
917
	
k
a
c
p
s
f
m
a
k
c
p
s
m
k
a
p
s
m
c
f
f
	
k
c
p
s
f
m
a
k
a
p
s
m
f
c
	
b.	The array, when rearranged into a heap (but not yet sorted) would be 
g
r
w
f
d
v
k
Exercises 6.3
	
1.	
x  L[1]
x  L[2]
x  L
x: L[1]
x: L[3]



x  L[3]

x: L[2]


	
3. 
x: L[2]
x: L[3]
x  L[1]
x  L[7]








L[1]
 x 
L[2]
 x 
L[3]
 x 
L[4]
L[3]
L[2]
x: L[5]
x: L[7]






L[5]
 x 
L[6]
 x 
L[5]
 x 
L[7]
L[6]
x: L[6]
x: L[2]
x: L[4]
L[4]
	
5.	
L[2]  x  L[3]


L[3]  x  L[4]
x: L[3]
x: L[2]
x: L[6]
x: L[4]
L[1]  x  L[2]


x: L[1]


L[4]  x  L[5]
x: L[5]
x  L[1]




L[5]  x  L[6]


x  L[6]
	
7.	 a. 
4
7
2
5
6
9
	
b.	average > 2.83
depth = 6; algorithm is not optimal	
because 6 > 1 + log:6; = 3
depth = 3 = 1 + :log 7;

918	
Answers to Odd-Numbered Exercises
	
9.	 a.	3      b.  For example: g, d, a, k, i, s	
11. 
not
that
the
is
question
be
or
To
	
	
be is not or question that the To
	 13.	 a.	5      b. 16      c. 45
	 15.	 a.	5      b. 2        c. 
1
1:2
4:5
2
3
1, 2:4, 5
1L or 2L
X
4
5
X







4L or 5L
	 17.	 a.	4      b. 2        c. 
1
1:3
1:3
2:3
X
1:2
1L, 2G
or 1G, 2H
2L, 1G
or 2G, 1H
2
2
X
1










3
3
4


	
	 This problem (because we do not have to decide whether the counterfeit coin is heavy or light) can also 
be done with a binary tree of depth 2:
	
	 4
1:3
1:3
3
1:2
2
1






	 19.	
1L
1:3
3:4
2:3
X
1:2
1L, 2G
or 1G, 2H
4L, 3G
or 3H, 4G
3L, 4G
or 3G, 4H
2L, 1G
or 2G, 1H
2H
2L
X
1H












X
1:3
2:3
3L
4H
X
X
4L
3H






	
21.  2 * (1 + :log n;).
	 23.	a.	 log n! = log3(n)(n −1)(n −2)  c  (2)(1)4 = log n + log(n −1) + log(n −2) + c+ log 2 +  
		 	
	
log 1 ≤log n + log n + log n + c+ log n for n ≥1 = n log n
	b.	log n! = log3(n)(n −1)(n −2)  c  (2)(1)4 = log n + log(n −1) + log(n −2) + c+ log 2 +
	
	log 1 ≥log n + log(n −1) + c+ log<n∙2= ≥log<n∙2= + log<n∙2= + c+ log<n∙2= ≥<n∙2=
	
	log<n∙2= ≥an
2blogan
2b = an
2b(log n −log2) = an
2b(log n −1) = an
2blog n −an
2b =
	
	 an
4blog n + an
4blog n −an
2b = an
4blog n + an
4b(log n −2) ≥an
4blog n because 
	
	log n ≥2 for n ≥4

Answers to Odd-Numbered Exercises	
919
	 13.	 a.	
955
1754
416
(82)
171
383
799
212
(327)
74
(389)
97
(664)
509
(349)
446
(423)
	
	 b.	82-01
	
	664-0001
	
	327-001
	
	349-11
	
	423-10
	
	389-0000
	 15.	 a.	85,000 bytes	
b.  34000 bytes
	 17.	 One of several possibilities: s-000, h-001, a-01, t-100, c-101, e-11
	 19.	 a.	One possible Huffman code is
	
	 B-110100	
	
	 C-11101
	
	 G-1101100
	
	 R-110101
	
	 S-1101101
0-01
1-101
2-1001
3-011
4-1111
5-1000
6-010
7-1100
	8-110111
9-11100
	
	 b.	The new file takes about 44 percent of the space of the original file.
 
Exercises 6.4
	
1.	 No, because the code for m, 01, is a prefix of the code for d, 011.
	
3.	 a.	ooue    	
b.  iaou    	 c.  eee
	
5.	 a.	(pw)a  	
b.  paw    	 c.  ((a))
	
7.	 a-0101, b-011, c-10, d-11
	
9.	a.	
45
55
100
20-m 25-d
27
9
28-c
18-z
6-g
3-r
	
b.  c-11, d-01, g-1001, m-00, r-1000, z-101
	 11.	a.	
42
58
100
15-c 27-a
27
31-e
15-t
12-z
	
or	
42
58
100
15-t
27-a
27
31-e
15-c
12-z
	
b.	
a-01	
a-01
	
z-100	
z-100
	
t-101     or  	 t-00
	
e-11	
e-11
	
c-00	
c-101

920	
Answers to Odd-Numbered Exercises
Chapter 7
Exercises 7.1
	
1.	 A = £
1
0
0
1
0
1
0
1
0
§
	
	r = 5(1, 1), (2, 1), (2, 3), (3, 2)6
	
3.	
2
4
5
1
3
	
	r = 5(1, 4), (2, 5), (4, 2), (5, 3), (5, 4)6
	
5.	
4
6
5
1
2
3	
A = F
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
1
0
V	
7.  0
2
4
6
1
3
5
	
9.	 For every pair of nodes a and b, if there is an arc from a to b, then there is also an arc from b to a.
	 11.	The graph can be written as a “star” with node 1 at the center; i.e., 1 is adjacent to every node and every 
node is adjacent to 1, but no other nodes are adjacent. For example, with n = 5:
	 13.	No node has a loop.
	 15.	r c s: £
1
0
1
1
1
1
0
0
1
§    r d s: £
1
0
0
1
0
0
0
0
1
§
	
17. 
1
1
2
2
3
3
	
19.	A2 = £
1
1
2
1
2
3
0
0
1
§   A(2) = £
1
1
1
1
1
1
0
0
1
§ 	
21.  R will have all 1 entries.	

Answers to Odd-Numbered Exercises	
921
	 23.	R = ≥
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
¥ 	
25.  R = £
1
0
0
1
1
1
1
1
1
§ 	
27.  R = E
0
1
1
1
1
0
1
1
1
1
0
0
0
0
0
0
1
1
1
1
0
1
1
1
1
U
	 29.	R = F
0
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
1
0
V	
31.  R = £
1
0
0
1
1
1
1
1
1
§
	 33.	R = E
0
1
1
1
1
0
1
1
1
1
0
0
0
0
0
0
1
1
1
1
0
1
1
1
1
U	
35.  R = F
0
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
1
0
V
	 37.	Transitive closure = 5(1, 2), (1, 3), (2, 2), (2, 3), (3, 2), (3, 3)6
	 39.	a.	Add (2, 1) and (3, 2) to r to get the transitive closure.
	b.	r is its own transitive closure. 
	 c.	Add (1, 1), (2, 1), (2, 2), (3, 3) to r to get the transitive closure.
	d.	r is its own transitive closure.
	 41.	
	 43.	A23i,j4 = ∙
n
k=1
aikakj. If a term such as ai2a2j in this sum is 0, then either ai2 = 0 or a2j = 0 (or both) and 
there is either no path of length 1 from ni to n2 or no path of length 1 from n2 to nj (or both). Thus there 
are no paths of length 2 from ni to nj passing through n2. If ai2a2j ∙0, then ai2 = p and a2j = q, where p 
and q are positive integers. Then there are p paths of length 1 from ni to n2 and q paths of length 1 from 
n2 to nj. By the multiplication principle, there are pq possible paths of length 2 from ni to nj through n2. 
By the addition principle, the sum of all such terms gives all possible paths of length 2 from ni to nj.
	 45.	3; A2 = ≥
0
0
3
0
0
0
0
0
0
0
0
0
0
0
0
0
¥

922	
Answers to Odd-Numbered Exercises
Exercises 7.2
	
1.	 No, four nodes of degree 3
	
3.	 No odd nodes, so yes; such a path can start at any node and will end there. For example, 1-2-6-3-1-4-6-5-1
	
5.	 No, four nodes of odd degree
	
7.	 Two odd nodes, 1 and 3, so yes; such a path must begin at one odd node and end at the other. For example, 
1-4-5-1-2-5-6-2-3-6-7-3
	
9.	 No, six nodes of odd degree
	 11.	No, four nodes of odd degree
	 13.	F
0
1
1
1
1
0
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
0
1
1
1
1
0
V	
15.  G
0
1
0
1
1
0
0
1
0
1
0
1
1
0
0
1
0
0
0
1
1
1
0
0
0
1
0
0
1
1
0
1
0
1
0
0
1
1
0
1
0
1
0
0
1
0
0
1
0
W
	
   total after row 2 is 0	
i = 8
	 17.	A connected directed graph will have an Euler path if and only if (a) All nodes have out-degree equal to in-
degree or (b) One node, np, has out-degree one greater than in-degree and another node, nq, has in-degree 
one greater than out-degree.
	 19.	Every node has equal in-degree and out-degree, so a path exists from an arbitrary node back to that node. 
For example, 2-4-2-3-1-2.
	 21.	No
	 23.	yes; for example, 1-4-2-6-3-5-1
	 25.	yes; for example, 1-2-3-7-6-5-4-1	
	 27.	yes; for example, 6-5-8-7-3-4-1-2-6
	 29.	Any two nodes must be part of the Hamiltonian circuit; therefore there is a path between them, namely, 
that part of the circuit that is between them.
	 31.	a.  (n −1)n	
b.  (n −1)(n −2)n−1	
c.  (n −1)!	
d.  14! seconds or about 24.22 hours.
	 33.	a.  n = 2 or n =  any odd number.	
b.  n > 2
	 35.	Such a graph is a chain, so just pick a node and then walk around the chain back to the starting node.
	 37.	a.	Consider each node of G in turn. At each node add as many new arcs as possible without creating a 
circuit. This process terminates because the complete graph with n nodes would contain a circuit.
	b.	H is not a complete graph or it would contain a Hamiltonian circuit. Therefore there must be two nodes 
p and q that are not adjacent in H, but adding arc p–q would complete a Hamiltonian circuit. Therefore 
there is a Hamiltonian path beginning at node p and ending at node q. 
	 c.	If both these arcs exist in H, then H has a Hamiltonian circuit, as follows: xi, p, x2, x3, … , xi−1, q, 
xn−1, xn−2, … , xi 
	d.	Nodes p and q are not adjacent (otherwise there would be a Hamiltonian circuit), so the only nodes that 
can be adjacent to p or q (with at most one arc) are the n −2 nodes xi, 2 ≤i ≤n −1. From part (c), 
for each such node xi, if p is adjacent to xi then q is not adjacent to xi−1, so the total of the two degrees 
cannot exceed n −2.

Answers to Odd-Numbered Exercises	
923
	 e.	H was constructed from G by adding additional arcs, so for any node its degree in G is ≤its degree in 
H. Using this fact together with the result of part (d), degree(p) + degree(q) < n in graph G. 
	 f.	Nodes p and q are not adjacent, yet degree(p) + degree(q) < n. This contradicts condition (2), so the 
assumption that G does not have a Hamiltonian circuit is wrong.
	
1.	 IN = 526	
1
2
3
4
5
6
7
8
d
3
0
2
∞
∞
∞
1
∞
s
2
−
2
2
2
2
2
2
	
	p = 7, IN = 52, 76
1
2
3
4
5
6
7
8
d
3
0
2
∞
∞
6
1
2
s
2
−
2
2
2
7
2
7
p = 3, IN = 52, 7, 36
1
2
3
4
5
6
7
8
d
3
0
2
3
∞
6
1
2
s
2
−
2
3
2
7
2
7
	
	p = 8, IN = 52, 7, 3, 86	
1
2
3
4
5
6
7
8
d
3
0
2
3
3
6
1
2
s
2
−
2
3
8
7
2
7
	
	p = 5, IN = 52, 7, 3, 8, 56
1
2
3
4
5
6
7
8
d
3
0
2
3
3
6
1
2
s
2
−
2
3
8
7
2
7
	
	path: 2, 7, 8, 5	
distance = 3
Exercises 7.3
	
3.	 IN = 516	
1
2
3
4
5
6
7
8
d
0
3
5
∞
8
1
∞
∞
s
−
1
1
1
1
1
1
1
	
p = 6, IN = 51, 66
1
2
3
4
5
6
7
8
d
0
3
5
∞
7
1
6
∞
s
−
1
1
1
6
1
6
1
p = 2, IN = 51, 6, 26
1
2
3
4
5
6
7
8
d
0
3
5
∞
7
1
4
∞
s
−
1
1
1
6
1
2
1
	
p = 7, IN = 51, 6, 2, 76
1
2
3
4
5
6
7
8
d
0
3
5
∞
7
1
4
5
s
−
1
1
1
6
1
2
7
	
p = 3, IN = 51, 6, 2, 7, 36
1
2
3
4
5
6
7
8
d
0
3
5
6
7
1
4
5
s
−
1
1
3
6
1
2
7
	
p = 8, IN = 51, 6, 2, 7, 3, 86
1
2
3
4
5
6
7
8
d
0
3
5
6
6
1
4
5
s
−
1
1
3
8
1
2
7
	
p = 5, IN = 51, 6, 2, 7, 3, 8, 56
1
2
3
4
5
6
7
8
d
0
3
5
6
6
1
4
5
s
−
1
1
3
8
1
2
7
	
	path: 1, 2, 7, 8, 5	
distance = 6
	
5.	 IN = 5a6	
a
b
c
d
e
f
d
0
1
3
∞
∞
∞
s
−
a
a
a
a
a
	
p = b, IN = 5a, b6
a
b
c
d
e
f
d
0
1
2
∞
∞
2
s
−
a
b
a
a
b

924	
Answers to Odd-Numbered Exercises
	
9.	a.	Change the condition on the while loop to continue until all nodes are in IN. Also, rather than writing 
out a particular shortest path, make d and s output parameters that carry the information about shortest 
paths and their distances.
	b.	No
	
p = c, IN = 5a, b, c6
a
b
c
d
e
f
d
0
1
2
4
6
2
s
−
a
b
c
c
b
	
p = f, IN = 5a, b, c, f 6
a
b
c
d
e
f
d
0
1
2
4
3
2
s
−
a
b
c
f
b
	
p = e, IN = 5a, b, c, f, e6
a
b
c
d
e
f
d
0
1
2
4
3
2
s
−
a
b
c
f
b
	
	path: a, b, f, e    distance = 3
	
7.	 IN = 516
1
2
3
4
5
6
7
d
0
2
∞
∞
3
2
∞
s
−
1
1
1
1
1
1
p = 2, IN = 51, 26
1
2
3
4
5
6
7
d
0
2
3
∞
3
2
∞
s
−
1
2
1
1
1
1
	
p = 6, IN = 51, 2, 66
1
2
3
4
5
6
7
d
0
2
3
∞
3
2
5
s
−
1
2
1
1
1
6
	
p = 3, IN = 51, 2, 6, 36
1
2
3
4
5
6
7
d
0
2
3
4
3
2
5
s
−
1
2
3
1
1
6
	
p = 5, IN = 51, 2, 6, 3, 56 
1
2
3
4
5
6
7
d
0
2
3
4
3
2
5
s
−
1
2
3
1
1
6
	
p = 4, IN = 51, 2, 6, 3, 5, 46
1
2
3
4
5
6
7
d
0
2
3
4
3
2
5
s
−
1
2
3
1
1
6
	
p = 7, IN = 51, 2, 6, 3, 5, 4, 76
1
2
3
4
5
6
7
d
0
2
3
4
3
2
5
s
−
1
2
3
1
1
6
	
	path: 1,6,7    distance = 5
	 11.	
1
2
3
4
5
6
7
8
d
3
0
2
∞
∞
∞
1
∞
s
2
−
2
2
2
2
2
2
	
	 	
	
(1)
1
2
3
4
5
6
7
8
d
3
0
2
3
11
4
1
2
s
2
−
2
3
1
1
2
7
	
	 	
	
(2)
1
2
3
4
5
6
7
8
d
3
0
2
3
3
4
1
2
s
2
−
2
3
8
1
2
7
	
	 	
	
(3)
	
	No further changes in d or s. Agrees with 
­Exercise 1 for 2 to 5

Answers to Odd-Numbered Exercises	
925
	 13.	
1
2
3
4
5
6
7
d
0
2
∞
∞
3
2
∞
s
−
1
1
1
1
1
1
	
	 	
(1)
1
2
3
4
5
6
7
d
0
2
3
∞
3
2
5
s
−
1
2
1
1
1
6
	
	 	
(2)
1
2
3
4
5
6
7
d
0
2
3
4
3
2
5
s
−
1
2
3
1
1
6
	
	 	
	
(3)
	
	 No further changes in d or s.
	
	 Agrees with Exercise 7 for 1 to 7
	 15.	Initial A and after k = x:
x
1
2
3
y
x
0
1
∞
4
∞
1
1
0
3
1
5
2
∞
3
0
2
2
3
4
1
2
0
3
y
∞
5
2
3
0
	
	after k = 1 and k = 2:	
x
1
2
3
y
x
0
1
4
2
6
1
1
0
3
1
5
2
4
3
0
2
2
3
2
1
2
0
3
y
6
5
2
3
0
	
	after k = 3 and k = y:
x
1
2
3
y
x
0
1
4
2
5
1
1
0
3
1
4
2
4
3
0
2
2
3
2
1
2
0
3
y
5
4
2
3
0
	 17.	 IN = 51, 6, 2, 7, 8, 5, 3, 46
2
2
1
1
4
7
8
2
1
1
3
1
1
5
4
5
8
3
6
6
5
	 19.	IN = 51, 4, 7, 3, 6, 5, 2, 86
2
2
1
2
2
2
3
4
4
1
1
1
3
8
7
5
6
3
3
4
	 21.	For example, 
2
2
1
1
4
7
8
2
1
1
3
1
1
5
4
5
8
3
6
6
5
	 23.	For example,
2
2
1
2
2
2
3
4
4
1
1
1
3
8
7
5
6
3
3
4

926	
Answers to Odd-Numbered Exercises
	 29.	Dijkstra’s algorithm is Θ(n2) in the worst case, which is when all nodes are brought into IN. This is the 
situation to find the distance from the start node to any other node. Repeating this process with all n 
nodes, in turn, as the start node would result in an algorithm of order nΘ(n2) = Θ(n3). Floyd’s algorithm 
is clearly Θ(n3) because of the nested for loops. Therefore the algorithms are the same order of magnitude. 
Although Floyd's algorithm has the advantage of simplicity to code, that is more than balanced out by the 
fact that Floyd's algorithm does not give the actual shortest paths.
Exercises 7.4
	
1.	 a b c e f d h g j i
	
3.	 d a b c e f h g j i	
	
5.	 e b a c f d h g j i 
	
7.	 a b c f j g d e h k i	
	
9.	 f c a b d e h k i g j
	 11.	a b c d e g f h j i
	 13.	d a f b c e h g i j
	 15.	e b c f g a d h j i
	 17.	a b c d e f g h i j k
	 19.	f c j a b g d e h i k
	 21.	a b c e g d f h
	 23.	f b	
	 25.	a b c d e g h f
	 27.	f b	
	
29.		
B
A
G
D
C
E
F
	
31.  Begin a dfs at node a: a c f g e b d
b(2)
f(5)
g(4)
d(1)
a(7)
c(6)
e(3)
	 33.	Because of the recursion, a stack would be a good data structure.
	 35.	Suppose the depth-first search has visited node x and has moved on to visit node y. The algorithm looks for 
nodes adjacent to y that are unvisited. If a visited node (other than y's “parent” x) is on y’s adjacency list, 
then the graph contains a cycle. For example, in Figure 7.13, when the recursive algorithm is invoked on 
node g, node d is a previously visited node that is adjacent to g but not the parent node of g (which is f  ). 
This situation detects the cycle d-g-f-d.
	 25.
	
4
5
2
5
3
3
1
4
1
2
	
The shortest path from 1 to 5 is 1–5 with dis-
tance 5. If the algorithm added the node closest 
to IN at each step, it would choose the path 1-2-
3-4-5 with distance 10.
	 27.	
2
4
4
2
2
7
3
3
5
4
5
6
	
The solution is to find a minimal  
spanning tree for the graph, as  
shown here.

Answers to Odd-Numbered Exercises	
927
Exercises 7.5
	
1.	
d
c
a
b
e
	
	 back arcs: a–c, a–e, b–d, c–e
	
3.	
c
a
f
h
e
d
g
b
	
	 back arcs: a–d, a–f
	
5.	
d
a
h
e
g
f
c
b
	
	back arcs: e–h
	
7.	
c(2, 2)
b(3, 3)
a(1, 1)
d(4, 4)
4
f(7, 7)
e(5, 5)
4
g(6, 6)
4
	
	articulation points: c, d
	
	 biconnected components
	
	
c
d
a
c
c
b
d
f
e
g
	
9.	
e(5, 5)
2
d(3, 3)
2
c(2, 2)
a(1, 1)
b(4, 4)
	
	articulation points: c, d
	
	biconnected components
	
	
e
d
c
d
c
a
b
	 11.	
e(5, 5)
1
b(2, 2)
3
1
f(6, 6)
1
g(7, 7)
a(1, 1)
1
h(8, 8)
1
c(3, 3)
1
d(4, 4)
1
	
	articulation points: none
	
	biconnected components
	
	
b
f
a
c
h
g
e
d

928	
Answers to Odd-Numbered Exercises
Chapter 8
Exercises 8.1
	
1.	
+
0
1
a
a′
0
0
1
a
a′
1
1
1
1
1
a
a
1
a
1
 a′
 a′
1
1
a′
#
0
1
a
a′
0
0
0
0
0
1
0
1
a
a′
a
0
a
a
0
 a′
0
 a′
0
a′
	
3.	a.	max(x, y) = max(y, x), min(x, y) = min(y, x), max(max(x, y), z) = max(x, max(y, z)) = max(x, y, z), 
min(min(x, y), z) = min(x, min(y, z)) = min(x, y, z), max(x, min(y, z)) = min(max(x, y), max(x, z)),  
min(x, max(y, z)) = max(min(x, y), min(x, z)). The last two can be shown by taking cases: x < y < z, 
y < x < z, etc.
	
b.	Let m be the 0 element. Then we must have max(x, m) = x for all x [ Z. But for x = m −1,
max(m −1, m) = m.
	
5.	a.	16
	b.	( f1 + f2)(0, 0) = 1	
( f1 # f2)(0, 0) = 1	
f1′(0, 0) = 0
	
	( f1 + f2)(0, 1) = 1	
( f1 # f2)(0, 1) = 0	
f1′(0, 1) = 1
	
	( f1 + f2)(1, 0) = 1 	
( f1 # f2)(1, 0) = 0	
f1′(1, 0) = 0
	
	( f1 + f2)(1, 1) = 0 	
( f1 # f2)(1, 1) = 0	
f1′(1, 1) = 1
	 c.	+ and # are binary operations on B, ′ is a unary operation on B. Max and min are commutative and 
associative operations; the distributive laws follow by considering different cases for the values of 
f1(x, y), f2(x, y), and f3(x, y) for a fixed (x, y) [ S2. For any f in B and (x, y) in S2, ( f + 0)(x, y) = max 
( f (x, y), 0(x, y)) = max( f (x, y), 0) = f (x, y), and ( f # 1)(x, y) = min( f (x, y), 1(x, y)) =
min( f (x, y), 1) = f (x, y). Also ( f + f ′)(x, y) = max( f (x, y), f ′(x, y)) = 1 and ( f # f ′)(x, y) =  
min( f (x, y), f ′(x, y)) = 0 because one value of the pair ( f (x, y), f ′(x, y)) is 1 and the other is 0.
	
7.	 Show that x acts like the complement of x′, that is, that it satisfies properties 5a and 5b with respect to x′.
	
x′ + x = x + x′	
(1a)
	
 = 1
	
(5a)
	
and	
	
x′ # x  = x # x′ 	
(1b)
	
 = 0
	
(5b)
	
Therefore x = (x′)′ by the theorem on the uniqueness of complements.
	
9.	a.	 x + (x # y)
	
	 	 	
	 = x # 1 + x # y	
(4b) 
	
	 	 	
	 = x(1 + y)	
(3b)
	
	 	 	
	 = x(y + 1)	
(1a)
	
	
	 	
	 = x # 1	
(universal bound)
	
	 	 	
	 = x	
(4b)
	
	
	x # (x + y) = x by duality
	
b.	x # 3y + (x # z)4	
	
	
	 	
	 = x # y + x # (x # z)	
(3b)
	
	
	 	
	 = x # y + (x # x) # z	
(2b)
	
	
	 	
	 = x # y + x # z	
(dual of idempotent)
	
	
	 x + 3y # (x + z)4 = (x + y) # (x + z) by duality

Answers to Odd-Numbered Exercises	
929
	
c.	 (x + y) # (x′ + y)
	
	 	 	
	 = (y + x) # (y + x′)	
(1a)
	
	 	 	
	 = y + (x # x′)	
(3a)
	
	 	 	
	 = y + 0 	
(5b)
	
	 	 	
	 = y	
(4a)
	
	
	(x # y) + (x′ # y) = y by duality
	
d.	(x + (y # z))′
	
	
	 	
	 = x′ # (y # z)′
(De Morgan’s laws)
	
	
	 	
	 = x′ # (y′ + z′) 	
(De Morgan’s laws)
	
	
	 	
	 = x′ # y′ + x′ # z′ 	
(3b)
	
	
	(x # (y + z))′ = (x′ + y′) # (x′ + z′) by ­duality
	
e.	 (x + y) # (x + 1)
	
	
	 	
	 = (x + y) # x + (x + y) # 1	
(3b)
	
	
	 	
	 = x # (x + y) + (x + y) # 1	
(1b)
	
	
	 	
	 = (x # x) + (x # y) + (x + y) # 1	
(3b)
	
	
	 	
	 = x + (x # y) + (x + y) # 1	
(dual of ­idempotent)
	
	 	 	
		 = x + (x # y) + (x + y)	
(4b)
	
	 	 	
		 = (x # y) + x + (x + y)	
(1a)
	
	 	 	
		 = (x # y) + (x + x) + y	
(2a)
	
	 	 	
		 = (x # y) + x + y	
(idempotent)
	
	 	 	
		 = x + (x # y) + y	
(1a)
	
	
	(x # y) + (x # 0) = x # (x + y) # y by duality
	 11.	a.	x + (x′ # y + x # y)′	
	
	
	
	 	
	 = x + (y # x′ + y # x)′	
(1b)		
	
	
	
	 	
	 = x + (y # (x′ + x))′	
(3b)	
	
	 	 	
	 = x + (y # (x + x′))′	
(1a)
	
	 	 	
	 = x + (y # 1)′	
(5a)		
	
	
	 	 	
	 = x + y′	
(4b)
	
b.	((x # y) # z) + (y # z)
	
	
	 	
	 = (x # (y # z)) + (y # z)	
(2b)
	
	
	 	
	 = ((y # z) # x) + y # z	
(1b)
	
	
	 	
	 = ((y # z) # x) + (y # z) # 1	
(4b)
	
	
	 	
	 = (y # z) # (x + 1)	
(3b)
	
	 	 	
		 = (y # z) # 1	
(universal bound)
	
	
	 	
	 = y # z	
(4b)
	
c.	 x # y + y # x′	
	
	
	
	 	
	 = y # x + y # x′	
(1b)
	
	
	 	
	 = y # (x + x′)	
(3b)
	
	
	 	
	 = y # 1	
(5a)	
	
	
	 	
	 = y # (x + 1)	
(universal bound)
	
	
	 	
	 = y # x + y # 1	
(3b)	
	
	
	 	
	 = y # x + y 	
(4b)	
	
	
	 	
	 = x # y + y	
(1b)
	
d.	(x + y)′ # z + x′ # z # y
	
	
	 	
	 = x′ # y′ # z + x′ # z # y	
(De Morgan’s laws)
	
	
	 	
	 = x′ # z # y′ + x′ # z # y	
(1b)
	
	
	 	
	 = x′ # z # (y′ + y)	
(3b)
	
	
	 	
	 = x′ # z # (y + y′)	
(1a)
	
	
	 	
	 = x′ # z # 1	
(5a)
	
	
	 	
	 = x′ # z	
(4b)

930	
Answers to Odd-Numbered Exercises
	
e.	 (x # y′) + (y # z′) + (x′ # z) = (x # y′) # 1 + (y # z′) # 1 + (x′ # z) # 1	
(4b)
	
	
	 	
	 = (x # y′) # (z + z′) + (y # z′) # (x + x′) + (x′ # z) # (y + y′)	
(5a)
	
	
	 	
	 = x # y′ # z + x # y′ # z′ + y # z′ # x + y # z′ # x′ + x′ # z # y + x′ # z # y′	
(3b)
	
	
	 	
	 = x # y′ # z + x′ # z # y′ + y # z′ # x + x # y′ # z′ + x′ # z # y + y # z′ # x′	
(1a)
	
	
	 	
	 = y′ # z # x + y′ # z # x′ + x # z′ # y + x # z′ # y′ + x′ # y # z + x′ # y # z′	
(1b) 
	
	
	 	
	 = (y′ # z) # (x + x′) + (x # z′) # (y + y′) + (x′ # y) # (z + z′)	
(3b)
	
	
	 	
	 = (y′ # z) # 1 + (x # z′) # 1 + (x′ # y) # 1	
(5a)
	
	
	 	
	 = (y′ # z) + (x # z′) + (x′ # y)	
(4b)
	
	 	 	
	 = (x′ # y) + (y′ # z) + (x # z′)	
(1a)
	 13.	This is an “if and only if” problem, so there are two things to prove.
	
a.	Let x = 0. Then 
	
	
	 x # y′ + x′ # y = 0 # y′ + x′ # y	
(x = 0)
	
	
	
 = y′ # 0 + x′ # y	
(1b)
	
	
	
 = 0 + x′ # y
	
(dual of universal  
	
	
	 	
bound)
	
	
	
 = x′ # y + 0
	
(1a)
	
	
	
 = x′ # y
	
(4a)
	
	
	
 = 1 # y
	
(Practice 4)
	
	
	
 = y # 1
	
(1b)
	
	
	
 = y
	
(4b)
	
b.	Let x # y′ + x′ # y = y. Then
	
	
	
x # x′ + x′ # x = x	
(letting y in the  
	
	
hypothesis have the 	
	
	
value x)
	
	
	
x # x′ + x # x′ = x	
(1b)
	
	
	
 0 + 0 = x	
(5b)
	
	
	
 0 = x	
(4a)
	 15.	a.	x ! y
	
	
= x # y′ + y # x′	
(definition of !)
	
	
= y # x′ + x # y′	
(1a)
	
	
= y ! x	
(definition of !)
	
b.	x ! x
	
	
= x # x′ + x # x′	
(definition of !)
	
	
= 0 + 0	
(5b)
	
	
= 0	
(4a)
	
c.	 0 ! x
	
	
= 0 # x′ + x # 0′	
(definition of !)
	
	
= x′ # 0 + x # 0′	
(1b)
	
	
= 0 + x # 0′	
(dual of universal 
bound)
	
	
= 0 + x # 1	
(Practice 4)
	
	
= 0 + x	
(4b)
	
	
= x + 0	
(1a)
	
= x	
(4a)
	
d. 1 ! x
	
	
= 1 # x′ + x # 1′	
(definition of !)
	
	
= x′ # 1 + x # 1′	
(1b)
	
	
= x′ + x # 1′	
(4b)
	
	
= x′ + x # 0	
(Practice 4)
	
	
= x′ + 0	
(dual of universal 
bound)
	
	
= x′	
(4a)

Answers to Odd-Numbered Exercises	
931
	 17.	Suppose x + 01 = x for all x [ B. Then 0 + 01 = 0 and 01 + 0 = 01 so 01 = 01 + 0 = 0 + 01 = 0 
and 01 = 0. Then 1 = 0′, so 1 is unique by the theorem on uniqueness of complements.
	 19.	a.	
	
	
b. 
	 	
c. 16
	 21.	a.	(i) bijection (ii) for x, y [ S, f (x # y) = f (x) + f (y)
	b.	Let f (0) = 5, f (1) = 7. Then f (0 # 0) = f (1) = 7 = 5 + 5 = f (0) + f (0), f (0 # 1) = f (0) = 5 =
5 + 7 = f (0) + f (1), f (1 # 0) = f (0) = 5 = 7 + 5 = f (1) + f (0), f (1 # 1) = f (1) = 7 = 7 + 7 =
f (1) + f (1)
	 23.	a.	f: ℝ S  ℝ+. f is onto: given y [ ℝ+, let x = log y; then x [ ℝ and f (x) = 2x = 2log y = y. f is one-to-
one: if f (x) = f (w) then 2x = 2w and (taking the log of both sides) x = w.
	b.	for x, y [ ℝ, g(x + y) = g(x) # g(y)
	 c.	f is a bijection from ℝ to ℝ+ and for x, y [ ℝ, f (x + y) = 2x+y = 2x # 2y = f (x) # f (y)
	d.	 f −1(y) = log y
	 e.	 f −1 is a bijection from ℝ+ to ℝ and for any 
x, y [ R+, f −1(x # y) = log(x # y) = log x + log y = f −1(x) + f −1(y)
	 25.	 f1 S  51, 36, f2 S  51, 26, f3 S  51, 2, 36, f5 S  51, 2, 46, f6 S  51, 3, 46, f7 S  52, 3, 46, f8 S  52, 36, 
f9 S  52, 46, f10 S  51, 46, f11 S  53, 46
	 27.	a.	For any y [ b, y = f (x) for some x [ B. Then y & f (0) = f (x) & f (0) = f (x + 0) = f (x) = y, and 
f (0) = f because the zero element in any Boolean algebra is unique (see Exercise 17).
	
	b.	 f (1) = f (0′) = 3f (0)4′ ′ = f″ = 1−
	 29.	a.	i.If x d y, then x d y and x d x, so x is a lower bound of x and y. If w* d x and w* d y, then w* d x, so 
x is a greatest lower bound and x = x # y. If x = x # y, then x is a greatest lower bound of x and y, so x d y. 
ii. Similar to i. 
	
	b.	 i. Let x + y = z. Then z is a least upper bound of x and y, which is a least upper bound of y and x, so 
z = y + x. ii. Similar to i. iii. Let (x + y) + z = p and x + (y + z) = q. Then y d x + y d p and 
z d p so p is an upper bound for y and z; because y + z is the least upper bound for y and z, y + z d p. 
Also x d x + y d p. Therefore p is an upper bound for x and y + z, and q d p because q is the least 
upper bound for x and y + z. Similarly p d q, so p = q. iv. Similiar to iii.
	 c.	x + 0 = x   4   0 d x, which is true because 0 is a least element. x # 1 = x   4   x d 1, which is true 
because 1 is a greatest element.
	d.	(a) no—no least element, (b) yes, (c) yes, (d) no—not distributive: 2 + (3 # 4) = 2 + 1 = 2 and 
(2 + 3) # (2 + 4) = 5 # 5 = 5. Also, both 3 and 4 are complements of 2, so complements are not 
unique.
Exercises 8.2
	
1.	
x1
x2
x3
(x′ 
 
 1 + x2) x3
1
1
1
1
1
1
0
0
1
0
1
0
1
0
0
0
0
1
1
1
0
1
0
0
0
0
1
1
0
0
0
0
x  x2
1
(x  x2)x3
1
x1
x1
x2
x3

932	
Answers to Odd-Numbered Exercises
	
3.	
x1
x2
x′ 
 
 1x2 + (x1 x2)′
1
1
0
1
0
1
0
1
1
0
0
1
	
5.	 x1x2 + x′ 
 
 2 
x1
x2
f(x1, x2)
1
1
1
1
0
1
0
1
0
0
0
1
(x x2)  (x1 x2)
1
(x1 x2)
x x2
1
x1
x2
x1
x2
	
7.	 (x1x2)′(x2 + x′ 
 
 3) 
x1
x2
x3
f(x1, x2, x3)
1
1
1
0
1
1
0
0
1
0
1
0
1
0
0
1
0
1
1
1
0
1
0
1
0
0
1
0
0
0
0
1
	
9.	 a.	
b.	
x
y
f(x, y)
1
1
0
1
0
1
0
1
1
0
0
0
xy  yx
x
y
xy
yx
x
y
	 c.	The truth function for the network is the same as part (a). The network illustrates “x OR y” and “NOT 
both x AND y”
	 11.	 x′ 
 
 1x′ 
 
 2
	 13.	x1x2x3 + x′ 
 
 1x2x3
	 15.	x1x′ 
 
 2x3 + x1x′ 
 
 2x′ 
 
 3 + x′ 
 
 1x2x′ 
 
 3
	 17.	 x1x2x3x4 + x1x2x′ 
 
 3x4 + x1x′ 
 
 2x3x4 + x1x′ 
 
 2x′ 
 
 3x4 + x′ 
 
 1x′ 
 
 2x3x4 + x′ 
 
 1x′ 
 
 2x3x′ 
 
 4
	 19.	x1x′ 
 
 2x3x′ 
 
 4 + x′ 
 
 1x2x3x4 + x′ 
 
 1x2x′ 
 
 3x4 + x′ 
 
 1x′ 
 
 2x3x4 + x′ 
 
 1x′ 
 
 2x3x′ 
 
 4 + x′ 
 
 1x′ 
 
 2x′ 
 
 3x4
	 21.	a.	 x1x2x′ 
 
 3 + x1x′ 
 
 2x′ 
 
 3
	
b.	
x1 x2 x  x1 x x
3
2
3
x2
x1
x3
x2
x1
x3
x1
x3
x1 x3
	 c.	x1x2x′ 
 
 3 + x1x′ 
 
 2x′ 
 
 3 = x1x′ 
 
 3x2 + x1x′ 
 
 3x′ 
 
 2 = x1x′ 
 
 3(x2 + x′ 
 
 2) = x1x′ 
 
 3 # 1 = x1x′ 
 
 3

Answers to Odd-Numbered Exercises	
933
	
c.	 x1x3 + x′ 
 
 1x2 = (x1x3 + x′ 
 
 1)(x1x3 + x2) = (x′ 
 
 1 + x1x3)(x2 + x1x3) =
(x′ 
 
 1 + x1)(x′ 
 
 1 + x3)(x2 + x1)(x2 + x3) = (x1 + x′ 
 
 1)(x′ 
 
 1 + x3)(x1 + x2)(x2 + x3) =
(x′ 
 
 1 + x3)(x1 + x2)(x2 + x3) = (x1 + x2)(x′ 
 
 1 + x3)(x2 + x3)
	 25.	a.	(x′ 
 
 1 + x′ 
 
 2)(x′ 
 
 1 + x2)(x1 + x′ 
 
 2)
	
b.	(x′ 
 
 1 + x2)(x1 + x2)
	
c.	 (x′ 
 
 1 + x′ 
 
 2 + x3)(x′ 
 
 1 + x2 + x′ 
 
 3)(x′ 
 
 1 + x2 + x3)(x1 + x′ 
 
 2 + x3)(x1 + x2 + x′ 
 
 3)(x1 + x2 + x3)
	
d.	(x′ 
 
 1 + x′ 
 
 2 + x′ 
 
 3)(x′ 
 
 1 + x2 + x3)(x1 + x′ 
 
 2 + x3)(x1 + x2 + x′ 
 
 3)
	
e.	 (x′ 
 
 1 + x′ 
 
 2 + x′ 
 
 3)(x′ 
 
 1 + x′ 
 
 2 + x3)(x1 + x′ 
 
 2 + x′ 
 
 3)(x1 + x2 + x′ 
 
 3)(x1 + x2 + x3) 
	 27.	a.	
1100	
b.	
1001	
c.	
001
	
0100	
0111	
111
	
(1)0000	
(1)0000	
(1)000
	 29.	a.	
	 23.	a.	
	
b.	 x1x2x3 + x1x′ 
 
 2x3 + x′ 
 
 1x2x3 + x′ 
 
 1x2x′ 
 
 3
x1
x2
x3
f(x1, x2, x3)
1
1
1
1
1
1
0
0
1
0
1
1
1
0
0
0
0
1
1
1
0
1
0
1
0
0
1
0
0
0
0
0
x1
x3
x x1
3
x x1
2
x2
x3
x2
x  x x1  x x1
3
2
3
	
b.	x′ 
 
 3x1 + x′ 
 
 2x1 + x′ 
 
 3 = x1x′ 
 
 3 + x1x′ 
 
 2 + x′ 
 
 3 = x1(x′ 
 
 3 + x′ 
 
 2) + x′ 
 
 3 = (x3x2)′x1 + x′ 
 
 3 = (((x3x2)′x1)′)x3)′
(x3 x2)
x1
x2
x3
((x3 x2) x1)
(((x3 x2) x1)x3)
	
	
or, alternatively, x′ 
 
 3x1 + x′ 
 
 2x1 + x′ 
 
 3 = x′ 
 
 3x1 + x′ 
 
 3 + x′ 
 
 2x1 = x′ 
 
 3x1 + x′ 
 
 3 # 1 + x′ 
 
 2x1 = x′ 
 
 3(x1 + 1) +
x′ 
 
 2x1 = x′ 
 
 3 # 1 + x′ 
 
 2x1 = x′ 
 
 3 + x′ 
 
 2x1 = (x3(x′ 
 
 2x1)′)′
x2
x1
x3
(x x1)
2
(x3(x x1))
2
x2
	 31.	a.	x1
1
1
1
(x1  x1) x x  x

934	
Answers to Odd-Numbered Exercises
	 35.	x1 = neutral, x2 = park, x3 = seat belt
X1
X2
X3
f(x1, x2, x3)
1
1
1
–
1
1
0
–
1
0
1
1
1
0
0
0
0
1
1
1
0
1
0
0
0
0
1
0
0
0
0
0
	
	
	 37.	a.	 Let the two input lines be x0 and x1, and the selector line be s. The truth function is
X0
X1
s
f(x0, x1, s)
1
1
1
1
1
1
0
1
1
0
1
0
1
0
0
1
0
1
1
1
0
1
0
0
0
0
1
0
0
0
0
0
	
b.	x0
x1
s
	 39.	x1 = pressure (1 when pressure > 50 psi, otherwise 0)
x2 = salinity (1 when salinity > 45 g∙L, otherwise 0)
x3 = temperature (1 when temperature > 53°C, otherwise 0)
x4 = acidity (1 when acidity < 7.0 pH, otherwise 0)
	
b.	
1 2
1
2
(x1  x2) x x
(xx) x1  x2
x1
x2
	
c.	
1
2
(x  x) x1x2
1
x
x1
x2
2
x
	 33.	
X1
X2
f(x1, x2)
1
1
0
1
0
1
0
1
0
0
0
0
	
x1x′ 
 
 2	
x1 x2
x1
x2
(x1 + x2)x3
(x1  x2)x3
x1
x2
x3

Answers to Odd-Numbered Exercises	
935
	
	 The output for each valve should be 1 when the valve is to open, 0 otherwise. The canonical sum-of-
products forms are
A = x1x2x3x4 + x1x2x3x′ 
 
 4 + x1x2x′ 
 
 3x4 + x1x2x′ 
 
 3x′ 
 
 4
B = x1x′ 
 
 2x3x4 + x′ 
 
 1x2x3x4 + x′ 
 
 1x′ 
 
 2x3x4
	
	 Using these forms, the circuit for A would require 2 inverters (one for x3 and one for x4, assuming we 
split the output from an inverter into more than one gate), 4 AND gates, and 1 OR gate; B would require 
2 inverters, 3 AND gates, and 1 OR gate. It is possible to write simpler equivalent expressions.
Exercises 8.3
	
1.	 x′ 
 
 1x3 + x1x′ 
 
 3 + x′ 
 
 1x2 or x′ 
 
 1x3 + x1x′ 
 
 3 + x2x′ 
 
 3
	
3.	 x3 + x2
	
5.	 x1x′ 
 
 3x′ 
 
 4 + x′ 
 
 1x3x′ 
 
 4 + x′ 
 
 2x′ 
 
 4 + x1x′ 
 
 2
	
7.	 x1x′ 
 
 2x4 + x′ 
 
 1x3x′ 
 
 4 + x′ 
 
 2x3x′ 
 
 4 or x1x′ 
 
 2x4 + x′ 
 
 1x3x′ 
 
 4 + x1x′ 
 
 2x3
	
9.	 x1x2 + x2x3
	 11.	 x1x4 + x′ 
 
 1x2′x3
	 13.	a.	x′ 
 
 1x4 + x′ 
 
 2x3x′ 
 
 4	
	
b.	 x1
x4
x2
x4
x3
	 15.	x2x′ 
 
 3x4 + x′ 
 
 2x3x′ 
 
 4 + x′ 
 
 1x4
	 17.	 x1x3 + x1x′ 
 
 2 + x′ 
 
 1x2 or x2x3 + x1x′ 
 
 2 + x′ 
 
 1x2
	
	
or
	 19.	x2x′ 
 
 4 + x′ 
 
 1x′ 
 
 2x4 Here the don’t care at x1x2x′ 
 
 3x′ 
 
 4 has been treated as a 1, as has the don’t care at x′ 
 
 1x′ 
 
 2x′ 
 
 3x4; 
the don’t care at x1x′ 
 
 2x3x′ 
 
 4 has been ignored.
	 21.	 x3 + x2 
	 23.	x1x3x′ 
 
 4 + x1x′ 
 
 2x′ 
 
 3 + x′ 
 
 1x′ 
 
 2x3 + x′ 
 
 1x′ 
 
 3x′ 
 
 4
	 25.	x1x′ 
 
 2x3x′ 
 
 4 + x′ 
 
 1x3x4 + x′ 
 
 1x′ 
 
 3x′ 
 
 4 + x′ 
 
 1x′ 
 
 2x4 
	
	 or
	
	 x1x′ 
 
 2x3x′ 
 
 4 + x′ 
 
 1x3x4 + x′ 
 
 1x′ 
 
 3x′ 
 
 4 + x′ 
 
 1x′ 
 
 2x′ 
 
 3
	 27.	 x1x2 + x2x′ 
 
 4 + x1x′ 
 
 3x4 + x′ 
 
 1x′ 
 
 2x′ 
 
 3 
	
	 or
	
	 x1x2 + x2x′ 
 
 4 + x′ 
 
 2x′ 
 
 3x4 + x′ 
 
 1x′ 
 
 3x′ 
 
 4
	
	 or
	
	 x1x2 + x2x′ 
 
 4 + x′ 
 
 2x′ 
 
 3x4 + x′ 
 
 1x′ 
 
 2x′ 
 
 3
	 29.	x1x3 + x′ 
 
 1x2x′ 
 
 3 + x′ 
 
 2x′ 
 
 3x′ 
 
 4
x1
x3
x1
x2
x1
x2
x2
x3
x1
x2
x1
x2

936	
Answers to Odd-Numbered Exercises
936	
Answers to Odd-Numbered Exercises
Chapter 9
Exercises 9.1
	
1.	 a.	 not commutative, not associative
	
b.	The completed table is
∙
p
q
r
s
p
p
q
r
s
q
q
r
s
p
commutative
r
r
s
p
q
s
s
p
q
r
	
3.	 a.	associative, not commutative	
b.	commutative, not associative	
c.	neither
	
	 d.	both	
e.	commutative, not associative
	
5.	 a.	semigroup	
b.	none	
c.	none
	d.	monoid; i = 1 + 0"2	
e.	group; i = 1 + 0"2	
f.	group; i = 1
	
7.	 a.	group; i = zero polynomial	 	
d.	group; i = 1
	
	b.	none 	
e.	group; i = 0
	
	c.	group; i = c1
0
0
1d 	
	
f.	 monoid; i = function mapping every x to 0
	
9.	
	
	 Identity element is R3; inverse for F1 is F1; inverse for R2 is R1.
	 11.	a.	 No—not the same operation
	
b.	 No—zero polynomial (identity) does not belong to P; also, closure does not hold.
	c.	 No—not every element of ℤ* has an inverse in ℤ*
	d.	Yes
	 13.	 3506, +124, 3Z12, +124, 350, 2, 4, 6, 8, 106, +124, 350, 4, 86, +124, 350, 3, 6, 96, +124, 350, 66, +124
	 15.	a1 = i, a2 = (1, 2) + (3, 4), a3 = (1, 3) + (2, 4), a4 = (1, 4) + (2, 3), a5 = (1, 3) + (1, 2),
	
	 a6 = (1, 2) + (1, 3), a7 = (1, 3) + (1, 4), a8 = (1, 4) + (1, 2), a9 = (1, 4) + (1, 3), a10 = (1, 2) + (1, 4),
	
	 a11 = (2, 4) + (2, 3), a12 = (2,3) + (2,4)
	 17.	a.	No        b.	No        c.	Yes, but not an isomorphism
	 19.	a.	 Yes; f: ℤ S  12ℤ, f (x) = 12x	
	b.	No; ℤ5 is finite, 5ℤ is infinite
	c.	 Yes; f: 5ℤ S  12ℤ, f (x) = 12
5
 x
	d.	No; both sets have 6 elements, but 3S3, + 4 is noncommutative, 3ℤ6, +64 is commutative.
+
R1
R2
R3
F1
F2
F3
R1
R2
R3
R1
F3
F1
F2
R2
R3
R1
R2
F2
F3
F1
R3
R1
R2
R3
F1
F2
F3
F1
F2
F3
F1
R3
R1
R2
F2
F3
F1
F2
R2
R3
R1
F3
F1
F2
F3
R1
R2
R3

Answers to Odd-Numbered Exercises	
937
	 21.	a.	 Closure: 
c1
z
0
1d # c1
w
0
1 d = c1
w + z
0
1
d [ M0
2(ℤ). 
Matrix 
multiplication 
is 
associative. 
c1
0
0
1d [ M0
2(ℤ). The inverse of c1
z
0
1d  is c1
−z
0
1 d , which belongs to M0
2(ℤ).
	
b.	f is a bijection and
	
f  a c1
z
0
1d # c1
w
0
1 d b = f  a c1
w + z
0
1
d b = w + z = z + w = f  a c1
z
0
1d b + f  a c1
w
0
1 d b
	
c.	 f  a c1
7
0
1d b = 7 and  f  a c1
−3
0
1 d b = −3, 7 + (−3) = 4, f−1(4) = c1
4
0
1d
	
d.	 f  −1(2) = c1
2
0
1d  and  f  −1(3) c1
3
0
1d,c1
2
0
1d # c1
3
0
1d = c1
5
0
1d  and  f  a c1
5
0
1d b = 5
	 23.	a.	 i # i = i so i = i−1	
b.	 x−1 # x = x # x−1 = i, so x = (x−1)−1
	 25.	a.	 x r x because i # x # i−1 = x # i−1 = x # i = x. If x r y then for some g [ G, g # x # g−1 = y or 
g # x = y # g or x = g−1 # y # g = (g−1) # y # (g−1)−1 so y r x. If x r y and y r z then for some g1, g2 [ G, 
g1 # x #  g1
−1 = y and g2 # y # g2
−1 = z so g2 # g1 # x # g1
−1 # g2
−1 = z or (g2 # g1) # x # (g2 # g1)−1 = z and x r z.
	
	 b.	 Suppose G is commutative and y [ 3x4. Then for some g [ G, y = g # x # g−1 = x # g # g−1 = x # i = x. 
Thus 3x4 = 5x6. Conversely, suppose 3x4 = 5x6 for each x [ G. Let x, y [ G, and denote the element 
y # x # y−1 by z. Then x r z, so z = x and y # x # y−1 = x or y # x = x # y.
	 27.	a.	 iL = iL # iR = iR so iL = iR and this element is an identity in 3S, # 4.
	
b.	For example,
#
a
b
a
a
b
b
a
b
	
c.	 For example, #
a
b
a
a
a
b
b
b
	
d.	For example, 3ℝ+, +4
	 29.	Let x [ S with left inverse y. Then y [ S, so let z be the left inverse of y. Then x # y =
iL # (x # y) = (z # y) # (x # y) = z # (y # x) # y = z # iL # y = z # y = iL, so y is also a right inverse of x. Also, 
x # iL = x # (y # x) = (x # y) # x = iL # x = x, so iL is also a right identity in S and therefore an identity.
	 31.	For some fixed a [ S, let x1 be the solution to x # a = a. Let b be any element of S. Then a # x = b for 
some x [ S and x1 # b = x1 # (a # x) = (x1 # a) # x = a # x = b. Therefore x1 is a left identity in S. Also, for 
any b [ S, there is an x such that x # b = x1; hence every element of S has a left inverse. Result follows 
from Exercise 29.
	 33.	If G is commutative, then (x # y)2 = (x # y) # (x # y) = x # (y # x) # y = x # (x # y) # y = (x # x) # (y # y) = x2 # y2. 
For the converse, let x, y [ G; then x # y # x # y = x # x # y # y, and by left and right cancellation, y # x = x # y, 
so G is commutative.
	 35.	Closure: let x, y [ Bk. Then (x # y)k = xk # yk (because of commutativity) = i # i = i, so x # y [ Bk. 
Identity: ik = i, so i [ Bk. Inverses: for x [ Bk, (x−1)k = (xk)−1 = i−1 = i, so x−1 [ Bk. 
	 37.	a.	 S d T # G. Closure: for x, y [ S d T, x # y [ S because of closure in S, x # y [ T because of closure 
in T, so x # y [ S d T. Identity: i [ S and i [ T so i [ S d T. Inverses: for x [ S d T, x−1 [ S and 
x−1 [ T so x−1 [ S d T.
	b.	No. For example, 350, 4, 86, +124 and 350, 66, +124 are subgroups of 3Z12, +124 but 350, 4, 6, 86, +124 
is not a subgroup of 3Z12, +124 (not closed).

938	
Answers to Odd-Numbered Exercises
	 39.	a.	 Closure: let f, g [ Ha. Then (  f + g)(a) = f (g(a)) = f (a) = a, so f + g [ Ha. Identity: the identity map-
ping on A maps a to a. Inverses: let f [ Ha. Then f(a) = a so f  −1(a) = a, and f  −1 [ Ha.
	b.	(n −1)!
	 41.	a.	 Let x = az1, y = az2 [ A. Then x # y−1 = az1 # (az2)−1 = az1 # (a−1)z2 = az1−z2 [ A. By Exercise 40, A is 
a subgroup.
	b.	20 = 0, 21 = 2, 22 = 2 +7 2 = 4, 23 = 6, 24 = 1, 25 = 3, 26 = 5
	c.	 50 = 0, 51 = 5, 52 = 5 +7 5 = 3, 53 = 1, 54 = 6, 55 = 4, 56 = 2
	d.	30 = 0, 31 = 3, 32 = 3 +4 3 = 2, 33 = 1
	 43.	a.	 [Aut(S),+] is closed because composition of isomorphisms is an isomorphism (Practice 31). Associa-
tivity always holds for function composition. The identity function iS is an automorphism on S. Finally, 
if f is an automorphism on S, so is f  −1.
	
b.	
i:
0 S  0
1 S  1
2 S  2
3 S  3
	
f  :
0 S  0
1 S  3
2 S  2
3 S  1
	
°
i
f
i
i
f
f
f
i
	 45.	Let iG and iH denote the identity elements of G and H, respectively. Let f  be an isomorphism, f : G S H. 
Then f (iG) = iH and because f is one-to-one, iG is the only such element. Now let f be a homomorphism 
from G onto H; then f (iG) = iH. Suppose iG is the only such element, and let f (g1) = f (g2) for g1, g2 [ G. 
Then f (g1 # g2
−1) = f (g1) # f (g2
−1) = f (g1) # (   f (g2))−1 = f (g1) # (   f (g1))−1 = iH. Therefore g1 # g2
−1 = iG 
and g1 = iG # g2 = g2. Thus f is one-to-one; f is already an onto homomorphism, so it is an isomorphism.
	 47.	a.	 The + operation is a binary operation on E (well-defined and closed). Associativity holds because 
(3x4 + 3y4) + 3z4 = 3x + y4 + 3z4 = 3(x + y) + z4 = 3x + (y + z)4 = 3x4 + 3y + z4 = 3x4 +
(3y4 + 3z4). [0] is the identity because 3x4 + 304 = 3x + 04 = 3x4 and 304 + 3x4 = 30 + x4 = 3x4. 
Each element has an inverse: 3x4 + 3−x4 = 3x + (−x)4 = 304 = 3−x4 + 3x4. Commutativity holds 
because 3x4 + 3y4 = 3x + y4 = 3y + x4 = 3y4 + 3x4 
	b.	The function f : ℤ5 S  E5 given by f (0) = 304, f (1) = 314, f (2) = 324, f (3) = 334, f (4) = 344 
is a bijection. It is also a homomorphism. For x, y elements of ℤ5, f (x + y) = 3x + y4 =
3x4 + 3y4 = f (x) + f (y)
	c.	 The inverse of 3104 is 3−104 = 344. The preimage of [21] is 7. 
Exercises 9.2
	
1.	 f (G) is closed: Let f (x) and f (y) be elements in f (G). Then because f is a homomorphism, 
f (x) + f (y) = f (x # y). Because x and y belong to G, x # y belongs to G and f (x # y) is an element of 
f (G). iH belongs to f (G): Let f (x) be an element in f (G). Then f (x) + f (iG) = f (x # iG) = f (x)  and 
f (iG) + f (x) = f (iG # x) = f (x), so f (iG) is an identity for the subset f (G) and therefore f (iG) = iH. Ele-
ments in f (G) have inverses in f (G): Let f (x) be an element in f (G). Then x belongs to G and x−1 exists 
in G. Then f (x−1) + f (x) = f (x−1 # x) = f (iG) = iH. Similarly f (x) + f (x−1) = iH, so f (x−1) = −f (x) 
and f (x) has an inverse in f (G).
	
3.	 K = 4ℤ
	
5.	 a.	 f ((x, y) + (r, s)) = f (x + r, y + s) = (x + r) + (y + s) = (x + y) + (r + s) = f (x, y) + f (r, s).
	b.	K = 5(x,−x)0x [ ℤ6.
	
7.	 7 +12 S = 57, 11, 36
	
9.	 a.	 H has no row of all 0s and no two rows alike, so the minimum distance = 3 and the code is single-error 
correcting.

Answers to Odd-Numbered Exercises	
939
	b.	H can encode all of Z3
2. 000 S  000000, 001 S  001101, 010 S  010011, 011 S  011110, 
100 S  100111, 101 S  101010, 110 S  110100, 111 S  111001
	 11.	For example, H =  I
1
1
0
0
1
0
1
0
1
0
0
1
0
1
1
0
0
1
0
1
0
0
1
1
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
Y
	 13.	Let X = (x1, … , xn) and Y = (y1, … , yn) be elements of Zn
2. The ith component of (X +2 Y) # H is 
given by(x1 +2 y1) # H1i +2 (x2 +2  y2) # H2i +2c +2 (xn +2   yn) # Hni. Because the distributive law holds 
and addition modulo 2 is commutative, this expression equals (x1H1i +2  x2H2i +2 c +2  xnHni) +2
(   y1H1i +2   y2H2i +2c +2   ynHni), which is the ith component of X # H +2 Y # H.
	 15.	Coset leaders	
Syndromes
	
	 0000000	
000
	
	 0000001	
001
	
	 0000010	
010
	
	 0010000	
011
	
	 0000100	
100
	
	 0100000	
101
	
	 1000000	
110
	
	 0001000	
111
	 17.	The decoded word is 011000010101001.
Exercises 9.3
	
1.	 a.	 0001111110	
b.  aaacaaaa	
c.  00100110
	
3.	
Next state
Present state
Output
Present input
s1
0
s1
s2
s1
s2
s0
s1
s2
0
1
0
s0
1
	
Output is 010010
	
5.	
Next state
Present state
Output
Present input
s1
0
s2
s2
s3
s2
s0
s1
s3
a
b
s2
s1
s2
c
b
s3
1
	
Output is abbcbb

940	
Answers to Odd-Numbered Exercises
	
7.	
1
1
1
0
0
0
s0/1
s1/0
s2/0
	
	
	 Output is 101110
	
9.	
a, b, c
c
c
a, b
s0/0
s1/0
b
a
s2/1
	
	 	Output is 0001101
	 11.		a.	
s0/0
s1/1
0
0
1
1
	
b.  010100
	 13.	a.	
s0/0
s1/1
11
11
00, 10, 01
00, 10, 01
	
b.  010010
	 15.	a.	 Name each state with the sequence of the last two input bits read.
00/0
01/0
11/1
10/1
0
0
0
0
1
1
1
1
	
b.	The length of time required to remember a given input grows without bound and eventually would 
exceed the number of states.
	 17.	
Cust.
data
Add
form
Screen
1
go
back
select
cust.
exit
new
cust.
go
back
Prog.
not
running
	 19.	
s1/wait
4
s2/wait
1
s3/bingo
7
I
I  {4}
I  {1}
I  {7}
I
s0/wait
s4/dead

Answers to Odd-Numbered Exercises	
941
	 21.	No
	 23.	Yes
	 25.	a.	
0
0
1
1
s0/1
s1/0
	
b.	
s1/0
1
s2/0
1
s3/1
0
0, 1
0, 1
1
0
0
s0/0
s4/0
	
c.	
s0/0
s1/0
0
s2/1
0
0
0, 1
1
1
1
s3/0
	 27.	a.	
s1/1
1
s2/0
1
0, 1
0
0
s0/0
	
b.	
s1/0
0
s2/0
0
1
1
1
s3/1
0
s0/0
s4/0
0, 1
0, 1
	
c.	
s2/0
0
0
s3/0
0, 1
0, 1
1
s4/1
1
s1/0
s0/0
s5/0
0, 1
0, 1
	 29.	The object is to recognize the substring bcon.
s1/0
s2/0
o
c
s3/1
n
s0/0
s4/0
β
I − {n, β}
I − {β}
I − {β}
I − {c, β}
β
β
β
β
I − {o, β}

942	
Answers to Odd-Numbered Exercises
	 31.	Once a state is revisited, behavior will be periodic because the input is always 0 and there is no choice of paths from 
a state. The maximum number of inputs that can occur before this happens is n −1 (visiting all n states before 
repeating). The maximum length of a period is n (output from all n states, with the last state returning to s0).
	 33.	0*
	 35.	01* ~ (110)*
	 37.	(1 ~ 01)(01)*
	 39.	10*1
	 41.	1* ~ (010)*
	 43.	a.	 0(0 ~ 1)*1	
b.  1*01*(01*0)*1*	
c.  100*1
	 45.	a.	Yes	
b.  No	
c.  No
	 47.	dd*(+ ~ −)dd* where d stands for any digit
	 49.	a.	 (00)*	
b.  111*0	
c.  1*001*
	 51.	a.	 0*10*	
b.  000(1 ~ 0)*	
c.  (1 ~ 0)0(1 ~ 0)1(1 ~ 0)*
	 53.	a.	 Proof is by induction on the length of the regular expression. For the base step, if A = [, l, or i, then 
AR = [, l, or i. Assume that for all expressions of length ≤k, A regular S AR regular. Let A be a reg-
ular expression of length k + 1. If A = BC, where B and C are regular, then BR and CR are regular by 
inductive hypothesis and AR = CRBR, so AR is regular. Similarly, if A = B ~ C, then AR = BR ~ CR 
(regular), and if A = B*, then AR = (BR)* (regular).
	b.	No—no regular expression describes this set.
	 55.	beer, beter
	 57.	beter, better, bettter
	 59.	bit, but, beet
	 61.	b t
	 63.	s1
	 65.	A = 506, B = 51, 2, 56, C = 53, 46, D = 566
Next state
Present state
Output
Present input
C
0
D
C
B
C
A
B
D
1
0
B
A
C
1
1
B
1
	 67.	 A = 506, B = 556, C = 526, D = 57, 86, E = 51, 36, F = 54, 66
Next state
Present state
Output
Present input
E
0
C
F
D
B
A
B
F
0
0
E
F
C
0
D
E
D
0
C
E
E
1
1
F
1

Answers to Odd-Numbered Exercises	
943
	 69.	A = 506, B = 526, C = 51, 46, D = 536, E = 556
Next state
Present state
Output
Present input
C
0
D
E
C
A
B
0
0
B
C
C
1
C
B
D
2
C
A
E
2
1
	 71.	 A = 50, 26, B = 51, 36, C = 546
Next state
Present state
Output
Present input
B
a
C
C
A
A
B
1
0
B
A
C
0
b
A
B
A
c
	 73.	A = 506, B = 52, 46, C = 51, 56, D = 536
Next state
Present state
Output
Present input
D
0
A
C
B
A
A
B
D
0
0
B
D
C
1
1
B
1
	 75.	Possible answer: 
d1
d2
s0
0
0
s1
0
1
s2
1
0
s3
1
1
	
x(t)
d1(t)
d2(t)
y(t)
d1(t∙1)
d2(t∙1)
0
0
0
0
1
0
1
0
0
0
1
1
0
0
1
1
0
0
1
0
1
1
0
1
0 
1
0
0
0
1
1
1
0
0
1
1
0
1
1
1
0
1
1
1
1
1
1
0
	
y(t) = d1
′d2 + d1d2 = d2
	
d1(t + 1) = x′d1
 ′d2
 ′ + xd1
 ′d2
 ′ + xd1d2
 ′ + xd1d2 = d1
 ′d2
 ′ + xd1
	
d2(t + 1) = xd1
 ′d2
 ′ + xd1
 ′d2 + x′d1d2
 ′ + xd1d2
 ′ + x′d1d2 = x(d1
 ′ + d2
 ′) + x′d1

944	
Answers to Odd-Numbered Exercises
2
1
x(t)
y(t)
d1(t)
d1(t)
d2(t)
d2(t)
d1(t  1)
d2(t  1)
x(d  d)
xd1
2
1
dd
xd1
d1(t  1)
d2(t  1)
Exercises 9.4
	
1.	 a.	 halts with final tape c b
0
0
0
0
0
b
c
	
b.	does not change the tape and moves forever to the left 
	
3.	 One answer: State 2 is a final state.
(0, b, b, 2, R)	 blank tape or no more 1’s, go to final state
(0, 1, 1, 1, R)	 has read odd number of 1’s
(1, 1, 1, 0, R)	 has read even number of 1’s
	
5.	 One answer: State 3 is a final state.
	
(0, 0, 0, 0, R)	
e
	
(0, 1, 1, 1, R)	
pass over 0s to first 1
	
(1, 0, 0, 1, R)	
e
	
(1, 1, 1, 2, R)	
pass over 0s to second 1
	
(2, b, b, 3, R)	
end of string, halt and accept
	
7.	 One answer: State 9 is a final state
	
(0, b, b, 9, R)	 	
accepts blank tape
	
(0, 0, 0, 0, R)	
e
	
(0, 1, X, 1, R)	
finds first 1, marks with X
	
(1, 1, 1, 1, R)	
e
	
(1, Y , Y , 1, R)	
searches right for 2s
	
(1, 2, Y , 3, R)	
e
	
(3, 2, Y , 4, L)	
pair of 2s, marks with Y’s
	
(4, Y , Y , 4, L)	
s
	
(4, X, X, 4, L)
	
(4, 1, 1, 4, L)
	
(4, Z, Z, 4, L)	
searches left for 0s

Answers to Odd-Numbered Exercises	
945
	
(4, 0, Z, 5, L)	
e
	
(5, 0, Z, 6, R)	
pair of 0s, marks with Z’s
	
(6, Z, Z, 6, R)	
s
	
(6, X, X, 6, R)
	
(6, 1, X, 1, R)	
passes right to next 1
	
(6, Y , Y , 7, R)	 	
no more ls
	
(7, Y , Y , 7, R)	
e
	
(7, b, b, 8, L)	
no more 2s
	
(8, Y , Y , 8, L)	
s
	
(8, X, X, 8, L)
	
(8, Z, Z, 8, L)
	
(8, b, b, 9, L)	
no more 0s, halts and accepts
	
9.	 One answer: State 8 is a final state
	
(0, 0, b, 1, R)	 	
0 read on left of w1
	
(1, 0, 0, 1, R)	
s
	
(1, 1, 1, 1, R)
	
(1, *, *, 2, R)	 	
moves right to * 
	
(2, X, X, 2, R)	 	
passes over X’s
	
(2, 1, 1, 8, R)	
e
	
(2, b, b, 8, R)	 	
nonzero on left of w2, halts and accepts
	
(2, 0, X, 3, L)	 	
left symbols match
	
(3, X, X, 3, L)	
e
	
(3, *, *, 4, L)	 	
moves left to * 
	
(4, 1, 1, 4, L)	
s
	
(4, 0, 0, 4, L)
	
(4, b, b, 0, R)	 	
finds leftmost symbol
	
(0, 1, b, 5, R)	 	
1 read on left of w1
	
(5, 0, 0, 5, R)	
s
	
(5, 1, 1, 5, R)
	
(5, *, *, 6, R)	
moves right to * 
	
(6, X, X, 6, R)	
passes over X’s
	
(6, 0, 0, 8, R)	
e
	
(6, b, b, 8, R)	 	
non-one on left of w2, halts and accepts
	
(6, 1, X, 3, L)	 	
left symbols match
	
(0, *, *, 7, R)	 	
word left of * is empty
	
(7, X, X, 7, R)	
s
	
(7, 0, 0, 8, R)
	
(7, 1, 1, 8, R)	 	
word right of * nonempty, halts and accepts
	
(0, b, b, 0, R)	 	
w1 initially empty
	 11.	(0, 0, 1, 0, R)	
changes 0 to 1
	
	 (0, 1, 0, 0, R)	
changes 1 to 0
	 13.	(0, 1, 1, 1, R)	
passes center point
	
(1, 0, 0, 1, R)	
e
	
(1, b, 0, 2, L)	 	
adds 0 on right end
	
(2, 0, 0, 2, L)	
s
	
(2, 1, 1, 2, L)
	
(2, b, 0, 0, R)	 	
adds 0 on left end
	
(0, 0, 0, 0, R)	
	
returns to center point

946	
Answers to Odd-Numbered Exercises
	 15.	The general idea is to decrement the binary number by 1; with each decrement, add a 1 to the string of 1s 
being built.1
	
(0, 1, 1, 0, R)	
s
	
(0, 0, 0, 0, R)
	
(0, b, b, 1, L)	 	
finds least significant digit
	
(1, 1, 0, 2, R)	
	
if least significant digit = 1, then decrement
	
(2, 0, 0, 2, R)	
s
	
(2, 1, 1, 2, R)
	
(2, b, b, 3, R)	 	
finds end of original string
	
(3, 1, 1, 3, R)	
	
finds right end of new string
	
(3, b, 1, 4, L)	
	
writes 1 at end of new string
	
(4, 1, 1, 4, L)	
e
	
(4, b, b, 1, L)	 	
goes back to original string 
	
	
	
	
if least significant digit = 0, change to 1 and look
	
(1, 0, 1, 5, L)	
	
left for another 1 to decrement
	
(5, 0, 1, 5, L)	
	
increment 0s to the left
	
(5, b, b, 8, R)	
	
just incremented the final remaining 0, clean up
	
(5, 1, 0, 6, L)	
	
found a 1 to decrement
	
(6, 1, 1, 2, R)	
e
	
(6, 0, 0, 2, R)	 	
prepare to move to end of original string
	
(6, b, b, 7, R)	
	
the 1 just decremented was the most significant digit
	
(7, 0, b, 2, R)	
	
blank out the leading 0
	
(8, 1, b, 9, L)	
	
clean up and halt
	 17.	
f(n1, n2, n3) = e n2 + 1      if n2 > 0
undefined if n2 = 0
	 19.	(0, 1, 1, 1, R)	
e
	
(1, b, 1, 4, R)	 	
n = 0, add 1 and halt
	
(1, 1, 1, 2, R)	
e
     
	
(2, b, 1, 4, R)	 	
n = 1, add additional 1 and halt
	
(2, 1, 1, 3, R)	
s
	
(3, 1, b, 3, R)
	
(3, b, b, 4, R)	 	
n > 2, erase extra 1s and halt
	 21.	One answer:
	
(0, 1, 1, 1, R)	
e
	
(1, b, b, 8, R)	 	
n = 0, 2 # 0 = 0
	
(1, 1, 1, 2, R)	
s
	
(2, 1, 1, 2, R)
	
(2, b, b, 3, L)	 	
n > 0, finds end of n
	
(3, 1, X, 4, R)	
s
	
(4, X, X, 4, R)
	
(4, 1, 1, 4, R)	    
	
(4, b, 1, 5, L)	 	
changes 1 to X, adds 1 at right end of string
	
(5, 1, 1, 5, L)	
s
	
(5, X, X, 6, L)
	
(6, X, X, 6, L)
	
(6, 1, X, 4, R)	 	
goes left to next 1 of n
1My thanks to Alicia Kime of Fairmont State College and her student Tim Holmes for this solution.	

Answers to Odd-Numbered Exercises	
947
	
(6, b, b, 7, R)	
e
	
(7, X, 1, 7, R)	 	
n is doubled, changes X’s to 1’s
	
(7, 1, 1, 7, R)	
s
	
(7, b, b, 8, L)
	
(8, 1, b, 9, L)	 	
finds right end, erases extra 1, halts
	 23.	One answer:
	
(0, 1, b, 1, R)	 	
erases one extra 1
	
(1, *, b, 3, R)	 	
n1 = 0
	
(1, 1, b, 2, R)	
s
	
(2, 1, 1, 2, R)
	
(2, *, 1, 3, R)	 	
n1 > 0, replaces * with leftmost 1 of n1, halts
	 25.	One answer:
	
(0, 1, 1, 0, R)	
s
	
(0, *, *, 0, R)
	
(0, b, b, 1, L)
	
(0, X, X, 1, L)	 	
move to right end of 1s for n2
	
(1, 1, X, 2, L)	 	
X’s rightmost 1 of n2
	
(2, 1, 1, 2, L)	
t
	
(2, *, *, 2, L)
	
(2, b, b, 3, R)
	
(2, X, X, 3, R)
	
(3, 1, X, 0, R)	 	
move to left end of 1s for n1, X leftmost 1
	
(3, *, X, 4, L)	 	
n1 < n2
	
(4, X, X, 4, L)	
t
	
(4, b, 1, 5, R)
	
(5, X, b, 5, R)
	
(5, 1, b, 5, R)
	
(5, b, b, 9, R)	 	
write 0 on tape and halt
	
(1, *, *, 6, R)	 	
all of n2 used, now write n1 −n2 on tape
	
(6, X, X, 6, R)	
s
	
(6, b, b, 7, L)
	
(7, X, b, 7, L)	 	
erase n2
	
(7, *, 1, 8, L)	
s
	
(8, 1, 1, 8, L)
	
(8, X, b, 8, L)
	
(8, b, b, 9, R)	 	
clean up n1 −n2 and halt
	 27.	invoke T1, invoke T
Exercises 9.5
	
1.	 L(G) = 5l, a6; the grammar is type 0.
	
3.	 L(G) = 0(10)*; the grammar is regular.
	
5.	 G = (V, VT, S, P) where V = 5a, S6, VT = 5a6, and P = 5S S l, S S a6
	
7.	 The grammar of Exercise 3 is already regular.
	
9.	 L(G) = (ab)*
	 11.	 L(G) = aa*bb*. G is context-sensitive. An example of a regular grammar that generates L(G) is  
G′ = (V, V T, S, P) where V = 5a, b, A, B, S6, V T = 5a, b6 and P = 5S S aA, S S aB, A S aA, 
A S aB, B S bB, B S b6

948	
Answers to Odd-Numbered Exercises
	 13.	a.	 <S> ::= 0<A> 0 1<A>, <A> ::= 1<B><B>, <B> ::= 01 0 11
	b.	<S> ::= 0 0 0<A>, <A> ::= 1<B>, <B> ::= 0<A> 0 0
	c.	 <S> ::= 0 <S> 0 11<A>, <A> ::= 1<A> 0 1
	 15.	a.	 1*1(00)*
	b.	S S 1, S S 1S, S S 0A, A S 0, A S 0B, B S 0A
	 17.	For example, G = (V, VT, S, P) where V = 5(, ), S6, VT = 5(, )6, and P = 5S S l, S S (S)S6
	 19.	For example, G = (V, VT, S, P) where V = 5a, b, A, B, S6, VT = 5a, b6, and P = 5S S l, S S aSa, 
S S bSb, S S a, S S b6
	 21.	For example, G = (V, VT, S, P) where V = 50, 1, A, B, S6, VT = 50, 16, and P = 5S S 1A, A S 1, 
A S 1B, B S 0, B S 1, B S 0B, B S 1B6
	 23.	For example, G = (V, VT, S, P) where V = 51, S6, VT = 516, and P = 5S S l, S S 11S6
	 25.	For example, G = (V, VT, S, P) where V = 50, 1, S6, VT = 50, 16, and P = 5S S l, S S A, A S 01, 
A S 0S16
	 27.	For example, G = (V, VT, S, P) where V = 50, 1, S6, VT = 50, 16, and P = 5S S SS, S S 01, S S 10, 
S S 0S1, S S 1S06
	 29.	For example, G = (V, VT, S, P) where V = 50, S, A, B, X6, VT = 506, and  P = 5S S A0B, A0 S A00X,
X0 S 00X, XB S B, A S l, B S l6
	 31.	For example, G = (V, VT, S, P) where V = 50, 1, S, S1, A, B, M6, VT = 50, 16, and P = 5S S l, 
S S 0S1A, S S 1S1B, S1 S 0S1A, S1 S 1S1B, S1 S M, MA S M0, MB S M1, M S l, 0A S A0, 
0B S B0, 1A S A1, 1B S B16
	 33.	a.	
S
S
1
11
1
S
S
1
1
S
	
b.	
1
1
S
S
1
1
S
1
1
	 35.	
1
A
A
S
1
A
A
S
1
A
A
1
A
A
0
0
0
0
0
0
	 37.	The set of productions for G′ is formed from the set of productions for G as follows: For A and B nonter-
minals, whenever A 1* B in G and B S a is a production in G with 0a0  ≥2, add the production A S a to 
the set, then eliminate all productions of the form A S B. For any productions of the form A S a, a [ VT, 
add to the set of productions those obtained by replacing any A on the right of an existing production by a, 
then eliminate all productions of the form A S a. Eliminate S S l. The remaining productions all have 
right sides with length ≥2 and L(G′) # L(G). Only l and a finite number of one-length words may have 
been eliminated, so L(G) −L(G′) is a finite set.

949
Answers to Self-Tests
Chapter 1
Section 1.1
	
1.	 F	
If a statement is not a tautology, it does not have values that are all true, but that does not make them 
all false.
	
2.	 T	 Because of the truth table for disjunction, ( ) ~  T is T.
	
3.	 F	
The statement must have an implication as its main connective.
	
4.	 T
	
5.	 F	
The negation of a disjunction is the conjunction of the negations.
Section 1.2
	
1.	 T
	
2.	 F
	
3.	 T
	
4.	 F	
It is one in which hypothesis S conclusion is always true.
	
5.	 T
Section 1.3
	
1.	 F	
In fact, (4x)(P(x) ` 3P(x)4′) would be false in all interpretations.
	
2.	 T	
	
3.	 T
	
4.	 F 
There is no one predicate wff defined on an interpretation, nor is the domain at all determined  
by truth values.
	
5.	 T
Section 1.4
	
1.	 T
	
2.	 F	
Existential instantiation should be used early.
	
3.	 F 
Universal instantiation would only strip off the leading universal quantifier.
	
4.	 F	
Wffs in propositional logic are not even wffs in predicate logic.
	
5.	 T	 Predicate logic is correct—only valid wffs are provable.

950	
Answers to Self-Tests
Section 1.5
	
1.	 T
	
2.	 F	
A single negated predicate is only one kind of Horn clause.
	
3.	 T
	
4.	 F	
A Prolog recursive rule is not a rule of inference.
	
5.	 T
Section 1.6
	
1.	 F 
It guarantees only that the output satisfies certain conditions, given that the input satisfies certain 
conditions.
	
2.	 F	
Nothing much can be said about the precondition without knowing the assignment, but at any rate the 
strict inequality will not go away.
	
3.	 F	
Program testing involves test data sets.
	
4.	 T
	
5.	 T
Chapter 2
Section 2.1
	
1.	 F 
A conjecture that only asserts something about a finite number of cases can be proved by proving all 
cases.
	
2.	 T
	
3.	 F 
A universal quantifier is understood, because the formal statement of the theorem is 
(4x)(x odd S  2 * x is even).
	
4.	 F 
The second statement is the converse of the first, not the contrapositive.
	
5.	 T
Section 2.2
	
1.	 T
	
2.	 F	
The basis step need not be n = 1.
	
3.	 T
	
4.	 T
	
5.	 F 
This omits the first k −1 terms of the series.
Section 2.3
	
1.	 F	
A loop invariant remains true after loop termination.
	
2.	 F	
It means that correctness has been proved only given that the loop terminates.

Answers to Self-Tests	
951
	
3.	 F 
The first principle of induction is used because the values at pass k + 1 through the loop depend only 
on the values at pass k.
	
4.	 F	
But Q should give the desired result when the condition B′ is true.
	
5.	 T	 (12 is the remainder when 42 is divided by 30).
Section 2.4
	
1.	 T
	
2.	 F	
The linear combination must equal 1.
	
3.	 F	
For example, 36 = 22·32, so the prime factors are 2 and 3, neither of which is > 6 = "36.
	
4.	 F	
For example, w(5) = 4, which is not a prime.
	
5.	 T
Chapter 3
Section 3.1
	
1.	 T
	
2.	 F	
18, 20, 22, 24 can be generated, but not, for example, 26.
	
3.	 F	
They are valuable because they represent natural ways of thinking about certain problems, but they 
typically use more storage and perform more operations than a corresponding iterative program.
	
4.	 T
	
5.	 T
Section 3.2
	
1.	 F	
Induction may be used to verify a proposed closed-form solution but not to determine such a solution 
from the recurrence relation.
	
2.	 F	
It is not linear because of the presence of the S(n −2) term.
	
3.	 F	
It is a pattern for the general solution, but it is not a closed-form solution because of the summation; 
in any specific case, there must be a closed-form expression to evaluate the summation.
	
4.	 T
	
5.	 T
Section 3.3
	
1.	 T
	
2.	 F	
It requires m(n −m + 1) comparisons.
	
3.	 T
	
4.	 F 
The recursive version looks at the first item in the list, and if that is not the target, it searches the rest 
of the list. The “input size” goes down only by 1 each time the algorithm is invoked.
	
5.	 T

952	
Answers to Self-Tests
Chapter 4
Section 4.1
	
1.	 F	
It is not a proper subset of itself.
	
2.	 T
	
3.	 T
	
4.	 F	
This is the closure property.
	
5.	 F	
It is a way to prove that certain sets are uncountable.
Section 4.2
	
1.	 T
	
2.	 F
	
3.	 T
	
4.	 T
	
5.	 F
Section 4.3
	
1.	 F
	
2.	 F	
The number of elements in the union plus the number of elements in the intersection is the sum of the 
number of elements in each set.
	
3.	 F 
All must be finite.
	
4.	 F
	
5.	 T
Section 4.4
	
1.	 T
	
2.	 T
	
3.	 F	
Use C(n, r).
	
4.	 F	
It is n!n1!n2!n3!.
	
5.	 T
Section 4.5
	
1.	 F	
Combinations, not arrangements.
	
2.	 T
	
3.	 F	
All terms are found in row n.
	
4.	 T
	
5.	 T

Answers to Self-Tests	
953
Section 4.6
	
1.	 T	
	
2.	 T
	
3.	 F	
This will work only if the events are independent.
	
4.	 F	
A random variable is not a variable; it is a function that assigns numerical values to the members of a 
sample space, and these values are generally not randomly chosen.
	
5.	 T
Chapter 5
Section 5.1
	
1.	 T
	
2.	 F	
(x, x) can belong.
	
3.	 T
	
4.	 F	
The relation of equality is both a partial ordering and an equivalence relation.
	
5.	 F	
An equivalence relation does this.
Section 5.2
	
1.	 F
	
2.	 T
	
3.	 F	
The converse is true.
	
4.	 F	
The maximum value is used.
	
5.	 F	
See Example 18 and Practice 19.
Section 5.3
	
1.	 T
	
2.	 T
	
3.	 F
	
4.	 T
	
5.	 F	
If the data satisfy data integrity to begin with, then data integrity will still be true after a delete. It is 
referential integrity that may be lost.
Section 5.4
	
1.	 F	
It may not have an image for each member of the domain.
	
2.	 F	
Every element of the range has a preimage; begin with an element of the codomain.
	
3.	 T

954	
Answers to Self-Tests
	
4.	 T
	
5.	 F	
The original function must be a bijection.
Section 5.5
	
1.	 F	
Other constants may work where these do not.
	
2.	 F	
Either f = Θ(g) or f = o(g)
	
3.	 T
	
4.	 F
	
5.	 T
Section 5.6
	
1.	 T
	
2.	 F	
If the hash table entry does not match the target value, then the collision resolution algorithm must be 
followed before the search can be deemed a failure.
	
3.	 T
	
4.	 F 
It derives from the difficulty of finding the prime factors of n.
	
5.	 T
Section 5.7
	
1.	 T
	
2.	 F	
The two products are not necessarily equal.
	
3.	 T
	
4.	 F
	
5.	 F	
See Practice 58.
Chapter 6
Section 6.1
	
1.	 F	
A complete graph has an arc between any two nodes.
	
2.	 T
	
3.	 F	
A planar graph could still be drawn with arcs that cross.
	
4.	 F	
It means that nodes 2, 3, and 4 are all adjacent to some one node.
	
5.	 F	
It could be symmetric; it just doesn’t have to be.
Section 6.2
	
1.	 T
	
2.	 F	
A complete (binary) tree has nothing to do with a complete graph.
	
3.	 T
	
4.	 T
	
5.	 T

Answers to Self-Tests	
955
Section 6.3
	
1.	 T
	
2.	 F	
This is the worst case; other cases could require fewer comparisons.
	
3.	 T
	
4.	 F	
The binary search tree depends on the order in which data elements are inserted.
	
5.	 F	
It must have at least n! leaves.
Section 6.4
	
1.	 T
	
2.	 F 
In a prefix code, no code word is the prefix of another code word.
	
3.	 F 
Characters that occur most frequently have the shortest strings, and frequency does not affect the 
number of 0s versus the number of 1s.
	
4.	 T
	
5.	 F 
The code table file (giving the code for each character) must be stored along with the encoded file.
Chapter 7
Section 7.1
	
1.	 T
	
2.	 T
	
3.	 F	
R = A ~ A(2) ~ c~ A(n)
	
4.	 F	
That’s what R = A ~ A(2) ~ c~ A(n) does; Warshall’s algorithm expands the set of nodes available 
for use on a path.
	
5.	 F	
Warshall’s algorithm computes transitive closure.
Section 7.2
	
1.	 T
	
2.	 F	
The graph can have at most two odd nodes.
	
3.	 T
	
4.	 F	
Some arcs may go unused.
	
5.	 F 
No efficient algorithm is known, but trial and error solves the problem.
Section 7.3
	
1.	 F 
This is how Prim’s algorithm works.
	
2.	 F 
A greedy algorithm does not necessarily divide a problem into smaller subproblems, but it takes the 
“best” action based on limited knowledge at each step.
	
3.	 T
	
4.	 T
	
5.	 F	
It will generally not form a tree at all.

956	
Answers to Self-Tests
Section 7.4
	
1.	 F 
The starting node for a depth-first search can be any node in the graph.
	
2.	 T
	
3.	 T
	
4.	 F	
It is the equivalent of depth-first search, assuming that sibling nodes are labeled in order from left to 
right.
	
5.	 F	
Use a succession of depth-first searches.
Section 7.5
	
1.	 F	
Any path between some set of two nodes must pass through it.
	
2.	 T
	
3.	 T
	
4.	 T
	
5.	 F	
The root is a special case.
Chapter 8
Section 8.1
	
1.	 F	
x + x′ = 1
	
2.	 T
	
3.	 T	
x + ( y + x # z) = x + (x # z + y)
	
	 	
 = x # 1 + (x # z + y)
	
	 	
 = (x # 1 + x # z) + y
	
	 	
 = x # (1 + z) + y
	
	 	
 = x # (z + 1) + y
	
	 	
 = x # 1 + y
	
	 	
 = x + y
	
4.	 T
	
5.	 T
Section 8.2
	
1.	 T	
(x + y)′ = x′ # y′
	
2.	 F	
It has as many terms as the function has 1-values (or one term if the function has all 0-values).
	
3.	 F	
Only one half-adder is needed (see Figure 8.14a).
	
4.	 T	 Because x + x = x
	
5.	 F	 This usually results in an unnecessarily large number of devices; start again from the truth ­ 
function.

Answers to Self-Tests	
957
Section 8.3
	
1.	 T
	
2.	 T
	
3.	 F 
Look for two-square blocks first and work up from there.
	
4.	 T
	
5.	 F 
The term is essential if the check for that row is the only one in some column.
Chapter 9
Section 9.1
	
1.	 F 
This describes a commutative operation.
	
2.	 T Even though this is not the definition of the identity
	
3.	 T
	
4.	 T By Lagrange’s theorem.
	
5.	 F	
f must also be a bijection.
Section 9.2
	
1.	 T
	
2.	 T
	
3.	 F	
H maps Z n
2  to Z r
2.
	
4.	 T If the syndrome of X equals 0r , then X is in the kernel of the homomorphism generated by H and is a 
code word; it will be assumed that no errors occurred.
	
5.	 F 
No coding scheme can guarantee zero bit errors.
Section 9.3
	
1.	 T
	
2.	 T	 (0 ~ 1)*00
	
3.	 F 
See Figure 9.8a.
	
4.	 T
	
5.	 F
Section 9.4
	
1.	 F 
Entering a final state causes a Turing machine to halt, but it can also halt in a nonfinal state if there is 
no instruction for the current state–input pair.
	
2.	 F 
There will be n + 2 1s on the tape.
	
3.	 F
	
4.	 F 
This is the version with the quantifiers reversed that is trivially true.
	
5.	 T

958	
Answers to Self-Tests
Section 9.5
	
1.	 T
	
2.	 F	
Depending on the productions selected, nonterminal symbols may never be removed.
	
3.	 F	
There may be an equivalent grammar for the language that is context-free.
	
4.	 T
	
5.	 T

Index
A
ABA routing number, 437
Absolute value, 107
Absorption property, 633
Ackermann’s function, 407
Acquaintanceship graph, 499
Acyclic graph, 482
Addition inference rule, 29
Addition modulo n, 343, 438, 692
Addition of matrices, 449
Addition principle, 254–55
definition of, 254
Adjacency list, 494
Adjacency matrix, 492
Adjacency relation, 555
Adjacent nodes, 481
Adleman, Len, 431
AES (Advanced Encryption  
Standard), 431
Algebraic structure, 686–708. See also 
Group
associative property, 687
commutative property, 687
free monoid, 695
group of permutations, 693
identity element, 687
inverse element, 687
monoid, 689
semigroup, 689
semigroup of transformations, 693
ALGOL, 164, 788
Algorithm
definition of, 12
divide-and-conquer, 468
graph traversal, 596–604
greedy, 586
optimal, 533
recursive, 166–71
Algorithms
ArtPoint, 610
Bellman-Ford, 592
BinarySearch, 169, 208
BreadthFirst, 599
BubbleSort, 214
CombGenerator, 285
DepthFirst, 597
Dijkstra’s, 582
Euclidean, 133
EulerPath, 574
Floyd’s, 593
HeapSort, 527
HuffmanTree, 542
Inorder, 515
Kruskal’s, 594
MatrixMultiplication, 452
MergeSort, 215
Minimize, 742
PermGenerator, 282, 283
Postorder, 515
Preorder, 514
QuickSort, 215
SelectionSort, 169, 215
SequentialSearch, 204, 207
Sum-of-Products, 643
TautologyTest, 13
TopologicalSort, 360
Warshall, 563
Alphabet, 694, 782
Alternating group, 701
Ambiguous grammar, 798
Analysis of algorithms, 203–10, 314, 
415
average case, 205, 314
binary search, 209
breadth-first search, 601
computational complexity, 416
definition of, 203
depth-first search, 601
Dijkstra’s algorithm, 586
Euclidean algorithm, 210
Euler path, 565
lower bound, 511
sequential search, 205, 207
upper bound, 210
using recurrence relations, 206–10
Warshall’s algorithm, 565
worst case, 205
AND connective, 11, 75
AND gate, 12, 639
Antecedent, 3
Antisymmetric relation, 332
Appel, Kenneth, 507
Arc, 477, 478
Archimedes, 286
Aristotle, 59, 71
Arithmetic progression (arithmetic 
sequence), 124
Array, 448
Articulation point., 607
Assertion, 85–87
definition of, 86
Assignment rule of inference, 87–89
definition of, 87
Associative equivalence rule, 28
Associative property, 9, 234, 687
Asymmetric encryption, 431
Asymmetric relation, 349
Atias,Nir, 497
Augmented matrix, 453
Automorphism, 714
Axiom, 98, 773
B
Back arc, 608
Backus-Naur form (BNF), 163, 787
Ballot problem, 175
BASIC, 259
Basis (basis step), 111
Bayes’ theorem, 308–9
statement of, 309
Behm, Patrick, 136
Bell numbers, 354
959

960	
Index
Bellman-Ford algorithm, 592
Benford’s law, 325
Benoit, Paul, 136
Bernoulli experiment, 313
Bernoulli trial, 313
Bernoulli, Jacob, 313
Biconnected components, 608
Big oh, 417
Big theta, 413
Bijection, 390
Binary adder, 731–33
Binary connective, 3
Binary GCD algorithm, 142
Binary operation, 228–30
associative, 687
commutative, 687
definition of, 229
well-defined, 229, 686
Binary predicate, 40
Binary relation, 328–36
antisymmetric, 332
asymmetric, 349
closure of, 334–36
complement of, 331
definition of, 329
and directed graph, 555–57
equivalence relation, 339–44
intersection of, 331
inverse of, 350
irreflexive, 349
many-to-many, 330
many-to-one, 330
one-to-many, 330
one-to-one, 330
partial ordering, 336–38
properties of, 332–34
reflexive, 332
reflexive closure of, 334
from S to T, 330
symmetric, 332
symmetric closure of, 334
transitive, 332
transitive closure of, 334, 561
union of, 331
Binary search algorithm, 169, 208
Binary search analysis, 209
Binary search tree, 352, 511, 534
Binary string, 163
Binary tree, 510
Binary tree search, 352, 534
Binomial coefficient, 297
Binomial distribution, 313–14
definition of, 313
Binomial theorem, 294–98
statement of, 296
Bipartite complete graph, 483
Birthday problem, 318
Blind key, 368
Block cipher, 429
Blocks of a partition, 339
BNF. See Backus-Naur form
Boole, George, 458, 617
Boolean algebra, 618–31
absorption property, 633
complement of an element, 625
definition of, 620
De Morgan’s laws, 624
double negation property, 624
dual of a property, 623
idempotent property, 622
isomorphism, 629
modular property, 633
universal bound property, 624
Boolean AND, 458
Boolean expression, 639
Boolean matrix, 458–59
Boolean AND, 458
Boolean OR, 458
multiplication, 458
and reachability, 558
Boolean OR, 458
Bottom up parsing, 794
Bourg, David M., 749
Breadth-first search, 598–601
analysis of, 601
B-tree, 526
Bubble sort algorithm, 214
Byte, 257
C
ℂ, 224
Caesar, Julius, 428
Caesar cipher, 428
Cancellation laws, 696
Canonical parity-check matrix, 721
Canonical product-of-sums form, 660
Canonical sum-of-products form, 643
Cantor, Georg, 237, 401
Cantor’s diagonalization method, 237
Cantor’s theorem, 401
Carbin, Michael, 654
Cardinality
of a relation, 366
of a set, 236, 401
Cartesian product (cross product), 233
Castile, Tracy, 262
Catalan numbers, 175, 263, 293, 526
Cayley, Arthur, 708
Cayley’s theorem, 708
Ceiling function, 386
Center of a group, 713
Chain, 338
Chaining, 426
Characteristic equation, 190
Characteristic function, 406
Chinese remainder theorem, 432, 445
Chomsky, Noam, 786
Chomsky hierarchy, 790
Chromatic number of a graph, 507
Chung, Fan, 287
Church, Alonzo, 770, 771, 773
Church-Turing thesis, 770
Ciphertext, 428
Circular left shift, 430, 439
Closed form solution, 180
Closure of binary relations, 334–36, 
556
definition of, 334
Coding theory, 714–26
canonical parity-check matrix, 721
check bits, 721
coset leader, 723
double-error detecting code, 715
group code, 719
Hamming distance, 718
information bits, 721
maximum likelihood decoding, 715
minimum distance of a code, 718
perfect code, 722
single-error correcting code, 715
syndrome, 724
weight of a code word, 719
Codomain, 383
Coefficient, 690
Collision, 425
Collision resolution, 425
Combinational network, 638–48, 744
definition of, 642
Combinations, 274–77
definition of, 274
eliminating duplicates, 279
generating, 284
with repetitions, 279
Combinatorial proof, 296
Combinatorics, 252–87
addition principle, 254
combinations, 277
decision tree, 257–58
definition of, 252
multiplication principle, 253
permutations, 272–74
pigeonhole principle, 269
Common difference, 124
Common ratio, 124

Index	
961
Commutative diagram, 391, 479, 628
Commutative equivalence rule, 28
Commutative group, 688
Commutative property, 9, 234, 687
Complement
of a binary relation, 331
of a boolean algebra element, 625
of a graph, 506
of a set, 232
Complement property, 9, 234
Complete binary tree, 510
Complete formal system, 27, 58
Complete graph, 482
Composite number, 107
Composition function, 391
Composition of functions, 390–92
definition of, 391
Compound statement, 2
Computational complexity, 416, 
776–78
Computational procedure, 769
Computer security, 143, 427–35
ciphertext, 428
cryptographic hash functiom, 434
cryptography, 427–33
one-way encryption, 434
password encryption, 433–35
plaintext, 428
Concatenation, 163, 694
Conclusion of an argument, 25
Conditional probability, 306–7
definition of, 307
independent events, 307
Conditional rule of inference, 90–92
definition of, 90
Conditional statement, 90
Congruence modulo n, 343
Conjunct, 2
Conjunction, 2
Conjunction inference rule, 29
Conjunctive normal form, 660
Connected component of a graph, 603
Connected graph, 482
Connective. See Logical connective
Consequent, 3
Constant symbol, 41
Context free (type 2) grammar, 790, 
793–95
Context free language, 790
Context sensitive (type 1) grammar, 
790
Context sensitive language, 790
Contradiction, 8, 104–6
Contraposition, 103–4
Contraposition inference rule, 37
Contrapositive, 21, 103
Converse, 21, 103
Correct formal system, 27, 58
Correct program, 85
Coset, 717
Countable set, 236
Counterexample, 99
Critical path, 359
Cryptographic hash function, 434
Cryptography, 427–33
AES, 431
asymmetric encryption, 431
block cipher, 429
Caesar cipher, 428
definition of, 428
DES, 429, 656
diffusion, 429
private key encryption, 431
public key encryption, 431
RSA public key encryption  
algorithm, 431
simple substitution cipher, 429
symmetric encryption, 431
Cryptology, 428
Cutler, William, 286
Cycle in a graph, 482
Cycle notation, 395
Cyclic group, 713
D 
Darwin, Charles, 211
Data compaction, 540
Data compression, 540
Data flow diagram, 480
Data integrity, 375
Database, 365–76
add operation, 375
blind key, 368
composite primary key, 367
conceptual model of, 365
data integrity, 375
definition of, 365
delete operation, 375
entity, 365
entity attributes, 365
entity integrity, 367, 375
entity-relationship diagram, 365
entity-relationship model, 365–66
foreign key, 368
integrity, 375–76
join operation, 370
metadata, 366
modify operation, 375
operations, 369–73
outer join, 369
primary key, 367
project operation, 369
in Prolog, 73
referential integrity, 375
relational, 366
relational algebra, 372
relational calculus, 372
relational model, 366–69
restrict operation, 369
SQL, 372
surrogate key, 368
tuple, 366
Decision problem, 771–76
definition of, 772
negative solution for, 772
positive solution for, 772
uncomputable, 772
undecidable, 772
unsolvable, 772
Decision tree, 257–58, 511, 529–36
definition of, 529
for searching, 529–35
for sorting, 535–36
Declarative language, 73
Deduction method, 32
Deductive reasoning, 99
Degree of a node, 481
Degree of a polynomial, 691
Degree of a relation, 366
Degree of separation, 499
Delay element, 744
DeMoivre’s theorem, 126
De Morgan, Augustus, 9, 507
De Morgan’s laws, 10, 28, 178, 248, 
250, 624, 633
Denumerable set, 236, 401
Depth of a node, 510
Depth-first search, 81, 596–98
analysis of, 601
Dequeue, 599
Derangement, 396
Derivation in a grammar, 784
Derivation rules, 803–04
definition of, 27
for predicate logic, 58–62
for propositional logic, 28–33
DES (Data Encryption Standard), 429, 
656
Descriptive language, 73
Determinant of a matrix, 473
Diagonal matrix, 463
Difference of sets, 233
Diffusion, 429
Digraph. See Directed graph

962	
Index
Dijkstra, Edsger W., 581
Dijkstra’s algorithm, 581
analysis of, 586
Dimensions of a matrix, 446
Direct proof, 101–3
Directed graph
connected, 568
definition of, 478
initial point, 478
path in, 483
reachability in, 557–62, 602
reachability matrix, 559
reachable node in, 483, 557
terminal point, 478
Warshall’s algorithm, 562–65
Disjoint cycles, 395
Disjoint sets, 232
Disjunct, 3
Disjunction, 3
Disjunctive normal form, 643
Disjunctive syllogism, 37
Distributive inference rule, 37
Distributive property, 9, 234, 250
Divide-and-conquer algorithm, 208, 
468
Divide-and-conquer recurrence  
relation, 193–97
Divides, 107
DNA, 205
Document Type Definition, 788
Domain
of a function, 383
of an interpretation, 41
Don’t-care condition, 653
Double negation equivalence rule, 28
Double negation property, 624, 633
DTD, 788
Dual
of Boolean algebra property, 623
of set identity, 235
of a tautological equivalence, 9
Dummy variable, 41
Dwyer function, 407
E
Edge, 477, 478
Elementary row operations, 454
Empty set, 224
Empty string, 163, 694
Enqueue, 599
Entity integrity, 367, 375
Entity relationship diagram, 365
Equal functions, 387
Equal matrices, 447
Equal sets, 223
Equivalence class, 339
Equivalence connective, 3
Equivalence relation, 339–44
definition of, 339
and equivalence class, 339
and partitions, 340
Equivalence rules
associative, 28
commutative, 28
definition of, 28
De Morgan’s laws, 28
double negation, 28
implication, 28
Equivalent Boolean expressions, 645
Equivalent grammars, 791
Equivalent sets, 401–2
Cantor’s theorem, 401
definition of, 401
Equivalent states, 739
Equivalent wffs, 8
Erasing convention, 789
Euclid, 98, 133, 148
Euclidean algorithm, 133–35, 144, 
145, 210, 217, 432
binary GCD algorithm, 142
greatest common divisor, 133
Euler, Leonhard, 488, 571
Euler path, 572, 573
Euler phi function, 149–51, 431
definition of, 150
Euler’s formula, 488
Even node, 572
Even number, 101
Even permutation, 700
Event, 302
Exclusive OR, 22, 430, 634, 656
Exhaustive proof, 100–101
Existential generalization, 59, 62
Existential instantiation, 59, 60
Existential quantifier, 40
Expected value, 310–12
definition of, 310
linearity of, 312
Expert system, 81
Exportation inference rule, 37
Extensible Markup Language, 788
F
Faivre, Alain, 136
Fermat, Pierre de, 143
Fermat’s last theorem, 143
Fermat’s little theorem, 432, 445
Fibonacci sequence, 159, 188, 301
Field-programmable gate array  
(FPGA), 647
Figurate numbers, 200
Final state, 734, 765
Finite set, 223
Finite state machine, 479, 728–48
binary adder, 731–33
definition of, 729
equivalent states in, 739
final state, 734
input alphabet, 729
k-equivalent states in, 739
Kleene’s theorem, 737
minimization, 737–44
minimization algorithm, 742
next-state function, 729
output alphabet, 729
output function, 729
recognition by, 734
and regular sets, 737
and sequential networks, 744–48
state graph, 730
state table, 730
unreachable state of, 737
First principle of induction, 110–12, 
250
definition of, 111
First order recurrence relation, 182
Five-color theorem, 507
Flip-flop, 744
Floating point operations, 460
Floor function, 386
Floyd’s algorithm, 593
Foreign key, 368
Forest, 510
Formal language, 782–95. See also 
Language
and computational devices,792–93
definition of, 785
generated by a grammar, 784
hierarchy of, 793
Formal logic, 1–96
predicate logic, 58–69, 773
propositional logic, 25–35
Formal system
completeness of, 27, 58
correctness of, 27, 58
Four-color problem, 507
Free monoid, 695
Free tree, 509
Free variable, 42
Full binary tree, 510
Full-adder, 649
Function, 381–402
Ackermann’s function, 407
bijection, 390
as a binary relation, 383
ceiling function, 386

Index	
963
characteristic, 406
codomain, 383
composition, 391
composition of, 390–92
definition of, 383
domain, 383
Dwyer function, 407
equality of, 387
floor function, 386
hash function, 441
identity function, 392
image under, 383
injective, 389
inverse, 392–94
left inverse, 408
modulo, 386
of more than one variable, 385
next-state, 729
nondeterministic, 411
number of, 397–400
number-theoretic, 767
one-to-one, 389
onto, 388
order of magnitude of, 412–21
output, 729
partial, 767
permutation, 394–96
preimage under, 383
properties of, 388–90
range of, 388
right inverse, 408
Smorynski function, 407
surjective, 388
total, 767
truth, 640
Turing-computable, 768
Fundamental Theorem of Arithmetic, 
144–48
definition of, 144
Fuzzy logic, 23, 250
Fuzzy set, 250
G
Gates, William, 211
Gauss, Karl Friedrich, 110, 454
Gaussian elimination, 453–57
Generating permutations, 280–85
Generator of a cyclic group, 713
Geometric progression (geometric 
sequence), 124
Global clustering coefficient, 500
Gödel, Kurt, 98, 773
Goldbach conjecture, 149, 154
Golden ratio, 160, 219
Goodman, Jacob, 211
Graham, Ronald, 287
Grammar
ambiguous, 798
Backus-Naur form, 787
bottom-up parsing, 794
Chomsky hierarchy, 790
classes of, 789–92
context-free (type 2), 790, 793–95
context-sensitive (type 1), 790
direct generation (direct derivation) 
in, 784
equivalent, 791
erasing convention, 789
generation (derivation) in, 784
language generated by, 784
parse tree, 793
phrase-structure (type 0)  
grammar, 783
production, 783
regular (type 3), 790
start symbol, 783
terminal, 783
top-down parsing, 794
Graph, 476–96. See also Tree
acquaintanceship graph, 499
acyclic, 482
adjacency list, 494
adjacency matrix, 492
adjacency relation, 555
adjacent nodes in, 481
algorithms, 553–604
applications, 479–81
arc, 477, 478
articulation point, 607
Bellman-Ford algorithm, 592
biconnected, 608
biconnected components, 608
bipartite complete, 483
breadth-first search of, 598–601
chromatic number of, 507
colorability, 506
coloring of, 507
complement of, 506
complete, 482
connected, 482
connected component of, 603
cycle in, 482
definition (formal), 478
definition (informal), 477
degree of a node, 481
degree of separation, 499
depth-first search of, 596–98
Dijkstra’s algorithm, 581
directed. See Directed graph
dual graph for a map, 507
edge, 477, 478
endpoints of an arc, 478
Euler path in, 572
Euler’s formula, 488
even node, 572
five-color theorem, 507
Floyd’s algorithm, 593
four-color problem, 507
global clustering coefficient, 500
Hamiltonian circuit in, 576
homeomorphic, 491
in-degree of a node, 579
isolated node, 481
isomorphic, 484–87
isomorphism, 486
Kruskal’s algorithm, 594
Kuratowski theorem, 491
labeled, 479
length of a path, 482
loop in, 481
loop-free, 481
map-coloring problem, 506
minimal spanning tree, 587
node, 477, 478
odd node, 572
out-degree of a node, 579
parallel arcs in, 481
path in, 482
Petersen, 492
planar, 487–92
Prim’s algorithm, 587
self-complementary, 506
shortest path problem, 581–87
simple, 481
six-color theorem, 508
spanning tree in, 587
sparse adjacency matrix, 494
subgraph of, 482
theorem on Euler paths, 573
traversal, 596
traversal algorithms, 596–604
trees, 509–21
vertex, 477, 478
weighted, 479
Graph coloring problem, 778
Greatest common divisor, 133, 144
Greatest element, 338
Greatest lower bound, 637
Greedy algorithm, 586
Group
alternating, 701
automorphism, 714
Cayley’s theorem, 708
center of a, 713
commutative, 688
coset, 717
cyclic, 713

964	
Index
Group (cont.)
definition of, 688
generator of, 713
homomorphism, 702
idempotent element, 713
improper subgroup of, 700
isomorphic, 702–8
isomorphism, 702
kernel of a homomorphism, 716
Lagrange’s theorem, 701
left cancellation law, 696
left identity element, 712
left inverse element, 713
order of, 698
permutation group, 700
of permutations, 693
proper subgroup of, 700
right cancellation law, 696
right identity element, 712
right inverse element, 713
subgroup of, 699
symmetric group of degree n, 693
of symmetries of an equilateral 
triangle, 710
Group code, 719
H
Haken, Wolfgang, 507
Half-adder, 649
Halting problem, 774
Hamilton, William Rowan, 576
Hamiltonian circuit, 576, 777
Hamming distance, 718
Hamming, Richard W., 718
Hash function, 424, 441
Hash table, 425
Hashing, 424–27
chaining, 426
collision, 425
collision resolution, 425
cryptographic hash functiom, 434
hash function, 424
hash table, 425
linear probing, 425
load factor, 427
Hasse diagram, 336, 479
Heap, 527
Heapsort algorithm, 527
Height of a tree, 510
Highway inspector problem, 554, 571
Hilbert, David, 772
Hilbert’s tenth problem, 772
Hoare, Anthony, 86
Hoare triple, 86
Homeomorphic graphs, 491
Homogeneous recurrence relation, 182
Homomorphism, 702
Hopkins, Brian, 571
Horn clause, 76
Horner’s method, 213
HTML, 788
Huffman code, 539–46
encoding algorithm, 542
JPEG compression, 547
prefix code, 541
Hypertext Markup Language, 788
Hypothesis of an argument, 25
Hypothetical syllogism, 33, 37
I
Idempotent property, 622
Identity element, 687
Identity function, 392
Identity matrix, 451
Identity permutation, 396
Identity property, 9, 234
Image under a function, 383
Immediate predecessor, 336
Implication, 3
Implication equivalence rule, 28
Improper subgroup, 700
Inclusive OR, 22
Inconsistency inference rule, 37
Independent events, 307
Index of summation, 182
Index set, 250
Induction
basis step, 111
equivalence to well-ordering, 119
first principle of, 110–12
inductive assumption, 112
inductive hypothesis, 112
inductive step, 111
proofs by, 112–18
second principle of, 118–22
structural induction, 164, 520
Inductive assumption, 112
Inductive definition, 158
Inductive hypothesis, 112
Inductive reasoning, 99
Inductive step, 111
Inference rules
addition, 29
conjunction, 29
contraposition, 37
definition of, 29
disjunctive syllogism, 37
distributive, 37
existential generalization, 59, 62
existential instantiation, 59, 60
exportation, 37
hypothetical syllogism, 33, 37
inconsistency, 37
modus ponens, 29
modus tollens, 29
resolution, 76
self-reference, 37
simplification, 29
universal generalization, 59, 61
universal instantiation, 59
Infinite sequence. See Sequence
Infix notation, 244, 518
Ingerman, P.Z, 788
Initial point, 478
Injective function, 389
Inorder tree traversal, 515
Input alphabet, 729
Integer overflow, 344
Intermediate statement, 43
Internal node in a tree, 510
Interpretation, 41
domain of, 41
Intersection of binary relations, 331
Intersection of sets, 231
Intractable problem, 417, 776
Inverse
of a binary relation, 350
of a function, 392–94
of an implication, 21
of a matrix, 452
Inverse element, 687
Inverse function, 393
Inverter, 12, 639
Invertible matrix, 452
IP address, 257
Irreflexive relation, 349
ISBN, 435
Isolated node, 481
Isomorphic Boolean algebras, 629
Isomorphic graphs, 484–87
Isomorphic groups, 702–8
Isomorphic partially ordered sets, 634
Isomorphic structures, 626
Isomorphic trees, 527
Isomorphism, 626
Iterative algorithm, 166
J
Join operation, 370
JPEG compression, 547
K
Karnaugh map, 665–72
steps in using, 669
k-equivalent states, 739

Index	
965
kernel of a homomorphism, 716
Kim, Deokhwan, 654
Kleene, Stephen, 737, 771
Kleene’s theorem, 737
Knight, John, 136
Knowledge-based system, 81
Koutis, Ioannis, 460
Kroeker, Kirk, 460
Kruskal’s algorithm, 594
Kuratowski, Kazimierz, 491
Kuratowski theorem, 491
L
Labeled graph, 479
Lagrange, Joseph-Louis, 701
Lagrange’s theorem, 701
Lamé, Gabriel, 217
Language. See also Formal language
alphabet, 782
context-free, 790
context-sensitive, 790
generated by a grammar, 784
over an alphabet, 782
palindrome, 797
pumping lemma, 798
regular, 790
type 0, 790
vocabulary, 782
word, 782
Lattice, 637
complemented, 637
distributive, 637
Leaf of a tree, 510
Least common multiple, 152
Least element, 338
Least upper bound, 637
Left cancellation law, 696
Left child node, 510
Left identity element, 712
Left inverse
of an element, 713
of a function, 408
Length of a string, 694
Level-order tree traversal, 606
Lexical analyzer, 794
Lexicographical ordering, 281, 351
L’Hôpital’s rule, 422
Linear bounded automaton (lba), 792
Linear combination, 144
Linear equations
definition of, 447
Gaussian elimination, 453–57
solving systems of, 453–57
Linear first-order recurrence relations, 
180–88
Linear probing, 425
Linear recurrence relation, 182
Linear second-order recurrence  
relations, 188–193
Linked list, 494
Little oh, 417
Load factor, 427
Logarithm function, 809–12
Logic. See also Formal logic
fuzzy, 23
many-valued, 23
three-valued, 23, 374
two-valued, 23
Logic network, 479, 638–53
AND gate, 639
canonical product-of-sums form, 
660
canonical sum-of-products form, 
643
combinational network, 638–48, 
744
conjunctive normal form, 660
delay element, 744
disjunctive normal form, 643
don’t-care condition, 653, 672
field-programmable gate array,  
647
flip-flop, 744
full-adder, 649
half-adder, 649
inverter, 639
Karnaugh map, 665–71
minimization, 663–77
multiplexor, 663
NAND gate, 650
NOR gate, 651
OR gate, 639
programmable logic device, 647
Quine–McCluskey procedure, 
673–77
sequential, 744–801
Logic programming, 73–82
Logical connective, 2–8
AND, 11, 75
conjunction, 2
disjunction, 3
equivalence, 3
implication, 3
negation, 4
NOT, 11, 75
OR, 11, 75
order of precedence, 6
and programming, 11
truth table, 3
XOR, 22
Loop in a graph, 481
Loop invariant, 130
Loop rule of inference, 129–33
definition of, 131
Lossy compression scheme, 547
Lower bound for sorting, 536
Lucas sequence, 174, 201
Lukasiewicz, J., 518
M
Machine. See Finite-state machine
Maclaurin series, 411
Main connective, 6
Main diagonal of a matrix, 447
Many-valued logic, 23
Map coloring problem, 506
Mapping. See Function
Markov, A., 771
Marley, Scott, 24
Master theorem, 417–21
proof of, 419–21
statement of, 418
Mathematical induction. See Induction
Mathematical structure, 619
Matrix, 446–59
addition, 449
augmented, 453
Boolean, 458–59
of coefficients, 447
cofactor of an element, 473
definition of, 446
determinant of, 473
diagonal, 463
dimensions of, 446
elementary row operations on, 454
equal, 447
Gaussian elimination, 453–57
identity, 451
inverse of, 452
invertible, 452
main diagonal, 447
minor of an element, 473
multiplication, 450
operations on, 448–53
scalar multiplication, 448
Strassen’s algorithm, 467
subtraction, 449
symmetric, 447
transpose of, 463
upper triangular, 453
zero, 449
Maximal element, 338
Mergesort algorithm, 215
Metadata, 366

966	
Index
Meynadier, Jean-Marc, 136
Miller, Gary, 460
Minimal element, 338
Minimization
of Boolean expressions, 645–47
of combinational network, 663–77
of finite-state machine, 737–44
Misailovic, Sasa, 654
Modular arithmetic, 692
Modular multiplicative inverse, 356
Modular property, 633
Modulo function, 386, 423–40
ABA routing number, 437
in cryptographic hashing, 434
to decompose integers, 438
to generate integer values, 437
for hashing, 427
ISBN, 435
modular arithmetic designs, 438
residue of x modulo n, 423
in RSA, 431
UPC-A, 436
Modus ponens, 27, 29
Modus tollens, 29
Monoid, 689
Morse code, 541
Multiplexor, 663
Multiplication modulo n, 692
Multiplication of matrices, 450
Multiplication principle, 252–53
definition of, 253
N
ℕ, 224
n factorial, 99, 272
NAND gate, 22, 650
n-ary predicate, 40
n-ary relation, 330
n-ary relation on a set, 356
Necessary condition, 4
Negation connective, 4
Negation of a statement, 5
Network. See Logic network
Netz, Reviel, 286
Next-state function, 729
Node, 337, 477, 478
Nondeterministic function, 411
Nondeterministic Turing machine, 777
Nonrooted tree, 509
NOR gate, 23, 651
NOT connective, 11, 75
NP, 777
NP-complete problem, 778
Null pointer, 495
Null set, 224
Number theory, 107, 143–51
Number theoretic function, 767
O
Odd node, 572
Odd number, 101
Odd permutation, 700
One-to-one function, 389
One-way encryption, 434
Only, 43
Only if, 4
Onto function, 388
Operation
binary, 228–30
unary, 230
Optimal algorithm, 533
OR connective, 11, 75
OR gate, 12, 639
Order of a group, 698
Order of magnitude, 412–21
big oh, 417
big theta, 413
definition of, 413
little oh, 417
master theorem, 418
Order of precedence, 6
Ordered pair, 228
Ore, Oystein, 580
Outer join, 369
Output alphabet, 729
Output function, 729
P
P
definition of, 777
and NP, 77–78
Page, Larry, 497
Palindrome, 163, 797
Palindrome language, 797
Papadimitriou, Christos, 211
Paradox, 69, 251
Parallel arcs, 481
Parent node in a tree, 509
Parity bit, 126, 733
Parse tree, 511, 793
Parsing
bottom-up, 794
top-down, 794
Partial correctness, 132
Partial function, 767
Partial ordering, 336–38
chain, 338
definition of, 336
greatest element, 338
greatest lower bound, 637
Hasse diagram, 336
immediate predecessor in, 336
lattice, 637
least element, 338
least upper bound, 637
maximal element, 338
minimal element, 338
predecessor in, 336
restriction of, 336
successor in, 336
total ordering, 338
Partially ordered set, 336
dual of, 350
Partition, 339
Partition refinement, 741
Pascal, Blaise, 294
Pascal’s formula, 295
Pascal’s triangle, 294–96
Password encryption, 433–35
Path
in a directed graph, 483
in a graph, 482
Pattern matching, 205
Peirce arrow, 23
Peng, Richard, 460
Pentagonal numbers, 200
Perfect square, 107
Perl, 757
Permutation function, 394–96
cycle notation, 395
definition of, 394
derangement, 396
disjoint cycles, 395
identity permutation, 396
Permutation group, 700
Permutations, 272–74
definition of, 272
eliminating duplicates, 279
generating, 282
with repetitions, 279
PERT chart, 357, 479
Petersen graph, 492
Phrase structure (type 0) grammar, 783
Pig latin, 797
Pigeonhole principle, 269
Plaintext, 428
Planar graph, 487–92
Plato, 154
Plaza, Jan, 186
Polish notation, 518
Polynomial, 690
Poset, 336
Post, E., 771
Postcondition, 86
Postfix notation, 244, 518

Index	
967
Postorder tree traversal, 515
Power set, 227
Precondition, 86
Predecessor, 336
Predicate, 39–42
binary, 40
definition of, 39
n-ary, 40
ternary, 40
unary, 40, 223
Predicate logic, 58–69
completeness of, 63, 773
correctness of, 63, 773
definition of, 58
derivation rules for, 58–62
valid argument in, 58
well-formed formula, 41
Predicate well-formed formula, 35, 41
validity of, 48
Prefix code, 541
Prefix notation, 518
Preimage, 383
Prenex normal form, 57
Preorder tree traversal, 514
Primary key, 367
Prime number, 107
Mersenne primes, 153
Prim’s algorithm, 587
Principle of inclusion and exclusion, 
150, 264–68, 300, 304
definition for n sets, 267
definition for three sets, 265
Principle of well-ordering, 119, 250, 702
Private key encryption, 431
Probability, 301–14
axioms, 304
Bayes’ theorem, 308–9, 321
Bernoulli trial, 313
binomial distribution, 313–14
birthday problem, 318
conditional, 306–7
equally likely outcomes, 302
event, 302
expected value, 310–12
independent events, 307
linearity of expected value, 312
probability distribution, 305
random variable, 310
sample space, 302
weighted average, 310
Probability distribution, 305
Procedural language, 73
Product notation, 807–08
Production, 783
Program testing, 85
Program validation, 85
Program verification, 84
Programmable logic device (PLD), 647
Programming language
declarative, 73
descriptive, 73
procedural, 73
Project operation, 369
Prolog, 73–81
database, 73
fact, 73
program, 73
query, 73
recursive rule, 80
rule, 75
rule of inference, 76
Proof by cases, 104
Proof of correctness, 84–92, 129–35
assertions, 85–87
assignment rule, 87–89
conditional rule, 90–92
definition of, 85
loop rule, 129–33
Proof sequence, 27
Proof techniques, 98–107
contradiction, 104–6
contraposition, 103–4
direct proof, 101–3
exhaustive proof, 100–101
indirect proof, 104
induction, 110–22
serendipity, 107
Proper subgroup, 700
Proper subset, 225
Proposition, 2
Propositional calculus, 25
Propositional logic, 25–35
completeness of, 32
correctness of, 32
definition of, 25
derivation rules for, 28–33
valid argument in, 25–28
well-formed formula, 25
Propositional well-formed formula,  
25
Pseudocode, 12
Public key encryption, 431
Pumping lemma, 798
Pushdown automaton (pda), 792
Pythagorean Society, 200
Q
ℚ, 224
Quantifier, 39–42
existential, 40
universal, 39
Queue, 599
dequeue, 599
enqueue, 599
Quicksort algorithm, 215
Quine–McCluskey procedure, 673–77
R
ℝ, 224
Random variable, 310
Range of a function, 388
Rational number, 105
Reachability, 557–62, 602
Reachability matrix, 559
Reachable node, 483, 557
Recaman’s sequence, 180
Recognition
by finite-state machine, 734
by Turing machine, 765
Recurrence relation,159, 180–97
characteristic equation of, 190
closed-form solution, 180
constant coefficients in, 182
definition of, 159
divide-and-conquer, 193–97
first-order, 182
general solution (divide-and- 
conquer), 196
general solution (first-order), 183
general solution (second-order),  
193, 196
homogeneous, 182
linear, 182
linear first-order, 182
second-order, 188
solving, 180
Recursion, 79–81, 158–71
recursive algorithm, 166–71
recursive definition, 79, 158
recursive operation, 165–66
recursive sequence, 158–62
recursive set, 162–64
Referential integrity, 375
Refinement of a partition, 354, 741
Reflexive relation, 332
Regular expression, 735
Regular (type 3) grammar, 790
Regular language, 790
Regular set, 736
Relation. See Binary relation
Relational algebra, 372
Relational calculus, 372
Relational database. See Database
Relatively prime, 146
Residue of x modulo n, 423
Resolution, 76

968	
Index
Restrict operation, 369
Restriction of a partial ordering, 336
Reverse Polish notation (RPN), 518
Right cancellation law, 696
Right child node, 510
Right identity element, 712
Right inverse
of an element, 713
of a function, 408
Rinard, Martin, 654
Rivest, Ron, 431
Root of a tree, 509
RSA public-key encryption  
algorithm, 431
Rule-based system, 81
Russell, Bertrand, 251
Russell’s paradox, 251
S
Sample space, 302
Satisfiability problem, 778
Scalar, 448
Scalar multiplication, 448
Scanner, 794
Scope of a quantifier, 41
Searching
binary search, 169
binary tree search, 352, 534
decision tree for, 529–35
by hash function, 425
lower bound for, 532–33
sequential search, 204, 415
Second principle of induction, 118–22, 
144, 160, 251
definition of, 118
Second-order recurrence relation, 188
Seemann, Glenn, 749
Selection sort algorithm, 169, 215
Self-complementary graph, 506
Self-reference inference rule, 37
Semigroup, 689
Semigroup of transformations, 693
Sequence
definition of, 158
Fibonacci, 159
recursive, 158–62
Sequential network, 744–48
definition of, 745
Sequential search algorithm, 204
Sequential search analysis, 205,  
207, 216
Serendipity, 106–7
Sets, 222–39
binary operation on, 229
binary relation on, 329
Cantor’s diagonalization  
method, 237
cardinality of, 236–39, 401
Cartesian product (cross product) 
of, 233
characteristic function of, 406
closure of, 229, 686
complement of, 232
countable, 236
denumerable, 236, 401
difference of, 232
disjoint, 232
empty, 224
equality of, 223
equivalent, 401–402
finite, 223
fuzzy, 250
identities, 233–36
intersection of, 231
membership, 222
n-ary relation on, 330
notation, 222–24
null, 224
operations on, 230–33
partial ordering on, 336
partially ordered, 336, 634
partition of, 339
permutations of, 394
power set of, 227
proper subset of, 225
recognition by finite-state  
machine, 734
recognition by Turing machine, 765
subset of, 224
symmetric difference of, 248
unary operation on, 230
uncountable, 236
union, 231
universal, 231
Shamir, Adi, 431
Shannon, Claude, 638
Sharan, Roded, 497
Sheffer stroke, 22
Sieve of Eratosthenes, 154
Simple closed polygon, 127, 263
triangulation of, 263
Simple graph, 481
Simple statement, 2
Simple substitution cipher, 429
Simplex method, 417
Simplification inference rule, 29
Six-color theorem, 508
Sloane, Neil, 179
Smorynski function, 407
Smullyan, Raymond, 25, 771
Sorting
bubble sort, 214
decision tree for, 535–36
heapsort, 527
lower bound for, 536
mergesort, 215
quicksort, 215
selection sort, 169, 215
Spanning tree, 587, 601
Sparse adjacency  
matrix, 494
SQL, 372
Square numbers, 200
Stack, 167, 409
pop instruction, 409
push instruction, 409
stack overflow, 167
Standard sets, 224
Start symbol, 783
State graph, 730
State table, 730
Statement, 2
Statement letter, 2
Statement logic, 25
Stewart, Ian, 174
Stirling numbers, 355
Stirling’s triangle, 355
Strassen’s algorithm, 467
String, 694
binary, 163
concatenation, 163
empty, 163
palindrome, 163
pattern matching, 205
Structural induction, 164, 520
Subgraph, 482
Subgroup, 699
Subset, 224
Subtraction of matrices, 449
Successor, 336
Sudoku, 154
Sufficient condition, 4
Summation notation, 182, 805–07
Sun-Tsu, 445
Surrogate key, 368
Swift, Jonathan, 550
Symbol, 694
Symbol table, 441
Symbolic logic, 68
Symmetric difference of sets, 248
Symmetric encryption, 431
Symmetric matrix, 447
Symmetric relation, 332
Syntax analyzer, 794
Syntax rule, 6

Index	
969
T
Tape alphabet, 762
Tautological equivalence, 9
associative property, 9
commutative property, 9
complement property, 9
distributive property, 9
identity property, 9
Tautology, 8–10
definition of, 8
Temporary hypothesis, 64
Terminal, 783
Terminal point, 478
Ternary predicate, 40
Ternary tree, 537
Theorem, 98, 773
Three-valued logic, 23, 374
Tiling problem, 117
Token, 163
Top down parsing, 794
Topological sorting, 356–61, 602
definition of, 359
Total function, 767
Total ordering, 338
Towers of Hanoi, 179, 199
Transitive relation, 332
Transpose of a matrix, 463
Transposition, 700
Traveling salesman problem, 554, 577
Tree, 353, 509–21
applications of, 511–12
binary, 510
binary search, 534
B-tree, 526
child node, 509
complete binary, 510
decision tree, 257–58, 529–36
definition of, 509
depth of, 510
depth of a node, 510
forest, 510
free, 509
full binary, 510
height of, 510
inorder traversal, 515
internal node in, 510
isomorphic, 527
leaf of, 510
left child in, 510
left child-right child  
representation, 513
level-order traversal, 606
nonrooted, 509
parent node, 509
postorder traversal, 515
preorder traversal, 514
right child in, 510
root, 509
ternary, 537
traversal, 514
Tree arc, 608
Tree traversal, 514
Triangular numbers, 200
Triangulation of a convex polygon, 263
Truth function, 640
Truth table, 3
Tuple, 366
Turing, Alan M., 428, 760, 771
Turing computable function, 768
Turing machine, 759–78
acceptance by, 765
Church–Turing thesis, 770
decision problem, 771–76
definition of, 762
final state, 765
as function computer, 767–69
halting problem, 774
nondeterministic, 777
NP, 777
NP-complete problem, 778
P, 777
recognition by, 765
as set recognizer, 764–67
tape alphabet, 762
unsolvability of halting problem, 
774
Two’s complement, 660
Two-valued logic, 23
Type 0 language, 790
U
Unary connective, 3
Unary operation, 230
Unary predicate, 40, 223
Uncomputability, 771–76
Uncomputable problem, 772
Uncountable set, 236
Undecidable problem, 772
Union of binary relations, 331
Union of sets, 231
Universal bound property, 624
Universal generalization, 59, 61
Universal instantiation, 59
Universal quantifier, 39
Universal set, 231
Universe of discourse, 231
Unreachable state, 737
Unsolvability of the halting  
problem, 774
Unsolvable problem, 772
UPC-A (Universal Product Code), 436
Upper bound, 210
Upper triangular matrix, 453
V
Valid argument
in predicate logic, 58
in propositional logic, 25–28
Valid predicate wff, 48
Vandermonde’s identity, 293
Vector, 448
dot product of, 463
magnitude of, 463
Venn, John, 231
Venn diagram, 231
Vertex, 337, 477, 478
Vocabulary, 782
W
Warshall’s algorithm, 562–65
analysis of, 565
Weighted average, 310
Weighted graph, 479
Well-balanced parentheses, 780
Well-defined binary operation, 229
Well-formed formula (wff), 6
comparison of propositional and 
predicate, 48
equivalent, 8
predicate, 35, 41
propositional, 25
Well-ordering principle, 119, 250, 702
Wff. See Well-formed formula
Wiles, Andrew, 143
Wilson, Robin, 571
Word, 694, 782
X
XML, 788
XOR, 22
Y
Yin, Xiang, 136
Z
ℤ, 224
Zero matrix, 449
Zero-degree polynomial, 691

