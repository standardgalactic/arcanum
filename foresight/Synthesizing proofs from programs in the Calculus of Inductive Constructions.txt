Laboratoire de lâ€™Informatique du ParallÃ©lisme
Ecole Normale SupÃ©rieure de Lyon
UnitÃ© de recherche associÃ©e au CNRS nÂ°1398 
Syn
thesizing
pro
ofs
from
programs
in
the
Calculus
of
Inductiv
e
Constructions
Catherine
P
aren
t
Decem
b
er
		
Researc
h
Rep
ort
N
o
	-
Ecole Normale SupÃ©rieure de Lyon
Adresse Ã©lectronique : lip@lip.ensâˆ’lyon.fr 
TÃ©lÃ©phone : (+33) 72.72.80.00    TÃ©lÃ©copieur : (+33) 72.72.80.80
46 AllÃ©e dâ€™Italie, 69364 Lyon Cedex 07, France

Syn
thesizing
pro
ofs
from
programs
in
the
Calculus
of
Inductiv
e
Constructions
Catherine
P
aren
t
Decem
b
er
		
Abstract
In
t
yp
e
theory
,
a
pro
of
can
b
e
represen
ted
as
a
t
yp
ed
-term
[Con
,
NPS	0].
There
exist
metho
ds
to
mark
logical
parts
in
pro
ofs
and
extract
their
algorithmic
con
ten
ts.
The
result
is
a
correct
program
with
resp
ect
to
a
sp
ecication.
This
pap
er
fo
cuses
on
the
in
v
erse
problem
:
ho
w
to
generate
a
pro
of
from
its
sp
ecication.
The
framew
ork
is
the
Calculus
of
Inductiv
e
Constructions
[Co
q
].
A
notion
of
coherence
is
in
tro
duced
b
et
w
een
a
sp
ecication
and
a
program
con
taining
t
yp
es
but
no
logical
pro
ofs.
This
notion
is
based
on
the
denition
of
an
extraction
function
called
the
w
eak
extraction.
Suc
h
a
program
can
giv
e
a
metho
d
to
reconstruct
a
set
of
logical
prop
erties
needed
to
ha
v
e
a
pro
of
of
the
initial
sp
ecication.
This
can
b
e
seen
either
as
a
metho
d
of
pro
ving
programs
or
as
a
metho
d
of
syn
thetically
describing
pro
ofs.
Keyw
ords:
program
pro
ving,
extraction,
Calculus
of
Constructions,
lam
b
da-calculus
R

esum

e
En
th

eorie
des
t
yp
es,
une
preuv
e
p
eut
^
etre
repr

esen
t

ee
par
un
-terme
t
yp

e
[Con
,
NPS	0].
Di

eren
tes
m

etho
des
on
t

et

e
d

enies
p
our
annoter
les
parties
logiques
des
preuv
es
et
extraire
leur
con
ten
u
algorithmiq
ue.
Il
en
r

esulte
un
programme
correct
vis-
a-vis
d'une
sp

ecication.
Ce
papier
s'in
t

eresse
au
probl

eme
in
v
erse
:
commen
t
engendrer
une
preuv
e

a
partir
de
sa
sp

eci-
cation.
Le
cadre
est
le
Calcul
des
Constructions
Inductiv
es
[Co
q
].
Une
notion
de
coh

erence
en
tre
une
sp

ecication
et
un
programme
con
tenan
t
des
t
yp
es
mais
pas
de
preuv
es
logiques
est
in
tro
duite.
Cette
notion
est
bas

ee
sur
la
d

enition
d'une
fonction
d'extraction
app
el

ee
fonction
d'extraction
faible.
Un
tel
programme
fournit
une
m

etho
de
de
reconstruction
d'un
ensem
ble
de
propri

et

es
logiques
qui
doiv
en
t
^
etre
v

eri

ees
p
our
retrouv
er
une
preuv
e
de
la
sp

ecication
initiale.
Il
s'agit
donc

a
la
fois
d'une
m

etho
de
de
preuv
es
de
programmes
et
d'une
m

etho
de
de
description
syn
th

etique
de
preuv
es.
Mots-cl

es:
preuv
es
de
programmes,
extraction,
Calcul
des
Constructions,
lam
b
da-calcul

Syn
thesizing
pro
ofs
from
programs
in
the
Calculus
of
Inductiv
e
Constructions
Catherine
P
aren
t

LIP
,
URA
CNRS
	,
ENS
Ly
on

All

ee
d'Italie,
	
Ly
on
cedex
0,
F
rance
e-mail
:
pa
rent@lip.ens-ly
on.fr
Decem
b
er
		
Abstract
In
t
yp
e
theory
,
a
pro
of
can
b
e
represen
ted
as
a
t
yp
ed
-term
[Con,
NPS	0].
There
exist
metho
ds
to
mark
logical
parts
in
pro
ofs
and
extract
their
algorithmic
con
ten
ts.
The
result
is
a
correct
program
with
resp
ect
to
a
sp
ecication.
This
pap
er
fo
cuses
on
the
in
v
erse
problem
:
ho
w
to
generate
a
pro
of
from
its
sp
ecication.
The
framew
ork
is
the
Calculus
of
Inductiv
e
Constructions
[Co
q].
A
notion
of
coherence
is
in
tro
duced
b
et
w
een
a
sp
ecication
and
a
program
con
taining
t
yp
es
but
no
logical
pro
ofs.
This
notion
is
based
on
the
denition
of
an
extraction
function
called
the
w
eak
extraction.
Suc
h
a
program
can
giv
e
a
metho
d
to
reconstruct
a
set
of
logical
prop
erties
needed
to
ha
v
e
a
pro
of
of
the
initial
sp
ecication.
This
can
b
e
seen
either
as
a
metho
d
of
pro
ving
programs
or
as
a
metho
d
of
syn
thetically
describing
pro
ofs.

In
tro
duction
This
pap
er
talks
ab
out
automation
of
pro
ofs
ab
out
functional
programs
correctness
with
resp
ect
to
a
sp
ec-
ication.
The
framew
ork
is
the
Calculus
of
Inductiv
e
Constructions
[Co
q
,
PM	b]
whic
h
is
a
t
yp
ed
-calculus
with
p
olymorphism,
higher-order
and
dep
enden
t
t
yp
es.
W
e
fo
cus
on
the
Co
q
[DFH
+
	
]
system
whic
h
is
an
implemen
tation
of
this
calculus.
It
is
a
system
for
formalizing
and
c
hec
king
the
mathematical
reasoning
[Bar	
,
ML
].
It
con
tains
a
sp
ecication
language
and
a
programming
language.
By
the
Curry-Ho
w
ard
isomorphism
[Ho
w0
],
a
pro
of
can
b
e
represen
ted
b
y
a
t
yp
ed
-term
whose
t
yp
e
is
the
prop
osition
that
it
pro
v
es.
In
the
Calculus
of
Inductiv
e
Constructions,
the
sp
ecication
of
a
program
is
regarded
as
a
prop
osition.
As
an
example,
the
euclidean
division
can
b
e
seen
as
a
transformation
taking
t
w
o
natural
n
um
b
ers
a
and
b,
a
pro
of
of
b
>
0,
and
yielding
a
quotien
t
q
,
a
rest
r
,
a
pro
of
of
b
>
r
and
a
pro
of
a
=
b

q
+
r
.
The
sp
ecication
of
the
division
is
then
a;
b:(b
>
0)
!
	q
;
r
:(a
=
b

q
+
r
)
^
(b
>
r
).
A
wide
class
of
sp
ecications
can
b
e
describ
ed
b
y
a
form
ula
of
the
form
x:(P
x)
!
	y
:(Q
x
y
).
A
pro
of
represen
ts
a
functional
program
whic
h
v
alidates
the
sp
ecication.
Ho
w
ev
er,
in
general,
to
ha
v
e
more
ecien
t
programs,
all
the
parts
of
a
term
that
compute
the
pro
of
rather
than
the
result
itself
are
suppressed.
This
is
the
principle
of
an
extraction
function
[PM	b
,
PM	a]
that
suppresses
some
parts
of
pro
ofs
and
that
w
e
call
the
strong
extraction.
In
the
previous
example,
a
large
part
of
the
pro
of
is
dev
oted
to
c
hec
k
that
q
and
r
v
erify
the
prop
ert
y
a
=
b

q
+
r
^
b
>
r
.
Suc
h
a
pro
of
con
tains
computational
parts
(to
construct
q
and
r
in
our
example)
and
logical
parts
(to
pro
v
e
a
=
b

q
+
r
in
our
example).
An
extraction
function
forgets
all
the
non-computational
parts
of
a
pro
of
to
giv
e
a
program.
Eac
h
dieren
t
pro
of
then
corresp
onds
to
a
dieren
t
program.
Indeed,
there
can
b
e
man
y
dieren
t
pro
ofs
for
a
sp
ecication
of
a
sort
algorithm.
Eac
h
dieren
t
pro
of
can
giv
e
a
dieren
t
algorithm
for
sorting
a
list.
It
is
also
imp
ortan
t
to
note
that
an
extracted
program
is
a
sk
eleton
of
its
corresp
onding
pro
of.
F
or
the
example
of
the
division,
the
ML
program
could
b
e
:

This
researc
h
w
as
partly
supp
orted
b
y
ESPRIT
Basic
Researc
h
Action
\T
yp
es
for
Pro
ofs
and
Programs"
and
b
y
Programme
de
Rec
herc
he
Co
ordonn

ees
and
CNRS
Group
emen
t
de
Rec
herc
he
\Programmati
on"
.


let
rec
div
a
b
=
match
a
with
0
->
(0,0)
|
n+
->
let
(q,r)
=
div
n
b
in
if
b<=(r+)
then
(q+,0)
else
(q,r+)
;;
In
this
pap
er,
w
e
fo
cus
on
the
in
v
erse
problem.
W
e
w
an
t
to
retriev
e
a
pro
of
from
an
extracted
program.
Ob
viously
,
there
is
no
hop
e
to
syn
thesize
all
the
forgotten
pro
ofs
but
our
goal
is
to
syn
thesize
at
least
the
t
yp
es
of
the
missing
pro
ofs.
This
approac
h
has
already
b
een
form
ulated
in
a
preceden
t
pap
er
[P
ar	
].
This
previous
v
ersion
w
as
only
an
empirical
explanation
of
a
tactic
implemen
ted
in
Co
q.
In
this
pap
er,
w
e
presen
t
a
more
rigorous
explanation.
In
fact,
logical
informations
can
b
e
retriev
ed
from
a
program
and
the
main
part
of
the
pro
of
can
b
e
reconstructed.
A
recurrence
in
the
program
corresp
onds
to
an
induction
in
the
pro
of.
A
test
in
the
program
corresp
onds
to
a
case
analysis
in
the
pro
of.
Then,
subsp
ecications
can
b
e
retriev
ed
from
the
initial
sp
ec-
ication.
Logical
informations
can
b
e
retriev
ed.
In
the
division
example,
the
follo
wing
can
b
e
retriev
ed
:
let
rec
div
a
b
=
match
a
with
0
->
f
(0
=
b

q
+
r
)
^
(b
>
r
)
g
(0,0)
|
n+
->
f
	q
;
r
(n
=
b

q
+
r
)
^
(b
>
r
)
!
	q
;
r
(n
+

=
b

q
+
r
)
^
(b
>
r
)
g
let
(q,r)
=
div
n
b
in
f
(n
+

=
b

q
+
r
)
^
(b
>
r
)
g
if
b<=(r+)
then
f
(n
+

=
b

(q
+
)
+
0)
^
(b
>
0)
g
(q+,0)
else
f
(n
+

=
b

q
+
r
+
)
^
(b
>
r
+
)
g
(q,r+);;
With
the
aim
of
retrieving
a
pro
of
from
a
program
and
its
sp
ecication,
a
new
extraction
function
called
the
w
eak
extraction
is
dened.
The
strong
extraction
applies
on
terms
and
t
yp
es.
It
suppresses
in
b
oth
of
them
all
logical
terms.
The
w
eak
extraction
applies
only
on
terms
and
k
eeps
all
the
informations
in
t
yp
es.
Then,
a
new
notion
of
t
yping
on
w
eak
extracted
terms
is
necessary
.
It
can
b
e
pro
v
ed
that
a
program,
coheren
t
with
a
giv
en
sp
ecication,
can
b
e
transformed
in
to
a
pro
of
of
an
equiv
alen
t
sp
ecication
mo
dulo
some
logical
lemmas.
This
corresp
onds
to
in
v
ert
the
w
eak
extraction.
This
problem
is
not
simple
b
ecause
the
framew
ork
is
v
ery
general.
The
Calculus
of
Inductiv
e
Construc-
tions
is
a
p
o
w
erful
language.
Some
restrictions
on
the
pro
of
system
ha
v
e
to
b
e
made.
Giv
en
a
program
p
that
is
exactly
a
trace
of
a
pro
of
P
,
it
can
b
e
pro
v
ed
that
the
generated
logical
lemmas
ha
v
e
a
pro
of
in
P
.
This
metho
d
is
the
basis
of
an
eectiv
e
heuristic
metho
d
corresp
onding
to
a
tactic
in
the
Co
q
system
describ
ed
in
[P
ar	
].
This
heuristic
metho
d
considers
strong
extracted
programs
and
syn
thesizes
t
yp
es
b
y
unication
from
the
initial
sp
ecication.
The
plan
is
in
three
main
parts.
First,
w
e
presen
t
the
Calculus
of
Inductiv
e
Constructions
and
the
extraction
of
[PM	b
].
Secondly
,
w
e
sho
w
the
w
eak
extraction,
wh
y
and
ho
w
it
can
b
e
in
v
erted.
Thirdly
,
w
e
explain
a
deriv
ed
heuristic
metho
d
as
a
consequence
of
the
in
v
ersion.

Extraction
in
the
Calculus
of
Inductiv
e
Constructions
This
section
presen
ts
the
framew
ork.
The
pro
of
language
is
the
Calculus
of
Inductiv
e
Constructions.
W
e
rst
presen
t
the
Pure
Calculus
of
Constructions
and
ho
w
it
can
b
e
extended
with
primitiv
e
inductiv
e
t
yp
es.
Then,
w
e
explain
the
motiv
atio
ns
for
extracting
programs
and
presen
t
the
extraction
of
[PM	a].
.
The
Calculus
of
Constructions
W
e
presen
t
a
v
arian
t
of
the
standard
Calculus
of
Constructions
due
to
[PM	b].
In
this
v
arian
t,
t
w
o
sorts
are
distinguished
:
S
et
:
T
y
peS
et
and
P
r
op
:
T
y
pe
.
These
t
w
o
sorts
allo
w
to
separate
computational
terms


and
logical
terms
b
y
marking
them.
T
erms
mark
ed
with
Set
are
computational
terms
and
terms
mark
ed
with
Pr
op
are
logical
terms.
The
inference
rules
for
the
calculus
are
then
the
follo
wing.
Denitio
n

[]
w
el
l
f
or
med
 `
A
:
s
 [x
:
A]
w
el
l
f
or
med
s

S
=
fS
et
;
P
r
op
;
T
y
peS
et
;
T
y
pe
g
 w
el
l
f
or
med
 `
S
et
:
T
y
peS
et
 w
el
l
f
or
med
 `
P
r
op
:
T
y
pe
 w
el
l
f
or
med
x
:
A

  `
x
:
A
 `
A
:
s
 [x
:
A]
`
B
:
s
0
 `
(x
:
A)B
:
s
0
(s;
s
0
)

R
=
S

S
 `
t
:
(x
:
A)B
 `
t
0
:
A
 `
(t
t
0
)
:
B
[x
 
t
0
]
 `
A
:
s
 `
A
0
:
s
 `
t
:
A
A
=

A
0
 `
t
:
A
0
s

S
.
Inductiv
e
T
yp
es
The
Calculus
of
Constructions
is
a
p
o
w
erful
language.
W
e
consider
the
Calculus
of
Constructions
without
univ
erses.
Since
data
t
yp
es
cannot
b
e
easily
co
ded
in
this
calculus,
w
e
consider
the
addition
of
primitiv
e
inductiv
e
t
yp
es.
This
allo
ws
to
dene
data
t
yp
es
in
a
more
natural
w
a
y
.
This
section
presen
ts
the
syn
tax
and
rules
for
inductiv
e
t
yp
es.
Our
presen
tation
is
m
uc
h
inspired
of
[PM	
,
PC	],
but
w
e
do
an
explicit
treatmen
t
of
the
parameters
of
inductiv
e
t
yp
es.
In
[PM	
],
inductiv
e
t
yp
es
are
presen
ted
without
parameters
and
these
ones
are
treated
as
-abstractions.
Denitio
n

Inductive
T
yp
es
:
T
::=
I
nd[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
Ar
)fc

:
C

j
:
:
:
jc
m
:
C
m
g
Ar
is
an
arity,
p
i
ar
e
the
p
ar
ameters
of
the
inductive
typ
e,
n
the
numb
er
of
p
ar
ameters
and
c
i
the
c
onstructors
of
the
inductive
typ
e.
Denitio
n

Syntax
for
the
typ
e
of
c
onstructors
:
C
o
::=
X
j
(C
o
m)
j
(P
!
C
o)
j
(x
:
M
)C
o
with
X
not
app
e
aring
in
m
nor
in
M
and
P
strictly
p
ositive
w.r.t.
X
.
Denitio
n

A
term
is
strictly
p
ositive
with
r
esp
e
ct
to
X
if
it
has
the
fol
lowing
syntax
:
P
os
::=
X
j
(P
os
m)
j
(x
:
M
)P
os
Denitio
n

Constructors
:
T
::=
Constr(i;
T
)
Examples
:

The
	
connectiv
e
can
b
e
dened
b
y
:
sig
:=
I
nd[A
:
S
et
;
P
:
A
!
P
r
op
](X
:
S
et
)fexist
:
(x
:
A)(P
x)
!
X
g



The
_
connectiv
e
can
b
e
dened
b
y
:
sumor
:=
I
nd[A
:
S
et
;
B
:
P
r
op
](X
:
S
et
)finl
ef
t
:
A
!
X
j
inr
ig
ht
:
B
!
X
g
The
inductiv
e
t
yp
e
sumor
is
a
sim
ulation
for
exceptions.
Indeed,
this
is
a
sum
t
yp
e.
The
rst
comp
onen
t
has
a
computational
sense
(mark
ed
with
Set)
and
the
second
a
logical
sense
(mark
ed
with
Pr
op).
The
rst
comp
onen
t
con
tains
the
result
if
it
exists,
the
second
sim
ulates
the
raise
of
an
exception.
Notations
:
W
e
note
c
onstructor(C
i
;
X
)
for
C
i
is
a
c
onstructor
w.r.t.
X
.
A
v
ectorial
notation
is
used
for
lists
of
v
ariables.
W
e
note
~
a
for
a

:
:
:
a
n
and
(
~
a
:
~
A)t
for
(a

:
A

)
:
:
:
(a
n
:
A
n
)t.
Then,
a
notion
of
elimination
can
b
e
dened.
Denitio
n

Elimination
:
T
::=
Elim(c;
Q)ff

j
:
:
:
jf
n
g
wher
e
c
is
the
term
on
which
the
elimination
is
done,
Q
the
typ
e
of
the
elimination
term
and
f
i
the
dier
ent
br
anches
of
the
elimination.
There
are
t
w
o
kinds
of
eliminations
:
the
dep
enden
t
elimination
(D
ep(s;
s
0
))
and
the
non-dep
enden
t
elimination
(N
odep(s;
s
0
)).
The
non-dep
enden
t
one
is
a
particular
case
of
the
dep
enden
t
one.
It
corresp
onds
to
the
situation
where
the
prop
osition
to
b
e
pro
v
ed
do
es
not
dep
end
on
the
term
on
whic
h
the
elimination
is
done.
W
e
presen
t
here
only
the
dep
enden
t
elimination.
F
or
this,
a
preliminary
denition
is
needed.
Denitio
n

Given
s
and
s'
two
sorts,
A

(
~
x
:
~
A)s,
X
a
variable
of
typ
e
A,
Q
a
variable
of
typ
e
(
~
x
:
~
A)(X
~
x)
!
s
0
,
C
a
c
onstructor
typ
e
w.r.t.
X
and
c
a
term
of
typ
e
C
,
we
dene
a
new
typ
e
note
d
C
fX
;
Q;
cg
by
induction
on
C
:
(P
!
C
)fX
;
Q;
cg
=
(p
:
P
)P
fX
;
Q;
pg
!
C
fX
;
Q;
(c
p)g
X
in
P
(x
:
M
)C
fX
;
Q;
cg
=
(x
:
M
)C
fX
;
Q;
(c
x)g
X
not
in
M
(X
~
a)fX
;
Q;
cg
=
(Q
~
a
c)
Then,
three
new
rules
are
dened
for
t
yping
an
inductiv
e
t
yp
e,
a
constructor
and
an
elimination.
Denitio
n

Inductive
T
yp
es
in
the
Calculus
of
Constructions
:
(i
=

:
:
:
m)
 [p
j
:
P
j
]
`
A
:
s
 [p
j
:
P
j
;
X
:
A]
`
C
i
:
s
0
c
onstructor(C
i
;
X
)
 `
Ind[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
A)fc

:
C

j
:
:
:
jc
m
:
C
m
g
:
(p

:
P

)
:
:
:
(p
n
:
P
n
)A
for
s
an
arity
 `
I
nd

Ind[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
A)fc

:
C

j
:
:
:
jc
m
:
C
m
g
:
(p

:
P

)
:
:
:
(p
n
:
P
n
)A


i

m
 `
Constr(i;
I
nd)
:
(p

:
P

)
:
:
:
(p
n
:
P
n
)C
i
[X
 
(I
nd
p

:
:
:
p
n
)]
 `
c
:
(I
~
p
~
a)
 `
Q
:
(
~
x
:
~
A)(I
~
p
~
x)
!
s
0
(i
=

:
:
:
m)
 `
f
i
:
C
i
f(I
~
p);
Q;
(Constr
(i;
I
)
~
p)g
 `
Elim(c;
Q)ff

j
:
:
:
jf
m
g
:
(Q
~
a
c)
The
rules
of
elimination
are
parametered
b
y
t
w
o
sorts
s
and
s
0
.
s
is
the
sort
of
the
arit
y
of
the
inductiv
e
t
yp
e
and
s
0
the
sort
of
the
t
yp
e
of
the
elimination
predicate.
Not
all
the
p
ossibilities
for
s
and
s
0
are
allo
w
ed.
In
practice,
only
four
rules
are
considered
:
D
ep(S
et
;
S
et),
D
ep(S
et
;
P
r
op
),
N
odep(P
r
op
;
P
r
op
)
and
N
odep(S
et
;
T
y
pe).
The
three
rst
ones
are
called
w
eak
eliminations
since
they
are
at
the
Set/Pr
op
lev
el.
The
last
one
is
called
a
strong
eliminatio
n
since
it
is
at
the
T
yp
e
lev
el.
Note
that
the
rst
w
eak
elimination
is
informativ
e
and
the
t
w
o
other
ones
are
logical.
The
strong
elimination
is
logical.
There
is
a
particular
notion
of
reduction
on
inductiv
e
t
yp
es
called
the
-reduction
that
w
e
do
not
detail
here.
A
denition
of
this
reduction
can
b
e
found
in
[PM	
].


Example
:
Let
us
giv
e
an
example
on
lists.
W
e
sho
w
an
elimination
to
illustrate
the
denition

and
an
example
of
-reduction.
The
inductiv
e
t
yp
e
l
ist
has
one
parameter
corresp
onding
to
the
t
yp
e
of
the
elemen
ts.
If
A
:
S
et
is
this
parameter,
then
an
elimination
predicate
Q
on
lists
is
of
t
yp
e
(l
ist
A)
!
S
et
.
The
elimination
has
t
w
o
cases
f

and
f

with
the
follo
wing
t
yp
es
:
f

:
X
f(l
ist
A);
Q;
(nil
A)g
=
(Q
(nil
A))
f

:
(A
!
X
!
X
)f(l
ist
A);
Q;
(cons
A)g
=
(x
:
A)Af(l
ist
A);
Q;
xg
!
(X
!
X
)f(l
ist
A);
Q;
(cons
A
x)g
=
(x
:
A)(l
:
(l
ist
A))X
f(l
ist
A);
Q;
l
g
!
X
f(l
ist
A);
Q;
(cons
A
x
l
)g
=
(x
:
A)(l
:
(l
ist
A))(Q
l
)
!
(Q
(cons
A
x
l
))
The
-reduction
corresp
onds
to
the
follo
wing
reduction
for
the
t
w
o
cases
nil
and
cons
:
Elim(nil
A;
Q)ff

jf

g


f

Elim(cons
A
x
l
;
Q)ff

jf

g


(f

x
l
Elim(l
;
Q)ff

jf

g)
Co
q
notations
:
W
e
presen
t
here
the
Co
q
syn
tax
for
some
particular
inductiv
e
t
yp
es
and
for
eliminations.
This
syn
tax
will
b
e
used
in
the
follo
wing
sections.
A+{B}
is
the
syn
tax
for
(sumor
A
B
).
{x:A|P(x)}
is
the
syn
tax
for
(sig
A
[x
:
A](P
x)).
<P>Match
c
with
f...fn
end
is
the
syn
tax
for
Elim(c;
P
)ff

j
:
:
:
jf
n
g.
.
The
strong
extraction
function
A
pro
of
is
a
v
ery
inecien
t
program.
F
or
the
division
example,
a
program
do
not
need
to
k
eep
the
pro
of
of
a
=
b

q
+
r
.
The
extraction
of
[PM	b
]
consists
in
forgetting
all
the
logical
parts
of
the
pro
of.
These
parts
ha
v
e
b
een
mark
ed
b
y
the
programmer
initially
with
P
r
op
for
logical
parts
and
S
et
for
computational
(or
informativ
e)
parts.
Moreo
v
er,
dep
enden
t
t
yp
es
are
suppressed.
Then,
resulting
terms
are
t
ypable
in
the
system
F
!
I
nd
[Gir
,
PM	b].
F
!
I
nd
corresp
onds
to
the
Calculus
of
Inductiv
e
Constructions
with
only
S
et
:
T
y
peS
et
and
without
the
rule
(S
et
;
T
y
peS
et
).
This
corresp
onds
to
a
calculus
without
the
p
ossibilit
y
for
t
yp
es
to
dep
end
on
terms.
A
preliminary
denition
of
lev
el
on
terms
is
needed.
Indeed,
terms
and
t
yp
es
are
nested
in
the
Calculus
of
Constructions.
Lev
els
can
b
e
in
tro
duced
and
are
giv
en
b
y
the
t
yping.
Indeed,
if
 `
M
:
N
then
either
N
:
T
y
pe
(S
et
)
or
	s
s.t.
N
:
s.
Three
lev
els
can
then
b
e
dened.
Denitio
n
	
L
evels
of
terms
:

A
term
is
of
level
0
if
it
is
an
arity.
This
is
the
domain
of
pr
op
ositional
typ
es.

A
term
is
of
level

if
its
typ
e
is
of
level
0.
This
is
the
domain
of
pr
op
ositional
schemes
or
pr
e
dic
ates.

A
term
is
of
level

if
its
typ
e
is
of
level
.
This
is
the
domain
of
pr
o
ofs.
Remarks
:

T
y
pe
and
T
y
peS
et
ha
v
e
lev
el
-.

Eac
h
term
has
a
unique
lev
el
dened
b
y
its
t
yp
e.

(B
A),
(x
:
A)B
and
[x
:
A]B
ha
v
e
the
same
lev
el
than
B
.



In
(x
:
A)B
and
[x
:
A]B
,
A
has
necessarily
lev
el
0
or
.

In
(B
A),
A
has
lev
el
0,

or
.
Examples
:

Lev
el
0
:
if
A
is
a
t
yp
e,
A
!
S
et
has
lev
el
0.

Lev
el

:
if
A
and
B
are
t
yp
es
(but
B
not
an
arit
y),
then
(x
:
A)B
and
[x
:
A]B
ha
v
e
lev
el
.
Inductiv
e
t
yp
es
and
the
strong
eliminatio
n
ha
v
e
lev
el
.

Lev
el

:
constructors
of
inductiv
e
t
yp
es
and
w
eak
eliminations
ha
v
e
lev
el
.
The
arithmetical
v
ariable
+
:
nat
!
nat
!
nat
has
lev
el

if
one
supp
oses
that
the
t
yp
e
nat
is
an
inductiv
e
t
yp
e
with
t
w
o
constructors
0
and
S
.
Then,
the
term
[x
:
nat](+
x
(S
0))
has
lev
el
.
The
prop
ert
y
for
a
term
to
b
e
informativ
e
(computational)
or
logical
can
no
w
b
e
formally
dened.
Denitio
n
0
Informative
arity
:
A
n
informative
arity
is
a
term
with
the
fol
lowing
syntax
:
I
nf
Ar
::=
S
et
j
(x
:
M
)I
nf
Ar
Denitio
n

Informative
term,
lo
gic
al
term
:

A
term
of
level
0
is
informative
if
it
is
an
informative
arity.

A
term
of
level

is
informative
if
its
typ
e
is
an
informative
arity
or
if
the
typ
e
of
its
typ
e
is
T
yp
eSet.

A
term
of
level

is
informative
if
the
typ
e
of
its
typ
e
is
Set.
A
term
is
lo
gic
al
if
it
is
not
informative.
The
extraction
function
of
[PM	b]
can
no
w
b
e
presen
ted.
In
the
follo
wing,
w
e
refer
to
this
function
as
the
strong
extraction
function.
In
tuitiv
ely
,
this
function
suppresses
all
the
logical
informations
from
a
pro
of
term.
Moreo
v
er,
it
suppresses
all
the
dep
endences
of
t
yp
es
with
terms.
This
function
can
b
e
applied
only
on
informativ
e
terms.
Then,
for
instance,
the
strong
extraction
can
nev
er
b
e
applied
to
a
strong
elimination.
Notation
:
the
application
of
a
constructor
to
its
parameters
is
treated
as
a
particular
case.
Indeed,
in
an
application,
all
the
informativ
e
argumen
ts
are
k
ept
(whatev
er
their
lev
el
is).
F
or
the
parameters
of
a
constructor,
only
the
informativ
e
ones
of
lev
el

ha
v
e
to
b
e
k
ept.
P
arameters
of
constructors
are
then
not
treated
as
usual
argumen
ts
of
an
application.
A
constructor
applied
to
its
parameters
is
noted
Constr(i;
ind;
~
p
)
where
i
is
the
n
um
b
er
of
the
constructor,
ind
the
corresp
onding
inductiv
e
t
yp
e
and
~
p
the
v
ector
of
parameters.
Denitio
n

Str
ong
extr
action
on
terms
:
"
0
(S
et
)
=
S
et
"
0
((x
:
A)B
)
=

"
0
(A)
)
"
0
(B
)
if
A
informative
of
level
0
"
0
(B
)
otherwise
"

(x)
=

x
wher
e

x
:
"
0
(T
x
)
if
x
:
T
x
"

((x
:
A)B
)
=

(

x
:
"
i
(A))"

(B
)
if
A
informative
of
level
i


"

(B
)
otherwise
"

([x
:
A]B
)
=

[

x
:
"
0
(A)]"

(B
)
if
A
informative
of
level
0
"

(B
)
otherwise
"

(A
B
)
=

("

(A)
"

(B
))
if
B
informative
of
level

"

(A)
otherwise
"

(Ind[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
A)fc

:
C

j
:
:
:
jc
m
:
C
m
g)
=


Ind[p
i
:
"
0
(P
i
)](

X
:
"

(A))fc

:
"

(C

)j
:
:
:
jc
m
:
"

(C
m
)g
for
informative
P
i
of
level
0
"

(x)
=

x
wher
e

x
:
"

(T
x
)
if
x
:
T
x
"

([x
:
A]B
)
=

[

x
:
"
i
(A)]"

(B
)
if
A
informative
of
level
i


"

(B
)
otherwise
"

(A
B
)
=

("

(A)
"
i
(B
))
if
B
informative
of
level
i


"

(A)
otherwise
"

(Elim(c;
P
)ff

j
:
:
:
jf
n
g
)
=
Elim("

(c);
"

(P
))f"

(f

)j
:
:
:
j"

(f
n
)g
"

(Constr(i;
ind;
~
p
))
=
Constr(i;
"

(ind);
"

(~
p))
Remark
:
the
extraction
function
corresp
onding
to
a
term
of
lev
el
i
is
noted
"
i
,
since
eac
h
term
has
a
unique
lev
el.
Denitio
n

Str
ong
extr
action
on
c
ontexts
:
"
i
( )
is
the
extr
acte
d
c
ontext
of
 dene
d
by
induction
on
 :

"
i
([])
=
[]

"
i
([ ;
x
:
A])
=
"
i
( )
if
A
lo
gic
al
or
if
level
of
A
>
i.

"
i
([ ;
x
:
A])
=
["
i
( );

x
:
"
j
(A)]
otherwise.
Prop
osition

If
 `
t
:
P
then
"
i
( )
`
"
i
(t)
:
"
i 
(P
).
Pro
of.
By
induction
on
the
length
of
the
deriv
ation.

Example
:
Let
us
consider
the
case
of
the
predecessor
function
whic
h
can
b
e
sp
ecied
through
the
prop
osition
:
(n
:
nat)fm
:
natj(S
m)
=
ng
+
f0
=
ng.
The
pro
of
of
this
prop
osition
pro
ceeds
b
y
induction
on
n.
If
n
=
0
then
the
righ
t
part
of
the
sp
ecication
is
true.
Otherwise,
if
n
=
y
+
,
then
the
left
part
of
the
sp
ecication
is
true
and
y
is
the
witness.
A
pro
of
term
for
this
sp
ecication
is
then
:
[n:nat]<[n0:nat]
{m:na
t|(S
m)=n0}+{0=n0}>Match
n
with
(inright
{m:nat|(S
m)=0}
(0=0)
(refl_equal
nat
0))
[y:nat][H:{m:na
t|(S
m)=y}+{0=y}]
(inleft
{m:nat|(S
m)=(S
y)}
(0=(S
y))
(exist
nat
[m:nat](S
m)=(S
y)
y
(refl_equal
nat
(S
y))))
end
The
extraction
of
this
term
is,
if
o
v
er-lines
are
forgotten
:
[n:nat]<(sumor
(sig
nat))>Match
n
with
(inright
(sig
nat))
[y:nat][H:(sumor
(sig
nat))](inleft
(sig
nat)
(exist
nat
y))
end
Since
sumor
is
a
sim
ulation
for
exceptions,
the
extraction
k
eeps
only
the
argumen
t
of
the
rst
comp
o-
nen
t
(the
witness
y
)
and
forgets
the
argumen
t
of
the
second
comp
onen
t.
In
an
ML
w
a
y
,
this
term
could
b
e
written
:
let
pred
n
=
match
n
with
O
->
raise
except_pred
|
y+
->
y
;;


.
Non-in
v
ersibilit
y
of
the
strong
extraction
The
extraction
function
allo
ws
to
syn
thesize
programs
from
pro
ofs.
Ho
w
ev
er,
a
complemen
tary
idea
could
b
e
to
start
from
a
program
and
its
sp
ecication
and
try
to
retriev
e
the
corresp
onding
pro
of.
A
natural
idea
for
this
is
to
in
v
ert
the
extraction
function.
Unfortunately
,
the
function
of
[PM	b
]
cannot
b
e
in
v
erted.
Indeed,
not
all
the
in
telligence
to
pro
v
e
prop
erties
is
reected
b
y
the
program.
Example
:
F
or
a
sp
ecication
fx
:
Aj(P
x)g
and
a
program
a,
w
e
need
to
reconstruct
a
pro
of
of
(P
a)
for
an
arbitrary
P
.
This
is
imp
ossible.
Indeed,
this
is
an
undecidable
prop
ert
y
.
It
is
imp
ossible
to
retriev
e
a
pro
of
only
from
its
sp
ecication.
There
is
another
problem.
In
termediate
sp
ecications
disapp
ear.
Let
us
tak
e
the
case
of
a
sp
ecication
(n
:
nat)fp
:
natj

p
=
ng
_
fp
:
natj

p
+

=
ng.
In
a
pro
of,
this
sp
ecication
can
b
e
enforced
b
y
a
distinction
b
et
w
een
n
ev
en
and
n
o
dd.
The
in
termediate
sp
ecication
is
then
(n
:
nat)((ev
en
n)
^
fp
:
natj

p
=
ng)
_
((odd
n)
^
fp
:
natj

p
+

=
ng).
It
is
imp
ossible
to
retriev
e
from
a
program
suc
h
a
sp
ecication
b
ecause
logical
informations
are
not
in
the
program.
Then,
it
seems
natural
not
to
b
e
able
to
retriev
e
logical
pro
ofs.
It
corresp
onds
to
logical
prop
erties
the
programmer
will
ha
v
e
to
pro
v
e
on
the
program.
Ho
w
ev
er,
one
can
hop
e
to
b
e
able
to
retriev
e
in
termediate
sp
ecications.
That
is
wh
y
w
e
in
tro
duce
a
new
extraction
function.

The
w
eak
extraction
function
The
aim
of
this
new
extraction
function
is
to
nd
a
w
a
y
of
k
eeping
a
sucien
t
n
um
b
er
of
informations
to
b
e
able
to
retriev
e
a
pro
of
term
from
a
w
eak
extracted
term.
Since
w
e
sho
w
the
problem
is
to
retriev
e
in
termediate
sp
ecications,
this
new
function
k
eeps
the
sp
ecications
and
no
more
suppresses
them.
Then,
this
function
only
suppresses
logical
pro
ofs.
.
Denitions
and
prop
erties
In
this
case,
argumen
ts
of
constructors
are
treated
as
usual
argumen
ts.
Indeed,
w
e
no
w
w
an
t
to
k
eep
all
the
informativ
e
parameters
of
a
constructor
(whatev
er
their
lev
el
is).
Then,
w
e
go
bac
k
no
w
to
the
notation
Constr(i;
ind).
The
case
of
the
strong
elimination
has
to
b
e
treated,
since
the
w
eak
extraction
can
b
e
applied
to
logical
terms.
Denitio
n

We
ak
extr
action
on
terms
:

i
([x
:
A]B
)
=


i
(B
)
if
A
:
P
r
op
[

x
:

j
(A)]
i
(B
)
otherwise

i
(A
B
)
=


i
(A)
if
B
lo
gic
al
of
level

(
i
(A)

j
(B
))
otherwise

i
(Elim(c;
P
)ff

j
:
:
:
jf
n
g)
=
Elim(

(c);

i 
(P
))f
i
(f

)j
:
:
:
j
i
(f
n
)g


(Constr(i;
ind))
=
Constr(i;


(ind))

i
(x)
=

x
wher
e

x
:

i 
(T
x
)
if
x
:
T
x


((x
:
A)B
)
=
(

x
:

i
(A))

(B
)


(Ind[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
A)fc

:
C

j
:
:
:
jc
m
:
C
m
g)
=
Ind[p
i
:

j
(P
i
)](

X
:

0
(A))fc

:


(C

)j
:
:
:
jc
m
:


(C
m
)g
for
P
i
not
of
typ
e
Pr
op

0
(K
)
=
K
wher
e
K
is
a
sort

0
((x
:
A)B
)
=


0
(B
)
if
A
:
P
r
op
(

x
:

0
(A))
0
(B
)
otherwise


Denitio
n

We
ak
extr
action
on
c
ontexts
:

c
( )
is
the
we
ak
extr
acte
d
c
ontext
of
 dene
d
by
induction
on
 :


c
([])
=
[]


c
([ ;
x
:
A])
=

c
( )
if
A
:
P
r
op
.


c
([ ;
x
:
A])
=
[
c
( );

x
:

i
(A)]
otherwise.
Example
:
Let
us
sho
w
the
w
eak
extraction
on
the
previous
example
of
the
predecessor.
Note
that
the
w
eak
extraction
do
es
not
c
hange
the
inductiv
e
t
yp
es
sig
and
sumor
.
The
w
eak
extracted
term
is
then
the
follo
wing
:
[n:nat]<[n0:nat]
{m:na
t|(S
m)=n0}+{0=n0}>Match
n
with
(inright
{m:nat|(S
m)=0}
(0=0))
[y:nat][H:{m:nat
|(S
m)=y}+{0=y}]
(inleft
{m:nat|(S
m)=(S
y)}
(0=(S
y))
(exist
nat
[m:nat](S
m)=(S
y)
y))
end
Note
that
this
program
has
the
same
computational
con
ten
ts
than
the
strong
extracted
program.
The
only
dierence
is
that
there
are
annotations
corresp
onding
to
in
termediate
sp
ecications.
The
terms
obtained
b
y
application
of
this
function
on
terms
of
the
Calculus
of
Inductiv
e
Constructions
are
F
!
I
nd
programs
annotated
with
sp
ecications
in
the
Calculus
of
Inductiv
e
Constructions.
Suc
h
terms
con
tain
logical
informations
whic
h
allo
w
the
in
v
ersion
of
the
w
eak
extraction.
W
e
need
a
new
notion
of
t
yping
for
these
particular
terms
since
they
are
neither
t
ypable
in
the
Calculus
of
Inductiv
e
Constructions
nor
in
F
!
I
nd
.
Denitio
n

T
yping
on
we
ak
extr
acte
d
terms
:
[]
w
el
l
f
or
med
 `
T
:
s
 [x
:
T
]
w
el
l
f
or
med
s

S
=
fP
r
op
;
S
et
;
T
y
pe
;
T
y
peS
et
g
 w
el
l
f
or
med
 `
P
r
op

T
y
pe
 w
el
l
f
or
med
 `
S
et

T
y
peS
et
 w
el
l
f
or
med
x
:
T

  `
x

T
 `
T

s
 [x
:
T
]
`
T
0

s
0
 `
(x
:
T
)T
0

s
0
(s;
s
0
)

R
=
S

S
n
f(P
r
op;
T
y
pe);
(P
r
op
;
T
y
peS
et
)g
()
 `
(x
:
T
)T
0

s
 [x
:
T
]
`
t

T
0
 `
[x
:
T
]t

(x
:
T
)T
0
s

S
 `
t

(x
:
A)B
 `
t
0

A
 `
(t
t
0
)

B
[x
 
t
0
]
A
of
level
0
or
informative
of
level

 `
A

P
r
op
 `
t

A
!
U
 `
t

U
()
 `
t

U
 `
A

P
r
op
 `
t

A
!
U
()
	

 `
T

s
 `
T
0

s
0
 `
t

T
T
=


T
0
 `
t

T
0
(i
=

:
:
:
m)
 [p
j
:
P
j
]
`
A

s
 [p
j
:
P
j
;
X
:
A]
`
C
i

s
0
c
onstructor(C
i
;
X
)
 `
Ind[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
A)fc

:
C

j
:
:
:
jc
m
:
C
m
g

(p

:
P

)
:
:
:
(p
n
:
P
n
)A

	P
j
:
P
r
op
 `
I
nd

Ind[~
p
:
~
P
](X
:
A)fc

:
C

j
:
:
:
c
m
:
C
m
g

B


i

m
 `
Constr(i;
I
nd)

(p

:
P

)
:
:
:
(p
n
:
P
n
)C
i
[X
 
(I
nd
p

:
:
:
p
n
)]
 `
c

(I
~
p
~
a)
 `
Q

(
~
x
:
~
A
)(I
~
p
~
x)
!
s
0
(i
=

:
:
:
m)
 `
f
i

C
i
f(I
~
p);
Q;
(Constr
(i;
I
)
~
p)g

 `
Elim(c;
Q)ff

j
:
:
:
jf
m
g

(Q
~
a
c)
The
denition
of
C
fX
;
Q;
cg
is
mo
died
in
to
C
fX
;
Q;
cg

.
Indeed,
no
pro
of
v
ariables
ha
v
e
to
app
ear
in
constructors.
If
a
constructor
is
c
:
(n
:
nat)(n
>
0)
!
C
,
the
elimination
principle
should
b
e
(n
:
nat)(n
>
0)
!
(P
(c
n))
and
not
(n
:
nat)(h
:
n
>
0)
!
(P
(c
n)
h).
The
new
denition
of
C
fX
;
Q;
cg

allo
ws
to
a
v
oid
this
problem.
Denitio
n

Given
s
and
s'
two
sorts,
A

(
~
x
:
~
A)s,
X
a
variable
of
typ
e
A,
Q
a
variable
of
typ
e
(
~
x
:
~
A
)(X
~
x)
!
s
0
,
C
a
c
onstructor
typ
e
w.r.t.
X
and
c
a
term
of
typ
e
C
,
we
dene
C
fX
;
Q;
cg

by
induction
on
C
:
(P
!
C
)fX
;
Q;
cg

=
(p
:
P
)P
fX
;
Q;
pg

!
C
fX
;
Q;
(c
p)g

(x
:
M
)C
fX
;
Q;
cg

=

C
fX
;
Q;
cg

if
M
:
P
r
op
(x
:
M
)C
fX
;
Q;
(c
x)g

otherwise
(X
~
a)fX
;
Q;
cg

=
(Q
~
a
c)
Remarks
:
.
In
the
rst
case
of
the
preceden
t
denition,
P
cannot
ha
v
e
the
t
yp
e
P
r
op.
Indeed,
an
inductiv
e
t
yp
e
in
an
eliminatio
n
is
alw
a
ys
informativ
e.
Moreo
v
er,
P
is
strictly
p
ositiv
e
w.r.t.
X
.
Then,
P
:
S
et
.
.
In
the
rule
,
(P
r
op;
T
y
pe)
and
(P
r
op;
T
y
peS
et
)
are
not
necessary
b
ecause
they
allo
w
the
forma-
tion
of
dep
enden
t
t
yp
es
on
logical
pro
ofs
and
these
ha
v
e
b
een
suppressed.
.
In
the
follo
wing,

applies
to
all
terms
except
logical
pro
ofs.
"
applies
only
on
informativ
e
terms.
.
If
 `
t

S
then
the
program
t
is
said
to
b
e
coheren
t
with
the
sp
ecication
S
.
W
e
can
no
w
giv
e
a
list
of
standard
prop
erties
on
this
w
eak
extraction
and
the
corresp
onding
new
t
yping
judgmen
t.
Prop
osition

Coher
enc
e
of
the
new
typing
judgment
w.r.t.
the
str
ong
extr
action
:
If
 `
t

P
and
P
is
informative
then
"
i
( )
`
"
i
(t)
:
"
i 
(P
).
Pro
of.
By
induction
on
the
length
of
the
deriv
ation
of
 `
t

P
.

Prop
osition

First
substitutivity
lemma
:
F
or
al
l
term
t
of
level
0,

or
informative
of
level

:

i
(T
[x
 
t])
=

i
(T
)[x
 

j
(t)]
wher
e
i
is
the
level
of
T
and
j
the
level
of
t
and
x.
Mor
e
over,
informations
of
x
and
t
have
to
b
e
c
oher
ent
(if
one
is
lo
gic
al,
the
other
one
to
o).
0

Pro
of.
By
induction
on
the
structure
of
t.

Prop
osition

Se
c
ond
substitutivity
lemma
:
F
or
al
l
lo
gic
al
term
t
of
level

:

i
(T
[x
 
t])
=

i
(T
)
wher
e
i
is
the
level
of
T
with
levels
and
informations
of
x
and
t
c
oher
ent.
Pro
of.
By
induction
on
the
structure
of
t.

Prop
osition

Coher
enc
e
of
the
we
ak
extr
action
:
 ,
t,
P
,
such
that
P
is
not
of
typ
e
Pr
op,
 `
t
:
P
)

( )
`

(t)


(P
).
Pro
of.
By
induction
on
the
length
of
the
deriv
ation
of
 `
t
:
P
.

.
In
v
ersion
of
the
w
eak
extraction
W
e
no
w
w
an
t
to
in
v
ert
the
w
eak
extraction.
Giv
en
a
w
eak
extracted
program
and
a
sp
ecication,
w
e
w
an
t
to
retriev
e
a
pro
of
term.
W
e
sho
w
that
w
e
can
reconstruct
a
partial
pro
of
term
with
\holes"
corresp
onding
to
logical
pro
ofs
to
b
e
pro
v
ed
b
y
the
user.
Then,
all
the
logical
pro
ofs
of
a
same
sp
ecication
ha
v
e
to
b
e
iden
tied.
The
pro
of
of
in
v
ersibilit
y
giv
es
suc
h
an
algorithm.
Some
restrictions
on
the
mo
del
ha
v
e
to
b
e
stated
in
order
to
b
e
able
to
in
v
ert
the
function.
.
Logical
pro
ofs
can
app
ear
in
prop
ositions.
This
is
a
problem
since
they
cannot
b
e
retriev
ed.
In
practice,
no
suc
h
prop
erties
of
logical
pro
ofs
are
expressed,
but
the
Calculus
of
Constructions
do
es
not
forbid
suc
h
constructions.
Moreo
v
er,
pro
ofs
can
naturally
app
ear
in
sp
ecications.
F
or
instance,
a
sp
ecication
of
the
ro
ot
function
can
b
e
(n
:
nat)(n
>
0)fp
:
natjp

p
=
ng.
Then,
a
pro
of
that
the
ro
ot
of

exists
is
a
pro
of
of
the
prop
osition
(r
oot

h)
where
h
is
a
pro
of
of

>
0.
In
general,
to
b
e
able
to
do
pro
ofs,
it
is
necessary
to
ha
v
e
a
mo
del
where
all
the
logical
pro
ofs
of
a
same
prop
osition
are
equal.
A
simple
w
a
y
for
doing
this
is
to
consider
a
system
where
the
con
v
ersion
rule
is

(A)
=

(B
)
and
no
more
A
=
B
.
.
W
e
consider
then
a
mo
del
where
there
are
no
logical
pro
ofs
in
t
yp
es.
The
basic
PTS
is
then
the
Calculus
of
Inductiv
e
Constructions
without
the
rules
(P
r
op;
T
y
pe)
and
(P
r
op;
T
y
peS
et
).
This
prop
ert
y
is
necessary
to
ensure
the
irrelev
ance
of
logical
pro
ofs.
This
pro
of-irrelev
ance
allo
ws
to
iden
tify
all
the
logical
pro
ofs
of
a
same
prop
osition.
.
The
programs
are
considered
to
b
e
in
a
normal
form.
This
p
oin
t
allo
ws
to
ensure
that
the
generated
conditions
are
minim
al
.
Remarks
:

These
prop
erties
imply
that

((x
:
A)B
)
=
(x
:

(A))
(B
).

If

(A)
:
s
where
s
is
a
sort
then
the
t
yp
e
of
A
is
a
sort.
W
e
can
no
w
state
the
theorem
of
in
v
ersibilit
y
.
It
corresp
onds
to
the
follo
wing
in
tuition.
A
program
p
is
in
v
ertible
if,
giv
en
a
con
text
 and
a
sp
ecication
S
where
S
is
pro
v
able
and
p
coheren
t
with
S
in
 ,
a
pro
of
term
for
p
can
b
e
reconstructed
with
holes
corresp
onding
to
logical
pro
ofs.
Theorem

Inversibility
of
the
we
ak
extr
action
:
If

`
t

T
and
if
 is
a
wel
l
forme
d
envir
onment
such
that

c
( )
=

then
	t
0
;
L
wel
l
forme
d
lo
gic
al
c
ontext
and
S
such
that
 ;
L
`
t
0
:
S
with

(t
0
)
=
t,

(S
)
=
T
.


Pro
of.
By
induction
on
the
deriv
ation
of
.
W
e
do
not
detail
the
cases
of
con
text
formation.
Eac
h
step
giv
es
the
construction
of
the
pro
of
term
t.
A
t
eac
h
step,
 is
kno
wn
suc
h
that

c
( )
=
.
In
all
the
pro
of,
the
L
are
logical
terms
of
lev
el
,
and
L
is
a
logical
con
text.

V
ariable
:

w
el
l
f
or
med
x
:
T



`
x

T
The
pro
of
term
is
the
v
ariable
x
of
t
yp
e
 x
.
As

c
( )
=
,

( x
)
=

x
=
T
.
Then,
 `
x
:
 x
with

(x)
=
x
and

( x
)
=
T
.
The
searc
hed
en
vironmen
t
is
 ,
the
pro
of
term
x
and
its
t
yp
e
 x
.

Application
formation
:

`
t

(x
:
A)B

`
u

A

`
(t
u)

B
[x
 
u]
A
of
lev
el
0
or
informativ
e
of
lev
el

By
induction
h
yp
othesis,
	t
0
;
L
and
T
0
suc
h
that
 ;
L
`
t
0
:
T
0
with

(t
0
)
=
t
and

(T
0
)
=
(x
:
A)B
.
Moreo
v
er,
	u
0
;
L
0
and
A
0
suc
h
that
 ;
L
0
`
u
0
:
A
0
with

(u
0
)
=
u
and

(A
0
)
=
A.
Necessarily
,
T
0
=
(x
:
A
00
)B
0
with

(A
00
)
=
A
and

(B
0
)
=
B
.
There
are
no
logical
pro
ducts
at
the
head
of
S
.
Indeed,
the
condition

imp
oses
arities
not
dep
ending
on
logical
pro
ofs.
Then,
 ;
L
`
t
0
:
(x
:
A
00
)B
0
and

(A
0
)
=

(A
00
)
=
A.
T
o
apply
the
standard
t
yping
rule
for
application,
A
0
=
A
00
is
needed.
The
irrelev
ance
of
logical
pro
ofs
is
then
necessary
.
A
0
=
A
00
can
b
e
deduced
from

(A
0
)
=

(A
00
).
Then,
	L
00
,
union
of
L
and
L
0
,
suc
h
that
 ;
L
00
`
(t
0
u
0
)
:
B
0
[x
 
u
0
].
(t
0
u
0
)
is
the
pro
of
term
with
the
follo
wing
conditions
:

(t
0
u
0
)
=
(
(t
0
)

(u
0
))
=
(t
u)

(B
0
[x
 
u
0
])
=

(B
0
)[x
 

(u
0
)]
=
B
[x
 
u]

Pro
duct
formation
:

`
T

s
[x
:
T
]
`
T
0

s
0

`
(x
:
T
)T
0

s
0
(s;
s
0
)

R
=
S

S
n
f(P
r
op;
T
y
pe);
(P
r
op
;
T
y
peS
et
)g
By
induction
h
yp
othesis,
	t
0
;
L
and
S
suc
h
that
 [x
:
A];
L
`
t
0
:
S
with

(t
0
)
=
T
0
,

(S
)
=
s
0
and

(A)
=
T
.
As
s
0

S
,
S
=
s
0
.
Indeed,
the
condition

imp
oses
arities
not
dep
ending
on
pro
ofs,
then
S
is
necessarily
a
sort.
Then,
 [x
:
A];
L
`
t
0
:
s
0
.
T
o
giv
e
a
pro
of
term,
the
logical
v
ariables
of
L
ha
v
e
to
b
e
comm
uted
in
the
con
text.
A
v
ector
~
l
0
:
~
L
0
is
dened
with
L
0
i
=
(x
:
A)L
i
if
L
=
[
~
l
:
~
L].
In
t
0
,
l
i
are
substituted
b
y
(l
0
i
x)
and
a
term
t
00
is
obtained.
Then,
 [
~
l
0
:
~
L
0
;
x
:
A]
`
t
00
:
s
0
.
The
application
of
the
standard
t
yping
rule
for
the
pro
duct
giv
es
:
 [
~
l
0
:
~
L
0
]
`
(x
:
A)t
00
:
s
0
.
The
conditions
are
:

((x
:
A)t
00
)
=
(x
:

(A))
(t
0
)
=
(x
:
T
)T
0

(s
0
)
=
S



Abstraction
formation
:

`
(x
:
T
)T
0

s
[x
:
T
]
`
t

T
0

`
[x
:
T
]t

(x
:
T
)T
0
s

S
By
induction
h
yp
othesis,
	t
0
;
L
and
S
suc
h
that
 [x
:
A];
L
`
t
0
:
S
with

(t
0
)
=
t,

(S
)
=
T
0
and

(A)
=
T
.
Then,
 [x
:
A];
L
`
t
0
:
S
.
T
o
giv
e
a
pro
of
term,
the
logical
v
ariables
of
~
l
ha
v
e
to
b
e
comm
uted
in
the
con
text.
A
v
ector
~
l
0
:
~
L
0
is
dened
with
L
0
i
=
(x
:
A)L
i
if
L
=
[
~
l
:
~
L].
W
e
note
~
(l
0
x)
for
the
v
ector
((l
0

x);
:
:
:
;
(l
0
n
x)).
The,
 [
~
l
0
:
~
L
0
;
x
:
A]
`
t
0
[
~
l
 
~
(l
0
x)]
:
S
.
The
application
of
the
standard
t
yping
rule
for
the
abstraction
giv
es
:
 [
~
l
0
:
~
L
0
]
`
[x
:
A]t
0
[
~
l
 
~
(l
0
x)]
:
(x
:
A)S
b
ecause
~
l
0
do
es
not
app
ear
in
S
.
The
conditions
are
:

([x
:
A]t
0
[
~
l
 
~
(l
0
x)])
=
[x
:

(A)]
(t
0
)
=
[x
:
T
]t

((x
:
A)S
)
=
(x
:

(A))
(S
)
=
(x
:
T
)T
0

Rule

:

`
A

P
r
op

`
t

A
!
U

`
t

U
By
induction
h
yp
othesis,
	t
0
;
L
and
S
suc
h
that
 ;
L
`
t
0
:
S
with

(t
0
)
=
t
and

(S
)
=
A
!
U
.
Then,
S
=
(x
:
A
0
)B
0
with

(A
0
)
=
A
and

(B
0
)
=
U
.
Then,
 ;
L
`
t
0
:
(x
:
A
0
)B
0
.
This
is
exactly
the
same
case
as
application
and
the
pro
of
term
can
b
e
reconstructed.
	L
0
,
x
0
suc
h
that
L
0
=
L[x
0
:
A
0
].
Then,
 ;
L
0
`
(t
0
x
0
)
:
B
0
[x
 
x
0
]
with

(t
0
x
0
)
=
t
and

(B
0
[x
 
x
0
])
=
U
.
This
is
the
only
place
where
a
logical
lemma
is
in
tro
duced.
In
the
other
cases,
the
logical
lemmas
of
the
induction
h
yp
otheses
ha
v
e
rep
ercussions
but
no
new
one
is
in
tro
duced.

Rule

:

`
t

U

`
A

P
r
op

`
t

A
!
U
By
induction
h
yp
othesis,
	t
0
;
L
and
S
suc
h
that
 ;
L
`
t
0
:
S
with

(t
0
)
=
t
and

(S
)
=
U
.
Then,
 [
~
l
:
~
L]
`
t
0
:
S
,
then
 `
[
~
l
:
~
L]t
0
:
(
~
l
:
~
L)S
with
	i;

(L
i
)
=
A.

Inductiv
e
t
yp
e
formation
:
(i
=

:
:
:
m)
[p
j
:
P
j
]
`
A

s
[p
j
:
P
j
;
X
:
A]
`
C
i

s
0
c
onstructor(C
i
;
X
)

`
Ind[p

:
P

j
:
:
:
jp
n
:
P
n
](X
:
A)fc

:
C

j
:
:
:
jc
m
:
C
m
g

(p

:
P

)
:
:
:
(p
n
:
P
n
)A

	P
j
:
P
r
op
By
induction
h
yp
othesis,
	L;
t
i
and
S
i
suc
h
that
 [p
0
j
:
P
0
j
;
X
0
:
A
0
];
L
`
t
i
:
S
i
with

(t
i
)
=
C
i
,

(S
i
)
=
s
0
,

(P
0
j
)
=
P
j
and

(A
0
)
=
A.
Moreo
v
er,
	L
0
;
t
0
and
S
0
suc
h
that
 ;
L
0
`
t
0
:
S
0
with

(t
0
)
=
A
and

(S
0
)
=
s.
Then,
 [p
0
j
:
P
0
j
;
X
0
:
A
0
;
~
l
:
~
L]
`
t
i
:
S
i
.
As

(t
0
)
=

(A
0
),
thanks
to
the
irrelev
ance
of
logical
pro
ofs,
t
0
=
A
0
.
Then,
as
for
preceden
t
cases,
~
l
ha
v
e
to
b
e
comm
uted
and
the
standard
t
yping
rule
for
inductiv
e
t
yp
es
can
b
e
applied.
A
pro
of
term
is
obtained
and
it
v
eries
the
go
o
d
prop
erties.

Constructor
formation
:

`
I
nd

Ind[~
p
:
~
P
](X
:
A)fc

:
C

j
:
:
:
c
m
:
C
m
g

B


i

m

`
Constr(i;
I
nd)

(p

:
P

)
:
:
:
(p
n
:
P
n
)C
i
[X
 
(I
nd
p

:
:
:
p
n
)]


By
induction
h
yp
othesis,
	ind
0
;
L
and
S
suc
h
that
 ;
L
`
ind
0
:
S
with

(ind
0
)
=
I
nd
and

(S
)
=
B
.
B
=
(~
p
:
~
P
)A,
then

(S
)
=
(
~
p
0
:
~
P
0
)A
0
with

(p
0
i
)
=
p
i
and

(A
0
)
=
A.
Then,
 ;
L
`
ind
0
:
(
~
p
0
:
~
P
0
)A
0
.
Then,
ind
0
=
Ind[~
p
:
~
P
](X
:
A
0
)fc
0
i
:
C
0
i
g.
Then,
 ;
L
`
Constr(i;
ind
0
)
:
(
~
p
0
:
~
P
0
)C
0
i
[X
 
(ind
0
~
p
0
)]
with

(Constr
(i;
ind
0
))
=
Constr(i;
I
nd)
and

((
~
p
0
:
~
P
0
)C
0
i
[X
 
(ind
0
~
p
0
)])
=
(~
p
:
~
P
)C
i
[X
 
(I
nd
~
p)].

Eliminatio
n
formation
:

`
c

(I
~
p
~
a)

`
Q

(
~
x
:
~
A)(I
~
p
~
x)
!
s
0
(i
=

:
:
:
m)

`
f
i

C
i
f(I
~
p);
Q;
(Constr
(i;
I
)
~
p)g


`
Elim(c;
Q)ff

j
:
:
:
jf
m
g

(Q
~
a
c)
By
induction
h
yp
othesis,
	c

;
L

and
S
c
suc
h
that
 ;
L

`
c

:
S
c
with

(c

)
=
c
and

(S
c
)
=
(I
~
p
~
a);
	Q

;
L

and
S
Q
suc
h
that
 ;
L

`
Q

:
S
Q
with

(Q

)
=
Q
and

(S
Q
)
=
(
~
x
:
~
A)(I
~
p
~
x)
!
s
0
;
	f
0
i
;
L
i
and
S
i
suc
h
that
 ;
L
i
`
f
0
i
:
S
i
with

(f
0
i
)
=
f
i
and

(S
i
)
=
C
i
f(I
~
p);
Q;
(Constr
(i;
I
)
~
p)g

.
Then,
S
Q
=
(
~
x

:
~
A
0
)(I

~
p

~
x

)
!
s
0
with

(A
0
i
)
=
A
i
,

(I

)
=
I
,

(
~
p

)
=
~
p
and

(
~
x

)
=
~
x
;
S
c
=
(I

~
p

~
a

)
with

(I

)
=
I
,

(
~
p

)
=
~
p
and

(
~
a

)
=
~
a;
S
i
=
C
0
i
f(I

~
p

);
Q

;
(Constr
(i;
I

)
~
p

)g

with

(C
0
i
)
=
C
i
,

(I

)
=
I
,

(
~
p

)
=
~
p,

(Q

)
=
Q,

(I

)
=
I
and

(
~
p

)
=
~
p
.
Then,
thanks
to
the
pro
of
irrelev
ance,
I

=
I

=
I

=
I

,
~
p

=
~
p

=
~
p

=
~
p

and
Q

=
Q

.
Then,
	L

,
union
of
L

,
L

and
L
i
,
suc
h
that
 ;
L

`
Elim(c

;
Q

)ff
0
i
g
:
(Q

~
a

c

)
with
the
go
o
d
prop
erties.

This
pro
of
is
constructiv
e.
It
explicitly
giv
es
a
metho
d
to
construct
a
pro
of
term
from
a
w
eak
extracted
program
and
a
sp
ecication.
Note
that
the
pro
of
term
is
partial.
Indeed,
in
practice,
logical
pro
ofs
cannot
b
e
retriev
ed
(in
the
pro
of
of
in
v
ersibilit
y
,
w
e
iden
tify
all
of
them).
Ho
w
ev
er,
this
pro
of
is
based
on
an
analysis
of
the
t
yping
of
the
program.
This
t
yping
is
not
deterministic
due
to
the
t
w
o
rules

and
.
W
e
need
to
replace
these
t
w
o
rules
with
a
new
one
()
to
ha
v
e
a
new
equiv
alen
t
t
yping
system.
This
system
will
b
e
deterministic.
Denitio
n

L
o
gic
al
e
quivalenc
e
:
Two
typ
es
A
and
B
ar
e
lo
gic
al
ly
e
quivalent
(A

L
B
)
if
and
only
if
ther
e
exist
~
L
and
~
M
lo
gic
al
of
level
,
and
C
such
that
A
=
~
L
!
C
and
B
=
~
M
!
C
.
Remarks
:
.
This
prop
ert
y
is
decidable.
.
If
A

L
B
and
 `
M

A,
then
 `
M

B
.
T
rivial
b
y
a
suit
of
applications
of
the
rules

and
.
.

L
is
reexiv
e,
symmetric
and
transitiv
e.
.
L
!
A

L
A
if
L
is
logical
of
lev
el
.
W
e
can
no
w
dene
a
new
t
yping
system
called


.
It
is
the
same
as

but

and

are
replaced
b
y
the
follo
wing
.
Denitio
n
	
T
yping
system


:
 `
t


A
 `
u


B
A

L
(x
:
M
)N
B

L
M
 `
(t
u)


N
[x
 
u]
()
W
e
can
no
w
pro
v
e
the
equiv
alence
b
et
w
een

and


.
The
pro
of
deals
with
the
fact
that

can
b
e
deduced
from

and

and
con
v
ersely
.


Prop
osition

Equivalenc
e
of

and


:
 `
t

S
if
and
only
if
	S
0
such
that
 `
t


S
0
with
S

L
S
0
.
By
this
prop
osition
and
the
theorem
,
w
e
ha
v
e
a
deterministic
metho
d
to
reconstruct
a
partial
pro
of
term
from
a
sp
ecication
and
a
w
eak
extracted
program.
Giv
en
a
program
t
and
a
sp
ecication
S
,
a
pro
of
of
t


S
0
can
b
e
inferred
with
S

L
S
0
.
Then,
this
giv
es
a
pro
of
of
t

S
.
This
pro
of
is
a
term
t
0
:
S
.
Naturally
,
if
S
is
pro
v
able,
w
e
hop
e
the
logical
lemmas
of
L
to
b
e
pro
v
able
to
o.
Ho
w
ev
er,
w
e
are
only
able
to
sa
y
that
the
generated
pro
of
obligations
had
a
pro
of
in
the
initial
pro
of
term
t.
The
result
is
w
eak
er
than
sa
ying
that
all
the
logical
lemmas
are
pro
v
able.
T
o
ensure
the
metho
d
generates
only
pro
of
obligations
that
had
a
pro
of
in
the
initial
term
t,
w
e
need
t
w
o
remarks.
First
of
all,
the
generated
logical
lemmas
are
in
tro
duced
only
b
y
the
rule
.
Let
us
consider
the
pro
of
of
in
v
ersibilit
y
for
this
rule.
The
t
yp
e
of
the
pro
of
term
corresp
onding
to
A
is
A
0
.
In
the
case
of
a
pro
of,
a
pro
of
of
A
0
exists.
Then,
it
is
sure
that
all
the
generated
logical
lemmas
ha
v
e
a
pro
of
in
the
initial
pro
of
term.
Moreo
v
er,
the
pro
of
in
tro
duces
generalizations
on
logical
lemmas
(comm
utations
in
con
texts).
The
condition
of
normal
form
on
programs
is
then
necessary
to
b
e
sure
that
these
generalizations
do
not
in
tro
duce
problems.
Indeed,
this
implies
that
the
generated
conditions
are
minim
al
.
Then,
logical
lemmas
are
t
yp
es
of
subparts
of
the
initial
term
and
a
pro
of
of
them
exists.
W
e
can
then
state
a
notion
of
w
eak
completeness
for
this
metho
d.
Prop
osition

We
ak
c
ompleteness
of
the
inversion
of
the
we
ak
extr
action
:
F
or
al
l
pr
o
gr
am
c
oher
ent
with
a
pr
ovable
sp
e
cic
ation,
the
metho
d
for
r
e
c
onstructing
a
pr
o
of
only
gener
ates
pr
o
of
obligations
for
which
a
pr
o
of
exists
in
the
initial
pr
o
of
term.
The
metho
d
is
then
deterministic.
It
reconstructs
a
partial
pro
of
term
from
a
w
eak
extracted
program
and
its
sp
ecication.
Pro
of
obligations
are
left
to
the
user.
They
represen
t
logical
prop
erties
that
the
program
has
to
v
erify
to
v
alid
its
sp
ecication.
This
implies
that
w
e
ha
v
e
a
canonical
represen
tation
for
pro
ofs.
This
approac
h
is
b
oth
a
metho
d
of
pro
ving
programs
and
a
metho
d
of
syn
thetically
describing
pro
ofs.

A
heuristic
metho
d
W
eak
extracted
programs
are
not
v
ery
natural.
It
w
ould
b
e
nice
to
consider
more
natural
programs,
that
is,
programs
with
less
sp
ecications.
In
fact,
w
e
w
ould
lik
e
the
programmer
to
write
F
!
I
nd
programs
and
the
metho
d
to
use
unication
to
retriev
e
subsp
ecications.
This
is
the
goal
of
a
tactic
implemen
ted
in
Co
q
and
presen
ted
in
[P
ar	].
This
heuristic
approac
h
should
follo
w
the
same
metho
d
as
the
deterministic
metho
d,
but
the
use
of
unication
in
tro
duces
non-determinism.
Nev
ertheless,
w
e
in
tro
duce
annotations
in
F
!
I
nd
programs
that
the
heuristic
metho
d
could
use
and
that
allo
w
to
k
eep
a
certain
notion
of
completeness.
W
e
briey
describ
e
some
heuristics
and
optimizations.
W
e
refer
the
reader
to
[P
ar	
]
for
further
details.
A
notion
of
t
yping
is
alw
a
ys
necessary
.
This
t
yping
is
a
little
dieren
t
from
.
W
e
dene


whic
h
replaces

and

b
y
.
This
new
t
yping
just
in
tro
duces
a
notion
of
correction
for
programs.
Denitio
n
0
T
yping
on
natur
al
pr
o
gr
ams
:
 `
T


s
 `
T
0


s
0
 `
t


T
"(T
)
=
"(T
0
)
 `
t


T
0
()
.
Heuristics
The
problem
is
to
retriev
e
sp
ecications.
F
or
this,
w
e
use
higher-order
unication
b
et
w
een
the
t
yp
e
of
the
program
and
the
sp
ecication.
Since
unication
is
not
deterministic,
w
e
ha
v
e
to
made
some
c
hoices.
W
e
prefer
not
to
giv
e
all
the
details
in
this
pap
er,
but
w
e
can
giv
e
an
idea
of
where
the
problems
are
and
ho
w
they
can
b
e
solv
ed.
The
main
problematic
cases
are
applications
and
eliminations.
In
an
application,
the
problem
is
to
retriev
e
all
the
logical
argumen
ts.
Moreo
v
er,
if
one
argumen
t
is
a
predicate,
it
is
not
deterministic
to
retriev
e
it
b
y
unication.
F
or
the
elimination,
the
problem
is
to
retriev
e
the
elimination
predicate.
Heuristics


deal
with
unication
b
et
w
een
the
t
yp
e
of
the
program
and
the
sp
ecication.
The
problem
is
to
c
ho
ose
the
go
o
d
unier.
The
c
hoice
is
to
alw
a
ys
k
eep
the
most
general
unier
(in
the
sense
of
the
one
whic
h
b
ounds
the
biggest
n
um
b
er
of
v
ariables).
In
practice,
it
seems
to
b
e
a
go
o
d
c
hoice.
Example
:
Let
us
giv
e
an
example
for
a
heuristic
in
an
application.
Let
us
tak
e
the
sp
ecication
n:	m:(S
m)
=
n
_
n
=
m
=
0.
A
strong
extracted
program
coheren
t
with
this
sp
ecication
is
:
[n:nat](nat_rec
(sig
nat)
(exist
nat
0)
[y:nat][H:(sig
nat)](exist
nat
y))
where
nat_rec
is
the
usual
induction
principle
on
natural
n
um
b
ers
whose
t
yp
e
is
(P
:
nat
!
S
et
)(P
0)
!
((n
:
nat)(P
n)
!
(P
(S
n)))
!
(n
:
nat)(P
n).
Note
that
in
the
previous
program,
nat_rec
is
a
program
v
ariable
and
then
its
t
yp
e
is
(P
:
S
et
)P
!
(nat
!
P
!
P
)
!
nat
!
P
.
The
pro
of
term
to
b
e
retriev
ed
is
:
[n:nat](nat_rec
[n0:nat]{m:nat|(S
m)=n0
\/
n0=m=0}
(exist
nat
[m:nat]((S
m)=0
\/
0=m=0)
0
P)
[y:nat][H:{m:nat|(S
m)=y
\/
y=m=0}]
(exist
nat
[m:nat]((S
m)=(S
y)
\/
(S
y)=m=0)
y
P))
where
P
and
P
are
pro
ofs
for
((S
0)
=
0)
_
(0
=
0
=
0)
and
((S
y
)
=
(S
y
))
_
((S
y
)
=
y
=
0).
Let
us
consider
only
the
application
case
(the
previous
abstraction
is
trivial).
W
e
lo
ok
for
the
predicate
whose
extraction
is
nat.
nat_rec
and
its
pro
of
t
yp
e
are
kno
wn.
The
searc
hed
predicate
P
has
t
yp
e
nat
!
S
et
.
Let
us
use
the
sp
ecication
to
instan
tiate
P
.
The
head
of
the
t
yp
e
of
nat_rec
(i.e.
(P
n))
can
b
e
unied
with
the
sp
ecication
(i.e.
	m:(S
m)
=
n
_
n
=
m
=
0).
This
is
non
deterministic
and
there
are
man
y
p
ossible
uniers
:
.
P
=
[n0]	m:(S
m)
=
n0
_
n0
=
m
=
0.
.
P
=
[n0]	m:(S
m)
=
n0
_
n
=
m
=
0.
.
P
=
[n0]	m:(S
m)
=
n
_
n0
=
m
=
0.
.
P
=
[n0]	m:(S
m)
=
n
_
n
=
m
=
0.
The
heuristic
consists
in
k
eeping
the
unier
whic
h
b
ounds
the
biggest
n
um
b
er
of
v
ariables,
th
us
the
rst
one
in
this
case.
Tw
o
subgoals
are
generated
:

	m:(S
m)
=
0
_
0
=
m
=
0
n:	m:((S
m)
=
n
_
n
=
m
=
0)
!
	m:(S
m)
=
(S
n)
_
(S
n)
=
m
=
0
asso
ciated
to
t
w
o
subprograms
(exist
nat
0)
and
[y:nat][H:{m:nat
|(S
m)=y\/y=m=0}](ex
ist
nat
[m:nat]((S
m)=(S
y)\/(S
y)=m=0)
y).
.
Annotations
The
heuristic
metho
d
deals
with
cases
where
the
higher-order
unication
succeeds.
In
practice,
it
seems
to
b
e
quite
often.
Ho
w
ev
er,
to
ensure
the
determinism
of
this
metho
d,
w
e
m
ust
b
e
able
to
direct
the
c
hoices
and
then
to
allo
w
the
programmer
to
add
logical
informations
in
the
program.
These
annotations
ha
v
e
to
b
e
tak
en
in
to
accoun
t
b
y
the
metho
d
to
tak
e
go
o
d
decisions.
Syn
tax
:
S
is
an
annotation
for
the
program
p
is
noted
p
::
S
.
Denitio
n

A
nnotations
:
 `
p


S
"(S
)
=
"(S
0
)
 `
(p
::
S
)


S
0


The
in
tuition
is
the
follo
wing.
S
is
an
annotation
for
p
if
p
is
coheren
t
with
S
.
Moreo
v
er,
if
p
is
coheren
t
with
S
0
then
p
::
S
is
coheren
t
with
S
0
and
"(S
)
=
"(S
0
).
Annotations
are
logical
sp
ecications
that
mark
programs
and
allo
w
to
precise
their
sp
ecication.
The
goal
is
to
use
them
to
giv
e
explicitly
the
sp
ecication
of
a
program
when
the
heuristic
metho
d
fails.
An
annotation
can
con
tain
free
v
ariables.
These
v
ariables
can
b
e
program
v
ariables
or
logical
v
ariables.
It
is
necessary
to
b
e
able
to
refer
to
logical
v
ariables
inside
a
program
and
then
to
authorize
logical
-
abstractions.
This
corresp
onds
to
the
already
existing
rule
of


:
 [x
:
L]
`
p


S
 `
[x
:
L]p


(x
:
L)S
if
L
:
T
y
pe
.
V
alidit
y
and
Completeness
The
heuristic
metho
d
can
either
succeed
or
fail.
There
are
three
p
ossible
b
eha
viors.
.
The
metho
d
fails.
Then,
either
the
program
is
false,
or
there
are
not
enough
logical
informations
in
the
program.
It
can
b
e
necessary
to
add
annotations
in
the
program.
.
The
metho
d
generates
a
set
of
logical
lemmas
that
are
not
pro
v
able.
Then,
either
the
program
is
false,
or
there
are
not
enough
logical
informations
in
the
program.
It
can
b
e
necessary
to
add
annotations
in
the
program.
.
The
metho
d
generates
a
set
of
pro
v
able
logical
lemmas.
The
theorem

ensures
that
the
in
v
ersion
of
the
w
eak
extraction
generates
a
partial
pro
of
of
the
initial
sp
ecication.
Then,
the
v
alidit
y
of
the
metho
d
is
ensured.
W
e
come
no
w
to
the
problem
of
the
completeness
of
the
heuristic
metho
d.
The
heuristic
metho
d
fails
on
a
correct
program
when
there
are
not
enough
logical
informations.
The
metho
d
on
w
eak
extracted
terms
is
deterministic.
As
a
consequence,
the
heuristic
metho
d
succeeds
on
sucien
tly
annotated
programs
that
is
if
the
annotated
program
is
the
w
eak
extracted
program.
The
completeness
of
the
heuristic
metho
d
can
then
b
e
stated.
Prop
osition

If
S
is
pr
ovable
and
if
the
asso
ciate
d
pr
o
gr
am
p
is
suciently
annotate
d,
then
ther
e
exists
in
the
initial
term
a
pr
o
of
of
the
lo
gic
al
lemmas
gener
ate
d
by
the
heuristic
metho
d.
Then,
if
programs
are
w
eak
extracted
programs,
the
heuristic
metho
d
is
complete.
The
notion
of
su-
cien
tly
annotated
programs
corresp
onds
in
the
w
orst
case
to
a
w
eak
extracted
term.
In
practice,
annotations
are
t
ypically
elimination
predicates.
It
corresp
onds
to
recursiv
e
structures
in
a
program.
One
retriev
es
the
problem
of
lo
op
in
v
arian
ts
searc
h
in
the
Hoare's
logic
[Hoa	
].
W
e
discuss
this
comparison
in
the
conclusion.
.
Optimizations
The
strong
extraction
can
b
e
optimized
in
order
to
generate
programs
that
are
closer
to
a
natural
form.
Suc
h
optimizations
generate
programs
more
and
more
far
from
the
pro
of.
Un
til
this
section,
w
e
nev
er
consider
suc
h
an
optimization.
By
no
w,
if
w
e
consider
it,
the
heuristics
to
retriev
e
a
pro
of
term
in
suc
h
a
case
are
m
uc
h
more
harder.
Sp
ecial
heuristics
ha
v
e
to
b
een
dev
elop
ed
to
deal
with
these
cases.
A
p
ossible
optimization
of
the
strong
extraction
consists
in
distinguishing
particular
t
yp
es
that
w
e
call
singleton
t
yp
es.
Suc
h
an
optimization
suppresses
constructors
on
singleton
t
yp
es
and
eliminations
on
singleton
t
yp
es.
Then,
for
instance,
heuristics
ha
v
e
to
b
e
found
to
retriev
e
an
elimination
on
a
singleton
t
yp
e
whic
h
has
disapp
eared
b
y
extraction
or
a
constructor
on
a
singleton
t
yp
e.
Other
optimizations
can
b
e
in
tro
duced
to
consider
more
natural
programs.
An
op
erator
of
w
ell-founded
recursion
can
b
e
in
tro
duced.
It
is
based
on
a
w
ell-founded
induction
principle.
Extracted
programs
often
con
tain
trivial
expressions
suc
h
as
if
b
then
true
else
false.
A
more
natural
program
is
b.
This
implies
that
heuristics
ha
v
e
to
deal
with
suc
h
situations.
They
ha
v
e
to
b
e
able
to
retriev
e
the
underlying
structure
of
pro
of
ev
en
if
this
is
not
the
same
in
the
program.
W
e
do
not
detail
at
all
this
part
but
one
can
refer
to
[P
ar	
]
for
an
explanation
of
suc
h
optimizations.



Conclusion
W
e
ha
v
e
dened
a
new
extraction
function
for
the
Calculus
of
Inductiv
e
Constructions
called
the
w
eak
extraction.
W
eak
extracted
terms
are
condensed
forms
of
pro
ofs.
They
are
F
!
I
nd
programs
annotated
with
sp
ecications.
A
new
notion
of
t
yping
has
b
een
dened
for
suc
h
terms.
This
w
eak
extraction
has
an
imp
ortan
t
prop
ert
y
:
it
can
b
e
in
v
erted.
The
pro
of
of
in
v
ersibilit
y
giv
es
an
algorithm
to
reconstruct
a
pro
of
from
a
program
and
its
sp
ecication.
Giv
en
a
w
eak
extracted
program
and
its
sp
ecication,
a
partial
pro
of
term,
with
\holes"
corresp
onding
to
logical
lemmas
to
b
e
pro
v
ed,
can
b
e
deterministically
reconstructed.
The
metho
d
is
complete
in
the
sense
that
there
exists
a
pro
of
for
these
logical
lemmas
in
the
original
pro
of
term.
A
heuristic
metho
d
can
b
e
deduced
based
on
the
same
idea.
The
considered
programs
are
F
!
I
nd
programs.
Heuristics
are
needed
to
retriev
e
in
termediate
subsp
ecications
b
y
unication.
Annotations
can
b
e
added
in
F
!
I
nd
programs
to
explicitly
giv
e
subsp
ecications.
Then,
the
heuristic
metho
d
is
complete
for
sucien
tly
annotated
programs.
Optimizations
can
b
e
in
tro
duced
to
consider
more
natural
programs.
This
metho
d
presen
ts
t
w
o
dieren
t
asp
ects
:
it
is
b
oth
a
metho
d
of
pro
ving
programs
and
a
metho
d
of
syn
thetically
describing
pro
ofs.
Indeed,
w
eak
extracted
programs
can
b
e
seen
as
pro
ofs
descriptions.
This
metho
d
can
b
e
compared
with
the
Hoare's
logic.
Indeed,
Hoare's
logic
pro
v
es
that
programs
meet
sp
ecications.
The
structure
of
the
program
is
analyzed
and
subsp
ecications
corresp
onding
to
subprograms
are
generated
un
til
arriving
to
axioms.
Our
idea
is
exactly
the
same.
The
Hoare's
axioms
corresp
onds
to
our
logical
lemmas.
A
kno
wn
problem
of
Hoare's
logic
is
the
problem
of
retrieving
lo
op
in
v
arian
ts.
This
can
b
e
compared
to
our
problem
of
retrieving
elimination
predicates
in
the
heuristic
metho
d.
In
Hoare's
logic,
the
user
is
necessary
to
explicitly
giv
e
in
v
arian
ts.
In
our
metho
d,
it
is
necessary
to
add
annotations.
The
main
dierence
b
et
w
een
the
t
w
o
metho
ds
is
that
they
are
in
dieren
t
framew
orks.
The
Hoare's
logic
considers
imp
erativ
e
programs
and
sp
ecications
in
rst
order
predicate
calculus.
W
e
consider
functional
programs
and
sp
ecications
in
the
Calculus
of
Inductiv
e
Constructions.
Moreo
v
er,
this
w
ork
can
b
e
compared
with
the
problem
of
retrieving
the
w
eak
est
precondition
in
Hoare's
Logic.
This
problem
consists
in
lo
oking
for
a
minim
al
precondition.
This
can
b
e
done
b
y
analyzing
the
program
and
the
p
ostcondition
and
building
step-b
y-step
the
w
eak
est
precondition.
Our
metho
d
is
close
to
this
one.
Indeed,
w
e
can
reconstruct
a
pro
of
term
for
a
sp
ecication
logically
equiv
alen
t
to
the
initial
one.
In
fact,
this
sp
ecication
con
tains
less
logical
informations
than
the
initial
one.
It
can
b
e
considered
as
a
construction
of
the
\w
eak
est
sp
ecication".
The
motiv
atio
ns
of
this
w
ork
w
ere
that
the
user
kno
ws
in
general
the
algorithm
he
w
an
ts
to
pro
v
e.
The
same
motiv
ations
are
the
basis
of
t
w
o
w
orks
[BM	
,
P
ol	
].
These
w
orks
construct
a
pro
of
and
a
program
hand
in
hand.
It
is
not
the
same
metho
d
as
our
but
the
motiv
ations
are
the
same
:
allo
wing
the
user
to
direct
the
pro
of
with
a
program.
This
metho
d
has
b
een
implem
en
ted
as
a
tactic
in
the
Co
q
system.
As
w
e
already
said,
the
description
of
this
tactic
can
b
e
found
in
[P
ar	
].
A
library
of
examples
has
b
een
dev
elop
ed
with
optimizations
on
the
input
language
for
programs.
W
e
can
use
the
ProPre
tactic
of
[MS	]
whic
h
has
b
een
in
tegrated
in
to
Co
q
to
dene
functions
via
equations.
This
denition
is
transformed
in
to
a
primitiv
e
recursiv
e
denition
whic
h
can
b
e
used
as
input
for
our
tactic.
This
can
allo
w
to
write
more
easily
input
programs
for
our
tactic.
In
the
curren
t
state,
this
is
p
ossible
but
only
for
a
restricted
n
um
b
er
of
functions.
W
e
hop
e
the
n
um
b
er
of
functions
easily
expressible
with
Propre
will
increase
and
then
allo
w
us
to
use
it
in
a
more
general
w
a
y
.
Moreo
v
er,
w
e
hop
e
to
b
e
able
to
write
programs
in
more
natural
form
than
F
!
I
nd
programs.
Finally
,
other
metho
ds
of
pro
of
syn
thesis
from
programs
could
p
erhaps
b
e
dev
elop
ed.
It
should
b
e
p
ossible
to
w
ork
with
the
program
f
and
with
the
pro
of
to
do
of
x:(P
x)
!
(Q
x
(f
x)).
This
form
ula
express
that
f
realizes
x:(P
x)
!
	y
:(Q
x
y
).
The
dev
elop
ed
tec
hnology
should
not
b
e
v
ery
dieren
t
but
one
can
hop
e
to
pro
v
e
more
things
since
a
pro
of
of
\f
realizes
B
"
can
sometimes
b
e
done
when
a
pro
of
of
B
do
es
not
exist.
References
[Bar	]
H.
Barendregt.
Lam
b
da
Calculi
with
T
yp
es.
T
ec
hnical
Rep
ort
	-	,
Catholic
Univ
ersit
y
Ni-
jmegen,
Septem
b
er
		.


[BM	]
R.
Burstall
and
J.
McKinna.
Deliv
erables
:
a
categorical
approac
h
to
program
dev
elopmen
t
in
t
yp
e
theory
.
T
ec
hnical
Rep
ort
	-,
LF
CS,
Octob
er
		.
Also
in
[NPP	
].
[Con]
R.
L.
Constable
et
al.
Implementing
Mathematics
with
the
Nuprl
Pr
o
of
Development
System.
Pren
tice-Hall,
	.
[Co
q]
T.
Co
quand.
Une
th

eorie
des
c
onstructions.
PhD
thesis,
Univ
ersit

e
P
aris
VI
I,
	.
[DFH
+
	]
G.
Do
w
ek,
A.
F
elt
y
,
H.
Herb
elin,
G.
Huet,
C.
Murth
y
,
C.
P
aren
t,
C.
P
aulin-Mohring,
and
B.
W
erner.
The
Co
q
Pro
of
Assistan
t
User's
Guide
-
V
ersion
..
T
ec
hnical
Rep
ort
,
Pro-
jet
F
ormel
-
INRIA-Ro
cquencourt-CNRS-ENS
Ly
on,
Ma
y
		.
[Gir]
J.Y.
Girard.
Interpr

etation
fonctionnel
le
et

elimination
des
c
oupur
es
de
l'arithm

etique
d'or
dr
e
sup

erieur.
PhD
thesis,
Univ
ersit

e
P
aris
,
	.
[Hoa	]
C.A.R.
Hoare.
An
Axiomatic
Basis
for
Computer
Programming
.
Communic
ations
of
the
A
CM,
(0),
Octob
er
		.
[Ho
w0]
W.A.
Ho
w
ard.
The
form
ulaes-as-t
yp
es
notion
of
construction.
In
J.R.
Hindley
,
editor,
T
o
H.B.Curry
:
Essays
on
Combinatory
L
o
gic
,
lamb
da-c
alculus
and
formalism.
Seldin,
J.P
.,
	0.
[ML]
P
.
Martin-L
of.
Intuitionistic
T
yp
e
The
ory.
Studies
in
Pro
of
Theory.
Bibliop
olis,
	.
[MS	]
P
.
Manoury
and
M.
Simonot.
Des
pr
euves
de
totalit

e
de
fonctions
c
omme
synth

ese
de
pr
o
gr
ammes.
PhD
thesis,
Univ
ersit

e
P
ARIS
,
Decem
b
er
		.
[NPP	]
B.
Nordstr
om,
K.
P
etersson,
and
G.
Plotkin,
editors.
Pr
o
o
c
e
e
dings
of
the
		
worshop
on
typ
es
for
pr
o
ofs
and
pr
o
gr
ams,
June
		.
[NPS	0]
B.
Nordstr
om,
K.
P
etersson,
and
J.
M.
Smith.
Pr
o
gr
amming
in
Martin-L
of
's
T
yp
e
The
ory
:
an
intr
o
duction.
Oxford
Science
Publications,
		0.
[P
ar	]
C.
P
aren
t.
Dev
eloping
certied
programs
in
the
system
Co
q
-
The
Program
tactic.
In
H.
Baren-
dregt
and
T.
Nipk
o
w,
editors,
T
yp
es
F
or
Pr
o
ofs
and
Pr
o
gr
ams,
v
olume
0
of
LNCS,
pages
	{,
Ma
y
		.
[PC	]
F.
Pfenning
and
P
aulin-Mohring
C.
Inductiv
ely
Dened
T
yp
es
in
the
Calculus
of
Constructions.
In
th
International
Confer
enc
e
on
Mathematic
al
F
oundations
of
Pr
o
gr
amming
Semantics,
v
olume

of
LNCS,
pages
0	{,
		.
[PM	a]
C.
P
aulin-Mohring.
Extracting
F
!
's
programs
from
pro
ofs
in
the
Calculus
of
Constructions.
In
Sixte
enth
A
nnual
A
CM
Symp
osium
on
Principles
of
Pr
o
gr
amming
L
anguages,
Austin,
Jan
uary
		.
[PM	b]
C.
P
aulin-Mohring.
Extr
action
de
pr
o
gr
ammes
dans
le
Calcul
des
Constructions.
PhD
thesis,
Univ
ersit

e
P
aris
VI
I,
		.
[PM	]
C.
P
aulin-Mohring.
Inductiv
e
Denitions
in
the
System
Co
q
-
Rules
and
Prop
erties.
In
T
yp
e
d
L
amb
da
Calculi
and
Applic
ations,
v
olume

of
LNCS,
Marc
h
		.
Also
in
researc
h
rep
ort
	-	,
LIP-ENS
Ly
on,
Decem
b
er
		.
[P
ol	]
E.
P
oll.
A
Pr
o
gr
amming
L
o
gic
Base
d
on
T
yp
e
The
ory.
PhD
thesis,
T
ec
hnisc
he
Univ
ersiteit
Eindho
v
en,
		.
	

