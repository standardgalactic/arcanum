Knowledge Representation and
Reasoning
Logics for Artiﬁcial Intelligence
Stuart C. Shapiro
Department of Computer Science and Engineering
and Center for Cognitive Science
University at Buﬀalo, The State University of New York
Buﬀalo, NY 14260-2000
shapiro@cse.buffalo.edu
copyright c⃝1995, 2004–2010 by Stuart C. Shapiro
Page 1

Contents
Part I
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2. Propositional Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3. Predicate Logic Over Finite Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
4. Full First-Order Predicate Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
5. Summary of Part I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .362
Part II
6. Prolog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
7. A Potpourri of Subdomains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
8. SNePS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .428
9. Belief Revision/Truth Maintenance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
10. The Situation Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 569
11. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588

Part III
12. Production Systems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
13. Description Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
14. Abduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Page 3

1
Introduction
1. Knowledge Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2. Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
Page 4

1.1 Knowledge Representation
Artiﬁcial Intelligence (AI)
A ﬁeld of computer science and engineering concerned with the
computational understanding of what is commonly called
intelligent behavior, and with the creation of artifacts that exhibit
such behavior.
Page 5

Knowledge Representation
A subarea of Artiﬁcial Intelligence concerned with understanding,
designing, and implementing ways of representing information in
computers so that programs (agents) can use this information
• to derive information that is implied by it,
• to converse with people in natural languages,
• to decide what to do next
• to plan future activities,
• to solve problems in areas that normally require human
expertise.
Page 6

Reasoning
Deriving information that is implied by the information already
present is a form of reasoning.
Knowledge representation schemes are useless without the ability
to reason with them.
So, Knowledge Representation and Reasoning (KRR)
Page 7

Manifesto of KRR
a program has common sense if it automatically deduces for itself a
suﬃciently wide class of immediate consequences of anything it is
told and what it already knows. . . In order for a program to be
capable of learning something it must ﬁrst be capable of being told
it. John McCarthy, “Programs with Common Sense”, 1959.
Page 8

Knowledge vs. Belief
Knowledge: justiﬁed true belief.
John believes that the world is ﬂat: Not true.
Sally believes that the ﬁrst player in chess can always win,
Betty believes that the second player can always win,
and Mary believes that, with optimal play on both sides, chess will
always end in a tie.
One of them is correct,
but none are justiﬁed.
So Belief Representation & Reasoning: more accurate
But we’ll continue to say KRR.
Page 9

In Class Exercise
“An Approach to Serenity”
Page 10

Easy NL Inferences
Every student studies hard.
Therefore every smart student studies.
Tuesday evening, Jack either went to the movies, played bridge, or
studied.
Tuesday evening, Jack played bridge.
Therefore, Jack neither went to the movies nor studied Tuesday
evening.
Page 11

Background Knowledge:
Some Sentences and
How We Understand Them.
John likes ice cream.
John likes to eat ice cream.
Mary likes Asimov.
Mary likes to read books written by Isaac Asimov.
Page 12

Background Knowledge:
Some Sentences and
How We Understand Them.
Bill ﬂicked the switch.
The room was ﬂooded with light.
Bill moved the switch to the “on” position, which caused a light to
come on, which lit up the room Bill was in.
Betty opened the blinds.
The courtyard was ﬂooded with light.
Betty adjusted the blinds so that she could see through the window
they were in front of, after which she could see that the courtyard
on the other side of the window was bright.
Page 13

Memory Integration in Humans
After seeing these sentences (among others),
The sweet jelly was on the kitchen table.
The ants in the kitchen ate the jelly.
The ants ate the sweet jelly that was on the table.
The sweet jelly was on the table.
The jelly was on the table.
The ants ate the jelly.
subjects, with high conﬁdence reported that they had seen the
sentence,
The ants ate the sweet jelly that was on the kitchen table.
[Bransford and Franks (1971). The abstraction of linguistic ideas. Cognitive
Psychology, 2, 331-350, as reported on
http://www.rpi.edu/∼verwyc/cognotes5.htm.]
Page 14

Requirements for
a Knowledge-Based Agent
1. “what it already knows” [McCarthy ’59]
A knowledge base of beliefs.
2. “it must ﬁrst be capable of being told” [McCarthy ’59]
A way to put new beliefs into the knowledge base.
3. “automatically deduces for itself a suﬃciently wide class of
immediate consequences” [McCarthy ’59]
A reasoning mechanism to derive new beliefs from ones already
in the knowledge base.
Page 15

1.2 Logic
• Logic is the study of correct reasoning.
• It is not a particular KRR language.
• There are many systems of logic (logics).
• AI KRR research can be seen as a hunt for the “right” logic.
Page 16

Commonalities among Logics
• System for reasoning.
• Prevent reasoning from “truths” to “falsities”.
(But can reason from truths and falsities to truths and
falsities.)
• Language for expressing reasoning steps.
Page 17

Parts of the Study/Speciﬁcation
of a Logic
Syntax: The atomic symbols of the logical language, and the rules
for constructing well-formed, nonatomic expressions (symbol
structures) of the logic.
Semantics: The meanings of the atomic symbols of the logic, and
the rules for determining the meanings of nonatomic
expressions of the logic.
Proof Theory: The rules for determining a subset of logical
expressions, called theorems of the logic.
Page 18

2
Propositional Logic
Logics that do not analyze information below the level of the
proposition.
2.1 What is a Proposition?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .20
2.2 CarPool World: A Motivational “Micro-World”. . . . . . . . . . . . . .23
2.3 The “Standard” Propositional Logic. . . . . . . . . . . . . . . . . . . . . . . . .24
2.4 Important Properties of Logical Systems . . . . . . . . . . . . . . . . . . . 133
2.5 Clause Form Propositional Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
Page 19

2.1
What is a Proposition?
An expression in some language
• that is true or false
• whose negation makes sense
• that can be believed or not
• whose negation can be believed or not
• that can be put in the frame
“I believe that it is not the case that
.”
Page 20

Examples
Of propositions
• Betty is the driver of the car.
• Barack Obama is sitting down or standing up.
• If Opus is a penguin, then Opus doesn’t ﬂy.
Of non-propositions
• Barack Obama
• how to ride a bicycle
• If the ﬁre alarm rings, leave the building.
Page 21

Sentences vs. Propositions
A sentence is an expression of a (written) language that begins
with a capital letter and ends with a period, question mark, or
exclamation point.
Some sentences do not contain a proposition:
“Hi!”, “Why?”, “Pass the salt!”
Some sentences do not express a proposition, but contain one:
“Is Betty driving the car?”
Some sentences contain more than one proposition:
If Opus is a penguin, then Opus doesn’t ﬂy.
Page 22

2.2
CarPool World: A Motivational
“Micro-World”
• Tom and Betty carpool to work.
• On any day, either Tom drives Betty or Betty drives Tom.
• In the former case, Tom is the driver and Betty is the passenger.
• In the latter case, Betty is the driver and Tom is the passenger.
Propositions:
Betty drives Tom.
Tom drives Betty.
Betty is the driver.
Tom is the driver.
Betty is the passenger.
Tom is the passenger.
Page 23

2.3
The “Standard” Propositional Logic
1. Syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25
2. Semantics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .39
3. Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
Page 24

2.3.1
Syntax of the “Standard” Propositional Logic
Atomic Propositions
• Any letter of the alphabet, e.g.: P
• Any letter of the alphabet with a numerical subscript, e.g.: Q3
• Any alphanumeric string, e.g.: Tom is the driver
is an atomic proposition.
Page 25

Well-Formed Propositions (WFPs)
1. Every atomic proposition is a wfp.
2. If P is a wfp, then so is (¬P).
3. If P and Q are wfps, then so are
(a)
(P ∧Q)
(b)
(P ∨Q)
(c)
(P ⇒Q)
(d)
(P ⇔Q)
4. Nothing else is a wfp.
Parentheses may be omitted. Precedence: ¬; ∧, ∨; ⇒; ⇔.
Will allow (P1 ∧· · · ∧Pn) and (P1 ∨· · · ∨Pn).
Square brackets may be used instead of parentheses.
Page 26

Examples of WFPs
¬(A ∧B) ⇔(¬A ∨¬B)
Tom is the driver ⇒Betty is the passenger
Betty drives Tom ⇔¬Tom is the driver
Page 27

Alternative Symbols
¬ :
∼
!
∧: & ·
∨:
|
⇒:
→
⊃
->
⇔:
↔
≡
<->
Page 28

A Computer-Readable Syntax for Wfps
Based on CLIF, the Common Logic Interchange Formata
Atomic Propositions: Use one of:
Embedded underscores: Betty drives Tom
Embedded hyphens: Betty-drives-Tom
CamelCase: BettyDrivesTom
sulkingCamelCase: bettyDrivesTom
Escape brackets: |Betty drives Tom|
Quotation marks: "Betty drives Tom"
Page 29
aISO/IEC, Information technology — Common Logic (CL): a framework for
a family of logic-based languages, ISO/IEC 24707:2007(E), 2007.

CLIF for Non-Atomic Wfps
Print Form
CLIF Form
¬P
(not P)
P ∧Q
(and P Q)
P ∨Q
(or P Q)
P ⇒Q
(if P Q)
P ⇔Q
(iff P Q)
(P1 ∧· · · ∧Pn)
(and P1 ...Pn)
(P1 ∨· · · ∨Pn)
(or P1 ...Pn)
Page 30

Semantics of Atomic Propositions 1
Intensional Semantics
• Dependent on a Domain.
• Independent of any speciﬁc
interpretation/model/possible world/situation.
• Statement in a previously understood language (e.g. English)
that allows truth value to be determined in any speciﬁc
situation.
• Often omitted, but shouldn’t be.
Page 31

Intensional CarPool World Semantics
[Betty drives Tom] = Betty drives Tom to work.
[Tom drives Betty] = Tom drives Betty to work.
[Betty is the driver] = Betty is the driver of the car.
[Tom is the driver] = Tom is the driver of the car.
[Betty is the passenger] = Betty is the passenger in the car.
[Tom is the passenger] = Tom is the passenger in the car.
Page 32

Alternative Intensional CarPool World
Semantics
[Betty drives Tom] = Tom drives Betty to work.
[Tom drives Betty] = Betty drives Tom to work.
[Betty is the driver] = Tom is the passenger in the car.
[Tom is the driver] = Betty is the passenger in the car.
[Betty is the passenger] = Tom is the driver of the car.
[Tom is the passenger] = Betty is the driver of the car.
Page 33

Alternative CarPool World
Syntax/Intensional Semantics
[A] = Betty drives Tom to work.
[B] = Tom drives Betty to work.
[C] = Betty is the driver of the car.
[D] = Tom is the driver of the car.
[E] = Betty is the passenger in the car.
[F] = Tom is the passenger in the car.
Page 34

Intensional Semantics Moral
• Don’t omit.
• Don’t presume.
• No “pretend it’s English semantics”.
Page 35

Intensional Semantics of WFPs
[¬P] = It is not the case that [P].
[P ∧Q] = [P] and [Q].
[P ∨Q] = Either [P] or [Q] or both.
[P ⇒Q] = If [P] then [Q].
[P ⇔Q] = [P] if and only if [Q].
Page 36

Example CarPool World Intensional
WFP Semantics
[Betty drives Tom ⇔¬Tom is the driver ]
= Betty drives Tom to work
if and only if Tom is not the driver of the car.
Page 37

Terminology
• ¬P is called the negation of P.
• P ∧Q is called the conjunction of P and Q.
P and Q are referred to as conjuncts.
• P ∨Q is called the disjunction of P and Q.
P and Q are referred to as disjuncts.
• P ⇒Q is called a conditional or implication.
P is referred to as the antecedent;
Q as the consequent.
• P ⇔Q is called a biconditional or equivalence.
Page 38

2.3.2
Semantics of Atomic Propositions 2
Extensional Semantics
• Relative to an interpretation/model/possible world/situation.
• Either True or False.
Page 39

Extensional CarPool World Semantics
Denotation in Situation
Proposition
1
2
3
4
5
Betty drives Tom
True
True
True
False
False
Tom drives Betty
True
True
False
True
False
Betty is the driver
True
True
True
False
False
Tom is the driver
True
False
False
True
False
Betty is the passenger
True
False
False
True
False
Tom is the passenger
True
False
True
False
False
Note: n propositions ⇒2n possible situations.
6 propositions in CarPool World
⇒26 = 64 diﬀerent situations.
Page 40

Extensional Semantics of WFPs
[[¬P]] is True if [[P]] is False. Otherwise, it is False.
[[P ∧Q]] is True if [[P]] is True and [[Q]] is True. Otherwise, it is
False.
[[P ∨Q]] is False if [[P]] is False and [[Q]] is False. Otherwise, it is
True.
[[P ⇒Q]] is False if [[P]] is True and [[Q]] is False. Otherwise, it is
True.
[[P ⇔Q]] is True if [[P]] and [[Q]] are both True, or both False.
Otherwise, it is False.
Note that this is the outline of a recursive function that evaluates a wfp,
given the truth values of its atomic propositions.
Page 41

Extensional Semantics Truth Tables
P
True
False
¬P
False
True
P
True
True
False
False
Q
True
False
True
False
P ∧Q
True
False
False
False
P ∨Q
True
True
True
False
P ⇒Q
True
False
True
True
P ⇔Q
True
False
False
True
Notice that each column of these tables represents a diﬀerent
situation.
Page 42

Material Implication
P ⇒Q is True when P is False.
So,
If the world is ﬂat, then the moon is made of green cheese
is considered True if if . . . then is interpreted as material
implication.
Page 43

(P ⇒Q) ⇔(¬P ∨Q)
P
True
True
False
False
Q
True
False
True
False
¬P
False
False
True
True
P ⇒Q
True
False
True
True
¬P ∨Q
True
False
True
True
(P ⇒Q) is sometimes taken as a abbreviation of (¬P ∨Q)
Note: “Uninterpreted Language”, Formal Logic,
applicable to every logic in the class.
Page 44

Example CarPool World Truth Table
Betty drives Tom
True
True
False
False
Tom is the driver
True
False
True
False
¬Tom is the driver
False
True
False
True
Betty drives Tom ⇔¬Tom is the driver
False
True
True
False
Page 45

Computing Denotations
Use the procedure sketched on page 41.
Use Spreadsheet:
See http://www.cse.buffalo.edu/~shapiro/Courses/CSE563/
truthTable.xls/
Use Boole program from Barwise & Etchemendy package
Page 46

Computing the Denotation of a Wfp
in a Model
Construct a truth table containing all atomic wfps and the wfp
whose denotation is to be computed, and restrict the truth table to
the desired model.
E.g., play with http:
//www.cse.buffalo.edu/~shapiro/Courses/CSE563/cpw.xls/
Use the program /projects/shapiro/CSE563/denotation
Page 47

Example Runs of denotation Program
cl-user(1): (denotation ’(if p (if q p))
’((p . True) (q . False)))
True
cl-user(2): (denotation
’(if BettyDrivesTom
(not TomIsThePassenger))
’((BettyDrivesTom . True)
(TomIsThePassenger . True)))
False
Page 48

Model Finding
A model satisﬁes a wfp if the wfp is True in that model.
If a wfp P is False in a model, M, then M satisﬁes ¬P.
A model satisﬁes a set of wfps if they are all True in the model.
A model, M, satisﬁes the wfps P1, . . . , Pn if and only if M, satisﬁes
P1 ∧. . . ∧Pn.
Task: Given a set of wfps, A, ﬁnd satisfying models.
I.e., models that assign all wfps in A the value True.
Page 49

Model Finding with a Spreadsheet
Play with http:
//www.cse.buffalo.edu/~shapiro/Courses/CSE563/cpw.xls/
Page 50

An Informal Model Finding Algorithm
(Exponential)
• Given: Wfps labeled True, False, or unlabeled.
• If any wfp is labeled both True and False, terminate with
failure.
• If all atomic wfps are labeled, return labeling as a model.
• If ¬P is
– labeled True, try labeling P False.
– labeled False, try labeling P True.
• If P ∧Q is
– labeled True, try labeling P and Q True.
– labeled False, try labeling P False, and try labeling Q False.
Page 51

Model Finding Algorithm, cont’d
• If P ∨Q is
– labeled False, try labeling P and Q False.
– labeled True, try labeling P True, and try labeling Q True.
• If P ⇒Q is
– labeled False, try labeling P True and Q False.
– labeled True, try labeling P False,
and try labeling Q True.
• If P ⇔Q is
– labeled True, try labeling P and Q both True,
and try labeling P and Q both False.
– labeled False, try labeling P True and Q False,
and try labeling P False and Q True.
Page 52

Tableau Procedure for Model Findinga
T : BP ⇒¬BD
T : TD ⇒BP
F : ¬BD
Page 53
aBased on the semantic tableaux of Evert W. Beth, The Foundations of Math-
ematics, (Amsterdam: North Holland), 1959.

Tableau Procedure Example: Step 1
T : BD
T : BP ⇒¬BD
T : TD ⇒BP
F : ¬BD ←
Page 54

Tableau Procedure Example: Step 2
F : BP
T : ¬BD
×





PPPP
T : BD
T : BP ⇒¬BD ←
T : TD ⇒BP
F : ¬BD
Page 55

Tableau Procedure Example: Step 3
F : TD
√
T : BP
×




PPPP
F : BP
T : ¬BD
×




hhhhhhhh
T : BD
T : BP ⇒¬BD
T : TD ⇒BP ←
F : ¬BD
Model: [[BD]] = True; [[BP]] = False; [[TD]] = False
Page 56

Lisp Program for Tableau Procedure
Function: (models trueWfps &optional falseWfps trueAtoms falseAtoms)
<timberlake:~:1:62> mlisp
...
cl-user(1): :ld /projects/shapiro/CSE563/modelfinder
; Loading /projects/shapiro/CSE563/modelfinder.cl
cl-user(2): (models ’( (if BP (not BD)) (if TD BP)) ’((not BD)))
(((BD . True) (BP . False) (TD . False)))
cl-user(3): (models ’( BDT (if BDT (and BD TP)) (not (or TP BD))))
nil
cl-user(4): (models ’( (if BDT (and BD TP)) (if TDB (and TD BP))))
(((TD . True) (BP . True) (BD . True) (TP . True))
((BD . True) (TP . True) (TDB . False))
((TD . True) (BP . True) (BDT . False))
((BDT . False) (TDB . False)))
Page 57

Decreasoner,a An Eﬃcient Model Finder
On nickelback.cse.buffalo.edu
or timberlake.cse.buffalo.edu,
do
cd /projects/shapiro/CSE563/decreasoner
and try
python ubdecreasonerP.py examples/ShapiroCSE563/cpwProp.e
and
python ubdecreasonerP.py examples/ShapiroCSE563/cpwPropFindModels.e
Page 58
aDecreasoner is by Erik T. Mueller, and uses relsat, by Roberto J. Bayardo
Jr. and Robert C. Schrag, and walksat, by Bart Selman and Henry Kautz.

Decreasoner Example Input File
/projects/shapiro/CSE563/decreasoner/examples/ShapiroCSE563/
cpwPropFindModels.e:
;;; Example of Finding Models for Some Wfp
;;;
In a SubDomain of Propositional Car Pool World
;;; Stuart C. Shapiro
;;; January 23, 2009
proposition BettyIsDriver ; Betty is the driver of the car.
proposition TomIsDriver ; Tom is the driver of the car.
proposition BettyIsPassenger ; Betty is the passenger in the car.
;;; A set of well-formed propositions to find models of within CPW
(BettyIsPassenger -> !BettyIsDriver).
(TomIsDriver -> BettyIsPassenger).
!!BettyIsDriver.
Page 59

Decreasoner Example Run
<timberlake:decreasoner:1:60> python ubdecreasonerP.py
examples/ShapiroCSE563/cpwPropFindModels.e
...
model 1:
BettyIsDriver.
!BettyIsPassenger.
!TomIsDriver.
Page 60

Semantic Properties of WFPs
• A wfp is satisﬁable if it is True in at least one situation.
• A wfp is contingent if it is True in at least one situation and
False in at least one situation.
• A wfp is valid (|= P) if it is True in every situation.
A valid wfp is also called a tautology.
• A wfp is unsatisﬁable or contradictory
if it is False in every situation.
Page 61

Examples
P
True
True
False
False
Q
True
False
True
False
¬P
False
False
True
True
Q ⇒P
True
True
False
True
P ⇒(Q ⇒P)
True
True
True
True
P ∧¬P
False
False
False
False
¬P, Q ⇒P, and P ⇒(Q ⇒P) are satisﬁable,
¬P and Q ⇒P are contingent,
P ⇒(Q ⇒P) is valid,
P ∧¬P is contradictory.
Page 62

Logical Entailment
{A1, . . . , An} logically entails B in logic L
A1, . . . , An |=L B
if B is True in every situation in which every Ai is True.
If L is assumed,
A1, . . . , An |= B
If n = 0, we have validity
|= B,
i.e., B is True in every situation.
Page 63

Examples
P
True
True
False
False
Q
True
False
True
False
¬P
False
False
True
True
Q ⇒P
True
True
False
True
P ⇒(Q ⇒P)
True
True
True
True
P ∧¬P
False
False
False
False
|= P ⇒(Q ⇒P)
P |= Q ⇒P
Q, Q ⇒P |= P
Page 64

A Metatheorem
A1, . . . , An |= B
iﬀ
A1 ∧· · · ∧An |= B
Page 65

Semantic Deduction Theorem
(Metatheorem)
A1, . . . , An |= P if and only if |= A1 ∧· · · ∧An ⇒P.
So deciding validity and logical entailment are equivalent.
Page 66

Domain Knowledge (Rules)
Used to reduce the set of situations to those that “make sense”.
Page 67

Domain Rules for CarPool World
Betty is the driver ⇔¬Betty is the passenger
Tom is the driver ⇔¬Tom is the passenger
Betty drives Tom ⇒Betty is the driver ∧Tom is the passenger
Tom drives Betty ⇒Tom is the driver ∧Betty is the passenger
Tom drives Betty ∨Betty drives Tom
Page 68

Sensible CarPool World Situations
The only 2 of the 64 in which all domain rules are True:
Denotation in Situation
Proposition
3
4
Betty drives Tom
True
False
Tom drives Betty
False
True
Betty is the driver
True
False
Tom is the driver
False
True
Betty is the passenger
False
True
Tom is the passenger
True
False
Betty drives Tom ⇔¬Tom is the driver
True
True
Page 69

General Eﬀect of Domain Rules
The number of models that satisfy a set of wfps is reduced (or stays
the same) as the size of the set increases.
For a set of wfps, Γ, and a wfp P, if the number of models that
satisfy Γ ∪{P} is strictly less than the number of models that
satisfy Γ, then P is independent of Γ.
Page 70

Computer Tests of CPW Domain Rules
Spreadsheet: http:
//www.cse.buffalo.edu/~shapiro/Courses/CSE563/cpwRules.xls
Decreasoner (on nickelback or timberlake):
cd /projects/shapiro/CSE563/decreasoner
python ubdecreasonerP.py examples/ShapiroCSE563/cpwPropRules.e
Page 71

CarPool World Domain Rules in
Decreasoner
proposition BettyDrivesTom ; Betty drives Tom to work.
proposition TomDrivesBetty ; Tom drives Betty to work.
proposition BettyIsDriver ; Betty is the driver of the car.
proposition TomIsDriver ; Tom is the driver of the car.
proposition BettyIsPassenger ; Betty is the passenger in the car.
proposition TomIsPassenger ; Tom is the passenger in the car.
;;; CPW Domain Rules
BettyIsDriver <-> !BettyIsPassenger.
TomIsDriver <-> !TomIsPassenger.
BettyDrivesTom -> BettyIsDriver & TomIsPassenger.
TomDrivesBetty -> TomIsDriver & BettyIsPassenger.
TomDrivesBetty | BettyDrivesTom.
Page 72

Decreasoner on CPW with Domain Rules
python ubdecreasonerP.py examples/ShapiroCSE563/cpwPropRules.e
...
model 1:
BettyDrivesTom.
BettyIsDriver.
TomIsPassenger.
!BettyIsPassenger.
!TomDrivesBetty.
!TomIsDriver.
---
model 2:
BettyIsPassenger.
TomDrivesBetty.
TomIsDriver.
!BettyDrivesTom.
!BettyIsDriver.
!TomIsPassenger.
Page 73

The KRR Enterprise
(Propositional Logic Version)
Given a domain you are interested in reasoning about:
1. List the set of propositions (expressed in English) that captures
the basic information of interest in the domain.
2. Formalize the domain by creating one atomic wfp for each
proposition listed in step (1). List the atomic wfps, and, for each,
show the English proposition as its intensional semantics.
Page 74

The KRR Enterprise, Part 2
3. Using the atomic wfps, determine a set of domain rules so that
all, but only, the situations of the domain that make sense satisfy
them. Strive for a set of domain rules that is small and
independent.
4. Optionally, formulate an additional set of situation-speciﬁc wfps
that further restrict the domain to the set of situations you are
interested in. We will call this restricted domain the “subdomain”.
5. Letting Γ be the set of domain rules plus situation-speciﬁc wfps,
and A be any proposition you are interested in, A is True in the
subdomain if Γ |= A, is false in the subdomain if Γ |= ¬A, and
otherwise is True in some more speciﬁc situations of the
subdomain, and False in others.
Page 75

Computational Methods for Determining
Entailment and Validity
Version 1
(defun entails (KB Q)
"Returns t if the knowledge base KB entails the query Q;
else returns nil."
(loop for model in (models KB)
unless (denotation Q model)
do (return-from entails nil))
t)
Two problems:
1. models does not really return all the satisfying models;
2. entails does extra work.
Page 76

Tableau Methods
Model-Finding Refutation
To Show A1, . . . , An |= P:
• Try to ﬁnd a model that satisﬁes A1, . . . , An but falsiﬁes P.
• If you succeed, A1, . . . , An ̸|= P.
• If you fail, A1, . . . , An |= P.
All refutation model-ﬁnding methods are commonly called “tableau
methods”.
Semantic Tableaux and Wang’s Algorithm are two tableau methods
that are decision procedures for logical entailment in
Propositional Logic.
Page 77

Semantic Tableauxa
A Model-Finding Refutation Procedure
The semantic tableau refutation procedure is the same as the
tableau model-ﬁnding procedure we saw earlier, except it uses
model ﬁnding refutation to show A1, . . . , An |= P.
The goal is that all branches be closed.
Page 78
aEvert W. Beth, The Foundations of Mathematics, (Amsterdam: North Hol-
land), 1959.

A Semantic Tableau to Prove
TD, TD ⇒BP, BP ⇒¬BD |= ¬BD
T : TD
T : TD ⇒BP
T : BP ⇒¬BD
F : ¬BD
Page 79

A Semantic Tableau to Prove
TD, TD ⇒BP, BP ⇒¬BD |= ¬BD
T : BD
T : TD
T : TD ⇒BP
T : BP ⇒¬BD
F : ¬BD ←
Page 80

A Semantic Tableau to Prove
TD, TD ⇒BP, BP ⇒¬BD |= ¬BD
F : TD
×
T : BP






XXXXXX
T : BD
T : TD
T : TD ⇒BP ←
T : BP ⇒¬BD
F : ¬BD
Page 81

A Semantic Tableau To Prove
TD, TD ⇒BP, BP ⇒¬BD |= ¬BD
F : T D
×
F : BP
×
T : ¬BD
×






XXXXXX
T : BP
(
(
(
(
(
(
(
(
(
(
(
(
XXXXXX
T : BD
T : T D
T : T D ⇒BP
T : BP ⇒¬BD ←
F : ¬BD
Page 82

A Semantic Tableau to Prove
TD ⇒BP, BP ⇒¬BD ̸|= ¬BD
T : TD ⇒BP
T : BP ⇒¬BD
F : ¬BD
Page 83

A Semantic Tableau to Prove
TD ⇒BP, BP ⇒¬BD ̸|= ¬BD
T : BD
T : TD ⇒BP
T : BP ⇒¬BD
F : ¬BD ←
Page 84

A Semantic Tableau to Prove
TD ⇒BP, BP ⇒¬BD ̸|= ¬BD
F : TD
T : BP




PPPP
T : BD
T : TD ⇒BP ←
T : BP ⇒¬BD
F : ¬BD
Page 85

A Semantic Tableau to Prove
TD ⇒BP, BP ⇒¬BD ̸|= ¬BD
F : BP
√
T : ¬BD
×




aaaa
F : T D
T : BP
!
!
!
!
hhhhhhhh
T : BD
T : T D ⇒BP
T : BP ⇒¬BD ←
F : ¬BD
Can stop as soon as one satisfying model has been found.
Page 86

Wang’s Algorithma
A Model-Finding Refutation Procedure
wang(Twfps, Fwfps) {
/*
* Twfps and Fwfps are sets of wfps.
* Returns True if there is no model
* that satisfies Twfps and falsifies Fwfps;
* Otherwise, returns False.
*/
Note: is a version of models, but returns the opposite value.
Page 87
aHao Wang, Toward Mechanical Mathematics. IBM Journal of Research and
Development 4, (1960), 2-22. Reprinted in K. M. Sayre and F. J. Crosson (Eds.)
The Modeling of Mind: Computers and Intelligence. Simon and Schuster, New
York, 1963.

Wang Algorithm
if Twfps and Fwfps intersect, return True;
if every A ∈Twfps ∪Fwfps is atomic, return False;
if (P = (not A)) ∈Twfps,
return wang(Twfps \ {P}, Fwfps ∪{A});
if (P = (not A)) ∈Fwfps,
return wang(Twfps ∪{A}, Fwfps \ {P});
Page 88

Wang Algorithm
if (P = (and A B)) ∈Twfps,
return wang((Twfps \ {P}) ∪{A, B}, Fwfps);
if (P = (and A B)) ∈Fwfps,
return wang(Twfps, (Fwfps \ {P}) ∪{A})
and wang(Twfps, (Fwfps \ {P}) ∪{B});
if (P = (or A B)) ∈Twfps,
return wang((Twfps \ {P}) ∪{A}, Fwfps);
and wang((Twfps \ {P}) ∪{B}, Fwfps);
if (P = (or A B)) ∈Fwfps,
return wang(Twfps, (Fwfps \ {P}) ∪{A, B})
Page 89

Wang Algorithm
if (P = (if A B)) ∈Twfps,
return wang(Twfps \ {P}, Fwfps ∪{A})
and wang((Twfps \ {P}) ∪{B}, Fwfps);
if (P = (if A B)) ∈Fwfps,
return wang(Twfps ∪{A}, (Fwfps \ {P}) ∪{B});
if (P = (iﬀA B)) ∈Twfps,
return wang((Twfps \ {P}) ∪{A, B}, Fwfps)
and wang(Twfps \ {P}, Fwfps ∪{A, B});
if (P = (iﬀA B)) ∈Fwfps,
return wang(Twfps ∪{A}, (Fwfps \ {P}) ∪{B})
and wang(Twfps ∪{B}, (Fwfps \ {P}) ∪{A});
Page 90

Implemented Wang Function
(wang ’(A1, . . . , An) ’(P))
Returns t if A1, . . . , An |= P;
nil otherwise.
Page 91

Alternative View of Wang Function
(wang KB (Query))
Returns t if the Query follows from the KB
nil otherwise.
Front end:
(entails KB Query)
Returns t if the Query follows from the KB
nil otherwise.
Page 92

Using Wang’s Algorithm
on a Tautology
(entails ’() ’(if A (if B A)))
0[2]: (wang
nil
((if A (if B A))))
1[2]: (wang
(A)
((if B A)))
2[2]: (wang (B A) (A))
2[2]: returned t
1[2]: returned t
0[2]: returned t
t
Page 93

Using Wang’s Algorithm
on a Non-Tautology
(entails ’() ’(if A (and A B)))
0[2]: (wang
nil
((if A (and A B))))
1[2]: (wang
(A)
((and A B)))
2[2]: (wang
(A)
(A))
2[2]: returned t
2[2]: (wang
(A)
(B))
2[2]: returned nil
1[2]: returned nil
0[2]: returned nil
nil
Page 94

Using Wang’s Algorithm
to see if
TD, TD ⇒BP, BP ⇒¬BD |= ¬BD
(entails ’(TD (if TD BP) (if BP (not BD))) ’(not BD))
0[2]: (wang
(TD (if TD BP) (if BP (not BD))) ((not BD)))
1[2]: (wang (TD (if BP (not BD)))
(TD (not BD)))
1[2]: returned t
1[2]: (wang
(BP TD (if BP (not BD))) ((not BD)))
2[2]: (wang (BP TD)
(BP (not BD)))
2[2]: returned t
2[2]: (wang ((not BD) BP TD) ((not BD)))
2[2]: returned t
1[2]: returned t
0[2]: returned t
t
Page 95

Properties of Wang’s Algorithm
1. Wang’s Algorithm is sound:
If (wang A ’(B)) = t then A |= B
2. Wang’s Algorithm is complete:
If A |= B then (wang A ’(B)) = t
3. Wang’s Algorithm is a decision procedure:
For any valid inputs A, B,
(wang A ’(B)) terminates
and returns t iﬀA |= B
Page 96

Example: Tom’s Evening Domaina
If there is a good movie on TV and Tom doesn’t have an early
appointment the next morning, then he stays home and watches a
late movie. If Tom needs to work and doesn’t have an early
appointment the next morning, then he works late. If Tom works
and needs his reference materials, then he works at his oﬃce. If
Tom works late at his oﬃce, then he returns to his oﬃce. If Tom
watches a late movie or works late, then he stays up late.
Assume: Tom needs to work, doesn’t have an early appointment,
and needs his reference materials.
Prove: Tom returns to his oﬃce and stays up late.
Page 97
aBased on an example in Stuart C. Shapiro, Processing, Bottom-up and Top-
down, in Stuart C. Shapiro, Ed. Encyclopedia of Artiﬁcial Intelligence, John
Wiley & Sons, Inc., New York, 1987, 779-785.

2.3.3
Proof Theory of the Standard Propositional Logic
• Speciﬁes when a given wfp can be derived correctly from a set
of (other) wfps.
A1, . . . , An ⊢P
• Determines what wfps are theorems of the logic.
⊢P
• Depends on the notion of proof.
Page 98

Hilbert-Style Syntactic Inference
• Set of Axioms.
• Small set of Rules of Inference.
Page 99

Hilbert-Style Proof
• A proof of a theorem P is
– An ordered list of wfps ending with P
– Each wfp on the list is
∗Either an axiom
∗or follows from previous wfps in the list by one of the
rules of inference.
Page 100

Hilbert-Style Derivation
• A derivation of P from A1, . . . , An is
– A list of wfps ending with P
– Each wfp on the list is
∗Either an axiom
∗or some Ai
∗or follows from previous wfps in the list by one of the
rules of inference.
Page 101

Example Hilbert-Style Axiomsa
All instances of:
(A1). (A ⇒(B ⇒A))
(A2). ((A ⇒(B ⇒C)) ⇒((A ⇒B) ⇒(A ⇒C)))
(A3). ((¬B ⇒¬A) ⇒((¬B ⇒A) ⇒B))
Page 102
aFrom Elliott Mendelson, Introduction to Mathematical Logic, (Princeton: D.
Van Nostrand) 1964, pp. 31–32.

Hilbert-Style Rule of Inference
Modus Ponens
A, A ⇒B
B
Page 103

Example Hilbert-Style Proof
that ⊢A ⇒A
(1) (A ⇒((A ⇒A) ⇒A))
⇒((A ⇒(A ⇒A)) ⇒(A ⇒A)) Instance of A2
(2) A ⇒((A ⇒A) ⇒A)
Instance of A1
(3) (A ⇒(A ⇒A)) ⇒(A ⇒A)
From 1, 2 by MP
(4) A ⇒(A ⇒A)
Instance of A1
(5) A ⇒A
From 3, 4 by MP
Page 104

Example Hilbert-Style Derivation
that
Tom is the driver
Tom is the driver ⇒Betty is the passenger,
Betty is the passenger ⇒¬Betty is the driver,
⊢
¬Betty is the driver
(1)
Tom is the driver
Assumption
(2)
Tom is the driver ⇒Betty is the passenger
Assumption
(3)
Betty is the passenger
From 1, 2 by MP
(4)
Betty is the passenger ⇒¬Betty is the driver
Assumption
(5)
¬Betty is the driver
From 3, 4 by MP
Page 105

Some AI Connections
AI
Logic
domain knowledge
assumptions
or domain rules
or non-logical axioms
inference engine procedures
rules of inference
knowledge base
proof
Page 106

Natural Deduction
(Style of Syntactic Inference)
• No Axioms.
• Large set of Rules of Inference.
– A few structural rules of inference.
– An introduction rule and an elimination rule for each
connective.
• A method of subproofs.a
Page 107
aFrancis Jeﬀry Pelletier, A History of Natural Deduction and Elementary
Logic Textbooks, in J. Woods, B. Brown (eds) Logical Consequence: Rival Ap-
proaches, Vol. 1. (Oxford: Hermes Science Pubs) 2000, pp. 105-138.

Fitch-Style Proofa
• A proof of a theorem P is
– An ordered list of wfps and subproofs ending with P
– Each wfp or subproof on the list must be justiﬁed by a rule
of inference.
• ⊢P is read “P is a theorem.”
Page 108
aBased on Frederic B. Fitch, Symbolic Logic: An Introduction, (New York:
Ronald Press), 1952.

Fitch-Style Derivation
• A derivation of a wfp P from an assumption A is a
hypothetical subproof whose hypothesis is A and which
contains
– An ordered list of wfps and inner subproofs ending with P
– Each wfp or inner subproof on the list must be justiﬁed by a
rule of inference.
• A ⊢P is read “P can be derived from A.”
• A Meta-theorem: A1 ∧. . . ∧An ⊢P iﬀA1, . . . , An ⊢P
Page 109

Format of Proof/Derivation
.
.
.
...
lineNumber
Wfp
RuleOfInference, lineNumber(s)
...
.
.
.
Page 110

Structural Rules of Inference
i
A1
...
i + n −1
An
Hyp
i
A
...
j
A
Rep, i
i
A
...
.
.
.
...
j
A
Reit, i
Page 111

Rules for ⇒
i
A1
...
i + n −1
An
Hyp
...
j
B
k
(A1 ∧. . . ∧An) ⇒B
⇒I, i–j
i
A
...
j
A ⇒B
k
B
⇒E, i, j
Page 112

Example Fitch-Style Proof
that ⊢A ⇒A
1.
A
Hyp
2.
A
Rep, 1
3.
A ⇒A
⇒I, 1–2
Page 113

Fitch-Style Proof of Axiom A1
1.
A
Hyp
2.
B
Hyp
3.
A
Reit, 1
4.
B ⇒A
⇒I, 2–3
5.
A ⇒(B ⇒A)
⇒I, 1–4
Page 114

Example Fitch-Style Derivation
that
Tom is the driver
Tom is the driver ⇒Betty is the passenger,
Betty is the passenger ⇒¬Betty is the driver,
⊢
¬Betty is the driver
1.
Tom is the driver
2.
Tom is the driver ⇒Betty is the passenger
3.
Betty is the passenger ⇒¬Betty is the driver
Hyp
4.
Betty is the passenger
⇒E, 1, 2
5.
¬Betty is the driver
⇒E, 4, 3
Page 115

Rules for ¬
i.
A1
...
i + n −1
An
Hyp
...
j.
B
j + 1.
¬B
j + 2.
¬(A1 ∧. . . ∧An)
¬I, i–(j + 1)
i.
¬¬A
j.
A
¬E, i
Page 116

Fitch-Style Proof of Axiom A3
1.
¬B ⇒¬A
Hyp
2.
¬B ⇒A
Hyp
3.
¬B
Hyp
4.
¬B ⇒¬A
Reit, 1
5.
¬B ⇒A
Reit, 2
6.
A
⇒E, 3, 5
7.
¬A
⇒E, 3, 4
8.
¬¬B
¬I, 3–7
9.
B
¬E, 8
10.
(¬B ⇒A) ⇒B
⇒I, 2–9
11.
(¬B ⇒¬A) ⇒((¬B ⇒A) ⇒B)
⇒I, 1–10
Page 117

Rules for ∧
i1.
A1
...
in.
An
j.
A1 ∧· · · ∧An
∧I, i1, . . . , in
i.
A1 ∧· · · ∧An
...
j.
Ak
∧E, i
Page 118

Proof that
⊢(A ∧B ⇒C) ⇒(A ⇒(B ⇒C))
1.
A ∧B ⇒C
Hyp
2.
A
Hyp
3.
B
Hyp
4.
A
Reit, 2
5.
A ∧B
∧I, 4, 3
6.
A ∧B ⇒C
Reit, 1
7.
C
⇒E, 5, 6
8.
B ⇒C
⇒I, 3–7
9.
A ⇒(B ⇒C)
⇒I, 2–8
10.
(A ∧B ⇒C) ⇒(A ⇒(B ⇒C))
⇒I, 1–9
Page 119

Proof that
⊢(A ⇒(B ⇒C)) ⇒(A ∧B ⇒C)
1.
A ⇒(B ⇒C)
Hyp
2.
A ∧B
Hyp
3.
A
∧E, 2
4.
B
∧E, 2
5.
A ⇒(B ⇒C)
Reit, 1
6.
B ⇒C
⇒E, 3, 5
7.
C
⇒E, 4, 6
8.
A ∧B ⇒C
⇒I, 2–7
9.
(A ⇒(B ⇒C)) ⇒(A ∧B ⇒C)
⇒I, 1–8
Page 120

Rules for ∨
i.
Ai
j.
A1 ∨· · · ∨Ai ∨· · · ∨An
∨I, i
i.
A1 ∨· · · ∨An
...
j1.
A1 ⇒B
...
jn.
An ⇒B
k.
B
∨E, i, j1, . . . , jn
Page 121

Proof that
⊢(A ⇒B) ⇒(¬A ∨B)
1.
A ⇒B
Hyp
2.
¬(¬A ∨B)
Hyp
3.
¬A
Hyp
4.
¬A ∨B
∨I, 3
5.
¬(¬A ∨B)
Reit, 2
6.
¬¬A
¬I, 3–5
7.
A
¬E, 6
8.
A ⇒B
Reit, 1
9.
B
⇒E, 7, 8
10.
¬A ∨B
∨I, 9
11.
¬(¬A ∨B)
Rep, 2
12.
¬¬(¬A ∨B)
¬I, 2–11
13.
¬A ∨B
¬E, 12
14.
(A ⇒B) ⇒(¬A ∨B)
⇒I, 1–14
Page 122

Proof that ⊢(A ∨B) ∧¬A ⇒B
1.
(A ∨B) ∧¬A
Hyp
2.
¬A
∧E, 1
3.
A ∨B
∧E, 1
4.
A
Hyp
5.
¬B
Hyp
6.
A
Reit, 4
7.
¬A
Reit, 2
8.
¬¬B
¬I, 5–7
9.
B
¬E, 8
10.
A ⇒B
⇒I, 4–9
11.
B
Hyp
12.
B
Rep, 11
13.
B ⇒B
⇒I, 11–12
14.
B
∨E, 3, 10, 13
15.
(A ∨B) ∧¬A ⇒B
⇒I, 1–14
Page 123

Rules for ⇔
i.
A ⇒B
...
j.
B ⇒A
k.
A ⇔B
⇔I, i, j
i.
A
...
j.
A ⇔B
k.
B
⇔E, i, j
i.
B
...
j.
A ⇔B
k.
A
⇔E, i, j
Page 124

Proof that
⊢(A ⇒(B ⇒C)) ⇔(A ∧B ⇒C)
Proof from p. 120
9.
(A ⇒(B ⇒C)) ⇒(A ∧B ⇒C)
⇒I
Proof from p. 119
18.
(A ∧B ⇒C) ⇒(A ⇒(B ⇒C))
⇒I
19.
(A ⇒(B ⇒C)) ⇔(A ∧B ⇒C)
⇔I, 9, 18
Page 125

CarPool World Derivation
1.
Tom is the driver ⇔¬Tom is the passenger
2.
Tom is the passenger ⇔Betty is the driver
3.
Betty is the driver ⇔¬Betty is the passenger
4.
Tom is the driver
Hyp
5.
¬Tom is the passenger
⇔E, 4, 1
6.
¬Betty is the passenger
Hyp
7.
Betty is the driver ⇔¬Betty is the passenger
Reit, 3
8.
Betty is the driver
⇔E, 6, 7
9.
Tom is the passenger ⇔Betty is the driver
Reit, 2
10.
Tom is the passenger
⇔E, 8, 9
11.
¬Tom is the passenger
Reit, 5
12.
¬¬Betty is the passenger
¬I, 6–11
13.
Betty is the passenger
¬E, 12
Page 126

Implementing Natural Deduction
Heuristics:
If trying to prove/derive a non-atomic wfp,
try the introduction rule for the major connective.
If trying to prove/derive a wfp,
and that wfp is a component of a wfp,
try the relevant elimination rule.
Page 127

Using SNePS 3
cl-user(2): :ld /projects/snwiz/Sneps3/sneps3
...
"Change package to snuser."
cl-user(3): :pa snuser
snuser(4): (showproofs)
nil
snuser(5): (askif ’(if A A))
Let me assume that A
Since A can be derived after assuming A
I infer wft1!: (if A A) by Implication Introduction.
wft1!: (if A A)
Page 128

Derivation by SNePS 3
snuser(12): (clearkb)
nil
snuser(13): (assert ’TomIsTheDriver)
TomIsTheDriver!
snuser(14): (assert ’(if TomIsTheDriver BettyIsThePassenger))
wft1!: (if TomIsTheDriver! BettyIsThePassenger)
snuser(15): (assert ’(if BettyIsThePassenger (not BettyIsTheDriver)))
wft3!: (if BettyIsThePassenger (not BettyIsTheDriver))
snuser(16): (askif ’(not BettyIsTheDriver))
Since wft1!: (if TomIsTheDriver! BettyIsThePassenger)
and TomIsTheDriver!
I infer BettyIsThePassenger! by Implication Elimination.
Since wft3!: (if BettyIsThePassenger! (not BettyIsTheDriver))
and BettyIsThePassenger!
I infer wft2!: (not BettyIsTheDriver) by Implication Elimination.
wft2!: (not BettyIsTheDriver)
snuser(17): (askif ’BettyIsThePassenger) ; Lemma
BettyIsThePassenger!
Page 129

SNePS 3 Proves Axiom A1
snuser(9): (clearkb)
nil
snuser(10): (askif ’(if A (if B A)))
Let me assume that A
Let me assume that B
Since A can be derived after assuming B
I infer wft1?: (if B A) by Implication Introduction.
Since wft1?: (if B A) can be derived after assuming A
I infer wft2!: (if A (if B A)) by Implication Introduction.
wft2!: (if A (if B A))
Page 130

Another Derivation by SNePS 3
snuser(24): (clearkb)
nil
snuser(25): (assert ’(iff TomIsTheDriver (not TomIsThePassenger)))
wft2!: (iff TomIsTheDriver (not TomIsThePassenger))
snuser(26): (assert ’(iff TomIsThePassenger BettyIsTheDriver))
wft3!: (iff TomIsThePassenger BettyIsTheDriver)
snuser(27): (assert ’(iff BettyIsTheDriver (not BettyIsThePassenger)))
wft5!: (iff (not BettyIsThePassenger) BettyIsTheDriver)
snuser(28): (assert ’TomIsTheDriver)
TomIsTheDriver!
snuser(29): (askif ’BettyIsThePassenger)
Since wft2!: (iff TomIsTheDriver! (not TomIsThePassenger))
and TomIsTheDriver!
I infer wft1!: (not TomIsThePassenger) by Equivalence Elimination.
Since wft3!: (iff TomIsThePassenger BettyIsTheDriver)
and wft1!: (not TomIsThePassenger)
I infer wft7!: (not BettyIsTheDriver) by Equivalence Elimination.
Since wft5!: (iff (not BettyIsThePassenger) BettyIsTheDriver)
and wft7!: (not BettyIsTheDriver)
I infer BettyIsThePassenger! by Equivalence Elimination.
BettyIsThePassenger!
Page 131

More Connections
• Deduction Theorem: A ⊢P if and only if ⊢A ⇒P.
• So proving theorems and deriving conclusions from
assumptions are equivalent.
• But no atomic proposition is a theorem.
• So theorem proving makes more use of Introduction Rules than
most AI reasoning systems.
Page 132

2.4
Important Properties of Logical Systems
Soundness: ⊢P implies |= P
Consistency: not both ⊢P and ⊢¬P
Completeness: |= P implies ⊢P
Page 133

More Connections
• If at most 1 of |= P and |= ¬P
then soundness implies consistency.
• Soundness is the essence of “correct reasoning.”
• Completeness less important for running systems since a proof
may take too long to wait for.
• The Propositional Logics we have been looking at are complete.
• G¨odel’s Incompleteness Theorem: A logic strong enough to
formalize arithmetic is either inconsistent or incomplete.
Page 134

More Connections
A1, . . . , An ⊢P
⇔
⊢A1 ∧. . . ∧An ⇒P
soundness ⇓⇑completeness
soundness ⇓⇑completeness
A1, . . . , An |= P
⇔
|= A1 ∧. . . ∧An ⇒P
Page 135

2.5
Clause Form Propositional Logic
2.5.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
2.5.2 Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
2.5.3 Proof Theory: Resolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
2.5.4 Resolution Refutation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
2.5.5 Translating Standard Wfps into Clause Form . . . . . . . . . . . . . 159
Page 136

2.5.1
Clause Form Syntax
Syntax of Atoms and Literals
Atomic Propositions:
• Any letter of the alphabet
• Any letter with a numerical subscript
• Any alphanumeric string.
Literals:
If P is an atomic proposition, P and ¬P are literals.
P is called a positive literal
¬P is called a negative literal.
Page 137

Clause Form Syntax
Syntax of Clauses and Sets of Clauses
Clauses: If L1, . . . , Ln are literals
then the set {L1, . . . , Ln} is a clause.
Sets of Clauses: If C1, . . . , Cn are clauses
then the set {C1, . . . , Cn} is a set of clauses.
Page 138

2.5.2
Clause Form Semantics
Atomic Propositions
Intensional: [P] is some proposition in the domain.
Extensional: [[P]] is either True or False.
Page 139

Clause Form Semantics: Literals
Positive Literals: The meaning of P as a literal is the same as it
is as an atomic proposition.
Negative Literals:
Intensional:
[¬P] means that it is not the case that [P].
Extensional: [[¬P]] is True if [[P]] is False;
Otherwise, it is False.
Page 140

Clause Form Semantics: Clauses
Intensional:
[{L1, . . . , Ln}] = [L1] and/or . . . and/or [Ln].
Extensional:
[[{L1, . . . , Ln}]] is True
if at least one of [[L1]], . . . , [[Ln]] is True;
Otherwise, it is False.
Page 141

Clause Form Semantics: Sets of Clauses
Intensional:
[{C1, . . . , Cn}] = [C1] and . . . and [Cn].
Extensional:
[[{C1, . . . , Cn}]] is True if [[C1]] and . . . and [[Cn]] are all True;
Otherwise, it is False.
Page 142

2.5.3
Clause Form Proof Theory: Resolution
Notion of Proof: None!
Notion of Derivation: A set of clauses constitutes a derivation.
Assumptions: The derivation is initialized with a set of
assumption clauses A1, . . . , An.
Rule of Inference: A clause may be added to a set of clauses if
justiﬁed by resolution.
Derived Clause: If clause Q has been added to a set of clauses
initialized with the set of assumption clauses A1, . . . , An by one
or more applications of resolution,
then A1, . . . , An ⊢Q.
Page 143

Resolution
{P, L1, . . . , Ln}, {¬P, Ln+1, . . . , Lm}
{L1, . . . , Ln, Ln+1, . . . , Lm}
Resolution is sound, but not complete!
Page 144

Example Derivation
1.
{¬TomIsTheDriver, ¬TomIsThePassenger}
Assumption
2.
{TomIsThePassenger, BettyIsThePassenger}
Assumption
3.
{TomIsTheDriver}
Assumption
4.
{¬TomIsThePassenger}
R,1,3
5.
{BettyIsThePassenger}
R,2,4
Page 145

Example of Incompleteness
{P} |= {P, Q}
but
{P} ̸⊢{P, Q}
because resolution does not apply to {{P}}.
Page 146

2.5.4
Resolution Refutation
• Notice that {{P}, {¬P}} is contradictory.
• Notice that resolution applies to {P} and {¬P}
producing {}, the empty clause.
• If a set of clauses is contradictory, repeated application of
resolution is guaranteed to produce {}.
Page 147

Implications
• Set of clauses {A1, . . . , An, Q} is contradictory
• means (A1 ∧. . . ∧An ∧Q) is False in all models
• means whenever (A1 ∧. . . ∧An) is True, Q is False
• means whenever (A1 ∧. . . ∧An) is True ¬Q is True
• means A1, . . . , An |= ¬Q.
Page 148

Negation and Clauses
• ¬{L1, . . . , Ln} = {{¬L1}, . . . , {¬Ln}}.
• ¬L =



¬A
if L = A
A
if L = ¬A
Page 149

Resolution Refutation
To decide if A1, . . . , An |= Q:
1. Let S = {A1, . . . , An} ∪¬Q
(Note: ¬Q is a set of clauses.)
2. Repeatedly apply resolution to clauses in S.
(Determine if {A1, . . . , An} ∪¬Q ⊢{})
3. If generate {}, A1, . . . , An |= Q.
(If {A1, . . . , An} ∪¬Q ⊢{} then A1, . . . , An |= Q)
4. If reach point where no new clause can be generated,
but {} has not appeared, A1, . . . , An ̸|= Q.
(If {A1, . . . , An} ∪¬Q ̸⊢{} then A1, . . . , An ̸|= Q)
Page 150

Example 1
To decide if {P} |= {P, Q}
S = {{P}, {¬P}, {¬Q}}
1.
{P}
Assumption
2.
{¬P}
From query clause
3.
{}
R, 1, 2
Page 151

Example 2
To decide if
{¬TomIsTheDriver, ¬TomIsThePassenger},
{TomIsThePassenger, BettyIsThePassenger},
{TomIsTheDriver}
|= {BettyIsThePassenger}
1.
{¬TomIsTheDriver, ¬TomIsThePassenger}
Assumption
2.
{TomIsThePassenger, BettyIsThePassenger}
Assumption
3.
{TomIsTheDriver}
Assumption
4.
{¬BettyIsThePassenger}
From query clause
5.
{TomIsThePassenger}
R, 2, 4
6.
{¬TomIsTheDriver}
R, 1, 5
7.
{}
R, 3, 6
Page 152

Resolution Eﬃciency Rules
Tautology Elimination: If clause C contains literals L and ¬L,
delete C from the set of clauses. (Check throughout.)
Pure-Literal Elimination: If clause C contains a literal A (¬A)
and no clause contains a literal ¬A (A), delete C from the set
of clauses. (Check throughout.)
Subsumption Elimination: If the set of clauses contains clauses
C1 and C2 such that C1 ⊆C2, delete C2 from the set of
clauses. (Check throughout.)
These rules delete unhelpful clauses.
Page 153

Resolution Strategies
Unit Preference: Resolve shorter clauses before longer clauses.
Set of Support: One clause in each pair being resolved must
descend from the query.
Many others
These are heuristics for ﬁnding {} faster.
Page 154

Example 1 Using prover
cl-user(2): :ld /projects/shapiro/AIclass/prover
; Fast loading /projects/shapiro/AIclass/prover.fasl
cl-user(3): :pa prover
prover(4): (prove ’(P) ’(or P Q))
1
(P)
Assumption
2
((not P))
From Query
3
((not Q))
From Query
Deleting
3 ((not Q))
because Q is not used positively in any clause.
4
nil
R,2,1,{}
QED
Page 155

Example 2 Using prover
prover(19): (prove ’((or (not TomIsTheDriver) (not TomIsThePassenger))
(or TomIsThePassenger BettyIsThePassenger)
TomIsTheDriver)
’BettyIsThePassenger)
1
(TomIsTheDriver)
Assumption
2
((not TomIsTheDriver) (not TomIsThePassenger))
Assumption
3
(TomIsThePassenger BettyIsThePassenger) Assumption
4
((not BettyIsThePassenger)) From Query
5
(TomIsThePassenger) R,4,3,{}
Deleting
3 (TomIsThePassenger BettyIsThePassenger)
because it’s subsumed by
5 (TomIsThePassenger)
6
((not TomIsTheDriver))
R,5,2,{}
Deleting
2 ((not TomIsTheDriver) (not TomIsThePassenger))
because it’s subsumed by
6 ((not TomIsTheDriver))
7
nil
R,6,1,{}
QED
Page 156

Example 1 Using SNARK
cl-user(5): :ld /projects/shapiro/CSE563/snark
; Loading /projects/shapiro/CSE563/snark.cl
...
cl-user(6): :pa snark-user
snark-user(7): (initialize)
...
snark-user(8): (assert ’P)
nil
snark-user(9): (prove ’(or P Q))
(Refutation
(Row 1
P
assertion)
(Row 2
false
(rewrite ~conclusion 1))
)
:proof-found
Page 157

Properties of Resolution Refutation
Resolution Refutation is sound, complete, and a decision procedure
for Clause Form Propositional Logic.
It remains so when Tautology Elimination, Pure-Literal
Elimination, Subsumption Elimination and the Unit-Preference
Strategy are included.
It remains so when Set of Support is used as long as the
assumptions are not contradictory.
Page 158

2.5.5
Equivalence of Standard Propositional Logic and
Clause FormLogic
Every set of clauses,
{{L1,1, . . . , L1,n1}, . . . , {Lm,1, . . . , Lm,nm}}
has the same semantics as the standard wfp
((L1,1 ∨· · · ∨L1,n1) ∧· · · ∧(Lm,1 ∨· · · ∨Lm,nm))
That is, there is a translation from any set of clauses into a
well-formed proposition of standard propositional logic.
Question: Is there a translation from any well-formed proposition
of standard propositional logic into a set of clauses?
Answer: Yes!
Page 159

Translating Standard Wfps
into Clause Form
Conjunctive Normal Form (CNF)
A standard wfp is in CNF if it is a conjunction of disjunctions of
literals.
((L1,1 ∨· · · ∨L1,n1) ∧· · · ∧(Lm,1 ∨· · · ∨Lm,nm))
Translation technique:
1. Turn any arbitrary wfp into CNF.
2. Translate the CNF wfp into a set of clauses.
Page 160

Translating Standard Wfps
into Clause Form
Useful Meta-Theorem:
The Subformula Property
If A is (an occurrence of) a subformula of B,
and |= A ⇔C,
then |= B ⇔B{C/A}
Page 161

Translating Standard Wfps
into Clause Form
Step 1
Eliminate occurrences of ⇔using
|= (A ⇔B) ⇔((A ⇒B) ∧(B ⇒A))
From: (LivingThing ⇔(Animal ∨Vegetable))
To:
((LivingThing ⇒(Animal ∨Vegetable))
∧((Animal ∨Vegetable) ⇒LivingThing))
Page 162

Translation Step 2
Eliminate occurrences of ⇒using
|= (A ⇒B) ⇔(¬A ∨B)
From:
((LivingThing ⇒(Animal ∨Vegetable))
∧((Animal ∨Vegetable) ⇒LivingThing))
To:
((¬LivingThing ∨(Animal ∨Vegetable))
∧(¬(Animal ∨Vegetable) ∨LivingThing))
Page 163

Translation Step 3
Translate to miniscope form using
|= ¬(A ∧B) ⇔(¬A ∨¬B)
|= ¬(A ∨B) ⇔(¬A ∧¬B)
|= ¬(¬A) ⇔A
From:
((¬LivingThing ∨(Animal ∨Vegetable))
∧(¬(Animal ∨Vegetable) ∨LivingThing))
To:
((¬LivingThing ∨(Animal ∨Vegetable))
∧((¬Animal ∧¬Vegetable) ∨LivingThing))
Page 164

Translation Step 4
CNF: Translate into Conjunctive Normal Form, using
|= (A ∨(B ∧C)) ⇔((A ∨B) ∧(A ∨C))
|= ((B ∧C) ∨A) ⇔((B ∨A) ∧(C ∨A))
From:
((¬LivingThing ∨(Animal ∨Vegetable))
∧((¬Animal ∧¬Vegetable) ∨LivingThing))
To:
((¬LivingThing ∨(Animal ∨Vegetable))
∧((¬Animal ∨LivingThing) ∧(¬Vegetable ∨LivingThing)))
Page 165

Translation Step 5
Discard extra parentheses using the associativity of ∧and ∨.
From:
((¬LivingThing ∨(Animal ∨Vegetable))
∧((¬Animal ∨LivingThing) ∧(¬Vegetable ∨LivingThing)))
To:
((¬LivingThing ∨Animal ∨Vegetable)
∧(¬Animal ∨LivingThing)
∧(¬Vegetable ∨LivingThing))
Page 166

Translation Step 6
Turn each disjunction into a clause,
and the conjunction into a set of clauses.
From:
((¬LivingThing ∨Animal ∨Vegetable)
∧(¬Animal ∨LivingThing)
∧(¬Vegetable ∨LivingThing))
To:
{{¬LivingThing, Animal, Vegetable},
{¬Animal, LivingThing},
{¬Vegetable, LivingThing}}
Page 167

Use of Translation
A1, . . . , An |=Standard Q
iﬀ
The translation of A1 ∧· · · ∧An ∧¬Q into a set of clauses
⊢{}
Page 168

prover Example
To prove
(LivingThing ⇔Animal ∨Vegetable), (LivingThing ∧¬Animal) |= Vegetable
prover(20): (prove ’((iff LivingThing (or Animal Vegetable))
(and LivingThing (not Animal)))
’Vegetable)
1
(LivingThing)
Assumption
2
((not Animal))
Assumption
3
((not Animal) LivingThing)
Assumption
4
((not Vegetable) LivingThing) Assumption
5
((not LivingThing) Animal Vegetable)
Assumption
6
((not Vegetable)) From Query
Deleting
3 ((not Animal) LivingThing)
because it’s subsumed by
1 (LivingThing)
Deleting
4 ((not Vegetable) LivingThing)
because it’s subsumed by
1 (LivingThing)
Page 169

prover Example, continued
1
(LivingThing)
Assumption
2
((not Animal))
Assumption
5
((not LivingThing) Animal Vegetable)
Assumption
6
((not Vegetable)) From Query
7
((not LivingThing) Animal)
R,6,5,{}
Deleting
5 ((not LivingThing) Animal Vegetable)
because it’s subsumed by
7 ((not LivingThing) Animal)
8
(Animal)
R,7,1,{}
9
((not LivingThing)) R,7,2,{}
10
nil
R,9,1,{}
QED
Page 170

Connections
Modus Ponens
A, A ⇒B
B
Resolution
{A}, {¬A, B}
{B}
Modus Tollens
A ⇒B, ¬B
¬A
Resolution
{¬A, B}, {¬B}
{¬A}
Disjunctive Syllogism
A ∨B, ¬A
B
Resolution
{A, B}, {¬A}
{B}
Chaining
A ⇒B, B ⇒C
A ⇒C
Resolution
{¬A, B}, {¬B, C}
{¬A, C}
Page 171

More Connections
Clause
Rule
{¬A1, . . . , ¬An, C}
(A1 ∧· · · ∧An) ⇒C
Set of Support
Back-chaining
Page 172

3 Predicate Logic Over Finite Models
3.1 CarPool World. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .174
3.2 The “Standard” Finite-Model Predicate Logic . . . . . . . . . . . . . . 175
3.3 Clause Form Finite-Model Predicate Logic . . . . . . . . . . . . . . . . . 211
Page 173

3.1 CarPool World
Propositional Logic
Tom drives Betty
Betty drives Tom
Tom is the driver
Betty is the driver
Tom is the passenger
Betty is the passenger
related only by the domain rules.
Predicate Logic
Drives(Tom, Betty)
Drives(Betty, Tom)
Driver(Tom)
Driver(Betty)
Passenger(Tom)
Passenger(Betty)
shows two properties, one relation, and two individuals.
Page 174

3.2 The “Standard”
Finite-Model Predicate Logic
1. Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
2. Substitutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
3. Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
4. Model Checking in Finite-Model Predicate Logic. . . . . . . . . . .202
Page 175

3.2.1 Syntax of the “Standard”
Finite-Model Predicate Logic
Atomic Symbols
Individual Constants:
• Any letter of the alphabet (preferably early),
• any (such) letter with a numeric subscript,
• any character string not containing blanks nor other
punctuation marks.
For example: a, B12, Tom, Tom’s mother-in-law.
Page 176

Atomic Symbols, Part 2
Variables:
• Any letter of the alphabet (preferably late),
• any (such) letter with a numeric subscript.
For example: u, v6.
Page 177

Atomic Symbols, Part 3
Predicate Symbols:
• Any letter of the alphabet (preferably late middle),
• any (such) letter with a numeric subscript,
• any character string not containing blanks.
For example: P, Q4, Drives.
Each Predicate Symbol must have a particular arity.
Use superscript for explicit arity.
For example: P1, Drives2, Q3
2
Page 178

Atomic Symbols, Part 4
In any speciﬁc predicate logic language
Individual Constants,
Variables,
Predicate Symbols
must be disjoint.
Set of individual constants and of predicate symbols must be ﬁnite.
Page 179

Terms
• Every individual constant and variable is a term.
• Nothing else is a term.
Page 180

Atomic Formulas
If P n is a predicate symbol of arity n,
and t1, . . . , tn are terms,
then P n(t1, . . . , tn) is an atomic formula.
E.g.: Passenger 1(Tom), Drives2(Betty, y)
(The superscript may be omitted if no confusion results.)
Page 181

Well-Formed Formulas (wﬀs):
Every atomic formula is a wﬀ.
If P is a wﬀ, then so is (¬P).
If P and Q are wﬀs, then so are
(P ∧Q)
(P ∨Q)
(P ⇒Q)
(P ⇔Q)
If P is a wﬀand x is a variable,
then ∀x(P) and ∃x(P) are wﬀs.
Parentheses may be omitted or replaced by square brackets if no
confusion results.
We will allow (P1 ∧· · · ∧Pn) and (P1 ∨· · · ∨Pn).
∀x(∀y(P)) may be abbreviated as ∀x, y(P).
∃x(∃y(P)) may be abbreviated as ∃x, y(P).
Page 182

Quantiﬁers:
In ∀xP and ∃xP
∀called the universal quantiﬁer.
∃called the existential quantiﬁer.
P is called the scope of quantiﬁcation.
Page 183

Free and Bound Variables
Every occurrence of x in P, not in the scope of some other
occurrence of ∀x or ∃x, is said to be free in P and bound in ∀xP
and ∃xP.
Every occurrence of every variable other than x that is free in P is
also free in ∀xP and ∃xP.
∀x[P(x, y) ⇔[(∃x∃zQ(x, y, z)) ⇒R(x, y)]]
Page 184

Open, Closed, and Ground
A wﬀwith a free variable is called open.
A wﬀwith no free variables is called closed,
An expression with no variables is called ground.
Page 185

CarPool World Domain Rules
PropositionalLogic
Betty is the driver ⇔¬Betty is the passenger
Tom is the driver ⇔¬Tom is the passenger
Betty drives Tom ⇒Betty is the driver ∧Tom is the passenger
Tom drives Betty ⇒Tom is the driver ∧Betty is the passenger
Tom drives Betty ∨Betty drives Tom
PredicateLogic
∀x(Driver(x) ⇔¬Passenger(x))
∀x, y(Drives(x, y) ⇒(Driver(x) ∧Passenger(y)))
Drives(Tom, Betty) ∨Drives(Betty, Tom)
Page 186

3.2.2 Substitutions
Syntax
Pairs: t/v (Read : “t for v”)
• t is any term
• v is any variable
Substitutions: {t1/v1, . . . , tn/vn}
• i ̸= j ⇒vi ̸= vj
Page 187

Terminology
σ = {t1/v1, . . . , tn/vn}
ti is a term in σ
vi is a variable of σ
Say ti/vi ∈σ and vi ∈σ,
but not ti ∈σ
Note: x is not a variable of {x/y},
i.e. x/y ∈{x/y}, y ∈{x/y}, x ̸∈{x/y}
Page 188

Substitution Application
For expression A and substitution σ = {t1/v1, . . . , tn/vn}
Aσ: replace every free occurrence of each vi in A by ti
E.g.:
P(x, y){x/y, y/x} = P(y, x)
∀x[P(x, y) ⇔[(∃x∃zQ(x, y, z)) ⇒R(x, y, z)]]{a/x, b/y, c/z}
= ∀x[P(x, b) ⇔[(∃x∃zQ(x, b, z)) ⇒R(x, b, c)]]
Page 189

3.2.3 Semantics of
Finite-Model Predicate Logic
Assumes a Finite Domain, D, of
• individuals,
• sets of individuals,
• relations over individuals
Let I be the set of all individuals in D.
Page 190

Semantics of Individual Constants
[a] = [[a]] = some particular individual in I.
There is no anonymous individual.
I.e. for every individual, i in I, there is an individual constant c
such that [c] = [[c]] = i.
Page 191

Semantics of Predicate Symbols
Predicate Symbols:
• [P1] is some category/property of individuals of I.
• [Pn] is some n-ary relation over I.
• [[P1]] is some particular subset of I.
• [[Pn]] is some particular subset of the relation
I × · · · × I
|
{z
}
n times
.
Page 192

Intensional Semantics
of Ground Atomic Formulas
• If P 1 is some unary predicate symbol,
and t is some individual constant,
then [P1(t)] is the proposition that [t] is an instance of the
category [P1] (or has the property [P1]).
• If P n is some n-ary predicate symbol,
and t1, . . . , tn are individual constants,
then [Pn(t1, . . . , tn)] is the proposition that the relation [Pn]
holds among individuals [t1], and . . . , and [tn].
Page 193

Extensional Semantics
of Ground Atomic Formulas
• If P 1 is some unary predicate symbol,
and t is some individual constant,
then [[P1(t)]] is True if [[t]] ∈[[P1]],
and False otherwise.
• If P n is some n-ary predicate symbol,
and t1, . . . , tn are individual constants,
then [[Pn(t1, . . . , tn)]] is True
if ⟨[[t1]], . . . , [[tn]]⟩∈[[Pn]],
and False otherwise.
Page 194

Semantics of WFFs, Part 1
[¬P], [P ∧Q], [P ∨Q], [P ⇒Q], [P ⇔Q]
[[¬P]], [[P ∧Q]], [[P ∨Q]], [[P ⇒Q]], and [[P ⇔Q]]
are as they are in Propositional Logic.
Page 195

Semantics of WFFs, Part 2
• [∀xP] is the proposition that every individual i in I, with
“name” ti, satisﬁes [P{ti/x}].
• [∃xP] is the proposition that some individual i in I, with
“name” ti, satisﬁes [P{ti/x}].
• [[∀xP]] is True if [[P{t/x}]] is True for every individual constant,
t. Otherwise, it is False.
• [[∃xP]] is True if there is some individual constant, t such that
[[P{t/x}]] is True. Otherwise, it is False.
Page 196

Intensional Semantics
of Individual Constants
In CarPool World
[Tom] = Someone named Tom.
[Betty] = Someone named Betty.
Page 197

Intensional Semantics
of Individual Constants
In 4-Person CarPool World
(Call it 4pCarPool World)
[Tom] = Someone named Tom.
[Betty] = Someone named Betty.
[John] = Someone named John.
[Mary] = Someone named Mary.
Page 198

Intensional Semantics
of Ground Atomic Wﬀs
In Both CarPool Worlds
Predicate Symbols:
[Driver 1(x)] = [x] is the driver of the/a car.
[Passenger 1(x)] = [x] is the passenger of the/a car.
[Drives2(x, y)] = [x] drives [y] to work.
Page 199

Extensional Semantics of
One CarPool World Situation
[[Tom]] = Tom.
[[Betty]] = Betty.
[[Driver]] = {Betty}.
[[Passenger]] = {Tom}.
[[Drives]] = {⟨Betty, Tom⟩}.
Page 200

Extensional Semantics of
One 4pCarPool World Situation
[[Tom]] = Tom.
[[Betty]] = Betty.
[[John]] = John.
[[Mary]] = Mary.
[[Driver]] = {Betty, John}.
[[Passenger]] = {Mary, Tom}.
[[Drives]] = {⟨Betty, Tom⟩, ⟨John, Mary⟩}.
Page 201

3.2.4 Model Checking
in Finite-Model Predicate Logic
• n Individual Constants.
• Predicate P j yields nj ground atomic propositions.
• kj predicates of arity j yields P
j(kj × nj) ground atomic
propositions.
• So 2
P
j(kj×nj) situations (columns of truth table).
• CarPool World has 2(2×21+1×22) = 28 = 256 situations.
• 4pCarPool World has 2(2×41+1×42) = 224 = 16, 777, 216
situations.
Page 202

Some CarPool World Situations
Driver(Tom)
T
T
F
Driver(Betty)
T
F
T
Passenger(Tom)
T
F
T
Passenger(Betty)
T
T
F
Drives(Tom, Tom)
T
F
F
Drives(Tom, Betty)
T
T
F
Drives(Betty, Tom)
T
F
T
Drives(Betty, Betty)
T
F
F
∀x(Driver(x) ⇔¬Passenger(x))
F
T
T
∀x∀y(Drives(x, y) ⇒(Driver(x) ⇔Passenger(y)))
T
T
T
Page 203

Turning
Predicate Logic Over Finite Domains
Into Ground Predicate Logic
If c1, . . . , cn are the individual constants,
• Turn ∀xP(x) into P(c1) ∧· · · ∧P(cn)
• and ∃xP(x) into P(c1) ∨· · · ∨P(cn)
• E.g.:
∀x∃y(Drives(x, y))
⇔∃yDrives(Tom, y) ∧∃yDrives(Betty, y)
⇔(Drives(Tom, Tom) ∨Drives(Tom, Betty))
∧(Drives(Betty, Tom) ∨Drives(Betty, Betty))
Page 204

Sorted Logic: A Digression
Introduce a hierarchy of sorts, s1, . . . , sn.
(A sort in logic is similar to a data type in programming.)
Assign each individual constant a sort.
Assign each variable a sort.
Declare the sort of each argument position of each predicate
symbol.
An atomic formula, P n(t1, . . . , tn) is only syntactically valid if the
sort of ti, for each i, is the sort, or a subsort of the sort, declared
for the ith argument position of P n.
Page 205

Predicate 2-Car CarPool World
in Decreasoner
sort commuter
commuter Tom, Betty
sort car
car TomsCar, BettysCar
;;; [DrivesIn(x,y,c)] = [x] drives [y] to work in car [c].
predicate DrivesIn(commuter,commuter,car)
;;; [DriverOf(x,c)] = [x] is the driver of car [c].
predicate DriverOf(commuter,car)
;;; [PassengerIn(x,c)] = [x] is a passenger in car [c].
predicate PassengerIn(commuter,car)
Page 206

Number of Ground Atomic Propositions
Unsorted vs. Sorted
Atomic Proposition
Unsorted
Sorted
DrivesIn(commuter,commuter,car)
43 = 64
23 = 8
DriverOf(commuter,car)
42 = 16
22 = 4
PassengerIn(commuter,car)
42 = 16
22 = 4
Total
96
16
Page 207

Domain Rules of 2-Car CarPool World
/projects/shapiro/CSE563/decreasoner/examples/ShapiroCSE563/4cCPWPRedRules.e
;;; If someone’s a driver of one car, they’re not a passenger in any car.
;;; (And if someone’s a passenger in one car, they’re not driver of any car.)
[commuter][car1][car2](DriverOf(commuter,car1) -> !PassengerIn(commuter,car2)).
;;; If A drives B in car C, then A is the driver of and B is a passenger in C.
[commuter1][commuter2][car](DrivesIn(commuter1,commuter2,car)
-> DriverOf(commuter1,car)
& PassengerIn(commuter2,car)).
;;; Either Tom drives Betty in Tom’s car or Betty drives Tom in Betty’s car.
DrivesIn(Tom,Betty,TomsCar) | DrivesIn(Betty,Tom,BettysCar).
;;; Tom doesn’t drive Betty’s car, and Betty doesn’t drive Tom’s car.
!DriverOf(Tom,BettysCar) & !DriverOf(Betty,TomsCar).
;;; Neither Tom nor Betty is a passenger in their own car.
!PassengerIn(Tom,TomsCar) & !PassengerIn(Betty,BettysCar).
Page 208

Decreasoner Produces Two Models
The True propositions:
model 1:
model 2:
DriverOf(Betty, BettysCar).
DriverOf(Tom, TomsCar).
DrivesIn(Betty, Tom, BettysCar). DrivesIn(Tom, Betty, TomsCar).
PassengerIn(Tom, BettysCar).
PassengerIn(Betty, TomsCar).
Page 209

Use of Predicate-Wang
cl-user(12): (wang:predicate-entails
’( (forall (x y)
(if (Drives x y)
(and (Driver x) (Passenger y))))
(Drives Betty Tom))
’(and (Driver Betty) (Passenger Tom))
’(Betty Tom))
t
Page 210

3.3 Clause Form
Finite-Model Predicate Logic
1. Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
2. Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
3. Model Finding. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215
Page 211

3.3.1 Syntax of Clause Form
Finite-Model Predicate Logic
Individual constants, predicate symbols, terms, and ground atomic
formulas as in standard ﬁnite-model predicate logic.
(Variables are not needed.)
Literals, clauses and sets of clauses as in propositional clause form
logic.
Page 212

3.3.2 Semantics of Clause Form
Finite-Model Predicate Logic
• Individual constants, predicate symbols, terms, and ground
atomic formulas as in standard ﬁnite-model predicate logic.
• Ground literals, ground clauses, and sets of ground clauses as
in propositional clause form logic.
Page 213

Translation of Standard Form
to Clause Form
Finite-Model Predicate Calculus
1. Eliminate quantiﬁers as when using model checking.
2. Translate into clause form as for propositional logic.
Page 214

3.3.3 Model Finding: GSAT
procedure GSAT(C, tries, ﬂips)
input: a set of clauses C, and positive integers tries and ﬂips
output: a model satisfying C, or failure
for i := 1 to tries do
M := a randomly generated truth assignment
for j := 1 to ﬂips do
if M |= C then return M
p := an atom such that a change in its truth
assignment gives the largest increase in the total
number of clauses in C that are satisﬁed by M
M := M with the truth assignment of p reversed
end for end for
return “no satisfying interpretation found”
[Brachman & Levesque, p. 82–83, based on Bart Selman, Hector J. Levesque and David Mitchell,
A New Method for Solving Hard Satisfiability Problems, AAAI-92.]
Page 215

A Pedagogical Implementation of GSAT
/projects/shapiro/CSE563/gsat.cl
Uses wang:expand to eliminate quantiﬁers,
and prover:clauseForm to translate to clause form.
Page 216

Example GSAT Run
cl-user(1): :ld /projects/shapiro/CSE563/gsat
...
cl-user(2): :pa gsat
gsat(3): (gsat ’((forall x (iff (Driver x) (not (Passenger x))))
(forall (x y) (if (Drives x y) (and (Driver x) (Passenger y))))
(or (Drives Tom Betty) (Drives Betty Tom))
(Driver Betty))
30 6)
A satisfying model (found on try 17) is
(((Driver Tom) nil)
((Passenger Tom) t)
((Drives Betty Betty) nil)
((Drives Tom Tom) nil)
((Drives Betty Tom) t)
((Drives Tom Betty) nil)
((Driver Betty) t)
((Passenger Betty) nil))
#<equal hash-table with 8 entries @ #x4a64dca>
Page 217

Using GSAT to Find
The Value of a Wﬀin a KB
gsat(19): (ask ’(and (Drives Betty Tom) (Passenger Tom))
’((forall x (iff (Driver x) (not (Passenger x))))
(forall (x y) (if (Drives x y) (and (Driver x) (Passenger y)
(or (Drives Tom Betty) (Drives Betty Tom))
(Driver Betty))
30 6)
A satisfying model (found on try 19) is
(((Drives Tom Tom) nil)
((Drives Betty Tom) t)
((Driver Betty) t)
((Passenger Tom) t)
((Drives Tom Betty) nil)
((Driver Tom) nil)
((Drives Betty Betty) nil) ((Passenger Betty) nil))
(and (Drives Betty Tom) (Passenger Tom)) is True in a model of the KB.
nil
Page 218

Model Finding: Walksat
A More Eﬃcient Version of GSAT
DIMACS FORMAT:
Code each atomic formula as a positive integer:
c 1 Drives(Tom, Betty) Tom drives Betty to work.
c 2 Drives(Betty, Tom) Betty drives Tom to work.
c 3 Driver(Tom) Tom is the driver of the car.
c 4 Driver(Betty) Betty is the driver of the car.
c 5 Passenger(Tom) Tom is the passenger of the car.
c 6 Passenger(Betty) Betty is the passenger of the car.
Page 219

DIMACS cont’d
Code each clause as a set ± integers, terminated by 0:
c ((~ (Driver Tom)) (~ (Passenger Tom)))
-3 -5 0
c ((~ (Driver Betty)) (~ (Passenger Betty)))
-4 -6 0
c ((Passenger Tom) (Driver Tom))
5 3 0
c ((Passenger Betty) (Driver Betty))
6 4 0
c ((~ (Drives Tom Betty)) (Driver Tom))
-1 3 0
c ((~ (Drives Betty Tom)) (Driver Betty))
-2 4 0
c ((~ (Drives Tom Betty)) (Passenger Betty))
-1 6 0
c ((~ (Drives Betty Tom)) (Passenger Tom))
-2 5 0
c ((Drives Tom Betty) (Drives Betty Tom))
1 2 0
c ((Driver Betty))
4 0
Page 220

Running Walksat
% /projects/shapiro/CSE563/WalkSAT/Walksat_v46/walksat -solcnf
< /projects/shapiro/CSE563/WalkSAT/cpw.cnf
...
ASSIGNMENT FOUND
v -1
v 2
v -3
v 4
v 5
v -6
Page 221

Model Finding: Decreasoner
Decreasoner translates sorted ﬁnite-model predicate logic wﬀs
into DIMACS clause form.
Decreasoner gives set of clauses to Relsat.
Relsat systematically searches all models. It either:
reports that there are no satisfying models;
returns up to MAXMODELS (currently 100) satisfying models;
or gives up.
If Relsat gives up, Decreasoner gives set of clauses to Walksat.
It either:
returns some satisfying models;
or returns some “near misses”;
or gives up.
Page 222

Decreasoner, Walksat, and “Near Misses”
“Let’s say that an ”N-near miss model of a SAT problem” is a truth
assignment that satisﬁes all but N clauses of the problem. Walksat provides the
command-line option:
-target N = succeed if N or fewer clauses unsatisﬁed
If relsat produces no models, the Discrete Event Calculus Reasoner invokes
walksat with -target 1. If this fails, it invokes walksat with -target 2. If this
fails, it gives up. One or two unsatisﬁed clauses may be helpful for debugging.
In my experience, three or more unsatisﬁed clauses are less useful.
If you get a near miss model, it’s often useful to rerun the Discrete Event
Calculus Reasoner. Because walksat is stochastic, you may get back a diﬀerent
near miss model, and that near miss model may be more informative than the
previous one.”
[Erik Mueller, email to scs, 1/12/2007]
Page 223

4 Full First-Order Predicate Logic (FOL)
4.1 CarPool World. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .225
4.2 The “Standard” First-Order Predicate Logic . . . . . . . . . . . . . . . 227
4.3 Clause-Form First-Order Predicate Logic . . . . . . . . . . . . . . . . . . . 260
4.4 Translating Standard Wﬀs into Clause Form . . . . . . . . . . . . . . . 306
4.5 Asking Wh Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
Page 224

4.1 CarPool World
We’ll add Tom and Betty’s mothers:
motherOf (Tom) and motherOf (Betty)
Page 225

CarPool World Domain Rules
(Partial)
∀x(Driver(x) ⇒¬Passenger(x))
∀x, y(Drives(x, y) ⇒(Driver(x) ∧Passenger(y)))
Page 226

4.2 The “Standard” First-Order
Predicate Logic
1. Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
2. Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
3. Model Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
4. Hilbert-Style Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
5. Fitch-Style Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
Page 227

4.2.1 Syntax of the “Standard”
First-Order Predicate Logic
Atomic Symbols
Individual Constants:
• Any letter of the alphabet (preferably early),
• any (such) letter with a numeric subscript,
• any character string not containing blanks nor other
punctuation marks.
For example: a, B12, Tom, Tom’s mother-in-law.
Page 228

Atomic Symbols, Part 2
Arbitrary Individuals:
• Any letter of the alphabet (preferably early),
• any (such) letter with a numeric subscript.
Indeﬁnite Individuals:
• Any letter of the alphabet (preferably early),
• any (such) letter with a numeric subscript.
Page 229

Atomic Symbols, Part 3
Variables:
• Any letter of the alphabet (preferably late),
• any (such) letter with a numeric subscript.
For example: x, y6.
Page 230

Atomic Symbols, Part 4
Function Symbols:
• Any letter of the alphabet (preferably early middle)
• any (such) letter with a numeric subscript
• any character string not containing blanks.
For example: f , g2, motherOf , familyOf .
Page 231

Atomic Symbols, Part 5
Predicate Symbols:
• Any letter of the alphabet (preferably late middle),
• any (such) letter with a numeric subscript,
• any character string not containing blanks.
For example: P, Q4, Passenger, Drives.
Page 232

Atomic Symbols, Part 6
Each Function Symbol and Predicate Symbol must have a
particular arity.
Use superscript for explicit arity.
For example: motherOf 1, Drives2, familyOf 2, g3
2
Page 233

Atomic Symbols, Part 7
In any speciﬁc predicate logic language
Individual Constants,
Arbitrary Individuals,
Indeﬁnite Individuals,
Variables,
Function Symbols,
Predicate Symbols
must be disjoint.
Page 234

Terms
• Every individual constant, every arbitrary individual, every
indeﬁnite individual, and every variable is a term.
• If f n is a function symbol of arity n, and t1, . . . , tn are terms,
then f n(t1, . . . , tn) is a term.
(The superscript may be omitted if no confusion results.)
For example: familyOf 2(Tom, motherOf 1(Betty))
• Nothing else is a term.
Page 235

Atomic Formulas
If P n is a predicate symbol of arity n,
and t1, . . . , tn are terms,
then P n(t1, . . . , tn) is an atomic formula.
E.g.: ChildIn2(Betty, familyOf 2(Tom, motherOf 1(Betty)))
(The superscript may be omitted if no confusion results.)
Page 236

Well-Formed Formulas (wﬀs):
• Every atomic formula is a wﬀ.
• If P is a wﬀ, then so is ¬(P).
• If P and Q are wﬀs, then so are
(P ∧Q)
(P ∨Q)
(P ⇒Q)
(P ⇔Q)
• If P is a wﬀand x is a variable, then ∀x(P) and ∃x(P) are wﬀs.
Parentheses may be omitted or replaced by square brackets if
no confusion results.
We will allow (P1 ∧· · · ∧Pn) and (P1 ∨· · · ∨Pn).
∀x(∀y(P)) may be abbreviated as ∀x, y(P).
∃x(∃y(P)) may be abbreviated as ∃x, y(P).
Page 237

Open, Closed, Ground, and Free For
A wﬀwith a free variable is called open.
A wﬀwith no free variables is called closed,
An expression with no variables is called ground.
Note: expressions now include functional terms.
A term t is free for a variable x in the wﬀA(x) if
no free occurrence of x in A(x) is in the scope
of any quantiﬁer ∀y or ∃y whose variable y is in t.
E.g., f(a, y, b) is free for x in ∀u∃v(A(x, u) ∨B(x, v))
but f(a, y, b) is not free for x in ∀u∃y(A(x, u) ∨B(x, y)).
Remedy: rename y in A(x). E.g., ∀u∃v(A(x, u) ∨B(x, v))
Page 238

Substitutions with Functional Terms
Notice, terms may now include functional terms.
E.g.:
P(x, f(y), z){a/x, g(b)/y, f(a)/z} = P(a, f(g(b)), f(a))
Page 239

4.2.2 Semantics of the “Standard”
First-Order Predicate Logic
Assumes a Domain, D, of
• individuals,
• functions on individuals,
• sets of individuals,
• relations on individuals
Let I be set of all individuals in D.
Page 240

Semantics of Constants
Individual Constant:
[a] = [[a]] = some particular individual in I.
Arbitrary Individual:
[a] = [[a]] = a representative of all individuals in I. Everything
True about all of them, is True of it.
Indeﬁnite Individual:
[s] = [[s]] = a representative of some individual in I, but it’s
unspeciﬁed which one.
There is no anonymous individual.
I.e. for every individual, i in I, there is a ground term t such that
[[t]] = i. (But not necessarily an individual constant.)
Page 241

Intensional Semantics of Functional
Terms
Function Symbols: [f n] is some n-ary function in D,
Functional Terms:
If f n is some function symbol and t1, . . . , tn are ground terms,
then [f n(t1, . . . , tn)] is a description of the individual in I that
is the value of [f n] on [t1], and . . . , and [tn].
Page 242

Extensional Semantics of Functional
Terms
Function Symbols: [[f n]] is some function in D,
[[f n]]: I × · · · × I
|
{z
}
n times
→I
Functional Terms:
If f n is some function symbol and t1, . . . , tn are ground terms,
then [[f n(t1, . . . , tn)]] = [[f n]]([[t1]], . . . , [[tn]]).
Page 243

Semantics of Predicate Symbols
Predicate Symbols:
• [P1] is some category/property of individuals of I
• [Pn] is some n-ary relation in D.
• [[P1]] is some particular subset of I.
• [[Pn]] is some particular subset of the relation
I × · · · × I
|
{z
}
n times
.
Page 244

Intensional Semantics
of Ground Atomic Formulas
• If P 1 is some unary predicate symbol,
and t is some ground term,
then [P1(t)] is the proposition that [t] is an instance of the
category [P1] (or has the property [P1]).
• If P n is some n-ary predicate symbol,
and t1, . . . , tn are ground terms,
then [Pn(t1, . . . , tn)] is the proposition that the relation [Pn]
holds among individuals [t1], and . . . , and [tn].
Page 245

Extensional Semantics
of Ground Atomic Formulas
Atomic Formulas:
• If P 1 is some unary predicate symbol,
and t is some ground term,
then [[P1(t)]] is True if [[t]] ∈[[P1]],
and False otherwise.
• If P n is some n-ary predicate symbol,
and t1, . . . , tn are ground terms,
then [[Pn(t1, . . . , tn)]] is True
if ⟨[[t1]], . . . , [[tn]]⟩∈[[Pn]],
and False otherwise.
Page 246

Semantics of WFFs, Part 1
[¬P], [P ∧Q], [P ∨Q], [P ⇒Q], [P ⇔Q]
[[¬P]], [[P ∧Q]], [[P ∨Q]], [[P ⇒Q]], and [[P ⇔Q]]
are as they are in Propositional Logic.
Page 247

Semantics of WFFs, Part 2
• [∀xP] is the proposition that every individual i in I, with name
or description ti, satisﬁes [P{ti/x}].
• [∃xP] is the proposition that some individual i in I, with name
or description ti, satisﬁes [P{ti/x}].
• [[∀xP]] is True if [[P{t/x}]] is True for every ground term, t.
Otherwise, it is False.
• [[∃xP]] is True if there is some ground term, t such that
[[P{t/x}]] is True. Otherwise, it is False.
Page 248

Intensional Semantics
of a 2-Car CarPool World 1
Individual Constants:
[Tom] = The individual named Tom.
[Betty] = The individual named Betty.
Functions:
[motherOf (x)] = The mother of [x].
Page 249

Intensional Semantics
of a 2-Car CarPool World 2
Predicates:
[Driver 1(x)] = [x] is the driver of a car.
[Passenger 1(x)] = [x] is the passenger in a car.
[Drives2(x, y)] = [x] drives [y] in a car.
Page 250

Extensional Semantics of
a 2-Car CarPool World Situation
[[Tom]] = the individual named Tom.
[[Betty]] = the individual named Betty.
[[motherOf ]] = {⟨[[Betty]], [[motherOf (Betty)]] ⟩,
⟨[[Tom]], [[motherOf (Tom)]]⟩}.
[[Driver]] = {[[motherOf (Betty)]], [[motherOf (Tom)]]}.
[[Passenger]] = {[[Betty]], [[Tom]]}.
[[Drives]] = {⟨[[motherOf (Betty)]], [[Betty]] ⟩,
⟨[[motherOf (Tom)]], [[Tom]] ⟩}.
Page 251

4.2.3 Model Checking in Full FOL
n Individual Constants.
At least one function yields ∞terms.∗Decreasoner.
E.g., motherOf (Tom), motherOf (motherOf (Tom)),
motherOf (motherOf (motherOf (Tom))) . . ..
So ∞ground atomic propositions.
So ∞situations (columns of truth table).
So can’t create entire truth table.
Can’t do model checking
by expanding quantiﬁed expressions
into Boolean combination of ground wﬀs.
There still could be a ﬁnite domain if at least one individual in I
has an ∞number of terms describing it, but we’ll assume not.
Page 252

4.2.4 Hilbert-Style Proof Theory
for First-Order Predicate Logic
(A1). (A ⇒(B ⇒A))
(A2). ((A ⇒(B ⇒C)) ⇒((A ⇒B) ⇒(A ⇒C)))
(A3). ((¬B ⇒¬A) ⇒((¬B ⇒A) ⇒B))
(A4). ∀xA ⇒A{t/x}
where t is any term free for x in A(x).
(A5). (∀x(A ⇒B)) ⇒(A ⇒∀xB)
if A is a wﬀcontaining no free occurrences of x.
Page 253

Hilbert-Style Rules of Inference for
“Standard” First-Order Predicate Logic
A, A ⇒B
B
A
∀xA
Note: ∃xA is just an abbreviation of ¬∀x¬A.
Page 254

4.2.5 Fitch-Style Proof Theory
for First-Order Predicate Logic
Additional Rules of Inference for ∀
i
a
Arb I
...
j
P(a)
j + 1
∀xP{x/a}
∀I, i–j
i
∀xP(x)
i + 1
P{t/x}
∀E, i
Where a is an arbitrary individual not otherwise used in the proof,
and t is any term, whether or not used elsewhere in the proof,
that is free for x in P(x).
Page 255

Example of ∀Rules
To prove ∀x(P(x) ⇒Q(x)) ⇒(∀xP(x) ⇒∀xQ(x))
1
∀x(P (x) ⇒Q(x))
Hyp
2
∀xP (x)
Hyp
3
a
Arb I
4
∀xP (x)
Reit, 2
5
P (a)
∀E, 4
6
∀x(P (x) ⇒Q(x))
Reit, 1
7
P (a) ⇒Q(a)
∀E, 6
8
Q(a)
⇒E, 5,7
9
∀xQ(x)
∀I, 3–8
10
∀xP (x) ⇒∀xQ(x)
⇒I, 2–9
11
∀x(P (x) ⇒Q(x)) ⇒(∀xP (x) ⇒∀xQ(x))
⇒I, 1–10
Page 256

Additional Rules of Inference for ∃
i
P(t)
i + 1
∃xP(x)
∃I, i
i
∃xP(x)
...
j
P{a/x}
Indef I, i
...
k
Q
k + 1
Q
∃E, j–k
Where P(x) is the result of replacing some or all occurrences of t in P(t) by x,
t is free for x in P(x);
a is an indeﬁnite individual not otherwise used in the proof,
P(a/x) is the result of replacing all occurrences of x in P(x) by a,
and there is no occurrence of a in Q. (Compare ∃E to ∨E.)
Page 257

Example of ∃Rules
To prove ∃x(P(x) ∧Q(x)) ⇒(∃xP(x) ∧∃xQ(x))
1
∃x(P (x) ∧Q(x))
Hyp
2
P (a) ∧Q(a)
Indef I, 1
3
P (a)
∧E, 2
4
∃xP (x)
∃I, 3
5
∃xP (x)
∃E, 2–4
6
P (b) ∧Q(b)
Indef I, 1
7
Q(b)
∧E, 5
8
∃xQ(x)
∃I, 6
9
∃xQ(x)
∃E, 5–7
10
∃xP (x) ∧∃xQ(x)
∧I, 5,9
11
∃x(P (x) ∧Q(x)) ⇒(∃xP (x) ∧∃xQ(x))
⇒I, 1–10
Page 258

CarPool Situation Derivation
1
∀x(Driver(x) ⇒¬Passenger(x))
2
∀x∀y(Drives(x, y) ⇒(Driver(x) ∧Passenger(y)))
3
∀xDrives(motherOf (x), x)
Hyp
4
Drives(motherOf (Tom), Tom)
∀E, 3
5
∀y(Drives(motherOf (Tom), y)
⇒(Driver(motherOf (Tom)) ∧Passenger(y)))
∀E, 2
6
Drives(motherOf (Tom), Tom)
⇒(Driver(motherOf (Tom)) ∧Passenger(Tom))
∀E, 5
7
Driver(motherOf (Tom)) ∧Passenger(Tom)
⇒E, 4, 6
8
Driver(motherOf (Tom))
∧E, 7
9
∃xDriver(motherOf (x))
∃I, 8
Page 259

4.3 Clause-Form First-Order Predicate
Logic
1. Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
2. Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
3. Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
4. Resolution Refutation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
Page 260

4.3.1 Syntax of Clause-Form First-Order
Predicate Logic
Atomic Symbols
Individual Constants:
• Any letter of the alphabet (preferably early),
• any (such) letter with a numeric subscript,
• any character string not containing blanks nor other
punctuation marks.
For example: a, B12, Tom, Tom’s mother-in-law.
Skolem Constants: Look like individual constants.
Page 261

Atomic Symbols, Part 2
Variables:
• Any letter of the alphabet (preferably late),
• any (such) letter with a numeric subscript.
For example: u, v6.
Page 262

Atomic Symbols, Part 3
Function Symbols:
• Any letter of the alphabet (preferably early middle)
• any (such) letter with a numeric subscript
• any character string not containing blanks.
For example: f, g2.
Use superscript for explicit arity.
Skolem Function Symbols: Look like function symbols.
Page 263

Atomic Symbols, Part 4
Predicate Symbols:
• Any letter of the alphabet (preferably late middle),
• any (such) letter with a numeric subscript,
• any character string not containing blanks.
For example: P, Q4, odd.
Use superscript for explicit arity.
Page 264

Terms
• Every individual constant, every Skolem constant, and every
variable is a term.
• If f n is a function symbol or Skolem function symbol of arity n,
and t1, . . . , tn are terms,
then f n(t1, . . . , tn) is a term.
(The superscript may be omitted if no confusion results.)
• Nothing else is a term.
Page 265

Atomic Formulas
If P n is a predicate symbol of arity n,
and t1, . . . , tn are terms,
then P n(t1, . . . , tn) is an atomic formula.
(The superscript may be omitted if no confusion results.)
Page 266

Literals and Clauses
Literals: If P is an atomic formula,
then P and ¬P are literals.
Clauses: If L1, . . . , Ln are literals,
then the set {L1, . . . , Ln} is a clause.
Sets of Clauses: If C1, . . . , Cn are clauses,
then the set {C1, . . . , Cn} is a set of clauses.
Page 267

4.3.2 Semantics of Clause-Form
First-Order Predicate Logic
• Individual Constants, Function Symbols, Predicate Symbols,
Ground Terms, and Ground Atomic Formulas as for Standard
FOL.
• Skolem Constants are like indeﬁnite individuals.
• Skolem Function Symbols are like indeﬁnite function symbols.
• Ground Literals, Ground Clauses, and Sets of Clauses as for
Clause-Form Propositional Logic.
Page 268

Semantics of Open Clauses
If clause C contains variables v1, . . . , vn,
then C{t1/v1, . . . , tn/vn} is a ground instance of C if it contains
no more variables.
If C is an open clause,
[[C]] is True if every ground instance of C is True.
Otherwise, it is False.
That is, variables take on universal interpretation,
with scope being the clause.
Page 269

4.3.3 Proof Theory of Clause-Form FOL
Notion of Proof: None!
Notion of Derivation: A set of clauses constitutes a derivation.
Assumptions: The derivation is initialized with a set of
assumption clauses A1, . . . , An.
Rule of Inference: A clause may be added to a set of clauses if
justiﬁed by a rule of inference.
Derived Clause: If clause Q has been added to a set of clauses
initialized with the set of assumption clauses A1, . . . , An by one
or more applications of resolution,
then A1, . . . , An ⊢Q.
Page 270

Clause-Form FOL Rules of Inference
Version 1
Resolution:
{P, L1, . . . , Ln}, {¬P, Ln+1, . . . , Lm}
{L1, . . . , Ln, Ln+1, . . . , Lm}
Universal Instantion (temporary):
C
Cσ
Page 271

Example Derivation
1.
{¬Drives(x, y), Driver(x)}
Assumption
2.
{¬Driver(z), ¬Passenger(z)}
Assumption
3.
{Drives(motherOf (Tom), Tom)}
Assumption
4.
{¬Drives(motherOf (Tom), Tom),
Driver(motherOf (Tom))}
UI , 1, {motherOf (Tom)/x, Tom/y}
5.
{Driver(motherOf (Tom))}
R, 3, 4
6.
{¬Driver(motherOf (Tom)),
¬Passenger(motherOf (Tom))}
UI , 2, {motherOf (Tom)/z}
7.
{ ¬Passenger(motherOf (Tom))}
R, 5, 6
Page 272

Motivation for a Shortcut
{P(x), L1(x), . . . , Ln(x)}
{¬P(y), Ln+1(y), . . . , Lm(y)}
↓{a/x, a/y}
↓{a/x, a/y}
{P(a), L1(a), . . . , Ln(a)}
{¬P(a), Ln+1(a), . . . , Lm(a)}
{L1(a), . . . , Ln(a), Ln+1(a), . . . , Lm(a)}
Page 273

Most General Uniﬁer
A most general uniﬁer (mgu), of atomic formulas A and B
is a substitution, µ,
such that Aµ = Bµ = a common instance of A and B
and such that every other common instance of A and B is an
instance of it.
I.e., Aµ = Bµ = a most general common instance of A and B.
Example:
Uniﬁer of P(a, x, y) and P(u, b, v) is {a/u, b/x, c/y, c/v}
giving P(a, b, c)
But more general is {a/u, b/x, y/v} giving P(a, b, y)
Page 274

Clause-Form FOL Rules of Inference
Version 2
Resolution:
{A, L1, . . . , Ln}, {¬B, Ln+1, . . . , Lm}
{L1µ, . . . , Lnµ, Ln+1µ, . . . , Lmµ}
where µ is an mgu of A and B.
Assume two parent clauses have no variables in common.
Page 275

Example Derivation Revisited
1.
{¬Drives(x, y), Driver(x)}
Assumption
2.
{¬Driver(z), ¬Passenger(z)}
Assumption
3.
{Drives(motherOf (Tom), Tom)}
Assumption
4.
{Driver(motherOf (Tom))}
R, 1, 3, {motherOf (Tom)/x, Tom/y}
5.
{ ¬Passenger(motherOf (Tom))}
R, 2, 4, {motherOf (Tom)/z, }
Page 276

Uniﬁcation
To ﬁnd the mgu of A and B.
Some Examples:
A
B
mgu
mgci
P(a, b)
P(a, b)
{}
P(a, b)
P(a)
P(b)
FAIL
P(a, x)
P(y, b)
{a/y, b/x}
P(a, b)
P(a, x)
P(y, g(y))
{a/y, g(a)/x}
P(a, g(a))
P(x, f(x))
P(y, y)
FAIL
(occurs check)
Page 277

Substitution Composition
Pστ = ((Pσ)τ) = P(σ ◦τ)
Let σ = {t1/v1, . . . , tn/vn}
σ ◦τ = {t1τ/v1, . . . , tnτ/vn} ⊎τ
σ ⊎τ = σ ∪{t/v | (t/v ∈τ) ∧v ̸∈σ}
E.g.: {x/y, y/z} ◦{u/y, v/w} = {x/y, u/z, v/w}
Page 278

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
Page 279

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
Page 280

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
Page 281

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
... (g (f u))
(g (f a)))
... v
v)
Page 282

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
... (g (f u))
(g (f a)))
... v
v)
µ = {(f u)/x}◦{(g (f u))/v} = {(f u)/x, (g (f u))/v}
Page 283

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
... (g (f u))
(g (f a)))
... v
v)
µ = {(f u)/x}◦{(g (f u))/v} = {(f u)/x, (g (f u))/v}
... (g (f a)) )
... v )
Page 284

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
... (g (f u))
(g (f a)))
... v
v)
µ = {(f u)/x}◦{(g (f u))/v} = {(f u)/x, (g (f u))/v}
... (g (f a)) )
... v )
... (g (f a)) )
... (g (f u)) )
Page 285

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
... (g (f u))
(g (f a)))
... v
v)
µ = {(f u)/x}◦{(g (f u))/v} = {(f u)/x, (g (f u))/v}
... (g (f a)) )
... v )
... (g (f a)) )
... (g (f u)) )
... a )))
... u )) )
Page 286

Manual Uniﬁcation Algorithm
(P x (g x) (g (f a)))
(P (f u) v v)
µ = {}
... x
(g x) (g (f a)))
... (f u)
v v)
µ = {}◦{(f u)/x}={(f u)/x}
... (g x)
(g (f a)))
... v
v)
... (g (f u))
(g (f a)))
... v
v)
µ = {(f u)/x}◦{(g (f u))/v} = {(f u)/x, (g (f u))/v}
... (g (f a)) )
... v )
... (g (f a)) )
... (g (f u)) )
... a )))
... u )) )
µ = {(f u)/x, (g (f u))/v}◦{a/u} = {(f a)/x, (g (f a))/v, a/u}
(P x (g x) (g (f a)))µ = (P (f u) v v)µ = (P (f a) (g (f a)) (g (f a)))
Page 287

Uniﬁcation Algorithm
(defun unify (A B &optional mu)
(cond ((eql mu ’FAIL) ’FAIL)
((eql A B) mu)
((variablep A) (unifyVar A B mu))
((variablep B) (unifyVar B A mu))
((or (atom A) (atom B)) ’FAIL)
((/= (length A) (length B)) ’FAIL)
(t (unify (rest A)
(rest B)
(unify (first A) (first B) mu)))))
Note: a more eﬃcient version is implemented in prover.cl
Page 288

UnifyVar
(defun unifyVar (var term subst)
(if (var-in-substp var subst)
(unify (term-of-var-in-subst var subst) term subst)
(let ((newterm (apply-sub subst term)))
(cond ((eql var newterm) subst)
((occursIn var newterm) ’FAIL)
(t (compose subst
(list (pair newterm var))))))))
Page 289

Program Assertion
If original A and B have no variables in common,
then throughout the above program
no substitution will have one of its variables occurring in one of its
terms.
Therefore, for any expression E and any substitution σ formed in
the above program, Eσσ = Eσ.
Page 290

4.3.4 Resolution Refutation
Example
To decide if
{¬Drives(x, y), Driver(x)}, {¬Driver(x), ¬Passenger(x)},
{Drives(motherOf (Tom), Betty)}
|= {¬Passenger(motherOf (Tom))}
1.
{¬Drives(x1 , y1 ), Driver(x1 )}
Assumption
2.
{¬Driver(x2 ), ¬Passenger(x2 )}
Assumption
3.
{Drives(motherOf (Tom), Betty)}
Assumption
5.
{Passenger(motherOf(Tom))}
From query
6.
{¬Driver(motherOf (Tom))}
R, 2, 5, {motherOf(Tom)/x2}
7.
{¬Drives(motherOf (Tom), y7 )}
R, 1, 6, {motherOf(Tom)/x1}
8.
{}
R, 3, 7, {Betty/y7}
Page 291

Example Using prover
prover(21): (prove ’((or (not (Drives ?x ?y)) (Driver ?x))
(or (not (Driver ?x)) (not (Passenger ?x)))
(Drives (motherOf Tom) Betty))
’(not (Passenger (motherOf Tom))))
1
((Drives (motherOf Tom) Betty)) Assumption
2
((not (Drives ?3 ?5)) (Driver ?3))
Assumption
3
((not (Driver ?9)) (not (Passenger ?9)))
Assumption
4
((Passenger (motherOf Tom)))
From Query
5
((not (Driver (motherOf Tom)))) R,4,3,{(motherOf Tom)/?9}
6
((not (Drives (motherOf Tom) ?86))) R,5,2,{(motherOf Tom)/?3}
7
nil
R,6,1,{Betty/?86}
QED
Page 292

Example Using snark
snark-user(84): (initialize)
snark-user(85): (assert ’(or (not (Drives ?x ?y)) (Driver ?x)))
snark-user(86): (assert ’(or (not (Driver ?x))
(not (Passenger ?x))))
snark-user(87): (assert ’(Drives (motherOf Tom) Betty))
snark-user(88): (prove ’(not (Passenger (motherOf Tom))))
(Refutation
(Row 1 (or (not (Drives ?x ?y)) (Driver ?x)) assertion)
(Row 2 (or (not (Driver ?x)) (not (Passenger ?x))) assertion)
(Row 3 (Drives (motherOf Tom) Betty) assertion)
(Row 4 (Passenger (motherOf Tom)) ~conclusion)
(Row 5 (not (Driver (motherOf Tom))) (resolve 2 4))
(Row 6 (not (Drives (motherOf Tom) ?x)) (resolve 5 1))
(Row 7 false (resolve 6 3))
)
:proof-found
Page 293

Resolution Refutation is Incomplete
for FOL
1.
{P(u), P(v)}
2.
{¬P(x), ¬P(y)}
3.
{P(w), ¬P(z)}
R, 1, 2, {u/x, w/v, z/y}
...
Page 294

Clause-Form FOL Rules of Inference
Version 3 (Last)
Resolution:
{A, L1, . . . , Ln}, {¬B, Ln+1, . . . , Lm}
{L1µ, . . . , Lnµ, Ln+1µ, . . . , Lmµ}
where µ is an mgu of A and B.
Factoring:
{A, B, L1, . . . , Ln}
{Aµ, L1µ, . . . , Lnµ}
where µ is an mgu of A and B.
(Note: Special case of UI.)
Page 295

Resolution Refutation with Factoring
is Complete
If A1, . . . , An |= Q, then A1, . . . , An, ¬Q ⊢R+F {}.
For example,
1.
{P(u), P(v)}
2.
{¬P(x), ¬P(y)}
3.
{P(w)}
F, 1, {w/u, w/v}
4.
{¬P(z)}
F, 2, {z/x, z/y}
5.
{}
R, 3, 4, {w/z}
However, resolution refutation with factoring is still not a decision
procedure—it is a semi-decision procedure.
Page 296

Factoring (Condensing) by snark
snark-user(30): (initialize)
; Running SNARK from ...
nil
snark-user(31): (assert ’(or (P ?u) (P ?v)))
nil
snark-user(32): (prove ’(and (P ?x) (P ?y)))
(Refutation
(Row 1
(or (P ?x) (P ?y))
assertion)
(Row 2
(P ?x)
(condense 1))
(Row 3
(or (not (P ?x)) (not (P ?y)))
negated_conjecture)
(Row 4
false
(rewrite 3 2))
)
:proof-found
SNARK has both factoring and condensing, which is factoring combined with immediate
subsumption elimination when the factored clause subsumes the original clause. The clause ’(or (p
a ?x) (p ?y b)) gets factored, but not condensed. [Mark Stickel, personal communication, March,
2008]
Page 297

Eﬃciency Rules
Tautology Elimination: If clause C contains literals L and ¬L,
delete C from the set of clauses. (Check throughout.)
Pure-Literal Elimination: If clause C contains a literal A (¬A)
and no clause contains a literal ¬B (B) such that A and B are
uniﬁable, delete C from the set of clauses. (Check throughout.)
Subsumption Elimination: If the set of clauses contains clauses
C1 and C2 such that there is a substitution σ for which
C1σ ⊆C2, delete C2 from the set of clauses. (Check
throughout.)
These rules delete unhelpful clauses.
Subsumption may be required to cut inﬁnite loops.
Page 298

Subsumption Cutting a Loop
prover(22): (prove ’((if (and (ancestor ?x ?y)
(ancestor ?y ?z))
(ancestor ?x ?z)))
’(ancestor ?x stu))
1
((not (ancestor ?0 ?1)) (not (ancestor ?1 ?2))
(ancestor ?0 ?2))
Assumption
2
((not (ancestor ?3 stu))) From Query
Page 299

Initial Resolution Steps
1
((not (ancestor ?0 ?1)) (not (ancestor ?1 ?2))
(ancestor ?0 ?2))
Assumption
2
((not (ancestor ?3 stu)))
From Query
3
((not (ancestor ?4 ?5)) (not (ancestor ?5 stu)))
R,2,1,{stu/?2, ?0/?3}
4
((not (ancestor ?6 stu)) (not (ancestor ?7 ?8))
(not (ancestor ?8 ?6)))
R,3,1,{?2/?5, ?0/?4}
5
((not (ancestor ?9 ?10)) (not (ancestor ?10 ?11))
(not (ancestor ?11 stu)))
R,3,1,{stu/?2, ?0/?5}
.
.
.
Page 300

Subsumption Cuts the Loop
1
((not (ancestor ?0 ?1)) (not (ancestor ?1 ?2))
(ancestor ?0 ?2))
Assumption
2
((not (ancestor ?3 stu)))
From Query
3
(not (ancestor ?4 ?5)) (not (ancestor ?5 stu)))
R,2,1,{stu/?2, ?0/?3}
4
((not (ancestor stu stu)))
F,3,{stu/?5, stu/?4}
Deleting
4 ((not (ancestor stu stu)))
because it’s subsumed by
2 ((not (ancestor ?3 stu)))
Deleting
3 ((not (ancestor ?4 ?5)) (not (ancestor ?5 stu)))
because it’s subsumed by
2 ((not (ancestor ?3 stu)))
nil
Page 301

Strategies
Unit Preference: Resolve shorter clauses before longer clauses.
Least Symbol Count Version: Count symbols, not literals.
Set of Support: One clause in each pair being resolved must
descend from the query.
Many others
These are heuristics for ﬁnding {} faster.
Page 302

Least Symbol Count Version
of Unit Preference
Instead of counting literals,
count symbols
ignoring negation operator.
Equivalent to standard unit preference for Propositional Logic.
Page 303

Problem with
Literal-Counting Unit Preference
1(1/2)
((walkslikeduck daffy)) Assumption
2(1/2)
((talkslikeduck daffy)) Assumption
3(2/5)
((not (duck (motherof ?1))) (duck ?1))
Assumption
4(3/6)
((not (walkslikeduck ?3)) (not (talkslikeduck ?3)) (duck ?3)) Assumption
5(1/2)
((not (duck daffy)))
From Query
6(1/3)
((not (duck (motherof daffy)))) R,5,3,{daffy/?1}
7(1/4)
((not (duck (motherof (motherof daffy)))))
R,6,3,{(motherof daffy)/?1}
8(1/5)
((not (duck
(motherof
(motherof
(motherof daffy)))))) R,7,3,{(motherof (motherof daffy))/?1}
9(1/6)
((not (duck
(motherof
(motherof
(motherof
(motherof
daffy)))))))
R,8,3,{(motherof (motherof (motherof daffy)))/?1}
Page 304

Solution with
Least Symbol Count Version
1(1/2)
((walkslikeduck daffy)) Assumption
2(1/2)
((talkslikeduck daffy)) Assumption
3(2/5)
((not (duck (motherof ?5))) (duck ?5))
Assumption
4(3/6)
((not (walkslikeduck ?13)) (not (talkslikeduck ?13)) (duck ?13)) Assumption
5(1/2)
((not (duck daffy)))
From Query
6(1/3)
((not (duck (motherof daffy)))) R,5,3,{daffy/?1}
7(1/4)
((not (duck (motherof (motherof daffy)))))
R,6,3,{(motherof daffy)/?1}
8(2/4)
((not (walkslikeduck daffy)) (not (talkslikeduck daffy))) R,5,4,{daffy/?3}
9(1/2)
((not (talkslikeduck daffy))) R,8,1,{}
10(0/0)
nil
R,9,2,{}
QED
Page 305

4.4 Translating Standard FOL Wﬀs into
FOL Clause Form
Useful Meta-Theorems
• If A is (an occurrence of) a subformula of B,
and |= A ⇔C,
then |= B ⇔B{C/A}
• ∀x1(· · · ∀xn(· · · ∃yA(x1, . . . , xn, y) · · · ) · · · ) is consistent
if and only if
∀x1(· · · ∀xn(· · · A(x1, . . . , xn, f n(x1, . . . , xn)) · · · ) · · · )
is consistent,
where f n is a new Skolem function.
Note: use a new Skolem constant instead of f 0().
Page 306

Translating Standard FOL Wﬀs into FOL
Clause Form
Step 1
Eliminate occurrences of ⇔using
|= (A ⇔B) ⇔((A ⇒B) ∧(B ⇒A))
From:
∀x[Parent(x) ⇔(Person(x) ∧∃y(Person(y) ∧childOf(y, x)))]
To:
∀x[(Parent(x) ⇒(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((Person(x) ∧∃y(Person(y) ∧childOf(y, x))) ⇒Parent(x))]
Page 307

Translation Step 2
Eliminate occurrences of ⇒using
|= (A ⇒B) ⇔(¬A ∨B)
From:
∀x[(Parent(x) ⇒(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((Person(x) ∧∃y(Person(y) ∧childOf(y, x))) ⇒Parent(x))]
To:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧(¬(Person(x) ∧∃y(Person(y) ∧childOf(y, x))) ∨Parent(x))]
Page 308

Translation Step 3
Translate to miniscope form using
|= ¬¬A ⇔A
|= ¬(A ∧B) ⇔(¬A ∨¬B)
|= ¬(A ∨B) ⇔(¬A ∧¬B)
|= ¬∀xA(x) ⇔∃x¬A(x)
|= ¬∃xA(x) ⇔∀x¬A(x)
From:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧(¬(Person(x) ∧∃y(Person(y) ∧childOf(y, x))) ∨Parent(x))]
To:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨∀y(¬Person(y) ∨¬childOf(y, x))) ∨Parent(x))]
Page 309

Translation Step 4
Rename apart: If any two quantiﬁers bind the same
variable, rename all occurrences of one of them.
From:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨∀y(¬Person(y) ∨¬childOf(y, x))) ∨Parent(x))]
To:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨∀z(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
Page 310

Optional Translation Step 4.5
Translate into Prenex Normal Form using:
|= (A ∧∀xB(x)) ⇔∀x(A ∧B(x))
|= (A ∧∃xB(x)) ⇔∃x(A ∧B(x))
|= (A ∨∀xB(x)) ⇔∀x(A ∨B(x))
|= (A ∨∃xB(x)) ⇔∃x(A ∨B(x))
as long as x does not occur free in A.
From:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨∀z(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
To:
∀x∃y∀z[(¬Parent(x) ∨(Person(x) ∧(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
Page 311

Translation Step 5
Skolemize
From:
∀x[(¬Parent(x) ∨(Person(x) ∧∃y(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨∀z(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
To:
∀x[(¬Parent(x) ∨(Person(x) ∧(Person(f(x)) ∧childOf(f(x), x))))
∧((¬Person(x) ∨∀z(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
or
From:
∀x∃y∀z[(¬Parent(x) ∨(Person(x) ∧(Person(y) ∧childOf(y, x))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
To:
∀x∀z[(¬Parent(x) ∨(Person(x) ∧(Person(f(x)) ∧childOf(f(x), x))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
Page 312

Translation Step 6
Discard all occurrences of “∀x” for any variable x.
From:
∀x[(¬Parent(x) ∨(Person(x) ∧(Person(f(x)) ∧childOf(f(x), x))))
∧((¬Person(x) ∨∀z(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
Or from:
∀x∀z[(¬Parent(x) ∨(Person(x) ∧(Person(f(x)) ∧childOf(f(x), x))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
To:
[(¬Parent(x) ∨(Person(x) ∧(Person(f(x)) ∧childOf(f(x), x))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
Page 313

Translation Step 7
CNF: Translate into Conjunctive Normal Form, using
|= (A ∨(B ∧C)) ⇔((A ∨B) ∧(A ∨C))
|= ((B ∧C) ∨A) ⇔((B ∨A) ∧(C ∨A))
From:
[(¬Parent(x) ∨(Person(x) ∧(Person(f(x)) ∧childOf(f(x), x))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
To:
[((¬Parent(x) ∨Person(x))
∧((¬Parent(x) ∨Person(f(x)))
∧(¬Parent(x) ∨childOf(f(x), x)))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
Page 314

Translation Step 8
Discard extra parentheses using the associativity of ∧and ∨.
From:
[((¬Parent(x) ∨Person(x))
∧((¬Parent(x) ∨Person(f(x)))
∧(¬Parent(x) ∨childOf(f(x), x)))))
∧((¬Person(x) ∨(¬Person(z) ∨¬childOf(z, x))) ∨Parent(x))]
To:
[(¬Parent(x) ∨Person(x))
∧(¬Parent(x) ∨Person(f(x)))
∧(¬Parent(x) ∨childOf(f(x), x))
∧(¬Person(x) ∨¬Person(z) ∨¬childOf(z, x) ∨Parent(x))]
Page 315

Translation Step 9
Turn each disjunction into a clause,
and the conjunction into a set of clauses.
From:
[(¬Parent(x) ∨Person(x))
∧(¬Parent(x) ∨Person(f(x)))
∧(¬Parent(x) ∨childOf(f(x), x))
∧(¬Person(x) ∨¬Person(z) ∨¬childOf(z, x) ∨Parent(x))]
To:
{{¬Parent(x), Person(x)},
{¬Parent(x), Person(f(x))},
{¬Parent(x), childOf(f(x), x)},
{¬Person(x), ¬Person(z), ¬childOf(z, x), Parent(x)}}
Page 316

Translation Step 10
Rename the clauses apart
so that no variable occurs in more than one clause.
From:
{{¬Parent(x), Person(x)},
{¬Parent(x), Person(f(x))},
{¬Parent(x), childOf(f(x), x)},
{¬Person(x), ¬Person(z), ¬childOf(z, x), Parent(x)}}
To:
{{¬Parent(x1), Person(x1)},
{¬Parent(x2), Person(f(x2))},
{¬Parent(x3), childOf(f(x3), x3)},
{¬Person(x4), ¬Person(z4), ¬childOf(z4, x4), Parent(x4)}}
Page 317

Use of Translation
A1, . . . , An |= B
iﬀ
The translation of A1 ∧· · · ∧An ∧¬B into a set of clauses is
contradictory.
Page 318

Example with ubprover
(prove
’((forall x (iff (Parent x)
(and (Person x)
(exists y (and (Person y) (childOf y x))))))
(Person Tom) (Person Betty) (childOf Tom Betty))
’(Parent Betty))
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((childOf Tom Betty))
Assumption
4
((not (Parent ?4)) (Person ?4))
Assumption
5
((not (Parent ?5)) (Person (S3 ?5)))
Assumption
6
((not (Parent ?6)) (childOf (S3 ?6) ?6))
Assumption
7
((not (Person ?7)) (not (Person ?8))
(not (childOf ?8 ?7)) (Parent ?7))
Assumption
8
((not (Parent Betty)))
From Query
Page 319

Resolution Steps
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((childOf Tom Betty))
Assumption
7
((not (Person ?7)) (not (Person ?8))
(not (childOf ?8 ?7)) (Parent ?7))
Assumption
8
((not (Parent Betty)))
From Query
9
((not (Person Betty)) (not (Person ?9))
(not (childOf ?9 Betty)))
R,8,7,{Betty/?7}
13
((not (Person Betty))
(not (childOf Tom Betty)))
R,9,1,{Tom/?9}
14
((not (childOf Tom Betty)))
R,13,2,{}
15
nil
R,14,3,{}
QED
Page 320

Example with SNARK
snark-user(42): (initialize)
; Running SNARK from ...
nil
snark-user(43): (assert
’(forall (x)
(iff (Parent x)
(and (Person x)
(exists (y)
(and (Person y) (childOf y x)))))))
nil
snark-user(44): (assert ’(Person Tom))
nil
snark-user(45): (assert ’(Person Betty))
nil
snark-user(46): (assert ’(childOf Tom Betty))
nil
snark-user(47): (prove ’(Parent Betty))
Page 321

Initial Set of Clauses
(Row 1 (or (not (Parent ?x)) (Person ?x)) assertion)
(Row 2 (or (not (Parent ?x)) (Person (skolembiry1 ?x))) assertion)
(Row 3 (or (not (Parent ?x)) (childOf (skolembiry1 ?x) ?x)) assertion)
(Row 4 (or (Parent ?x) (not (Person ?x)) (not (Person ?y)) (not (childOf ?y ?x
assertion)
(Row 5 (Person Tom) assertion)
(Row 6 (Person Betty) assertion)
(Row 7 (childOf Tom Betty) assertion)
(Row 8 (not (Parent Betty)) negated_conjecture)
(Row 9 (or (not (Person ?x)) (not (childOf ?x Betty))) (rewrite (resolve 8 4)
(Row 10 false (rewrite (resolve 9 7) 5))
Page 322

Refutation
(Refutation
(Row 4 (or (Parent ?x) (not (Person ?x)) (not (Person ?y)) (not (childOf ?y ?x
assertion)
(Row 5 (Person Tom) assertion)
(Row 6 (Person Betty) assertion)
(Row 7 (childOf Tom Betty) assertion)
(Row 8 (not (Parent Betty)) negated_conjecture)
(Row 9 (or (not (Person ?x)) (not (childOf ?x Betty))) (rewrite (resolve 8 4)
(Row 10 false (rewrite (resolve 9 7) 5))
)
:proof-found
Page 323

A ubprover Example
Using the Skolem Function
prover(72): (prove
’((forall x (iff (Parent x)
(and (Person x)
(exists y (and (Person y) (childOf y x))))))
(Person Tom) (Person Betty) (Parent Betty))
’(exists x (childOf x Betty)))
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((Parent Betty))
Assumption
4
((not (Parent ?4)) (Person ?4))
Assumption
5
((not (Parent ?5)) (Person (S3 ?5)))
Assumption
6
((not (Parent ?6)) (childOf (S3 ?6) ?6))
Assumption
7
((not (Person ?7)) (not (Person ?8))
(not (childOf ?8 ?7)) (Parent ?7))
Assumption
8
((not (childOf ?10 Betty)))
From Query
9
((not (Parent Betty)))
R,8,6,{Betty/?6, (S3 Betty)/?10}
10
nil
R,9,3,{}
QED
Page 324

4.5 Asking Wh Questions
Given
∀x[Parent(x) ⇔(Person(x) ∧∃y(Person(y) ∧childOf(y, x)))]
Person(Tom)
Person(Betty)
childOf(Tom, Betty)
Ask: “Who is a parent?”
Answer via constructive proof of ∃x Parent(x).
Page 325

Try to Answer Wh Question
(prove
’((forall x (iff (Parent x)
(and (Person x)
(exists y (and (Person y) (childOf y x))))))
(Person Tom) (Person Betty) (childOf Tom Betty))
’(exists x (Parent x)))
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((Parent Betty))
Assumption
4
((not (Parent ?4)) (Person ?4))
Assumption
5
((not (Parent ?5)) (Person (S3 ?5)))
Assumption
6
((not (Parent ?6)) (childOf (S3 ?6) ?6))
Assumption
7
((not (Person ?7)) (not (Person ?8))
(not (childOf ?8 ?7)) (Parent ?7))
Assumption
8
((not (childOf ?10 Betty)))
From Query
Page 326

Resolution Steps
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((childOf Tom Betty))
Assumption
7
((not (Person ?7)) (not (Person ?8))
(not (childOf ?8 ?7)) (Parent ?7))
Assumption
8
((not (Parent ?10)))
From Query
9
((not (Person ?11)) (not (Person ?12))
(not (childOf ?12 ?11)))
R,8,7,{?7/?10}
15
((not (Person ?16)) (not (childOf Tom ?16)))
R,9,1,{Tom/?12}
16
((not (childOf Tom Tom)))
R,15,1,{Tom/?16}
17
((not (childOf Tom Betty)))
R,15,2,{Betty/?16}
18
nil
R,17,3,{}
QED
Page 327

The Answer Predicate
Instead of query ∃x1 · · · ∃xnP(x1, . . . , xn),
and resolution refutation with {¬P(x1, . . . , xn)}
until {},
use ∀x1 · · · ∀xn(P(x1, . . . , xn) ⇒Answer(P(x1, . . . , xn)))
and do direct resolution with
{¬P(x1, . . . , xn), Answer(P(x1, . . . , xn))}
until {(Answer . . .) · · · (Answer . . .)}.
Page 328

General Procedure for
Inserting The Answer Predicate
Let:
Q be either ∀or ∃;
Q be either ∃or ∀, respectively;
Prenex Normal form of query be Q1x1 · · · QnxnP(x1, . . . , xn).
Do direct resolution with clause form of
Q1x1 · · · Qnxn(P(x1, . . . , xn) ⇒Answer(P(x1, . . . , xn)))
until generate {(Answer . . .) · · · (Answer . . .)}.
Page 329

Using the Answer Predicate
(setf *UseAnswer* t)
(prove
’((forall x (iff (Parent x)
(and (Person x)
(exists y (and (Person y) (childOf y x))))))
(Person Tom) (Person Betty) (childOf Tom Betty))
’(exists x (Parent x)))
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((childOf Tom Betty))
Assumption
4
((not (Parent ?3)) (Person ?3))
Assumption
5
((not (Parent ?4)) (Person (S2 ?4)))
Assumption
6
((not (Parent ?5)) (childOf (S2 ?5) ?5))
Assumption
7
((not (Person ?6)) (not (Person ?7))
(not (childOf ?7 ?6)) (Parent ?6))
Assumption
8
((not (Parent ?9)) (Answer (Parent ?9)))
From Query
Page 330

Resolution Steps
1
((Person Tom))
Assumption
2
((Person Betty))
Assumption
3
((childOf Tom Betty))
Assumption
7
((not (Person ?6)) (not (Person ?7))
(not (childOf ?7 ?6)) (Parent ?6))
Assumption
8
((not (Parent ?9)) (Answer (Parent ?9)))
From Query
9
((Answer (Parent ?10)) (not (Person ?10))
(not (Person ?11)) (not (childOf ?11 ?10)))
R,8,7,{?6/?9}
15
((Answer (Parent Betty))
(not (Person Betty)) (not (Person Tom)))
R,9,3,{Betty/?10,
Tom/?11}
26
((Answer (Parent Betty)) (not (Person Tom)))
R,15,2,{}
29
((Answer (Parent Betty)))
R,26,1,{}
QED
Page 331

Answer Predicate in snark
snark-user(11): (assert ’(forall x (iff (Parent x)
(exists y (and (Person y)
(childOf y x))))))
nil
snark-user(12): (assert ’(Person Tom))
nil
snark-user(13): (assert ’(Person Betty))
nil
snark-user(14): (assert ’(childOf Tom Betty))
nil
snark-user(15): (prove ’(exists x (Parent x))
:answer ’(Parent x))
Page 332

snark Refutation
(Refutation
(Row 3
(or (Parent ?x) (not (Person ?y)) (not (childOf ?y ?x)))
assertion)
(Row 4 (Person Tom) assertion)
(Row 6 (childOf Tom Betty) assertion)
(Row 7 (not (Parent ?x)) negated_conjecture
Answer (Parent ?x))
(Row 8 (or (not (Person ?x)) (not (childOf ?x ?y))) (resolve 7 3)
Answer (Parent ?y))
(Row 9 false (rewrite (resolve 8 6) 4)
Answer (Parent Betty))
)
:proof-found
Page 333

Answer Predicate with ask
From same SNARK KB:
snark-user(18): (ask ’(exists x (Parent x)) :answer ’(Parent x))
(Parent Betty)
Page 334

Using :printProof
snark-user(19): (ask ’(Parent ?x) :answer ’(Parent ?x)
:printProof t)
(Refutation
(Row 3 (or (Parent ?x) (not (Person ?y)) (not (childOf ?y ?x)))
assertion)
(Row 4 (Person Tom) assertion)
(Row 6 (childOf Tom Betty) assertion)
(Row 13 (not (Parent ?x)) negated_conjecture
Answer (Parent ?x))
(Row 14 (or (not (Person ?x)) (not (childOf ?x ?y)))
(resolve 13 3)
Answer (Parent ?y))
(Row 15 false (rewrite (resolve 14 6) 4)
Answer (Parent Betty))
)
(Parent Betty)
Page 335

Answer Predicate with query
From same SNARK KB:
snark-user(9): (query "Who is a parent?"
’(exists x (Parent x))
:answer ’(Parent x))
Who is a parent?
(ask ’(exists x (Parent x))) = (Parent Betty)
Page 336

query with :answer and :printProof
snark-user(10): (query "Who is a parent?"
’(exists x (Parent x)) :answer ’(Parent x) :printProof t)
Who is a parent?
(Refutation
(Row 3
(or (Parent ?x) (not (Person ?y)) (not (childOf ?y ?x)))
assertion)
(Row 4
(Person Tom)
assertion)
(Row 6
(childOf Tom Betty)
assertion)
(Row 19
(not (Parent ?x))
negated_conjecture
Answer (Parent ?x))
(Row 20
(or (not (Person ?x)) (not (childOf ?x ?y)))
(resolve 19 3)
Answer (Parent ?y))
(Row 21
false
(rewrite (resolve 20 6) 4)
Answer (Parent Betty))
)
(ask ’(exists x (Parent x))) = (Parent Betty)
Page 337

Disjunctive Answers
(prove ’((On a b)(On b c)
(Red a) (Green c)
(or (Red b) (Green b)))
’(exists (x y)
(and (Red x) (Green y) (On x y))))
1
((On a b))
Assumption
2
((On b c))
Assumption
3
((Red a))
Assumption
4
((Green c))
Assumption
5
((Red b) (Green b))
Assumption
6
((not (Red ?28)) (not (Green ?30))
(not (On ?28 ?30))
(Answer (and (Red ?28) (Green ?30) (On ?28 ?30)))) From Query
Page 338

Resolution Steps
9
((Answer (and (Red a) (Green ?107) (On a ?107)))
(not (On a ?107)) (not (Green ?107)))
R,6,3,{a/?28}
10
((Answer (and (Red ?112) (Green c) (On ?112 c)))
(not (On ?112 c)) (not (Red ?112)))
R,6,4,{c/?30}
11
((Answer (and (Red b) (Green ?117) (On b ?117)))
(not (On b ?117)) (not (Green ?117)) (Green b))
R,6,5,{b/?28}
13
((not (Red b))
(Answer (and (Red b) (Green c) (On b c))))
R,10,2,{b/?112}
Page 339

Resolution Finished
16
((Answer (and (Red b) (Green c) (On b c)))
(Green b))
R,13,5,{}
20
((not (On a b))
(Answer (and (Red a) (Green b) (On a b)))
(Answer (and (Red b) (Green c) (On b c)))) R,9,16,{b/?107}
22
((Answer (and (Red b) (Green c) (On b c)))
(Answer (and (Red a) (Green b) (On a b)))) R,20,1,{}
QED
Page 340

Multiple Clauses From Query
(prove ’((On a b)(On b c)
(Red a) (Green c)
(or (Red b) (Green b)))
’(exists x (or (Red x) (Green x))))
1
((On a b))
Assumption
2
((On b c))
Assumption
3
((Red a))
Assumption
4
((Green c))
Assumption
5
((Red b) (Green b))
Assumption
6
((not (Red ?25))
(Answer (or (Red ?25) (Green ?25)))) From Query
7
((not (Green ?27))
(Answer (or (Red ?27) (Green ?27)))) From Query
8
((Answer (or (Red a) (Green a))))
R,6,3,{a/?25}
QED
Page 341

Resolution Produces Only 1 Answer
snark-user(20): (initialize)
; Running SNARK from ...
nil
snark-user(21): (assert ’(Man Socrates))
nil
snark-user(22): (assert ’(Man Turing))
nil
snark-user(23): (ask ’(Man ?x) :answer ’(One man is ?x))
(One man is Turing)
Page 342

Generic and Hypothetical Answers
Every clause that descends from a query clause (that contains an
Answer predicate) is an answer of some sort.a
Page 343
aDebra T. Burhans and Stuart C. Shapiro, Deﬁning Answer Classes Using
Resolution Refutation, Journal of Applied Logic 5, 1 (March 2007), 70–91 .
http://www.cse.buffalo.edu/~shapiro/Papers/bursha05.pdf

Example of
Generic and Hypothetical Answers
Question
(prove ’((forall (x y z) (if (and (Member x FBS) (Sport y)
(Athlete z) (PlaysWell z y))
(ProvidesScholarshipFor x z)))
(forall x (if (Sport x) (Activity x)))
(forall x (if (Activity x) (or (Sport x) (Game x))))
(forall x (if (or (Member x MAC) (Member x Big10) (Member Pac10 x))
(Member x FBS)))
(Member Buffalo MAC) (Member KentSt MAC)
(Member Wisconsin Big10) (Member Indiana Big10)
(Member Stanford Pac10) (Member Berkeley Pac10)
(Activity Frisbee))
’(exists x (ProvidesScholarshipFor Buffalo x)))
Page 344

Initial Clauses
1
((Member Buffalo MAC))
Assumption
2
((Member KentSt MAC))
Assumption
3
((Member Wisconsin Big10))
Assumption
4
((Member Indiana Big10))
Assumption
5
((Member Stanford Pac10))
Assumption
6
((Member Berkeley Pac10))
Assumption
7
((Activity Frisbee))
Assumption
8
((not (Sport ?7)) (Activity ?7))
Assumption
9
((not (Member ?11 MAC)) (Member ?11 FBS))
Assumption
10
((not (Member ?12 Big10)) (Member ?12 FBS))
Assumption
11
((not (Member Pac10 ?13)) (Member ?13 FBS))
Assumption
12
((not (Activity ?9)) (Sport ?9) (Game ?9))
Assumption
13
((not (Member ?3 FBS)) (not (Sport ?4)) (not (Athlete ?5))
(not (PlaysWell ?5 ?4)) (ProvidesScholarshipFor ?3 ?5))
Assumption
14
((not (ProvidesScholarshipFor Buffalo ?15))
(Answer (ProvidesScholarshipFor Buffalo ?15)))
From Query
Page 345

Resolvents
15
((Answer (ProvidesScholarshipFor Buffalo ?16)) (not (Member Buffalo FBS)) (not (Sport ?17))
(not (Athlete ?16)) (not (PlaysWell ?16 ?17)))
R,14,13,{?5/?15, Buffalo/?3}
16
((not (Member Buffalo MAC)) (Answer (ProvidesScholarshipFor Buffalo ?18)) (not (Sport ?19))
(not (Athlete ?18)) (not (PlaysWell ?18 ?19)))
R,15,9,{Buffalo/?11}
17
((not (Member Buffalo Big10)) (Answer (ProvidesScholarshipFor Buffalo ?20)) (not (Sport ?21))
(not (Athlete ?20)) (not (PlaysWell ?20 ?21)))
R,15,10,{Buffalo/?12}
18
((not (Member Pac10 Buffalo)) (Answer (ProvidesScholarshipFor Buffalo ?22)) (not (Sport ?23))
(not (Athlete ?22)) (not (PlaysWell ?22 ?23)))
R,15,11,{Buffalo/?13}
19
((Game ?24) (not (Activity ?24)) (Answer (ProvidesScholarshipFor Buffalo ?25))
(not (Member Buffalo FBS)) (not (Athlete ?25)) (not (PlaysWell ?25 ?24)))
R,15,12,{?9/?17}
20
((Game ?26) (not (Activity ?26)) (not (Member Pac10 Buffalo)) (Answer (ProvidesScholarshipFor Buffalo ?27))
(not (Athlete ?27)) (not (PlaysWell ?27 ?26)))
R,18,12,{?9/?23}
21
((Game ?28) (not (Activity ?28)) (not (Member Buffalo Big10)) (Answer (ProvidesScholarshipFor Buffalo ?29))
(not (Athlete ?29)) (not (PlaysWell ?29 ?28)))
R,17,12,{?9/?21}
22
((Answer (ProvidesScholarshipFor Buffalo ?30)) (not (Sport ?31)) (not (Athlete ?30))
(not (PlaysWell ?30 ?31))) R,16,1,{}
23
((Game ?32) (not (Activity ?32)) (not (Member Buffalo MAC)) (Answer (ProvidesScholarshipFor Buffalo ?33))
(not (Athlete ?33)) (not (PlaysWell ?33 ?32)))
R,16,12,{?9/?19}
24
((Game ?34) (not (Activity ?34)) (Answer (ProvidesScholarshipFor Buffalo ?35)) (not (Athlete ?35))
(not (PlaysWell ?35 ?34))) R,22,12,{?9/?31}
25
((Game Frisbee) (Answer (ProvidesScholarshipFor Buffalo ?36)) (not (Athlete ?36))
(not (PlaysWell ?36 Frisbee)))
R,24,7,{Frisbee/?34}
26
((not (Sport ?37)) (Game ?37) (Answer (ProvidesScholarshipFor Buffalo ?38)) (not (Athlete ?38))
(not (PlaysWell ?38 ?37)))
R,24,8,{?7/?34}
nil
Page 346

Non-Subsumed Resolvents
22
((Answer (ProvidesScholarshipFor Buffalo ?30))
(not (Sport ?31)) (not (Athlete ?30))
(not (PlaysWell ?30 ?31)))
24
((Game ?34) (not (Activity ?34))
(Answer (ProvidesScholarshipFor Buffalo ?35))
(not (Athlete ?35)) (not (PlaysWell ?35 ?34)))
25
((Game Frisbee)
(Answer (ProvidesScholarshipFor Buffalo ?36))
(not (Athlete ?36)) (not (PlaysWell ?36 Frisbee)))
Page 347

Interpretation of Clauses
As Generic Answers
22
((Answer (ProvidesScholarshipFor Buffalo ?30))
(not (Sport ?31)) (not (Athlete ?30))
(not (PlaysWell ?30 ?31)))
∀xy[Athlete(x) ∧Sport(y) ∧PlaysWell(x, y)
⇒ProvidesScholarshipFor(Buﬀalo, x)]
24
((Game ?34) (not (Activity ?34))
(Answer (ProvidesScholarshipFor Buffalo ?35))
(not (Athlete ?35)) (not (PlaysWell ?35 ?34)))
∀xy[Athlete(x) ∧Activity(y) ∧¬Game(y) ∧PlaysWell(x, y)
⇒ProvidesScholarshipFor(Buﬀalo, x)]
Page 348

Interpretation of Clause
As Hypothetical Answer
25
((Game Frisbee)
(Answer (ProvidesScholarshipFor Buffalo ?36))
(not (Athlete ?36)) (not (PlaysWell ?36 Frisbee)))
¬Game(Frisbee) ⇒∀xy[Athlete(x) ∧PlaysWell(x, Frisbee)
⇒ProvidesScholarshipFor(Buﬀalo, x)]
Page 349

Rule-Based Systems
Every FOL KB
can be expressed as a set of rules of the form
∀x(C1(x) ∨· · · ∨Cm(x))
or
∀x(A1(x) ∧· · · ∧An(x) ⇒C1(x) ∨· · · ∨Cm(x))
or
∀x(A1(x) ∧· · · ∧An(x) ⇒C(x))
where Ai(x) and Cj(x) are literals.
Page 350

Wh Questions in Rule-Based Systems
Given rule ∀x(A(x) ⇒C(x))
Ask C(y)?
Backchain to subgoal A(x)µ, where µ is an mgu of C(x)) and C(y))
Moral: Uniﬁcation is generally needed in backward chaining
systems.
Uniﬁcation is correct pattern matching when both structures have
variables.
Page 351

Forward Chaining & Uniﬁcation
Forward chaining generally matches a ground fact with rule
antecedents.
Forward chaining does not generally require uniﬁcation.
Page 352

Common Formalizing Diﬃculties
Every raven is black: ∀x(Raven(x) ⇒Black(x))
Some raven is black: ∃x(Raven(x) ∧Black(x))
Note the satisfying models of the incorrect
∃x(Raven(x) ⇒Black(x))
Page 353

Another Formalizing Diﬃculty
Note where a Skolem function appears in
∀x(Parent(x) ⇔∃ychildOf (y, x))
⇔∀x((Parent(x) ⇒∃ychildOf (y, x))
∧((∃ychildOf (y, x)) ⇒Parent(x)))
⇔∀x((¬Parent(x) ∨∃ychildOf (y, x))
∧(¬(∃ychildOf (y, x)) ∨Parent(x)))
⇔∀x((¬Parent(x) ∨∃ychildOf (y, x))
∧(∀y(¬childOf (y, x)) ∨Parent(x)))
⇔∀x(Parent(x) ⇒childOf (f (x), x))
∧∀x∀y(childOf (y, x) ⇒Parent(x))
Page 354

What’s “First-Order” About FOL?
In a ﬁrst-order logic:
Predicate and function symbols cannot be arguments of predicates
or functions;
Variables cannot be in predicate or function position.
E.G. ∀r[Transitive(r) ⇔∀xyz[r(x, y) ∧r(y, z) ⇒r(x, z)]]
is not a ﬁrst-order sentence.
“The adjective ’ﬁrst-order’ is used to distinguish the languages we shall
study here from those in which there are predicates having other
predicates or functions as arguments or in which predicate quantiﬁers or
function quantiﬁers are permitted, or both.” [Elliott Mendelson,
Introduction to Mathematical Logic, Fifth Edition, CRC Press, Boca
Raton, FL, 2010, p. 48.]
Page 355

Russell’s Theory of Types
Designed to solve paradox: ∃s∀c[s(c) ⇔¬c(c)]
has instance S(S) ⇔¬S(S)
Page 356

N th-Order Logic
Assign type 0 to individuals and to terms denoting individuals.
Assign type i + 1 to any set and to any function or predicate
symbol that denotes a set, possibly of tuples, such that the
maximum type of any of its elements is i.
Also assign type i + 1 to any variable that range over type i objects.
Note that the type of a functional term is the type of its range—the
nth element of the n-tuples of the set which the function denotes.
Syntactically, if the maximum type of the arguments of a ground
atomic wﬀis i, then the type of the predicate is i + 1.
No predicate of type i may take a ground argument of type i or
higher.
Page 357

First-Order Logic Deﬁned
First-order logic has a language that obeys Russell’s Theory of
Types, and whose highest type symbol is of type 1.
nth-order logic has a language that obeys Russell’s Theory of
Types, and whose highest type symbol is of type n.
Ω-ordered logic has no limit, but must still follow the rules.
E.g., ∀r[Transitive(r) ⇔∀xyz[r(x, y) ∧r(y, z) ⇒r(x, z)]]
is a formula of Second-Order Logic:
Type 0 objects: individuals in the domain
Type 1 symbols: x, y, z because they range over type 0 objects
Type 1 objects: binary relations over type 0 objects
Type 2 symbols: r because it ranges over type 1 objects,
Transitive because it denotes a set of type 1 objects
Page 358

Nested Beliefs
Can a proposition be an argument of a proposition?
Consider:
∀p(Believes(Solomon, p) ⇒p)
Believes(Solomon, Round(Earth)) ⇒Round(Earth)
Believes(Solomon, Round(Earth))
|= Round(Earth)
If Round(Earth) is an atomic wﬀ, it’s not a term, and only terms
may be arguments of functions and predicates.
Even if it could:
[[Round(Earth)]] = True if [[Earth]] ∈[[Round]], else False.
So [[Believes(Solomon, Round(Earth))]] = True
iﬀ⟨[[Solomon]], True-or-False⟩∈[[Believes]]
Page 359

Reifying Propositions
and the Holds Predicate
So how can we represent in FOL
“Everything that Solomon believes is true”?
• Reify (some) propositions.
Make them objects in the domain.
Represent them using individual constants or functional terms.
• Use Holds(P) to mean
“P holds (is true) in the given situation”.
• Examples:
∀p(Believes(Solomon, p) ⇒Holds(p))
Believes(Solomon, Round(Earth)) ⇒Holds(Round(Earth))
Page 360

Semantics of the Holds Predicate
∀p(Believes(Solomon, p) ⇒Holds(p)) ∧Believes(Solomon, Round(Earth))
⇒Holds(Round(Earth))
Type 0 individuals and terms:
[Solomon] = [[Solomon]] = A person named Solomon
[Earth] = [[Earth]] = The planet Earth
[Round(Earth)] = [[Round(Earth)]] = The proposition that the Earth is round
Type 1 objects and symbols:
p: A variable ranging over type 0 propositions
[[Round]] = A function from type 0 physical objects to type 0 propositions.
[[Holds]] = A set of type 0 propositions.
[[Believes]] = A set of pairs, type 0 People × type 0 propositions
Type 1 atomic formulas:
[Holds(x)] = The type 1 proposition that [x] is True.
[[Holds(x)]] = True if [[x]] ∈[[Holds]]; False otherwise
[Believes(x, y)] = The type 1 proposition that [x] believes [y]
[[Believes(x, y)]] = True if ⟨[[x]], [[y]] ⟩∈[[Believes]]; False otherwise
Page 361

5 Summary of Part I
Artiﬁcial Intelligence (AI): A ﬁeld of computer science and
engineering concerned with the computational understanding of
what is commonly called intelligent behavior, and with the
creation of artifacts that exhibit such behavior.
Knowledge Representation and Reasoning (KR or KRR):
A subarea of Artiﬁcial Intelligence concerned with
understanding, designing, and implementing ways of
representing information in computers, and using that
information to derive new information based on it.
KR is more concerned with belief than “knowledge”. Given
that an agent (human or computer) has certain beliefs, what
else is reasonable for it to believe, and how is it reasonable for it
to act, regardless of whether those beliefs are true and justiﬁed.
Page 362

What is Logic?
Logic is the study of correct reasoning.
There are many systems of logic (logics). Each is speciﬁed by
specifying:
• Syntax: Specifying what counts as a well-formed expression
• Semantics: Specifying the meaning of well-formed expressions
– Intensional Semantics: Meaning relative to a Domain
– Extensional Semantics: Meaning relative to a Situation
• Proof Theory: Deﬁning proof/derivation, and how it can be
extended.
Page 363

Relevance of Logic
Any system that consists of
• a collection of symbol structures,
well-formed relative to some syntax;
• a set of procedures for adding new structures to that collection
based on what’s already in there.
is a logic.
But:
Do the symbol structures have a consistent semantics?
Are the procedures sound relative to that semantics?
Soundness is the essence of “correct reasoning.”
Page 364

KR and Logic
Given that a Knowledge Base is represented in a language with a
well-deﬁned syntax, a well-deﬁned semantics, and that reasoning
over it is a well-deﬁned procedure, a KR system is a logic.
KR research can be seen as a search for the best logic to capture
human-level reasoning.
Page 365

Relations Among Inference Problems
Syntax
Derivation
Theoremhood
A1, . . . , An ⊢Q
⇔
⊢A1 ∧. . . ∧An ⇒Q
⇓⇑
⇓⇑
A1, . . . , An |= Q
⇔
|= A1 ∧. . . ∧An ⇒Q
Semantics
Logical Entailment
Validity
(⇓Soundness)
(⇑Completeness)
Page 366

Inference/Reasoning Methods
Given a KB/set of assumptions A and a query Q:
• Model Finding
– Direct: Find satisfying models of A,
see if Q is True in all of them.
– Refutation: Find if A ∪{¬Q} is unsatisﬁable.
• Natural Deduction
– Direct: Find if A ⊢Q.
• Resolution
– Direct: Find if A ⊢Q (incomplete).
– Refutation: Find if V A ∧¬Q is inconsistent.
Page 367

Classes of Logics
• Propositional Logic
– Finite number of atomic propositions and models.
– Model ﬁnding and resolution are decision procedures.
• Finite-Model Predicate Logic
– Finite number of terms, atomic formulae, and models.
– Reducible to propositional logic.
– Model ﬁnding and resolution are decision procedures.
• First-Order Logic
– Inﬁnite number of terms, atomic formulae, and models.
– Not reducible to propositional logic.
– There are no decision procedures.
– Resolution plus factoring is refutation complete.
Page 368

Logics We Studied
1. Standard Propositional Logic
2. Clause Form Propositional Logic
3. Standard Finite-Model Predicate Logic
4. Clause Form Finite-Model Predicate Logic
5. Standard First-Order Predicate Logic
6. Clause Form First-Order Predicate Logic
Page 369

Proof Procedures We Studied
1. Direct model ﬁnding: truth tables, decreasoner,
relsat (complete search) walksat, gsat (stochastic search)
2. Semantic tableaux (model-ﬁnding refutation)
3. Wang algorithm (model-ﬁnding refutation), wang
4. Hilbert-style axiomatic (direct), brief
5. Fitch-style natural deduction (direct)
6. Resolution (refutation), prover, SNARK
Page 370

Utility Notions and Techniques
1. Material implication
2. Possible properties of connectives
commutative, associative, idempotent
3. Possible properties of well-formed expressions
free, bound variables
open, closed, ground expressions
4. Possible semantic properties of wﬀs
contradictory, satisﬁable, contingent, valid
5. Possible properties of proof procedures
sound, consistent, complete,
decision procedure, semi-decision procedure
Page 371

More Utility Notions and Techniques
5. Substitutions
application, composition
6. Uniﬁcation
most general common instance (mgci),
most general uniﬁer (mgu)
7. Translation from standard form to clause form
Conjunctive Normal Form (CNF),
Skolem functions/constants
8. Resolution Strategies
subsumption, unit preference, set of support
9. The Answer Literal
Page 372

Uniﬁcation
• Uniﬁcation is a least-commitment method of choosing a
substitution for Universal Instantiation (∀E).
• Uniﬁcation is correct pattern matching when both
structures have variables.
• Uniﬁcation is generally needed in backward chaining
systems.
Page 373

AI-Logic Connections
AI
Logic
rules
non-atomic assumptions
or domain rules
or non-logical axioms
inference engine procedures
rules of inference
knowledge base
derivation
Page 374

6 Prolog
6.1 Horn Clauses. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .376
6.2 Prolog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Page 375

6.1 Horn Clauses
A Horn Clause is a clause with at most one positive literal.
Either {¬Q1(x), . . . , ¬Qn(x)} (negative Horn clause)
or {C(x)} (fact or positive or deﬁnite Horn clause)
or {¬A1(x), . . . , ¬An(x), C(x)} (positive or deﬁnite Horn clause)
which is the same as
A1(x) ∧· · · ∧An(x) ⇒C(x)
where Ai(x), C(x), and Q(x) are atoms.
Page 376

SLD Resolution
Selected literals, Linear pattern, over Deﬁnite clauses
SLD derivation of clause c from set of clauses S is
c1, . . . , cn = c
s.t. c1 ∈S
and ci+1 is resolvent of ci and a clause in S. [B&L, p. 87]
If S is a set of Horn clauses,
then there is a resolution derivation of {} from S
iﬀthere is an SLD derivation of {} from S.
Page 377

SLDSolve
procedure SLDSolve(KB,query) returns true or false {
/* KB = {rule1 , . . . , rulen}
* rulei = {hi, ¬bi1 , . . . , ¬biki }
* query = {¬q1, . . . , ¬qm}
*/
if (m = 0) return true;
for i := 1 to n {
if((µ := Unify(q1, hi)) ̸= FAIL
and SLDSolve(KB, {¬bi1µ, . . . , ¬bikiµ, ¬q2µ, . . . , ¬qmµ})) {
return true;
}
}
return false;
}
Where hi, bij, and qi are atomic formulae.
See B&L, p. 92
Page 378

6.2 Prolog
Example Prolog Interaction
<timberlake:~/.xemacs:1:35> sicstus
SICStus 4.0.5 (x86_64-linux-glibc2.3): Thu Feb 12 09:48:30 CET 2009
Licensed to SP4cse.buffalo.edu
| ?- consult(user).
% consulting user...
| driver(X) :- drives(X,_).
| passenger(Y) :- drives(_,Y).
| drives(betty,tom).
|
% consulted user in module user, 0 msec 1200 bytes
yes
| ?- driver(X), passenger(Y).
X = betty,
Y = tom ?
yes
| ?- halt.
Page 379

Variables are Capitalized
SICStus 4.0.5 (x86-linux-glibc2.3): Thu Feb 12 09:47:39 CET 2009
Licensed to SP4cse.buffalo.edu
| ?- [user].
% compiling user...
| canary(Tweety).
* [Tweety] - singleton variables
|
% compiled user in module user, 10 msec 152 bytes
yes
| ?- canary(Tweety).
true ?
yes
| ?- canary(oscar).
yes
| ?-
Page 380

Prolog Program with Two Answers
% From Rich & Knight, 2nd Edition (1991) p. 192.
likesToEat(X,Y) :- cat(X), fish(Y).
cat(X) :- calico(X).
fish(X) :- tuna(X).
tuna(charlie).
tuna(herb).
calico(puss).
Page 381

Listing the Fish Program
| ?- listing.
calico(puss).
cat(A) :-
calico(A).
fish(A) :-
tuna(A).
likesToEat(A, B) :-
cat(A),
fish(B).
tuna(charlie).
tuna(herb).
yes
Note: consult(File) loads the File in interpreted mode, whereas [File] loads the
File in compiled mode. listing is only possible in interpreted mode.
Page 382

Running the Fish Program
<timberlake:CSE563:1:39> sicstus
SICStus 4.0.5 (x86_64-linux-glibc2.3): Thu Feb 12 09:48:30 CET 2009
Licensed to SP4cse.buffalo.edu
| ?- [’fish.prolog’].
% compiling /projects/shapiro/CSE563/fish.prolog...
% compiled /projects/shapiro/CSE563/fish.prolog in module user, 0 msec 1808 by
yes
| ?- likesToEat(puss,X).
X = charlie ? ;
X = herb ? ;
no
| ?- halt.
<timberlake:CSE563:1:40>
Page 383

Tracing the Fish Program
| ?- [’fish.prolog’].
% consulting /projects/shapiro/CSE563/fish.prolog...
% consulted /projects/shapiro/CSE563/fish.prolog in module user
yes
| ?- trace.
% The debugger will first creep -- showing everything (trace)
yes
% trace
Page 384

Tracing First Answer
| ?- likesToEat(puss,X).
1
1 Call: likesToEat(puss,_442) ?
2
2 Call: cat(puss) ?
3
3 Call: calico(puss) ?
3
3 Exit: calico(puss) ?
2
2 Exit: cat(puss) ?
4
2 Call: fish(_442) ?
5
3 Call: tuna(_442) ?
?
5
3 Exit: tuna(charlie) ?
?
4
2 Exit: fish(charlie) ?
?
1
1 Exit: likesToEat(puss,charlie) ?
X = charlie ? ;
Page 385

Tracing the Second Answer
X = charlie ? ;
1
1 Redo: likesToEat(puss,charlie) ?
4
2 Redo: fish(charlie) ?
5
3 Redo: tuna(charlie) ?
5
3 Exit: tuna(herb) ?
4
2 Exit: fish(herb) ?
1
1 Exit: likesToEat(puss,herb) ?
X = herb ? ;
no
% trace
| ?- notrace.
% The debugger is switched off
yes
Page 386

Backtracking Example
Program:
bird(tweety).
bird(oscar).
bird(X) :- feathered(X).
feathered(maggie).
large(oscar).
ostrich(X) :- bird(X), large(X).
Run (No backtracking needed):
| ?- ostrich(oscar).
1
1 Call: ostrich(oscar) ?
2
2 Call: bird(oscar) ?
?
2
2 Exit: bird(oscar) ?
3
2 Call: large(oscar) ?
3
2 Exit: large(oscar) ?
?
1
1 Exit: ostrich(oscar) ?
yes
Page 387

Backtracking Used
| ?- ostrich(X).
1
1 Call: ostrich(_368) ?
2
2 Call: bird(_368) ?
?
2
2 Exit: bird(tweety) ?
3
2 Call: large(tweety) ?
3
2 Fail: large(tweety) ?
2
2 Redo: bird(tweety) ?
?
2
2 Exit: bird(oscar) ?
4
2 Call: large(oscar) ?
4
2 Exit: large(oscar) ?
?
1
1 Exit: ostrich(oscar) ?
X = oscar ?
yes
Page 388

Backtracking: Eﬀect of Query
/projects/shapiro/CSE563/Examples/Prolog/backtrack.prolog:
supervisorOf(X,Y) :- managerOf(X,Z), departmentOf(Y,Z).
managerOf(jones,accountingDepartment).
managerOf(smith,itDepartment).
departmentOf(kelly,accountingDepartment).
departmentOf(brown,itDepartment).
Backtracking not needed:
| ?- supervisorOf(smith,X).
1
1 Call: supervisorOf(smith,_380) ?
2
2 Call: managerOf(smith,_772) ?
2
2 Exit: managerOf(smith,itDepartment) ?
3
2 Call: departmentOf(_380,itDepartment) ?
3
2 Exit: departmentOf(brown,itDepartment) ?
1
1 Exit: supervisorOf(smith,brown) ?
X = brown ?
yes
Page 389

Backtracking Example, part 2
supervisorOf(X,Y) :- managerOf(X,Z), departmentOf(Y,Z).
managerOf(jones,accountingDepartment).
managerOf(smith,itDepartment).
departmentOf(kelly,accountingDepartment).
departmentOf(brown,itDepartment).
| ?- supervisorOf(X,brown).
1
1 Call: supervisorOf(_368,brown) ?
2
2 Call: managerOf(_368,_772) ?
?
2
2 Exit: managerOf(jones,accountingDepartment) ?
3
2 Call: departmentOf(brown,accountingDepartment) ?
3
2 Fail: departmentOf(brown,accountingDepartment) ?
2
2 Redo: managerOf(jones,accountingDepartment) ?
2
2 Exit: managerOf(smith,itDepartment) ?
4
2 Call: departmentOf(brown,itDepartment) ?
4
2 Exit: departmentOf(brown,itDepartment) ?
1
1 Exit: supervisorOf(smith,brown) ?
X = smith ?
yes
Page 390

Negation by Failure
& The Closed World Assumption
| ?- [user].
% consulting user...
| manager(jones, itSection).
| manager(smith, accountingSection).
|
% consulted user in module user, 0 msec 416 bytes
yes
| ?- manager(smith, itSection).
no
| ?- manager(kelly, accountingSection).
no
Negation by failure: “no” means didn’t succeed.
CWA: If it’s not in the KB, it’s not true.
Page 391

Cut: Preventing Backtracking
KB Without Cut
| ?- consult(user).
% consulting user...
| bird(oscar).
| bird(tweety).
| bird(X) :- feathered(X).
| feathered(maggie).
| large(oscar).
| ostrich(X) :- bird(X), large(X).
|
% consulted user in module user, 0 msec 1120 bytes
yes
Page 392

No Backtracking Needed
| ?- trace.
% The debugger will first creep -- showing everything (trace)
yes
% trace
| ?- ostrich(oscar).
1
1 Call: ostrich(oscar) ?
2
2 Call: bird(oscar) ?
?
2
2 Exit: bird(oscar) ?
3
2 Call: large(oscar) ?
3
2 Exit: large(oscar) ?
?
1
1 Exit: ostrich(oscar) ?
yes
% trace
Page 393

Unwanted Backtracking
| ?- ostrich(tweety).
1
1 Call: ostrich(tweety) ?
2
2 Call: bird(tweety) ?
?
2
2 Exit: bird(tweety) ?
3
2 Call: large(tweety) ?
3
2 Fail: large(tweety) ?
2
2 Redo: bird(tweety) ?
4
3 Call: feathered(tweety) ?
4
3 Fail: feathered(tweety) ?
2
2 Fail: bird(tweety) ?
1
1 Fail: ostrich(tweety) ?
no
No need to try to solve bird(tweety) another way.
Page 394

KB With Cut
| ?- consult(user).
% consulting user...
| bird(oscar).
| bird(tweety).
| bird(X) :- feathered(X).
| feathered(maggie).
| large(oscar).
| ostrich(X) :- bird(X), !, large(X).
|
% consulted user in module user, 0 msec -40 bytes
yes
% trace
Page 395

No Extra Backtracking
| ?- ostrich(tweety).
1
1 Call: ostrich(tweety) ?
2
2 Call: bird(tweety) ?
?
2
2 Exit: bird(tweety) ?
3
2 Call: large(tweety) ?
3
2 Fail: large(tweety) ?
1
1 Fail: ostrich(tweety) ?
no
% trace
Page 396

Cut Fails the Head Instance: Program
| ?- [user].
% compiling user...
| yellow(bigbird).
| bird(tweety).
| canary(X) :- bird(X), !, yellow(X).
| canary(X).
* [X] - singleton variables
|
% compiled user in module user, 0 msec 600 bytes
yes
| ?- canary(fred).
yes
| ?- canary(bigbird).
yes
| ?- canary(tweety).
no
| ?-
Page 397

fail: Forcing Failure
If something is a canary, it is not a penguin.
| ?- consult(user).
% consulting user...
| penguin(X) :- canary(X), !, fail.
| canary(tweety).
|
% consulted user in module user, 0 msec 416 bytes
yes
% trace
| ?- penguin(tweety).
1
1 Call: penguin(tweety) ?
2
2 Call: canary(tweety) ?
2
2 Exit: canary(tweety) ?
1
1 Fail: penguin(tweety) ?
no
% trace
Page 398

Cut Fails the Head Instance: Program
penguin(X) :- canary(X), !, fail.
penguin(X) :- bird(X), swims(X).
canary(tweety).
bird(willy).
swims(willy).
Page 399

Cut Fails the Head Instance: Run
| ?- penguin(willy).
1
1 Call: penguin(willy) ?
2
2 Call: canary(willy) ?
2
2 Fail: canary(willy) ?
3
2 Call: bird(willy) ?
3
2 Exit: bird(willy) ?
4
2 Call: swims(willy) ?
4
2 Exit: swims(willy) ?
1
1 Exit: penguin(willy) ?
yes
% trace
| ?- penguin(tweety).
1
1 Call: penguin(tweety) ?
2
2 Call: canary(tweety) ?
2
2 Exit: canary(tweety) ?
1
1 Fail: penguin(tweety) ?
no
Page 400

Cut Fails Head Alternatives
| ?- penguin(X).
1
1 Call: penguin(_368) ?
2
2 Call: canary(_368) ?
2
2 Exit: canary(tweety) ?
1
1 Fail: penguin(_368) ?
no
Moral:
Use cut when seeing if a ground atom is satisﬁed (T/F question),
but not when generating satisfying instances (wh questions).
Page 401

Bad Rule Order
penguin(X) :- bird(X), swims(X).
penguin(X) :- canary(X), !, fail.
bird(X) :- canary(X).
canary(tweety).
% trace
| ?- penguin(tweety).
1
1 Call: penguin(tweety) ?
2
2 Call: bird(tweety) ?
3
3 Call: canary(tweety) ?
3
3 Exit: canary(tweety) ?
2
2 Exit: bird(tweety) ?
4
2 Call: swims(tweety) ?
4
2 Fail: swims(tweety) ?
5
2 Call: canary(tweety) ?
5
2 Exit: canary(tweety) ?
1
1 Fail: penguin(tweety) ?
no
Page 402

Good Rule Order
penguin(X) :- canary(X), !, fail.
penguin(X) :- bird(X), swims(X).
bird(X) :- canary(X).
canary(tweety).
% trace
| ?- penguin(tweety).
1
1 Call: penguin(tweety) ?
2
2 Call: canary(tweety) ?
2
2 Exit: canary(tweety) ?
1
1 Fail: penguin(tweety) ?
no
Page 403

SICSTUS Allows “or” In Body.
bird(willy).
swims(willy).
canary(tweety).
penguin(X) :-
canary(X), !, fail;
bird(X), swims(X).
bird(X) :- canary(X).
| ?- [’twoRuleCutOr.prolog’].
% compiling /projects/shapiro/CSE563/twoRuleCutOr.prolog...
* clauses for user:bird/1 are not together
* Approximate lines: 8-10, file: ’/projects/shapiro/CSE563/twoRuleCutOr.prolog’
% compiled /projects/shapiro/CSE563/twoRuleCutOr.prolog in module user, 0 msec 928 bytes
yes
| ?- penguin(willy).
yes
| ?- penguin(tweety).
no
Page 404

not: “Negated” Antecedents
A bird that is not a canary is a penguin.
| penguin(X) :- bird(X), !, \+canary(X).
| bird(opus).
| canary(tweety).
% compiled user in module user, 0 msec 512 bytes
| ?- penguin(opus).
1
1 Call: penguin(opus) ?
2
2 Call: bird(opus) ?
2
2 Exit: bird(opus) ?
3
2 Call: canary(opus) ?
3
2 Fail: canary(opus) ?
1
1 Exit: penguin(opus) ?
yes
\+ is SICStus Prolog’s version of not.
It is negation by failure, not logical negation.
Page 405

Can Use Functions
driver(X) :- drives(X,_).
drives(mother(X),X) :- schoolchild(X).
schoolchild(betty).
schoolchild(tom).
| ?- driver(X).
X = mother(betty) ? ;
X = mother(tom) ? ;
no
Page 406

Inﬁnitely Growing Terms
driver(X) :- drives(X,_).
drives(mother(X),X) :- commuter(X).
commuter(betty).
commuter(tom).
commuter(mother(X)) :- commuter(X).
| ?- driver(X).
X = mother(betty) ? ;
X = mother(tom) ? ;
X = mother(mother(betty)) ? ;
X = mother(mother(tom)) ? ;
X = mother(mother(mother(betty))) ? ;
X = mother(mother(mother(tom))) ?
yes
Page 407

Prolog Does Not Do the Occurs Check
<pollux:CSE563:2:31> sicstus
...
| ?- [user].
% consulting user...
| mother(motherOf(X), X).
|
% consulted user in module user, 0 msec 248 bytes
yes
| ?- mother(Y, Y).
Y = motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(
motherOf(motherOf(motherOf(motherOf(...))))))))))
yes
| ?-
Page 408

“=” and “is”
| ?- p(X, b, f(c,Y)) = p(a, U, f(V,U)).
U = b,
V = c,
X = a,
Y = b ?
yes
| ?- X is 2*(3+6).
X = 18 ?
yes
| ?- X = 2*(3+6).
X = 2*(3+6) ?
yes
| ?- X is 2*(3+6), Y is X/3.
X = 18,
Y = 6.0 ?
yes
| ?- Y is X/3, X is 2*(3+6).
! Instantiation error in argument 2 of is/2
! goal:
_76 is _73/3
Page 409

Avoid Left Recursive Rules
To deﬁne ancestor as the transitive closure of parent.
The base case: ancestor(X,Y) :- parent(X,Y).
Three possible recursive cases:
1. ancestor(X,Y) :- parent(X,Z), ancestor(Z,Y).
2. ancestor(X,Y) :- ancestor(X,Z), parent(Z,Y).
3. ancestor(X,Y) :- ancestor(X,Z), ancestor(Z,Y).
Versions (2) and (3) will cause inﬁnite loops.
Page 410

7 A Potpourri of Subdomains
7.1 Taxonomies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
7.2 Time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .418
7.3 Things vs. Substances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .425
Page 411

Taxonomies: Categories as Intensional
Sets
In mathematics, a set is deﬁned by its members.
This is an extensional set.
Plato: Man is a featherless biped.
An intensional set is deﬁned by properties.
Aristotle: Man is a rational animal.
A category (type, class) is an intensional set.
Page 412

Taxonomies: Need for Two Relations
With sets, there’s a diﬀerence between
set membership, ∈
5 ∈{1, 3, 5, 7, 9}
and subset, ⊂, ⊆
{1, 3, 5, 7, 9} ⊂{1, 2, 3, 4, 5, 6, 7, 8, 9}
One diﬀerence is that subset is transitive:
{1, 3, 5} ⊂{1, 3, 5, 7, 9} and {1, 3, 5, 7, 9} ⊂{1, 2, 3, 4, 5, 6, 7, 8, 9}
and {1, 3, 5} ⊂{1, 2, 3, 4, 5, 6, 7, 8, 9}
membership is not:
5 ∈{1, 3, 5, 7, 9} and {1, 3, 5, 7, 9} ∈{{1, 3, 5, 7, 9}, {2, 4, 6, 8}}
but 5 ̸∈{{1, 3, 5, 7, 9}, {2, 4, 6, 8}}
Similarly, we need both the instance relation and the subcategory
relation.
Page 413

Taxonomies:
Categories as Unary Predicates
One way to represent taxonomies:
Canary(Tweety)
∀x[(Canary(x) ⇒Bird(x)]
∀x[(Bird(x) ⇒Vertebrate(x)]
∀x[(Vertebrate(x) ⇒Chordate(x)]
∀x[(Chordate(x) ⇒Animal(x)]
Page 414

Taxonomies: Reifying
To reify: to make a thing of.
Allows discussion of “predicates” in FOL.
Membership: Member or Instance or Isa
Isa(Tweety, Canary)
Subcategory: Subclass or Ako (sometimes, even, Isa)
Ako(Canary, Bird)
Ako(Bird, Vertebrate)
Ako(Vertebrate, Chordate)
Ako(Chordate, Animal)
Axioms:
∀x∀c1∀c2[Isa(x, c1) ∧Ako(c1, c2) ⇒Isa(x, c2)]
∀c1∀c2∀c3[Ako(c1, c2) ∧Ako(c2, c3) ⇒Ako(c1, c3)]
Page 415

Discussing Categories
Isa(Canary, Species)
Isa(Bird, Class)
Isa(Chordate, Phylum)
Isa(Animal, Kingdom)
Extinct(Dinosaur)
Note: That’s Isa, not Ako.
If categories are predicates, requires second-order logic.
Other relationships: exhaustive subcategories, disjoint categories,
partitions.
DAG (directed acyclic graph), rather than just a tree.
E.g., human: man vs. woman; child vs. adult vs. senior.
Page 416

Transitive Closure
It’s sometimes useful (especially in Prolog)
to have a second relation, R2
be the transitive closure of a relation, R1.
∀R1, R2[transitiveClosureOf(R2, R1)
⇔[∀x, y(R1(x, y) ⇒R2(x, y))
∧∀x, y, z[R1(x, y) ∧R2(y, z) ⇒R2(x, z)]]
E.g. ancestor is the transitive closure of parent:
∀x, y[parent(x, y) ⇒ancestor(x, y)]
∀x, y, z[parent(x, y) ∧ancestor(y, z) ⇒ancestor(x, z)]
Page 417

7.2 Time
How would you represent time?
Discuss
Page 418

Subjective vs. Objective: Subjective
Make now an individual in the domain.
Include other times relative to now.
OK if time doesn’t move.
Page 419

Subjective vs. Objective: Objective
Make now a meta-logical variable with some time-denoting term as
value.
Relate times to each other, e.g. Before(t1, t2).
Now can move by giving now a new value.
Page 420

Points vs. Intervals: Points
Use numbers: integers, rationals, reals?
Computer reals aren’t really dense.
How to assign numbers to times?
Granularity: How big, numerically, is a day, or any other interval of
time?
If an interval is deﬁned as a pair of points, which interval is the
midpoint in, if one interval immediately follows another?
Page 421

Points vs. Intervals: Intervals
Use intervals only: no points at all.
More cognitively accurate.
Granularity is not ﬁxed.
A “point” is just an interval with nothing inside it.
Page 422

James Allen’s Interval Relations
x
x
before(x,y)
|---|
|---|
meets(x,y)
|---|---|
y
y
x
x
|---|
overlaps(x,y)
|----|
equals(x,y) |---|
|----|
y
y
x
x
starts(x,y)
|---|
finishes(x,y)
|---|
|-----|
|-----|
y
y
x
during(x,y)
|---|
|-----|
y
[James F. Allen, Maintaining Knowledge About Temporal Intervals, Communications of the ACM 26,
11 (Nov 1983), 832–843.]
Page 423

A Smaller Set of Temporal Relations
If fewer distinctions are needed, one may use
before(x, y) for Allen’s before(x, y) ∨meets(x, y)
during(x, y) for Allen’s starts(x, y) ∨during(x, y) ∨ﬁnishes(x, y)
overlaps(x, y) and equals(x, y)
and appropriate converses.
Page 424

7.3 Things vs. Substances
Count Nouns vs. Mass Nouns
A count noun denotes a thing.
Count nouns can be singular or plural.
Things can be counted.
One dog. Two dogs.
A mass noun denotes a substance.
Mass nouns can only be singular.
One can have a quantity of a substance.
A glass of water. A pint of ice cream.
Page 425

A Quantity of a Substance
is a Thing
water a substance
a lake = a body of water a thing
lakes a plurality of things
40 acres of lakes a quantity of a substance
Page 426

Nouns with mass and count senses
A noun might have both senses.
a piece of pie vs. A piece of a pie
two pieces of steak vs. two steaks
Any count noun can be “massiﬁed”.
Any thing can be put through “the universal grinder”.
I can’t get up; I’ve got cat on my lap.
Page 427

8 SNePS
8.1 SNePSLOG Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
8.2 SNePSLOG Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
8.3 SNePSLOG Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446
8.4 Loading and Running SNePSLOG. . . . . . . . . . . . . . . . . . . . . . . . . .456
8.5 Reasoning Heuristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
8.6 SNePS as a Network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
8.7 SNeRE: The SNePS Rational Engine . . . . . . . . . . . . . . . . . . . . . . . 499
Page 428

8.1 SNePSLOG Semantics
The Intensional Domain
of (Mental) Entities
Frege: The Morning Star is the Evening Star.
diﬀerent from The Morning Star is the Morning Star.
Russell: George IV wanted to know whether Scott was the author of
Waverly.
not George IV wanted to know whether the author of Waverly was
the author of Waverly.
Jerry Siegel and Joe Shuster: Clark Kent is a mild-mannered
reporter; Superman is the man of steel.
Page 429

Intensions vs. Extensions
the Morning Star and the Evening Star
Scott and the author of Waverly
Clark Kent and Superman
are diﬀerent intensions, or intensional entities, or mental entities, or
just entities,
even though they are coreferential, or extensionally equivalent, or
have the same extensions.
Page 430

SNePSLOG Semantics
Intensional Representation
SNePSLOG individual ground terms denote intensions, (mental)
entities.
Mental entities include propositions.
Propositions are ﬁrst-class members of the domain.
SNePSLOG wﬀs denote propositions.
Assume that for every entity in the domain there is a term that
denotes it.
Make unique names assumption: no two terms denote the same
entity.
Page 431

The Knowledge Base
Think of the SNePS KB as the contents of the mind of an
intelligent agent.
The terms in the KB denote mental entities that the agent has
conceived of (so far).
Some of the wﬀs are asserted.
These denote propositions that the agent believes.
The rules of inference sanction believing some additional
proposition(s), but drawing that inference is optional.
I.e., the agent is not logically omniscient.
Page 432

8.2 SNePSLOG Syntax
Atomic Symbols
Individual Constants, Variables, Function Symbols:
any Lisp symbol, number, or string.
All that matters is the sequence of characters.
I.e. "4", \4, and 4, are the same.
The sets of individual constants, variables, and function symbols
should be distinct, but don’t have to be.
Page 433

SNePSLOG Syntax
Terms
An individual constant is a term.
A variable is a term.
If t1, ..., tn are terms, then {t1, ..., tn} is a set of terms.
If f is a function symbol or a variable, then f() is a term.
If t1, ..., tn are terms or sets of terms and f is a function
symbol or variable, then f(t1, ..., tn) is a term.
A function symbol needn’t have a ﬁxed arity, but it might be a
mistake of formalization otherwise.
Page 434

SNePSLOG Syntax
Atomic Wﬀs
If x is a variable, then x is a wﬀ.
If P is a proposition-valued function symbol or variable,
then P() is a wﬀ.
If t1, ..., tn are terms or sets of terms
and P is a proposition-valued function symbol or variable,
then P(t1, ..., tn) is a wﬀ.
A predicate symbol needn’t have a ﬁxed arity, but it might be a
mistake of formalization otherwise.
If P1, . . . , Pn are wﬀs, then {P1, . . . , Pn} is a set of wﬀs.
Abbreviation: If P is a wﬀ, then P is an abbreviation of {P}.
Every wﬀis a proposition-denoting term.
Page 435

SNePSLOG Syntax/Semantics
AndOr
If {P1, . . . , Pn} is a set of wﬀs (proposition-denoting terms),
and i and j are integers such that 0 <= i <= j <= n, then
andor(i, j){P1, . . . , Pn} is a wﬀ(proposition-denoting term).
The proposition that at least i and at most j of P1, . . . , Pn are True.
Page 436

SNePSLOG Syntax/Semantics
Abbreviations of AndOr
~P = andor(0,0){P}
and{P1, . . . , Pn} = andor(n, n){P1, . . . , Pn}
or{P1, . . . , Pn} = andor(1, n){P1, . . . , Pn}
nand{P1, . . . , Pn} = andor(0, n −1){P1, . . . , Pn}
nor{P1, . . . , Pn} = andor(0, 0){P1, . . . , Pn}
xor{P1, . . . , Pn} = andor(1, 1){P1, . . . , Pn}
P1 and ...
and Pn = andor(n, n){P1, . . . , Pn}
P1 or ...
or Pn = andor(1, n){P1, . . . , Pn}
Page 437

SNePSLOG Syntax/Semantics
Thresh
If {P1, . . . , Pn} is a set of wﬀs (proposition-denoting terms)
and i and j are integers such that 0 <= i <= j <= n, then
thresh(i, j){P1, . . . , Pn} is a wﬀ(proposition-denoting term).
The proposition that
either fewer than i or more than j of P1, . . . , Pn are True.
Page 438

SNePSLOG Syntax/Semantics
Abbreviations of Thresh
iff{P1, . . . , Pn}
is an abbreviation of thresh(1, n −1){P1, . . . , Pn}
P1 <=> · · · <=> Pn
is an abbreviation of thresh(1, n −1){P1, . . . , Pn}
thresh(i){P1, . . . , Pn}
is an abbreviation of thresh(i, n −1){P1, . . . , Pn}
Page 439

SNePSLOG Syntax/Semantics
Numerical Entailment
If {P1, . . . , Pn} and {Q1, . . . , Qm} are sets of wﬀs
(proposition-denoting terms), and i is an integer, 1 <= i <= n,
then
{P1, . . . , Pn} i=> {Q1, . . . , Qm} is a wﬀ(proposition-denoting
term).
The proposition that whenever at least i of P1, . . . , Pn are True,
then so is any Qj ∈{Q1, . . . , Qm}.
Page 440

SNePSLOG Syntax/Semantics
Abbreviations of Numerical Entailment
{P1, . . . , Pn} => {Q1, . . . , Qm}
is an abbreviation of {P1, . . . , Pn} 1=> {Q1, . . . , Qm}
{P1, . . . , Pn} v=> {Q1, . . . , Qm}
is also an abbreviation of {P1, . . . , Pn} 1=> {Q1, . . . , Qm}
{P1, . . . , Pn} &=> {Q1, . . . , Qm}
is an abbreviation of {P1, . . . , Pn} n=> {Q1, . . . , Qm}
Page 441

SNePSLOG Syntax/Semantics
Universal Quantiﬁer
If P is a wﬀ(proposition-denoting term)
and x1, . . . , xn are variables, then
all(x1, . . . , xn)(P) is a wﬀ(proposition-denoting term).
The proposition that for every sequence of ground terms, t1, . . . , tn,
P{t1/x1, . . . , tn/xn} is True.
Page 442

SNePSLOG Syntax/Semantics
Numerical Quantiﬁer
If P and Q are sets of wﬀs, x1, . . . , xn are variables, and i, j, and k
are integers such that 0 <= i <= j <= k, then
nexists(i, j, k)(x1, . . . , xn)(P:
Q) is a wﬀ.
The proposition that there are k sequences of ground terms,
t1, . . . , tn, that satisfy every P ∈P, and, of them, at least i and at
most j also satisfy every Q ∈Q.
Page 443

SNePSLOG Syntax/Semantics
Abbreviations of Numerical Quantiﬁer
nexists( , j,
)(x1, . . . , xn)(P:
Q)
is an abbreviation of nexists(0, j, ∞)(x1, . . . , xn)(P:
Q)
nexists(i,
, k)(x1, . . . , xn)(P:
Q)
is an abbreviation of nexists(i, k, k)(x1, . . . , xn)(P:
Q)
Page 444

SNePSLOG Syntax/Semantics
Wﬀs are Terms
Every wﬀis a proposition-denoting term.
So, e.g., Believes(Tom, ~Penguin(Tweety))
is a wﬀ, and a well-formed term.
For a more complete, more formal syntax, see
The SNePS 2.7.1 User’s Manual,
http://www.cse.buffalo.edu/sneps/Manuals/manual271.pdf.
Page 445

8.3 SNePSLOG Proof Theory
Implemented Rules of Inference
Reduction Inference
Reduction Inference1: If α is a set of terms and β ⊂α,
P(t1, . . . , α, ...tn) ⊢P(t1, . . . , β, . . . tn)
Reduction Inference2: If α is a set of terms, and t ∈α,
P(t1, . . . , α, ...tn) ⊢P(t1, ..., t, ...tn)
Page 446

Example of Reduction Inference
: clearkb
Knowledge Base Cleared
: Member({Fido, Rover, Lassie}, {dog, pet}).
wff1!:
Member({Lassie,Rover,Fido},{pet,dog})
CPU time : 0.00
: Member ({Fido, Lassie}, dog)?
wff2!:
Member({Lassie,Fido},dog)
CPU time : 0.00
Page 447

SNePSLOG Proof Theory
Implemented Rules of Inference
for AndOr
AndOr I1: P1, ..., Pn ⊢andor(n, n){P1, ..., Pn}
AndOr I2: ~P1, ..., ~Pn ⊢andor(0,0){P1, ..., Pn}
AndOr E1: andor(i, j){P1, ..., Pn}, ~P1, ..., ~Pn−i ⊢Pj
for n −i < j ≤n
AndOr E2: andor(i, j){P1, ..., Pn}, P1, ..., Pj ⊢~Pk,
for j < k ≤n
Page 448

SNePSLOG Proof Theory
Implemented Rules of Inference
for Thresh
Thresh E1: When at least i args are true, and at least n −j −1
args are false, conclude that any other arg is true.
thresh(i, j){P1, ..., Pn},
P1, ..., Pi, ¬Pi+1, ..., ¬Pi+n−j−1
⊢Pi+n−j
Thresh E2: When at least i −1 args are true, and at least n −j
args are false, conclude that any other arg is false.
thresh(i, j){P1, ..., Pn},
P1, ..., Pi−1, ¬Pi+1, ..., ¬Pi+n−j
⊢¬Pi
Page 449

SNePSLOG Proof Theory
Implemented Rules of Inference
for &=>
&=>I: If A, P1, ..., Pn ⊢Qi for 1 ≤i ≤m
then A ⊢{P1, ..., Pn} &=> {Q1, ..., Qm}
&=>E: {P1, ..., Pn} &=> {Q1, ..., Qm}, P1, ..., Pn ⊢Qi,
for 1 ≤i ≤m
Page 450

SNePSLOG Proof Theory
Implemented Rules of Inference
for v=>
v=>I: If A ⊢P v=> Q and A ⊢Q v=> R then A ⊢P v=> R
v=>E: {P1, ..., Pn} v=> {Q1, ..., Qm}, Pi, ⊢Qj,
for 1 ≤i ≤n, 1 ≤j ≤m
Page 451

SNePSLOG Proof Theory
Implemented Rules of Inference
for i=>
i=>E: {P1, ..., Pn} i=> {Q1, ..., Qm}, P1, ..., Pi ⊢Qj,
for 1 ≤i ≤n, 1 ≤j ≤m
Page 452

SNePSLOG Proof Theory
Implemented Rules of Inference
for all
Universal Elimination for universally quantiﬁed versions of
andor, thresh, v=>, &=>, and i=>.
Page 453

UVBR & Symmetric Relations
In any substitution {t1/x1, . . . , tn/xn}, if xi ̸= xj, then ti ̸= tj
: all(u,v,x,y)(childOf({u,v}, {x,y}) => Siblings({u,v})).
: childOf({Tom,Betty,John,Mary}, {Pat,Harry}).
: Siblings({?x,?y})?
wff14!:
Siblings({Mary,John})
wff13!:
Siblings({John,Betty})
wff12!:
Siblings({Betty,Tom})
wff11!:
Siblings({Mary,Betty})
wff10!:
Siblings({John,Tom})
wff9!:
Siblings({Mary,Tom})
Page 454

SNePSLOG Proof Theory
Implemented Rules of Inference
for nexists
nexists E1:
nexists(i, j, k)(x)(P(x) : Q(x)),
P(t1), Q(t1), . . . , P(tj), Q(tj),
P(tj+1)
⊢¬Q(tj+1)
nexists E2:
nexists(i, j, k)(x)(P(x) : Q(x)),
P(t1), ¬Q(t1), . . . , P(tk−i), ¬Q(tk−i),
P(tk−i+1)
⊢Q(tk−i+1)
Page 455

8.4 Loading SNePSLOG
cl-user(2): :ld /projects/snwiz/bin/sneps
; Loading /projects/snwiz/bin/sneps.lisp
;;; Installing streamc patch, version 2.
Loading system SNePS...10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
SNePS-2.7 [PL:2 2010/09/04 02:35:18] loaded.
Type ‘(sneps)’ or ‘(snepslog)’ to get started.
cl-user(3): (snepslog)
Welcome to SNePSLOG (A logic interface to SNePS)
Copyright (C) 1984--2010 by Research Foundation of
State University of New York. SNePS comes with ABSOLUTELY NO WARRANTY!
Type ‘copyright’ for detailed copyright information.
Type ‘demo’ for a list of example applications.
Page 456

Running SNePSLOG
cl-user(3): (snepslog)
Welcome to SNePSLOG (A logic interface to SNePS)
Copyright (C) 1984--2010 by Research Foundation of
State University of New York. SNePS comes with ABSOLUTELY NO WARRANTY!
Type ‘copyright’ for detailed copyright information.
Type ‘demo’ for a list of example applications.
: clearkb
Knowledge Base Cleared
CPU time : 0.00
: Member({Fido, Rover, Lassie}, {dog, pet}).
wff1!:
Member({Lassie,Rover,Fido},{pet,dog})
CPU time : 0.00
: Member ({Fido, Lassie}, dog)?
wff2!:
Member({Lassie,Fido},dog)
CPU time : 0.00
Page 457

Common SNePSLOG Commands
: clearkb
Knowledge Base Cleared
: all(x)(dog(x) => animal(x)). ; Assert into the KB
wff1!:
all(x)(dog(x) => animal(x))
: dog(Fido). ; Assert into the KB
wff2!:
dog(Fido)
: dog(Fido)?? ; Query assertion without inference
wff2!:
dog(Fido)
Page 458

Common SNePSLOG Commands
: animal(Fido)?? ; Query assertion without inference
: animal(Fido)? ; Query assertion with inference
wff3!:
animal(Fido)
: dog(Rover)! ; Assert into the KB & do forward inference
wff6!:
animal(Rover)
wff5!:
dog(Rover)
: list-asserted-wffs ; Print all asserted wffs
wff6!:
animal(Rover)
wff5!:
dog(Rover)
wff3!:
animal(Fido)
wff2!:
dog(Fido)
wff1!:
all(x)(dog(x) => animal(x))
Page 459

Tracing Inference
: trace inference
Tracing inference.
: animal(Fido)?
I wonder if
wff3:
animal(Fido)
holds within the BS defined by context default-defaultct
I wonder if
wff5:
dog(Fido)
holds within the BS defined by context default-defaultct
I know
wff2!:
dog({Rover,Fido})
Since
wff1!:
all(x)(dog(x) => animal(x))
and
wff5!:
dog(Fido)
I infer
wff3:
animal(Fido)
wff3!:
animal(Fido)
CPU time : 0.01
: untrace inference
Untracing inference.
CPU time : 0.00
: animal(Rover)?
wff6!:
animal(Rover)
Page 460

Recursive Rules
Don’t Cause Inﬁnite Loops
: all(x,y)(parentOf(x,y) => ancestorOf(x,y)).
wff1!:
all(y,x)(parentOf(x,y) => ancestorOf(x,y))
: all(x,y,z)({ancestorOf(x,y), ancestorOf(y,z)} &=> ancestorOf(x,z)).
wff2!:
all(z,y,x)({ancestorOf(y,z),ancestorOf(x,y)} &=> {ancestorOf(x,z)})
: parentOf(Sam,Lou).
wff3!:
parentOf(Sam,Lou)
: parentOf(Lou,Stu).
wff4!:
parentOf(Lou,Stu)
: ancestorOf(Max,Stu).
wff5!:
ancestorOf(Max,Stu)
: ancestorOf(?x,Stu)?
wff8!:
ancestorOf(Sam,Stu)
wff6!:
ancestorOf(Lou,Stu)
wff5!:
ancestorOf(Max,Stu)
CPU time : 0.01
Page 461

Inﬁnitely Growing Terms
Get Cut Oﬀ
: all(x)(Duck(motherOf(x)) => Duck(x)).
wff1!:
all(x)(Duck(motherOf(x)) => Duck(x))
CPU time : 0.00
: Duck(Daffy)?
I wonder if
wff2:
Duck(Daffy)
holds within the BS defined by context default-defaultct
I wonder if
wff5:
Duck(motherOf(Daffy))
holds within the BS defined by context default-defaultct
I wonder if
wff8:
Duck(motherOf(motherOf(Daffy)))
holds within the BS defined by context default-defaultct
...
I wonder if
wff32:
Duck(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(Daffy))
holds within the BS defined by context default-defaultct
SNIP depth cutoff beyond *depthcutoffback* = 10
I wonder if
wff35:
Duck(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherOf(motherO
holds within the BS defined by context default-defaultct
SNIP depth cutoff beyond *depthcutoffback* = 10
SNIP depth cutoff beyond *depthcutoffback* = 10
CPU time : 0.05
Page 462

Eager-Beaver Search
: all(x)(Duck(motherOf(x)) => Duck(x)).
wff1!:
all(x)(Duck(motherOf(x)) => Duck(x))
: all(x)({walksLikeaDuck(x), talksLikeaDuck(x)} &=> Duck(x)).
wff2!:
all(x)({talksLikeaDuck(x),walksLikeaDuck(x)} &=> {Duck(x)})
: and{talksLikeaDuck(Daffy),walksLikeaDuck(Daffy)}.
wff5!:
walksLikeaDuck(Daffy) and talksLikeaDuck(Daffy)
: Duck(Daffy)? (1)
I wonder if
wff6:
Duck(Daffy)
I wonder if
wff9:
Duck(motherOf(Daffy))
I wonder if
wff3:
talksLikeaDuck(Daffy)
I wonder if
wff4:
walksLikeaDuck(Daffy)
It is the case that
wff4:
walksLikeaDuck(Daffy)
It is the case that
wff3:
talksLikeaDuck(Daffy)
Since
wff2!:
all(x)({talksLikeaDuck(x),walksLikeaDuck(x)} &=> {Duck(x)})
and
wff3!:
talksLikeaDuck(Daffy)
and
wff4!:
walksLikeaDuck(Daffy)
I infer
wff6:
Duck(Daffy)
wff6!:
Duck(Daffy)
CPU time : 0.02
Page 463

Contradictions
The KB
: clearkb
Knowledge Base Cleared
: all(x)(nand{Mammal(x), Fish(x)}).
wff1!:
all(x)(nand{Fish(x),Mammal(x)})
: all(x)(LivesInWater(x) => Fish(x)).
wff2!:
all(x)(LivesInWater(x) => Fish(x))
: all(x)(BearsYoungAlive(x) => Mammal(x)).
wff3!:
all(x)(BearsYoungAlive(x) => Mammal(x))
: LivesInWater(whale).
wff4!:
LivesInWater(whale)
: BearsYoungAlive(whale).
wff5!:
BearsYoungAlive(whale)
Page 464

Contradictions
The Contradiction
: ?x(whale)?
A contradiction was detected within context default-defaultct.
The contradiction involves the newly derived proposition:
wff6!:
Mammal(whale)
and the previously existing proposition:
wff7!:
~Mammal(whale)
You have the following options:
1. [C]ontinue anyway, knowing that a contradiction is derivable;
2. [R]e-start the exact same run in a different context which is
not inconsistent;
3. [D]rop the run altogether.
(please type c, r or d)
=><= d
Page 465

SNePSLOG Demonstrations
: demo
Available demonstrations:
1:
Socrates - Is he mortal?
2:
UVBR - Demonstrating the Unique Variable Binding Rule
3:
The Jobs Puzzle - A solution with the Numerical Quantifie
4:
Pegasus - Why winged horses lead to contradictions
5:
Schubert’s Steamroller
6:
Rule Introduction - Various examples
7:
Examples of various SNeRE constructs.
8:
Enter a demo filename
Your choice (q to quit):
Page 466

8.5 Reasoning Heuristics
Logically equivalent SNePSLOG wﬀs
are interpreted diﬀerently by the SNePS Reasoning System.
Page 467

v=>-Elimination
Instead of
P()
(P() or Q()) => R()
R()
which would require or-I followed by =>-E
Have
P()
{P(), Q()} v=> R()
R()
which requires only v=>-E
Page 468

Example of v=>-E
: P().
wff1!:
P()
: {P(), Q()} v=> R().
wff4!:
{Q(),P()} v=> {R()}
: trace inference
Tracing inference.
: R()?
I wonder if
wff3:
R()
holds within the BS defined by context default-defaultct
I wonder if
wff2:
Q()
holds within the BS defined by context default-defaultct
I know
wff1!:
P()
Since
wff4!:
{Q(),P()} v=> {R()}
and
wff1!:
P()
I infer
wff3:
R()
wff3!:
R()
Page 469

Bi-Directional Inference
Backward Inference
: {p(), q()} v=> {r(), s()}.
wff5!:
{q(),p()} v=> {s(),r()}
: p().
wff1!:
p()
: r()?
I wonder if
wff3:
r()
holds within the BS defined by context default-defaultct
I wonder if
wff2:
q()
holds within the BS defined by context default-defaultct
I know
wff1!:
p()
Since
wff5!:
{q(),p()} v=> {s(),r()}
and
wff1!:
p()
I infer
wff3:
r()
wff3!:
r()
Page 470

Bi-Directional Inference
Forward Inference
: {p(), q()} v=> {r(), s()}.
wff5!:
{q(),p()} v=> {s(),r()}
: p()!
Since
wff5!:
{q(),p()} v=> {s(),r()}
and
wff1!:
p()
I infer
wff4:
s()
Since
wff5!:
{q(),p()} v=> {s(),r()}
and
wff1!:
p()
I infer
wff3:
r()
wff4!:
s()
wff3!:
r()
wff1!:
p()
Page 471

Bi-Directional Inference
Forward-in-Backward Inference
: {p(), q()} v=> {r(), s()}.
wff5!:
{q(),p()} v=> {s(),r()}
: r()?
I wonder if
wff3:
r()
holds within the BS defined by context default-defaultct
I wonder if
wff2:
q()
holds within the BS defined by context default-defaultct
I wonder if
wff1:
p()
holds within the BS defined by context default-defaultct
: p()!
Since
wff5!:
{q(),p()} v=> {s(),r()}
and
wff1!:
p()
I infer
wff3:
r()
wff3!:
r()
wff1!:
p()
Active connection graph cleared by clear-infer.
Page 472

Bi-Directional Inference
Backward-in-Forward Inference
: p().
wff1!:
p()
: p() => (q() => r()).
wff5!:
p() => (q() => r())
: q()!
I know
wff1!:
p()
Since
wff5!:
p() => (q() => r())
and
wff1!:
p()
I infer
wff4:
q() => r()
I know
wff2!:
q()
Since
wff4!:
q() => r()
and
wff2!:
q()
I infer
wff3:
r()
wff4!:
q() => r()
wff3!:
r()
wff2!:
q()
Page 473

Modus Tollens Not Implemented
: all(x)(p(x) => q(x)).
wff1!:
all(x)(p(x) => q(x))
: p(a).
wff2!:
p(a)
: q(a)?
wff3!:
q(a)
: ~q(b).
wff6!:
~q(b)
: p(b)?
:
Page 474

Use Disjunctive Syllogism Instead
: all(x)(or{~p(x), q(x)}).
wff1!:
all(x)(q(x) or ~p(x))
: p(a).
wff2!:
p(a)
: q(a)?
wff3!:
q(a)
: ~q(b).
wff7!:
~q(b)
: p(b)?
wff9!:
~p(b)
Page 475

=> Is Not Material Implication
If ⇒is material implication,
¬(P ⇒Q) ⇔(P ∧¬Q)
and
¬(P ⇒Q) |= P
But ~(p => q) just means that its not the case that p => q:
: ~(p() => q()).
wff4!:
~(p() => q())
: p()?
:
Page 476

Use or
Instead of Material Implication
: ~(~p() or q()).
wff5!:
nor{q(),~p()}
: p()?
wff1!:
p()
Page 477

Ordering of Nested Rules Matters
Optimal Order
: wifeOf(Caren,Stu).
: wifeOf(Ruth,Mike).
: brotherOf(Stu,Judi).
: brotherOf(Mike,Lou).
: parentOf(Judi,Ken).
: parentOf(Lou,Stu).
: all(w,x)(wifeOf(w,x)
=> all(y)(brotherOf(x,y)
=> all(z)(parentOf(y,z)
=> auntOf(w,z)))).
: auntOf(Caren,Ken)?
I wonder if
wff8:
auntOf(Caren,Ken)
I wonder if
p7:
wifeOf(Caren,x)
I know
wff1!:
wifeOf(Caren,Stu)
I wonder if
p8:
brotherOf(Stu,y)
I know
wff3!:
brotherOf(Stu,Judi)
I wonder if
wff5!:
parentOf(Judi,Ken)
I know
wff5!:
parentOf(Judi,Ken)
wff8!:
auntOf(Caren,Ken)
CPU time : 0.03
Page 478

Ordering of Nested Rules Matters
Bad Order
all(x,y)(brotherOf(x,y)
=> all(w)(wifeOf(w,x)
=> all(z)(parentOf(y,z)
=> auntOf(w,z)))).
: auntOf(Caren,Ken)?
I wonder if
wff8:
auntOf(Caren,Ken)
I wonder if
p1:
brotherOf(x,y)
I know
wff3!:
brotherOf(Stu,Judi)
I know
wff4!:
brotherOf(Mike,Lou)
I wonder if
wff12:
wifeOf(Caren,Mike)
I wonder if
wff1!:
wifeOf(Caren,Stu)
I know
wff1!:
wifeOf(Caren,Stu)
I wonder if
wff5!:
parentOf(Judi,Ken)
I know
wff5!:
parentOf(Judi,Ken)
wff8!:
auntOf(Caren,Ken)
CPU time : 0.04
Page 479

Ordering of Nested Rules Matters
Parallel
all(w,x,y,z)({wifeOf(w,x),brotherOf(x,y),parentOf(y,z)}
&=> auntOf(w,z)).
: auntOf(Caren,Ken)?
I wonder if
wff8:
auntOf(Caren,Ken)
I wonder if
p5:
parentOf(y,Ken)
I wonder if
p2:
brotherOf(x,y)
I wonder if
p6:
wifeOf(Caren,x)
I know
wff5!:
parentOf(Judi,Ken)
I know
wff3!:
brotherOf(Stu,Judi)
I know
wff4!:
brotherOf(Mike,Lou)
I know
wff1!:
wifeOf(Caren,Stu)
wff8!:
auntOf(Caren,Ken)
CPU time : 0.03
Page 480

Lemmas (Expertise)
Knowledge Base
: all(r)(transitive(r)
=> all(x,y,z)({r(x,y),r(y,z)} &=> r(x,z))).
: transitive(biggerThan).
: biggerThan(elephant,lion).
: biggerThan(lion,hyena).
: biggerThan(hyena,rat).
Page 481

Lemmas: First Task
: biggerThan(?x,rat)?
I wonder if
p6:
biggerThan(x,rat)
I know
wff5!:
biggerThan(hyena,rat)
I wonder if
wff2!:
transitive(biggerThan)
I know
wff2!:
transitive(biggerThan)
I infer
wff6:
all(z,y,x)({biggerThan(x,y),biggerThan(y,z)} &=> {biggerThan(x,z)})
I wonder if
p8:
biggerThan(y,rat)
I wonder if
p10:
biggerThan(x,y)
I know
wff5!:
biggerThan(hyena,rat)
I wonder if
p12:
biggerThan(rat,z)
I know
wff3!:
biggerThan(elephant,lion)
I know
wff4!:
biggerThan(lion,hyena)
I infer
wff7:
biggerThan(lion,rat)
I infer
wff8:
biggerThan(elephant,rat)
...
wff8!:
biggerThan(elephant,rat)
wff7!:
biggerThan(lion,rat)
wff5!:
biggerThan(hyena,rat)
CPU time : 0.09
Page 482

Second Task
: clear-infer
: biggerThan(truck,SUV).
: biggerThan(SUV,sedan).
: biggerThan(sedan,roadster).
: biggerThan(?x,roadster)?
I wonder if
p14:
biggerThan(x,roadster)
I know
wff11!:
biggerThan(sedan,roadster)
I wonder if
p10:
biggerThan(x,y)
I wonder if
p16:
biggerThan(y,roadster)
I know
wff3!:
biggerThan(elephant,lion)
I know
wff4!:
biggerThan(lion,hyena)
I know
wff5!:
biggerThan(hyena,rat)
I know
wff7!:
biggerThan(lion,rat)
I know
wff8!:
biggerThan(elephant,rat)
I know
wff9!:
biggerThan(truck,SUV)
I know
wff10!:
biggerThan(SUV,sedan)
I know
wff11!:
biggerThan(sedan,roadster)
I infer
wff12:
biggerThan(SUV,roadster)
I infer
wff13:
biggerThan(truck,roadster)
I wonder if
p17:
biggerThan(roadster,z)
wff13!:
biggerThan(truck,roadster)
wff12!:
biggerThan(SUV,roadster)
wff11!:
biggerThan(sedan,roadster)
CPU time : 0.04
Page 483

Contexts
: demo /projects/shapiro/CSE563/Examples/SNePSLOG/facultyMeeting.snepslog
...
: ;;; Example of Contexts
;;; from
;;;
J. P. Martins & S. C. Shapiro, Reasoning in Multiple Belief Spaces IJCAI-83, 370-373.
: all(x)(meeting(x) => xor{time(x,morning), time(x,afternoon)}).
wff1!:
all(x)(meeting(x) => (xor{time(x,afternoon),time(x,morning)}))
: all(x,y)({meeting(x),meeting(y)} &=> all(t)(xor{time(x,t),time(y,t)})).
wff2!:
all(y,x)({meeting(y),meeting(x)} &=> {all(t)(xor{time(y,t),time(x,t)})})
: meeting(facultyMeeting).
wff3!:
meeting(facultyMeeting)
: meeting(seminar).
wff4!:
meeting(seminar)
: meeting(tennisGame).
wff5!:
meeting(tennisGame)
: time(seminar,morning).
wff6!:
time(seminar,morning)
: time(tennisGame,afternoon).
wff7!:
time(tennisGame,afternoon)
: set-context stuSchedule {wff1,wff2,wff3,wff4,wff6}
((assertions (wff6 wff4 wff3 wff2 wff1)) (named (stuSchedule)) (kinconsistent nil))
: set-context tonySchedule {wff1,wff2,wff3,wff5,wff7}
((assertions (wff7 wff5 wff3 wff2 wff1)) (named (tonySchedule)) (kinconsistent nil))
: set-context patSchedule {wff1,wff2,wff3,wff4,wff5,wff6,wff7}
((assertions (wff7 wff6 wff5 wff4 wff3 wff2 wff1)) (named (patSchedule default-defaultct)) (kinconsistent nil))
Page 484

Stu’s Schedule
: set-default-context stuSchedule
((assertions (wff6 wff4 wff3 wff2 wff1)) (named (stuSchedule))
(kinconsistent nil))
: list-asserted-wffs
wff6!:
time(seminar,morning)
wff4!:
meeting(seminar)
wff3!:
meeting(facultyMeeting)
wff2!:
all(y,x)({meeting(y),meeting(x)}
&=> {all(t)(xor{time(y,t),time(x,t)})})
wff1!:
all(x)(meeting(x)
=> (xor{time(x,afternoon),time(x,morning)}))
: time(facultyMeeting,?t)?
wff10!:
time(facultyMeeting,afternoon)
wff9!:
~time(facultyMeeting,morning)
Page 485

Tony’s Schedule
: set-default-context tonySchedule
((assertions (wff7 wff5 wff3 wff2 wff1)) (named (tonySchedule))
(kinconsistent nil))
: list-asserted-wffs
wff12!:
xor{time(facultyMeeting,afternoon),time(facultyMeeting,morning)}
wff7!:
time(tennisGame,afternoon)
wff5!:
meeting(tennisGame)
wff3!:
meeting(facultyMeeting)
wff2!:
all(y,x)({meeting(y),meeting(x)}
&=> {all(t)(xor{time(y,t),time(x,t)})})
wff1!:
all(x)(meeting(x)
=> (xor{time(x,afternoon),time(x,morning)}))
: time(facultyMeeting,?t)?
wff11!:
~time(facultyMeeting,afternoon)
wff8!:
time(facultyMeeting,morning)
Page 486

Pat’s Schedule
: set-default-context patSchedule
((assertions (wff7 wff6 wff5 wff4 wff3 wff2 wff1))
(named (patSchedule default-defaultct)) (kinconsistent nil))
: time(facultyMeeting,?t)?
A contradiction was detected within context patSchedule.
The contradiction involves the newly derived proposition:
wff8!:
time(facultyMeeting,morning)
and the previously existing proposition:
wff9!:
~time(facultyMeeting,morning)
You have the following options:
1. [C]ontinue anyway, knowing that a contradiction is derivable;
2. [R]e-start the exact same run in a different context which is
not inconsistent;
3. [D]rop the run altogether.
(please type c, r or d)
=><= d
Page 487

Resulting Contexts
: describe-context stuSchedule
((assertions (wff6 wff4 wff3 wff2 wff1)) (named (stuSchedule))
(kinconsistent nil))
: describe-context tonySchedule
((assertions (wff7 wff5 wff3 wff2 wff1)) (named (tonySchedule))
(kinconsistent nil))
: describe-context patSchedule
((assertions (wff7 wff6 wff5 wff4 wff3 wff2 wff1))
(named (patSchedule default-defaultct)) (kinconsistent t))
Page 488

8.6 SNePS as a Network:
Semantic Networks
Animal
head
Penguin
Canary
sing
Charlie
Tweety
Opus
isa
isa
moves-by
moves-by
has-part
has-part
moves-by
isa
isa
instance
instance
instance
swimming
Bird
flying
fin
wing
Fish
has-part
can
Some psychological evidence.
More eﬃcient search than logical inference.
Unclear semantics.
Page 489

SNePS as a Network
: clearkb
: Canary(Tweety).
: Penguin(Opus).
: Ako({Canary,Penguin}, Bird).
: Ako(Bird, Animal).
: show
m4!
Bird
a1
Animal
a2
Ako
r
m3!
a2
r
Penguin
a1
Canary
a1
m2!
r
Opus
a1
m1!
r
Tweety
a1
Page 490

Deﬁning Case Frames
: set-mode-3
Net reset
In SNePSLOG Mode 3.
Use define-frame <pred> <list-of-arc-labels>.
...
: define-frame Canary(class member) "[member] is a [class]"
Canary(x1) will be represented by {<class, Canary>, <member, x1>}
: define-frame Penguin(class member) "[member] is a [class]"
Penguin(x1) will be represented by {<class, Penguin>, <member, x1>}
: define-frame Ako(nil subclass superclass) "Every [subclass] is a [superclas
Ako(x1, x2) will be represented by {<subclass, x1>, <superclass, x2>}
Page 491

Entering the KB
: Canary(Tweety).
wff1!:
Canary(Tweety)
: Penguin(Opus).
wff2!:
Penguin(Opus)
: Ako({Canary, Penguin}, Bird).
wff3!:
Ako({Penguin,Canary},Bird)
: Ako(Bird, Animal).
wff4!:
Ako(Bird,Animal)
Page 492

The Knowledge Base
: list-terms
wff1!:
Canary(Tweety)
wff2!:
Penguin(Opus)
wff3!:
Ako({Penguin,Canary},Bird)
wff4!:
Ako(Bird,Animal)
: describe-terms
Tweety is a Canary.
Opus is a Penguin.
Every Penguin and Canary is a Bird.
Every Bird is a Animal.
Page 493

The Network
: show
m4!
Bird
subclass
Animal
superclass
m3!
superclass
Penguin
subclass
Canary
subclass
m2!
class
Opus
member
m1!
class
Tweety
member
Page 494

Path-Based Inference
m4!
Bird
subclass
Animal
superclass
m3!
superclass
Penguin
subclass
Canary
subclass
m2!
class
Opus
member
m1!
class
Tweety
member
: define-path class (compose class
(kstar (compose subclass- ! superclass))
class implied by the path (compose class
(kstar
(compose subclass- ! superclass)))
class- implied by the path (compose
(kstar (compose superclass-
! subclass))
class-)
Page 495

Using Path-Based Inference
: list-asserted-wffs
wff4!:
Ako(Bird,Animal)
wff3!:
Ako({Penguin,Canary},Bird)
wff2!:
Penguin(Opus)
wff1!:
Canary(Tweety)
: define-frame Animal(class member) "[member] is a [class]"
Animal(x1) will be represented by {<class, Animal>, <member, x1>}
: trace inference
Tracing inference.
: Animal(Tweety)?
I wonder if
wff5:
Animal(Tweety)
holds within the BS defined by context default-defaultct
I know
wff1!:
Canary(Tweety)
wff5!:
Animal(Tweety)
Page 496

Rules About Functions in Mode 3
: set-mode-3
: define-frame WestOf(relation domain range)
: define-frame isAbove(relation domain range)
: define-frame Likes(relation liker likee)
: define-frame r(relation domain range)
: define-frame anti-symmetric(nil antisymm)
: all(r)(anti-symmetric(r) => all(x,y)(r(x,y) => ~r(y,x))).
wff1!:
all(r)(anti-symmetric(r) => (all(y,x)(r(x,y) => (~r(y,x)))))
: anti-symmetric({WestOf, isAbove, Likes}).
: WestOf(Buffalo,Rochester).
: isAbove(penthouse37,lobby37).
: Likes(Betty,Tom).
: WestOf(?x,?y)?
wff9!:
~WestOf(Rochester,Buffalo)
wff3!:
WestOf(Buffalo,Rochester)
: isAbove(?x,?y)?
wff13!:
~isAbove(lobby37,penthouse37)
wff4!:
isAbove(penthouse37,lobby37)
: Likes(?x,?y)?
wff5!:
Likes(Betty,Tom)
Page 497

Procedural Attachment in SNePS
cl-user(3): (snepslog)
: load /projects/snwiz/Libraries/expressions.snepslog
: define-frame Value(nil obj val) "the value of [obj] is [val]"
: define-frame radius(nil radiusof) "the radius of [radiusof]"
: define-frame volume(nil volumeof) "the volume of [volumeof]"
: all(x,r,p)({Value(radius(x), r), Value(pi,p)}
&=> all(v)(is(v,/(*(4.0,*(p,*(r,*(r,r)))),3.0))
=> Value(volume(x),v))).
: Value(pi,3.14159).
: Value(radius(sphere1), 9.0).
: Value(volume(sphere1), ?x)?
wff13!:
Value(volume(sphere1),3053.6257)
Page 498

8.7 SNeRE: The SNePS Rational Engine
Motivation
Coming to believe something
is diﬀerent from acting.
Page 499

Prolog Searches In Order
The KB
| ?- [user].
% consulting user...
| q(X) :- q1(X), q2(X).
| q1(X) :- p(X), s(X).
| q2(X) :- r(X), s(X).
| s(X) :- t(X).
| p(a).
| r(a).
| t(a).
|
% consulted user in module user, 0 msec 1592 bytes
yes
Page 500

Prolog Searches In Order
The Run
| ?- trace.
% The debugger will first creep -- showing everything (trace)
yes
% trace
| ?- q(a).
1
1 Call: q(a) ?
2
2 Call: q1(a) ?
3
3 Call: p(a) ?
3
3 Exit: p(a) ?
4
3 Call: s(a) ?
5
4 Call: t(a) ?
5
4 Exit: t(a) ?
4
3 Exit: s(a) ?
2
2 Exit: q1(a) ?
6
2 Call: q2(a) ?
7
3 Call: r(a) ?
7
3 Exit: r(a) ?
8
3 Call: s(a) ?
9
4 Call: t(a) ?
9
4 Exit: t(a) ?
8
3 Exit: s(a) ?
6
2 Exit: q2(a) ?
1
1 Exit: q(a) ?
yes
Page 501

SNePS Avoids Extra Search
The KB
: clearkb
Knowledge Base Cleared
: all(x)({q1(x), q2(x)} &=> q(x)).
: all(x)({p(x), s(x)} &=> q1(x)).
: all(x)({r(x), s(x)} &=> q2(x)).
: all(x)(t(x) => s(x)).
: p(a).
: r(a).
: t(a).
Page 502

SNePS Avoids Extra Search
The Search
: trace inference
Tracing inference.
: q(a)?
I wonder if
wff8:
q(a)
I wonder if
wff10:
q2(a)
I wonder if
wff12:
q1(a)
I wonder if
wff14:
s(a)
I wonder if
wff6!:
r(a)
I wonder if
wff14:
s(a)
I wonder if
wff5!:
p(a)
I know
wff6!:
r(a)
I know
wff5!:
p(a)
I wonder if
wff7!:
t(a)
I know
wff7!:
t(a)
Page 503

SNePS Avoids Extra Search
The Answers
Since
wff4!:
all(x)(t(x) => s(x))
and
wff7!:
t(a)
I infer
wff14:
s(a)
Since
wff3!:
all(x)({s(x),r(x)} &=> {q2(x)})
and
wff14!:
s(a)
and
wff6!:
r(a)
I infer
wff10:
q2(a)
Since
wff2!:
all(x)({s(x),p(x)} &=> {q1(x)})
and
wff14!:
s(a)
and
wff5!:
p(a)
I infer
wff12:
q1(a)
Since
wff1!:
all(x)({q2(x),q1(x)} &=> {q(x)})
and
wff10!:
q2(a)
and
wff12!:
q1(a)
I infer
wff8:
q(a)
wff8!:
q(a)
Page 504

Primitive Acts
: set-mode-3
Net reset
In SNePSLOG Mode 3.
Use define-frame <pred> <list-of-arc-labels>.
...
: define-frame say(action line)
say(x1) will be represented by {<action, say>, <line, x1>}
: ^^
--> (define-primaction sayaction ((line))
(format sneps:outunit "~A" line))
sayaction
--> (attach-primaction say sayaction)
t
--> ^^
: perform say("Hello world")
Hello world
Page 505

Eﬀects: The KB
: set-mode-3
Net reset
In SNePSLOG Mode 3.
Use define-frame <pred> <list-of-arc-labels>.
...
Effect(x1, x2) will be represented by {<act, x1>, <effect, x2>}
...
: define-frame say (action line)
: define-frame said (act agent object)
: define-frame Utterance (class member)
: ^^
--> (define-primaction sayaction ((line))
(format sneps:outunit "~A" line))
sayaction
-->
(attach-primaction say sayaction)
t
--> ^^
: Utterance("Hello world").
: all(x)(Utterance(x) => Effect(say(x), said(I,x))).
Page 506

Eﬀects: The Run
: list-asserted-wffs
wff2!:
all(x)(Utterance(x) => Effect(say(x),said(I,x)))
wff1!:
Utterance(Hello world)
: perform say("Hello world")
Hello world
: list-asserted-wffs
wff5!:
Effect(say(Hello world),said(I,Hello world))
wff4!:
said(I,Hello world)
wff2!:
all(x)(Utterance(x) => Effect(say(x),said(I,x)))
wff1!:
Utterance(Hello world)
Page 507

Deﬁned Acts
: set-mode-3
...
ActPlan(x1, x2) will be represented by {<act, x1>, <plan, x2>}
...
: define-frame say (action part1 part2)
: define-frame greet (action object)
: define-frame Person (class member)
: ^^
--> (define-primaction sayaction ((part1) (part2))
(format sneps:outunit "~A ~A~%"
part1 part2))
sayaction
-->
(attach-primaction say sayaction)
t
--> ^^
: all(x)(Person(x) => ActPlan(greet(x), say(Hello,x))).
: Person(Mike).
: perform greet(Mike).
Hello Mike
Page 508

Other Propositions about Acts
GoalPlan(p, a )
Precondition(a, p )
Page 509

Control Acts
achieve(p )
do-all({a1, ..., an })
do-one({a1, ..., an })
snif({if(p1,a1 ), ..., if(pn,an )[, else(da )]})
sniterate({if(p1,a1 ), ..., if(pn,an )[, else(da )]})
snsequence(a1, a2 )
withall(x, p(x), a(x) [, da ])
withsome(x, p(x), a(x) [, da ])
Must use attach-primaction on whichever you want to use.
Page 510

Policies
ifdo(p, a )
whendo(p, a )
wheneverdo(p, a )
Page 511

Mental Acts
believe(p )
disbelieve(p )
adopt(p )
unadopt(p )
Page 512

The Execution Cycle
perform(act):
pre := {p | Precondition(act,p )};
notyet := pre - {p | p ∈pre & ⊢p };
if notyet ̸= nil
then perform(snsequence(do-all({a | p ∈notyet
& a = achieve(p )}),
act))
else {effects := {p | Effect(act,p )};
if act is primitive
then apply(primitive-function(act), objects(act));
else perform(do-one({p | ActPlan(act,p )}))
believe(effects)}
Page 513

Examples
SNePSLOG demo #7
/projects/robot/Karel/ElevatorWorld/elevator.snepslog
/projects/robot/Karel/DeliveryWorld/DeliveryAgent.snepslog
/projects/robot/Karel/WumpusWorld/WWAgent.snepslog
/projects/robot/Fevahr/Ascii/afevahr.snepslog
/projects/robot/Fevahr/Java/jfevahr.snepslog
/projects/robot/Greenfoot/ElevatorWorld/sneps/elevator.snepslog
/projects/robot/Greenfoot/WumpusWorld/sneps/WWAgent.snepslog
Page 514

9 Belief Revision/Truth Maintenance
9.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
9.2 Relevance Logic Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
9.3 Relevance Logic Syntax & Semantics . . . . . . . . . . . . . . . . . . . . . . . 540
9.4 Relevance Logic Proof Theory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .542
Page 515

9.1 Motivation
Floors Above and Below Ground
: xor{OnFloor(1),OnFloor(2),OnFloor(3),OnFloor(4)}.
: {OnFloor(1), OnFloor(2)} => {Location(belowGround)}.
: {OnFloor(3), OnFloor(4)} => {Location(aboveGround)}.
: perform believe(OnFloor(1))
: list-asserted-wffs
wff13!:
~OnFloor(2)
wff12!:
~OnFloor(3)
wff11!:
~OnFloor(4)
wff9!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
wff7!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
wff6!:
Location(belowGround)
wff5!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
wff1!:
OnFloor(1)
Page 516

Motivation
Disbelieving an Hypothesis
: perform disbelieve(OnFloor(1))
: list-asserted-wffs
wff9!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
wff7!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
wff5!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
Note the absence of Location(belowGround)
Page 517

Moral
If retain derived beliefs (lemmas),
need a way to delete them
when their foundations are removed.
Page 518

When Needed 1
If the KB contains beliefs about the (some) world,
and the world changes,
and the KB does not have a model of time.
I.e. the beliefs in the KB are of the form,
I believe this is true now.
Page 519

What’s needed
Links from hypotheses to propositions derived from them.
Page 520

=> vs. when(ever)do: Assertions
: Floor({1,2,3,4}).
: xor{OnFloor(1),OnFloor(2),OnFloor(3),OnFloor(4)}.
: {OnFloor(1), OnFloor(2)} => {Location(belowGround)}.
: {OnFloor(3), OnFloor(4)} => {Location(aboveGround)}.
: perform withall(f, Floor(f),
adopt(wheneverdo(OnFloor(f),
believe(HaveBeenOnFloor(f)))),
noop()).
: perform believe(OnFloor(1))
Page 521

=> vs. when(ever)do: The KB
: list-asserted-wffs
wff37!:
~OnFloor(2)
wff36!:
~OnFloor(3)
wff35!:
~OnFloor(4)
wff31!:
wheneverdo(OnFloor(4),believe(HaveBeenOnFloor(4)))
wff27!:
wheneverdo(OnFloor(3),believe(HaveBeenOnFloor(3)))
wff23!:
wheneverdo(OnFloor(2),believe(HaveBeenOnFloor(2)))
wff19!:
wheneverdo(OnFloor(1),believe(HaveBeenOnFloor(1)))
wff17!:
HaveBeenOnFloor(1)
wff16!:
Floor(1)
wff15!:
Floor(2)
wff14!:
Floor(3)
wff13!:
Floor(4)
wff10!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
wff8!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
wff7!:
Location(belowGround)
wff6!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
wff2!:
OnFloor(1)
wff1!:
Floor({4,3,2,1})
Page 522

=> vs. when(ever)do: Move Floors
: perform believe(OnFloor(4))
: list-asserted-wffs
wff39!:
~OnFloor(1)
wff37!:
~OnFloor(2)
wff36!:
~OnFloor(3)
wff31!:
wheneverdo(OnFloor(4),believe(HaveBeenOnFloor(4)))
wff29!:
HaveBeenOnFloor(4)
wff27!:
wheneverdo(OnFloor(3),believe(HaveBeenOnFloor(3)))
wff23!:
wheneverdo(OnFloor(2),believe(HaveBeenOnFloor(2)))
wff19!:
wheneverdo(OnFloor(1),believe(HaveBeenOnFloor(1)))
wff17!:
HaveBeenOnFloor(1)
wff16!:
Floor(1)
wff15!:
Floor(2)
wff14!:
Floor(3)
wff13!:
Floor(4)
wff10!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
wff9!:
Location(aboveGround)
wff8!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
wff6!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
wff5!:
OnFloor(4)
wff1!:
Floor({4,3,2,1})
HaveBeenOnFloor(1) remains; OnFloor(1) doesn’t.
Page 523

Moral
The consequents of
=>, v=>, &=>, or, nand, xor, iff, andor, thresh, and nexists
are derived and retain a connection to their underlying hypotheses.
Whatever is believe’d is a hypothesis.
Use =>, v=>, &=>, or, nand, xor, iff, andor, thresh, and nexists
for logical implications.
Use whendo(p1,believe(p2) ) or wheneverdo(p1,believe(p2) )
for decisions.
Page 524

Contingent Plans
: xor{Location(BellHall), Location(home)}.
: Location(BellHall) => ActPlan(getMail, go(MailRoom)).
: Location(home) => ActPlan(getMail, go(mailBox)).
: perform believe(Location(BellHall))
: ActPlan(getMail, ?how)?
wff5!:
ActPlan(getMail,go(MailRoom))
: perform believe(Location(home))
: ActPlan(getMail, ?how)?
wff8!:
ActPlan(getMail,go(mailBox))
Page 525

Moral
Using this design for contingent plans,
along with retention of lemmas,
depends on belief revision.
Page 526

Motivation
Sea Creatures
: all(x)(andor(0,1){Ako(x, mammal), Ako(x, fish)}).
: all(x)(LiveIn(x, water) => Ako(x, fish)).
: all(x)(BearYoung(x, live) => Ako(x, mammal)).
: LiveIn(whales, water).
: LiveIn(sharks, water).
: BearYoung(whales, live).
: BearYoung(dogs, live).
Page 527

Motivation
Are Whales Fish or Mammals?
: Ako(whales, ?x)?
A contradiction was detected within context default-defaultct
The contradiction involves the newly derived proposition:
wff8!:
Ako(whales,mammal)
and the previously existing proposition:
wff9!:
~Ako(whales,mammal)
Page 528

SNeBR Options
You have the following options:
1. [C]ontinue anyway, knowing that a contradiction is derivabl
2. [R]e-start the exact same run in a different context which
not inconsistent;
3. [D]rop the run altogether.
(please type c, r or d)
=><= r
In order to make the context consistent you must delete at leas
one hypothesis from each of the following sets of hypotheses:
(wff6 wff4 wff3 wff2 wff1)
Page 529

Possible Culprits
In order to make the context consistent you must delete
at least one hypothesis from the set listed below.
An inconsistent set of hypotheses:
1 :
wff6!:
BearYoung(whales,live)
(2 supported propositions: (wff8 wff6) )
2 :
wff4!:
LiveIn(whales,water)
(3 supported propositions: (wff10 wff9 wff4) )
3 :
wff3!:
all(x)(BearYoung(x,live) => Ako(x,mammal))
(2 supported propositions: (wff8 wff3) )
4 :
wff2!:
all(x)(LiveIn(x,water) => Ako(x,fish))
(3 supported propositions: (wff10 wff9 wff2) )
5 :
wff1!:
all(x)(nand{Ako(x,fish),Ako(x,mammal)})
(2 supported propositions: (wff9 wff1) )
Page 530

Choosing the Culprit
Enter the list number of a hypothesis to examine or
[d] to discard some hypothesis from this list,
[a] to see ALL the hypotheses in the full context,
[r] to see what you have already removed,
[q] to quit revising this set, or
[i] for instructions
(please type a number OR d, a, r, q or i)
=><= d
Enter the list number of a hypothesis to discard,
[c] to cancel this discard, or [q] to quit revising this set.
=><= 4
Page 531

Remaining Possible Culprits
The consistent set of hypotheses:
1 :
wff6!:
BearYoung(whales,live)
(2 supported propositions: (wff8 wff6) )
2 :
wff4!:
LiveIn(whales,water)
(1 supported proposition: (wff4) )
3 :
wff3!:
all(x)(BearYoung(x,live) => Ako(x,mammal))
(2 supported propositions: (wff8 wff3) )
4 :
wff1!:
all(x)(nand{Ako(x,fish),Ako(x,mammal)})
(1 supported proposition: (wff1) )
Enter the list number of a hypothesis to examine or
[d] to discard some hypothesis from this list,
[a] to see ALL the hypotheses in the full context,
[r] to see what you have already removed,
[q] to quit revising this set, or
[i] for instructions
(please type a number OR d, a, r, q or i)
=><= q
Page 532

Other Hypotheses
The following (not known to be inconsistent) set of
hypotheses was also part of the context where the
contradiction was derived:
(wff7 wff5)
Do you want to inspect or discard some of them?
=><= no
Do you want to add a new hypothesis?
no
wff11!:
~Ako(whales,fish)
wff8!:
Ako(whales,mammal)
CPU time : 0.03
Page 533

Resultant KB
: list-asserted-wffs
wff12!:
~(all(x)(LiveIn(x,water) => Ako(x,fish)))
wff11!:
~Ako(whales,fish)
wff8!:
Ako(whales,mammal)
wff7!:
BearYoung(dogs,live)
wff6!:
BearYoung(whales,live)
wff5!:
LiveIn(shakes,water)
wff4!:
LiveIn(whales,water)
wff3!:
all(x)(BearYoung(x,live) => Ako(x,mammal))
wff1!:
all(x)(nand{Ako(x,fish),Ako(x,mammal)})
Page 534

Moral
When Needed 2
If accepting information from multiple sources,
or just one possibly inconsistent source,
need a way to recognize contradictions,
and to ﬁnd the culprit,
and to delete it,
and its implications.
Page 535

What’s Needed
Links between derived propositions
and hypotheses they were derived from.
Page 536

9.2 Relevance Logic (R)
Motivation
Paradoxes of Implication 1
Anything Implies a Truth
1
A
Hyp
2
B
Hyp
3
A
Reit, 1
4
B ⇒A
⇒I, 2–3
5
A ⇒(B ⇒A)
⇒I, 1–4
But it seems that B had nothing to do with deriving A.
Page 537

Motivation of R
Paradoxes of Implication 2
A Contradiction Implies Anything
1
A ∧¬A
Hyp
2
¬B
Hyp
3
A ∧¬A
Reit, 1
4
A
∧E, 3
5
¬A
∧E, 3
6
B
¬I, 2–5
7
(A ∧¬A) ⇒B
⇒I, 1–6
But it seems that ¬B had nothing to do
with deriving the contradiction.
Page 538

What’s Needed
A way to determine when a hypothesis is really used to derive
another wﬀ.
When a hypothesis is relevant to a conclusion.
Page 539

9.3 R
Relevance Logic
The Logic of Relevant Implication
Syntax: The same as Standard FOL.
Intensional Semantics: The same as Standard FOL.
Extensional Semantics: The same as Standard FOL for terms.
For wﬀs: a four-valued logic, using True, False, Neither, and Both.
Page 540

KB Interpretations of R’s 4 Truth Values
True
true
False
false
Neither
unknown
Both
contradictory, “I’ve been told both.”
or a “true contradiction”
such as Russell’s set both is and isn’t a member of itself.
Page 541

9.4 R Proof Theory
Structural Rules of Inference
i.
A, {n}
Hyp
i.
A, α
...
j.
A, α
Rep, i
i.
A, α
...
.
.
.
...
j.
A, α
Reit, i
where n is a new integer.
Page 542

R Rules for ⇒
i.
A, {n}
Hyp
...
j.
B, α, s.t. n ∈α
k
(A ⇒B), α −{n}
⇒I, i–j
i.
A, α
...
j.
(A ⇒B), β
k.
B, α ∪β
⇒E, i, j
Page 543

How the Paradoxes of Implication are
Blocked 1
1.
A, {1}
Hyp
2.
B, {2}
Hyp
3.
A, {1}
Reit, 1
Can’t then apply ⇒I
Page 544

R Rules for ∧
i1.
A1, α
...
in.
An, α
j.
A1 ∧· · · ∧An, α
∧I, i1, . . . , in
i.
A1 ∧· · · ∧An, α
...
j.
Ak, α
∧E, i
Page 545

Why ∧I Requires the Same OS
If Not
1
A, {1}
Hyp, 2–5
2
B, {2}
Hyp, 3–5
3
A, {1}
Reit, 1
4
(A ∧B), {1, 2}
∧I?
5
A, {1, 2}
∧E, 4
6
(B ⇒A), {1}
⇒I, 2–5
7
(A ⇒(B ⇒A)), {}
⇒I, 1–6
Reconstruct paradox of implication.
Note: Empty os means a theorem.
Page 546

Extended Rule for ∧I
i1.
A1, α
...
in.
An, η
j.
A1 ∧· · · ∧An, (α ∪· · · ∪η)∗
∧I, i1, . . . , in
Can’t apply ∧E to an extended wﬀ.
Page 547

R Rules for ¬
i.
A, {n}
Hyp
...
j.
B, α s.t. n ∈α
j + 1.
¬B, α
j + 2.
¬A, α −{n}
¬I, i–(j + 1)
i.
¬A, {n}
Hyp
...
j.
B, α s.t. n ∈α
j + 1.
¬B, α
j + 2.
A, α −{n}
¬I, i–(j + 1)
i.
¬¬A, α
j.
A, α
¬E, i
Page 548

Extended R Rule for ¬I
i.
A, {n}
Hyp
...
j.
B, α
j + 1.
¬B, β
j + 2.
¬A, ((α ∪β) −{n})∗s.t. n ∈(α ∪β)
¬I, i–(j + 1)
i.
¬A, {n}
Hyp
...
j.
B, α
j + 1.
¬B, β
j + 2.
A, ((α ∪β) −{n})∗s.t. n ∈(α ∪β)
¬I, i–(j + 1)
Page 549

How the Paradoxes of Implication are
Blocked 2
1.
(A ∧¬A), {1}
Hyp
2.
¬B, {2}
Hyp
3.
(A ∧¬A), {1}
Reit, 1
4.
A, {1}
∧E, 3
5.
¬A, {1}
∧E, 3
Can’t then apply ¬I
R is a paraconsistent logic:
a contradiction does not imply anything whatsoever.
Page 550

R Rule for ∨I
i.
Ai, α
j.
A1 ∨· · · ∨Ai ∨· · · ∨An, α
∨I, i
Page 551

R Rule for ∨E
i1.
A1 ∨· · · ∨An, α
...
i2.
A1 ⇒B, β
...
i3.
An ⇒B, β
j.
B, α ∪β
∨E, i1, i2, i3
Page 552

Irrelevance of Disjunctive Syllogism
1
((A ∨B) ∧¬A), {1}
Hyp
2
¬A, {1}
∧E,1
3
(A ∨B), {1}
∧E,1
4
A, {2}
Hyp
5
¬B, {3}
Hyp
6
A, {2}
Reit, 4
7
¬A, {1}
Reit, 2
8
B
¬I, 5–7
Not valid in R
9
A ⇒B
⇒I, 4–8
10
B, {4}
Hyp
11
B, {4}
Rep, 10
12
B ⇒B, {}
⇒I, 10–11
13
B
∨E, 3,9,12
So ∨is just truth-functional.
Page 553

R Rules for Intensional OR (⊕)
i.
(¬A ⇒B), α
...
j.
(¬B ⇒A), α
j + 1.
(A ⊕B), α
⊕I, i, j
i.
(A ⊕B), α
...
j.
¬A, β
j + 1.
B, α ∪β
⊕E
i.
(A ⊕B), α
...
j.
¬B, β
j + 1.
A, α ∪β
⊕E
Page 554

R Rules for ⇔
i.
(A ⇒B), α
...
j.
(B ⇒A), α
j + 1.
(A ⇔B), α
⇔I, i, j
i.
A, α
...
j.
(A ⇔B), β
j + 1.
B, α ∪β
⇔E, i, j
i.
B, α
...
j.
(A ⇔B), β
j + 1.
A, α ∪β
⇔E, i, j
Page 555

R Rules for ∀
i.
A(a), {n}
Hyp
...
j.
B(a), α s.t. n ∈α
j + 1.
∀x(A(x) ⇒B(x)), α −{n}
∀I, i–j
i.
A(t), α
...
j.
∀x(A(x) ⇒B(x)), β
j + 1.
B(t), α ∪β
∀E, i, j
Where a is an arbitrary individual not otherwise used in the proof,
and t is free for x in B(x).
Note ∀only governs ⇒.
Page 556

R Rules for ∃
i
A(t), α
i + 1
∃xA(x), α
∃I, i
i
∃xA(x), α
...
j
A{a/x}, β
Indef I, i
...
k
B, γ s.t. β ⊂γ
k + 1
B, γ −β
∃E, j–k
Where A(x) is the result of replacing some or all occurrences of t in A(t) by x,
t is free for x in A(x);
a is an indeﬁnite individual not otherwise used in the proof,
A(a/x) is the result of replacing all occurrences of x in A(x) by a,
and there is no occurrence of a in B.
Page 557

Why the Subproof Contours?
1. To keep track of assumptions for each derived wﬀ.
But this is accomplished by os.
2. To diﬀerentiate hypotheses from derived wﬀs.
Introduce support: ⟨{hyp | der | ext}, os⟩
with origin tag and origin set.
Page 558

SNePS KB
The SNePS KB consists of a collection of supported wﬀs.
A wﬀmay have more than one support if it was derived in multiple
ways.
Every implemented rule of inference speciﬁes how the derived wﬀis
derived from its parent(s) and how its support is derived from the
support(s) of its parent(s).
Page 559

Contexts and Belief Spaces
A context is a set of hypotheses.
A belief space deﬁned by a context c is the set containing every wﬀ
whose os is a subset of c.
Page 560

SNePSLOG Example
: expert
...
: xor{OnFloor(1),OnFloor(2),OnFloor(3),OnFloor(4)}.
wff5!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
{<hyp,{wff5}>}
: {OnFloor(1), OnFloor(2)} => {Location(belowGround)}.
wff7!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
{<hyp,{wff7}>}
: {OnFloor(3), OnFloor(4)} => {Location(aboveGround)}.
wff9!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
{<hyp,{wff9}>}
Page 561

: perform believe(OnFloor(1))
: describe-context
((assertions (wff9 wff7 wff5 wff1))
(named (default-defaultct)) (kinconsistent nil))
Page 562

: list-asserted-wffs
wff13!:
~OnFloor(2)
{<der,{wff1,wff5}>}
wff12!:
~OnFloor(3)
{<der,{wff1,wff5}>}
wff11!:
~OnFloor(4)
{<der,{wff1,wff5}>}
wff9!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
{<hyp,{wff9}>}
wff7!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
{<hyp,{wff7}>}
wff6!:
Location(belowGround)
{<der,{wff1,wff7}>}
wff5!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
{<hyp,{wff5}>}
wff1!:
OnFloor(1)
{<hyp,{wff1}>}
Page 563

: perform disbelieve(OnFloor(1))
: describe-context
((assertions (wff9 wff7 wff5)) (named (default-defaultct))
(kinconsistent nil))
: list-asserted-wffs
wff9!:
{OnFloor(4),OnFloor(3)} v=> {Location(aboveGround)}
{<hyp,{wff9}>}
wff7!:
{OnFloor(2),OnFloor(1)} v=> {Location(belowGround)}
{<hyp,{wff7}>}
wff5!:
xor{OnFloor(4),OnFloor(3),OnFloor(2),OnFloor(1)}
{<hyp,{wff5}>}
Page 564

SNePSLOG Example of ¬I
wff5!:
BearYoung(whales,live)
{<hyp,{wff5}>}
wff4!:
LiveIn(whales,water)
{<hyp,{wff4}>}
wff3!:
all(x)(BearYoung(x,live) => Ako(x,mammal))
{<hyp,{wff3}>}
wff2!:
all(x)(LiveIn(x,water) => Ako(x,fish))
{<hyp,{wff2}>}
wff1!:
all(x)(nand{Ako(x,fish),Ako(x,mammal)})
{<hyp,{wff1}>}
Page 565

: Ako(whales, ?x)?
A contradiction was detected within context default-defaultct.
The contradiction involves the newly derived proposition:
wff8!:
Ako(whales,mammal)
{<der,{wff3,wff5}>}
and the previously existing proposition:
wff9!:
~Ako(whales,mammal)
{<der,{wff1,wff2,wff4}>}
...
In order to make the context consistent you must delete at least
one hypothesis from each of the following sets of hypotheses:
(wff5 wff4 wff3 wff2 wff1)
Page 566

The Culprit Set
1 :
wff5!:
BearYoung(whales,live)
{<hyp,{wff5}>}
(2 supported propositions: (wff8 wff5) )
2 :
wff4!:
LiveIn(whales,water)
{<hyp,{wff4}>}
(3 supported propositions: (wff9 wff7 wff4) )
3 :
wff3!:
all(x)(BearYoung(x,live) => Ako(x,mammal)) {<hyp,{wff3}
(2 supported propositions: (wff8 wff3) )
4 :
wff2!:
all(x)(LiveIn(x,water) => Ako(x,fish)) {<hyp,{wff2}>}
(3 supported propositions: (wff9 wff7 wff2) )
5 :
wff1!:
all(x)(nand{Ako(x,fish),Ako(x,mammal)})
{<hyp,{wff1}>}
(2 supported propositions: (wff9 wff1) )
Page 567

KB after deleting wff2
wff10!:
~(all(x)(LiveIn(x,water) => Ako(x,fish)))
{<ext,{wff1,wff3,wff4,wff5}>}
wff8!:
Ako(whales,mammal)
{<der,{wff3,wff5}>}
wff7!:
~Ako(whales,fish)
{<der,{wff1,wff3,wff5}>}
wff5!:
BearYoung(whales,live)
{<hyp,{wff5}>}
wff4!:
LiveIn(whales,water)
{<hyp,{wff4}>}
wff3!:
all(x)(BearYoung(x,live) => Ako(x,mammal))
{<hyp,{wff3}>}
wff1!:
all(x)(nand{Ako(x,fish),Ako(x,mammal)})
{<hyp,{wff1}>}
Page 568

10 The Situation Calculus
Page 569

Motivation (McCarthy)
I’m in my study at home. My car is in the garage. I want to get to
the airport. How do I decide that I should walk to the garage and
drive to the airport, rather than vice versa?
A commonsense planning problem.
Page 570

Solution Sketch
My study and garage are in my home.
To get from one place to another in my home, I should walk.
My garage and the airport are in the county.
To get from one place to another in the county, I should drive.
Page 571

Situations
When an agent acts, some propositions change as a result of acting,
and some are independent of acting.
E.g. the fact that the airport is in the county is independent of my
acting, but whether I’m in my study, in the garage, or at the
airport, changes when I act.
We say that an act takes us from one situation to another.
Propositions that are dependent on situations are called
propositional ﬂuents. E.g. At(study, S0), At(garage, S1)
vs. In(study, home), In (airport, county)
Page 572

Situational Fluents
We can view an act as something that’s done in some situation,
and takes us to another situation.
Let do(a, s) be a two-argument functional term.
[[do(a, s)]] = the situation that results from doing the act [[a]] in the
situation [[s]].
So, At(study, S0), At(garage, do(walk(study, garage), S0))
Page 573

Planning in the Situational Calculus
Describe the situation S0.
Give domain rules describing the eﬀects of actions.
Find a solution for At(airport, ?s)
Page 574

Formalization in SNARK
Non-Fluent Propositions
(assert ’(Walkable home))
(assert ’(Drivable county))
(assert ’(In study home))
(assert ’(In garage home))
(assert ’(In garage county))
(assert ’(In airport county))
Page 575

Eﬀect Axioms
(assert ’(all (x y z s)
(=> (and (At x s) (In x z) (In y z)
(Walkable z))
(At y (do (walk x y) s)))))
(assert ’(all (x y z s)
(=> (and (At x s) (In x z) (In y z)
(Drivable z))
(At y (do (drive x y) s)))))
Initial Situation
(assert ’(At study S0))
Page 576

SNARK Solves the Problem
(query "How do you go to the airport?"
’(At airport ?s)
:answer ’(By doing ?s))
How do you go to the airport?
(ask ’(At airport ?s))
= (At airport (do (drive garage airport)
(do (walk study garage) S0)))
Page 577

Example 2: BlocksWorld
Domain Axioms
(assert ’(all s (Clear Table s)))
(assert ’(all (x y s) (=> (and (Block y) (On x y s))
(not (Clear y s)))))
(assert ’(all (x s) (=> (Held x s)
(not (Clear x s)))))
Page 578

BlocksWorld Eﬀect Axioms
(assert
’(all (x y s) (=> (and (On x y s) (Clear x s))
(and (Held x (do (pickUp x) s))
(Clear y (do (pickUp x) s))))))
(assert
’(all (x y s) (=> (and (Held x s) (Clear y s))
(and (On x y (do (putOn x y) s))
(not (Held x (do (putOn x y) s)))
(Clear x (do (putOn x y) s))))))
Page 579

Initial Situation
(assert ’(Block A))
(assert ’(Block B))
(assert ’(Block C))
(assert ’(On A B S0))
(assert ’(On B Table S0))
(assert ’(On C Table S0))
(assert ’(Clear A S0))
(assert ’(Clear C S0))
Page 580

Solving A Simple Problem
(query "How do you achieve holding Block A?"
’(Held A ?s)
:answer ’(By doing ?s))
How do you achieve holding Block A?
(ask ’(Held A ?s)) = (By doing (do (pickUp A) S0))
Page 581

A Harder Problem
(query "How do you put Block A on Block C"
’(On A C ?s)
:answer ’(By doing ?s))
Just loops!
Page 582

The Frame Problem
We want
(On A C (do (putOn A C) (do (pickUp A) S0)))
but this requires C to be clear in situation
(do (pickUp A) S0)
That can’t be decided.
We need to specify what propositional ﬂuents don’t change when
an action is performed.
Page 583

A Frame Axiom
(assert
’(all (x y s) (=> (and (Clear x s) (not (= x y)))
(Clear x (do (pickUp y) s)))))
Page 584

Another Problem
Still doesn’t work, because we don’t know that
(not (= C A))
Page 585

Unique Names Axioms
(assert ’(not (= A B)))
(assert ’(not (= A C)))
(assert ’(not (= B C)))
Also need
(use-paramodulation)
after (initialize)
This includes the theory of equality with resolution.
Page 586

Success!
(query "How do you put Block A on Block C" ’(On A C ?s)
:answer ’(By doing ?s))
How do you put Block A on Block C
(ask ’(On A C ?s))
= (By doing (do (putOn A C) (do (pickUp A) S0)))
Page 587

11 Summary
Artiﬁcial Intelligence (AI): A ﬁeld of computer science and
engineering concerned with the computational understanding of
what is commonly called intelligent behavior, and with the
creation of artifacts that exhibit such behavior.
Knowledge Representation and Reasoning (KR or KRR):
A subarea of Artiﬁcial Intelligence concerned with
understanding, designing, and implementing ways of
representing information in computers, and using that
information to derive new information based on it.
KR is more concerned with belief than “knowledge”. Given
that an agent (human or computer) has certain beliefs, what
else is reasonable for it to believe, and how is it reasonable for it
to act, regardless of whether those beliefs are true and justiﬁed.
Page 588

What is Logic?
• Logic is the study of correct reasoning.
• There are many systems of logic (logics). Each is speciﬁed by
specifying:
– Syntax: Specifying what counts as a well-formed expression
– Semantics: Specifying the meaning of well-formed
expressions
∗Intensional Semantics: Meaning relative to a Domain
∗Extensional Semantics: Meaning relative to a Situation
– Proof Theory: Deﬁning proof/derivation, and how it can be
extended.
Page 589

KR and Logic
Given that a Knowledge Base is represented in a language with a
well-deﬁned syntax, a well-deﬁned semantics, and that reasoning
over it is a well-deﬁned procedure, a KR system is a logic.
KR research can be seen as a search for the best logic to capture
human-level reasoning.
Page 590

Proof Theory and Semantics
Proof
Derivation
Theoremhood
Theory
A1, . . . , An ⊢P
⇔
⊢A1 ∧. . . ∧An ⇒P
⇓⇑
⇓⇑
A1, . . . , An |= P
⇔
|= A1 ∧. . . ∧An ⇒P
Semantics
Logical Implication
Validity
(⇓Soundness)
(⇑Completeness)
Page 591

Inference/Reasoning Methods
Given a KB/set of assumptions A and a query Q:
• Model Finding
– Direct: Find satisfying models of A;
see if Q is true in all of them.
– Refutation: Find if A ∪{¬Q} is unsatisﬁable.
• Natural Deduction
– Direct: Find if A ⊢Q.
• Resolution
– Direct: Find if A ⊢Q (incomplete).
– Refutation: Find if V A ∧¬Q is inconsistent.
Page 592

Logics We Studied
1. Standard Propositional Logic
2. Clause Form Propositional Logic
3. Standard Finite-Model Predicate Logic
4. Clause Form Finite-Model Predicate Logic
5. Standard First-Order Predicate Logic
6. Clause Form First-Order Predicate Logic
7. Horn Clause Logic
8. Relevance Logic
9. SNePSLOG & SNeRE
10. The Situation Calculus
11. Description Logics
Page 593

Classes of Logics
• Propositional Logic
– Finite number of atomic propositions and models.
– Model ﬁnding and resolution are decision procedures.
• Finite-Model Predicate Logic
– Finite number of terms, atomic formulae, and models.
– Reducible to propositional logic.
– Model ﬁnding and resolution are decision procedures.
• First-Order Logic
– Inﬁnite number of terms, atomic formulae, and models.
– Not reducible to propositional logic.
– There are no decision procedures.
– Resolution plus factoring is refutation complete.
Page 594

Proof Procedures We Studied
1. Direct model ﬁnding: truth tables, decreasoner,
relsat (complete search) walksat, gsat (stochastic search)
2. Wang algorithm (model-ﬁnding refutation), wang
3. Semantic tableaux (model-ﬁnding refutation)
4. Hilbert-style axiomatic (direct), brief
5. Fitch-style natural deduction (direct)
6. Resolution (refutation), prover, SNARK
7. SLD resolution (refutation), Prolog
8. SNePS (direct), SNePS
Page 595

Utility Notions and Techniques
1. Material implication
2. Possible properties of connectives
commutative, associative, idempotent
3. Possible properties of well-formed expressions
free, bound variables
open, closed, ground expressions
4. Possible semantic properties of wﬀs
contradictory, satisﬁable, contingent, valid
5. Possible properties of proof procedures
sound, consistent, complete,
decision procedure, semi-decision procedure
Page 596

More Utility Notions and Techniques
5. Substitutions
application, composition
6. Uniﬁcation
most general common instance (mgci),
most general uniﬁer (mgu)
7. Translation from standard form to clause form
Conjunctive Normal Form (CNF),
Skolem functions/constants
8. Resolution Strategies
subsumption, unit preference, set of support
9. The Answer Literal
Page 597

Yet More Utility Notions and Techniques
9. Closed vs. Open World Assumption
10. Negation by failure
11. Origin sets, contexts
12. Belief Revision/Truth-Maintenance
Page 598

Domain Modeling
1. Formalization in various logics
2. Reiﬁcation
3. Ontologies/Taxonomies/Hierarchies
• extensional vs. intensional
• instance vs. subcategory
• Single (DAGs) vs multiple inheritance
• transitive relations/transitive closure
• mutually exclusive/disjoint categories
• exhaustive set of subcategories
• partitioning of a category
Page 599

More Domain Modeling
4. Time
• subjective vs. objective
• points vs. intervals
• Allen’s relations
5. Things (Count Nouns) vs. Substances (Mass Nouns)
6. Acting
• situations
• ﬂuents
Page 600

12 Production Systems
Architecture
Working (Short-term) Memory
Contains set (unordered, no repeats) of
Working Memory Elements (WMEs).
Each being a rather ﬂat, ground (no variables) symbol structure.
Page 601

Rule (Long-term) Memory
Contains set (unordered, no repeats) of
Production Rules.
Each being a condition-action rule
of form
if condition1 . . . conditionn then action1 . . . actionm
Each condition and action being like a WME,
but allowing variables (and, maybe, other expressions)
Page 602

Rule Triggering
A rule if condition1 . . . conditionn then action1 . . . actionm
is triggered
if there is a substitution, σ
such that each conditioniσ is a WME.
A single rule can be triggered in multiple ways (by multiple
substitutions).
Page 603

Rule Firing
A rule if condition1 . . . conditionn then action1 . . . actionm
that is triggered in a substitution σ
ﬁres by performing every actioniσ.
Page 604

Production System Execution Cycle
loop
Collect T = {rσ | rσ is a triggered rule}
if T is not empty
Choose a rσ ∈T
Fire rσ
until T is empty.
Page 605

Some Typical Actions
• stop
• delete a WME
• add a WME
• modify a WME
• formatted print
Page 606

Conﬂict Resolution Strategies
Purpose: to “Choose a rσ ∈T ”
Speciﬁcity: If the conditions of one rule are a subset of a second
rule, choose the second rule. [B & L, p. 126]
Recency: Based on recency of addition or modiﬁcation of WMEs,
or on recency of a rule ﬁring. [B & L, p. 126]
Refactoriness: Don’t allow the same substitution instance of a rule
to ﬁre again. [B & L, p. 127]
Salience: Explicit salience value. “The use of salience is generally
discouraged” [http://herzberg.ca.sandia.gov/jess/docs/70/
rules.html#salience].
Page 607

The Rete Algorithm
Assumptions
Rule memory doesn’t change.
WM changes only slightly on each cycle.
WMEs are ground.
Production Systems are data-driven (use forward chaining).
Many rules share conditions.
Page 608

The Rete Network
Create a network from the conditions (Like a discrimination tree)
with rules at the leaves.
Create a token for each WME.
Pass each token through the network, stopping when it doesn’t
satisfy a test; resuming when the WME is modiﬁed.
When tokens reach a leaf, the rule is triggered.
Kinds of branch nodes
α nodes: Simple test.
β nodes: Constraints caused by diﬀerent conditions.
Page 609

13 Description Logics
Main reference:
Franz Baader, Diego Calvanese, Deborah L. McGuinness, Daniele
Nardi, and Peter F. Patel-Schneider, Eds., The Description Logic
Handbook: Theory, Implementation and Applications, Second
Edition, Cambridge University Press, Cambridge, UK, 2007.
Page 610

DL: Main Ideas
• Terminological Box or T-Box.
Deﬁnition of Concepts (“Classes”) and Roles (“Properties”).
• Assertional Box or A-Box.
Assertions about individuals (instances)
– Unary predicates = concepts
– Binary predicates = roles
• Necessary and Suﬃcient conditions on classes.
• Subsumption Hierarchy
Page 611

Syntax of a Simple DLa
Atomic Symbols
• Positive integers: 1, 2, 3
• Atomic concepts: Thing, Pizza, PizzaTopping, PizzaBase
Thing is the top of the hierarchy.
• Roles: hasTopping, hasBase
• Constants: item1, item2
Page 612
aFrom Ronald J. Brachman & Hector J. Levesque, Knowledge Representation
and Reasoning, Morgan Kaufmann/Elsevier, 2004, Chapter 9, with examples
from Matthew Horridge, Simon Jupp, Georgina Moulton, Alan Rector, Robert
Stevens, & Chris Wroe, A Practical Guide To Building OWL Ontologies Using
Prot´eg´e 4 and CO-ODE Tools: Edition 1.1, The University of Manchester, 2007.

Syntax of a Simple DL
Concepts
• Every atomic concept is a concept
• If r is a role and d is a concept, [ALL r d] is a concept.
The concept of individuals all of whose r’s are d’s.
E.g., [ALL hasTopping VegetarianTopping]
• If r is a role and n is a positive integer, [EXISTS n r] is a concept.
The concept of individuals that have at least n r’s.
E.g., [EXISTS 1 hasTopping]
• If r is a role and c is a constant, [FILLS r c] is a concept.
The concept of individuals one of whose r’s is c.
E.g., [FILLS hasTopping item2]
• If d1, . . . , dn are concepts, [AND d1, . . . , dn] is a concept
The concept that is the intersection of d1, . . . , dn.
E.g., [AND Pizza [EXISTS 1 hasTopping]
[ALL hasTopping VegetarianTopping]]
Page 613

Syntax of a Simple DL
Sentences
• If d1 and d2 are concepts, (d1 ⊑d2) is a sentence.
d1 is subsumed by d2
E.g., VegetarianPizza ⊑Pizza
• If d1 and d2 are concepts, (d1 .= d2) is a sentence.
d1 and d2 are equivalent
E.g., VegetarianPizza .= [AND Pizza [EXISTS 1 hasTopping]
[ALL hasTopping VegetarianTopping]]
• If c is a constant and d is a concept, (c →d) is a sentence.
The individual c satisﬁes the description expressed by d.
E.g., item1 →Pizza
Page 614

Necessary and Suﬃcient Conditions
A necessary condition on a class, d, is a property, p, such that if
an individual, c, is an instance of d, it is necessary that c satisfy p.
A suﬃcient condition on a class, d, is a property, p, such that if
an individual, c, satisﬁes p, then that is a suﬃcient reason to
decide that it is an instance of d.
A deﬁned concept has both necessary and suﬃcient conditions.
A primitive concept has only necessary conditions.
Page 615

Subsumption Hierarchy
(d1 ⊑d2)
d1 is subsumed by d2
E.g., VegetarianPizza ⊑Pizza
means that every instance of d1 is an instance of d2.
Every DL concept is subsumed by Thing, the top of the hierarchy.
Page 616

Classiﬁcation Algorithm
Decision procedure for placing every deﬁned concept correctly in
the subsumption hierarchy.
Note: Two concepts that subsume each other are the same.
Note: No concept can be computed as being subsumed by a
primitive concept.
Page 617

Examples Using Classic
Deﬁned and Primitive Concepts
: (cl-startup)
t
: (cl-define-concept ’PizzaTopping ’Classic-Thing)
*WARNING*: The new concept PizzaTopping is identical
to the existing concept @c{Classic-Thing}.
@c{Classic-Thing}
: (cl-define-primitive-concept ’PizzaBase ’Classic-Thing)
@c{PizzaBase}
Page 618

Creating An Individual
: (cl-create-ind ’base1 ’PizzaBase)
@i{base1}
: (cl-instance? @base1 @PizzaBase)
t
: (cl-print-ind @base1)
Base1 ->
Derived Information:
Primitive ancestors: PizzaBase Classic-Thing
Parents: PizzaBase
Ancestors: Thing Classic-Thing
@i{base1}
Page 619

Deﬁning Some Roles
: (cl-define-primitive-role ’hasIngredient
:inverse ’isIngredientOf)
@r{hasIngredient}
: (cl-define-primitive-role ’hasBase :parent ’hasIngredient
:inverse ’isBaseOf)
@r{hasBase}
: (cl-define-primitive-role ’hasTopping :parent ’hasIngredient
:inverse ’isToppingOf)
@r{hasTopping}
Page 620

Necessary and Suﬃcient Conditions
: (cl-define-concept ’Pizza ’(and Classic-Thing (at-least 1 hasBase)
(at-least 1 hasTopping)))
@c{Pizza}
: (cl-create-ind ’pizza1 ’Pizza)
@i{pizza1}
: (cl-print-ind @pizza1)
Pizza1 ->
Derived Information:
Parents: Pizza
Ancestors: Thing Classic-Thing
Role Fillers and Restrictions:
Hasingredient[1 ; INF]
Hastopping[1 ; INF]
Hasbase[1 ; INF]
@i{pizza1}
: (cl-create-ind ’item3 ’(and (fills hasBase base3) (fills hasTopping topping3)))
@i{item3}
: (cl-print-ind @item3)
Item3 ->
Derived Information:
Parents: Pizza
Ancestors: Thing Classic-Thing
Role Fillers and Restrictions:
Hasingredient[2 ; INF] -> Base3 Topping3
Hastopping[1 ; INF] -> Topping3
Hasbase[1 ; INF] -> Base3
@i{item3}
Page 621

Classiﬁcation
: (cl-define-concept ’PreparedFood ’(and Classic-Thing (at-least 1 hasIngredient)))
@c{PreparedFood}
: (cl-print-concept @PreparedFood)
PreparedFood ->
Derived Information:
Parents: Classic-Thing
Ancestors: Thing
Children: Pizza
Role Restrictions:
Hasingredient[1 ; INF]
@c{PreparedFood}
: (cl-print-concept @Pizza)
Pizza ->
Derived Information:
Parents: PreparedFood
Ancestors: Thing Classic-Thing
Role Restrictions:
Hasingredient[1 ; INF]
Hastopping[1 ; INF]
Hasbase[1 ; INF]
@c{Pizza}
: (cl-instance? @pizza1 @PreparedFood)
t
Page 622

Disjoint Concepts
: (cl-startup)
t
: (cl-define-primitive-concept ’PizzaTopping ’Classic-Thing)
@c{PizzaTopping}
: (cl-define-disjoint-primitive-concept ’CheeseTopping ’PizzaTopping ’pizzaToppings)
@c{CheeseTopping}
: (cl-define-disjoint-primitive-concept ’MeatTopping ’PizzaTopping ’pizzaToppings)
@c{MeatTopping}
: (cl-define-disjoint-primitive-concept ’SeafoodTopping ’PizzaTopping ’pizzaToppings)
@c{SeafoodTopping}
: (cl-define-disjoint-primitive-concept ’VegetableTopping ’PizzaTopping ’pizzaToppings)
@c{VegetableTopping}
classic(56): (cl-define-primitive-concept ’ProbeInconsistentTopping
’(and CheeseTopping VegetableTopping))
*WARNING*: Disjoint primitives: @tc{CheeseTopping}, @tc{VegetableTopping}.
*CLASSIC ERROR* while processing
(cl-define-primitive-concept ProbeInconsistentTopping (and CheeseTopping
VegetableTopping))
occurred on object @c{ProbeInconsistentTopping-*INCOHERENT*}:
Trying to combine disjoint primitives: @tc{CheeseTopping} and
@tc{VegetableTopping}.
classic-error
(disjoint-prims-conflict @tc{CheeseTopping} @tc{VegetableTopping})
nil
@c{ProbeInconsistentTopping-*INCOHERENT*}
Page 623

Open World
: (cl-define-primitive-concept ’MushroomTopping ’VegetableTopping)
@c{MushroomTopping}
: (cl-define-primitive-concept ’OnionTopping ’VegetableTopping)
@c{OnionTopping}
: (cl-define-concept ’VegetarianPizza ’(and Pizza (all hasTopping VegetableTopping)))
@c{VegetarianPizza}
: (cl-create-ind ’mt1 ’MushroomTopping)
@i{mt1}
: (cl-create-ind ’ot1 ’OnionTopping)
@i{ot1}
: (cl-create-ind ’pizza2 ’(and Pizza (fills hasTopping mt1) (fills hasTopping ot1)))
@i{pizza2}
: (cl-instance? @pizza2 @VegetarianPizza)
nil
: (cl-ind-close-role @pizza2 @hasTopping)
@i{pizza2}
: (cl-instance? @pizza2 @VegetarianPizza)
t
Page 624

Typology of DL Languages
Construct
Syntax
Language
Concept
A
Role name
R
FL0
Intersection
C∩D
Value Restriction
∀R.C
FL−
Limited existential quantiﬁcation
∃R.⊤
AL
Top or Universal
⊤
S
Bottom
⊥
Atomic negation
¬A
Negation
¬C
C
Union
C ∪D
U
Existential restriction
∃R.C
E
Language S = ALCR+ = ALC plus transitive roles.
From A. G`omez-P`erez, M. Fern`andez-L`opez & O. Corcho, Ontological Engineering, Springer-Verlag,
London, 2004, Table 1.1, p. 17.
Page 625

Typology, continued
Construct
Syntax
Language
Number restrictions
(≥n R) (≤n R)
N
Nominals
{a1 . . . an}
O
Role hierarchy
R ⊆S
H
Inverse role
R′
I
Qualiﬁed number restriction
(≥n R.C) (≤n R.C)
Q
Key to abbreviations under “Syntax”:
A: atomic concept
C, D: concept deﬁnitions
R: atomic role
S: role deﬁnition
From A. G`omez-P`erez, M. Fern`andez-L`opez & O. Corcho, Ontological Engineering, Springer-Verlag,
London, 2004, Table 1.1, p. 17.
Page 626

14 Abduction
Abduction is the non-sound inference
from
P ⇒Q
and Q
to
P
See Brachman & Levesque, Chapter 13.
Page 627

Some Uses of Abduction
1. Explanation
from It′s raining ⇒The grass is wet
and The grass is wet to It′s raining
2. Diagnosis
from Infection ⇒Fever
and Fever to Infection
3. Plan Recognition
from Cooking pasta ⇒Boil water
and Boil water to Cooking pasta
4. Text Understanding
from ∀x(gotGoodService(x) ⇒leftBigTip(x))
and Betty left a big tip. to Betty got good service.
Page 628

Prime Implicates
Applies to KRR using resolution.
For some KB and some clause C, if
KB |= C
and for any C′ s.t. C′ is a proper subset of C
KB ̸|= C′
C is a prime implicate of KB.
Page 629

Example of Computing Prime Implicate
prover(4): (prove ’( (=> (and p q r) g)
(=> (and (not p) q) g)
(=> (and (not q) r) g))
’g)
1
(p (not q) g)
Assumption
2
(q (not r) g)
Assumption
3
((not p) (not q) (not r) g)
Assumption
4
((not g))
From Query
5
(p (not q))
R,4,1,{}
6
(q (not r))
R,4,2,{} Subsumed
7
((not p) (not q) (not r)) R,4,3,{} Subsumed
8
((not r) p)
R,5,6,{} Subsumed
11
((not q) (not r))
R,7,8,{} Subsumed
12
((not r))
R,11,6,{}
Example from Brachman & Levesque, p 271.
Page 630

Example 2
prover(8): (prove ’((forall x (=> (enterRestaurant x) (beSeated x)))
(forall x (=> (beSeated x) (beServed x)))
(forall x (=> (beServed x) (getFood x)))
(forall x (=> (getFood x) (eatFood x)))
(forall x (=> (eatFood x) (and (pay x) (leaveTip x))))
(forall x (=> (gotGoodService x) (leftBigTip x)))
(enterRestaurant Betty))
’(leftBigTip Betty))
1
((enterRestaurant Betty)) Assumption
2
((not (enterRestaurant ?1)) (beSeated ?1))
Assumption
3
((not (beSeated ?3)) (beServed ?3)) Assumption
4
((not (beServed ?5)) (getFood ?5))
Assumption
5
((not (getFood ?7)) (eatFood ?7)) Assumption
6
((not (eatFood ?9)) (pay ?9)) Assumption
7
((not (eatFood ?10)) (leaveTip ?10))
Assumption
8
((not (gotGoodService ?12)) (leftBigTip ?12)) Assumption
9
((not (leftBigTip Betty)) (Answer (leftBigTip Betty)))
From Query
10
((not (gotGoodService Betty))
(Answer (leftBigTip Betty)))
R,9,8,{Betty/?12}
nil
I.e., (=> (gotGoodService Betty) (leftBigTip Betty))
Page 631

Interpretation
Possible interpretations of
(=> (gotGoodService Betty) (leftBigTip Betty)):
1. Abduction: Since (leftBigTip Betty),
infer (gotGoodService Betty).
2. Diagnosis: Since (not (leftBigTip Betty)),
infer (not (gotGoodService Betty)).
3. Hypothetical Answer: If (gotGoodService Betty)
then (leftBigTip Betty).
4. Why Not: Didn’t infer (leftBigTip Betty)
because didn’t know (gotGoodService Betty).
Page 632

