The Quaternion Bingham Distribution,
Detection, and Dynamic Manipulation
by
Jared Marshall Glover
Submitted to the Department of Electrical Engineering and Computer
Science
in partial fulfillment of the requirements for the degree of
Doctor of Philosophy
at the
MASSACHUSETTS INSTITUTE OF TECHNOLOGY
OF TECHNOLO0GY
JUN 10 2014
K -BRARIES
June 2014
@ Massachusetts Institute of Technology 2014. All rights reserved.
Signature redacted
Aiuthor
Department of Electrical Engineering and
Certified by.......
C
Signature redacted
omputer Science
May 21, 2014
Leslie Pack Kaelbling
Professor
Certified by..... Signature redacted Thesis Supervisor
..................
/ Jo 
mis Lozano-Pe~rez
Professor
Thesis Supervisor
Accepted by............ Signature redacted
Prof Ui Leslie A. Kolodziej ski
Chair of the Committee on Graduate Students
Aut.o.
3D Object

The Quaternion Bingham Distribution, 3D Object
Detection, and Dynamic Manipulation
by
Jared Marshall Glover
Submitted to the Department of Electrical Engineering and Computer Science
on May 21, 2014, in partial fulfillment of the
requirements for the degree of
Doctor of Philosophy
Abstract
Over the past few years, the field of robotic computer vision has undergone a 3-D
revolution. One of the biggest challenges in dealing with 3-D geometry lies in appro-
priately handling 3-D rotational data. To specify "where" an object is in space, one
must provide both a position and an orientation for the object. Noise and ambiguity
in the robot's sensory data necessitate a robust model for representing uncertainty on
the space of 3-D orientations. This is given by the quaternion Bingham distribution-a
maximum entropy probability distribution on the 4-D unit quaternion hypersphere.
In this thesis, we apply the quaternion Bingham to two applications: 3-D object
instance detection from RGB-D images, and robot ping pong. The Bingham enables
our object detection system to achieve state-of-the-art detection rates in highly clut-
tered scenes, while also enabling the ping pong robot to track the orientation and spin
on flying ping pong balls. To enable the robot to actually play ping pong, we also
explored a new method for incorporating human advice into a robot's motor control
exploration policies.
Thesis Supervisor: Leslie Pack Kaelbling
Title: Professor
Thesis Supervisor: Tomas Lozano-Perez
Title: Professor
2

Acknowledgments
I began this journey with a change of plans. Upon arriving at Willow Garage for
an internship, my hopes for getting their PR2 robot to play ping pong were quickly
dashed when it became apparent that the robot would be too slow for the job. Then,
in swooped Gary Bradski with his idea of using 3-D local feature orientations for
object localization, and a light bulb went off. This thesis would have been written on
an entirely different subject if Gary hadn't planted that idea in my head. I owe Gary,
Radu Rusu, and Kurt Konolige my utmost thanks for their guidance and inspiration
during my time at Willow; my gratitude also goes to Baskara Marthi for recruiting
me to Willow in the first place.
Thanks also to my masters advisers, Nicholas Roy and Daniela Rus, for putting
up with me when I had no clue what I was doing -both in research and in time
management. Thanks to Mark Schnepf at Two Signia for teaching me how to be
professional and get things done.
My return to MIT would not have been possible without the support of Nick Roy.
Nick, Mike Montenerlo, Greg Armstrong, and Sebastian Thrun are responsible for
introducing me to the world of robotics way back in the Wean hall days at Carnegie
Mellon. Thanks for giving me a sip of the Kool-Aid!
My Ph.D advisers, Leslie Kaelbling and Tomas Lozano-P6rez, are two of the best
teachers and nicest human beings you will ever meet. Thank you for giving ine the
freedom to pursue my own dreams, and for teaching me to step back and see the big
picture.
Thanks to Teresa Cataldo for being the best administrator in MIT, and for drink-
ing my kale juice. Thanks to Ron Wiken for helping to install the ping-pong robot's
arm on the wall, and to Greg Esparza (from Barrett) for fixing the arm two days
before the AAAI paper deadline! My third reader, Russ Tedrake, provided many
helpful comments on the thesis draft. 
Thanks to Igor Gilitschnenski for checking
proofs. And thanks again to Leslie Kaelbling for teaching me about the relationship
between chicken pump dispensers and ping pong balls.
3

I have been fortunate to work with a number of great undergraduates over the
past four years: Aaron Fryman, Will Grathwohl, Dawit Zewdie, Jessie Zhang, Sanja
Popovic, and Charlotte Zhu have all made contributions to the work in this the-
sis. The object detection system in chapter 6 would not have been possible without
Sanja's help, and Charlotte was essential to developing the control learning methods
in chapter 7.
To my LIS labmates----Lawson Wang, Patrick Barragan, Ariel Anders, Alejandro
Perez, Sam Davies, Gustavo Goretkin, Huan Liu, George Konidaris, Chris Amato-
thanks for the many hours of thought-provoking conversation and laughter. I will
miss you all.
4

Contents
1 
Introduction
1.1 
Background . . . . . . . . . . . . . . . . . . . . . . . .
1.2 
A pplications . . . . . . . . . . . . . . . . . . . . . . . .
1.3 
Contributions . . . . . . . . . . . . . . . . . . . . . . .
1.4 
Thesis Organization. 
. . . . . . . . . . . . . . . . . . .
2 
The Bingham Distribution
2.1 
Definition and Properties . . . . . . . . . . . . . . . ..
2.2 
The Normalization Constant . . . . . . . . . . . . . ..
2.2.1 
Computing the Normalization Constant 
. . .
2.3 
Maximum Likelihood Parameter Estimation 
. . . . .
2.3.1 
Computing the Maximum Likelihood Estimates
2.4 
Bayesian Parameter Estimation . . . . . . . . . . . ..
2.5 
Characterization 
. . . . . . . . . . . . . . . . . . . .
2.6 
Sam pling . . . . . . . . . . . . . . . . . . . . . . . . .
2.7 
M ode . . .
. . . . . . .... 
. . . .. 
. . . . . . . . . .
2.8 
M om ents . . . . . . . . . . . . . . . . . . . . . . . . .
2.9 
E ntropy 
. . . . . . . . . . . . . . . . . . . . . . . . .
2.10 D ivergence . . . . . . . . . . . . . . . . . . . . . . . .
2.11
2.12
2.13
Product of Bingham PDFs .
Marginal Distributions 
.
.
.
Mixtures of Binghams 
. . . .
2.13.1 Parameter Estimation
5
16
17
19
19
20
22
. . . . . . . .
23
. . . . . . . .
27
. . . . . . . .
30
. . . . . . . .
32
. . . . . . . .
35
. . . . . . . .
36
. . . . . . . . .
37
. . . . . . . . .
37
. . . . . . . . .
38
. . . . . . . . .
38
. . . . . . . . .
41
. . . . . . . . .
42
. . . . . . . . .
43
. . . . . . . . .
44
. . . . . . . . .
45
. . . . . . . . . . . . . .
4 5

2.13.2 Approximating a Mixture by a Single Bingham 
. . . . . . . .
2.14 Historical Remarks and Contributions . . . . . . . . . . . . . . . . . .
2.14.1 Softw are . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 The Quaternion Bingham Distribution
3.1 
Understanding the Space of 3-D Rotations ......
3.2 
Representing 3-D Rotations as Unit
Q uaternions . . . . . . . . . . . . . . . . . . . . . .
3.3 
Using the Bingham as a Distribution on
3-D Rotations . . . . . . . . . . . . . . . . . . . . .
3.3.1 
Rotation by a constant quaternion 
. . . . .
3.3.2 
Quaternion inversion . . . . . . . . . . . . .
3.3.3 
Composition of quaternion Binghams . . . .
3.3.4 
Estimating the error of approximation 
. . .
3.4 
A Preview of Quaternion Bingham Results in Later
46
46
47
48
48
51
. . . . . . . . . .
52
. . . . . . . . . .
53
. . . . . . . . . .
53
. . . . . . . . . .
53
. . . . . . . . . .
55
Chapters . . . . .
56
4 Tracking 3-D Rotations with the Quaternion Bingham Filter
4.1 
Discrete-time quaternion Bingham process . . . . . . . . . . . .
4.2 
Discrete quaternion Bingham filter . . . . . . . . . . . . . . . .
4.2.1 
Extensions . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 
Experimental Results . . . . . . . . . . . . . . . . . . . . . . . .
4.4 
C onclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5 
A Generative Method for 3-D Object
5.1 
Introduction . . . . . . . . . . . . . .
5.1.1 
O utline 
. . . . . . . . . . . .
5.2 
Monte Carlo Pose Estimation . . . .
5.2.1 
Problem Statement . . . . . .
5.2.2 
MC-SOPE Algorithm . . . . .
5.2.3 
MC-SCOPE Algorithm . . . .
5.3 
Local Feature Distributions 
. . . . .
Detection
6
58
58
60
62
63
71
73
. . . . .
74
. . . . .
75
. . . . .
75
. . . . .
76
. . . . .
78
. . . . .
78
. . . . .
78

5.3.1 
Oriented Local Features 
. . . . . . . . . . . . . . . . . . . . .
81
5.3.2 
Local Feature Likelihood . . . . . . . . . . . . . . . . . . . . .
82
5.3.3 
Multi-Feature Likelihood . . . . . . . . . . . . . . . . . . . . .
84
5.3.4 
Bingham Mixture Models (BMMs) 
. . . . . . . . . . . . . . .
84
5.3.5 
BMM Parameter Estimation via Sample Consensus . . . . . .
86
5.4 
Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
5.5 
R elated W ork . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
5.6 
C onclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
6 A Discriminative Method for 3-D Object Detection 
93
6.1 
A lignm ent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
6.1.1 
Background . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
6.2 
Bingham Procrustean Alignment 
. . . . . . . . . . . . . . . . . . . .
98
6.2.1 
Incorporating Orientation Measurements . . . . . . . . . . . .
102
6.2.2 
Estimating the Uncertainty on Feature Orientations . . . . . .
102
6.2.3 
The Alignment Algorithm . . . . . . . . . . . . . . . . . . . .
103
6.3 
A New Characterization of the Quaternion Bingham Distribution 
. .
104
6.4 
Building Noise-Aware 3-D Object Models . . . . . . . . . . . . . . . .
108
6.5 
Learning Discriminative Feature Models for Detection . . . . . . . . .
110
6.6 
Detecting Single Objects in Clutter . . . . . . . . . . . . . . . . . . .
111
6.7 
Detecting Multiple Objects in Clutter . . . . . . . . . . . . . . . . . .
114
6.8 
Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
6.8.1 
BPA vs. ICP 
. . . . . . . . . . . . . . . . . . . . . . . . . . .
117
6.9 
R elated W ork . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
6.10 Conclusion and Future Work . . . . . . . . . . . . . . . . . . . . . . .
119
7 Dynamic Manipulation: Teaching a Robot to Play Ping Pong 
120
7.1 
Policy Search for Dynamic Skill Improvement 
. . . . . . . . . . . . .
121
7.1.1 
Representing the policy: explicit vs. implicit . . . . . . . . . .
122
7.2 
Gaussian Process Bandit Optimization . . . . . . . . . . . . . . . . .
123
7.3 
G iving A dvice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
7

7.3.1 
Policy gradient advice 
. . . . . . . . . . . . . . . . . . . . . .
127
7.3.2 
Exploration Bias with Directional Advice (EBDA) . . . . . . .
128
7.4 
Robot Ping Pong . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
7.5 
Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
7.6 
Conclusion. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
139
8 Conclusion 
140
8.1 
Food for Thought . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
141
8.2 
Beyond Ping Pong 
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
143
8

List of Figures
2-1 
The Bingham distribution (in 2-D) is formed by taking a zero-mean
Gaussian distribution (with equiprobable ellipses shown in (a) and (b))
in R2 and intersecting it with the unit circle, 51. The resulting Binghan
distribution (whose PDF is represented by the intensity of pixels on
the circle in (b) and (c)) has non-zero probability density only on the
surface of S'. It is also antipodally symmetric (i.e., x and -x have the
same probability density), since the original Gaussian was centered on
the origin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
2-2 
The same Bingham distribution on S' resulting from three Gaussians
on R2 of different scales. . . . . . . . . . . . . . . . . . . . . . . . . .
24
2-3 
A Bingham distribution on S2, with concentration parameters A =
-41.7 and A2 = -2.6. 
Shown are the mode, p, and the two orthogonal
direction vectors, vi and 
. .
. .
. . .
. . .
. . . .
. .
. . . . . . . .
25
2-4 
The progression of A2 towards zero. 
. . . . . . . . . . . . . . . . . .
26
2-5 
More examples of 3-D Binghams. 
. . . . . . . . . . . . . . . . . . . .
27
3-1 ............ 
....................................... 
50
4-1 
Process and graphical models for the discrete quaternion Bingham pro-
cess. ........... 
.................................... 
59
9

4-2 
Two simulated runs with the quaternion Bingham filter-(b) and (c)
are different plots of the same simulation. In all figures, the thick black
line is the true process signal, generated with isotropic process noise
Ap = (-400, -400, -400). 
The thin blue lines in (a) and (b) are the
observation signal, and the thick red line is the filtered output. Rows 1-
4 in each figure show the 4 quaternion dimensions (q), qX, qy, qz). Row
5 in (a) and (b) shows the error between filter output and true state
(thick red line), together with the QBF sample error 90% confidence
bounds (thin red line). Marginal sample 90% confidence bounds are
also shown in the thin red lines in (c). 
. . . . . . . . . . . . . . . . .
64
4-3 
Example image sequences from the spinning ping-pong ball dataset.
In addition to lighting variations and low image resolution, high spin
rates make this dataset extremely challenging for orientation tracking
algorithms. Also, because the cameras were facing top-down towards
the table, tracking side-spin relies on correctly estimating the orien-
tation of the elliptical marking in the image, and is therefore much
harder than tracking top-spin or under-spin. . . . . . . . . . . . . . .
66
4-4 
Spinning ping-pong ball tracking results. 
Top row: comparison of
QBF-2 (with and without an oracle-given prior) to QBF-1, EKF-1,
EKF-2, and random guessing (for spin classification); QBF-1 and EKF-
1 do not show up in the orientation error graph because they only
tracked spin. Note that QBF-2 quickly converges to the oracle error
and classification rates. Bottom row: QBF-2 results broken down into
top-spin/under-spin vs. side-spin. As mentioned earlier, the side-spin
data is harder to track due to the chosen camera placement and ball
markings for this experiment. Note that the time axes are measured
in fram es (not seconds). 
. . . . . . . . . . . . . . . . . . . . . . . . .
68
4-5 
Simulated spinning ping-pong ball QBF-2 tracking results. . . . . . .
69
10

4-6 
Average QBF spin tracking error as it tracks the spin through the ball's
bounce on the table. Post-bounce errors are significantly lower with
the sample-based bounce tracking method (solid black line) outlined
section 4.2.1. 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
4-7 
An example ball trajectory (underspin + left-sidespin) and the state
of the QBF as it tracks the ball's orientation and spin through the
bounce. In the top row of ball images, the big red (solid-line) axis is
the mode of the QBF's orientation distribution, and the small red axes
are random samples from the orientation distribution. The big green
(dashed-line) axis is the detected ball orientation in that image. In the
bottom row, the big red (solid-line) axis is the mode of the QBF's spin
distribution, and the small red axes are random samples from the spin
distribution. The big green (dashed-line) axis is the ground truth spin,
and the black axis in the center is the identity (no-spin), for reference. 
71
5-1 
Five 3-D point clouds and their corresponding Q-Iiage transforms,
respresenting the distribution of local 3-D surface orientations on each
object (see section 5.3 for details). . . . . . . . . . . . . . . . . . . . .
75
5-2 
The Single Object Pose Estimation (SOPE) problem: given a model
and a (partial) observation (left), we wish to estimate the pose of the
object (right). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
5-3 
The Single Cluttered Object Pose Estimation (SCOPE) problem: given
a model, an observation, and a region of interest (a), we wish to esti-
mate the pose of the object (b). . . . . . . . . . . . . . . . . . . . . .
79
11

5-4 
Informative oriented local (surface patch) features. Observing just a
single patch of an object can often constrain the set of feasible object
poses to a narrow range of possibilities. In the top row, two different
patches on a wine glass are shown, along with four possible object
poses consistent with each patch. In the bottom row, a bowl feature is
shown, along with four object poses consistent with the observed patch.
Both of the the observed glass features constrain the orientation of the
glass to be aligned with the z-axis, while the bowl feature places much
weaker constraints on orientation. . . . . . . . . . . . . . . . . . . . .
80
5-5 
Cluster Q-Im ages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
82
5-6 
Given that an oriented local feature with shape type Qj has the co-
ordinate frame shown in (a), the range of possible feature positions is
restricted to lie on the dark band of the cup in (b). 
. . . . . . . . . .
85
5-7 
Fitting a Bingham Mixture Model (BMM). (a) A cluster of similar
oriented local features. (b) The local coordinate frames of the oriented
local features. (c-d) The local coordinate frames (only the axis part
of the axis-angle format is visualized), along with the fitted Binghams
(represented by the light bands on the two spheres). . . . . . . . . . .
85
5-8 
Sample error distributions (bar plots), compared to random guessing
for orientation (solid red lines). (a-c) MC-SOPE/uncluttered, (d) MC-
SCOPE/cluttered . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
5-9 
(a) Search orientation accuracy of MC-SOPE and MC-SCOPE on each
dataset. Each point, (X, Y), in the figure shows the percentage Y of
trials for which a "good" pose sample was found in the top X sam-
ples. (b) Comparison to the proposal sample distribution of SAC-IA
(orientation error thresholds are the same as in (a)). 
. . . . . . . . .
87
5-10 Top sample poses for 7 objects found by the MC-SCOPE algorithm
for a cluttered scene. When a "good" pose sample is found within the
top 20 samples, the caption under the best sample is shown in bold. .
92
12

6-1 
Object detections found with our system, along with the feature cor-
respondences that BPA used to align the model. Surface features are
indicated by red points, with lines sticking out of them to indicate
orientations (red for normals, orange for principal curvatures). Edge
features (which are orientation-less) are shown by magenta points. . .
96
6-2 
Rigid alignment of two point sets. . . . . . . . . . . . . . . . . . . . .
98
6-3 
Distance between corresponding points as a function of orientation. 
.
100
6-4 
The 18 objects in our new Clutter data set. 
. . . . . . . . . . . . . .
108
6-5 
Our noise models predict range and normal errors (standard devia-
tions) as functions of surface angle and edge distance (both with re-
spect to the viewpoint). 
. . . . . . . . . . . . . . . . . . . . . . . . .
110
6-6 
Single object detection pipeline. . . . . . . . . . . . . . . . . . . . . .
111
6-7 
Examples of objects correctly aligned by BPA with only two correspon-
dences.. . .... 
. . . . . . ... 
.. 
. . . . . . . . . . . . . . . . . . .
112
6-8 
Object detections found with our system, along with the feature cor-
respondences that BPA used to align the model. Surface features are
indicated by red points, with lines sticking out of them to indicate
orientations (red for normals, orange for principal curvatures). Edge
features (which are orientation-less) are shown by magenta points. . .
115
6-9 
The Clutter testing data set. . . . . . . . . . . . . . . . . . . . . . . .
116
6-10 Comparing BPA with ICP. (Left) The average of the mininumn position
errors in each alignment trial. (Right) The average of the minimum
orientation errors in each alignment trial. . . . . . . . . . . . . . . . .
118
7-1 
Implicit vs. explicit policies. In the smooth reward function on the left,
a good explicit policy mapping T to P can be found. In the reward
function on the right, any explicit policy mapping will be throwing
away information about alternative modes. . . . . . . . . . . . . . . .
124
13

7-2 
The robot interprets advice from a human coach as an exploration bias.
The light green shaded areas on top of the reward functions (top-down
view of figure 7-1(a)) in the left and right images indicate what the
robots believes are "good" regions to explore, and are inferred from
a series of policy gradients given by the human coach (e.g., "swing
harder" or "angle your paddle up more"). Note that the exporation
advice can either be global (left) or local (right). In our system, local
advice is the default; advice is only applied globally (for all T E T)
at the coach's discretion (e.g., by saying "always swing harder") Note
that we used a keyboard interface to communicate with the robot--- --no
human language understanding was done for this work. . . . . . . . .
127
7-3 
Our ping pong robot uses a 7-dof Barrett WAM arm with a ping pong
paddle rigidly attached at the wrist. . . . . . . . . . . . . . . . . . . .
131
7-4 
Simulation results (cumulative reward vs. learning trials) with mixture-
of-Gaussian reward functions, for task and parameter spaces of differ-
ent dim ensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
7-5 
Robot ping pong results (cumulative reward vs. learning trials) for
topspin and underspin balls. . . . . . . . . . . . . . . . . . . . . . . .
139
14

List of Tables
4.1 
Projected Gaussian process simulations. Average % mean error de-
crease for QBF over EKF. . . . . . . . . . . . . . . . . . . . . . . . .
66
5.1 
M C -SO P E . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 
M C -SC O PE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
79
6.1 
A comparison of precision and recall. . . . . . . . . . . . . . . . . . .
117
6.2 
Recall on the Clutter data set as a function of the number of scene
interpretation sam ples. . . . . . . . . . . . . . . . . . . . . . . . . . .
117
15

Chapter 1
Introduction
Robots have been the workhorses of industrial manufacturing for decades. The speed
and precision at which they can accomplish repetitive (and increasingly non-trivial)
tasks is astounding. However, if hoping to have your very own personal service robot,
you were to steal a robotic arm from a factory in Detroit or Kawasaki and take it
home with you, you would quickly find it to be quite useless. Every new task-such as
opening a pickle jar-would require days or weeks of programming (assuming you are
already an experienced robot programmer), and the slightest change in object shape,
material, or even a change in the lighting in the room could mean the difference
between finally getting to eat that elusive pickle or spending an afternoon cleaning
up broken glass and pickle juice.
This is not to say that robots haven't made impressive strides towards operation
outside the factory. Advances in robotic motion control and sensing capabilities have
led to cars that can drive themselves [60], acrobatic helicopters [1], and robots that
can walk on rough outdoor terrain [71]. However, generic manipulation capabilites
have lagged behind, despite the fact that robot hands are more precise and steady
than human hands.
This is partly due to the fact that developing skin to give robots a sense of touch
has proven very difficult'. But one might argue the biggest reason for robots' "but-
'Although rare, humans who are born without a sense of touch also find many fine manipulation
tasks difficult. Fortunately, human vision is often advanced enough to provide the necessary feedback
16

terfingers" is simply that they lack the ability to adequately perceive and understand
the physical world.
What is necessary goes beyond simply detecting "what and where" objects are in
an image; it involves understanding relationships between objects, like "on-top-of,"
"contains," and "attached." It involves estimating object attributes, like "slippery"
or "sticky." And most importantly, it involves making predictions about how the
objects will move-predictions that depend on those attributes and relationships, and
the actions the robot takes. A truly comprehensive model of the physical world (and
the ability to perceive and track its state) will significantly improve robots' ability
to manipulate objects because it will allow them to accurately predict the results of
their actions (including what might go wrong), and quickly react to disturbances.
Furthermore, such a model will form the basis for skill transfer, since actions on
similar objects are likely to have similar effects.
1.1 
Background
There are two trends that have driven much of the recent progress in robotics: the
availability of 3-D sensors, and the development of probabilistic methods.
Over the past few years, the field of robotic computer vision has undergone a 3-D
revolution. Cheap 3-D sensors like the Microsoft Kinect have shifted the focus away
from image processing and toward reasoning about the 3-D geometry of the world.
Even within the "pure" computer vision work that deals with only 2-D images, there
has been an increased focus on using 3-D geometric reasoning to explain the relative
placement of objects in an image [88, 271.
One of the biggest challenges in dealing with 3-D geometry lies in appropriately
handling 3-D rotational data. To specify "where" an object is in space, one must
provide both a position and an orientation for the object. There are many ways to
specify a 3-D orientation natheniatically: as a set of three Euler angles, as a 3x3
rotation matrix, as an axis of rotation and an angle, or as a unit quaternion, which
for most tasks.
17

combines the axis and angle into a single 4-D vector:
q = (cos(Q/2), u sin(O/2)). 
(1.1)
For topological reasons, the unit quaternion representation is often the best. Math-
ematically, q can be viewed as a point on the unit hypersphere in four dimensions,
53, with a special algebra that enables composition of rotations to be carried out
by quaternion multiplication. Because unit quaternions lie on a hypersphere, they
lack the singularites associated with Euler angles. Furthermore, they have only one
redundant parameter, while rotation matrices have six. The only potential pitfall
with unit quaternions is that they aren't unique: q and -q represent the same 3-D
rotation, since rotating by 0 about the axis u is the same as rotating by -0 about
-U.
Returning to the second trend, much of the recent success in robotics, computer
vision, and machine learning has built upon probabilistic methods like Kalman filters,
probabilistic roadmaps, and Bayes nets. Yet when work on this thesis began, there
were few tools for incorporating 3-D rotations into these probabilistic frameworks.
Many methods used local linear approximations to 3-D rotation space, which only
worked well when orientation uncertainty was very small.
Fortunately, there is a probability model --the Bingham distribution-that is per-
fectly suited to modeling uncertainty (large or small) on 3-D rotations when they
are represented as unit quaternions. The Bingham distribution is an antipodally-
symmetric probability distribution on a unit hypersphere §d in any number of dimen-
sions. It is very flexible, and can be used to represent many types of uncertainty,
from highly peaked distributions to distributions which are symmetric about some
axis, and even the uniform distribution. As we will see in chapter 2, the mathemat-
ical form of the Bingham is very similar to a Gaussian distribution, which makes it
easy to perform many types of inference. We refer to the Bingham on the space of
unit quaternions 53 as the quaternion Bingham distribution. Much of the technical
part of this thesis is devoted to exploring the quaternion Bingham distribution in
depth, although many of the tools we develop are applicable to Binghams in other
18

dimensions as well.
1.2 
Applications
The goal of this thesis is to explore tools that robots will need to robustly perform
complex manipulations. While much of the thesis is devoted to 3-D computer vision
applications using directional probability models (based on the Bingham distribu-
tion), we also spend a chapter on one specific dynamic manipulation task: robot ping
pong. By leveraging the tools we develop in chapter 2 for processing 3-D rotational
information, our robot is able to use high-speed cameras to track the spin on ping
pong balls. To get the robot to actually play ping pong, we developed a learning
system to allow the robot to learn how to hit the ball with experience. One novel
feature of the learning system is that it incorporates human advice such as "hit the
ball harder" or "angle your paddle up more" which greatly speeds up the rate at
which it learns. As a result, the robot was able to learn how to succesfully return a
variety of topspin and underspin balls at various speeds and locations on the table 
a
feat that takes many human learners months to master.
The core application of this thesis, however, is the task of object detection in clut-
tered RGB-D images. While our scope is currently limited to detecting known object
instances rather than generalizing over object types, the algorithms and theoretical
models developed in this work are foundational, and are likely to be beneficial for
more general object detection problems as well. Some of the possible extensions to
the methods in this thesis are discussed in chapter 8.
1.3 
Contributions
The main contributions of this work are:
* An open-source software library, libbinghaM, that provides tools in C and Mat-
lab for using the Bingham in practice
19

" Several formulas of use for inference with the Bingham distribution (of any
dimension), such as entropy and KL divergence
" Formulas and theoretical results for the quaternion Bingham distribution; of
particular significance is its connection to the least-squares alignment problem
" A method for alignment of oriented point sets called Bingham Procrustean
Alignment (BPA)
* An object detection system that leverages BPA to obtain state-of-the-art recog-
nition rates in cluttered RGB-D images
* A recursive filter for 3-D rotations called the Quaternion Bingham Filter (QBF)
" A visual system for tracking the orientation and spin on a ping pong ball
" An algorithm for incorporating exploration-bias advice from human domain
experts called Exploration Bias with Directional Advice (EBDA)
" A ping-pong-playing robot that learns to improve its swings with human advice
The majority of these contributions are built upon the theoretical work on the
Bingham distribution in the first chapters of this thesis. The most significant prac-
tical contribution of this thesis is likely to be the alignment algorithm, BPA-which
enables better alignment of 3-D models in cluttered scenes. The work on advice-taking
(EBDA) may also lead to important future research directions, but the experiments
on ping pong in this work are still preliminary in nature.
1.4 
Thesis Organization
We begin in chapter 2 with a tutorial on the Bingham distribution, followed by new
theoretical results and formulas for Binghams. In chapter 3 we focus on the quaternion
Bingham distribution. Chapter 4 uses these theoretical results to derive recursive
filters for 3-D orientation data based on the quaternion Bingham distribution. We
present our object detection system in chapters 5 and 6, while chapter 7 covers the
20

ping pong robot application and advice-taking. We conclude in chapter 8 with a
discussion of how the work in this thesis might be applied to other applications,
along with directions for improvement and future work. 
Background and related
work are discussed in each chapter.
21

Chapter 2
The Bingham Distribution
Many geometric quantities have a natural representation as a unit vector on a hyper-
sphere. For example, an angle can be thought of as a point on a circle, a direction
in 3-D as a point on a sphere, a 3-D rotation as a unit quaternion (which is a 4-D
unit vector on the hypersphere §3), and the "shape" (i.e. all the information that
is left when you remove position, scale, and orientation) of a sequence of N points
in 2 or 3 dimensions as a point on the hypersphere 52N-1 or 53N-1 respectively.
Since angles, rotations, and shapes are plentiful in physical systems, there is a need
to perform probabilistic inference on hyperspheres when there is uncertainty in the
system. However, many existing algorithms that reason about directional statistics
ignore the topology of hyperspheres, and instead use a Gaussian noise model in either
the embedding space (e.g., R3 for the sphere S2) or in a local, linear, tangent space
to the hypersphere. These methods work well when the errors are small, but as the
variance grows, so too does the error of the linear approximation.
Many directional quantities have a further property, called antipodal symmetry,
which means that their sign doesn't matter: x and -x represent the same object.
Lines, unit quaternions (representing 3-D orientations), and shapes all share this
property. For many directional statistics problems with this property, the Bingham
distribution turns out to be a perfect match. 
The Bingham is a member of the
exponential family, and is the maximum entropy distribution on the hypersphere
which matches the sample second moment matrix. This means that the distribution
22

(a) original Gaussian 
(b) intersection with S1 
(c) resulting Bingham
Figure 2-1: The Bingham distribution (in 2-D) is formed by taking a zero-mean
Gaussian distribution (with equiprobable ellipses shown in (a) and (b)) in R2 and
intersecting it with the unit circle, S1. The resulting Bingham distribution (whose
PDF is represented by the intensity of pixels on the circle in (b) and (c)) has non-zero
probability density only on the surface of S'. It is also antipodally symmetric (i.e., x
and -x have the same probability density), since the original Gaussian was centered
on the origin.
is flexible enough to match the second moments of any (antipodally-symmetric) set
of points on a hypersphere, while making the fewest additional assumptions about
the form of the distribution as possible.
2.1 
Definition and Properties
The Bingham distribution is an antipodally-symmetric probability distribution on
a unit hypersphere. It is derived from a zero-mean Gaussian on Rd+1, conditioned
to lie on the surface of the unit hypersphere Sd. Thus, the Bingham's probability
density function (PDF) is proportional to the PDF of a zero-mean Gaussian, but
it differs from the Gaussian in its normalization constant-the Bingham PDF must
integrate to one over the surface of the hypersphere Sd, while the Gaussian's domain
is all of Rd+1 . Figure 2-1 illustrates the origin of the Bingham distribution in 2-D. It
is important to understand that the same Bingham distribution can result from an
infinite set of original Gaussians on Rd+1 (Figure 2-2). This is because one loses a
degree of freedom in going from Rd+1 to Sd -intuitively, by scaling a Gaussian in the
23

right way, its intersection with the unit hypersphere S' can remain the same (up to
a constant multiplicative factor).
Figure 2-2: The same Bingham distribution on S' resulting from three Gaussians on
R2 of different scales.
The PDF of a Bingham distribution on Sd is
f(x; A, V) 
F(A) exp{ 
Ai 
(2.1)
i=1
-
exp{xTVAVx} 
(2.2)
F(A)
where x is a unit vector on the surface of the sphere Sd c R +1, A is a d x d diagonal
matrix of concentration parameters A1,. 
.
A 
the columns of the (d + 1) x d matrix
V are orthogonal unit vectors, and F is a normalization constant that depends only
on A. We refer to the density in equation 2.1 as the standard form for the Bingham.
Any reader who is familiar with the nultivariate Gaussian distribution will rec-
ognize the exponent of equation 2.2 as the exponent of the Gaussian in information
form, where the information (inverse covariance) matrix has been decomposed into
its eigenvector and eigenvalue matrices, V and A, and where the Bingham exponent
is missing a factor of -
which is moved into the Bingham's normalization constant.
2'
Also missing are the (d + 1)'st eigenvector and eigenvalue, Vd+1 and Ad+1. This is
because one can add a constant, c, to all of the original (d + 1) A's and obtain the
same PDF (up to a proportionality constant, which will be compensated for in the
normalization term, F):
ex T V(A+d 
xx)VAxx )XVAVX±XV( JV'T X 
exT VAV x+ x+x 
X 
TVAV'x . CE 
(2.3)
24

V2
Vi
Figure 2-3: A Bingham distribution on S2, with concentration parameters A = -41.7
and A2 = -2.6. 
Shown are the mode, p, and the two orthogonal direction vectors,
vi and v 2 -
since V is orthogonal and x is a unit vector. Therefore, by setting C 
= -Aj for any i,
one can remove one of the A's and v's without changing the distribution.
By convention, one typically subtracts off the highest-valued A and reorders the
columns of A and V so that A, < A2 < ... 
< Ad 
0. That way, all d concen-
tration parameters will have the same sign (negative or zero), making some of the
computations we will need to do easier1.
Let us now try to gain some intuition for how the parameters A and V determine
the shape of the Bingham distribution. By examining equation 2.1, it is easy to see
that the Bingham distribution achieves its highest density when x - vi = 0 for all
i 
1 . .. d. Thus, Vd+1 (the eigenvector of the original Gaussian's information matrix
that was thrown away in order to get the Bingham into standard form) is always
a mode of the Bingham distribution. Letting ft =Vd+1, the Bingham's antipodal
symmetry means that -p is also a mode. (The quadratic form of the Bingham
exponent makes it clear that f(x) = f(-x) for any x.)
Another thing we can see from equation 2.1 is that the larger (in magnitude) any
given A becomes, the higher the penalty becomes for deviations of x away from P
towards vi. This is precisely why the A's are called concentration parameters-they
'Easier still would have been to add a minus-sign to the Bingham's exponent so that all of the
concentration parameters are positive or zero, but alas, history has already spoken.
25

(a) A 
(-100, -100) 
(b) A 
(-100, -5) 
(c) A 
(-100, -2) 
(d) A 
(-100, 0)
Figure 2-4: The progression of A2 towards zero.
indicate how concentrated the distribution is along the vi axis, and are analogous to
the negative inverse of the variance (O. 2) parameters of a Gaussian distribution.
In figure 2-3, we see our first example of a Bingham distribution in 3-D (on the
sphere 52). In this example, A1 < A2 < 0, and so the distribution is more spread out
in the direction of v 2 than it is along vj.
Unlike the Gaussian distribution (which has one mode), we have already seen that
the Bingham distribution has at least two modes, M and -pt. 
In fact, the Bingham
can also have infinitely many modes! If one or more of the d Ai's in equation 2.1 is
zero, then any x E 5d in the subspace spanned by p and the vi's with Ai = 0 will also
be a mode of the distribution. As an extreme example, if all of the Ai's are zero, then
every x C 5d is equally likely, which means that the distribution is uniform. If only
some of the Ai's are zero, then the distribution will have rings of equal probability
around the hypersphere, as shown in figure 2-4. Some more examples of Binghams
on S2 are shown in figure 2-5.
This capability of the Bingham distribution to represent distributions that wrap
around hyperspheres, all the way to the uniform distribution, is one of the things that
makes the Bingham so unique and powerful as a tool for representing information
about 3-D orientations. But we'll talk more about this later.
First, we will discuss the mechanics of using the Bingham distribution of any
dimension. We will start with the basics- -computing the normalization constant,
and maximum likelihood fitting of a Bingham to a set of points on §d. Then, we will
present some results which are new to this thesis: closed-form solutions for the covari-
26

(a) Al = -43.2
A2 = -2.3
(f) At = -94.0
A2 = -0.6
(b) A1 = -49.0
A2 = -1.0
(g) 
A I = -73.6
A2 = 
1.8
Figure 2-5: M
(c) A1 = -100
A2 = 0
(h) Al = -32.8
A2 = -4.7
ore examples of
(d) A 
-20.9
A2  
-4.7
(i) 
A 
= -55.2
A2 --
1.0
3-D Binghams.
(e) A= -41.6
A2  
-3.3
(j) Al = -78.4
A2 = -3.4
ance matrix and higher moments of the Bingham, entropy and KL-divergence, and
algorithms for efficient sampling from the Bingham and for computing the product
of two or more Bingham PDFs.
2.2 
The Normalization Constant
The primary difficulty with using the Bingham distribution in practice lies in com-
puting the normalization constant, F. Since the distribution must integrate to one
over its domain (Sd), we can write the normalization constant as
I.
d
F(A) =XESd exp{ 
Ai (viTx) 2 } 
(2.4)
In general, there is no closed form for this integral, which means that F must be
solved for numerically.
In his thesis, Bingham [10] derived a series expansion for F(A) for the special case
of d = 2, and showed that the expansion is proportional to 1F1(-)-a hyper-geometric
27

function of matrix argument 2:
F(A) 
471F1( 
; ; A)
2' 2'
(2.5)
Later work [41] on the Bingham distribution makes use of a general formula for
F(A) in any dimension, which we now state as a Theorem. To our knowledge, the
proof of this general formula has never been published. Therefore, for completeness,
we derive it here.
Theorem 2.1. The normalization constant of a Bingham distribution on 5 d with
concentration parameters A is given by
F(A)
I d + I
= 
dS iFi(i; 
2+ ;A),
2 
2'
(2.6)
where |Sd| is the surface area of the hypersphere Ed.
Proof. Our proof follows the same basic pattern as Bingham's derivation of F(A) for
d = 2. First, we switch from cartesian to polar coordinates:
v 1Tx = cos 01
v 2 Tx = sin 01 cos 02
T
Vd x= sin 01
*Sin Od1 COS Od
Thus,
d
Ai (vTx) 2
i=1
= 
A1 cos 2 01 + A2 sin2 01 cos 2 02 + - - + Ads sin2 01
- - sin 2 0 d-1 cos2 Od
Next, using the famous Taylor series expansion c' 
Z,2=o 7 and grouping like terms,
d
exp{ 
Ai (vITx)2}
i=1
nj=0
00
YI 
.
d!_ . (cos 01) 2 n1
nd=O 
i 
-d
. (sin 
)2(n2+---+n± 
) ... 
(Sin 0d
1 )
2nd.
2Actually, in Bingham's original work [11] he used the convention that the probability distribution
integrate to 47r over the unit sphere, so that F(A) = IF 1 (; 
; A). However, in this thesis we will
follow the standard convention in modern probability theory that PDFs integrate to unity.
28
... 
(cos Od)
2nd

Now we can switch the integral in equation 2.6 to polar coordinates and plug in our
expansion for e_=1 Ai (vi x)2
. (sin Oa_1)dOd ... 
d01
00 
00 
ni 
nA' 
27r
--- 
J(cos0d)2ndd~d
n1 =0 
n11=0 
. -
.
d- 
0
njd-O 
'UI0
(P 
( COS 0
2 )2ni (Sin O)d-i+2(nj+1+f--l-+nd)dO j
To tackle these polar integrals, we rely on the following two identities for the Beta
B(x,y)
7r
=2 J(
/2
(sin 0)2-1 (cos 0) 2y-1d
and
B ~y) 
F(x)F(y)
F(x + y)
By the symmetry of cos 2 (.),
j *1/2
(cos Od )2 1d dOd = 4
Similarly, by the symmetry of sin(.) (and cos 2 (.)),
/2
I (cos Oi)2,,i (sin O)d-i+ 2(ni+1+--+nd)dO 
=
7r
2 J0
(cos , )2i (sin 0.)d-i+2(n+1+ -+---nd) d0
= B(ni+1+---+n + d-i+ 1
,nr 
+ 1
2
rd+ d-i±l 
1 )I7(n + ')
F(i+j+ - - + nd 
2-+1)-2
F(n +--+ 
nd + I+ 
9)
29
function:
I- 27r
0
(cos Od) 2nd d~d
1 
1
2-B(-,nd+ )
2 
2
2 -2
F(n., + 1)
7r ... 
f7r 
j27r 
Crd 
-I(Sin 
)d-2
F (A) =:: 
_ j= I A,(VTX)2 (Sin 01)d 
02
J 
0 
0
2

which yields
d-1
fo (cos 0 2 )2n2 (sin Oj)d-i+2 (ni1±+...+nd)doi
d- 1
JB(ni++...+nd 
+ 
2
i=1
(nl 
+ })2
F(ni + -
nd + d$ )
F(nd + 1)F(nd1 +2
Bnd- 
d
I?(nd + 1)F(n, + ~)..F(ndl~ + ~
F(ni±**. 
d±+ 2'
Therefore
F(A) = 
-...
ni=0 
nd=O nil ...
'nd
Ko +'TF(ni + -) -. 
-- F(nd_1 + 1)
F(ni + -+ +nd + d+)
(2.7)
Now since F(') = V/ 
and F(a + n) = F(a) - (a), where (a),, is the rising factorial
(+1 
00 
.
(2 
n 2=0 
na j= 
a
F(A)
1
2=
(I)n 
... 
(I)nd
(d2I±n1+-)+n4
(2.8)
(2.9)
d + I
2i ;A),
2'
where the infinite series expansion for 1F1 above is a special case of 1F1 (j; b; A) for
symmetric A with latent roots (eigenvalues) A1,... 
, Aj, as proved by Bingham [10].
D-
2.2.1 
Computing the Normalization Constant
Many operations on Bingham distributions require computing the normalization con-
stant. Given that we already have an infinite series representation for F(A), the
most straightforward way to calculate it is via series trunctation [11, 43]. However,
since each dimension of 5 d adds a new infinite sum to the calculation, this approach
30
1
2
F( 
u 
F(n2 + 
)
F(')F(nd +
2 
2
K

is exponential in d, and is therefore limited to low d (e.g., less than 4 or 5). 
Al-
ternative approaches to calculating the Bingham normalizing constant F(A) include
numerical integration [87], saddle-point approximations [52], and holonomic gradient
descent [77].
Since we are primarily interested in Bingham distributions on S' in this thesis,
we will use the direct (series trunctation) method. For convenience, we will calculate
1F1 (1; d+1; A) and then multiply by the surface area of Sd to get F(A). Starting from
equation 2.8,
1 d+ 1 
0 
AflA' 
-A- A 
(j 
-.
( )(210
F'( 
; 
2 
; A) 
= 
... 
E 
I 
d 
2 
( 
(2.10)
) 2ni 
=0 
nr=O 
21lI..md! 
d+1)
However, difficulty arises when we try to calculate 1F1 with equation 2.10. Since
all the A's are less than or equal to zero, this is an alternating series with slow
convergence-a computational nightmare that requires an infinite-precision math li-
brary! Fortunately, there is a series transformation3 of F(A) that makes all the A's
positive (or zero):
F( 
,A 
...
, Ad) = C AF(-MA, 
A2 - A,,. . . , Ad - A,). 
(2.11)
Denoting zi = -A, 
z 2 = A2 - A,.. ., Zd = Ad - A,
1 d±+1
F( )= eA, . ISd 
I 
- F ( ; 
; z+ . .I .... 
Z), 
(2.12)
2 
2
and so we can compute 1F1 with all non-negative arguments. Although this infinite
series converges much more quickly than the original due to all of its terms being
non-negative, for d = 3 it is still a triple infinite sum, which tends to converge very
slowly when some of the z's are large in magnitude. Therefore, for the real-time
robotics applications in this thesis, we pre-compute a lookup table of 1F,-values over
a discrete grid of A's, and use tri-linear interpolation to quickly estimate normalizing
constants on the fly. Note that this lookup table approach is only practical for small
d-in particular, we computed lookup tables in this work for d = 1, 2, 3.
3 This can be easily proved using the integral form of F(A) in equation 2.4.
31

To speed up the normalization constant table calculations, we use the following
two recursive formulas. For d = 2:
1 3 
z1 
1 
3
1 F1( 
; 
zi, z2 ) 
(1) 
IF,(-; Z + 
; z2), 
(2.13)
2'2' 
1i! 2 
21 
21(.3
and for d = 3:
1 4 
EEZiz2 
1 
1 
1ji 
4 
(.4
zF( 
; 
; Zi, z2 , z3) 
. ( 
-)(') 
1F1(1; i 
+ j + 
; z3). 
(2.14)
=1 
i!j! 22 
2 
2
That way, by first calculating an intermediate table of 1F1 (); b; z)-values which we
call the "b-table", we are able to eliminate one of the infinite sums from both the
d = 2 and d = 3 table calculations.
2.3 
Maximum Likelihood Parameter Estimation
Given a d + 1-by-N sample matrix X = [x 1 ... 
XN] containing N unit vectors in
the columns which we assume to be generated i.i.d. from a Bingham distribution
on Sd we wish to estimate the parameters (A, V) of the distribution that generated
them. There are two main ways of doing this: (i) with maximum likelihood estimation
(MLE), and (ii) with a Bayesian approach. We will first cover the maximum likelihood
method. Note that this section is adapted from Bingham [11], where we have modified
Bingham's theorems to account for the standard form conventions in this thesis (where
Ad+1 and Vd+1 are dropped).
Since we assume that x 1,... , XN are i.i.d., their joint log-likelihood under a Bing-
ham with parameters (A, V) is
N
The maximum likelihood approach to is pick the A and V that maximize L(A, V; X).
Continuing,
N
L(A, V; X) = 
(xiTVAVTxi - In F(A)) 
(2.16)
= tr[XTVAVTX] - N In F(A) 
(2.17)
= tr[AVTXXTV] - N In F(A) 
(2.18)
32

by the cyclic property of trace. Before we can derive the maximum likelihood esti-
mates for A and V, we will need the following three lemmas.
Lemma 2.2. -L(A, 
V; X) is strictly convex in A.
Proof. We will start by showing that lIn F(A) is strictly convex.
then follow because the sum of a strictly convex function with
(-tr[AVTXXi'V]) is strictly convex. The Hessian of ln F(A) with
H 
V 2 F 
(VF)(VF) T
F 
F 2
The Lemma will
a linear function
respect to A is
(2.19)
where VF is the gradient of F(A) with respect to A, and V 2 F is its matrix of second
derivatives. From the integral form of F(A) in equation 2.4, one can see that
d
OF/OA-
F
F JESd
= E[(ViTx.
(ViTX)2 exp{Z Ak (Vk 
X)2
k)1
~)2]
(2.20)
(2.21)
and
0 2 F/OAiOA
F
FE 
(ViTX)
2 (Vj
E [(ViIx)2(VjTx)2].
TX)2 exp{Z Ak (Vk T X) 2
k=1
Thus, letting y =[(V
1 Tx)2.
.(* 
X) 2]T
V 2 F 
(VF)(VF)T
H =
F 
F 2
E[yy T] - E[y]E[y] T
Cov[y]
which is positive seiidefinite by the properties of covariance matrices. Since f(x; A, V) >
0 for all x E Ed (for finite A), the random variable y can achieve any point in the
d-dimensional volume {y I Vi, yj > 0, K_ 1 y < 1}, which means that H = Cov[y]
has full rank, and is therefore positive definite. It follows that lIn F(A) is strictly
convex. 
El
33
(2.22)
(2.23)
(2.24)
(2.25)
(2.26)

Lemma 2.3 (Von Neumann's trace inequality). Given square n-by-n matrices
A and B with singular values a 1 < ... 
< an and 
- O 
-
n. Then
n
|trAB| < Z 
3i 
(2.27)
i=1
Proof. See Mirsky [62]. 
E
Lemma 2.4 (Bingham [11], Lemma 6.1). For any A = diag(A,..., Ad+l) 
with
A, < ... < kA+1, tr[AVTXXTV] is maximized (subject to the constraint that VTV =
VVT = I) by V = W = [w1 ... 
Wd+1], where wi is the eigenvector of XXT corre-
sponding to eigenvalue o-i with o-1 < - - - < Jd+1.
Proof. When V = W, tr[AWTXXTW] = tr[AW T WZ:] = tr[AE] = E+ 
Aio-. 
For
arbitrary V, tr[AVTXXTV] 
< |tr[AVT XX TV] 
Ed+ Ajo-i by von Neumann's
trace inequality, since multiplying XXT by orthogonal V and VT doesn't change its
singular values. Thus, V = W achieves a global maximum of tr[AVTXXTV], subject
to the constraint that V be orthogonal. 
D
We can now state the main theorem about the maximum likelihood estimates for
A and V.
Theorem 2.5. If the following conditions hold:
(a) V = [v 1 ... 
Vd] contains the first d eigenvectors of XXT, corresponding to eigen-
values o-r 
- - - <d 
Ord < Od+
(b) A= zdiag(A,..., Ad) satisfies
OF(A)/OAi _ o-,(228
F(A) 
N
for all i1,...,d
then A and V are maximum likelihood estimates for the parameters of the Bingham
distribution that generated the i.i.d. sample matrix X. Furthermore, A is always the
unique MLE, while V is only unique if XXT has no repeated eigenvalues.
34

Proof. Assume without loss of generality that A, < -
< Ad K 0. Then letting A' =
diag(l, ... , Ad, 0), Lemna 2.4 tells us that tr[A'V'T XX T V'] achieves its maximum
when V' is the (full) matrix of XX"'s eigenvectors, ordered by eigenvalues or < ... <
1d+1. 
Since Ad+I = 0, we can drop the last column of V' which means that the V
given in (a) maximizes tr[AV T XXT V] and therefore also maximizes L(A, V; X)
tr[AV TXX T V] - NlinF(A) with respect to V.
Necessary conditions for A can be found by setting the partial derivatives of
L(A, V; X) with respect to A to zero. From equation 2.18,
L (A, V; X)
=~ 0
ON In F(A) 
Otr[ AV T XX T V]
O~j 
OAj
UF(A)/A, 
I 
TxxT 
0i1
-- 4> 
= 
Vi XX v=-.
F(A) 
N 
N
for i = 1,... , d. By the convexity of -L(A, 
V; X)-which we proved in Lemma 2.2 -A
is the unique MLE. 
D
2.3.1 
Computing the Maximum Likelihood Estimates
The MLE V can quickly be found by computing the eigenvectors of X. But solving
equation 2.28 for A requires a bit more effort.
Just as we did for F(A), we can pre-compute values of the gradient of F with
respect to A, VF, and store them in a lookup table. Using a kD-tree, we can find the
nearest neighbors of a new sample VF/F = -[91... 
9d]T in O(d log M) time (where
Md is the size of the lookup table), and use their indices to find an initial estimate
of the MLE A via interpolation (since the lookup tables for F and VF are indexed
by A). This estimate can be further refined using gradient descent on -L(A, V; X).
35

2.4 
Bayesian Parameter Estimation
The Bayesian approach to parameter estimation for the Bingham is to compute a
posterior distribution on parameters A, V given a data set X:
p(A, VIX) oc p(XIA, V)p(A, V).
It is desirable for the prior distribution, p(A, V), to be formed such that the posterior
p(A, VIX) will belong to the same class of probability distribution, D, as the prior.
When this occurs, we say that D is a conjugate prior for the Bingham distribution.
Because the Bingham is in the exponential family, we know that a conjugate prior
exists. To find it, let's examine the data likelihood term:
p(X|A, V) = F(A)-N cr[AVTXXTV] 
-
trFAVT SVJ 
N
F(A)
where the first equation is easily derived by exponentiating both sides of equation 2.18,
and where etr(.) = et( 
is the exponential trace and S = 
XXT is the scatter matrix
of X. This suggests the following distributional form for p(A, V), which (as it is easy
to check) is a conjugate prior for the Bingham:
p(A, V; S, N) 
1 
(.tr[AV
T SV] 
N 
(2.29)
r,(S, N) 
F(A)
The distribution has two parameters-a real, symmetric, positive definite matrix S
with tr(S) = 1, and a positive real number, N. i,(S, N) is a normalization constant
to ensure that the distribution integrates to one.
Given a prior on A, V with parameters So, No, the posterior is
p(A, VIX) oc p(XIA, V)p(A, V; So, No) = p(A, V; NS 
NoSo N + No).
N + No
Thus, the prior parameters SO, NO act as a prior on the scatter matrix along with
a weight, or prior data count, No. 
A common procedure for choosing these prior
parameters is to write down the parameters AO, V of a prior Bingham distribution,
then use the formula for the second moments (scatter) matrix of a Bingham from
equation 2.33 below to find So, and then to choose how much weight (in terms of a
fictitious count No) to give the prior scatter matrix.
36

Oftentimes we are not interested in the full posterior distribution on A, V, but
only on their maximum a posteriori (MAP) values:
(A.AAp, 
YAP) = argmaxp(A,VIX),
A,V
which reduces to maximum likelihood estimation on the posterior scatter matrix S'
NS+NSo when the conjugate prior is used. (Thus, the same lookup-table approach to
computing MLE values based on the eigen-decomposition of scatter matrix may be
applied to computing MAP parameter estimates.)
2.5 
Characterization
Notice that the maximum likelihood estimates for V and A are both computed given
only the sample scatter matrix, S = XXT = Ex[xx']. Thus, the scatter matrix is
a sufficient statistic for the Bingham distribution. In fact, there is a beautiful result
from the theory of exponential families which says that the Bingham distribution is
the riaxirnum entropy distribution on the hypersphere which matches a given second
moments (scatter) matrix [58]. This gives us further theoretical justification to use
the Bingham distribution in practice, if we assume that all of the relevant information
about the data is captured in the matrix of second moments.
In chapter 3, we will see another characterization of the Bingham (for the special
case of d = 3), resulting from a deep connection between the Bingham and the
probleni of least-squares alignment of point sets.
2.6 
Sampling
Because of the complexity of the normalization constant, there is no known way
to sample directly from the Bingham (listribution. Therefore, we use a Metropolis-
Hastings sampler, with target distribution given by the Bingham density, and proposal
distribution given by the projected zero-mean Gaussian' in Rd+1 with covariance ma-
4 To sample from the projected Gaussian, we first sample from a Gaussian with covariance S,
then project the sample onto the unit sphere.
37

trix equal to the Bingham's sample scatter matrix, S. 
Empirically, the proposal
distribution is often very similar to the target distribution. Thus, the sampling dis-
tribution from the Metropolis-Hastings sampler is typically a good approximation to
the true Bingham sampling distribution after just a few iterations.
2.7 
Mode
As was discussed in section 2.1 and illustrated in figure 2-3, the unit vector A, which
is orthogonal to v 1 , .. . , Vd, is always a mode of the Bingham. However, it is not
unique. When all concentration parameters Ai are non-zero, the Bingham has two
modes: p and -p. But when one or more of the A's is zero, there are infinitely many
modes, corresponding to the subspace of unit vectors spanned by p and all the vi's
with Ai = 0.
2.8 
Moments
Due to the Bingham's antipodal symmetry, many of its moments are zero.
Theorem 2.6. All the Bingham's odd moments are zero. That is,
dI
E[fl Xa] = 0 
if any ai is odd. 
(2.30)
Proof. Given a Bingham with parameters A, V. Choose j such that aj is odd. Then
d+1
E[ 
fi] 
=a 
X aj 
X fi f(x; A, V)
i-1 
.XESd
-
X a 
X afi f (x; A, V) + 
X aj 
X ai f (x; A, V).
2- 
H 7
4JR 
i
i 
xj 
x<0 
i
Now by symmetry of Sd, each x with xj > 0 in the first integral has a counterpart x'
in the second integral with j replaced by -
y but all the other xi's unchanged, so
38

we can combine the integrals to get
d+I
E[1Fi] 
1>0 
f 
H'f(x; 
A, V) + (-xj)" flaif(x; 
A, V)
i=1 
>0 
5 
4.
(X ai + (-)a 
X a, ) 
aoi f (x; A, V)
(X iX 
a 
X a)oifxAV)
Iz >0f 
x
=0
since aj is odd. 
E
As a special case of theorem 2.6, note that the mean of the Bingham distribution,
E[x], is always zero. This makes sense, because the Gaussian distribution from
which the Bingham is derived has zero mean and is symmetric.
You might recall that the sufficient statistic for the Bingham distribution is its
matrix of second moments, E[xxT]. As with many other things Bingham, there is a
simple formula for E[xxT] in terms of V, F, and VF. But before we can derive this
formula, we will first need to understand its projected moments.
Theorem 2.7. All odd projected moments are zero for the Bingham distribu-
tion. That is, letting Vd+1 -
,
d+i
E[l(vx)"i] = 0 
if any ai is odd. 
(2.31)
i=1
Proof. As in the previous proof, we will exploit the symmetry of §d. To begin, choose
j such that aj is odd. Then
d+1
E[H(ViTX)ai] 
= 
(VjTX)a fl(viTx)ai f (x; A, V)
(v0 x)aj f(v 1 Tx)a"f(x; A, V)
+ 
' 
(Vjx)a fJ(viTx)ai f (x; A, V).
vj x4i
39

Now associate each x in the first integral (with vjTx > 0) with its reflection along
vj, x' = x -
2(vjTx)vj, which lies in the second integral because VjTx' = vjTx -
2(vj7x)vjTvj = 
-VjTx since ||vjJ| = 1. Furthermore, for i $ j, VwTx' 
-
Tx since
all the v's are orthogonal. In other words, all projections of x' onto other vi's remain
the same, while the sign gets flipped on the projection of x' onto vj. Thus,
d+1
E[f 
(ViTX)a ]
i=1
((VTX)a' + (-VjTX)a) 
J(v.Tx)ai f (x; A, V)
vjT x>O 0
since aj is odd.
ED
Theorem 2.8. The Bingham's even projected moments' are given by
1 
d 
ai F
E[fJ(VTX) 2a= 
Fr 
OA 
.a
i=1 
i=1 
i
(2.32)
Proof. This can be easily seen by writing the Bingham normalization constant in
integral form:
F(A) = -
ESd
1
d Aai
OA=1
d
expZ Ai(viTX) 2 }
1
F
d
d
(vi'X)
2a exp{Z A (ViTX)
2}
S(vi Tx)2
f(x; A, V)
d
E[ 
(ViTX)2ai].
i=1
ED
Theorem 2.9. Let E = diag( V).
given by
The Bin gham's second moments matrix is
E[xxT] = VEV T + (1- tr(E))p
T .
5excluding Vd+1 -- ft
40
Thus,
(2.33)
= 
0

Proof. Let W = [V p]. Since WWT
E[xxT] 
WWTEXXT]WWT
WE[WTxxTW]WT
by linearity of expectation. Now note that the ij-th entry of the matrix WTxx7'W is
(viTx)(vjTx) if we let Vd+1 = p. By theorem 2.7, E[(vi~x)(vjTx)] = 0 if i 7 j, which
means that E[WTxxTW] is a diagonal matrix. By theorem 2.8, E[(vix) 2
i < d, which just leaves the bottom-right corner of the matrix, E[(p Ix)
2 ]
F OA
Let y
WTx = 
1. Since WT is orthogonal, it preserves lengths. Thus, |lyll = ||xJ| = 1,
so it follows that
d
2 
2y
i=1
d
-> 
E[y2+1 ] 
E[ 
-
y 
]
-> 
E[(px)2]
d
1 - >3E[(vilx) 2]
i=1
= 1 - tr(E).
Thus, the final form of the second moments matrix is E[xxT] 
W [0 i
(2.34)
tr()] 
WT
which yields equation 2.33 when W is replaced with [V ii]. 
E
2.9 
Entropy
Theorem 2.10. The entropy of a Binyham distribution with PDF f is given by:
h(f)
logF - A - VF
F
(2.35)
h()f(
= 5 
1
JlCsg 
F
=log F - 1F
C) log f(X)
SXCX(XTCx 
-
log F)
x Cxex' Cx
IESd
41
Proof.
I,

Writing f in standard form, and denoting the hyperspherical integral fCSd 
XTCXeX T CX
by g(A),
(A) = .ECd 
viT 
2 
(vjTx) 2
d 
F
Aj 
= A -VF.
Thus, the entropy is log F - A - 7, as claimed.
Since both the normalization constant, F, and its gradient with respect to A, VF,
are stored in a lookup table, the entropy is trivial to compute, and can be used on
the fly without any numerical integration over hyperspheres.
2.10 
Divergence
The Kullback-Leibler (KL) divergence between two Binghams with PDFs f and g
(from f to g) is
DKL(f 11g) = I~sd f (x) log f(X)
xE~d 
g(x)
= h(fg) - h(f),
where h(f) is the entropy of f and h(f, g) is the cross entropy of f and g.
Theorem 2.11. The cross entropy between two Binghams with PDFs f and g
(from f to g) is
d7
h(f, g) =log Fg -> 
gib 2 +
d
j~1
-
b) 
1
1Ff
dFf
aAfj
(2.38)
where the matrix A of coefficients ai1 is given by A = VTV, 
and b =p4V (where
[if is the mode of f).
42
(2.36)
(2.37)
1:1

h(f, g) 
= 
f- 
d f (x) log g(x)
d
f(x) -(Z Agi (vgjx)
= log Fg -
AgiEj, [(vx)].
Since [T] =V] 
V and [I 
'iT] 
is orthogonal, V
[Vf pi] [ T], and so vgi
Vf ai + bifp. Thus,
Ef [(VTx)] = E[((Vf)ai + bi 
) x)2
d
yEf 
[(p)Ix)2] + 
a 2 E [(vTx) 2]
j=1
by linearity of expectation, and since all the odd projected moments are zero (theo-
rem 2.7). Then, since EJ[(pIf)"x) 2 ] =1 -
Ef[(vj x)
2] (from equation 2.34) and
Ef [(vIjx) 2] = 
1 aFf (from theorem 2.8),
Ff. , Afj 
ern
h(f, g) = log F. -
~Ag
2
b + 
+
Za~
J= 1
b2) 1dFf
0
as claimed.
2.11 
Product of Bingham PDFs
The product of two Binghain PDFs is given by adding their exponents:
-
Ad
f(x; A1, V1 )f(x; A2, 
1/) =F 1F exp {xT(Z A11viivi +
F1F2 
i=1
A2iv 2 iv 2 iT)x}
(2.39)
1= 
expi{xT(CI + C 2)x}
F1F2
After computing the sum C 
C1 + C 2 in the exponent of equation 2.39, we transform
the PDF to standard form by computing the eigenvectors and eigenvalues of C, and
then subtracting off the lowest magnitude eigenvalue from each spectral component,
43
Proof.
log Fq)

so that only the eigenvectors corresponding to the largest d eigenvalues (in magnitude)
are kept, and A, < --
Ad < 0 (as in equation 2.1). We then recompute (or look up)
the normalization constant of the new distribution as a function of the concentration
parameters.
2.12 
Marginal Distributions
In some cases, it may be useful to compute the marginal distribution of a single com-
ponent xi of a Bingham random variable x ~ Bingham(A, V). Closed-form marginals
also allow for easy computation of conditional distributions, since f(xlxi) -
f(.
The axis-aligned marginals (i.e., f(vx), or f(xi) when V's columns are taken from
the identity matrix) of a Bingham distribution have a particularly simple form.
Theorem 2.12. Given an axis-aligned Bingham distribution with PDF6 f(x; A)
1exp Zd1 Ax 2 . Then the marginal distribution of any component x of x is
F~S- 
(A 
dx 
1
f (xi) = 
ja 
111. 
d+1. 
C 
(-X d 
21 ; -;( 
-)A 
_i) 
(2.40)
| F (2' 
2 , A)
where Ai is A with Ai removed.
Proof. We will prove the theorem for f(xd+1). The other d marginals can be derived
with simple changes of indices.
f(xd+l) 
= 
d±1 
e~lx+-Add. 
(2.41)
f (X~ ) 
F (A) i 
+-...+x2=-1- 
A 
.+dd 
(.1
Now let yj = 
'_X for i 
1 . . . d. Then y+. 
.+y2 = 1, so y e Sd-1 
Furthermore,
d+1d
XZ 
(1 -
xd+ 1)y 
and dxi 
1 - xig dyi. Thus,
A 2
f (xd+1) 
-
(±1- 
) /2 
1(1-X)y2+-- 
-+Ad(1- 
1)y2 
(2.42)
(Xd~l) 
F(A) 
iyEd-1 
d 
1d 
d(.2
eAd+_ 
S1 
-
2 
2 
j/
S| 
1 
d- 
-ld1 )d/2 
-S-F1( 
1 d (1 -- x2l)A-(d+l)). 
(2.43)
§FdjiF 1Q1; d+1 -A) 
2' 2' 
d
'3The (d + 1)'st terni in the exponent is included-even though Ad+ 1 = 0--in order to avoid a
separate case for the marginal f(xd±1).
44

The general case of non-axis-aligned muarginals is more difficult, because the in-
tegral in equation 2.41 becomes a normalization constant of a Binghaum-von Mises-
Fisher distribution rather than a Bingham distribution. The Binghan-von Mises-
Fisher is a hyperspherical distribution derived from a Gaussian distribution with any
mean, ti; it's PDF is
f (x; C, A) 
1 
e(x-W
T (x-P) 
(2.44)
z(C, A)
Infinite-series expansions are available for the normalization constant, z(C, ii), but
they have twice as many infinite sums as the normalization constant expansions for
the Bingham distribution.
2.13 
Mixtures of Binghams
For many applications, such as texture analysis in material science [67], the directional
random variables of interest may be best respresented by a mixture of Bingham
distributions, rather than a single Bingham.
The PDF of a Binghar mixture is given by
k
f (x; A, V, a) = 
aif(x; A., V1) 
(2.45)
i=1
where the Ai's and 
i's are component Bingham parameters and the ai's are non-
negative weights that sum to one.
2.13.1 
Parameter Estimation
There is no closed-form solution to the maximum likelihood parameter estimates
for a Bingham mixture distribution, but a modified expectation maximization (EM)
algorithm (with a minimum message length criterion to determine the number of
components) has been used with success for texture analysis [67]. Fast (non-iterative)
heuristic approaches to fitting Bingham mixtures have also been developed [31].
45

2.13.2 
Approximating a Mixture by a Single Bingham
Given a random variable X which is drawn from a mixture of two Binghams, with
PDF f(X) = afi(X) + (1 - a)f 2 (X). Under certain circumstances, one may wish to
approximate f by a single Bingham with PDF g. To do this, consider what happens
when we fit a Bingham distribution to N samples drawn from the mixture model, f,
as N -p o. 
Recall that with maximum likelihood parameter estimation (section 2.3),
the sufficient statistic is the sample scatter matrix, S = I ZI xixiT, which goes to
the true scatter matrix, S = E[xxT], as N -a oc. 
Thus, we simply need to fit g to
f's scatter matrix,
Sf = aEi[xx T] + (1 - a)E2[xxT]. 
(2.46)
The component scatter matrices E1 [xxT] and E2 [xxT] can be computed with equa-
tion 2.33. The Bingham distribution which fits this matrix of second moments is the
maximum likelihood fit of a single Bingham to a mixture of two Binghams. (For the
information-theoretically inclined, this approach is equivalent to the variational ap-
proach, where g is found by minimizing the KL divergence from f to g, DKL(J 
g).)
Note that this result can easily be extended to a mixture of K Binghams-we will
simply need to sum over K component intertia matrices in equation 2.46 rather than
just two.
2.14 
Historical Remarks and Contributions
The Bingham distribution was first published by Christopher Bingham in his 1964
thesis [10], and was expanded upon in a 1974 journal article [11]. The next major
result was by Mardia in 1975 [58], where the characterization of the Bingham as
a maximum entropy distribution was uncovered, and Jupp and Mardia in 1979 [41],
where maximum likelihood estimation for the Bingham was extended to hyperspheres
of any dimension. (Bingham's work was primarily focused on the 3-D sphere, S2 .)
Later work on the Bingham distribution mostly focused on applications in material
science [68, 75, 53], and extensions to complex fields [44, 45] with applications to 2-D
46

shape analysis.
To our knowledge, most of the material in this chapter after section 2.3 is new
to this thesis, with the exception of section 2.5 and section 2.8 up to theorem 2.9.
Specifically, the results on Bayesian parameter estimation, sampling, second moments
matrix, entropy, KL divergence, product of Bingham PDFs, marginal distributions,
mixtures of Bingharns, as well as the proof of theorem 2.1 and methods for calculating
and storing tables of normalizing constants and parameter estimates, are all believed
to be contributions of this thesis. Furthermore, previously-known results have been
tailored to be consistent with the standard form of the Bingham distribution in this
work (where Ad+1 and Vd+1 are dropped).
2.14.1 
Software
As a part of this thesis work, an open-source software library called libbingham7 has
been developed which provides a C and Matlab interface to most of the common
operations on Bingham distributions, with a focus on hyperspheres of dimension 4
and lower (SI 
S2 and S').
47
7 https://code.google.com/p/binghamii/

Chapter 3
The Quaternion Bingham
Distribution
3.1 
Understanding the Space of 3-D Rotations
As we discussed in chapter 1, one of the biggest challenges in dealing with 3-D ge-
ometry lies in appropriately handling 3-D rotational data. The topological space of
3-D rotations is called SO(3), the special orthogonal group of dimension 3, and has
several unique properties:
* The composition of rotations is non-commutative: in general, p o q $ q o p.
" Every rotation p has a unique inverse rotation p-.
* Elements of SO(3) can be thought of either as a 3-D rotation operator (i.e.,
a function that rotates points in 3-D space), or as a 3-D orientation (i.e., a
coordinate frame at the origin in 3-D space).
There are many ways to parameterize SO(3). Perhaps the most intuitive (and
common) way is as a set of three Euler angles a, /, 'y, specifying a sequence of rotation
angles about three axes (e.g., the z-, X-, and z-axes). However, this representation
suffers from a problem known as gimbal lock--when # reaches a special value (0 or
7r), any fixed sum a + -y for / = 0 (or a - 7 for / 
=) 
represents the same 3-D
48

rotation in SO(3). 
Mathematically, this is called a singularity of the Euler angle
chart on SO(3), and presents many problems for engineers--most famously during the
Apollo 11 moon landing mission, when an inertial measurement unit (IMU) on the
spacecraft shut down because its internal gimbal system (a mechanical realization
of Euler angles with interconnected rings) approached the singularity in Euler angle
space. The astronauts then had to use the position of the stars to manually re-orient
the spacecraft before restarting the IMU.
Gimbal lock also poses a problem when one tries to use a probability distribution
on the space of Euler angles to represent uncertainty about 3-D rotations. Any of the
common (non-trivial') distributions on angles-such as the wrapped Gaussian-will
end up having different probability densities for points in Euler angle space that map
to the same 3-D rotation!
Another common way of representing 3-D rotations is with a 3x3 rotation ma-
trix. While this parameterization is useful for computations (rotation of a 3-D vec-
tor is accomplished by multiplication with the rotation matrix), it is a severe over-
parameterization for SO(3). As the number 3 indicates, the space of 3-D rotations
has three degrees of freedom, while 3x3 rotation matrices have nine parameters. This
greatly complicates the math involved in using probability distributions on the space
of 3x3 rotation matrices. However, such distributions do exist-the matrix Langevin
and the matrix Bingham being two examples. For a general discussion of distribu-
tions on the Stiefel manifold (the space of matrices with orthonormal columns), see
the excellent book by Chikuse [16].
A third parameterization for SO(3) is the axis-angle representation: any 3-D
rotation can be described by an axis (unit vector) of rotation u and an angle of
rotation 0 e [0, 7r] (about u). The combination (0, u) is both an over-parameterization
and contains a singularity at 0 = 0.
However, when we combine the axis and angle into a single vector v = Ou, it lies
in a ball of radius 7r in R3. This parameterization is sometimes known as the Euler
vector. It has both the correct number of parameters (three) and no singularities,
'The uniform distribution is an exception, of course.
49

1.5
-- 
axis-angle distance
1 
-
natural distance
0.5-
0
0 
0.5 
1 
1.5 
2 
2.5 
3 
3.5
e
Figure 3-1:
although it wraps around at antipodal points (since rotating by 7r about u is the same
as rotating by 7r about -u), which can be problematic for probability distributions.
Yet Euler vectors' biggest flaw is this: space gets "stretched out" the further v gets
from the origin.
To see why this is the case, note that a natural, minimum-effort distance metric
on SO(3) is given by the absolute value of the minimum angle of rotation (about any
axis) required to rotate one 3-D orientation into another. In other words, if p and q
are elements of SO(3), p = r o q (where "o" denotes composition of rotations), and
the axis-angle representation of r is (0r, ur), then the natural distance between p and
q is equal to jOrl.
Except for a special case (when p and q share the same axis of rotation), the
Euclidean distance in Euler vector space overestimates the natural distance on SO(3),
and the error between the distances grows (non-linearly) the further the Euler vector
gets from the origin. In figure 3-1, the natural and axis-angle (Euclidean in Euler
vector space) distances are plotted as a function of 0 for the case of Op= Oq= 0 and
Up *uq 
= 0.9. In other words, p and q share the same angle of rotation and their
axes of rotation are separated by an angle of cos 1 0.9 ~ 7r/7.
Statistical methods that do use Euler vectors must therefore "unstretch" space to
respect the natural distance metric of SO(3) using methods from differential geometry
like Lie groups and tensors [17].
50

3.2 
Representing 3-D Rotations as Unit
Quaternions
Although the Euler vector representation has some issues when we try to use it as
a metric space, there is another simple transformation of the axis-angle parameteri-
zation of SO(3) which does have much more desirable properties as a metric space,
and therefore as a domain for probability distributions. That transformation is
q = (cos(/2), u sin(O/2)) 
(3.1)
which takes S' X S2 to S3, the 4-D unit hypersphere (i.e., the space of all 4-D unit
vectors). Furthermore, if we endow S3 with the algebra of quaternions, then quater-
nion multiplication is equivalent to the composition of 3-D rotations, and quaternion
inversion computes the inverse of 3-D rotatations.
This unit quaternion parameterization has many desirable properties as a repre-
sentation for SO(3):
1. It has no singularities.
2. The geodesic distance on S3 is proportional to the natural distance on SO(3).
3. Unit quaternions lie on one of the simplest non-Euclidean spaces --the hyper-
sphere.
The geodesic distance is the shortest-path distance along a manifold (e.g., on the
surface of the hypersphere), and for S3 is given by d(p, q) = cos- 1 (p -q).
The only potential pitfall with unit quaternions is that they aren't unique: q and
-q represent the same 3-D rotation, since rotating by 0 about the axis u is the same
as rotating by -- about -u. Yet as the reader should already be intimately aware of
after reading chapter 2, this antipodal symmetry is a perfect match for the Bingham
distribution, which shares the same symmetry!
The Bingham is not the only distribution that has been used on the space of
unit quaternions, but it is often the best. Other approaches include using Gaussian
51

distributions on R4 and pretending that the quaternions need not be unit vectors [55,
15, 59, 18, 46, 50], or using a Gaussian distribution on the tangent space to the unit
quaternion hypersphere at the mean of the distribution [25]. 
Such approaches rely
on local linear approximations to the true topology of unit quaternion space, and are
unable to effectively represent distributions that have large variances.
3.3 
Using the Bingham as a Distribution on
3-D Rotations
Although the Bingham distribution has been used as a distribution on SO(3) before
this thesis [53, 5], it was more commonly used to represent uncertainty in axial data
on S2 . In geology, it has been used to encode preferred orientations of minerals in
rocks [53]. Higher dimensional, complex forms of the Bingham distribution have also
been used to represent the distribution over 2-D planar shapes [22].
In this thesis, we will refer to the Bingham distribution on 3-D rotations (as
represented by unit quaternions in S3) as the quaternion Bingham distribution (QBD).
As we will see in the remainder of this thesis, the quaternion Bingham distribution
is very flexible, is easy to use (formulas for inference are readily available), and has
a deep connection to the problem of least-squares alignment of point sets. All of the
results for quaternion Binghams in the remaining chapters are new contributions of
this thesis.
In the remainder of this chapter, we will present formulas for fixed transforma-
tions of quaternion Bingham random variables, followed by a derivation for the (non-
Bingham) distribution resulting from a composition of two quaternion Bingham ran-
dom variables, as well as a Bingham approximation to the composition. We will
conclude this chapter with a preview of the technical contributions for the quaternion
Bingham to be found in later chapters.
52

3.3.1 
Rotation by a constant quaternion
Given q ~ Bingham(A, V), u E S', and s = u o q, then s 
~ Bingham(A, u o V),
where u o V 
[ Lu o v1 , u o v 2 , u o v 3]. In other words, s is distributed according to
a Bingham whose orthogonal direction vectors have been rotated (on the left) by u.
Similarly, if s = q o u then s ~ Bingham(A, V o u).
Proof for s = u o q: Since unit quaternion rotation is invertible and volume-
preserving, we have
d
f (s) = fq(u- 1 o s) = 
exp{Z Ai(vif (u-1 o s))2
i=1
d
= Fexp{ 
Aj((u ovj)'s)2j
3.3.2 
Quaternion inversion
Given q ~ Bingham(A, V) and s 
q-1, then s ~ Bingham(A, JV), where J is the
quaternion inversion matrix, J [ 4 a 
. The proof follows the same logic as
in the previous section.
3.3.3 
Composition of quaternion Binghams
Many inference algorithms (such as the recursive filters in the next chapter) call for
the composition of random rotations. When the random rotations are independent
quaternion Bingham random variables, the methods in this section may be used to
compute (or approximate) the distribution of their composition.
Letting q ~ Bingham(A, V) and r ~ Bingham(E, W), we wish to find the PDF of
s = q o r.
The true distribution is the convolution, in S', of the PDFs of the component
distributions.
53

f(s) 
j 
f(s q)f (q) = 
f (s; E, q o W)f (q; A, V)
(Jq(ES3 
J
F()1F(A) Jx 
oZ((s o w-1)q) 2 + Ai(viTq)2]
enC 
q(s~q
F(E)F (A) Jq
where
3
C(s) 
(Or 
(s owi- )(s o wi-)T + AiviviT) 
(3.2)
Since all the Ai's and o-i's are negative, the matrix C is negative semidefinite.
Therefore, fq eqTc(s)q is the normalization constant of a Bingham distribution, so
that the final form for the composed PDF is a quotient of hypergeometric functions,
1F 
(I -; 4; C(S))
f (S) =12 
(3.3)
23 
1F 2; 
2;A 
1 1 
; 2; E)
This does not have the form of a quaternion Bingham density.
To approximate the PDF of s with a Bingham density, fB(s) = fB(q o r), it is
sufficient to compute the second moments of q o r, since the inertia matrix, E[ssT] is
the sufficient statistic for the Bingham. This moment-matching approach is equivalent
to the variational approach, where fB is found by minimizing the KL divergence from
fB to ftrue.
Noting that q o r can be written as (qTHTr, qTH 2Tr 
qTHTr 
qTH4Tr), where
Fioool 
ro-o 
[00 0 -1 
[000-11
H, [ 
80 0 
], 
H 2 = [0 8 
0] 
H 3 = 
1 ,andH 4 = 
0010 
we find
L 
01 
g 
0 
j1 
adH
0 0 0 1. 
0 0 -1 0. 
0 1 0 0 .1 
0 0 0_
that
E[sisj] = E[qTHrrTHjq],
which has 16 terms of the form trarbqcqd, where a, b, c, d C {, 2, 3, 4}. 
Since q
and r are independent, E[±rrbqqd] = +E[rar]E[qcqd]. Therefore (by linearity of
expectation), every entry in the matrix E[ssT] is a quadratic function of elements of
the inertia matrices of q and r, which can be easily computed given the Bingham
normalization constants and their partial derivatives.
Let A = [aijl = E[qqT] and B = [bij] = E[rrT] be the inertia matrices of q and r,
respectively. Then E[ssT] is given by:
54

allbli -
2a 1 2 b12
-2a1313 
-- 2-
1 4 b 1 4
+a22b2 2 + 2a23b 2 3
+2a24b2 4 + a 3 3 b3 3
+2a
3 4b 3 4 + a 4 4 b4 4
a1 1 b 12 + a 1 2b 1 1 i+ 
a1 3 b 14
-- a14b13 -
a 1 2 b22 -
a22b12
- a3b23 -
a23b1 3 -
a14b24
--
24b4 
-- a2
3 b2 4 + a2 4 b23
-a
3 3 b3 4 + a 3 4 b3 3 -
(34b44
+a44b
3 4
a1lb13 - a3bi -
1 2b1 4
+a14bI2 
-
a 1 2b 2 3 -
a23b12
-a
1
3 b 3 3 + a 2 2b24 -
a24b22
-- a33b3 
-
-
a3 4 b14
+(L23b34 
-
a 3 4 b2 3 + a24b44
-a
4 4 b24
a1 1 b 1 4 + a 1 2 b 1 3 -
a 13 b 12
+ai 4bui 
-
a 1 2b 2 4 -
a24b12
-a2
2 b2 3 + a23 b22 -
a13b34
-a34b13 
-
a 2 3 b 3 3 + a 3 3 b 2 3
-a 1 4 b 4 4 -
a 2 4b 3 4 + a 3 4 b24
-a44bl4
all-12 + 
1 2b 1 1 + a 1 3 b 1 4
-(114bl3 
- al2b22 - a22b12
-
13b23 -
a2 3 b 1 3 -
4b24
--
24b14 -
u23b24 + a2 4 b2 3
-a
3 3 b3 4 + a 3
4 b33 -
a 3 4 b44
+a44b34
2a 12bl2 + all b2 2
a22b1 1 + 2ai 3b 2 4
-2a
4 b2 3 + 2a 2 3b 1 4
--2a24b3 -
2a 3 4 b 3 4
+a33-44 + a4 4 b3 3
a l 2 b 1 3 + a 13 b 1 2 + a1 1b 2 3
+a23b11 
-
a 1 2 b2 4 + u 1 4 b22
-a
2 2 b1 4 + a 2 4b 1 2 + a-3b34
-a14b33 
i a 3 3 b1 4 -
a34b13
+a24b34 + a 3 4 b24 -
a23b44
-a
4 4 b23
a 1 2 1 4 ± a 14 b12
+a12b23 -
a 1 3622
-a
2 3b 1 2 + a2 4 bii
+a34b3 4 + a3b44
-a24b33 - a33b24
" a 1 1 b2 4
+ a22b1 3
-
a 1 4 b 3 4
+ a 2 3 b3 4
+ a 3 4 b23
-a
4 4 b13
±a14 b23
-a13a33
~a33b13
+a23b34
I a 1 3 b1 1 
-
a12b14
-
a 1 2b2 3 -
a23b12
+ a 2 2 b24 -
(24b22
-
a 1 4 b 3 4 -
a34bl4
-
a 3 4b2 3 + a 2 4 b4 4
-a
4 4 b2 4
a 1 2 b1 3 + a 1 3 b1 2 + a 1 1 b 2 3
+a 2 3 bI1 -
a 1 2b24 - a-4b22
-a
2 2b 1 4 + a2 4b12 + 
13-34-
-a
1 4 b 3 3 I a 3 3b 14 -
a34b13
+a24b3 4 + a 3 4b2 4 - a23b44
-a
4 4 b23
2a 1 3 b 1 3 + 2a 1 4 b23
-2a2 3 bl 4 + allb3 3
+-33b11 
-
2a 1 2b 3 4
+2a
3 4 bi 2 -
2a 2 4b 2 4
+a 2 2 b4 4 + a 4 4 b2 2
a 1 3 b 14 + a1 4b 1 3
+a 2 3bI 3 + al 4 b2 4
+aIib34 + a233
+a 3 4b 11 + a23 b24
-a12b44 
-
a22b34
- -13b23
- a24bi4
- -3312
+ U24b23
-
a34b22
+a44b12
a11-14 + a2b13
+-14bi 
-
u12b24
-a 2 2b2 3 + a 2 3 b2 2
-a
3 4 b13 -
a23b33
-a
14 64 4
-
a24b34
-
U11 3 b1 2
-
a24b12
-
a13b34
" a 3 3b23
+ a 3 4 b2 4
-a44b14
a12b14 +i a
4bI2 + aib
2 4
+a12b23 - a1 3 b 2 2 + a22bl3
-a23b 1 2 + a 2 4 b11 -
a14b34
+a 3 4bl 4 + a 13 b4 4 ± a23b3 4
-a24b33 
-
a 3 3 b2 4 + a 3 4 b23
-a
4 4b13
-13b14 
+ a 1 4 b1 3 -
al3b23
+a 2 3 b1 3 + a 1 4 b2 4 - a24b14
±allb
3 4 + a 12b 3 3 - a33b12
±a 3 4 bii + a23b2 4 + a24b2 3
-a12b44 
-
a 2 2b
3 4 -
a34b22
+-444b12
2a 1 4 b1 4 
-
2a 1 3 b24
+2a24b1 3 + 2a 1 2b 3 4
-2a23b23 
-
2a 3 4b 1 2
+a 1 1 b 4 4 + a 2 2 b3 3
+a33b22 + a4 4b 11
3.3.4 
Estimating the error of approximation
To estimate the error in the Bingham approximation to the composition of two quater-
nion Bingham distributions, B1 o B 2 , we approximate the KL divergence from fB to
ft,e using a finite element approximation on the quaternion hypersphere
DKL(fB 
11 ftrue)
fB(X) log fB(x)
ftrue (X)
) fB(x) log 
- Ax
XCT(S3)ftllue (X)
where F(Sd) and {Ax} are the points and volumes of the finite-element approximation
to S3, based on a recursive tetrahedral-octahedral subdivision method [76].
To generate the tetrahedral-octahedral mesh that approximates S3, we begin by
placing vertices at (±i, 00, 0), (0, ±1, 0, 0), (0, 0, +1, 0), and (0, 0, 0, I). 
We then
join the vertices with sixteen tetrahedra formed by taking one vertex from each of
the four axes. This forms an initial tetrahedral mesh on S3 in the same way that
55

one can form a triangular mesh on the sphere S2 by placing eight triangles between
(+1, 0, 0), (0, +1, 0), and (0, 0, ±1). To increase the resolution of the mesh on S', we
subdivide each of our sixteen initial tetrahedra into four tetrahedra (at the corners)
and one octahedron (in the center) with vertices at the midpoints of the parent
tetrahedron's edges. Then we project each vertex back onto the unit hypersphere.
Octahedra can be subdivided into eight tetrahedra and six octahedra in a similar way.
The resulting tetrahedral-octahedral mesh may be subdivided until the necessary
resolution on S' is obtained.
3.4 
A Preview of Quaternion Bingham Results in
Later Chapters
In the next chapter, we will derive a recursive filter for 3-D orientation data that
is similar to the Kalman filter, but which uses the quaternion Bingham distribution
(rather than the Gaussian distribution) as its noise model. Because the quaternion
Bingham isn't closed under composition, the filter will be approximate. However, in
the practical applications we explore (including tracking the orientation and spin on
a ping pong ball) the error of approximation due to composition is negligable.
In chapter 5, we use mixtures of quaternion Binghams to form a generative model
of the distribution of local feature orientations on 3-D object models. Inverting this
distribution allows one to estimate the orientation distribution of an object in a
new scene, given a set of observed 3-D feature orientations. This chapter represents
the first step towards a Bingham-based object detection system, but stops short of
presenting a complete object detection system, as it is missing final alignment and
hypothesis evaluation steps in the algorithm.
Chapter 6 presents a complete, discriminative, object detection system. It is based
on a deep connection between the quaternion Bingham distribution and the least-
squares alignment problem, which will yield a new characterization of the quaternion
Bingham distribution (in addition to providing the probabilistic backbone for the
56

alignment step of the object detection algorithm).
57

Chapter 4
Tracking 3-D Rotations with the
Quaternion Bingham Filter
We now present a new deterministic method-the Quaternion Bingham Filter (QBF)-
for approximate recursive inference in quaternion Bingham processes1 . The quater-
nion Bingham process is a type of dynamic Bayesian network (DBN) on 3-D rota-
tional data, where both process dynamics and measurements are perturbed by random
Bingham rotations. The QBF uses the Bingham distribution to represent state un-
certainty on the unit quaternion hypersphere. Quaternions avoid the degeneracies of
other 3-D orientation representations, while the Bingham enables accurate tracking
of high-noise signals. Performing exact inference on quaternion Bingham processes
requires the composition of Bingham distributions, which results in a non-Bingham
density. Therefore, we approximate the resulting composed distribution as a Bing-
ham using the method of moments, in order to keep the filtered state distribution in
the Bingham family.
4.1 
Discrete-time quaternion Bingham process
We will derive filters for both first- and second-order rotating systems. Since most
physical systems have second-order dynamics, we expect second-order models to be
1This work in this chapter was published as an MIT technical report [29].
58

Second-order
First-order 
Vn 
wn 0 Un 0 Vn-1
Xn = wn 0 Un 0 Xn-I 
Xn 
-
0i Xn-1
Yn = Zn 0 Xn 
Yn 
Zn O Xn
Un
Un 
Vn-1 
Vn
Xn-1 
Xn 
Xn-1 
Xn
Yn-1 
Yn 
Yn-1 
Yn
Figure 4-1: Process and graphical models for the discrete quaternion Bingham pro-
cess.
a better fit for many real-world rotating systems, such as the spinning ball data set
in section 5.4.
The first-order discrete-time quaternion Bingham process has, as its state, Xn, a
unit quaternion representing the orientation of interest at time n. The system's be-
havior is conditioned on control inputs un, which are also unit quaternions. The new
orientation is the old orientation rotated by the control input and then by indepen-
dent noise w, 
~ Bingham(Ap, V4). Note that "o" denotes quaternion multiplication,
which corresponds to composition of rotations for unit quaternions. (q o r means
"rotate by r and then by q".)
The second-order quaternion Bingham process has state (Xn, vn), where x,, repre-
sents orientation and the quaternion v, represents discrete rotational velocity at time
n'. The control inputs u, are analogous to rotational accelerations. Process noise
w, enters the system in the velocity dynamics.
2We use a quaternion to represent rotational velocity so that its uncertainty can be modeled as
a quatenion Bingham distribution.
59

In both the first-order and second-order systems, observations y, are given by the
orientation x, corrupted by independent Bingham noise z" 
~ Bingham(A,, V). One
S0 01
common choice for V1 and V is 
0 1 
,which means that the mode is the quaternion
S0 1_
identity, (1, 0, 0, 0). (Any V matrix whose top row contains all zeros will have this
mode.) Figure 4-1 shows the process and graphical models for the discrete quaternion
Bingham process.
4.2 
Discrete quaternion Bingham filter
The state of a discrete-time quaternion Bingham process can be estimated using
a discrete-time quaternion Bingham filter, which is a recursive estimator similar in
structure to a Kalman filter. Unlike the Kalman filter, however, the QBF is ap-
proximate, in the sense that the tracked state distribution is projected to be in the
Bingham family after every time step. The second-order QBF will also require an
assumption of independence between x,, and v,, given all the data up to time n.
Both the first-order and second-order QBFs are examples of assumed density filter-
ing-a well-supported approximate inference method in the DBN literature [12]. We
will start by deriving the first-order QBF, which follows the Kalman filter deriva-
tion quite closely. Note that the following derivations rely on several properties of
Bingham distributions which were detailed in chapters 2 and 3.
First-order QBF. Given a distribution over the initial state x0 , Bx0 - Bingham(Ao, V),
and an action-observation sequence u1, Yi, ... , un, yn, the goal is to compute the pos-
terior distribution f(xn I u1, Y. 
. . , un, yn). We can use Bayes' rule and the Markov
property to decompose this distribution as follows:
BX71 = f (xnu yI, 
Y1... , Un, yn)
OC f (yn Ix.) f (xn uI, 
1, .... 
. ,n s1, yn_1, Un)
= f (ynIxn) J 
f(x 
I xn_1, un)Bx,_1 (xn-)
= f(y- xI)(f., o u o B,,)(x.) .
where f,, o un o Bx, , means rotate B 
,,, by u, and then convolve with the process
60

noise distribution, f. 1.
For the first term, f(y, Ix,), recall that the observation
process is y, = z0 
0 x1, so yn Ix, 
Binghamt(y,; A,, V o x,), where we used the
result from section 3.3.1 for rotation of a Bingham by a fixed quaternion. Thus the
distribution for ynXn is
1
f (yn Ix7) = 
exp 
Ao (yT (v 0 
xn)
i=1
Now we can rewrite ynT(v.,oxn) as (v-i oyn)Txn, so that f(yn Ix ) is a Bingham den-
sity on xn, Bingham(xn; A0 , VI-1 0 yn). Thus, computing B, 
reduces to multiplying
two Bingham PDFs on xn, which is given in section 2.11.
Second-order QBF. Given a factorized distribution over the initial state f(xo, vo)
Bx 0 Bvo and an action-observation sequence u, yi, . .. , u,, y,,, the goal is to compute
the joint posterior distribution f (xn, Vn I U1, Y,. 
.. , 
, yn). However, the joint dis-
tribution on xn and vn cannot be represented by a Bingham distribution. 
Instead,
we compute the marginal posteriors over x. and vn separately, and approximate the
joint posterior as the product of the marginals. The marginal posterior on x, is
BX11 = f (xn luI, Y1, .
n 
. .,,y71)
cx f(ynIxn) J 
f(xI Xn -1)Bx, 
(xn_)
= f(y. x,,)(B,, o Bx,_,)(x,)
since we assume x,_1 and v,_ 1 are independent given all the data up to time n -
1.
Similarly, the marginal posterior on vr, is
BV, = f(v 
Iu 1 , y 1, . .. , U, 
yt)
cX j 
f(Vr I vn_ 1,un)Bv,_ I(v
11 )f(ynIVn_1,Ui,y1, . .. , U711, y7_1)
= 
f (Vn I Vn_1, ust)BV,,_J (VTI_) 
f (yn IX,)f (x,,IVn,, ui, y1 
I 
, .... 
, Ut_1, IIyT_)
Once again, f(yn x,) can be written as a Bingham density on xn, Bingham(xn; A0, V1-7o
yn). Next, note that X, = vn_1 o xn_ 1 so that f(xVnm,_U1, I Y1,...,us_,yn_1) =
3 Exploring good distributions for pairs of 3-D rotations-as unit quaternions on Vx 
--or for
full 3-D poses on R3 x 3 is an area of ongoing research.
61

Bx,, (vin 
o xn), which can also be re-written as a Bingham on xn. Now letting
xn-1 ~Bingham(E, W), and since the product of two Bingham PDFs is Bingham,
the integral over xn becomes proportional to a Bingham normalization constant,
F(C(v_ 1 )), where
3
C(v a_) =Z 
o-dvn_ 
o w )(Vn 
_1o w )T + Ay(v- 
0 Yn)(V- 1 
y0 )T)
Comparing C(v2,i) with the formula for the composition of two independent Bing-
ham random variables (equation 3.2 in section 3.3.3) we find that F(C(vn_1)) c
(Y 
nI 
o Bn )(vn_1). Thus,
BV, oc 
f (vn I Vn_1, Un)By_(_)-(fix 
o B-1)va1
=(fw,, 0 Un 0 (B ,, 
f~ x o B -1 
))( 
a
In other words, to update the belief on va, we first convolve the inverse belief on
Xn- 
with the measurement distribution, then multiply by the belief on v,_ 1 , rotate
by the control input un, and convolve by the noise distribution, f,". Intuitively,
this update rule combines the prior velocity belief, B,_,- with the observed velocity
information-i.e., the change from x,_1 to yn. Then a process update (borrowing
terminology from the Kalman filter) is applied by rotating by u, and adding noise.
4.2.1 
Extensions
For some applications (such as tracking a ping pong ball through a bounce), the
process and observation models of the QBFs described above may be somewhat re-
strictive. Several extensions are possible, as we outline here.
Sampling-based methods / Tracking the ball through a bounce. 
The
QBF can handle arbitrary process and control models by drawing N samples at
random 4 from the current state distribution, applying the process/control function
to each sample, and then fitting new Bingham distributions to the resulting post-
process/control samples. This is precisely the method we use in our experiments to
4 A related method is the unscented quaternion Bingham filter, which draw samples determinis-
tically in order to handle arbitrary process models [28].
62

track the ping pong ball through a bounce on the table. The process model is taken
from Andersson's ball physics derivation [4], and is a complex function of the ball's
tracked angular arid translational velocities,
3pu
Wf 
wi + 
(Pry, -v2, 0)vi,(1 + E),
2r
where wi and wf are the initial arid final (pre- and post-bounce) angular velocity
vectors, p and c are the coefficients of friction and restitution, r is the ball's radius,
vi, is the ball's initial translational z-velocity, and 
Vr 
=V/JJVrJ , where vr = (viy +
war, vjx -
wZYr, 0) is the relative velocity of the surface of the ball with respect to the
table.
Quaternion exponentiation / Continuous-time filters. Quaternion expo-
nentiation for unit quaternions is akin to scaling in Euclidean space. If q represents
a 3-D rotation of angle 0 about the axis v, then q" is a rotation of aO about v. This
operation would be needed to handle a continuous-time update in the second-order
Bingham filter, since the orientation needs to be rotated by some fraction of the spin
quaternion at each (time-varying) time step.
Although we do not do it in this work, it is possible to incorporate quaternion
exponentiation in all parts of the model via a moment-matching method for Bing-
ham exponentiation (akin to the moment-matching method for Bingamn composition).
However, an additional Taylor approximation is needed to approximate the second
moments of the exponentiated Bingham as a function of the second and higher even
moments of the original distribution. (Recall from chapter 2 that the odd moments
of a Bingham are always zero due to symmetry.)
4.3 
Experimental Results
We compare the quaternion Bingham filter against an extended Kalman filter (EKF)
approach in quaternion space [55], where process and observation noise are generated
by Gaussians in R , the measurement function normalizes the quaternion state (to
project it onto the unit hypersphere), arid the state estimate is renormalized after
63

0 
20 
4O 
W0 
1010 Ii 
' 12 1 0 mn 
190 
200
(a) A, = (-50, -50, -50)
Figure 4-2: Two simulated
'OU 
'W 
:00
5, VV
'Zo 
W 
lt 
'N 
?,"
___ 200
1 
140 
1W 
M 
2W
a 
2Q 
0 
60 
1. 
120 
IQ
(b) A, 
(- 10, - 10, - 1)
runs with the quaternion Bingham filter-(b) and (c)
are different plots of the same simulation. In all figures, the thick black line is the
true process signal, generated with isotropic process noise Ap = (-400, -400, -400).
The thin blue lines in (a) and (b) are the observation signal, and the thick red line
is the filtered output. Rows 1-4 in each figure show the 4 quaternion dimensions
(qw, qx, qy, qz). Row 5 in (a) and (b) shows the error between filter output and true
state (thick red line), together with the QBF sample error 90% confidence bounds
(thin red line). Marginal sample 90% confidence bounds are also shown in the thin
red lines in (c).
every update. We chose the EKF both due to its popularity and because LaViola
reports in [55] that it has similar (slightly better) accuracy to the unscented Kalman
filter (UKF) in several real tracking experiments. We adapted two versions of the
EKF (for first-order and second-order systems) from LaViola's EKF implementation
by changing from a continuous to a discrete time prediction update. We also mapped
QBF (Bingham) noise parameters to EKF (Gaussian) noise parameters by empirically
matching second moments from the Bingham to the projected Gaussian-i.e., the
Gaussian after it has been projected onto the unit hypersphere.
Synthetic Data. To test the first-order quaternion Bingham filter, we generated
several synthetic signals by simulating a quaternion Bingham process, where the (ve-
64
0 A0 
'1 
I 
A1o 0  
10, 
60 
1 
80 
2
(C) 
A, = (-10, -10,-)

locity) controls were generated so that the nominal process state (before noise) would
follow a sine wave pattern on each angle in Euler angle space. We chose this control
pattern in order to cover a large area of 3-D rotation space with varying rotational ve-
locities. Two examples of synthetic signals along with quaternion Bingham filter out-
put are shown in figure 4-2. Their observation parameters were A, = (-50, -50, -50),
which gives moderate, isotropic observation noise, and A, = (-10, -10, 
-1), 
which
yields moderately high noise in the first two directions, and near-uniform noise in the
third direction. We estimated the composition approximation error (KL-divergence)
for 9 of these signals, with both isotropic and nonisotropic noise models, from all
combinations of (Ap, A,) in {(-50, -50, -50), (-200, -200, -200), (-10, -10, -1)}.
The mean composition error was .0012, while the max was .0197, which occurred
when AP and A, were both (-10, -10, 
-1).
For the EKF comparison, we wanted to give the EKF the best chance to succeed,
so we generated the data from a projected Gaussian process, with process and obser-
vation noise generated according to a projected Gaussian (in order to match the EKF
dynamics model) rather than from Bingham distributions. We ran the first-order QBF
and EKF on 270 synthetic projected Gaussian process signals (each with 1000 time
steps) with different amounts of process and observation noise, and found the QBF to
be more accurate than the EKF on 268/270 trials. The mean angular change in 3-D
orientation between time steps were 7, 9, and 18 degrees for process noise parameters
-400, -200, and -50, respectively (where -400 means Ap = (-400, -400 - 400), etc.).
The most extreme cases involved anisotropic observation noise, with an average
improvement over the EKF mean error rate of 40-50%. The combination of high
process noise and low observation noise also causes trouble for the EKF. Table 4.1
summarizes the results. Error rates were computed for the EKF and QBF on each
signal by measuring the average absolute difference between the true signal and the
modes of the EKF and QBF filtered distributions. Percentage improvement values
(in the error rates) for QBF over EKF were then calculated for each signal; the mean
and standard deviation of these percentage improvement values across all signals for
each process and noise model are shown in table 4.1.
65

observation noise 
-400, -400, -10 
-400 
-50
process noise 
-50 
-200 
-400 
-50 
-200 
-400 
-50 
-200 
-400
% improvement 
37.3 
45.6 
54.3 
19.9 
3.33 
1.52 
3.42 
0.72 
0.47
± 
(5.1) 
(5.0) 
(6.4) 
(1.8) 
(0.53) 
(0.44) 
(0.88) 
(0.40) 
(0.27)
Table 4.1: Projected Gaussian process simulations. Average % mean error decrease
for QBF over EKF.
(a) slow top-spin 
(b) fast top-spin
(c) slow side-spin 
(d) fast side-spin
Figure 4-3: Example image sequences from the spinning ping-pong ball dataset. In
addition to lighting variations and low image resolution, high spin rates make this
dataset extremely challenging for orientation tracking algorithms. Also, because the
cameras were facing top-down towards the table, tracking side-spin relies on correctly
estimating the orientation of the elliptical marking in the image, and is therefore
much harder than tracking top-spin or under-spin.
Spinning ping-pong ball dataset. To test the second-order QBF, we collected
a dataset of high-speed videos of 73 spinning ping-pong balls in flight (Figure 4-3).
On each ball we drew a solid black ellipse over the ball's logo to allow the high-speed
(200fps) vision system to estimate the ball's orientation by finding the position and
orientation of the logo5 . However, an ellipse was only drawn on one side of each
ball, so the ball's orientation could only be estimated when the logo was visible in
the image. Also, since ellipses are symmetric, each logo detection has two possible
orientation interpretations'. The balls were spinning at 25-50 revolutions per second
5Detecting the actual logo on the ball, without darkening it with a marker, would require im-
provements to our camera setup.
6We disambiguated between the two possible ball orientation observations by picking the obser-
66

(which equates to a 45-90 degree orientation change per frame), making the filtering
problem extremely challenging due to aliasing effects. We used a ball gun to shoot the
balls with consistent spin and speed, at 4 different spin settings (topspin, underspin,
left-sidespin, and right-sidespin) and 3 different speed settings (slow, medium, fast),
for a total of 12 different spin types. Although we initially collected videos of 107 ball
trajectories, the logo could only be reliably found in 73 of them; the remaining 34
videos were discarded. Although not our current focus, adding more cameras, adding
markings to the ball, and improving logo detections would allow the ball's orientation
and spin to be tracked on a larger percentage of such videos. To establish an estimate
of ground truth, we then manually labeled each ball image with the position and
orientation of the logo (when visible), from which we recovered the ball orientation
(up to symmetry). We then used least-squares non-linear regression to smooth out
our (noisy) manual labels by finding the constant spin quaternion, s, which best fit
7
the labeled orientations for each trajectory
To run the second-order QBF on this data, we initialized the QBF with a uni-
form orientation distribution B, 0 and a low concentration (A = (-3, -3 - 3)) spin
distribution By0 centered on the identity rotation, (1, 0, 0, 0). In other words, we pro-
vided no information about the ball's initial orientation, and an extremely weak bias
towards slower spins. We also treated the "no-logo-found" (a.k.a. "dark side") ob-
servations as a very noisy observation of the logo in the center of the back side of the
ball at an arbitrary orientation, with A, = (-3.6, -3.6, 0)'. When the logo was de-
tected, we used A, = (-40, -40, -10) 
for the observation noise. A process noise with
AP = (-400, -400, -400) was used throughout, to account for small perturbations to
spin.
Results of running the second-order QBF (QBF-2) are shown in figure 4-4. We
compared the second-order QBF to the second-order EKF (EKF-2) and also to the
vation with highest likelihood under the current QBF belief.
7Due to air resistance and random perturbations, the spin was not really constant throughout
each trajectory. But for the short duration of our experiments (40 franes), the constant spin
approximation was sufficient.
8We got this A, by fitting a Bingharn to all possible dark side orientations.
67

1.5
5 
1
0.5
orientation error
1.5
0.5
U,
5 
10 
15 
20 
25
time
--- 
QBF-
orientation erro
1.5
1
0.5
0_
5 
10 
15 
20 
25
time
spin error
a
a
spin classification
0.6
0.4
0.2
30 35 40 
5 10 
15 20 25 30 35 40 
5 
10 15 20 25 30 35 40
time 
time
2 -
-
- QBF-1 -
- - EKF-1 -
EKF-2 
oracle prior 
filter bank - -
- random
r 
spin error 
spin classification
1.5 
[ 
~ 
X
-
topspin/underspin 
0.8
-
sidespin 
0.6
0.5
0.2-
0 
0
30 
35 
40 
5 
10 
15 
20 
25 
30 
35 
40 
5 
10 
15 
20 
25 
30 
35 
40
time 
time
Figure 4-4: Spinning ping-pong ball tracking results. Top row: comparison of QBF-
2 (with and without an oracle-given prior) to QBF-l, EKF-1, EKF-2, and random
guessing (for spin classification); QBF-1 and EKF-1 do not show up in the orientation
error graph because they only tracked spin. Note that QBF-2 quickly converges to
the oracle error and classification rates. Bottom row: QBF-2 results broken down into
top-spin/under-spin vs. side-spin. As mentioned earlier, the side-spin data is harder
to track due to the chosen camera placement and ball markings for this experiment.
Note that the time axes are measured in frames (not seconds).
first-order QBF and EKF (QBF-1 and EKF-1), which were given the difference be-
tween subsequent orientation observations as their observations of spin. The first-
order filters were initialized with the same spin distributions as the second-order
filters. The solid, thin, blue line in each plot marked "oracle prior" shows results
from running QBF-2 with a best-case-scenario prior, centered on the average ground
truth spin for that spin type, with A = (-10, -10, -10). 
We show mean orientation
and spin errors (to regressed ground truth), and also spin classification accuracy us-
ing the MAP estimate of spin type (out of 12) given the current spin belief'. The
'Spin was classified into one of the 12 spin types by taking the average ground truth spin for each
spin type and choosing the one with the highest likelihood with respect to the current spin belief.
68

0.7 
0.7
-
-
high noise, one side 
-
-
high noise, one side
0.6 
--- 
high noise, both sides 
0.6 
-
high noise, both sides
0.5- 
-
- low noise, one side 
-
-
low noise, one side
0-- 
low noise, both sides 
0 
low noise, both sides
I. 14 
0.4
S0.3- 
M 0.3
0.2 
0.2 
.
0.1 
01
0 
0
0 
10 
20 
30 
40 
50 
0 
10 
20 
30 
40 
50
time (frames) 
time (frames)
Figure 4-5: Simulated spinning ping-pong ball QBF-2 tracking results.
results clearly show that QBF-2 does the best job of identifying and tracking the ball
rotations on this extremely challenging dataset, achieving a classification rate of 91%
after just 30 video frames, and a mean spin (quaternion) error of 0.17 radians (10
degrees), with an average of 6.1 degrees of logo axis error and 6.8 degrees of logo angle
error. In contrast, the EKF-2 does not significantly outperform random guessing, due
to the extremely large observation noise and spin rates in this dataset. In the middle
of the pack are QBF-1 and EKF-1, which converge much more slowly since they use
the raw observations (rather than the smoothed orientation signal used by QBF-2)
to estimate ball spin. Finally, to address the aliasing problem, we ran a set of 12
QBFs in parallel, each with a different spin prior mode (one for each spin type), with
A = (-10, -10, -10). 
At each time step, the filter was selected with the highest total
data likelihood. Results of this "filter bank" approach are shown in the solid, thin,
green line in figure 4-4.
Simulated balls. Orientation and spin error rates for the QBF-2 were quite
high on the real ping-pong ball data set due to poor logo detection rates caused
by low-resolution ball images (and by only seeing the logo when it was on the top
side of the ball). 
Therefore, to further validate the accuracy of the second-order
QBF, we generate a set of 100 simulated flying ball trajectories with constant spin
between 0 and 7r/2 radians per frame (with an average spin rate of 1.16 ~ 7r/2.7 ra-
dians). Observed orientations were perturbed by random quaternion Bingham noise,
with two different noise settings: "low noise" with A, 
= (-400, -400, -100), 
and
69
orientation error
spin error

spin error
-
QBF-2 + bounce
0.6- 
- - - QBF-2
0.6-
0.4-
0.2
-20 
-15 
-10 
-5 
0 
5 
10 
15 
20
time
Figure 4-6: Average QBF spin tracking error as it tracks the spin through the ball's
bounce on the table. Post-bounce errors are significantly lower with the sample-based
bounce tracking method (solid black line) outlined section 4.2.1.
"high noise" with A, = (-40, -40, -10). 
We also compared the filter's performance
with the top-side-only ("one side") observations to the performance when orientation
measurements were available from any ball orientation ("both sides"). Figure 4-5
summarizes the results. This simulated experiment demonstrates that the QBF-2's
high error rates on the real ball data set are caused by poor quality observations, and
not by shortcomings of the quaternion Bingham filter.
Tracking through the bounce. We also used the sampling-based method out-
lined in section 4.2.1 to track the ball through the bounce (on real ball data) for 5
topspin/right-sidespin and 5 underspin/left-sidespin ball trajectories, and found that
incorporating the bounce model as a sample-based process update in the quater-
nion Bingham filter (rather than restarting the filter after the bounce) resulted in a
significant reduction in tracking error post-bounce (Figure 4-6).
In Figure 4-7 we show an example of the output of the second-order QBF we
used to track the orientation and spin on the ball through one of the underpin/left-
sidespin trajectories. In the first image frame, no logo is detected, so the orientation
distribution is initialized to the "dark side" of the ball, and the spin distribution is
close to a uniform distribution. After a few more frames, the filter has an accurate
estimate of both the orientation and spin of the ball, with fairly high concentration
parameters (low-uncertainty) in its Bingham distributions. After the bounce, the
sample-based process update correctly updates the orientation and spin on the ball,
70

orientati
spins XEl CDJf
[3c-1311f[
Figure 4-7: An example ball trajectory (underspin + left-sidespin) and the state of
the QBF as it tracks the ball's orientation and spin through the bounce. In the top
row of ball images, the big red (solid-line) axis is the mode of the QBF's orienta-
tion distribution, and the small red axes are random samples from the orientation
distribution. The big green (dashed-line) axis is the detected ball orientation in that
image. In the bottom row, the big red (solid-line) axis is the mode of the QBF's spin
distribution, and the small red axes are random samples from the spin distribution.
The big green (dashed-line) axis is the ground truth spin, and the black axis in the
center is the identity (no-spin), for reference.
and the filter maintains correct, high-concentration distributions.
4.4 
Conclusion
For many control and vision applications, the state of a dynamic process involving 3-D
orientations and spins must be estimated over time, given noisy observations. Previ-
ously, such estimation was limited to slow-moving signals with low-noise observations,
where linear approximations to 3-D rotation space were adequate. The contribution
of our approach is that the quaternion Bingham filter encodes uncertainty directly
on the unit quaternion hypersphere, using a distribution-the Bingham-with nice
mathematical properties enabling efficient approximate inference, with no restrictions
on the magnitude of process dynamics or observation noise. Because of the compact
71

nature of 3-D rotation space and the flexibility of the Bingham distribution, we can
use the QBF not only for tracking but also for identification of signals, by start-
ing the QBF with an extremely unbiased prior, a feat which previously could only
be matched by more computationally-intensive algorithms, such as discrete Bayesian
filters or particle filters.
The composition operator for quaternion Bingham distributions may also have ap-
plications beyond tracking the state of a rotating system. For example, uncertainty
propagation on kinematic chains requires the addition (composition) of multiple noisy
joint angle measurements, each of which could be represented as a quaternion Bing-
ham random variable. The method-of-moments approximation may be used to ap-
proximate the distribution of orientations at the final link in the chain, without the
need for sampling.
72

Chapter 5
A Generative Method for 3-D
Object Detection
The success of personal service robotics hinges upon reliable manipulation of every-
day household objects, such as dishes, bottles, containers, and furniture. In order to
accurately manipulate such objects, robots need to know objects' full 6-DOF pose,
which is made difficult by clutter and occlusions. Many household objects have reg-
ular structure that can be used to effectively guess object pose given an observation
of just a small patch on the object. In this chapter, we present a method to model
the spatial distribution of oriented local features on an object, which we invert to
find a distribution over object poses given small sets of observed local features. The
orientation distribution for local features is given by a mixture of Binghams on the
hypersphere of unit quaternions, while the local feature distribution for position given
orientation is given by a locally-weighted (quaternion kernel) likelihood. Experiments
on 3D point cloud data of cluttered and uncluttered scenes generated from a struc-
tured light stereo image sensor validate our approach.
While this chapter represents the first step towards a Bingham-based object de-
tection system, it stops short of presenting a complete object detection system, as it
is missing final alignment and hypothesis evaluation steps. This chapter is included
in this thesis primarily as an exploratory prelude to the full object detection system
in chapter 6, although the generative models developed here may be useful for related
73

tasks in the future. The work in this chapter was previously published in the pro-
ceedings of Robotics: Science and Systems in 2011 [31], and was the first publication
from this thesis.
5.1 
Introduction
The goal of this chapter is to determine a set of possible object poses, given a 3D
model of the object and a point cloud observation of a scene containing the object.
To answer this question, we will consider the observed point cloud to be made up of
many tiny overlapping surface patches, and we will construct a model of the informa-
tion each observed patch gives us about the object's pose, by considering the range
of locations the patch may have come from on the model. When such a surface patch
contains orientation information in the form of a normal vector and principal curva-
ture direction (or when the normal and principal curvature can be estimated from
the local patch geometry), we call it an oriented local feature (or "oriented feature"
for short).
In this chapter, we present a new method to model the spatial distribution of
oriented local features on an object, which we use to infer object pose given small
sets of observed features. We split up the spatial distribution of oriented local features
into two parts, one modeling the distribution over feature orientations, and another
modeling the conditional distribution of feature position given orientation. Splitting
up the feature distributions in this way allows us to exploit predictable relationships
between the orientation of local surface patches on an object and the object's pose
(Figure 5-1).
The distribution for feature orientation is given by a mixture of quaternion Bing-
hams, while the distribution for feature position given orientation is given by a locally-
weighted (Quaternion kernel) likelihood. Local likelihood is a non-parametric, kernel-
based technique for modeling a conditional distribution, p(xlq), as a smoothly varying
function of the observed variable, q.
74

Point Cloud
Q-Image
V 4
Figure 5-1: Five 3-D point clouds and their corresponding Q-Image transforms, re-
spresenting the distribution of local 3-D surface orientations on each object (see sec-
tion 5.3 for details).
5.1.1 
Outline
The technical portion of this chapter is organized in a top-down fashion. We present
our pose estimation algorithms in section 5.2. Our main contribution-a new way to
model the distribution of oriented local features on an object-is given in section 5.3.
Section 5.4 contains experimental results, followed by related work and conclusions
in sections 5.5 and 5.6.
5.2 
Monte Carlo Pose Estimation
At its core, this chapter presents a new way to model the spatial relationship between
an object and its oriented local features. This model can be used for many perceptual
tasks, since there are many uses for such spatial models in a perceptual processing
pipeline. As an application, we test the acuity of our model for object pose estimation,
in a probabilistic Random-Sampling-Consensus (RANSAC) framework.
RANSAC [26] is a classic Monte-Carlo algorithm for using small random subsets
from a large set of features to quickly generate many guesses of whatever the algorithm
75

is trying to estimate. It then ranks the guesses according to an evaluation criterion,
and returns the top n answers. RANSAC is part of a larger trend to solve perceptual
problems by applying successive filters, or sieves, to a set of guesses (or samples),
keeping good samples and throwing away the bad ones, until (one hopes) only good
samples are left. The key to making such a filtering scheme work efficiently is to
generate reasonable guesses early on in the pipeline, and throw away as many bad
samples with the early, fast filters, so that the later, discriminative (but slow) filters
don't have to sift through as much junk to find the right answers.
Our model fits perfectly at the early stage of such a filtering scheme for pose
estimation. By squeezing all the information one can get from a single oriented local
feature, and then from small sets of oriented local features, we can quickly generate
many good guesses for object pose. Later filters-which for example iteratively align
a model at a sample pose with the observed point cloud and then compute a fitness
score using all the points in the model-can be used to further refine the set of pose
estimates, and are explored in chapter 6. However, that final stage of the estimation
process is omitted in this chapter in order to explore the potential benefits of using
a generative model of an object's oriented local features. The hope is that one can
get good initial sample poses using just a few local oriented features at a time, which
is crucial for pose estimation in cluttered scenes, where only a small portion of an
object may be visible.
5.2.1 
Problem Statement
We address two primary pose estimation problems in this chapter. The first problem,
which we call "Single Object Pose Estimation" (SOPE), is to estimate an object's
pose given a point cloud observation, Fob,, of part of the object (Figure 5-2). For this
task, we have a model (i.e. we know the object's identity) and a segmentation (i.e.
we know which points in the observation correspond to the model), and the goal is
to return samples from the distribution over possible object poses (x, q) C R3 X 3
given the observation, p(x, qlFob,). The SOPE problem is well suited to "separable"
scenes, for example when one or more objects are separated on a table or a shelf.
76

+e .
Observed Point Cloud
Figure 5-2: The Single
a (partial) observation
Object Pose Estimation (SOPE) problem: given a model and
(left), we wish to estimate the pose of the object (right).
" Given: a model, M, and an observed point cloud, Fb8 .
* Fori=1... N
-
1) Sample a "proposal" oriented feature, f,, at random from Fob,.
-
2) Sample an object pose, (xi, qi) from pm(x, qJfp).
-
3) Sample k "validation" oriented features, {f 
} at random from Fob,.
-
4) Set sample weight wi +- pm(xi, qiIfo, 
.
" Return: the top n samples (xi, qi) ranked by weight, wi.
Table 5.1: MC-SOPE
The second problem is "Single Cluttered Object Pose Estimation" (SCOPE). In
this task, we have a model, an observed point cloud containing several objects, and
a rough location (e.g. a bounding box) in which to look for the desired object. The
goal once again is to return a set of samples from the posterior pose distribution,
p(x, qIFob,), of the desired object.
77
Model
Pose

5.2.2 
MC-SOPE Algorithm
Our solution to the SOPE problem, MC-SOPE, is shown in table 5.1. It starts by
sampling a pose using the information from one "proposal" oriented local feature
fp which is chosen at random from the observed point cloud, Fob,. Then, it uses k
"validation" features, frl, . .. , fvk, to compute a weight/score for the proposed object
pose. After N poses have been proposed and weighted, the algorithm returns the top
n samples, ranked by weight. As we will see in section 5.3, sampling from pM(x, qI f)
and computing the validation density pM(X, q {fv 
... }) are both 0(1) operations when
k is a small constant (we use k = 5 in our experiments), so the entire algorithm is
O(N), allowing us to generate large numbers of good samples quickly'. This is in
contrast to traditional RANSAC-type methods for model fitting and pose estimation,
which typically use all the observed features in Fob, to rank each proposal, resulting
in a running time of 0(N -|Fobs ).
5.2.3 
MC-SCOPE Algorithm
Our solution to the SCOPE problem, MC-SCOPE, is shown in table 5.2. It is nearly
identical to MC-SOPE, with the main difference being that MC-SCOPE samples
validation points using a random walk (since the observed point cloud contains more
than one object and the region of interest, Fobsro may not be a perfect segmentation
of the desired object).
5.3 
Local Feature Distributions
Both pose estimation algorithms in the previous section require a model for pA! (x, qI fp)
and p1l(x, q {f 
})-the likelihood of an object pose, given one or more observed
oriented local features. Although the oriented local features on an object may not
be unique, they can still be quite informative. For example, in figure 5-4, observing
'It turns out to be quite difficult to generate good samples in clutter, which will motivate our
more computationally-expensive detection algorithm in the next chapter.
78

(a)
\ 
I
(b)
Figure 5-3: The Single Cluttered Object Pose Estimation (SCOPE) problem: given
a model, an observation, and a region of interest (a), we wish to estimate the pose of
the object (b).
" Given: a model, M, and an observed point cloud, Fob8 with sub-cloud region
of interest, Fobs,roi.
" For i= 1I... N
-
1) Sample a "proposal" oriented feature, fp, at random from sub-cloud
Fobs,roi.
-
2) Sample an object pose, (xi, qi) from pm (x, qJfp).
-
3) Sample k "validation" features, {fV1 . } using a random walk in the full
point cloud Fos, starting from fp.
-
4) Set sample weight wi +-- pm (xi, qi {fc 
}.
" Return: the top n samples (xi, qi) ranked by weight, wi.
Table 5.2: MC-SCOPE
a curved patch of the surface on the cup or a flat patch on the base tells us that
the object is aligned with the z-axis, at a narrow range of positions. In contrast,
79

(a)
S
4.4
(b)
4$
./~
(c)
Figure 5-4: Informative oriented local (surface patch) features. 
Observing just a
single patch of an object can often constrain the set of feasible object poses to a
narrow range of possibilities. In the top row, two different patches on a wine glass
are shown, along with four possible object poses consistent with each patch. In the
bottom row, a bowl feature is shown, along with four object poses consistent with
the observed patch. Both of the the observed glass features constrain the orientation
of the glass to be aligned with the z-axis, while the bowl feature places much weaker
constraints on orientation.
oriented local features oil the surface of a hemispherical bowl tell us very little about
the bowl's orientation, and constrain the bowl's position to a bowl-shaped set of
locations, centered on the observed patch.
Our approach to computing pm(x, qlfi) will be to use Bayes' rule:
PM(x, qI fi) oc pm(fiIx, q)pA(x, q)
where pAl(x, q) is a prior probability and pAI(fiIx, q) is the likelihood of observing
80
:J e.

fi given the object pose (x, q). 
We will gain further purchase on pM(filx, q) by
examining the components of an oriented local feature, fi.
5.3.1 
Oriented Local Features
In this chapter, an oriented local feature is a descriptor for the pose and shape of a
local surface patch on a 3D point cloud. We describe an oriented local feature fi with
three components-
1. a shape descriptor, si,
2. a position, xi C R3 , and
3. a quaternion orientation, qi C 53.
The shape descriptor si should be invariant to position and orientation, while de-
scribing the local surface geometry of the feature. After testing different 3D shape
descriptors, we selected the Fast Point Feature Histogram (FPFH)[73], due to its
favorable performance in the presence of noise and missing data. The position xi
and orientation qi are relative to a fixed global coordinate frame; they describe the
rigid body transform which maps global coordinates to local feature coordinates.
Unit quaternions are used to describe rotations because they avoid the topological
degeneracies of other representations, and fit perfectly into the Bingham mixture
distributions we develop in this work.
Given a surface patch (i.e. a local set of 3D points P on a model M) with estimated
surface normals U at every point, we compute the transform (xi, qi) by picking an
arbitrary (fixed) model coordinate frame, and estimating the local coordinate frame
whose origin is at the center of patch P, with axes given by u, the estimated surface
normal at the center of patch P, v, the direction of maximal surface curvature 2, and
2The direction of maximal surface curvature, or principal curvature, is estimated using principal
components analysis on the neighborhood of local surface patch normals, projected into the tangent
space to the central normal vector; the principal curvature is the eigenvector corresponding to the
largest eigenvalue, and is only defined up to sign.
81

w = u x v, the cross product of u and v. An example of a local coordinate frame is
shown on the left side of figure 5-6.
Figure 5-5: Cluster Q-Images.
5.3.2 
Local Feature Likelihood
The next step in modeling pm(fiIx, q) is to discretize shape descriptor space into a
"vocabulary" Q of local shape types for each model. The reason for doing this is that
when we observe a local feature in a new point cloud, we want to know where on the
model that feature may have come from. Discretizing the local feature shapes into a
set of distinct classed will give us a simple mapping from shape class to object pose
distribution.
We perform the discretization of shape space using K-Means clustering (with
JQJ = 10 in this work) on the set of all local shape descriptors, {si} in the model
point cloud, yielding a shape vocabulary, {Q}. We then segment the model point
82
Oriented Local Feature Cluster
Q-Image
C

cloud into §2J clusters, where cluster j contains all the oriented local features in the
model whose closest vocabulary shape is Q.. Examples of three feature clusters on a
wine glass, with their local coordinate frames, is shown in the top row of figure 5-5.
For a newly observed oriented local feature, fi, we compute the local feature
likelihood, p (fi x, q) by expanding fi into components (si, xi, qi), and classifying si
into one of the shape vocabulary clusters, Qj, yielding
PU(f ix, q)
= p (xi, qi x, q, Qj)pA (Qj x, q) 
(5.1)
= pM (qi x, q, Qj)pI (xi qi, x, q, Qj)pI(Qj Ix, q)
where we can drop the dependence on x in the first term (since the orientation of a
local feature on an object shouldn't depend on the object's position in space), and
where pm(Qj x, q) is assumed to be uniform. Thus,
pm (fi Ix, q) = pNI (gi Iq, Qj )pm (xi Iqi, x, q, G ). 
(5.2)
To model pm(qi q, Qj), we consider the set of all local feature orientations on the
model from feature cluster Qj, which we visualize using the "Q-Image" transform3
for three features types in the bottom row of figure 5-5. 
We then fit a Bingham
Mixture Model (BMM)-defined in section 5.3.4--to the set of all rotations mapping
model axes into local axes, so that
pM (qi q, Qj) = p(qiq1; B3) 
(5.3)
where B3 are parameters of the BMM for feature cluster j.
To model pNI(xiIqi, x, q, Qj), we use a non-parametric technique, called local like-
lihood, to fit a distribution to the set of all translations mapping model origin to
rotated local feature origin; that is,
PM (xi Iqi, x, q, Qj) = pm (q--1 (xi - x) Iqigq-', O ). 
(5.4)
3 The Q-Image of a 3D point cloud is defined as the set of all quaternion local feature orientations;
we visualize the Q-Irnage in 3D using the axis-angle format of 3D rotation.
83

Local Likelihood is a technique introduced by Tibshirani and Hastie [85] to model the
parameters of a conditional probability distribution, p(Y X), as a smoothly varying
function of X. In our case, we wish to model the conditional local feature pose
distribution p(xlq) within a particular feature class, Qj (where xlq is shorthand for
q-1 (xi - x)lqig- 1 in equation 5.4). 
To do so, we choose a particular parametric
model for p(xlq = q') (multivariate normal distribution), with parameters (p, E).
To fit parameters, we use a locally-weighted data log-likelihood function, f(), with
Gaussian kernel K(q, qi) to weight the contribution of each (xilqi) in the model point
cloud according to how close qi is to q,
n
f(p, E; q, X, Q) = 
K(q, qi)f (p, E; xi). 
(5.5)
We use a local likelihood model in this work for its flexibility, since finding a good
parametric model for p(xlq) which works for all q's is quite difficult. An example of
p(xlq) for a particular q is shown on the right side of figure 5-6.
5.3.3 
Multi-Feature Likelihood
Given multiple observed oriented local features, {f1} 
- {(si, xi, qi)}, i 
-
1 ... k, the
local feature distribution p({fi} x, q) would be simply a product of individual local
feature distributions, HR p(fix., q), if the local features were independent given the
object pose. However, since features may overlap, we use an exponential model which
averages the log-likelihood contribution from each feature,
-Ak
p({fil x, q) = A exp 
3log p(filx, q) 
(5.6)
where A is a smoothing parameter (currently set to 0.5 in all of our experiments).
5.3.4 
Bingham Mixture Models (BMMs)
The Bingham distribution is a natural, maximum entropy model for second order
distributions on a hypersphere, 5d. 
However, we have found that the Q-Image in
a local feature distribution model will almost always be explained best by a more
84

principal
curvature
normal
(a) local feature coordinate frame
-4X
17
(b) possible
feature
positions
Figure 5-6: Given that an oriented local feature with shape type Qj has the coordinate
frame shown in (a), the range of possible feature positions is restricted to lie on the
dark band of the cup in (b).
WA.~v.
(a)
(b)
(c)
(d)
Figure 5-7: Fitting a Bingham Mixture Model (BMM). (a) A cluster of similar ori-
ented local features. (b) The local coordinate frames of the oriented local features.
(c-d) The local coordinate frames (only the axis part of the axis-angle format is vi-
sualized), along with the fitted Binghams (represented by the light bands on the two
spheres).
complex, multi-modal distribution, as one can see in figures 5-1 and 5-5.
purpose, we a Bingham Mixture Model (BMM), with PDF
fBM (x; B, a)
kS af (x; B1).
85
For this
(5.7)

error in the z-axis
1
~-0.5
E
CU
0
0 
100
error (degrees)
translation error
0.4
0.2
E 
1
0 
100
error (mm)
error in the z-axis
0.4
I0
0.2
E 
m
0
0 
100
error (degrees)
error about the z-axis
0.4
0.2
0
0 
100
error (degrees)
translation error
0.2
L0.1
E 
I 
~
U) 
A
0 
100
error (mm)
error in the z-axis
0.2
0.1
0
0 
100
error (degrees)
error about the z-axis
0.4
a 0.21
E 
i
0
0 
100
error (degrees)
translation error
0.4
02 
E 
1
0 
100
error (mm)
error in the z-axis
0.2
(D" 0.1
0
0 
100
error (degrees)
error about the z-axis
error (degrees)
translation error
0.2
0.1
0 
I 
I
0 
100
error (mm)
(a) IKEA
(b) Household
(c) PR2
(d) PR2, SCOPE
Figure 5-8: Sample error distributions (bar plots), compared to random guessing for
orientation (solid red lines). (a-c) MC-SOPE/uncluttered, (d) MC-SCOPE/cluttered
where the Br's are the component Bingham parameters and the ai's are weights.
5.3.5 
BMM Parameter Estimation via Sample Consensus
To fit a mixture model to a set of data points we must estimate the cluster param-
eters, Oj, the cluster weights, aj, and the number of clusters, k. Although iterative,
Expectation Maximization (EM) algorithms for fitting BMMs exist [67], we found
the following greedy, heuristic algorithm (based on the sample consensus framework)
to work well in practice at a much lower computational cost. The BMM sample-
consensus (BMM-SAC) algorithm starts by fitting M Binghams to M random sets of
4 points each. The Bingham B* which fits the data best under a capped loss function
(where outliers all contribute a minimum likelihood, f.min, so as not to give them too
much influence on the total fitness) is added to the mixture if it is a good enough fit
(i.e. has data likelihood > ftures). Then, the inlier points with respect to B* (those
points with likelihood greater than Emin) are removed from the training set, and the
86

1 
0.
0..8
0 0.6 
0.6-1
0.5___KEA 
(MC SOPE
-
sOPE, IKEA (er4 
-0 -- 
PR2 (MC-SOPE)
-- 
-
SOPE PR2 (err<20") 
0,3 
-
-
- IKEA (SAC-A)
--- 
SOPE, HOUSEHOLD (err<20*) 
-
Household (MC-SOPE)
0.2 
-
- - SCOPE, PR2 (err<20') 
0.1 
-
-
- Household (SAC-lA)
random (err<20*) 
0.1 
-
-
- PR2 (SAC-IA)
40 
60 
80 
-10 
1 
2 
3 
4 
5 
6 
7 
8 
9 
1C
# samples 
# samples
(a) 
(b)
Figure 5-9: (a) Search orientation accuracy of MC-SOPE and MC-SCOPE on each
dataset. Each point, (X, Y), in the figure shows the percentage Y of trials for which a
"good" pose sample was found in the top X samples. (b) Comparison to the proposal
sample distribution of SAC-IA (orientation error thresholds are the same as in (a)).
algorithm searches for another Bingham to add to the mixture. When no further
Binghams can be found, the remaining points are considered outliers, and a uniform
mixture component is added4 . A reasonable choice for the outlier threshold, emin, is
given by the uniform probability density,
Cmin 
Punif (x) = 1/A(d), 
(5.8)
where A(d) is the surface area of the hypersphere 5d.
5.4 
Experimental Results
We tested our pose estimation algorithms on three different datasets-one containing
41 rotationally-symmetric IKEA objects (mostly dishes), one containing 29 rotationally-
asymmetric household items, such as soap bottles, tools, and food containers, and one
containing 8 manipulable objects for a PR2 robot. Each dataset consisted of a set of
3D point clouds which were scanned in from real objects; however, novel point cloud
views of objects (for both training and testing) were generated in three different ways.
4 Recall that a Bingham with all its concentration parameters Ai set to zero is a uniform distri-
bution on 5d; thus, the uniform component of a BMM is also a Bingham distribution.
87

For the IKEA dataset, we used ray-tracing with additive Gaussian noise to generate
41 views of each object. For the Household dataset, we used a 3-D simulator to
emulate output from a texture-projection stereo camera pair. Then we ran a stereo
vision algorithm on the simulated images to estimate pixel depth, and extracted point
clouds from the rectified depth images for 71 views per object. For the PR,2 dataset,
we captured point clouds from the Willow Garage PR2 robot's projected light stereo
cameras. To generate 3D models, we drove the robot around each object, placed in
varying orientations on a table, collecting 34-40 views of each object; point clouds
from all the views were then aligned using an occupancy-grid approach. The PR2
dataset also contained 11 point clouds of cluttered scenes with varying configurations
of the 8 objects on a tabletop in front of the robot; we painstakingly hand-labelled
every scene with each object's true pose for testing purposes.
To fit local feature models for the objects in each dataset, we calculated normals,
local shape descriptors (FPFHs), and principal curvatures for the points in each point
cloud. After downsampling to reduce the number of oriented local features in each
model to around 2000 points, we clustered features across all views by their FPFH
using KMeans with k = 10. We then fit a Bingham Mixture Model (BMM) to the
local coordinate frames (Q-Image) in each cluster. For the purposes of testing the
MC-SOPE algorithm, we used cross-validation with 5 training and testing set pairs.
For each testing set, we used the corresponding (non-overlapping) training set to
learn FPFH clusters and BMMs. We then ran MC-SOPE on each point cloud with
N = 1000 proposal samples in the testing sets, returning the top n = 100 pose
samples for each view.
We ran the MC-SCOPE algorithm on the objects in each scene of the cluttered
PR2 dataset with N = 5000 proposal samples, returning the top n = 100 pose samples
for each object. In figure 5-10, we show examples of top pose samples for one of the
scenes.
In figure 5-8, average error histograms across all MC-SOPE tests are shown for
the three datasets, and for the cluttered PR2 dataset for the MC-SCOPE trials. For
the IKEA dataset, we show orientation error in the z-axis, since the IKEA objects
88

are all symmetric about the z-axis. For the Household and PR2 datasets, we show
orientation error in the z-axis, and also about the z-axis for samples with z-axis error
< 20 degrees. Error in translation (XYZ) for samples with z-axis error < 20 degrees
is shown for all datasets.
In figure 5-9, we show the search orientation accuracy of MC-SOPE and MC-
SCOPE on each dataset. Each point, (X, Y), in figure 5-9 shows the percentage
Y of trials for which a "good" pose sample was found in the top X samples. A
"good" sample is defined as z-axis error < 10 degrees for the IKEA dataset, and
both z-axis error < 20 degrees and about-z-axis error < 20 degrees for the Household
and PR2 datasets. Position accuracy is not measured in figure 5-9, since we saw in
figure 5-8 that most samples with small orientation error have translation error within
a few centimeters (and the average model size is about 10 cm). In figure 5-9(b),
we also compare performance on the SOPE/uncluttered datasets to the proposal5
sample accuracy of SAC-IA, the RANSAC-based alignment method in the original
FPFH paper [73]. Our method, MC-SOPE, is either comparable to or better than the
proposal method of SAC-IA on all three datasets, with the biggest improvement being
on the PR2 dataset (which has the most sensor noise). Further gains in MC-SOPE
may be acheived by incorporating some of the feature selection/pruning methods in
SAC-IA, which we have not yet explored in this work.
5.5 
Related Work
Many modern techniques6 for pose estimation of a rigid 3D object are correspondence-
based, relying on the presence of unique visual features on the object's surface so that
a rigid-body transform can be found which minimizes the sum of squared distances
between corresponding points [39, 73, 56]. Unfortunately, many common household
objects----such as dishes, tools, or furniture-do not have such uniquely-identifiable
5 The validation part of SAC-IA, which ranks each pose sample by computing an inlier percentage
over the entire observed point cloud, is left out of the experiment for a fair comparison of how each
algorithm does using only a few local features at a time.
6 including the object detection method presented in the next chapter
89

visual features (or they have too few unique features to uniquely determine a pose).
Current alternatives to the correspondence-based approach tend to be limited
in some way. Spherical harmonics can be used in an attempt to bring the object
into a "standard" reference frame [14], and tend to work better than pure moment
matching techniques. 
However, such standardization approaches may fail when a
unique reference frame can't be found, and are sensitive to noise and occlusions.
Brute force techniques using Extended Gaussian Images [37, 42] or registration [9]
must exhaustively search the space of 3D object rotations, and are currently too slow
for real-time applications. The generalized Hough transform [8] uses local geometric
information to vote for object parameters (e.g. position and orientation), and is robust
to occlusions. However, it suffers from quantization noise which can make parameter
searches in high dimensions difficult [33]. 
Geometric hashing [54] tries to alleviate
this quantization difficulty by voting among a discrete set of basis point tuples, but
it has a worst case running time of 0(n4 ) for n 3D model points. Classification-based
techniques, such as [74], which classify object observations by viewpoint, appear to
work well when the object is perfectly segmented out of the scene, but are sensitive
to clutter and occlusions.
Our method can be most accurately described as a hybrid between the Generalized
Hough transform and RANSAC, in that we try to model the relationship between the
poses of local features and the pose of the model in a random sampling framework.
However, unlike the Hough transform, our model is continuous, which allows us to
avoid discretization issues and perform extremely fast, constant time inference.
5.6 
Conclusion
Robust recognition and pose estimation of common household objects is an important
capability for any personal service robot. However, real-world scenes often contain a
great deal of clutter and occlusion, making the estimation task difficult. Therefore,
it is necessary to infer as much as possible from small object features, such as the
oriented surface patches we considered in this work. Although our results on both
90

uncluttered and cluttered datasets demonstrated the applicability of our approach to
3D point cloud models, the full power of 3D oriented local feature distributions will
only be seen when more feature types (based on color, edges, local image appearance,
etc.) are added to the model. Then, the pose of objects with unique visible features,
such as the logo on a mug, will be locked down immediately, while observations of
non-unique features such as the ones considered in this chapter will still lead to a
much smaller set of possible object poses that the algorithm will ultimately need to
consider.
In the next chapter, we will present a full object detection system with many of
these features. Although it will draw inspiration from the methods of this chapter
in that it also uses the Bingham distribution to represent orientation uncertainty, it
differs both in its high-level architecture and in the way it uses the Bingham--the
Bingham was used in this chapter as a distribution on groups of features' orientations,
while in the next chapter it is used as a distribution on individual feature orientations.
91

(a) original
scene
(b) segmentation
(for 
illus-
tration
only)
(f) hypothesis 1 
(g) hypothesis 2 
(h) hypothesis
11
(1) hypothesis 
(m) hypothesis 
(n) hypothesis 3
1 
2
(r) hypothesis 1 
(s) hypothesis 2 
(t) hypothesis
(c) hypothesis 1 
(d) hypothesis 2 
(e) hypothesis
7
(i) hypothesis 1
(o) hypothesis
(j) hypothesis 2 
(k) hypothesis
5
(p) hypothesis 2 
(q) hypothesis 3
1
(u) hypothesis 1 
(v) hypothesis 2 
(w) hypothesis
3
Figure 5-10: Top sample poses for 7 objects found by the MC-SCOPE algorithm for
a cluttered scene. When a "good" pose sample is found within the top 20 samples,
the caption under the best sample is shown in bold.
92

Chapter 6
A Discriminative Method for 3-D
Object Detection
Full, category-level object recognition has been a long-standing goal for the Al corn-
munity. Much progress has been made over the years, and accurate recognition sys-
tems can now be made for constrained environments, such as for self-driving cars,
or factory assembly line robots, even though general-purpose, category-level object
recognition remains elusive. In household robotics, where manipulating everyday ob-
jects is the primary goal, the robotics community has recently shifted to a much
simpler goal: recognizing known object instances, and estimating their 3-D positions
and orientations in space (so that the robot can manipulate them!). Even before the
introduction of the Microsoft Kinect camera in 2010, much progress had already been
made towards this goal--starting with the geometric, model-based object localization
work in the 1980s [24, 34, 84], continuing in work on spin images in the 1990s [39],
which used 3-D geometric features, and more recently, using SIFT features on im-
age data [19]. Since 2010, progress towards object instance recognition has rapidly
accelerated, as nearly every robotics research group in the world now has access to
good-quality RGB-D data for the first time in history. This has given us, as object
recognition researchers, a unique opportunity to finally solve one of the most press-
ing needs in robotics -the need for reliable object instance recognition and 3-D pose
estimation.
93

But there are many challenges along the way. Real scenes are full of clutter and
ambiguity. Many common objects do not have the unique local features which we
have come to rely upon in object recognition, and even those that do may not have
visible unique features from every viewpoint. Objects can be shiny, or transparent.
Data from the Kinect and related sensors isn't perfect, and their noise process can be
complex to model. A complete system must combine both geometric and color infor-
mation, must reason about the relationships between objects (e.g., to avoid putting
two objects in the same space), and must report confidence in its predictions, in-
cluding any ambiguities that it detects. Sometimes this will mean returning several
different possible scene interpretations (sets of object detections), and sometimes this
will just mean returning a local model of object pose uncertainty. It must also be
fast. No existing system does all of these things well yet.
In this chapter, we will present a system with two main contributions that we
hope will bring the field closer to its goal of reliable object instance recognition in
clutter. The first contribution is a novel object alignment algorithm, called Bing-
ham Procrustean Alignment (BPA), which uses sparse (but not necessarily unique),
oriented 3-D features to very quickly align an object model with an observed scene.
BPA uses point correspondences between oriented features to derive a probability
distribution over possible model poses. The orientation component of this distribu-
tion, conditioned on the position, is shown to be a Bingham distribution. This result
also applies to the classic problem of least-squares alignment of point sets, when point
features are orientation-less, and gives a principled, probabilistic way to measure pose
uncertainty in the rigid alignment problem.
The second contribution is a sequence (i.e., a cascade) of highly discriminative
model placement evaluation functions, which combine many different feature types-
from positions and surface normals to RGB and depth image edges-with a sophis-
ticated sensor noise model. The combination of a robust object alignment algorithm
together with improved evaluation functions leads to state-of-the-art performance on
scenes with high clutter, such as in figure 6-1. The work in this chapter was origi-
nally published in the proceedings of the 2013 IEEE/RSJ International Conference
94

on Intelligent Robots and Systems (IROS) [30].
Although the object detection system in this chapter is loosely inspired by the
generative methods of the previous chapter in that it also uses the Bingham distribu-
tion to represent orientation uncertainty, it differs both in its high-level architecture
and in the way it uses the Bingham-the Bingham was used in the previous chapter
as a distribution on groups of features' orientations, while in this chapter it is used as
a distribution on individual feature orientations. Furthermore, this chapter provides
a complete, discriminative object detection algorithm, whereas the previous chapter's
methods were restricted to making initial guesses of object placements only.
6.1 
Alignment
Detecting known, rigid objects in RGB-D images relies on being able to align 3-D
object models with an observed scene. If alignments are inconsistent or inaccurate,
detection rates will suffer. In noisy and cluttered scenes (such as shown in figure 6-
1), good alignments must rely on multiple cues, such as 3-D point positions, surface
normals, curvature directions, edges, and image features. Yet before the work in this
thesis there was no existing alignment method (other than brute force optimization)
that could fuse all of this information together in a meaningful way.
We have seen that the Bingham distribution is a good fit mathematically for the
space of 3-D orientations (represented by unit quaternions). In this chapter, we derive
a surprising result connecting the Bingham distribution to the classical least-squares
alignment problem, which allows our new system to easily fuse information from
both position and orientation information in a principled, Bayesian alignment system
which we call Bingham Procrustean Alignment (BPA).
6.1.1 
Background
Rigid alignment of two 3-D point sets X and Y is a well-studied problem-one seeks
an optimal (quaternion) rotation q and translation vector t to minimize an alignment
cost function, such as sum of squared errors between corresponding points on X and
95

/
Figure 6-1: Object detections found with our system, along with the feature cor-
respondences that BPA used to align the model. Surface features are indicated by
red points, with lines sticking out of them to indicate orientations (red for normals,
orange for principal curvatures). Edge features (which are orientation-less) are shown
by magenta points.
Y. Given known correspondences, t and q can be found in closed form with Horn's
method [36]. If correspondences are unknown, the alignment cost function can be
specified in terms of sum-of-squared distances between nearest-neighbor points on X
and Y, and iterative algorithms like ICP (Iterative Closest Point) are guaranteed to
reach a local minimum of the cost function [9]. During each iteration of ICP, Horn's
method is used to solve for an optimal t and q given a current set of correspondences,
and then the correspondences are updated using nearest neighbors given the new
pose.
ICP can be slow, because it needs to find dense correspondences between the two
point sets at each iteration. Sub-sampling the point sets can improve speed, but only
at the cost of accuracy when the data is noisy. Another drawback is its sensitivity to
outliers-for example when it is applied to a cluttered scene with segmentation error.
Particularly because of the clutter problem, many modern approaches to align-
ment use sparse point sets, where one only uses points computed at especially unique
keypoints in the scene. These keypoint features can be computed from either 2-D
(image) or 3-D (geometry) information, and often include not only positions, but also
orientations derived from image gradients, surface normals, principal curvatures, etc.
96

However, these orientations are typically only used in the feature matching and pose
clustering stages, and are ignored during the alignment step.
Another limitation is that the resulting alignments are often based on just a,
few features, with noisy position measurements, and yet there is very little work on
estimating confidence intervals on the resulting alignments. This is especially difficult
when the features have different noise models- for example, a feature found on a flat
surface will have a good estimate of its surface normal, but a high variance principal
curvature direction, while a feature on an object edge may have a noisy normal, but
precise principal curvature. Ideally, we would like to have a posterior distribution over
the space of possible alignments, given the data, and we would like that distribution
to include information from feature positions and orientation measurements, given
varying noise models.
As we will see in the next section, a full joint distribution on t and q is difficult to
obtain. However, in the original least-squares formulation, it is possible to solve for
the optimal t* independently of q*, simply by taking t* to be the translation which
aligns the centroids of X and Y. Given a fixed t*, solving for the optimal q* then
becomes tractable. In a Bayesian analysis of the least-squares alignment problem, we
seek a full distribution on q given t, not just the optimal value, q*. That way we can
assess the confidence of our orientation estimates, and fuse p(qlt) with other sources
of orientation information, such as from surface normals.
Remarkably, given the common assumption of independent, isotropic Gaussian
noise on position measurements (which is implicit in the classical least-squares for-
mulation), we can show that p(qlt) is a quaternion Bingham distribution. This result
makes it easy to combine the least-squares distribution on q t with other quaternion
Bingham distributions from feature orientations (or prior distributions), since (as we
have seen in previous chapters) the quaterion Bingham is a useful distribution for
encoding uncertainty on 3-D rotations represented as unit quaternions.
The mode of the least-squares Bingham distribution on q t will be exactly the
same as the optimal orientation q* from Horn's method. When other sources of
orientation information are available, they may bias the distribution away from q*.
97

2 
1 
22 
2
1 
10D@
1 
0 
+ 
19 
3
033
0------ 
0
3 
3 
3 
Xi0 
Yi
Figure 6-2: Rigid alignment of two point sets.
Thus, it is important that the concentration (inverse variance) parameters of the
Bingham distributions are accurately estimated for each source of orientation infor-
mation, so that this bias is proportional to confidence in the measurements. (See
section 6.2.2 for an example.)
We use our new alignment method, BPA, to build an object detection system
for known, rigid objects in cluttered RGB-D images. Our system combines infor-
mation from surface and edge feature correspondences to improve object alignments
in cluttered scenes (as shown in figure 6-1), and acheives state-of-the-art recognition
performance on both an existing Kinect data set [2], and on a new data set containing
far more clutter and pose variability than any existing data set1 .
6.2 
Bingham Procrustean Alignment
Given two 3-D point sets X and Y in one-to-one correspondence, we seek a distri-
bution over the set of rigid transformations of X, parameterized by a (quaternion)
rotation q and a translation vector t. Assuming independent Gaussian noise models
on deviations between corresponding points on Y and (transformed) X, the condi-
'Most existing data sets for 3-D cluttered object detection have very limited object pose variability
(most of the objects are upright), and objects are often easily separable and supported by the same
flat surface.
98
original points
shifted
shifted + rotated

tional distribution p(qlt, X, Y) is proportional to p(X, Yjq, t)p(q t), where
p(X, Yjq, t) =7 
p(xi, yi1 q, t) 
(6.1)
= N(Q(xi + t) - yi; 0, E) 
(6.2)
given that Q is q's rotation matrix, and covariances Ei.
Given isotropic noise models 2 on point deviations (so that E is a scalar times
the identity matrix), p(xi, y Iq, t) reduces to a 1-D Gaussian PDF on the distance
between yj and Q(xi + t), yielding
p(xi, y I q, t) = N (I Q (xi + t) - yil11; 0, o-3)
= N(dj; 0, o-i)
where di depends on q and t.
Now consider the triangle formed by the origin (center of rotation), Q(xi + t) and
yi, as shown on the left of figure 6-3. By the law of cosines, the squared-distance
between Q(xi + t), and yj is d2 = a2 + b2 - 2abcos(O), which only depends on q via
the angle 0 between the vectors Q(xi + t) and yi. (We drop the i-subscripts on d, a,
b, and 0 for brevity.) We can thus replace p(xi, y Iq, t) with
p(xi, yj10, t) = 
exp 
2bco } 
(6.3)
which has the form of a Von-Mises distribution on 0.
Next, we need to demonstrate how 0 depends on q. Without loss of generality,
assume that yj points along the axis (1, 0, 0). When this is not the case, the Bingham
distribution over q which we derive below can be post-rotated by any quaternion
which takes (1, 0, 0) to yi/Ilyill.
Clearly, there will be a family of q's which rotate xi + t to form ail angle of 0 with
yi, since we can compose q with any rotation about xi + t and the resulting angle
with yj will still be 0. To demonstrate what this family is, we first let s be a unit
quaternion which rotates xi + t onto yj's axis, and let x' = S(xi + t), where S is s's
2 This is the implicit assumption in the least-squares formulation.
99

Q(Xi+t)
a 
|
b 
y
d2a 2 + b 2 - 2ab cos 0
n 3
aa 
n 2
a 
/ 
12
|d
b 
yi 
xi
nii n2 n13]
Figure 6-3: Distance between corresponding points as a function of orientation.
rotation matrix. Then, let r (with rotation matrix R) be a quaternion that rotates
x' to Q(xi + t), so that q = r o s. Because yj and x' point along the axis (1, 0, 0), the
first column of R, r1, will point in the direction of Q(xi + t), and form an angle of 0
with yi, as shown on the right side of figure 6-3. Thus, di - (1, 0, 0) = nCn = cos 0.
The rotation matrix of quaternion r =(ri, 
r 2, r 3 , r4) is
r+r 
-r3-r 
2r 2 r 3 -2rir4 
2r2r4+2r1r3
R 
2r 2r3+2rir4 
r2-r2+r2-r2 
2r3r 4-2rir2
L 2r2r4-2rir3 
2r 3r4+2rir2 
r 2-r 
2 -r2+r2
Therefore, cos 0 = d, 
= 
2 + r2 - r- 
1
2r2 -22r
We can now make the following claim about p(Xi, yiIq, t):
Claim 6.1. Given that yj lies along the (1, 0, 0) axis, then the probability density
p(xi, yjIq, t) is proportional to a quaternion Bingham density on q with parameters
2ab
A =-(- 
2,
2ab
- 2,0)
0o0o1
and 
V= 100
0 10_
O=S 
WOS
where "o" indicates column-wise quaternion multiplication.
100

Proof. The Bingham density in claim 6.1 is given by
3
p(qlAV ) 
I exp 
Aj((wj o s)Tq) 2  
(6.4)
j=1
1 
r2ab 
2ab .
F exp 
2 r 
2 
r 
(6.5)
F 
01 
3 
r
1 
rabcosO0
= exp 
(6.6)
since (wj o s)Tq = wjT(q o s- 1 ) 
wjTr, and cos 0 = 1 -
2,r -
2r2. Since (6.6) is
proportional to (6.3), we conclude that p(q A, V) oc p(xi, y Iq, t), as claimed.
Claim 6.2. Let s' be a quaternion that rotates (1, 0, 0) onto the axis of yj (for
arbitrary yi). Then the probability density p(xi, yjIq, t) is proportional to a Bingham
density on q with parameters
2ab 
2ab 
0[0o ~
A 2 
2 
,0) 
and 
V - s'o 
0 
0] o s 
(6.7)
where "o" indicates column-wise quaternion multiplication.
As explained above, the distribution on q from claim 6.1 must simply be post-
rotated by s' when yj is not aligned with the (1, 0, 0) axis. The proof is left to the
reader. Putting it all together, we find that
p(q t, X, Y) oc 
Bingham(q; Aj, VI) 
-p(q t) 
(6.8)
Bingham(q; A, f) -p(q t) 
(6.9)
where Ai and Vi are taken from claim 6.2, and where A and V are computed from
the formula for multiplication of Bingham PDFs (section 2.11).
Equation 6.9 tells us that, in order to update a prior on q given t after data
points X and Y are observed, one must simply multiply the prior by an appropriate
Bingham term. Therefore, assuming a Bingham prior over q given t (which includes
the uniform distribution), the conditional posterior, p(q t, X, Y) is the PDF of a
Bingham distribution.
101

To demonstrate this fact, we relied only upon the assumption of independent
isotropic Gaussian noise on position measurements, which is exactly the same as-
sumption made implicitly in the least-squares formulation of the optimal alignment
problem. This illustrates a deep and hitherto unknown connection between least-
squares alignment and the quaternion Bingham distribution, and paves the way for
the fusion of orientation and position measurements in a wide variety of applications.
6.2.1 
Incorporating Orientation Measurements
Now that we have shown how the orientation information from the least-squares
alignment of two point sets X and Y is encoded as a Bingham distribution, it becomes
trivial to incorporate independent orientation measurements at some or all of the
points, provided that the orientation noise model is Bingham. Given orientation
measurements (Ox, Oy),
p(q t, XY, Ox, Oy)
c p(X, Y, Ox, Oylq, t) -p(qlt)
= P(X, Yjq,t) -p(Ox,Oyjq, t) -p(qjt).
Similarly as in equation 6.9, p(Ox, Oy q, t) is the product of quaternion Bingham
distributions from corresponding orientation measurements in (Ox, Oy), and so the
entire posterior p(q t, X, Y, Ox, Oy) is Bingham (provided as before that the prior
p(qlt) is Bingham).
6.2.2 
Estimating the Uncertainty on Feature Orientations
When we extract surface features from depth images, we estimate their 3-D orienta-
tions from their normals and principal curvature directions by computing the rotation
matrix R = [n p p'], where n is the normal vector, p is the principal curvature vec-
tor, and p' is the cross product of n and p. We take the quaternion associated with
this rotation matrix to be the feature's estimated orientation.
These orientation estimates may be incredibly noisy, not only due to typical sens-
ing noise, but because on a flat surface patch the principal curvature direction is
102

undefined and will be chosen completely at random. Therefore it is extremely useful
to have an estimate of the uncertainty on each feature orientation that allows for the
uncertainty on the normal direction to differ from the uncertainty on the principal
curvature direction. Luckily, the Bingham distribution is well suited for this task.
To form such a Bingham distribution, we take the quaternion associated with R
to be the mode of the distribution, which is orthogonal to all the vi vectors. Then,
we set v 3 to be the quaternion associated with R' = [n - p - p'], which has the
same normal as the mode, but reversed principal curvature direction. In quaternion
form, reversing the principal curvature is equivalent to the mapping:
(qi, q2, q3, q4) 
--- (- q2, q, 
q4, -q3) 
-
We then take v, and v 2 to be unit vectors orthogonal to the mode and v 3 (and each
other). Given these vi's, the concentration parameters A, and A2 penalize deviations
in the normal vector, while A3 penalizes deviations in the principal curvature direction.
Therefore, we set A1 = A2 = / (we use K = -100 
in all our experiments), and we
use the heuristic A3 = max{10(1 - cI/c2 ), i}, where ci/c
2 is the ratio of the principal
curvature eigenvalues 3.
When the surface is completely flat, ci = c2 and A3 = 0,
so the resulting Bingham distribution will be completely uniform in the principal
curvature direction. When the surface is highly curved, ci > c2 , so A3 will equal ,
and deviations in the principal curvature will be penalized just as much as deviations
in the normal.
6.2.3 
The Alignment Algorithm
To incorporate our Bayesian model into an iterative ICP-like alignment algorithm,
one could solve for the maximum a posteriori (MAP) position and orientation by
maximizing p(q, t X, Y, .. .) with respect to q and t. However, it is often more de-
sirable to draw samples from this posterior distribution in order to maximize the
coverage of the proposed alignments.
3The principal curvature direction is computed with an eigen-decomposition of the covariance of
normal vectors in a neighborhood about the feature.
103

The joint posterior distribution p(q, tIZ)--where Z contains all the measurements
(X, Y, Ox, Oy ... 
.)-can be broken up into p(qlt, Z)p(tlZ). 
Unfortunately, writing
down a closed-form distribution for p(tIZ) is difficult. But sampling from the joint
distribution is easy with an importance sampler, by first sampling t from a proposal
distribution-for example, a Gaussian centered on the optimal least-squares trans-
lation (that aligns the centroids of X and Y)-then sampling q from p(qlt, Z), and
then weighting the samples by the ratio of the true posterior (from equation 6.2) and
the proposal distribution (e.g., Gaussian times Bingham).
We call this sampling algorithm Bingham Procrustean Alignment (BPA). It takes
as input a set of (possibly oriented) features in one-to-one correspondence, and returns
samples from the distribution over possible alignments. In section 6.6, we will show
how BPA can be incorporated into an iterative alignment algorithm that re-computes
feature correspondences at each step and uses BPA to propose a new alignment given
the correspondences.
6.3 
A New Characterization of the Quaternion Bing-
ham Distribution
If any two sets of 3-D points in one-to-one correspondence (endowed with a Gaussian
noise model on the error between corresponding points) defines a quaternion Bingham
distribution on the space of possible 3-D orientations of one set of points with respect
to the other, then what about the reverse statement? Does every quaternion Bingham
distribution have a pair of point sets and a Gaussian noise model that generates it? In
other words, can one generate all possible quaternion Bingham distributions (covering
the space of possible A's and V's) by moving around the points? And if the answer is
yes, then how many pairs of points does it take to cover quaternion Bingham space?
As it turns out, the answers to those questions are "yes" and "3".
Theorem 6.3. For every quaternion Bingham distribution (with parameters A and
V), there exists a set of three pairs of points {(x 1 , yi), (x 2 , y2), (x 3 , y3)} with unit
104

error variance (Or 
= 1) that generates the given quaternion Bingham distribution.
Proof. Given quaternion Bingham parameters A, < A2 < A3 < 0 and V = [v1 v 2 v3 ]
with VTV = I. Each pair of points (xi, y) will generate a Bingham with PDF of
the form I exp[xT(a.(wiiwT + wi2 w2))x]. When the three Binghams are combined,
their PDFs are multiplied, yielding an exponent of the form xTCx, where
C =a1(wrwf1 + w2wT2) + a2(w2wi + w22w 
) + a(w31wT1 +w32w2
Now let
1
OZ=-(A,
2
1
Z2  =- (A,
2
wil =Vi
W12 =V
2
w 2 1 
-
v1
W22 = V3 .
+ A2 -
A3 )
-A2 + A3)
We know that a, < a 2 < 0 since A < A2 < A3  
0. For a 3 , w 3 1 , and w 3 2 , there are
two cases to consider (to ensure that a 3 is non-positive).
Case 1: If A1 - A2 -
A3  
0, then let
1
a3  
-(A, 
- A2 -
A3)
2
W31 
V1
w 3 2 = V4
where v 4 completes the basis with (v 1 , v 2 , v 3 ). Then the C matrix of the combined
Bingham is
C =aI(viv + v 2v2) + a 2 (vivf + v3 vi') + a 3 (vivI + v 4v)
(6.10)
The eigenvectors of C are vi, v 2 , v 3 , and v 4 , with eigenvalues4 A1, A,, A', A given
4 These eigenvectors and eigenvalues can be easily verified by multiplying C by each vi and using
the fact that the vi's are orthonormal.
105

by
1
A 
=t 
+2 
-
-(3A - A2 -
3 ),
2
1 + 
1
2
1
3's = a 2 = -( 
-
2+ A3 ), and
2
1
A4 
= a 
-3),2
respectively. Now, to put the resultant Bingham into standard form, we eliminate
the fourth spectral component by subtracting A' from each eigenvalue, yielding
A- 
A' 
A,
A/ 
At 
A2
-/ A' 
A3
A- 
At 
0,
as desired.
Case 2: If A, - A2 - A3 > 0, then let
1
a3 = -(-A,
2
W31 = V 2
w 3 2 = V3 .
+ A2
A3)
The C matrix of the combined Bingham then becomes
C =a
1(viv i + v 2v) 
+ a 2(vivI + v 3v3) + a 3 (v 2v2 + v 3v )
with eigenvectors v1 , v 2 , v3 , and v 4 , and eigenvalues
(6.11)
= a 1 + a2
= al1+ 
ft3
-3 
V2 +a 3
= A3
= 0
106
A/I
= A2
A/1

as desired.
We have just proven that the above a's and w's will generate the correct Bingham
parameters (A, V). So all that remains to be shown is that one can find pairs of points
(xi, y) to generate the component Binghams with those oz's and w's.
To generate a Bingham with first two axes wi, w 2 , the quaternions s (that rotates
xi onto [1 0 0]T) and s' (that rotates [1 0 0 ]T onto yi) must satisfy:
s'o (0, 0, 1, 0) o s = wi
s' o (0, 0, 0, 1) o s = w 2 -
Thus,
s / 
(-S3, 84, 81, -2) 
= W, 
(6.12)
s' o (-s4, -s3 , 
S 2 , 
sI) = w 2.
(6.13)
Left-multiphiying by (s')-- and substitution for si, s2, 83, and S4 yields a system of
four linear equations in four unknowns for s':
W1 1 -
W 2 2  
W 1 2 + W2 1  
W1 3 + W24 
W1 4 -
W 2 3  
Si 
0
W 1 2 + W2 1 
W2 2 -
W 
W2 3 -
W 14  
W13 + W2 4  
s 
0
2. 
(6.14)
W13 -
W 2 4 
W14 + W23 
-WII 
-
W22 
W 2 1 -
W1 2  
8/ 
0
W 1 4 + W 2 3 
W2 4 -
W13 
W12 -
W21 
-WI 
-
W 2 2  
s'/ 
0
The matrix on the left can be shown to have determinant zero (using the fact that w,
and w 2 are orthonogonal unit vectors), which means that its nullspace is a subspace
of rank at least one. Therefore, a solution s' can always be found of unit length. Once
a s' is found, we can plug it into equation 6.12 to solve for s.
Finally, given s and s', let S and S' be their 3x3 rotation matrices. Then let yi
equal the first column of S', so that S' 
= yi, and let xi equal -o 
times the
ai/2 
Id-ai/2~ 
S i(ic
first row of S, so that ST 
0 
= xi, which means that 
=Sx (since s
.- 0 
1 
=- 
0 
.
is orthogonal). Plugging a = 1, b = -ai/2, and - = 1 into equation 6.7 yields a
component Bingham with shared concentration parameter cai and direction vectors
w, and w 2 , as desired. 
E
107

Figure 6-4: The 18 objects in our new Clutter data set.
6.4 
Building Noise-Aware 3-D Object Models
Our first step in building a system to detect known, rigid objects-such as the ones
in figure 6-4-is to build complete 3-D models of each object. However, the end goal
of model building is not just to estimate an object's geometry correctly. Rather,
we seek to predict what an RGB-D sensor would see, from every possible viewing
angle of the object. To generate such a predictive model, we will estimate both
the most likely observations from each viewing angle, and also the degree of noise
predicted in those measurements. That way, our detection system will realize that
depth measurements near object boundaries, on reflective surfaces, or on surfaces
at a high oblique angle with respect to the camera, are less reliable than front-on
measurements of non-reflective, non-edge surface points.
In our model-building system, we place each object on a servo-controlled turntable
in 2-3 resting positions and collect RGB-D images from a stationary Kinect sensor at
100 turntable increments, for a total of 60-90 views. We then find the turntable plane
in the depth images (using RANSAC), and separate object point clouds (on top of
the turntable) from the background. Next we align each set of 30 scans (taken of the
object in a single resting position) by optimizing for the 2-D position of the turntable's
108

center of rotation, with respect to an alignment cost function that measures the sum-
of-squared nearest-neighbor distances from each object scan to every other scan. We
then use another optimization to solve for the 6-dof translation + rotation that aligns
5
the 2-3 sets of scans together into one, global frame of reference
After the object scans are aligned, we compute their surface normals, principal
curvatures, and FPFH features [73], and we use the the ratio of principal curvatures to
estimate the (Bingham) uncertainty on the quaternion orientation defined by normals
and principal curvature directions at each point6 . We then use ray-tracing to build a 3-
D occupancy grid model, where in addition to the typical probability of occupancy, we
also store each 3-D grid cell's mean position and normal, and variance on the normals
in that cell7 . We then threshold the occupancy grid at an occupancy probability of 0.5,
and remove interior cells (which cannot be seen from any viewing angle) to obtain
a full model point cloud, with associated normals and normal variance estimates.
We also compute a distance transform of this model point cloud, by computing the
distance fromn the center of each cell in the occupancy grid to the nearest model point
(or zero if the cell contains a model point).
Next, for a fixed set of 66 viewing angles across the view-sphere, we estimate range
edges-points on the model where there is a depth discontinuity in the predicted
range image seen from that view angle. We also store the minimum distance from
each model point to a range edge for each of the 66 viewing angles. Using these
view-dependent edge distances, along with the angles between surface normals and
viewpoints, we fit sigmoid models across the whole data set to estimate the expected
noise on range measurements and normal estimates as functions of (1) edge distance,
and (2) surface angle, as shown in figure 6-5.
'In ongoing work, we are working to use BPA in this step.
6The idea is to capture the orientation uncertainty on the principal curvature direction by mea-
suring the "flatness" of the observed surface patch; see section 6.2.2 for details.
'In fact, we store two "view-buckets" per cell, each containing an occupancy probability, a po-
sition, a normal, and a normal variance, since on thin objects like cups and bowls, there may be
points on two different surfaces which fall in the same grid cell.
109

0.01
0.005.
0
0.2
.1
0
0 
0.5 
1 
0 
0.02 
0.04
surface angle 
edge distance
Figure 6-5: Our noise models predict range and normal errors (standard deviations)
as functions of surface angle and edge distance (both with respect to the viewpoint).
6.5 
Learning Discriminative Feature Models for
Detection
Similarly to other recent object detection systems, our system computes a set of
feature model-placement-score functions, in order to evaluate how well a given model
placement hypothesis fits the scene according to different features, such as depth
measurements, surface normals, edge locations, etc. In our early experiments with
object detection using the generative object models in the previous section, the system
was prone to make mis-classification errors, because some objects scored consistently
higher on certain feature scores (presumably due to training set bias). Because of
this problem, we trained discriminative, logistic regression models on each of the
score components using the turntable scans with true model placements as positive
training examples and a combination of correct object / wrong pose and wrong object
/ aligned pose as negative examples. Alignments of wrong objects were found by
running the full object detection system (from the next section) with the wrong
object on the turntable scans. By adding an (independent) discriminative layer to
each of the feature score types, we were able to boost the classification accuracy of
our system considerably.
110

Extract features 
Output model
RGB-D input 
Find feature 
For each sample: 
Remove 
ddant 
... 
placement samples
(nomals, PCs, Oft 
-0 
correspondences 
-s 
pls(Withsces
edges, superpixes) 
segment
Sa 
em 
e 
correspondences 
Align with gradients
cluster poes 
Repeat 
Align with BPA
Accept If score 
samples
samples.
Figure 6-6: Single object detection pipeline.
6.6 
Detecting Single Objects in Clutter
The first stages of our object detection pipeline are very similar to many other state-
of-the-art systems for 3-D object detection, with the exception that we rely more
heavily on edge information. We are given as input an RGB-D image, such as from
a Kinect. If environmental information is available, the image may be pre-processed
by another routine to crop the image to an area of interest, and to label background
pixels (e.g., belonging to a supporting surface).
As illustrated in figure 6-6, our algorithm starts by estimating a dense set of
surface normals on the 3-D point cloud derived from the RGB-D image. From these
surface normals, it estimates principal curvatures and FPFH features. In addition, it
finds and labels three types of edges: range edges, image edges, and curvature edges-
points in the RGB-D image where there is a depth discontinuity, an image intensity
discontinuity8, or high negative curvature. This edge information is converted into an
edge image, which is formed from a spatially blurred, weighted average of the three
edge pixel masks. Intuitively, this edge image is intended to capture the relative
likelihood that each point in the image is part of an object boundary. Then, the
algorithm uses k-means to over-segment the point cloud based on positions, normals,
and spatially-blurred colors (in CIELAB space) into a set of 3-D super-pixels.
Next, the algorithm samples possible oriented feature correspondences from the
scene to the model9 . Then, for each correspondence, a candidate object pose is gen-
'We use the Canny edge detector to find image edges.
'We currently use only FPFH correspondences in the first stage of detection as we did not find
the addition of other feature types, such as SIFT [57] or SHOT [86], to make any difference in our
111

Figure 6-7: Examples of objects correctly aligned by BPA with only two correspon-
dences.
erated using BPA. Given a set of sampled model poses from single correspondences,
we then reject samples for which more than 20% of a subset of 500 randomly selected
model points project into free space-places where the difference between observed
range image depth and predicted model depth is above 5cm. Next, we run a pose clus-
tering stage, where we group correspondences together whose sampled object poses
are within 2.5cm and 7r/16 radians of one another. After pose clustering, we reject
any sample with less than two correspondences, then re-sample object poses with
BPA.
At this stage, we have a set of possible model placement hypotheses, with at
least two features correspondences each. Because BPA uses additional orientation
information, two correspondences is often all it takes to lock down a very precise
estimate of an object's pose when the correspondences are correct (Figure 6-7).
We proceed with a second round of model placement validation and rejection, this
time using a scoring function that includes (1) range and normal differences, which are
computed by projecting a new subset of 500 randomly-selected model points into the
observed range image, (2) visibility-the ratio of model points in the subset that are
unoccluded, (3) edge likelihoods, computed by projecting the model's edge points from
the closest stored viewpoint into the observed edge image, and (4) edge visibility-the
ratio of edge points that are unoccluded. Each of the feature score components is
computed as a truncated (so as not to over-penalize outliers), average log-likelihood
of observed features given model feature distributions. For score components (1) and
detection rates.
112

(3), we weight the average log-likelihood by visibility probabilities, which are equal to
10
1 if predicted depth < observed depth, and N(Adepth; 0, o-wi)/N(O; 0, 1) otherwise
After rejecting low-scoring samples in round 2, we then refine alignments by re-
peating the following three steps:
1. Assign observed super-pixel segments to the model.
2. Align model to the segments with BPA.
3. Accept the new alignment if the round 2 model placement score has improved.
In step (1), we sample a set of assigned segments according to the probability that each
segment belongs to the model, which we compute as the ratio of segment points (sam-
pled uniformly from the segment) that are within 1cm in position and r/16 radians
in normal orientation from the closest model point. In step (2), we randomly extract
a subset of 10 segment points from the set of assigned segments, find nearest neighbor
correspondences from the keypoints to the model using the model distance transform,
and then use BPA to align the model to the 10 segment points. Segment points are
of two types-surface points and edge points. We only assign segment edge points
to model edge points (as predicted from the given viewpoint), and surface points to
surface points. Figures 6-1 and 6-8 show examples of object alignments found after
segment alignment, where red points (with red normal vectors and orange principal
curvature vectors sticking out of them) indicate surface point correspondences, and
magenta points (with no orientations) are the edge point correspondences".
After round 2 alignments, the system removes redundant samples (with the same
or similar poses), and then rejects low-scoring samples using the scores found at the
end of the segment alignment process. Then, it performs a final, gradient-based align-
ment, which optimizes the model poses with a local hill-climbing search to directly
maximize model placement scores. Since this alignment step is by far the slowest, it is
critical that the system has performed as much alignment with BPA and has rejected
as many low-scoring samples as possible, to reduce the computational burden.
'OWe use o%5 = 1cm in all of our experiments.
"In future work, we plan to incorporate edge orientations as well.
113

Finally, the system performs a third round of model placement evaluation, then
sorts the pose samples by score and returns them. This third round of scoring includes
several additional feature score components:
" Random walk score-starting from an observed point corresponding to the
model, take a random walk in the edge image (to stay within predicted ob-
ject boundaries), then measure the distance from the new observed point to the
closest model point.
* Occlusion edge score-evaluate how well model occlusion edges (where the
model surface changes from visible to occluded) fits the observed edge image.
" FPFH score-computes how well observed and model FPFH features match.
" Segment score-computes distances from segment points to nearest model points.
" Segment affinity score-measures how consistent the set of assigned segments is
with respect to predicted object boundaries (as measured by the observed edge
image, and by differences in segment positions and normals).
The random walk, occlusion edge, segment, and segment affinity scores all aim to
evaluate how well the model placement fits with object boundary cues in the scene,
while the FPFH score evalutes the similarity between local shapes on the model and
the scene.
6.7 
Detecting Multiple Objects in Clutter
To detect multiple objects in a scene, we run the individual object detector from the
previous section to obtain the 50 best model placements for each model, along with
their individual scores. Then, following Aldoma et. al [21, we use simulated annealing
to optimize the subset of model placements (out of 50 x N for N models) according to
a multi-object-placement score, which we compute as a weighted sum of the following
score components: 
(1) the average of single object scores, weighted by the number
of observed points each object explains, (2) the ratio of explained / total observed
114

'I/I
N
Figure 6-8: Object detections found with our system, along with the feature cor-
respondences that BPA used to align the model. Surface features are indicated by
red points, with lines sticking out of them to indicate orientations (red for normals,
orange for principal curvatures). Edge features (which are orientation-less) are shown
by magenta points.
points, and (3) a small penalty for the total number of detected objects. We also
keep track of the top 100 multi-object-placement samples found during optimization,
so we can return a set of possible scene interpretations to the user (in the spirit of
interpretation tree methods [351). This is particularly useful for robot vision systems
because they can use tracking, prior knowledge, or other sensory input (like touch)
to provide additional validation of model placements, and we don't want detections
from a single RGB-D image to filter out possible model placements prematurely.
115
I .

Figure 6-9: The Clutter testing data set.
6.8 
Experimental Results
We tested our object detection system on two Kinect-based data sets-the Kinect
data set from Aldoma et. al [2] containing 35 models and 50 scenes, and a new,
more difficult data set with many more occlusions and object pose variations that
we collected for this experiment which we will refer to as Clutter, which contains 18
models and 30 scenes (Figure 6-9). We used the same parameters (score component
weights, number of samples, etc.) on both data sets. In table 6.1, we compare the
precision and recall of the top scene interpretations (multi-object-placement samples)
of our method against Aldoma et. al on both data sets.
Our algorithm (with BPA) achieves state-of-the art recall performance on both
data sets. When multiple scene interpretations are considered, we achieve even higher
recall rates (Table 6.2). Our precisions are similar to the baseline method (slightly
higher on Clutter, slightly lower on Kinect). We were unable to train discriminative
feature models on the Kinect data set, because the original training scans were not
12Since neither ours nor the baseline method uses colors in their object models, we considered a
model placement "correct" for the Clutter data set if it was within a threshold of the correct pose
(2.5cm, pi/16 radians) with respect to the model's symmetry group. For example, we don't penalize
flipping boxes front-to-back or top-to-bottom, since the resulting difference in object appearance is
purely non-geometric. For the Kinect data set, we used the same correctness measure as the baseline
method (RMSE between model in true pose and estimated pose), with a threshold of 1cm.
116

our method (BPA) 
our method (ICP) Aldoma et. al [2]
precision 
recall 
precision 
recall 
precision 
recall
Kinect 
89.4 
86.4 
71.8 
71.0 
90.9 
79.5
Clutter 
83.8 
73.3 
73.8 
63.3 
82.9 
64.2
Table 6.1: A comparison of precision and recall.
# samples
recall
1 
2 
3 
5 
10 
20
73.3 
77.5 
80.0 
80.8 
83.3 
84.2
Table 6.2: Recall on the Clutter data set as a function of the number of scene inter-
pretation samples.
provided. Training on scenes that are more similar to the cluttered test scenes is also
likely to improve precision on the Clutter data set, since each training scan contained
only one, fully-visible object.
For our experiments, we implemented our algorithm in C++ and ran them on a
single 64-bit, 2.4 GHz Intel Xeon processor. On a single CPU, each scene took 1-2
minutes to process, compared to 10.4 seconds per scene for Aldoma's system, which
ran in parallel on multiple CPUs [2]. We are now in the process of porting our code to
the GPU-our current prototype system can detect single objects in about 1 second
on an NDIVIA GeForce GTX 580 with 512 cores.
6.8.1 
BPA vs. ICP
We evaluated the benefits of our new alignment method, BPA, in two ways. First,
we compared it to ICP by replacing the BPA alignment step in round 2 with an ICP
alignment step' 3 . This resulted in a drop of 10% in both precision and recall on the
Clutter data. The lesson is that using a bad alignment algorithm can actually hurt
object detection performance rather than help!
For a second test of BPA, we initialized 50 model placements by adding random
l 31Both ICP and BPA used the same point correspondences; the only difference was that BPA
incorporated point feature orientations, while ICP used only their positions.
117

Gaussian noise to the ground truth poses for each object in each scene of the Clut-
ter data set. Then, we ran BPA and ICP for 20 iterations on each of the model
placements". We then computed the average of the minimum pose errors in each
alignment trial, where the minimum at time t in a given trial is computed as the
minimum pose error from step 1 to step t. (The justification for this measure is that
this is approximately what the "accept if score improves" step of round 2 is doing.)
As shown in figure 6-10, the pose errors decrease much faster in BPA.
0.03 
0.28 
-
-
- lCP
0.028 
BPA 
0.26 
B 
-
B 
PA
0 0.026-
0.2
X)0.024 
024
0.022. 
0.22-
0.02 
0.2
5 
10 
15 
20 
5 
10 
15 
20
alignment iterations 
alignment iterations
Figure 6-10: Comparing BPA with ICP. (Left) The average of the minimum position
errors in each alignment trial. (Right) The average of the minimum orientation errors
in each alignment trial.
6.9 
Related Work
Since the release of the Kinect in 2010, much progress has been made on 3-D object
detection in cluttered RGB-D scenes. The two most succesful systems to date are
Aldoma et. al [2] and Tang et. al [81]. Aldoma et. al's system is purely geometric,
and uses SHOT features [86] for model-scene correspondences. It relies heavily on
pose clustering of feature correspondences to suggest model placements 5 . The main
"In other words, we repeated the alignment step of round 2 twenty times, regardless of whether
the total score improved.
15 This is essentially a sparse version of the Hough transform [7], which is limited by the number
of visible features on an object, and is why their recall rates tend to be lower than in our system for
objects that are heavily occluded.
118

contribution of Aldoma et. al's system is that they jointly optimize multiple model
placements for consistency, which inspired our own multiple object detection system.
Tang et. al's detection system uses both geometry and image features, and placed
first in the ICRA 2011 Solutions in Perception instance recognition challenge. Their
system relies heavily on being able to segment objects in the scene from one another,
and most of the effort is spent on combining geometry and image features for classi-
fication of scene segments. It is unclear how well the system would perform if such
segmentations are not easy to obtain, as is the case in our new Clutter data set.
The Bingham distribution was first used for 3-D cluttered object detection in
Glover et. al [31] (and was the subject of chapter 5). 
However, that system was
incomplete in that it lacked any alignment step, and differs greatly from this work
because it did not use feature correspondences.
6.10 
Conclusion and Future Work
We have presented a system for 3-D cluttered object detection which uses a new align-
ment method called Bingham Procrustean Alignment (BPA) to improve detections
in highly cluttered scenes, along with a new RGB-D data set which contains much
more clutter and pose variability than existing data sets. Our system relies heavily
on geometry, and will clearly benefit from image and color models, such as in Tang
et. al [81]. Our Clutter data set, while challenging, contains zero ambiguity, in that a
human could easily detect all of the objects in their correct poses, given enough time
to study the models. An important direction of future work is to handle ambiguous
scenes, where the parts of objects that are visible are insufficient to perform unique
alignments, and instead one ought to return distributions over possible model poses.
In early experiments we have performed on this problem, the Bingham distribution
has been a useful tool for representing orientation ambiguity.
119

Chapter 7
Dynamic Manipulation: Teaching a
Robot to Play Ping Pong
We now turn our attention away from computer vision and towards the final topic
in this thesis: dynamic manipulation. Specifically, in this chapter we present work
on a ping-pong-playing robot that learns to improve its swings with human advice.
Our method learns a reward function over the joint (combined) space of task and
policy parameters T x P, so the robot can explore policy space more intelligently in
a way that trades off exploration vs. exploitation to maximize the total cumulative
reward over time. Multimodal stochastic polices (e.g., for when two very different
swings could achieve the same high expected reward) can also easily be learned with
this approach when the reward function is multimodal in the policy parameters. We
extend the recently-developed Gaussian Process Bandit Optimization framework to
include exploration-bias advice from human domain experts, using a novel algorithm
called Exploration Bias with Directional Advice (EBDA).
As any athlete (or parent) knows, coaching is an essential ingredient to human
motor-skill learning for manipulation. Learning to tie one's shoes, cook a meal, or
shoot a basketball is nearly impossible without the active guidance of a teacher. With
the right combination of demonstration, verbal advice, goal-setting, and performance
feedback, humans routinely teach one another incredibly complex skills in a wide
variety of domains. Yet most work on manipulation learning in robotics has focused
120

on self-improvement. The human teacher may be involved in an initial demonstration
via teleoperation or kinesthetic teaching, but after that the robot is on its own; left
to explore independently, often using no more than a random walk in policy space,
with rewards few and far between.
The work that has been done on coaching robots (beyond the initial demonstration
phase) has primarily used goal-setting and feedback (i.e., rewards). But there has
been very little work on directly giving robots policy exploration advice. Sometimes
a simple "pull harder" or "keep your knees bent" is enough to get human learners
to master a skill. Doing the same for robots in arbitrary domains will require AI
systems that can translate generic natural language commands into motor skill policy
information. While there has recently been some effort on this problem [82], we are
a long way from any complete solution.
In this chapter we assume that the mapping between verbal commands and policy
parameters can be programmed in ahead of time. Our focus is on integrating an advice
signal from a human coach into a robot's exploration policy. We focus on episodic
learning tasks, like hitting a ping pong ball, where the robot executes a policy iro
with parameters 0 for some finite period of time, then receives a reward y reflecting
how well it performed the task. In the case of ping pong, the policy ro is a computer
program (parameterized by 0) for swinging a robot arm, and the reward depends on
whether or not the robot succesfully hit the ball back to the other side of the table.
The robot's goal is to maximize the total reward it receives over time. We phrase
this as a multi-armed bandit problem, and extend the recently-developed Gaussian
Process Bandit Optimization framework [79, 51, 20] to include advice in the regret-
minimizing exploration/exploitation strategy.
7.1 
Policy Search for Dynamic Skill Improvement
There is a long-running debate in robotics on whether model-based or model-free
learning of motor control policies is the best way to get robots to perform dynamic
tasks like walking, juggling, or playing ping pong. Proponents of model-based ap-
121

proaches boast that with carefully tuned models of system dynamics, robots can
achieve skills equalling or even surpassing those of their human teachers, while the
model-free crowd argues that acheiving such models isn't always possible, and that
robots' ability to learn new tasks from demonstration, with little or no prior domain-
specific programming, is the true measure of success.
Regardless of whether a robot uses model-based or model-free methods to achieve
basic competency at a new skill, skill improvement for model-based methods is limited
by the accuracy of the model class. In contrast, model-free methods, which directly
explore the space of motor control policies, are only limited by the class of policies.
Of course, this space is often too large to search exhaustively, and aggressive search
heuristics and priors are needed to increase the data efficiency of model-free learning
algorithms in all but the simplest domains.
Policies must also typically be generalized over a task space T, which we here
parameterize by a task parameter vector 7. For example, in our application T includes
the predicted position, velocity and spin of the incoming ball when it bounces on the
robot's side of the table. (Although it may seem that the task space in our application
is equivalent to the state space of the ping-pong ball, it actually contains higher-level
features which are computed/predicted as a function of a history of the state space
variables.) Complicating matters is that T is usually a hidden variable: the robot
is given a noisy task observation, r, from which it must infer the underlying task
parameters.
7.1.1 
Representing the policy: explicit vs. implicit
There are two main ways that a policy-search algorithm can represent policies-
explicitly, with a direct mapping from task parameters to policy parameters (T -> P);
or implicitly, with a reward function over the joint space of task and policy parameters
(T x P -
R)'. Although both represent ations have been tried in classic reinforcement
learning domains [23], only direct policy mappings have been used in recent work
'The learning domains in this work are single step (not sequential).
122

where robots have learned dynamic manipulation skills, like throwing darts, flipping
pancakes, or hitting balls [48, 49, 21]. In this (direct) approach, a continuous [48]
or piecewise-continuous [21] function 4D is learned from T to P, representing the
robot's current estimate of the reward-maximizing policy parameters for each task
parameter vector T. To explore, the robot perturbs (D with random noise; for example,
by sampling from a Gaussian process [48].
The main problem with this direct-mapping-based exploration policy is that it
may be difficult for the learning algorithm to escape from local maxima, since the
exploration only makes local perturbations to the policy parameters. In contrast,
by learning a reward function over the joint space of task and policy parameters
T x P, the robot can explore policy space more intelligently in a way that trades
off exploration vs. exploitation to maximize the total cumulative reward over time.
Multimodal stochastic polices can also easily be learned with this approach when the
reward function is multimodal in the policy parameters. In figure 7-1, we illustrate
the difference between implicit and explicit policy representations. For smooth reward
functions that are unimodal in P (figure 7-1, left), both explicit and implicit policy
models are suitable. But for "bumpy" reward functions with many local maxima,
explicit methods will lose information about the multiple good actions that the robot
can take given the same task parameters (figure 7-1, right). 
Note that for many
dynamic robotic tasks like ping pong, both T and P are continuous.
7.2 
Gaussian Process Bandit Optimization
The multi-armed bandit problem [72] is the decision problem of choosing the sequence
of "levers" to pull when each lever f has an associated "payoff" or reward distribu-
tion, Df. The agent pulls a lever, receives a reward, and then gets to choose again,
incorporating all the information it has obtained from past lever pulls.
Maximizing the reward that a robot learner gets by exploring a reward function
f : T x P -+ R mapping continuous task and policy parameters to the reals is akin
to a multi-armed bandit problem with infinitely many levers. At each round t, the
123

(a) 
(b)
Figure 7-1: Implicit vs. explicit policies. In the smooth reward function on the
left, a good explicit policy mapping T to P can be found. In the reward function
on the right, any explicit policy mapping will be throwing away information about
alternative modes.
world chooses task parameters Tt which the robot observes with noise as ft, then the
robot selects policy parameters Ot, executes policy 7ro, and receives a noisy reward
y 
= f(Tt, 0) + Et.
With some mild smoothness assumptions, the reward function f can be modelled
as a Gaussian process (GP). There is a large body of literature on exploration heuris-
tics for GPs [65, 13]. We use GP-UCB [79, 51], which has recently been shown to
achieve sub-linear regret bounds for cumulative reward in bounded policy domains
P. It has not yet been applied to active learning of robot control parameters.
GP-UCB (Gaussian Process Upper Confidence Bound)
The GP-UCB algorithm [79, 51] chooses the next Ot so as to maximize a combination
of the current GP mean and variance estimates of the reward function f:
Ot 
argmax pt 1 (?t,O + 
)+!/2ut(# 
),
0
where pi(.) and o(.) are the posterior mean and standard deviations functions of the
GP after the first t -
1 observations, (?1, 01, yi), ... , (t-i, Ot-1, yt-1). The /t's are
exploration constants, which must increase over time as a function of log t in order
124

to obtain the theoretical regret bounds below.
Letting 0* be the reward-maximizing policy parameter vector for the true task
parameters Tt, the true cumulative regret up to time step T is defined as
RT := 
f(t, 0t*) -
f (Tt, 0t). 
(7.2)
t=1
Unfortunately, since the Tt's are unobserved, the best bound we can achieve for RT is
O(T), since there will always be a small constant expected regret at every time step
t due to task parameter observation noise, rt -
ft.
The sub-linear regret bounds that have been found for GP-UCB assume that the
agent has access to the true task parameters. We can achieve similar bounds for
the noisy task parameter case with a modified definition of regret. Letting 0* be
the reward-maximizing policy parameter vector for task parameters it, we define the
observable cumulative regret up to time step T as
T
fRT : 
f(ft, 
t*) 
- f(#t, 0 ). 
(7.3)
t=1
RT has a bound of O(v T 3TOT-) 
with probability 1 - 6, where 6 - (0, 1) is an explo-
ration parameter that can be controlled by the user. Since the robot doesn't get to
choose rt, it is unfair to penalize it for the difference between Tt and -it, and so the
observable regret bounds still provide some insight into our problem.
7.3 
Giving Advice
There are many ways to train a robot. Some of the most common are:
" Demonstration: The coach can demonstrate a particular skill to a robot,
either by performing the skill while the robot watches, or by teleoperating the
robot.
" Goal setting: The coach can select a sequence of tasks to give the robot, only
moving on when the robot has demonstrated a sufficient level of skill at the
current task.
125

" Performance feedback: The coach can give the robot learner a reward signal,
which may be in addition to environmental rewards that the robot observes on
its own.
" Policy advice: The coach can suggest modifications to the robot's policy
parameters, like "hit the ball harder" or "angle your paddle down more".
Learning from demonstration is a well-explored paradigm in robotics [6, 69]. How-
ever, it can be difficult for a human to teleoperate a robot to perform complex and
dynamic tasks, and computer vision algorithms are not yet advanced enough to un-
derstand most manipulation actions (for example, to determine that a human is using
their right hand to hold a jar between their knees while the left hand tries to generate
enough force to twist off the cap). Nevertheless, learning from demonstration has
been applied successfully to several robotic domains, including ping pong [66].
Setting goals is less explored in the robotics literature, but it is the de facto
standard for all of robotics research. Typically, a human researcher explores policy
parameter space (by modifying the robot's program) rather than the robot exploring
on its own.
Performance feedback is perhaps the most-explored mechanism for training com-
puter agents (not just robots). Particularly for reinforcement learning domains (MDPs)
like computer games and robot navigation, there is a long history of incorporat-
ing a human reward signal (called reward shaping) into reinforcement learning algo-
rithms [32, 83, 40, 70].
The approach to training robots that we use in this work is that of giving the robot
policy advice. In RL domains, this has been explored with action biasing-where the
human biases the robot's action-selection mechanism [47], and control sharing-where
the human selects some of the robot's actions directly [78]. For manipulation, a recent
technique is to give the robot policy improvement advice--where the human provides
the robot with incremental improvements to its manipulation trajectories in order to
indicate a step in policy space that may increase reward [38].
126

P7
P'
T
T
Figure 7-2: The robot interprets advice from a human coach as an exploration bias.
The light green shaded areas on top of the reward functions (top-down view of figure 7-
1(a)) in the left and right images indicate what the robots believes are "good" regions
to explore, and are inferred from a series of policy gradients given by the human coach
(e.g., "swing harder" or "angle your paddle up more"). Note that the exporation
advice can either be global (left) or local (right). In our system, local advice is
the default; advice is only applied globally (for all r E T) at the coach's discretion
(e.g., by saying "always swing harder") Note that we used a keyboard interface to
communicate with the robot-no human language understanding was done for this
work.
7.3.1 
Policy gradient advice
Giving robots entirely new policies as advice can be a time-consuming process. In-
stead, we explore policy gradient advice, where the human trainer need only provide
a direction in policy space P in which reward is likely to increase, rather than a
new, complete policy. Intuitively, this type of advice can directly capture information
like "hit the ball harder" or "angle your paddle down more", so long as the mapping
between the natural language instructions and policy parameters is known.
There are two ways a robot can interpret policy gradient advice: (1) as a pseudo-
reward, or (2) as an exploration bias. Treating the advice as a pseudo-reward
involves a level of trust: the robot believes that hitting the ball harder is a good
127

thing to do because the coach said so, and it may take several trials to overcome
the pseudo-reward in the case that the coach is wrong. Using the policy gradient
advice as an exploration bias (which is akin to action biasing in RL domains) is less
susceptible to bad advice, since the robot can decide for itself whether the advice was
useful. In addition, gradient-based pseudo-reward may be difficult to implement in
continuous policy domains, since it isn't clear how far in the direction of the gradient
one should place the pseudo-rewards, or how many to place. For these reasons, we
interpret policy gradient advice as exploration bias.
7.3.2 
Exploration Bias with Directional Advice (EBDA)
We now present our algorithm for turning directional (policy gradient) advice into an
exploration bias. Intuitively, EBDA turns directional information into soft constraints
on future policy parameters; namely, that they be in roughly the same direction as
the advice indicates.
Let T,... 
, T, be a sequence of tasks the robot has received, let 01, . . . , 0, be the
policy parameters it chose for each task, and let V1, . . ., 0, be the coach's policy
gradient advice. The direction of each Oi indicates a direction of increasing reward
(according to the coach) in policy parameter space, with respect to the current Oi.
The robot interprets 01,... ,', 
as a sequence of probabilistic constraints on the
policy parameter vector 0n+1 for the next task, Tn+1. Each constraint is of the form
{0 : 
(0 
-
0(0- ) > 0}, and is only applied if the advice is global2 (indicated by V@i > 1)
or if the new task parameter vector T+l is close to Ti. EBDA then flips a biased coin
(based on an advice noise parameter p) to determine whether or not to include each
constraint. Pseudo-code for EBDA is shown in Algorithm 1.
2Note that the magnitute of Vh is only used as a binary signal for whether or not the advice is
global; it has no other purpose in the EBDA algorithm.
128

Algorithm 1 EBDA
Input: History of task parameters T1 , ... 
, T., policy parameters 01,... , 0 .,, policy
gradient advice 01,... , 
, advice noise p, and a new task parameter vector Tn+
Output: Exploration region E c P
S <- P
for i = 1 to i do
Sample s ~ Uniform(0, 1)
if 1<iI > 1 or IT,+1 -
TiI < 7thresh then
if s > 1 - p then
S <- E n {O: O - (0 - Oi) > o}
end if
end if
end for
7.4 
Robot Ping Pong
There are several reasons for choosing ping pong as an application to study human
coaching for dynamic robots. First, ping pong is a high-speed, underactuated control
task, requiring a level of precision and timing not seen in many robot systems out-
side of the factory setting. At the same time there is substantial uncertainty about
the world. The spin on the ball is difficult to observe directly, and the opponent's
actions are unpredictable. For these reasons it is very difficult to conquer with model-
based optimal control methods alone, leaving room for learning methods to improve
significantly upon the state of the art. Ping pong is also similar in spirit to other
high-skill manipulation tasks, such as those often found in cooking-chopping veg-
etables, stirring ingredients in a bowl, flipping burgers-in that they are all dynamic
and underactuated and are defined by repetitive motions applied to a limited range
of objects. Finally, ping pong has been used as an application for learning dynamic
control policies [66], which makes it a good application for comparison.
129

Background
The first work on robotic ping pong was by Russell Andersson at Bell labs in the
late 1980's [4, 3]. 
A massive feat of engineering at the time, his system combined
real-time computer vision to track the ball with high-speed controllers on a standard
Puma robot arm and was able to beat novice players on a modified ping pong table
(higher net, narrower table). Since computing power was limited at the time, he
had to derive all the equations of motion for the system analytically, which he did
to varying degrees of success. The effect of spin on the ball's collision dynamics, for
example, was greatly simplified by reducing friction on the robot's paddle.
The next major research effort in robotic ping pong came in the early 2000's
in Japan by Miyazaki and Matsushima [61, 64, 63]. 
Their system used a frame
attached to the ping pong table with a paddle that translates only in the wy-plane,
with 2 additional rotational degrees of freedom. Drawing upon advances in robot
juggling, they used locally-weighted regression (LWR) to learn input-output maps
for ball collision dynamics, enabling their system to use a modern, inverted rubber
ping pong paddle (capable of imparting a great deal of spin on the ball). Due to
the limitations of their minimalistic hardware setup, their system was only able to
rally with a human opponent for short rallies at moderate speed. But to their credit,
the table was unmodified, and in their released videos it appears that the human
opponents were skilled ping pong players, accustomed to hitting the ball with spin.
More recently, a Chinese group led by Yuan-Hui Zhang have used humanoid robots
to play ping pong, where the robot must balance while swinging the paddle at the
same time [89, 80].
But the closest work to ours is [66]. Their robot also learns to improve its swing
parameters from experience, but they use an explicit policy mapping from task pa-
rameters to policy parameters, and they do not use human advice to help the robot
learn. We compare to their learning method, CrKR, in our experimental results.
130

Figure 7-3: Our ping pong robot uses a 7-dof Barrett WAM arm with a ping pong
paddle rigidly attached at the wrist.
Hardware
Our system consists of a 7-dof Barrett WAM arm, mounted sideways on the wall
behind the ping pong table, along with a pair of high-speed 200Hz black-and-white
Silicon Video SV-640M cameras mounted on a fixed frame above the arm (Figure 7-
3). A Kinect is also used to detect human opponents and predict ball spin based on
the type of swing they use to hit the ball to the robot.
Sensing
Since the cameras are stationary and the ping pong ball is much lighter in color than
the table, we use a simple background-subtraction-based blob tracker to detect and
track the ping pong ball. Detections in the left and right cameras are triangulated
to estimate depth, and the ball's 3-D position is then transformed into ping pong
table coordinates. The camera-table transform is estimated using a gradient descent
algorithm which optimizes the fitness of the table's edges projected into left and right
Canny edge images. The human opponent's body configuration is tracked in the
Kinect depth image with OpenNI.
131

Tracking and predicting the ball's trajectory
In order to decide when and where the robot should swing its paddle, it needs to
predict the ball's future trajectory based on its past trajectory. Although it would be
possible for the robot to learn the ball's dynamics autonomously, this is not the focus
of our current work. Therefore, for simplicity we use Andersson's models to predict
ball aerodynamics and collisions with the table [4].
The ball's state is defined by the 9-dimensional vector b = (x y, z, v, 
vY, vz, w, w 
l, 
w,),
representing the ball's current position, velocity, and spin. During flight, the ball's
acceleration is given by
a= -Clvlv + Cmvlw x v - g, 
(7.4)
where Cd and Cm are drag and Magnus coefficients, and g is the gravity acceleration
vector (in the negative z-direction).
The bounce dynamics model is slightly more complex, since the ball may change
from a "slipping" to a "rolling" mode during contact with the table. First define
Vrel = (Vm - wyr, VY + zur, 0) 
(7.5)
Vrel
Vr = 
Vrel 
(7.6)
||Vreill
where r = 20mm is the ball's radius. Then rolling occurs if
Vrel < -Cf 
vz(1 + C) 
(7.7)
where Cf is the coefficient of friction and C, is the coefficient of restitution. If rolling
occurs during the bounce, the ball's final velocity vf and spin wf are
3vx + 2rwy 3vY - 2rw(
Vf =( 
' 
, -Croz) 
(7.8)
5 
5
Wf( 
2rwx - 3vY 2rwy + 3v(
5r 
5r
Otherwise, the ball experiences friction during the whole bounce, and the final velocity
and spin are
Vf = V + (Cf vr - k)v2(1 + Cr) 
(7.10)
Wf = 
+ 3Cfry, -f,, 0)v (1 + C,) 
(7.11)
2r
132

where k = (0, 0, 1) is the table normal.
To track the ball's state, we use an Extended Kalman Filter (EKF) derived from
these equations of motion. We initialize the ball's spin vector based on the human
opponent's paddle hand velocity vector (determined by smoothing a finite difference
of hand position signals from OpenNI) at the time of contact with the ball. Letting
(hr, hy, hz) be the hand's velocity vector, we empirically set the ball's spin to be
w = (240, 40hz, 0) if h, > 0 for a topspin stroke, and w = (-240, -80hz, 0) otherwise.
This is clearly a gross approximation to the true effect of the human hand's velocity
vector on the initial ball spin, but with high initial EKF variance, they provide a
suitable prior on the ball's spin state for our experiments. Without this prior, it
takes the EKF too long to determine the ball's spin (which has a great effect on
its predicted trajectory), and the robot cannot differentiate between a topspin and
underspin ball in time to decide how to hit it.
Note that we are still working on incorporating the quaternion Bingham filter
(QBF) appoach from chapter 4 into our ball tracking system. Unfortunately, the
logo detections are currently too noisy due to poor image resolution in our current
system's high-speed cameras, so tracking the orientation and spin of the ball based
on observations of the logo will require a new camera setup.
Swing planning
Our approach to swing planning is hierarchical. First, the robot finds a hit plan-
indicating a desired contact between the ball and paddle. 
The hit plan includes
the paddle's position, velocity, normal, and time when it hits the ball. Then, a
kinodynamic paddle trajectory is planned that achieves the desired contact state.
Finally, the robot uses inverse kinematics to find a trajectory in joint angle space to
satisfy the paddle trajectory constraints.
For our learning experiments, the hit plan is precisely the policy parameter vector,
0. Task parameters T are the position, velocity and spin of the incoming ball when it
bounces on the robot's side of the table.
The paddle always starts in the same configuration with position po = (1O, Yo, zO)
133

and normal no = (n.e, nya, nzo) at the beginning of every swing. To find a paddle
trajectory that achieves the desired hit (paddle position Phit, normal nhit, and velocity
Vhit at time t;it), we compute three separate bang-bang control laws for the paddle's x-
, y--, and z-trajectories, and we interpolate the paddle normals to transition smoothly
from no to nhit.
Let T be the duration of the swing (starting at to= thit - T), discretized into N
time steps (so each time step is At = T/N). The bang-bang control law we use is to
accelerate at -a for k time steps, then at +a for N - k time steps. Assuming the
system starts at rest at the origin, the velocity trajectory given by this control law is
Ata 
(-1,. .. , -k, -k + 1, .. ., N - 2k), and so the final position is
(At)2a((N - 2k)(N - 2k + 1) -
k2 
(7.12)
2
Thus the acceleration is uniquely determined by XN and k; we set a to make XN 
Xhit,
so the paddle always reaches the desired final position. Changing k yields different
final velocities, VN = At - a - (N -
2k); we choose the k that makes VN as close
as possible to the desired hit velocity. Note that we compute three different pairs:
(ax, kx), (aY, ky), (as, k,) for controllers in the paddle's x, y, and z coordinates.
Learning a swing controller
Given a planned trajectory Q = (qo, . . . , qN) from times to to tN in joint angle space,
the robot must find a way to execute the swing by sending torque commands to the
motors at each joint. This is accomplished with a combination of feed-forward and
proportional control in joint angle space. Given current joint angles and velocities q
and 4, and desired joint angles and velocities qt and t, the robot applies torques:
u = K,(qt - q) + Kd( t -
) + ut, 
(7.13)
where Kp and Kd are gain matrices, and ut are the feed-forward (constant) torques
at time t.
Controllers of this form have been applied to execute dynamic motions with robot
arms in the past. Often, ut is computed with an inverse dynamics model that esti-
mates the torques needed to achieve varying joint accelerations 4 in state (q, 
j). Such
134

models assume 4 is a function of q, q, and u; higher-order effects like vibrations, cable
stretching, gear thrashing, etc. are ignored.
Our ping pong robot needs to operate at the very limits of its specifications, with
paddle speeds up to 3 meters/second and swing durations of less than half a second.
Because of this, we found inverse dynamics models to be too noisy to rely on for
swing control. Instead, our system learns a library of feed-forward torque trajectories,
U1, .I. . , Urm, corresponding to hit plans H 1, . . . , Hm (which uniquely determine joint
trajectories Q1, ... , Q,. 
This library is learned incrementally--a new (U, H) pair is
only added when the error between a desired swing and actual swing (as measured
by joint encoders) is larger than a given threshold.
To learn a new swing (U, H) with corresponding Q and Q, the robot initializes
U to either: (i) the Ui corresponding to the closest Hi if IH -
HiI < thresh, or (ii)
G(Qi): the torques needed to cancel out gravity at each joint angle configuration
in Qi 3. Then, the robot executes the current swing according to equation 7.13 and
computes the errors between desired and measured joint angles and velocities, Q -Q
and Q - Q. These errors are used to update U:
dU <- AKp(Q - Q) + Kd(Q - Q) 
(7.14)
U +- U + min(max(-dUm,,, dU), dUmax), 
(7.15)
and then the robot repeats the swing and updates U until convergence. This U update
is a functional control law for trajectories that tries to drive Q - Q and Q - Q to zero
over time as the robot practices the swing over and over again. Note that each time
the robot practices the swing, it decreases the position gains Kp in equation 7.13 so
it relies more and more heavily on the feed-forward torques U to drive the swing.
7.5 
Experimental Results
We compare five learning methods: GP-UCB, CrKR, GP-UCB + EBDA, CrKR
+ EBDA, and Direct -where the human coach directly controls the robot's hit plan
3The anti-gravity torques are also learned: the robot moves to a list of pre-specified configurations
with a PID control law and records the torques needed to keep the system at rest.
135

with incremental changes to policy parameters. CrKR is a direct policy mapping
method [48] that has been applied to learning ping pong swings [66]. For the three
learning algorithms that use advice, we only allowed the coach to give information
about one parameter at a time.
Simulation
As a pilot domain, we simulated mixture-of-Gaussian reward functions and ran each
learning method (except CrKR + EBDA) for 100 trials. Direct advice was given
by adding random noise to the true maximum policy parameter O* in the slice of P
with all other policy parameters fixed to their last values. Directional advice ') for
EBDA was given by the direction of Q* with respect to the last 0 along one randomly
chosen axis. We repeated each experiment 50 times. Average cumulative rewards
for each method are shown in figure 7-4. For GP-UCB, we tried using both the 0
from the original paper [79] and 3 = log t (betal and beta2 in figure 7-4). Since
# = log t performed the best in simulation, we used that beta throughout the rest
of the experiments. Adding advice (with EBDA) improved GP-UCB further, while
direct advice performed the best (because it is an oracle perturbed by noise).
Robot Ping Pong
We next compared the learning algorithms on the task of improving the ping pong
robot's hit plans. We ran each algorithm for 100 trials of a human ping pong expert
hitting balls to the robot in a predetermined sequence (e.g., "high backhand topspin
to (.2,.4) on the table", "low forehand underspin to (.7,.5) on the table") . If an
incoming ball trajectory from the human differed significantly from the desired ball
trajectory, the human was prompted to hit another ball to the robot.
As a starting point and a baseline, we implemented a default hit plan as follows.
Given an estimate of the ball's predicted future trajectory, it finds the ball's highest
point in that trajectory within ±15cm. of the robot's end of the table. That ball
position is the hit plan's paddle position. The paddle velocity is a constant (1.3, 0, 0)
i/s, and the paddle normal points in the opposite direction of the ball's (x, y)-velocity
136

1.5r
0.5
0
-0.5
30
25
20-
15
10
5
-0.5
0 
0.5 
1
theta
(a) example reward function (l-D) with 1-or error bars
showing noise
0 
-
-
-
-- 
r - - - -
-
_ 
l 
--- 
-- 
r 
, 
r -
- -
-
-
- -- 
-
-
-- gp ucb beta2 + ebda
0 
- -
gp ucb beta2
- @- gpucb betal
0 
-
- crkr
-
direct advice
0 
150
?0 -
0
0
0 
10 
20 
30 
40 
50 
60 
70 
80 
90 
1
(c) 2x3
00
0
-
gp ucb beta2 + ebda
- -, gp ucb beta2
- 0 - gp ucb betal
-
- crkr
-
direct advice
10 
20 
30 
40 
50 
60 
70 
80 
90 
1
(b) 1x1
35
-
gp ucb beta2 + ebda
30- 
gp ucb beta2
-@-gp ucb betal
-
- crkr
25 -direct 
advice
20 
1
15-
0 
10 
20 
30 
40 
50 
60 
70 
80 
90 
1
(d) 5x6
Figure 7-4: Simulation results (cumulative reward vs. learning trials) with mixture-
of-Gaussian reward functions, for task and parameter spaces of different dimensions.
137
Vr
9
00
1
-
1
7
6
5
I
4
00

vector (in order to hit the ball back the way it came).
We ran the default hit plan for 50 trials of topspin balls only to generate an initial
swing table of 12 swings. Then--resetting to the initial swing table and hit policy
each time--we ran 5 different learning methods on 100 trials of topspin balls and 100
trials of underspin balls, for a total of 10 learning experiments. The policy parameter
vector for each learning experiment was 0 = (x, vx, v2, nY, nz): a subset of the hit plan
parameters from section 7.4. x was defined as a displacement from the default hit
plan's x position, and controlled whether the ball was hit before or after its highest
point. Policy parameters were bounded from (-.1, 1, 0, -. 1, -. 5) to (.1, 2, .5, .1, .5).
Due to the real-time nature of the ping pong task, it was infeasibile to run the
learning methods to choose a hit plan 0 for every new task parameter vector (i.e., ball
parameters) T. Instead, a lookup table of hit plans was computed between trials for
every 
. .. 
, T, the robot has seen in that experiment. Then, when a new incoming
ball is detected by the robot (with ball parameters T+,), the robot uses the pre-
computed hit plan from the closest Ti, or the default hit plan if no nearby Ti is found.
Rewards were given by the experimenter of 0 or 1 depending on whether the ball
was succefully hit back to the other side of the table. In addition, a coach's pseudo-
reward of 0.5 was added if the coach liked the way the robot hit the ball, for a total
reward in each trial between 0 and 1.5.
The cumulative reward (without the coach's pseudo-rewards) is shown in figure 7-5
for each learning method. Using EBDA to include human advice increased reward for
both GP-UCB and CrKR for both topspin and underspin. GP-UCB and CrKR are
comparable on topspin, while GP-UCB is the clear winner for the harder underspin
experiment, which requires a great deal more exploration since the default policy is
designed to return topspin balls only.
The results support the idea that global exploration of a reward function (with GP-
UCB) is better than local exploration of policy space (with CrKR) when the default
policy is far from the optimum. However, the best method may be to combine the
two: starting globally and then exploring locally for improvement once a good policy
has been found.
138

70 
_____
-
gp ucb beta2 + ebda
60 
--- 
gp ucb beta2
--- crkr + ebda
- -crkr
50 
-
direct advice
40-
30--
20
10 
-
0 
10 
20 
30 
40 
50 
60 
70 
80 
90 
100
(a) topspin
45 
-
-_ 
- -_---__--_--T---__
-
gp ucb beta2 + ebda
40 --- 
gp ucb beta2
-
crkr + ebda
-
crkr
30 
-
direct advice
25
20
15-
10
52
0 
10 
20 
30 
40 
50 
60 
7'0 
80 
90 
100
(b) underspin
Figure 7-5: Robot ping pong results (cumulative reward vs. learning trials) for topspin
and underspin balls.
Videos of the robot playing ping pong (before and after learning) are available at
https://sites.google.com/site/aaairobotpingpong/.
7.6 
Conclusion
We have presented EBDA, a general method for incorporating policy gradient advice
into a robot's exploration strategy. By incorporating EBDA into two recent explo-
ration methods, CrKR and GP-UCB, we were able to boost the robot's cumulative
reward both in simulation and on a ping pong robot. On the robot, we demonstrated
an approach to learning both low-level swing controllers (feed-forward torques) and
high-level hit parameters. Our robot was able to learn policies to return both topspin
and underspin balls-to our knowledge, this is the first time this has been accom-
plished, as the underspin "push" is a difficult skill to master, even for human ping
pong players.
139

Chapter 8
Conclusion
Over the course of the last seven chapters, we have covered in full the technical
contributions of this thesis. The purpose of this final chapter is threefold: to place
these contributions in a broader context, to evaluate their strengths and weaknesses,
and to illuminate directions for future work.
If we hope to ever get robots cooking and cleaning for us, we must first teach them
to perceive and manipulate the extrordinarily wide variety of object configurations
that are possible in a home environment-from stacks of dishes and piles of dirty
laundry and trash to plastic bags, papers, wires, and furniture. They must be able
to push buttons, open lids, bend and fold things, pour and stir liquids, and (once we
trust them enough) cut vegetables and cook things on the stove.
Clearly, the contributions towards object detection and motor control learning
in this thesis are but small steps in the pursuit of these loftier goals. Our object
detection system is currently limited to detecting known instances of rigid objects.
And yet, since the core of the detection algorithm is a new method for alignment
(BPA), and at the core of the alignment method lies a new way of understanding 3-D
orientation information (with the quaternion Bingham distribution), it is hoped that
many of the tools developed in this thesis can be easily extended to more general
settings. For example, incorporating a "shape fitting" step into BPA would allow it
to handle deformable objects or novel objects within a class (e.g., bowls) with similar
shapes. In addition, BPA could form the basis of a new object tracking algorithm,
140

since tracking can be accomplished by iteratively aligning objects with the scene from
one frame to the next.
But to truly tackle the complexity of a sink full of dirty dishes or a desk full of
papers and wires, robots will need computer vision systems that go beyond detecting
"'what and where" objects are in the scene. The next logical step is to begin esti-
mating relationships between objects, like "on-top-of," "contains," and "attached."
Estimating these relationships in conjunction with detecting the objects will also im-
prove detection rates, since considering physical constraints between objects can lower
the size of the object placement hypothesis space considerably. They will also need to
understand object attributes, like "slippery" or "sticky." And most importantly, they
must make predictions about how the objects will move - predictions that depend on
those attributes and relationships, and the actions the robot takes to manipulate
them.
8.1 
Food for Thought
Let's consider the task of having a robot make a sandwich. A reasonable first step is to
find a plate. (We'll ignore high-level planning for the purposes of this discussion, and
instead focus on accomplishing each of the sub-tasks, which may either be specified
by a human or by a planning algorithm.) Suppose the robot already knows which
cupboard the plates are stored in. It opens the cupboard. Now it sees stacks of
plates, bowls, and cups. Maybe the bowls are even stacked on top of the plates. So
the first challenge is simply to detect the plates, and identify their relationship to
objects around them, so that the robot can make a plan to first lift the bowls, then
grab the first plate off of the stack, and then place the bowls down again on the
remaining plates.
Now the robot must execute the plan without breaking anything. It reaches for
the bowls. They are too big to grasp with one hand, so it must use two hands. It
can't see what's behind the bowls, so it has to feel its way around the back to make
sure it has a good grasp. It lifts up the bowls. Now, since both of its hands are
141

occupied, it has to find a place to put the bowls down before it can retrieve a plate.
The robot identifies a clear space on the counter and sets the bowls down. Now it
looks inside the cupboard again and finds that there is a small plate on top of the
big plates that it didn't detect before when the bowls were in the way. It uses one
hand to lift up the small plate, and then uses the other hand to grab the first big
plate underneath. The robot has to use all of its sensors-vision, touch and force-to
ensure that it has grasped one, and only one of the big plates. It begins to pull the
big plate out of the cupboard. Then suddenly, it feels a spike in its force sensors and
notices one of the cups tipping over next to the plates. The plate must have bumped
into the cup. The robot quickly drops the plate back onto the stack and lunges its
free hand over to stabilize the cup before it falls. It pushes the cup out of the way to
make room, grabs the plate again, pulls it out of the cupboard, sets down the small
plate on top of the remaining big plates, finds a free space for the big plate on the
counter, sets it down, and then grabs the bowls with two hands, puts them back in
the cupboard, and closes the cupboard door! As you can see, even the first step in
making a sandwich (or any meal that requires a plate) is quite complex, involving
18 distinct manipulation actions and 13 perceptual actions, not including the object
tracking that goes along with each manipulation action. Even if each one of these
manipulation actions has a success rate of 99% (meaning that 1% of the time there
is a catastrophic failure, such as the stack of bowls getting dropped on the floor),
the robot will still fail at the overall task of retrieving a plate 17% of the time! So
robustness is really the key to achieving complex goals.
Looking forward, the rest of the sandwich-making activity will prove to be even
harder. The robot must find a loaf of bread (which is tricky because its often inside
of a bag), grab the bag and put it on the counter, open the bag, take two pieces
of bread out of the bag (assuming its pre-sliced), close the bag and return it to its
shelf or drawer. Then the robot needs to open the refrigerator, locate meat, cheese,
lettuce, tomatoes, condiments in jars, and any other ingredients, pull them out of
the refrigerator, open and close them, grab slices of meat and cheese, use a knife or
a spoon to scoop and spread condiments, and so on and so forth.
142

How can robots achieve robustness at such complex manipulations? I think the
four keys to achieving manipulation robustness are:
1. To accurately track the state of the manipulation action.
2. To quickly react to disturbances.
3. To be able to predict what might go wrong.
4. To have good "technique."
Building better perception algorithms (that incorporate both touch and vision) is the
solution to (1). Items (2) and (3) will require models of dynamics for both the robot
and the objects. However, they don't necessarily have to be perfect models of the
physics---- even a prediction as simple as the rough direction of motion of a tipping or
falling object is often enough to move the hand into a position to catch it. The last
item on the list is where the advice-based learning methods in this thesis may have
the biggest effect.
Consider a task like chopping an onion. In a human culinary class, the teacher
will instruct students how to position their elbows and fingers, where and how deep
(and in what order) to make the cuts, and the proper angle of the knife and tension
in the wrist. To get a robot to learn the same skill, it will be nearly impossible to
program in a perfect model of the physics of onion chopping. For one thing, every
onion is different! Lacking an accurate model, the space of policy parameters (the
angle of the knife, etc.) will be prohibatively large to search through with trial and
error alone. So feedback (advice) from human instructors is certain to speed up the
rate at which robots can learn to master such skills.
8.2 
Beyond Ping Pong
Among the hardest manipulation tasks are those involving dynamics--where the
robot does not have complete control authority over the object and must predict
its dynamic motion as it tips or rolls or flies through the air. One finds dynamic
143

manipulation tasks everywhere-chopping vegetables, stirring ingredients in a bowl,
flipping hamburgers, moving furniture, playing sports, and so on. Furthermore, many
non-dynamic manipulation tasks become dynamic when the robot is pushed to its lim-
its: for example, when we want the robot to move very quickly, or to manipulate very
heavy objects. It is critical to these tasks for the robot to have accurate models of
object dynamics, so that the robot can predict where objects will end up when an
action is taken.
The manipulation problem considered in this thesis-ping pong-is both easier
and harder than other manipulation tasks. It is difficult because the system is very
fast and dynamic. But because the interaction between the robot's paddle and the
ball is so brief, it is easier to predict how the robot's actions will affect the ball.
There are also relatively few policy parameters to optimize, because the only thing
that matters is the state of the paddle when it hits the ball.
For longer-lasting manipulation tasks like chopping an onion or picking up a stack
of plates, the robot may want to vary its policy parameters throughout the manip-
ulation in response to sensory feedback. Of course, we can add parameters to the
feedback mechanism itself, and learn those in the same way (with exploration and
advice) that we learned the instantaneous policy parameters for the ping pong task.
But it is unlikely that one can adequately parameterize an onion chopping policy with
only five parameters, as we were able to do for ping pong.
The Gaussian-process-based exploration method that we used to explore policy
parameter space in chapter 7 can theoretically be extended to higher dimensional
parameter spaces. However, with a purely non-parametric model of the reward func-
tion, the algorithm has a tendency to explore all of the corners in policy parameter
space. And since the number of corners grows exponentially with the dimension of
parameter space, this behavior will be quite problematic for tasks with more pol-
icy parameters. Using the advice algorithm from chapter 7 (EBDA) alleviates this
problem to some extent, but the amount of advice required will also grow with the
number of policy parameters. Therefore, it may help to add a graphical structure to
the reward function to reduce dependencies between parameters.
144

Bibliography
[1] Pieter Abbeel, Adam Coates, and Andrew Y. Ng. Autonomous helicopter aer-
obatics through apprenticeship learning. The International Journal of Robotics
Research, June 2010.
[2] Aitor Aldoma, Federico Tombari, Luigi Di Stefano, and Markus Vincze. A global
hypotheses verification method for 3d object recognition. In ECCV 2012, pages
511-524. Springer, 2012.
[3] R.L. Andersson. Aggressive trajectory generator for a robot ping-pong player.
Control Systems Magazine, IEEE, 9(2):15-21, 1989.
[4] Russell L. Andersson. A robot ping-pong player: experimrent in real-time intelli-
gent control. MIT Press, Cambridge, MA, USA, 1988.
[5] Matthew E Antone. Robust camera pose recovery using stochastic geometry. PhD
thesis, Massachusetts Institute of Technology, Dept. of Electrical Engineering and
Computer Science, 2001.
[6] Christopher G Atkeson and Stefan Schaal. Robot learning from demonstration.
In ICML, volume 97, pages 12-20, 1997.
[7] Dana H Ballard. Generalizing the hough transforn to detect arbitrary shapes.
Pattern recognition, 13(2):111-122, 1981.
[8] D.H. Ballard. 
Generalizing the hough transform to detect arbitrary shapes.
Pattern Recognition, 13(2):111-122.
145

[9] P.J. Besl and N.D. McKay. A method for registration of 3-d shapes. IEEE
Transactions on Pattern Analysis and Machine Intelligence, 14:239-256, 1992.
[10] Christopher Bingham. Distributions on the sphere and on the projective plane.
PhD thesis, Yale University, 1964.
[11] Christopher Bingham. An antipodally symmetric distribution on the sphere.
The Annals of Statistics, 2(6):1201-1225, November 1974. ArticleType: pri-
mary-article / Full publication date: Nov., 1974 / Copyright 1974 Institute of
Mathematical Statistics.
[12] Xavier Boyen and Daphne Koller. Tractable inference for complex stochastic
processes. In Proceedings of the Fourteenth conference on Uncertainty in arti-
ficial intelligence, UAI'98, page 3342, San Francisco, CA, USA, 1998. Morgan
Kaufmann Publishers Inc.
[13] Eric Brochu, Vlad M Cora, and Nando De Freitas. A tutorial on bayesian op-
timization of expensive cost functions, with application to active user modeling
and hierarchical reinforcement learning. arXiv preprint arXiv:1012.2599, 2010.
[14] Gilles Burel and Hugues Henoco. Determination of the orientation of 3D objects
using spherical harmonics. Graph. Models Image Process., 57(5):400-408, 1995.
[15] Yee-Jin Cheon and Jong-Hwan Kim. Unscented filtering in a unit quaternion
space for spacecraft attitude estimation. In Industrial Electronics, 2007. ISIE
2007. IEEE International Symposium on, pages 66-71, 2007.
[16] Yasuko Chikuse. Statistics on special manifolds, volume 174. Springer, 2003.
[17] Gregory S Chirikjian. Stochastic Models, Information Theory, and Lie Groups,
Volume 2: Analytic Methods and Modern Applications, volume 2. Springer, 2011.
[18] D. Choukroun, I.Y. Bar-Itzhack, and Y. Oshman. Novel quaternion Kalman
filter. Aerospace and Electronic Systems, IEEE Transactions on, 42(1):174-190,
2006.
146

[19] Alvaro Collet, Manuel Martinez, and Siddhartha S Srinivasa. The moped frame-
work: Object recognition and pose estimation for manipulation. The Interna-
tional Journal of Robotics Research, 30(10):1284--1306, 2011.
[20] Emile Contal and Nicolas Vayatis. Gaussian process optimization with mutual
information. arXiv preprint arXiv:1311.4825, 2013.
[21] Bruno Da Silva, George Konidaris, and Andrew Barto. Learning parameterized
skills. arXiv preprint arXiv:1206.6398, 2012.
[22] I. Dryden and K. Mardia. Statistical Shape Analysis. John Wiley and Sons, 1998.
[23] Yaakov Engel, Shie Mannor, and Ron Meir. Reinforcement learning with gaus-
sian processes. In In Proc. of the 22nd International Conference on Machine
Learning, pages 201-208. ACM Press, 2005.
[24] Olivier D Faugeras and Martial Hebert. The representation, recognition, and
locating of 3-d objects. The international journal of robotics research, 5(3):27-
52, 1986.
[25] Wendelin Feiten, Pradeep Atwal, Robert Eidenberger, and Thilo Grundmnann.
6D pose uncertainty in robotic perception. In Advances in Robotics Research,
pages 89--98. Springer Berlin Heidelberg, 2009.
[26] Martin A. Fischler and Robert C. Bolles. Random sample consensus: a paradigm
for model fitting with applications to image analysis and automated cartography.
Commun. A CM, 24(6):381-395, 1981.
[27] David F Fouhey, Abhinav Gupta, and Martial Hebert. Data-driven 3d primitives
for single image understanding. ICCV, 2013.
[28] Igor Gilitschenski, Gerhard Kurz, Simon J. Julier, and Uwe D. Hanebeck.
Unscented orientation estimation based on the bingham distribution. 
CoRR,
abs/1311.5796, 2013.
147

[29] Jared Glover and Leslie Pack Kaelbling. Tracking 3-d rotations with the quater-
nion bingham filter. Technical Report MIT-CSAIL-TR-2013-005, 2013.
[30] Jared Glover and Sanja Popovic. Bingham procrustean alignment for object
detection in clutter. In Proceedings of IEEE/RSJ International Conference on
Intelligent Robots and Systems (IROS), 2013.
[31] Jared Glover, Radu Rusu, and Gary Bradski. Monte carlo pose estimation with
quaternion kernels and the bingham distribution. In Proceedings of Robotics:
Science and Systems, Los Angeles, CA, USA, June 2011.
[32] Shane Griffith, Kaushik Subramanian, Jonathan Scholz, Charles Isbell, and An-
drea L Thomaz. Policy shaping: Integrating human feedback with reinforcement
learning. In Advances in Neural Information Processing Systems, pages 2625-
2633, 2013.
[33] W. E. L. Grimson and D. P. Huttenlocher. On the sensitivity of the hough trans-
form for object recognition. IEEE Trans. Pattern Anal. Mach. Intell., 12(3):255--
274, 1990.
[34] W Eric L Grimson and Tomas Lozano-Perez. Model-based recognition and local-
ization from sparse range or tactile data. The International Journal of Robotics
Research, 3(3):3-35, 1984.
[35] W Eric L Grimson and Tomas Lozano-Perez. Localizing overlapping parts by
searching the interpretation tree. Pattern Analysis and Machine Intelligence,
IEEE Transactions on, (4):469-482, 1987.
[36] Berthold KP Horn. 
Closed-form solution of absolute orientation using unit
quaternions. JOSA A, 4(4):629-642, 1987.
[37] B.K.P. Horn. Extended gaussian images. Proceedings of the IEEE, 72(12):1671--
1686, 1984.
148

[38] Ashesh Jain, Thorsten Joachims, and Ashutosh Saxena. Learning trajectory pref-
erences for manipulators via iterative improvement. In International Conference
on Machine Learning (ICML) Workshop on Robot Learning, 2013.
[39] Andrew Johnson and Martial Hebert. 
Using spin images for efficient object
recognition in cluttered 3d scenes. IEEE Transactions on Pattern Analysis and
Machine Intelligence, 21(5):433 - 449, May 1999.
[40] Kshitij Judah, Saikat Roy, Alan Fern, and Thomas G Dietterich. Reinforcement
learning via practice and critique advice. In AAAI, 2010.
[41] PE Jupp and KV Mardia. Maximum likelihood estimators for the matrix von
mises-fisher and bingham distributions. The Annals of Statistics, pages 599- 606,
1979.
[42] S.B. Kang and K. Ikeuchi. The complex egi: A new representation for 3-d pose
determination. 
IEEE Transactions on Pattern Analysis and Machine Intelli-
gence, 15:707- 721, 1993.
[43] John T. Kent. Asymptotic expansions for the bingham distribution. Journal of
the Royal Statistical Society. Series C (Applied Statistics), 36(2):139-144, 1987.
ArticleType: primary-article / Full publication (late: 1987 / Copyright 
1987
Royal Statistical Society.
[44] John T Kent. The complex bingham distribution and shape analysis. Journal
of the Royal Statistical Society. Series B (Methodological), pages 285-299, 1994.
[45] John T Kent, Patrick DL Constable, and Fikret Er. Simulation for the complex
bingham distribution. Statistics and Computing, 14(1):53 -57, 2004.
[46] A. Kim and M.F. Golnaraghi. A quaternion-based orientation estiniation algo-
rithm using an inertial measurement unit. In Position Location and Navigation
Symposium, 2004. PLANS 2004, pages 268--272, 2004.
149

[47] W Bradley Knox and Peter Stone. Reinforcement learning from simultaneous
human and mdp reward. In Proceedings of the 11th International Conference on
Autonomous Agents and Multiagent Systems-Volume 1, pages 475-482. Interna-
tional Foundation for Autonomous Agents and Multiagent Systems, 2012.
[48] Jens Kober, Andreas Wilhelm, Erhan Oztop, and Jan Peters. Reinforcement
learning to adjust parametrized motor primitives to new situations. Autonomous
Robots, 33(4):361-379, 2012.
[49] P. Kormushev, S. Calinon, and D. G Caldwell. Robot motor skill coordina-
tion with EM-based reinforcement learning. In 2010 IEEE/RSJ International
Conference on Intelligent Robots and Systems (IROS), pages 3232-3237. IEEE,
October 2010.
[50] E. Kraft. A quaternion-based unscented Kalman filter for orientation tracking.
In Information Fusion, 2003. Proceedings of the Sixth International Conference
of, volume 1, pages 47-54, 2003.
[51] Andreas Krause and Cheng S Ong. Contextual gaussian process bandit optimiza-
tion. In Advances in Neural Information Processing Systems, pages 2447-2455,
2011.
[52] A. Kume and Andrew T. A. Wood. Saddlepoint approximations for the bingham
and Fisher-Bingham normalising constants. Biometrika, 92(2):465-476, June
2005.
[53] Karsten Kunze and Helmut Schaeben. The bingham distribution of quaternions
and its spherical radon transform in texture analysis. Mathematical Geology,
36(8):917 -943, November 2004.
[54] Y. Lamudan and H.J. Wolfson. Geometric hashing: A general and efficient model-
based recognition scheme. In Computer Vision., Second International Conference
on, pages 238--249, 1988.
150

[55] J.J. LaViola. A comparison of unscented and extended Kalman filtering for esti-
mating quaternion motion. In American Control Conference, 2003. Proceedings
of the 2003, volume 3, pages 2435-2440 vol.3, 2003.
[56] S. Linnainnaa, D. Harwood, and L.S. Davis. Pose determination of a three-
dimensional object using triangle pairs. IEEE Transactions on Pattern Analysis
and Machine Intelligence, 10:634-647, 1988.
[57] David G Lowe. Object recognition from local scale-invariant features. In Com-
puter Vision, 1999. The Proceedings of the Seventh IEEE International Confer-
ence on, volume 2, pages 1150-1157. Ieee, 1999.
[58] K. V. Mardia. Characterizations of directional distributions. In Statistical Dis-
tributiorIs in Scientific Work, volume 3, pages 365-385. D. Reidel Publishing
Company, Dordrecht, 1975.
[59] J.L. Marins, Xiaoping Yun, E.R. Bachmann, R.B. McGhee, and M.J. Zyda. An
extended Kalman filter for quaternion-based orientation estimation using MARG
sensors. In Intelligent Robots and Systems, 2001. Proceedings. 2001 IEEE/RSJ
International Conference on, volume 4, pages 2003--2011 vol.4, 2001.
[60] John Markoff. Google cars drive themselves, in traffic. The New York Times,
October 2010.
[61] M. Matsushima, T. Hashimoto, M. Takeuchi, and F. Miyazaki. A learning ap-
proach to robotic table tennis. Robotics, IEEE Transactions on, 21(4):767-771,
2005.
[62] Leon Mirsky. A trace inequality of john von neumann. Monatshefte fir Mathc-
matik, 79(4):303-306, 1975.
[63] F. Miyazaki, M. Takeuchi, M. Matsushima, T. Kusano, and T. Hashimoto. Real-
ization of the table tennis task based on virtual targets. In Robotics and Automa-
tion, 2002. Proceedings. ICRA '02. IEEE International Conference on, volume 4,
pages 3844-3849 vol.4, 2002.
151

[64] Fumio Miyazaki, Michiya Matsushima, and Masahiro Takeuchi. 
Learning to
dynamically manipulate: A table tennis robot controls a ball and rallies with a
human being. In Advances in Robot Control, pages 317-341. 2006.
[65] Jonas Mockus. Bayesian approach to global optimization: theory and applica-
tions. Kluwer Academic Dordrecht, The Netherlands, 1989.
[66] Katharina Milling, Jens Kober, Oliver Kroemer, and Jan Peters. Learning to
select and generalize striking movements in robot table tennis. The International
Journal of Robotics Research, 32(3):263-279, 2013.
[67] Stephen R Niezgoda and Jared Glover. Unsupervised learning for efficient texture
estimation from limited discrete orientation data. Metallurgical and Materials
Transactions A, pages 1-15, 2013.
[68] Tullis C Onstott. Application of the bingham distribution function in paleo-
magnetic studies. Journal of Geophysical Research: Solid Earth (1978-2012),
85(B3):1500-1510, 1980.
[69] Jan Peters, Katharina Milling, Jens Kober, Duy Nguyen-Tuong, and Oliver
Kr6mer. Towards motor skill learning for robotics. In Robotics Research, pages
469-482. Springer, 2011.
[70] Patrick M Pilarski and Richard S Sutton. Between instruction and reward:
Human-prompted switching. In 2012 AAAI Fall Symposium Series, 2012.
[71] Marc Raibert and Myung Chung. BigDog, the Rough-Terrain quadruped robot.
In Proceedings of the 17th IFAC World Congress, volume 17, COEX, Korea,
South, 2008.
[72] Herbert Robbins. Some aspects of the sequential design of experiments. Bulletin
of the American Mathematical Society, 58(5):527-535, 1952.
[73] Radii Bogdan Rusu, Nico Blodow, and Michael Beetz. Fast Point Feature His-
tograms (FPFH) for 3D Registration. In Proceedings of the IEEE International
Conference on Robotics and Automation (ICRA), Kobe, Japan, May 12-17 2009.
152

[74] Radu Bogdan Rusu, Gary Bradski, Romain Thibaux, and John Hsu. Fast 3d
recognition and pose using the viewpoint feature histogram. In Proceedings of
the 23rd IEEE/RSJ International Conference on Intelligent Robots and Systems
(IROS), Taipei, Taiwan, 10/2010 2010.
[75] H Schaeben. Texture approximation or texture modelling with components rep-
resented by the von mises-fisher matrix distribution on so (3) and the bingham
distribution on s4++. Journal of applied crystallography, 29(5):516-525, 1996.
[76] S. Schaefer, J. Hakenberg, and J. Warren. Smooth subdivision of tetrahedral
meshes. In Proceedings of the 2004 Eurographics/ACM SIGGRAPH symposium
on Geometry processing, pages 147-154, Nice, France, 2004. ACM.
[77] Tomonari Sei and Alfred Kune. Calculating the normalising constant of the bing-
ham distribution on the sphere using the holononic gradient method. Statistics
and Computing, pages 1-12, 2013.
[78] William D Smart and L Kaelbling. Effective reinforcement learning for mobile
robots. In Robotics and Automation, 2002. Proceedings. ICRA'02. IEEE Inter-
national Conference on, volume 4, pages 3404--3410. IEEE, 2002.
[79] Niranjan Srinivas, Andreas Krause, Sham M Kakade, and Matthias Seeger. Gaus-
sian process optimization in the bandit setting: No regret and experimental de-
sign. arXiv preprint arXiv:0912.3995, 2009.
[80] Yichao Sun, Rong Xiong, Qiuguo Zhu, Jun Wu, and Jian Chu. Balance motion
generation for a hunanoid robot playing table tennis. In 2011 11th IEEE-RAS
International Conference on Humanoid Robots (Humanoids), pages 19-25. IEEE,
October 2011.
[81] Jie Tang, Stephen Miller, Arjun Singh, and Pieter Abbeel. A textured object
recognition pipeline for color and depth image data. In Robotics and Automation
(ICRA), 2012 IEEE International Conference on, pages 3467-3474. IEEE, 2012.
153

[82] Stefanie Tellex, 
Thomas Kollar, Steven Dickerson, 
Matthew R Walter,
Ashis Gopal Banerjee, Seth J Teller, and Nicholas Roy. Understanding nat-
ural language commands for robotic navigation and mobile manipulation. In
AAAI, 2011.
[83] Andrea L Thomaz and Cynthia Breazeal. Teachable robots: Understanding
human teaching behavior to build more effective robot learners. Artificial Intel-
ligence, 172(6):716-737, 2008.
[84] D Thompson and Joseph L Mundy. Three-dimensional model matching from an
unconstrained viewpoint. In Robotics and Automation. Proceedings. 1987 IEEE
International Conference on, volume 4, pages 208-220. IEEE., 1987.
[85] Robert Tibshirani and Trevor Hastie. Local likelihood estimation. Journal of
the American Statistical Association, 82(398):559-567, June 1987. ArticleType:
research-article / Full publication date: Jun., 1987 / Copyright 1987 American
Statistical Association.
[86] Federico Tombari, Samuele Salti, and Luigi Di Stefano. Unique signatures of
histograms for local surface description. Computer Vision ECCV 2010, pages
356-369, 2010.
[87] Andrew TA Wood. Estimation of the concentration parameters of the fisher
matrix distribution on 50 (3) and the bingham distribution on sq, q 2. Australian
Journal of Statistics, 35(1):69-79, 1993.
[88] Jianxiong Xiao, Bryan C Russell, and Antonio Torralba. Localizing 3d cuboids
in single-view images. In NIPS, volume 2, page 4, 2012.
[89] Yuan-hui Zhang, Wei Wei, Dan Yu, and Cong-wei Zhong. A tracking and pre-
dicting scheme for ping pong robot. Journal of Zhejiang University SCIENCE
C, 12(2):110- 115, February 2011.
154

