UC Berkeley
UC Berkeley Electronic Theses and Dissertations
Title
Mobile Reactive Systems over Bigraphical Machines - A Programming Model and its 
Implementation
Permalink
https://escholarship.org/uc/item/830795dx
Author
Pereira, Eloi Teixeira
Publication Date
2015
 
Peer reviewed|Thesis/dissertation
eScholarship.org
Powered by the California Digital Library
University of California

Mobile Reactive Systems over Bigraphical Machines - A Programming Model
and its Implementation
by
El´oi Teixeira Pereira
A dissertation submitted in partial satisfaction of the
requirements for the degree of
Doctor of Philosophy
in
Engineering - Civil and Environmental Engineering
in the
Graduate Division
of the
University of California, Berkeley
Committee in charge:
Professor Raja Sengupta, Chair
Professor Edward Lee
Professor Alexandre Bayen
Summer 2015

Mobile Reactive Systems over Bigraphical Machines - A Programming Model
and its Implementation
Copyright 2015
by
El´oi Teixeira Pereira

1
Abstract
Mobile Reactive Systems over Bigraphical Machines - A Programming Model and its
Implementation
by
El´oi Teixeira Pereira
Doctor of Philosophy in Engineering - Civil and Environmental Engineering
University of California, Berkeley
Professor Raja Sengupta, Chair
In this dissertation we address the problem of bridging reactive programs and mobile
computing machinery embedded in physical spaces with dynamic structure. We propose
the BigActor Model as a bridging model between programs and logical-space models. The
BigActor model [1] combines Hewitt and Agha’s Actor model [2] for specifying concurrent
reactive programs with Robin Milner’s Bigraphical Model [3] for specifying the location and
connectivity of the computing machines. The BigActor Model makes location and connectiv-
ity ﬁrst-class citizens in distributed machines. This is analogous to another bridging model,
the von Neumann machine, which makes ﬁrst-class citizens of memory, instructions, and
their sequentiality. The BigActor Programming Language (BAL) is an implementation of
the BigActor Model. It has a runtime system named the BigActor Runtime System (BARS).
The BARS targets an abstract machine (bigraphs). The abstract machine has to be real-
ized on a physical space of mobile and distributed computing machines. The realization is
produced by the Logical-Space Execution Engine (LSEE), which bridges bigraphs with the
physical space. The Logical-Space Runtime System (LSRS) extends BARS with LSEE so
that programs written in BAL can seamlessly execute over physical spaces.
The second part of this dissertation is concerned with the formalization and implementa-
tion of the interactions between logical spaces and physical spaces. First, we approach this
problem formally, by introducing the logical-space computing semantics. In logical-space
computing, spatial agents operate over logical-space models while the runtime system is in
charge of interacting with the physical space. We presented an implementation that follows
the logical-space computing semantics. The LSRS uses the LSEE to generate logical-space
models using bigraphs. The physical space is modelled using polygons deﬁned using GPS
coordinates. The spatial agents are bigActors. Our implementation programs robots and
sensors in logical-space to execute an oil-spill monitoring exercise in the Atlantic. BigActor
programs execute over BARS, which interacts with physical spaces through the LSEE. LSEE
executes over the Robot Operating System (ROS) - an open-source middleware for robotics.
The physical machinery used in the demonstration consisted of one Air Force UAV, three

2
ground control stations, four drifters that broadcast their position using AIS, and one Navy
vessel equipped with a small speedboat. The Portuguese Navy emulated the oil-spill by
releasing 100kg of popcorn in the ocean.

i
To my parents Lourdes and Artur

ii
Contents
Contents
ii
List of Figures
iv
List of Tables
vii
1
Introduction
1
1.1
Models bridging programs and machines
. . . . . . . . . . . . . . . . . . . .
4
1.2
Spatial Models
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.3
Spatial programming models . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
I
Reactive programming on bigraphical machines
10
2
Observing and Controlling Bigraphs
11
2.1
Bigraphical formalism - a review . . . . . . . . . . . . . . . . . . . . . . . . .
11
2.2
Querying for local observations
. . . . . . . . . . . . . . . . . . . . . . . . .
20
2.3
Local bigraphical reaction rules
. . . . . . . . . . . . . . . . . . . . . . . . .
24
2.4
Final remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
3
BigActors
27
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
3.2
Actor model of computation - review . . . . . . . . . . . . . . . . . . . . . .
29
3.3
BigActor Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
3.4
BigActors Operational semantics
. . . . . . . . . . . . . . . . . . . . . . . .
38
3.5
Communication back-channelling
. . . . . . . . . . . . . . . . . . . . . . . .
50
3.6
Correctness of BigActor Model Semantics . . . . . . . . . . . . . . . . . . . .
52
3.7
Final remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
4
BigActor Programming Language
59
4.1
What is an Embedded DSL
. . . . . . . . . . . . . . . . . . . . . . . . . . .
60
4.2
Scala Programming Language . . . . . . . . . . . . . . . . . . . . . . . . . .
60
4.3
BARS - The BigActor Runtime System . . . . . . . . . . . . . . . . . . . . .
63

iii
4.4
A simulation environment for BigActors
. . . . . . . . . . . . . . . . . . . .
68
4.5
A case study in mobile robotics . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.6
Final remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
II Bridging logical and physical machines
80
5
Logical-Space Computing
81
5.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
5.2
Spatial Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
84
5.3
Bigraphs and Polygons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
5.4
Consistency of spatial structures . . . . . . . . . . . . . . . . . . . . . . . . .
89
5.5
Logical-Space Computing Semantics . . . . . . . . . . . . . . . . . . . . . . .
91
5.6
Correctness of control actions
. . . . . . . . . . . . . . . . . . . . . . . . . .
95
5.7
Using the semantics to enforce local consistency . . . . . . . . . . . . . . . .
99
5.8
Final remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
6
Case study: oil-spill monitoring mission
104
6.1
The bilge dumping problem
. . . . . . . . . . . . . . . . . . . . . . . . . . .
104
6.2
Vehicles and Sensors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
6.3
Logical-Space Runtime System . . . . . . . . . . . . . . . . . . . . . . . . . .
110
6.4
Logical-Space Execution Engine . . . . . . . . . . . . . . . . . . . . . . . . .
111
6.5
Final remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119
7
Conclusions
121
Bibliography
123

iv
List of Figures
1.1
A bridging model between programs and machines with dynamic structure. . . .
2
2.1
Example of a bigraph.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.2
Placing and Linking graphs of the bigraph of Figure 2.1. . . . . . . . . . . . . .
12
2.3
Example of a bigraph from ‵Bg(Kcity). . . . . . . . . . . . . . . . . . . . . . . .
15
2.4
Composition of the bigraph streetMap with the bigraph networkInf. . . . . . .
17
2.5
Abstract BBRs MOVE that moves a Smart node from its current location to a
Street node , and CONNECT that connects the Smart node to a Wlan node. . . .
18
2.6
Example of the application of the MOVE reaction rule. . . . . . . . . . . . . . . .
19
2.7
A bigraph trace resulting from applying the BRRs MOVE(sp,street1), MOVE(sp,street3),
and CONNECT(sp,wlan0).
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.8
BigActor observing the street map using query CHILDREN(PARENT(HOST)). . . . .
21
3.1
A pictorial representation of a bigActor system. . . . . . . . . . . . . . . . . . .
28
3.2
Speciﬁcation of the bigActor system for Example 3.1. . . . . . . . . . . . . . . .
29
3.3
Execution trace for the Example 3.1. . . . . . . . . . . . . . . . . . . . . . . . .
30
3.4
The Actor Model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
3.5
Grammar for actors syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
3.6
Actor operational semantics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
3.7
app and social actors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
3.8
Execution trace of the actor system {app, social}. . . . . . . . . . . . . . . . .
35
3.9
Actor system for Example 3.2 with new actors app, smartphone, and env.
. . .
36
3.10 BigActor system for scenario presented in Example 3.3. . . . . . . . . . . . . . .
37
3.11 BRRs MOVE HOST TO(Loc) and CONNECT HOST TO(Wlan). . . . . . . . . . . .
38
3.12 Grammar for bigActors syntax. . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
3.13 BigActors operational semantics.
. . . . . . . . . . . . . . . . . . . . . . . . . .
40
3.14 BigActor system for scenario presented in Example 3.5. . . . . . . . . . . . . . .
42
3.15 BigActors of Figure 3.14 embedded in the bigraph of Figure 2.3. . . . . . . . . .
42
3.16 Execution trace for the bigActor system of Figure 3.14. . . . . . . . . . . . . . .
44
3.17 Execution trace over the respective Bigraph Reactive System.
. . . . . . . . . .
45
3.18 Actor system synthesized to produce the projected trace of Figure 3.16. . . . . .
49
3.19 Areas of inﬂuence AB0
app2 and AB0
social2. . . . . . . . . . . . . . . . . . . . . . . . .
51

v
3.20 BigActor grabberBA. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
3.21 Example of an execution of grabberBA leading to an unsafe conﬁguration.
. . .
53
3.22 BigActors grabberBA0 and grabberBA1. . . . . . . . . . . . . . . . . . . . . . .
54
3.23 Example of an execution of multiple bigActors leading to an unsafe conﬁguration. 54
4.1
A simple actor class and its instantiation and invocation. . . . . . . . . . . . . .
61
4.2
A simple actor instantiated and invoked using the actor method. . . . . . . . .
62
4.3
Remote actor instantiation.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
4.4
Remote actor selection and use. . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
4.5
BigActor Runtime System. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
4.6
Deﬁnition of BigActor class.
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
64
4.7
Instantiation and invocation of a BigActor.
. . . . . . . . . . . . . . . . . . . .
64
4.8
Instantiation and invocation of a BigActor.
. . . . . . . . . . . . . . . . . . . .
65
4.9
Algebraic data type BigActorSchdlAPI that deﬁnes a set of messages to interact
with BigActorSchdl. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
4.10 Code skeleton for BigActorSchdl.
. . . . . . . . . . . . . . . . . . . . . . . . .
66
4.11 Algebraic data type BigraphManagerAPI that deﬁnes a set of messages to interact
with BigraphManager. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
4.12 Remote bigActor registering, selection and use.
. . . . . . . . . . . . . . . . . .
68
4.13 Remote bigActor instantiation.
. . . . . . . . . . . . . . . . . . . . . . . . . . .
68
4.14 BGM grammar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.15 Term specifying the bigraph of Figure 2.3
. . . . . . . . . . . . . . . . . . . . .
69
4.16 BigActor Runtime Syste on BigMC. . . . . . . . . . . . . . . . . . . . . . . . . .
70
4.17 Example of a bigraph generation for the mobile robotics case study. . . . . . . .
72
4.18 BGM term for the bigraph depicted in Figure 4.17. . . . . . . . . . . . . . . . .
73
4.19 Abstract BRRs modelling the set of control actions. . . . . . . . . . . . . . . . .
74
4.20 Abstract BRRs modelling the set of environment actions. . . . . . . . . . . . . .
74
4.21 BigActor specifying the oil-spill monitoring mission. . . . . . . . . . . . . . . . .
75
4.22 Deﬁnition of track oilSpills. . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
4.23 Deﬁnition of sample spill. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
4.24 Deﬁnition of ais receiver. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
4.25 Timeline for an exectuion of the BigActor system that speciﬁes the oil-spill mon-
itoring example. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
78
4.26 Deﬁnition of broadcast command that broadcasts a message to all bigActors
hosted at nodes linked to the host of the bigActors executing the command.
. .
79
5.1
Physical-space execution for Example 5.1.
. . . . . . . . . . . . . . . . . . . . .
82
5.2
Symbolical-space execution for Example 5.1. . . . . . . . . . . . . . . . . . . . .
83
5.3
BRRs that generates the symbolic-space execution depicted in Figue 5.2. . . . .
83
5.4
Logical space and physical space. . . . . . . . . . . . . . . . . . . . . . . . . . .
86
5.5
Logical-space execution for Example 5.1. . . . . . . . . . . . . . . . . . . . . . .
87
5.6
Logical-space execution for Example 5.5. . . . . . . . . . . . . . . . . . . . . . .
89

vi
5.7
Inconsistent structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
90
5.8
Spatial agent modelled as a bigActor. . . . . . . . . . . . . . . . . . . . . . . . .
96
5.9
Logical-space execution for the spatial agent of Figure 5.8. . . . . . . . . . . . .
96
5.10 Example of a feedback speciﬁed as a bigActor. . . . . . . . . . . . . . . . . . . .
101
6.1
CleanSeaNet SAR image with evidences of bilge dumping acquired in June 2009
oﬀthe coast of Spain. The suspected vessel was also detected in the SAR image.
The satellite image is compared with SafeSeaNet AIS database in order to identify
the suspected ship. Source: EOMag [4].
. . . . . . . . . . . . . . . . . . . . . .
106
6.2
High-resolution satellite image from the oil spill. Courtesy of EMSA.
. . . . . .
108
6.3
Alfa Extended UAV. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
110
6.4
Onboard UAV picture of the oil-spill (popcorn) and Navy vessel. . . . . . . . . .
110
6.5
Mission Visualization Tool.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
111
6.6
BigActor Runtime System for Logical-Space Programming. . . . . . . . . . . . .
112
6.7
ROS message deﬁnition for MobilityCommand. . . . . . . . . . . . . . . . . . . .
113
6.8
ROS message deﬁnition for PhysicalProp. . . . . . . . . . . . . . . . . . . . . .
113
6.9
ROS message deﬁnition for Location.
. . . . . . . . . . . . . . . . . . . . . . .
114
6.10 ROS message deﬁnition for Connection. . . . . . . . . . . . . . . . . . . . . . .
114
6.11 ROS message deﬁnition for Bigraph. . . . . . . . . . . . . . . . . . . . . . . . .
115
6.12 Bigraph Driver example. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
6.13 Distributed bigraph example.
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
117
6.14 BRR Driver example. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
6.15 Logical-space program for observing and tracking the oil-spill. . . . . . . . . . .
118
6.16 Code for bigActor handover.
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
119

vii
List of Tables
3.1
Encoding of Scala actor commands into the actors grammar. . . . . . . . . . . .
33
4.1
Sorting discipline for the mobile robotics case study. . . . . . . . . . . . . . . . .
72
5.1
Physical interpretation for the logical-space execution depicted by Figure 5.5 . .
88

viii
Acknowledgments
First and foremost I want to thank my adviser, Professor Raja Sengupta, for all his guidance
and support. Our collaboration started in 2007 when I did an internship at the Center for
Collaborative Control for Unmanned Vehicles (C3UV). Professor Sengupta made an assess-
ment of my research capabilities and limitations and put me in an unorthodox research path
- exploring the boundaries between the areas of “programming models” and “robotics”. This
dissertation is the result of our research endeavour, which was built from endless meetings
brainstorming on the white board or on a sheet of paper.
I would like to thank my dissertation committee, Professor Edward Lee and Professor
Alexandre Bayen for reading my dissertation, providing invaluable feedback. Professor Lee
has been endorsing this research work from the day I had the pleasure to present it to the
Ptolemy II research group. He provided insightful feedback regarding the formalization of
the model of computation and its applicability to swarm systems.
I want to thank the ﬁnancial support from the “Funda¸c˜ao para a Ciencia e Tecnologia”
and the Portuguese Studies Program (PSP) / Pinto-Fialon fellowship. In particular I want
thank the director of the PSP, Professor Deolinda Ad˜ao, for all her support and help since
the day I decided to apply to UC Berkeley.
I want to thank Professor Christoph Kirsch from University of Salzburg. Professor Kirsch
participated in the discussions that spawned our main research ideas. His expertise in the
area of “programming languages” was of paramount importance for the success of this work.
I want to thank Professor Bob Iannucci from Carnegie Mellon University for reading and
commenting this dissertation. Professor Iannucci attended a presentation where I introduced
our model of computation at a very early stage.
I want to thank Professor Jo˜ao Sousa from Porto University for his advise at early stages
of my doctoral studies and for his research suggestions.
I want to thank the Civil and Environmental Engineering Department, in particular the
graduate student adviser Shelley Okimoto.
I want to thank the Principal Investigators of the Cyber-Physical Cloud Computing lab
(CPCC), Professor Sengupta and Professor Kirsch, and the chief of the Portuguese Air Force
Academy Research group (CIAFA), Colonel Jos´e Morgado.
I would also like to thank my colleagues at CPCC and CIAFA, in particular the help and
support of Joshua Love, Hao Chen, Robert Hansen, Tiago Oliveira, Gon¸calo Cruz and Fran-
cisco Machado. I would like to give a special thanks for Pedro Marques da Silva and Clemens
Krainer for their tremendous inﬂuence and contributions on the software implementation.
I would like to thank the Ptolemy II research group, in particular Professor David Broamn
and Professor Stavros Tripakis for the help on the formalization of the semantics of the model.
Throughout the times of this PhD I had the pleasure to make some amazing friends.
I am thankful for the support and friendship of Maria, Catarina, Gon¸calo, Osni, Ricardo
Sousa, Blanca, Tim, Aude, Ryan, Samitha, Jack, Yusef, Cavaco, and Ricardo Guerreiro.
Now it is time for my Berkeley family.
I would like to thank Ana.
We started our
PhD journeys together and it is amazing to realize what we accomplished. I want to thank

ix
Richard and Sylvia for their support and advice provided during sweet breakfast chats or
during inspirational hikes. I want to thank the Abreu’s family for always making me feel
part of their own family. I am tremendously thankful to my “irm˜aos da vida” Carlos Oliveira
and Lu´ıs dos Santos for their companionship, and to my “greek girl” Eleftheria Stavridi for
her unconditional support and for keeping my levels of sanity, conﬁdence, and motivation
high so that I could reach the end of this dissertation.
Now in Portuguese. Quero agradecer a toda a minha fam´ılia em Portugal, em Fran¸ca
e aos restantes emigrados por este mundo. Agrade¸co os meus av´os Margarida, Adriano,
Rosalina e Antonio que muito lutaram para dar um futuro as suas fam´ılias.Por ﬁm, quero
dedicar esta disserta¸c˜ao aos meus pais, Lourdes e Artur. As suas vidas s˜ao hist´orias de
perseveran¸ca e determina¸c˜ao. S˜ao as minhas pricipais fontes de motiva¸c˜ao e de exemplo.
Estou tremendamente grato pelo vosso apoio incondicional, amor e educa¸c˜ao. Bem hajam!

1
Chapter 1
Introduction
In this dissertation we address the problem of bridging reactive programs and mobile
computing machinery embedded in physical spaces with dynamic structure. Our approach
is two-fold. In the ﬁrst part of we propose the BigActor Model as a bridging model between
programs and bigraphical machines. The BigActor model [1] combines Hewitt and Agha’s
Actor model [2] for specifying concurrent reactive programs with Robin Milner’s Bigraphical
Model [3] for specifying the location and connectivity of the computing machines.
The
BigActor Model makes location and connectivity ﬁrst-class citizens in distributed and mobile
systems. The approach is motivated by another bridging model, the von Neumann machine,
which makes ﬁrst-class citizens of memory, instructions, and their sequentiality.
The BigActor Programming Language (BAL) is an implementation of the BigActor
Model. It has a runtime system named the BigActor Runtime System (BARS). The BARS
targets an abstract machine modelled as bigraphs. The abstract machine must be realized
on a physical-space of mobile and distributed computing machines. The second part of this
dissertation is concerned with the formalization and implementation of this realization.
We propose a semantics named Logical-Space Computing, where spatial agents oper-
ate over logical-space models, such as bigraphs, while the runtime system is in charge of
interacting with the physical space. The mediation of these interactions is performed by
the Logical-Space Execution Engine (LSEE). The Logical-Space Runtime System (LSRS)
extends BARS with LSEE so that programs written in BAL can seamlessly execute over
physical spaces. Our implementation of the LSEE uses bigraphs as logical-space models
and polygons deﬁned using GPS coordinates as physical-space models. Spatial agents are
modeled as bigActors. Our implementation provides means for logical-space programming
of autonomous vehicles and a variety of spatial sensors. We present a case study where Un-
manned Aerial Vehicles (UAVs), GPS drifters, and vessels are programmed in logical-space
to perform a oil-spill monitoring mission.
Figure 1.1 depicts our approach for bridging logical-space programs and the physical
machine of networked autonomous vehicles and sensors. The bottom of Figure 1.1 depicts
the physical layer composed of heterogeneous computing machinery such as Unmanned Aerial
Vehicles (UAVs), vessels, ground control stations, drifters, and submarines. In the middle

CHAPTER 1. INTRODUCTION
2
Figure 1.1: A bridging model between programs and machines with dynamic structure.
we depict the bigraphical abstraction. The bigraph models location and connectivity of the
physical machinery, e.g., uav1 is located at oilSpill0 and is connected to gcs1. The top
of Figure 1.1 shows bigActor programs hosted at bigraph nodes, e.g., the ﬁrst bigActor is
hosted at uav0 and its behavior consists of moving its host to the location oilSpill0. Note
that programs are written over a symbolic model of space, i.e., a bigraph. The interactions
with the physical-space are speciﬁed by the logical-space computing semantics.
Computation is facing a paradigm shift from algorithmic calculation to interaction [5, 6].
The logic foundations of computation created by Alan Turing assumes that a computer is
a machine that performs calculations in an algorithmic fashion. This assumption is carried
by John von Neumann in the deﬁnition of the von Neumann machine [7]. According to
von Neumann, computing systems are devices that “carry out instructions to perform cal-
culations of a considerable order of complexity, e.g., to solve a non-linear partial diﬀerential
equation” [7]. Valiant [8] claims that the von Neumann model is of great engineering value
since it is the bridge that enables the chaotic world of sequential computer programs to
run eﬃciently over the chaotic world of hardware. The von Neumann model became the de
facto computing machine abstraction, which was followed by hardware industry making the
computer a consumer product.
Nonetheless, performing pure calculations such as solving partial diﬀerential equations
does not resonate for computation running over modern computing devices such as smart-
phones, autonomous vehicles, robots, and wireless sensor networks. Modern computation is

CHAPTER 1. INTRODUCTION
3
distributed, mobile, reactive, and interactive [9]. Computation lives ubiquitously embedded
and spatially distributed over the physical space. Computation moves together with comput-
ing machines. Computation reacts upon information from human users, and interacts with
the environment by means of sensors and actuators that equip modern computing machinery.
Perhaps the most signiﬁcant conceptual diﬀerence between modern computing machines
and the ones envisioned by Turing and von Neumann is that modern computing machines
change their structure over time. The environment is now explicitly part of computing ma-
chines and its dynamics can not be overlooked. For example, smartphones and autonomous
vehicles have the ability to move from one location to another, while their communication
structure may change deliberately or by inﬂuence of the environment. Computation exe-
cuting over these devices may execute diﬀerently according to their spatial context, e.g.,
requesting a smartphone to connect over a diﬀerent network. Computation may also inﬂu-
ence the environment, e.g., requesting an autonomous vehicle to change its location. In their
positioning paper, Zambonelli and Mamei [10, 11] advocate that modern computing machin-
ery needs new models of computation with spatial abstractions. Programming models must
include, as ﬁrst-class citizens, means for computation to locally sense the environment, to
actuate over the environment, and to express mobility.
Computation that exhibits spatial behavior is commonly known as spatial computing [12].
Spatial programming languages provide programmers with spatial constructs as a ﬁrst-class
citizen. Just as the von Neumann model became the de facto bridging model for sequential
computation, one needs new bridging models to connect the world of spatial programs and
the emergent world of mobile computing devices, robots, and autonomous vehicles.
We
address this problem from a theoretical point of view with the BigActor model and the
logical-space computing semantics, and provide a practical implementation in the area of
mobile robotics.
The remainder of this dissertation goes as follows. In the remaining of Chapter 1, we
position our work with respect to the literature on bridging models of computation, on
programming models for systems with dynamic structure, and on spatial computing models.
In Chapter 2 we review the bigraphical formalism and introduce a query language for
requesting local bigraphical observations.
In Chapter 3 we introduce the semantics of the BigActor model. The semantics is for-
malized using an operational style. We also formalize the correctness of BigActor executions
and provide suﬃcient conditions to achieve it. In Chapter 4 we present an implementation
of the model. The model is implemented as a Scala embedded Domain-Speciﬁc Language,
called the BigActor Language (BAL). BAL programs runs over the BigActor Runtime Sys-
tem (BARS), which interfaces with a bigraphical abstraction of the world. The bigraphical
executions are handled by a bigraph model checker. This ﬁnishes Part I of the thesis.
Part II of the thesis is concerned with bridging logical spatial abstractions with the
physical world. This is called logical-space computing. In Chapter 5 we introduce the logical-
space computing semantics and present a case where logical spaces are speciﬁed as bigraphs
and physical spaces are speciﬁed using geometrically-deﬁned polygons. We demonstrate the
use of bigActors as a logical-space programming language. In Chapter 6 we present a case

CHAPTER 1. INTRODUCTION
4
study of using logical-space computing to program vehicles and sensors performing an oil-spill
monitoring scenario. Our approach is to use bigraphs as a logical model of vehicles, sensors
and their surrounding maritime environment and use bigActors as a programming model for
specifying their interactive reactive behaviour. Logical-space programs are speciﬁed using
bigActors. We build a software system to explore and demonstrate the value of logical-space
computing when integrating and controlling a network of robots sensing an environment. The
physical model is implemented over the Robot Operating System (ROS) - an open-source
middleware for robotics. The physical machinery used in the demonstration consisted in
one Air Force UAV, three ground control stations, four drifters that broadcast their position
using AIS, and one Navy vessel equipped with a small speedboat. The Portuguese Navy
emulated the oil-spill by releasing 100kg of popcorn in the ocean. We ﬁnish this dissertation
in Chapter 7 with conclusions and future work.
1.1
Models bridging programs and machines
The von Neumann Machine (VNM) is a computer architecture for sequential programs [7].
As Valiant stated, VNM provides a bridge between sequential programs and the rich world
of computer hardware [8]. VNM was designed for stand-alone computation and, as such, it
does not entail means for explicitly model distributed systems.
Valiant [8] addresses this problem by introducing the Bulk-Synchronous Parallel (BSP)
model for bridging computation and distributed computing systems. Nonetheless, BSP does
not provide constructs for modelling mobility of computing devices and dynamic topology
of the networks that connect them.
One can ﬁnd in the literature programming models that provide dynamic structure as
ﬁrst-class citizen.
SHIFT [13] is a language that implements Dynamic Networks of Hy-
brid Automata (DNHA) where components modelled as hybrid systems can be created,
interconnected and destroyed as the execution evolves. R-Charon [14] extends Charon, an
agent-based language for specifying interacting hybrid systems, with network reconﬁgura-
tion. Inﬂuenced by SHIFT and R-Charon, we introduced the Structure Model (SM) [15] for
modelling and controlling the structure of networked robotic systems. The model introduces
structural dynamics to Nancy Lynch’s Synchronous Network Model [16]. The actor model [2]
was introduced by Hewitt and Agha as a model for reactive, concurrent, and distributed sys-
tems. An actor can communicate with another actor if it has its address. Actor systems can
implicitly model dynamic structure, evidenced by the communication of addresses between
diﬀerent actors. With the π−calculus [17], Milner addresses the problem of dynamic con-
nectivity explicitly by deﬁning channels as ﬁrst-class citizens. Luca Cardelli took a diﬀerent
route by pointing that computation is not only constrained by its communication topology
but also by its location. Cardelli’s Ambient Calculus [18] addresses the problem of mobility
by deﬁning ambients - a bounded location where computation may occur. Inﬂuenced by
Hewitt’s and Cardelli’s work, Robin Milner introduced Bigraphs, combining both dynamic
location and connectivity in a single model [3].

CHAPTER 1. INTRODUCTION
5
Debois and Milner posed the problem of how to bridge Turing-computation and ubiqui-
tous computing machines with complex physical behaviors [19]. The authors claim that, in
ubiquitous systems, the complex world of machines and their environment demand diﬀerent
models than the ones used to describe Turing-computation. Their approach is to model both
layers using two diﬀerent Bigraph Reactive Systems that are semantically combined.
In his essay “The tower of informatic models” [20], Robin Milner introduces a modelling
practice to semantically combine models that address diﬀerent aspects of computing be-
haviour. In a tower of models, one can combine models horizontally, e.g., two models with
two diﬀerent semantics are combined together to form a third one. One can also vertically
explain a model into anther one, as far as the target model is at least as expressive as the
original one. This practice is analogous to compilation.
Inﬂuenced by Milner’s tower of models, we introduced the BigActor model for bridg-
ing computation and mobile systems with dynamic structure [1, 21]. In [19], Debois and
Milner use only Bigraph Reactive Systems as modelling formalism. We take a diﬀerent ap-
proach. We model computation using the Actor model [2] - a well known model of concurrent
computation adopted by large spectrum of modern programming languages. For modelling
machines and their dynamic structural behavior we use Bigraph Reactive Systems. The two
models are horizontally combined by the BigActor semantics. The ﬁrst step towards a verti-
cal explanation of bigActors is presented in [22], where we introduce a bigraphical encoding
of actors.
The design decisions behind the BigActor model relied on the following engineering con-
siderations. The asynchronous-message passing provided by the actor semantics suits the
networked robotic applications that we primarily target. Moreover, the actor model has been
adopted as the concurrent model of a large number of modern programming languages such
as Scala [23], Erlang [24], Ptolemy II [25], and the Akka framework [26]. We are interested
in robotic systems that vary their location and connectivity during their execution, e.g.,
an UAV changing its communication capabilities while ﬂying from one location to another.
Since both location and connectivity are ﬁrst-class citizens in bigraphs [3], we choose Milner’s
model as the underlying spatial model.
1.2
Spatial Models
Location models are used in a variety of applications ranging from ubiquitous systems,
autonomous vehicles, indoor robotics, and mobile computing. According to Hightower and
Borriello [27] there are two classes of location models for ubiquitous computing: physical and
symbolical. Physical location models are concerned with geographical position of an entity
in the world. Symbolic location models deﬁne symbolically the location of entities.
Becker and Durr [28] categorize symbolic space models into set-based, graph-based mod-
els. Set-based models deﬁne space as set of names, e.g., the collection of house numbers
in US Postal addresses. Using set intersection one can implicitly determine the overlapping
between locations and containment relations. Graphs are used to explicitly model physi-

CHAPTER 1. INTRODUCTION
6
cal relations between sets of symbolic names. For example, vertices can be used to model
physical adjacency or containment relation between names.
While physical location models are commonly used for applications that require geograph-
ical information of the world, e.g., GPS waypoint control of unmanned vehicles, symbolic
models are used in domains such as indoor localization and navigation [29, 30, 31], robot
exploration and mapping [32], speciﬁcation and veriﬁcation of robotic trajectories [33].
The bigraphical formalism introduced by Robin Milner [3] is a graph-based symbolic
model that models explicitly both location and connectivity. The model uses two graphical
structures over the same set of nodes, a forest named placing graph and an hypergraph
named linking graph. The placing graph models containment relations, e.g., a smartphone
located inside a room which is inside a building. The linking graph models connectivity
between entities, e.g., physical adjacency between two rooms or network connectivity of a
smartphone. With the bigraphical formalism one can also model dynamical properties of
space by means of Bigraph Reaction Rules (BRR). A set of bigraphs and a set of reactive
rules that models their dynamics is known as a Bigraph Reactive System (BRS). With the
advent of informatics and the internet, Milner envisioned that location and connectivity are
necessary for modelling mobility of ubiquitous computing systems.
The literature shows other uses of bigraphs for modelling space. Walton and Worboys
[34, 35] propose the use of bigraphs for modelling indoor environments and the dynamics of
entities within them. Birkedal et al. [36] present bigraphs as a model for context-aware and
symbolic location-aware systems. In our case study, vehicles and sensors change both location
and connectivity. Hence, we choose bigraphs as our spatial model. For example, while the
UAV moves from one location to another there is often the need to change control authority
from one ground station to another. This manoeuvre is known as handover. A handover
manoeuvre is seen as a change of connectivity between an UAV and ground stations.
Symbolic models usually have a small location space compared with physical models.
Moreover, locations can be conveniently named turning a spatial model speciﬁc to a given
domain. Nonetheless, physical information is often needed. For example, to move an UAV
from one location to another one needs the GPS location of the destination. Zender et al.
[37] and Galindo et al. [38] present hybrid models that combine information at diﬀerent
layers of abstraction, such as geometric, topological, and ontological. Using hybrid mod-
els, the programmer has means to model space both symbolically, e.g., a set of names with
explicit nested relation, and physically, e.g., augmenting each symbolic name with geomet-
rical coordinates. Note that these hybrid approaches may lead to inconsistencies between
the explicit relations modelled symbolically and the implicit relations between the physical
interpretation of locations. For example, one can explicitly model a person inside a building
while the GPS coordinates of the person are not contained by the GPS-deﬁned polygon that
deﬁnes the building.
With logical-space computing [39, 40] we take a diﬀerent approach. Instead of oﬀering the
programmer with a hybrid abstraction that blends both physical and symbolical information,
programs operate over a symbolic model named logical space, while the runtime system is
in charge of interacting with the physical space. The consistency between the logical space

CHAPTER 1. INTRODUCTION
7
and the physical space is ensured by the logical-space computing semantics. The aim is to
keep the simplicity of programming over symbolic spacial abstractions, while still being able
to make the desired eﬀects over the physical space.
1.3
Spatial programming models
In this section, we position the BigActor Programming Language in the literature of
spatial programming languages. The BigActor Programming Language (BAL) is a spatial
programming language that follows the bigActor semantics. It is implemented as an exten-
sion of the Scala Actor Library. BAL programs run over a runtime system, named BigActor
Runtime System (BARS), which interfaces with an abstract bigraphical machine. BARS
is introduced in Chapter 4. BARS logically host a bigActor instance by a bigraph node
that models the underlying computing machine. Besides the regular Scala Actor commands
(i.e. spawn new bigActors and asynchronously sending messages), a bigActor program can
query the bigraphical space model for local observations, request control actions to change
the bigraph, and request to migrate from its current host to another host. The interactions
with the physical world are formalized by the logical-space computing semantics presented
in Chapter 5. The Logical-Space Execution Engine (LSEE), presented in Chapter 6, is a
software layer that bridges BARS with a physical world of robots and sensors performing an
environmental monitoring mission.
Beal et al. [12] present a survey of spatial computing programming models. The authors
survey eight diﬀerent ﬁelds: amorphous computing, biological, agent-based, pervasive com-
puting, robotics, parallel and reconﬁgurable computing, and formal calculi. The authors
compare the models according to their characteristics (e.g. paradigm and target platforms),
operators to observe and control the environment, and characteristics of the environment
abstraction (e.g. discretization and granularity). Next we review some relevant models and
relate them with BAL.
Amorphous computing [41] is concerned with systems of large families of homogeneous,
unreliable, locally communicating, simple computation devices. Proto [42, 43] is an amor-
phous programming language for programming spatial computers using a continuous space
abstraction. It is concerned with collections of devices that are distributed to ﬁll the space
and where communication capability between devices is strongly coupled with their distance.
Rather than specifying the behaviour of individual entities, a proto program speciﬁes the
behaviour of regions of space. The programs are automatically distributed to a collection
of devices which actions produce an approximation of the aggregate behaviour. BAL does
not require computing agents to be homogeneous. Moreover, we are interested in internet-
based systems where connectivity between two entities might not be directly related to their
physical distance. BAL uses the bigraphs to model space, which provide an abstract model
of connectivity. The dynamics is formalized using Bigraph Reaction Rules, which are not
necessarily triggered by physical distance.
Borcea et al. [44] introduce the Spatial Programming (SP) language. SP provides high

CHAPTER 1. INTRODUCTION
8
level abstractions for network-transparent access to data and services distributed across the
physical space. The main concept behind SP is the one of spatial references. Spatial ref-
erences are tuples of the kind space : name that model physical geographical regions where
computation is embedded. SP runs over a Smart Messages [45] runtime system. Smart mes-
sages is a model of concurrency based on migration of computing entities through a shared
memory space. Gaia [46] is another relevant spatial computing platform. The Gaia frame-
work provides a runtime environment to support the concept of active spaces. An active
space is a physical space augmented with computing devices and software to enhance its
capabilities. Gaia works as a meta operating system that supports active space applications.
Such applications are developed in the context of generic active spaces. Gaia OS adapts the
application requirements to the particular properties of its associated physical space, foster-
ing code reusability. With SP and Gaia the programmer has control over both symbolical
and physical spaces. With BAL the programmer only has access to a symbolic spaces while
the runtime system is in charge of interfacing the physical world. BAL deliberately reduces
the expressiveness of the programmer for the sake of a correct physical execution that is
ensured by the runtime system.
Biological systems often exhibit locality and spatial structures. MGS [47] is a declarative
programming language for simulation of biological processes. Computation in MGS is deﬁned
using topological collections that are manipulated using transformation rules. A program in
MGS locally manipulates values and modify local structures. Thus, MGS is capable of sim-
ulating dynamic systems with dynamical structure. MGS is developed speciﬁcally to model
biological processes symbolically. BAL programs run over BARS, which interfaces with an
abstract bigraphical machine. The bigraphical machine can be physically realized for target-
ing a variety of systems and applications. In this dissertation we formalized this realization
semantically and provide a implementation that targets mobile robotic applications.
On can ﬁnd in the literature spatial computing languages that emerged from the area of
robotics [48]. The amorphous computing language Proto is used to specify the behaviour
of swarms of homogeneous robots that are programmed to ﬁll a space [49, 50]. DynaRole
[51] and RoCoRo [48] (a generalization of DynaRole inspired by Proto) are languages for
modular robotics. Both languages are role-based and provide constructs to specify robot’s
local behaviors which are active in given contexts. Konur et al. [52] investigates the use
of probabilistic model checking for specifying and formally analyse swarms of robots. The
authors specify a foraging robot scenario in PRISM model checker as Discrete-Time Markov
Chains (DTMC). The speciﬁcation is written using the probabilistic temporal logic PCTL.
Klavis et al. [53] present a class of graph grammars (also known as graph rewriting systems)
to model and control concurrent self-organizing robots. The robotic system is represented as
a labelled graph where the nodes of graphs represent robots and labels represent their state
while edges represent their interactions. The Collaborative Sensing Language (CLS) [54] is
a language for the speciﬁcation of ad-hoc mobile robot networks. In CSL the programmer
speciﬁes the mission (e.g. a sequence of tasks like visiting a location, patrolling a line, survey
an area, etc.) in a Petri-net like fashion. The programmer does not specify speciﬁc robot
behaviours but rather focus on the overall mission speciﬁcation. The Collaborative Sensing

CHAPTER 1. INTRODUCTION
9
System takes the mission speciﬁcation and allocates the available resources to perform the
mission according to some notion of optimality (e.g. distance travelled by the robots). The
CSL/CSS framework was demonstrated using teams of UAVs performing surveillance tasks.
BAL targets heterogeneous robotic systems that requires location and connectivity as ﬁrst-
class citizens. We speciﬁcally address the area of unmanned vehicles and present a case
study where a programmer uses BAL to specify the spatial behavior of vehicles and sensors
performing an environmental monitoring mission. This is presented in Chapter 6.

10
Part I
Reactive programming on bigraphical
machines

11
Chapter 2
Observing and Controlling Bigraphs
This dissertation addresses computation that is able to observe and to control the space
where it is embedded, e.g., a robot observing the environment with its sensors and aﬀecting
the environment using its actuators, or a person moving around a city with a smartphone
taking pictures.
Our spatial worlds are modelled as bigraphs, including the computing machinery (e.g.
robots, smartphones, etc.). Thus, computation addressed in this dissertation, observes and
controls bigraphical worlds. For example, BigActors introduced in Chapter 3, are comput-
ing entities embedded in spatial dynamic worlds modelled as bigraphs. They can perceive
their bigraphical environment by querying for observations and inﬂuence the environment
by requesting control actions speciﬁed as reaction rules.
In this chapter we investigate how to generically observe and control bigraphical worlds.
This provides the foundations for modelling the interactions between bigActors and the un-
derlying bigraphical world. The semantic glue that binds bigActors and bigraphs is presented
In Chapter 3 where we introduce the BigActor Model and its semantics.
In Section 2.1 we provide a review of the bigraphical model. This review is not intended
to be an exhaustive presentation but rather cover the necessary formalism to understand the
remainder of this dissertation. For a complete exposition on bigraphs see [3].
In Section 2.2 we introduce a query language to locally observe bigraphs. This approach
contrasts with other bigraphical approaches in the literature [36, 19] where both the reactive
behaviour and observations are modelled using Bigraph Reactive Systems (BRS).
In Section 2.3 we formalize how to locally control bigraphs.
2.1
Bigraphical formalism - a review
As the name suggests a bigraph is a mathematical structure with two graphs, the place
graph - a forest that represents nested locality of components and the linking graph - a
hypergraph that models connectivity between components. Figure 2.1 presents an example
of a bigraph. The corresponding placing and linking graphs are presented in Figure 2.2

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
12
0
Figure 2.1: Example of a bigraph.
Figure 2.2: Placing and Linking graphs of the bigraph of Figure 2.1.
Place graphs are contained inside regions 1 and may also contain holes2. Regions and
holes enable composition of placing graphs, i.e. a hole of a given bigraph can be replaced by
a region of another bigraph using the composition operator. We explain composition later.
A linking graph may contain hyperedges and inner names and outer names3. Just as
one can ﬁt regions inside holes, one can also merge inner names and outer names using the
bigraph composition operator.
A node can have ports4 which are points for connections to edges or names. The kinds
of nodes and their number of ports (arity) are the signature of the bigraph.
The signature takes the form (K, ar) where K is a set of kinds of nodes called controls
and ar : K →N assigns an arity (i.e. a natural number) to each control. Each node in
the bigraph is assigned a control. For example, the bigraph of Figure 2.1 has the following
1Regions are graphically represented by dashed rectangles and are also known as roots
2Holes are graphically represented as gray rectangles and are also known as sites
3Names are graphically represented by a line connected at one end to a port or an edge and the other
end is left loose.
4Ports are graphically represented as black dots on the node.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
13
signature: K = {M : 1, Q : 2} where mi has kind M with arity 1 and qi has kind Q with
arity 2. By convention we start kind names with upper-case characters and node names with
lower-case characters.
A bigraph b is called concrete when each node and each edge is assigned a unique identiﬁer
(known as support). The set of concrete bigraphs with a signature K is denoted as ‵Bg(K).
A bigraph without support is called abstract. In abstract bigraphs, nodes are exclusively
denoted by their controls. The structure of an abstract bigraph is deﬁned algebraically. The
set of abstract bigraphs with a signature K is denoted as Bg(K).
We almost exclusively use concrete bigraphs and thus we devote this section to present
them formally. For a formal deﬁnition of abstract bigraphs see [3], Chapter 3.
Deﬁnition 2.1. A concrete bigraph b is deﬁned as a 5-tuple together with its interface.
b = (V, E, ctrl, prnt, link)
where
• V is a set of node identiﬁers.
• E is the set of hyperedge identiﬁers.
• ctrl : V →K is a control map that assigns controls to nodes.
• prnt : m ⊎V →V ⊎n5 is the parent map that assigns a parent (a node or a region) to
a hole or a node. The set of holes is deﬁned as m = {0, . . . , |m| −1} while the set of
regions is deﬁned as n = {0, 1, . . . , |n| −1}.
• link : X⊎P →E⊎Y is the link map that assigns edges and outer names to inner names
and ports. The set of ports P is formalized as P = {(v, i) | i ∈{0, 1, . . . , ar(ctrl(v)) −
1}}.
Let ⟨m, X⟩→⟨n, Y ⟩be the interface of b (denoted as b : ⟨m, X⟩→⟨n, Y ⟩). ⟨m, X⟩is called
the inner face of b and speciﬁes the set of inner names X and the set of holes m. ⟨n, Y ⟩is
called the outer face of b and speciﬁes the set of outer names Y and the set of regions n.
Example 2.1. Let b be the bigraph depicted in Figure 2.1. b is deﬁned as
(V, E, ctrl, prnt, link) : ⟨{0}, x⟩→⟨{0}, y⟩
5The symbol ⊎denotes the exclusive union operator for sets.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
14
where:
V = {m0, m1, m2, q0, q1}
(2.1)
E = {e}
(2.2)
ctrl(v) =
(
M : 1,
if v ∈{m0, m1, m2}
Q : 2,
if v ∈{q0, q1}
(2.3)
prnt(v) =









0,
if v = m2
m0,
if v = q0
m1,
if v ∈{q1, 0}
m2,
if v ∈{m0, m1}
(2.4)
link(l) =
(
e,
if l ∈{x, (m0, 0), (m1, 0), (q0, 0), (q1, 0)}
y,
if l ∈{(q0, 1), (q1, 1), (m2, 0)}
(2.5)
P = {(m0, 0), (m1, 0), (m2, 0), (q0, 0), (q0, 1), (q1, 0), (q1, 1)}
(2.6)
We use bigraphs to model the location and connectivity of computing machines and their
physical environment.
Example 2.2. Consider users with smartphones walking on a city. A user can walk from
one street to an adjacent one. Streets may contain buildings. Some streets may also contain
wireless hotspots which can be connected to the internet. If a smartphone is contained in a
wireless hotspot it can connect to it.
In order to model this physical reality using bigraph, ﬁrst we must deﬁne the bigraph
signature K.
Kcity = {Street : 1, WiFi : 1, Smart : 2, Building : 0}
(2.7)
The nodes of kind Street model streets. The connectivity of Street nodes models their
physical adjacency (arity 1). The nodes of kind WiFi model wireless hotspots. The con-
nectivity of WiFi nodes models their network topology (arity 1). The nodes of kind Smart
model smartphones. The connectivity of Smart nodes models its connectivity to wireless
hotspots and to 3G network providers (arity 2). The nodes of kind Building model build-
ings. Building nodes have 0 arity and thus do not deﬁne a connectivity structure.
Figure 2.3 depicts a bigraph from ‵Bg(Kcity). The ﬁgure shows a city with six nodes of
kind Street (grey boxes), namely street0 to street5. All streets but street5 are con-
nected with a link named road which models physical adjacency between the corresponding
physical locations. Some streets contain nodes of kind WiFi (blue circle), namely street3
contains wlan0 and street4 contains wlan1. A smartphone modelled as a node sp (white
star) is located at street2. A server modelled as a node srv (green star) is located at
street5. The nodes wlan0, wlan1, and srv all share a link named internet modelling the
connectivity of the corresponding entities to the internet. The nodes street1 and street0

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
15
internet
Figure 2.3: Example of a bigraph from ‵Bg(Kcity).
contains nodes of kind Building, namely build0 to build3. The dark gray box inside the
nodes of kind Building are holes. They model the fact that there might be some structure
inside those nodes (e.g. ﬂoors, rooms, corridors, etc.) but it is abstracted away in this
representation.
Note that the signature of the bigraph does not impose any structural constraint rather
than the arity of the nodes. One must be able to specify, for example, that Street nodes
can contain Smart nodes but not the reverse. This kind of structural constraints are deﬁned
using a sorting discipline.
Sorting
Milner [3] introduces a typing discipline named Sorting. Sorting provides means to con-
strain the kind of bigraphs that generate from a given signature.
Deﬁnition 2.2 (place sorting). A place sorting is deﬁned as Σ = (Θ, K, Φ) where Θ is a
set of sorts, K is a sorted signature over Θ, and Φ is the formation rule of Σ, i.e. a set of
properties that the sorted bigraph place structure must satisfy. By convention, sorts range
over a, b, . . . , z. Disjunctive sorts are denoted as bab meaning either sort a or sort b.
Example 2.3. Let Σcity = (Θ, Kcity, Φ) where Θ = {s, w, p, b}, Kcity = {Street : s, WiFi :
w, Smart : p, Building : b}, and Φ given by:
• an p−node is atomic
• all children of a s−node have either sort w, p, or b
• all children of a b−node have either sort p or w

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
16
• all children of a w−node have sort p
• all children of an s−root have sort s
• all children of an d
pwb−root have either sort p, w, b, or d
pwb
• all children of an θ−root have sort θ where θ ∈Θ
Operations on bigraphs
Milner introduced two operators for combining bigraphs, the composition operator and
the tensor product.
The composition operator is deﬁned by matching interfaces. Like function composition,
a bigraph A : I →J composed with a bigraph B : K →I is a bigraph C : K →J.
Deﬁnition 2.3. Let
A = (VA, EA, ctrlA, prntA, linkA) : ⟨ma, Xa⟩→⟨na, Ya⟩
and
B = (VB, EB, ctrlB, prntB, linkB) : ⟨mb, Xb⟩→⟨nb, Yb⟩
The composition of bigraphs A and B, denoted by A ◦B, is a bigraph
C = (VC, EC, ctrlC, prntC, linkC) : ⟨mb, Xb⟩→⟨na, Ya⟩
where VC = VA ⊎VB, EC = EA ⊎EB, ctrlC = ctrlA ⊎ctrlB. prntC is obtained by “ﬁlling”
the holes of A with regions of B while linkC is obtained by “merging” the inner names of A
with the outer names of B. By convention, the regions are matched to holes with the same
indices and inner names are matched with outer names with the same name. For a formal
deﬁnition of prntC and linkC see [3], page 17. The composition A ◦B is well deﬁned iﬀthe
outer face of B is equal to the inner face of A, i.e. ⟨nb, Yb⟩= ⟨ma, Xa⟩.
Example 2.4. Consider the bigraphs of Figure 2.4. The bigraph streetMap : ⟨6, ∅⟩→⟨1, ∅⟩
models a street map where the grey nodes represent streets and links represent physical
adjacency between street nodes. Bigraph networkInf : ⟨6, ∅⟩→⟨6, ∅⟩models a network
infrastructure where the blue nodes denote places with network connectivity (local area
networks (LAN), wireless LAN, etc.) and links represent connectivity which is linked to
name internet denoting the internet. The bigraph resulting from the composition of both
bigraphs is streetMap ◦networkInf : ⟨6, ∅⟩→⟨1, ∅⟩. Note that since the networkInf kept
the holes inside street nodes one could compose streetMap◦networkInf with other features
(e.g. cars, pedestrians, utilities network, etc.).
Milner also introduced another operator to combine bigraphs called the tensor product.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
17
internet
internet
Figure 2.4: Composition of the bigraph streetMap with the bigraph networkInf.
Deﬁnition 2.4. Let A and B be bigraphs that do not share inner or outer names. The
tensor product of A and B, denoted by A ⊗B, is the juxtaposition of both bigraphs where
indices of holes and regions of B are made unique with respect to A. The names of tensor
product are the union of the names of both bigraphs. The tensor product is a bifunctor of
a symmetric monoidal category with interfaces as objects and bigraphs as arrows [3].
Dynamics
Consider again the bigraph of Figure 2.3. The bigraph represents a speciﬁc snapshot of
the world but there is no information on how it can evolve to another bigraph. For example,
where can the smartphone sp move and in what conditions it can connect to the internet.
This is speciﬁed using Bigraph Reaction Rules (BRR).
A BRR is a tuple (R, R′, η) where R and R′ are bigraphs called respectively redex 6 and
reactum. The redex is the portion of the bigraph to be matched and the reactum is the
bigraph that replaces the matched portion. η is called the instantiation map and indicates
how holes in R correspond to holes in R′. If η is the identity map, then we represent the
rule as R →R′. For the reminder of this thesis we assume η to be the identity map, i.e., the
6Redex stands for “reducible expression”.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
18
Wlan
0
Smart
Street
Street
0
0
Smart
MOVE(Smart,Street)
Smart
Smart
Wlan
CONNECT(Smart,Wlan) 
0
Figure 2.5: Abstract BBRs MOVE that moves a Smart node from its current location to a
Street node , and CONNECT that connects the Smart node to a Wlan node.
hole i in R matches with the hole i in R′ for all i ∈N. If R and R′ are abstract bigraphs,
then R →R′ is an abstract BRR. If R and R′ are concrete then the BRR is concrete. It is
often convenient to deﬁne BBRs to be abstract even when working with concrete bigraphs.
This deﬁnes rules that can be applied on several contexts.
Let r = R →R′ be a BRR and B a bigraph. In order to perform the reaction r in B we
need ﬁrst to decompose B into C ◦R◦d where C represents the context and d represents the
parameters inside the holes of R. Assuming that η is the identity map, we compose C with
the reactum R′ and with d to get the resulting B′, i.e., B = C ◦R ◦d ⇒B′ = C ◦R′ ◦d.
The application of BRRs works both for abstract and concrete BRRs. If a bigraph is
concrete then the redex and the reactum of the BRR must also be concrete. We use abstract
BRR when we want to evidence the generality of a given rule. Nonetheless, since we work
with concrete bigraphs, the rule must be concretized, i.e., one must provide the redex and
reactum with a support before the application.
Example 2.5. Consider the two abstract BRR of Figure 2.5. The ﬁrst rule, MOVE, models
a computational device, e.g., a user with a smartphone denoted by a star with kind Smart,
moving from one street to another. The second rule, CONNECT, models computational device
to move inside a hotspot with network connectivity denoted by a node with kind Wlan) and
connecting to the network. Note that the rules are parametric, i.e., they can be applied
regardless the nodes inside the street nodes. For example, this rule allows moving a node
of kind Smart regardless of the content of the node of kind Street. Figure 2.6 shows an
example of the application of BRR MOVE. The bigraphs in this example are concrete. Thus,
we need to ﬁrst concretize MOVE. Since we want to move sp0 from its current location to
street3 we denote the concrete BRR as MOVE(sp0, street3). Figure 2.6 depicts the context
C, and parameters d where the rule is applied. Note that the parameters allow the rule to be
applied with sp1 inside street3. At the top of Figure 2.6 shows the bigraph B transitioning
to B′. At the bottom we show the decomposition of each bigraph in the context C, redex
R, reactum R′, and parameters d.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
19
decomposition: 
context, redex, and parameters
replace 
redex with reactum
composition: 
context, reactum, and parameters
Figure 2.6: Example of the application of the MOVE reaction rule.
Deﬁnition 2.5. A bigraph reactive system (BRS), denoted as Bg(K, R), is a bigraphical
category Bg(K) and a set of BRR R.
Next we deﬁne a trace of a BRS based on [55].
Deﬁnition 2.6. A trace of a BRS (B, R) is a sequence of bigraphs
t = (B0, B1, . . .)
where B0 = B and for each Bi and Bi+1 there exists a reaction rule R →R′ ∈R a context
C and parameters d such that for each i
Ci ◦R ◦di →Ci ◦R′ ◦di
where Bi = Ci ◦R ◦di and Bi+1 = Ci ◦R′ ◦di. The set of all traces starting from B and
generated by rules R is denoted by T R
B .
Example 2.6. Consider the bigraph depicted in Figure 2.3. The application of the reac-
tion rules MOVE(sp,street1), MOVE(sp,street3), and CONNECT(sp,wlan0) results in the
execution trace presented in Figure 2.7.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
20
internet
internet
internet
internet
MOVE(sp,street1)
MOVE(sp,street3)
CONNECT(sp,wlan0)
Figure 2.7:
A bigraph trace resulting from applying the BRRs MOVE(sp,street1),
MOVE(sp,street3), and CONNECT(sp,wlan0).
2.2
Querying for local observations
In this section we introduce a query language for bigraphs. Queries provide means for
agents to specify local observations of the bigraph with respect to their location. An agent
requesting to observe the bigraph is denoted as host. One can think of a host node as denoting
the physical entity that is querying the bigraphical world, i.e., hosting the computation that
is querying the world. We think of “local” in terms of the placing graph (parents and children
of a given node) and in terms of the linking graph (nodes linked to a given node).
The query language syntax is speciﬁed by the following grammar:
query ::= node|CHILDREN(node)|LINKED_TO(node)
node
::= HOST|PARENT(node)
For example, the query CHILDREN(PARENT(HOST)) can be interpreted in English as “the
children of the parent of the host”.
Queries are interpreted as bigraphs. The interpretation of a query q ∈query over a
bigraph B with respect to a host h is formalized by the semantic function
[[·]]B
h : query →‵Bg(Σ).

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
21
Given a query q ∈query, the interpretation [[q]]B
h is composable with a context in B, i.e.,
there exists a context C and parameters d such that B = C ◦[[q]]B
h ◦d.
Example 2.7. Figure 2.8 presents an example of querying the bigraph B0 of Figure 4.7 with
respect to sp. On the right-hand side of Figure 2.8 one can see the interpretation of the
queries HOST, PARENT(HOST), CHILDREN(PARENT(HOST)).
Figure 2.8: BigActor observing the street map using query CHILDREN(PARENT(HOST)).
The semantic function [[·]]B
h is deﬁned inductively over the structure of the query gram-
mar.
Every query is deﬁned with respect to a node named HOST. Thus [[HOST]]B
h deﬁnes the
base case.
[[HOST]]B
h 7→({h}, ∅, ctrlh, prnth, linkh) : ⟨1, ∅⟩→⟨1, Yh⟩

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
22
where:
ctrlh(h) = ctrlB(h)
prnth(v) =
(
0
if v = h
h
if v = −0
linkh(l) =
(
linkB(l)
if linkB(l) ∈YB
ye
if e = linkB(l) ∈EB
Yh = {ye | ∀l.e = linkh(l) ∧e ∈EB} ⊎{y | ∀l.y = linkh(l) ∧y ∈YB}
[[HOST]]B
h is a bigraph with a single node (i.e. h) with the same arity as in B. The node
h contains hole −0.
For each edge e connected to h in B there is a outer name ye in
[[HOST]]B
h connected to h.
These outer names are introduced such that the composition
B = C ◦[[HOST]]B
h ◦d is valid. The remaining outer names of B connected to h are kept in
[[HOST]]B
h .
The ﬁrst inductive deﬁnition is [[PARENT(node)]]B
h .
Let [[node]]B
h = Bn where Bn is a
bigraph with a single node n.
[[PARENT(node)]]B
h 7→({p}, ∅, ctrlp, prntp, linkp) : ⟨1, ∅⟩→⟨1, Yn⟩
where
p = prntB(n)
ctrlp(p) = ctrlB(p)
prntp(v) =
(
0
if v = p
p
if v = −0
linkh(l) =
(
linkB(l)
if linkB(l) ∈YB
ye
if e = linkB(l) ∈EB
Yn = {ye | ∀l.e = linkh(l) ∧e ∈EB} ⊎{y | ∀l.y = linkh(l) ∧y ∈YB}
[[PARENT(node)]]B
h is a bigraph with a single node, the parent of h. The linking structure is
deﬁned in the same way as in [[HOST]]B
h .
The next inductive deﬁnition is [[CHILDREN(node)]]B
h .
[[CHILDREN(node)]]B
h 7→(VC, ∅, ctrlC, prntC, linkC) : ⟨|VC|, ∅⟩→⟨1, YC⟩
where
VC = {v | v ∈VB, n = prntB(v)}
prntC(v) =
(
0
if v ∈VC
v′
if v = holeOf(v′)

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
23
holeOf : VC →N is a function that assigns to each children node a unique hole to abstract
its contents. ctrlC, linkC, and the set of external names YC are given as before although
now ranging over the set of nodes VC and respective ports.
At last, [[LINKED TO(node)]]B
h is inductively deﬁned as follows.
[[LINKED TO(node)]]B
h 7→(VL, ∅, ctrlL, prntL, linkL) : ⟨|VL|, ∅⟩→⟨|VL|, Y ⟩
where ,
VL = {v ∈VB | ∃p ∈ports(v).∃p′ ∈ports(n).linkB(p) = linkB(p′)}
prnth(v) =
(
regionOf(v)
if v ∈VL
v′
if v = holeOf(v′)
The set of nodes VL is generated by searching the nodes of VB that are connected to n,
i.e., the nodes in VL have a port that is linked to a port of n. For each node in VL we
create a unique region using the function regionOf : VL →N. By putting each node in a
unique region we can restore the parenthood by composing again with a context of B. The
remainder of the bigraph deﬁnition is as per the previous cases.
Deﬁnition 2.7 (Local match). We say that a bigraph B′ is local match of B with respect
to h if there exists a query q such that B′ = [[q]]B
h .
Example 2.8. Consider the host to be srv. The interpretation of [[LINKED TO(HOST)]]B
srv is
given by:
(VL, ∅, ctrlL, prntL, linkL) : ⟨3, ∅⟩→⟨3, {ynetwork}⟩
where VL = {wlan0, wlan1, wlan2},
∀v ∈VL.ctrlL(v) = Wlan, ∀i ∈{0, 1, 2}.prntL(i) = wlani, ∀i ∈{0, 1, 2}.prntL(wlani) = i,
∀v ∈VL.linkL((v, 0)) = ynetwork.
The query language only requires local interpretation with respect to the host node, i.e.,
the interpretation of a given query does not require the knowledge of the overall bigraph. In
other words, the time complexity of querying depends on the size of the query and not on
the size of the bigraph.
Theorem 2.1 (Complexity of querying). The time complexity of interpreting a query into an
observation depends on the size of the query (the number of terminal symbols in the abstract
syntax tree) and not on the size of the bigraph (the total number of nodes and edges).
Proof. In order to calculate the complexity of interpreting a query we need to deﬁne a data
structure for Bigraphs. We assume that the placing graph is stored in a data structure
composed by a list of trees P = [T0, T1, . . . , Tn] where Ti = (rooti, foresti) where rooti is a
node name and foresti is zero or more child trees. We assume that all subtrees are stored

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
24
in a hash table where the key is the root and the value is the corresponding children. The
linking graph is stored in a hypergraph L = (V, hyper) where V is the list of vertices and
hyper is a list of lists of vertices representing the hyperedges. Vertices are also annotated
with their arity.
By structural induction of query.
• Base case (HOST): Interpreting HOST requires reading a variable. This takes O(1) and
thus does not depend on the size of the bigraph
• Inductive steps: The time complexity of interpreting PARENT(node) is equal to the com-
plexity of interpreting node plus the complexity of getting the root node which is equal
to O(1). Since node is either HOST or recursive application of PARENT the complexity
depends linearly on the size of the query (O(n) where n is the size of the query) and
not on the size of the bigraph. The time complexity of interpreting CHILDREN(node) is
equal to the time complexity of interpreting node (O(n)) plus the complexity of getting
the children nodes. Since all subtrees are saved in a hash table, getting the children is
of complexity O(1). The time complexity of interpreting LINKED TO(node) is equal to
the time complexity of interpreting node plus the complexity of looking for hyperedges
containing the node. This depends on the arity of the node (which is constant and
stated initially in the bigraph signature).
The complexity of the interpretation of a query is on the size of the query and not on the
size of the overall bigraph comes from the fact that the interpretation is local with respect
to a host node.
Corollary 2.1. The time complexity of interpreting a query into an observation depends
linearly on the size of the query.
Proof. This theorem comes as a corollary of Theorem 2.1. By structural induction and as-
suming that interpreting the base case host takes constant time, then interpreting PARENT(query)
or CHILDREN(query) takes on extra step (looking up one level in the place tree or looking
on level down), while interpreting LINKED TO(query) takes in the worst-case the maximum
arity declared in the bigraph signature (which is a constant value). Thus, the worst-case
complexity T(query) = n × max(arity) = O(n) where n is the size of the query.
2.3
Local bigraphical reaction rules
We assume that agents aﬀect their environment in the vicinities of their hosts. In bi-
graphical worlds, we enforce locality by imposing constraints on the reaction rules requested
by an agent with respect to the location of its host.

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
25
We use the query language to deﬁne which part of the bigraph a given BRR can change.
Since the query language deﬁnes local observations with respect to a host node, one can
extend the concept of locality to reaction rules.
The veriﬁcation that a BRR R →R′ satisﬁes a locality property speciﬁed by a query
q ∈query is performed by the following function:
localq : ‵Bg(Σ) × ‵Bg(Σ) →B
localq(R, R′) 7→
(
true
∃S.R = S ◦ˆR ∧R′ = S ◦ˆR′
false
o.w.
where ˆR →ˆR′ is a reaction rule such that ˆR = [[q]]B
h . The function localq requires that a
reaction rule R →R′ can only change ˆR = [[q]]B
h keeping the remaining context S static.
Example 2.9. Consider a controller hosted at an autonomous vehicle. The controller is only
allowed to move its own host from one location to another keeping the remaining environment
untouched. This can be formalized by stating that the BRRs that the controller can use to
control the world can only change the world matched by [[HOST]]B
h , where B is the current
bigraph and h is the node denoting the autonomous vehicle.
Example 2.10. Now consider an autonomous vehicle that has the ability move around and
manipulate the world around it (e.g. collect tokens). This can be formalized by stating
that a controller hosted at the autonomous vehicle can only change the world matched by
[[HOST]]B
h or [[CHILDREN(PARENT(HOST))]]B
h , meaning that it can change the host location or
the siblings of the host.
2.4
Final remarks
In this chapter we provide a review of the bigraphical model and introduce a query
language for performing local observations over bigraphs.
The bigraphical formalism was introduced by Robin Milner as the ubiquitous abstract
machine, the equivalent to the von Neumann machine for ubiquitous systems [3].
The
model entails two graphical structures to model respectively the location and connectivity
of ubiquitous systems. The bigraphical formalism provides means for changing one bigraph
to another. This is known as Bigraph Reaction Rules (BRRs). BRRs can be seen as the
speciﬁcation of control actions performed over bigraphs forming a bigraphical execution
trace.
As Birkedal et al. claimed [36], performing observations over bigraphs under solely the
realm of the bigraphical formalism is not practical since one would have to use BRRs which,
by deﬁnition, change the bigraph being observed. To overcome this diﬃculty we introduce
a query language for performing observations over bigraphs. The query language provides
means for querying the placing graph, the linking graph, or both. We demonstrate that the

CHAPTER 2. OBSERVING AND CONTROLLING BIGRAPHS
26
complexity of interpreting queries from our query language depends on the size of the query
and not on the size of the underlying bigraph.
We are interested on modelling mobile computing machines that only aﬀect the environ-
ment in their vicinities, i.e., an agent can aﬀect the world locally with respect to its host.
We use the query language to deﬁne locality and enforce BRRs to only change the bigraph
locally with respect to a given host.

27
Chapter 3
BigActors
Computing agents are getting ubiquitously embedded in spatial environments.
They
move, interact within each-other, and interact with their environment by observing it and
controlling it. These computing agents are carried by machines such as robots, autonomous
vehicles, or even people walking with their smartphones. Computation performed at these
kind of systems is fundamentally coupled with their environment. In this chapter we in-
troduce the BigActor Model - a model for structure-aware computation.
BigActors are
computing agents modelled as actors that are embedded in an spatial environment modelled
as bigraphs.
This chapter is dedicated to the speciﬁcation of the bigActor semantics. In Section 3.1
we provide a brief introduction to the BigActor model using a simple example that gives
emphasis to its ﬁrst-class concepts.
The semantics of the BigActor model is inspired by the Actor model operational seman-
tics. In Section 3.2, we provide a brief review of the Actor model and its formal semantics. In
Section 3.3 we introduce the BigActor model and its formal semantics. Section 3.6 discusses
the correctness of the BigActor Model semantics and presents suﬃcient conditions for safety.
3.1
Introduction
We introduce the BigActor model in [1] as a model for structure-aware computation.
BigActors are Actors as per Hewitt and Agaha’s semantics [2] that operate over Milner’s
bigraphical [3] abstractions of the world. A bigActor is an actor hosted by a bigraph node
denoting the computing machine that is executing it. Like a regular actor, a bigActor can
create new bigActors and send messages asynchronously to other bigActors. In addition it
can request observations the bigraph, request control actions to change the bigraph, and
migrate from one host to another.
Example 3.1. Figure 3.1 depicts a set of bigActors interacting with a bigraphical model
of the world. The picture provides examples for the interactions between bigActors and
their bigraphical environment, i.e.
send a message to another bigActor, create a new

CHAPTER 3. BIGACTORS
28
bigActor, observe the underlying bigraph, request a control action to change the bigraph,
and request to migrate to another host.
There are three bigraph nodes modelling robots,
a0
a1
a2
room0
room1
building1
building0
robot0
robot1
observe
host
control
MOVE_HOST_TO room0
a2
migrate
PARENT_HOST
robot1
robot2
send
new
robot2
room0
wifi
host
host
host
Bigraph
BigActors
Figure 3.1: A pictorial representation of a bigActor system.
namely robot0, robot1, and robot2. The robot modelled by node robot0 is located at
room0 of building0. The robot modelled by node robot1 is located at room1 of the same
building. The robot modelled by node robot2 is located at building1. The link named
wifi models the wiﬁconnectivity between robots.
The bigActor system is composed by three bigActors, a0, a1, and a2, that are speciﬁed
in Figure 3.2. The code is written in the Scala BigActor Programming Language which is
explained in detail in Chapter 4.
The bigActor a0 is hosted by robot0 and its objective is to gather all the robots at
the location of its host. Its ﬁrst step is to observe where its host is located. The bigActor
a0 requests the observation using the command observe(PARENT(HOST)) which queries the
bigraph for the parent of the host of a0 (which in this case is room0). The observation is
asynchronous. When the result of the observation is available, it is assigned to the variable
obs inside the react body1. The second step of a0 is to send a message to a1 with the former
observation. The message received by a1 gets assigns to the variable msg inside the react
body. Later, a1 requests its host to move the location speciﬁed in the message. This is
1The react command is inherited form the Scala Actors library and is originally used for asynchronous
message-passing.

CHAPTER 3. BIGACTORS
29
val a0 = BigActor hosted_at robot0 with_behavior{
observe(PARENT(HOST))
react{
case obs => {
a1 ! obs
val a2 = BigActor hosted_at robot2 with_behavior{
control(MOVE_HOST_TO(obs))
}
}
}
}
val a1 = BigActor hosted_at robot1 with_behavior{
react{
case msg => control(MOVE_HOST_TO(obs))
}
}
Figure 3.2: Speciﬁcation of the bigActor system for Example 3.1.
preformed by a command control(MOVE HOST TO(msg)) that applies a Bigraph Reaction
Rule over the current bigraph in order to move the host of the bigActor to the location
speciﬁed by msg.
Assume that a0 does not know the name of any bigActor hosted at
robot2. To overcome this situation, a0 synthesizes a new bigActor named a2 that migrates
to robot2. The speciﬁcation of a2 has only one command that requests to move its host to
room0.
Figure 3.3 depicts the execution trace for the Example 3.1.
Example 3.1 presents informally the execution semantics of a simple bigActor system.
The remainder of the chapter is concerned with providing a formal semantics for the model
and analyse its correctness.
3.2
Actor model of computation - review
The semantics of the BigActor model is formalized by extending the Actor model oper-
ational semantics presented by Agha in [2, 56]. In this section we provide an overview of
the Actor model and its semantics with suﬃcient detail in order to understand the BigActor
model semantics. For an exhaustive presentation of the actor model and its semantics refer
to [2, 56].
The Actor model of computation is a model of concurrency for distributed concurrent
computing entities. An actor system is composed of autonomous objects called actors. Actors
have local memory and local behavior. Actors communicate using asynchronous message

CHAPTER 3. BIGACTORS
30
a0
a1
room0
room1
building1
building0
robot0
robot1
observe
host
PARENT_HOST
robot2
room0
wifi
host
Bigraph
BigActors
a0
a1
room0
room1
building1
building0
robot0
robot1
host
robot2
send
wifi
host
Bigraph
BigActors
a0
a1
room0
room1
building1
building0
robot0
robot1
host
control
MOVE_HOST_TO room0
robot1
robot2
wifi
host
Bigraph
BigActors
a0
a1
a2
room0
room1
building1
building0
robot0
host
robot1
robot2
new
wifi
host
host
Bigraph
BigActors
a0
a2
room0
room1
building1
building0
robot0
host
a2
migrate
robot1
robot2
robot2
wifi
host
host
Bigraph
BigActors
a1
host
a0
a2
room0
room1
building1
building0
robot0
host
robot1
robot2
wifi
Bigraph
BigActors
a1
host
control
MOVE_HOST_TO room0
host
Figure 3.3: Execution trace for the Example 3.1.
passing. Messages that have been sent but not yet received are queued up in the receiver
actor’s mailbox. The receiver eventually removes the message and processes it and aﬀecting
its behavior. An actor encapsulates a state and a thread. Each actor has a mail-address
used by other actors for communication.
An actor reacts upon receiving a message from another actor by: compute and change
state; send a message to another actor; or create a new actor. Figure 3.4 depicts an example
of an actor system. Figure 3.4 contains three actors, a 0, a 1, and a 2. Actor a 0 starts
at state x 0. When it receives a message m it sends the message to a 1 and moves its state
to x 1. When a 0 receives the message m′ it creates a new actor a 2.
The Actor model has been adopted as the concurrency model in several modern program-
ming languages such as Erlang [57], Scala [58], Dart, Cloud Haskell [59], and in embedded
systems design using Ptolemy II [60]. The use of asynchronous message-passing contrasts
with other concurrency models such as threads, where computing entities communicate using
shared state.

CHAPTER 3. BIGACTORS
31
x_0 become
become
...
Behavior
Mail box
x_1
Actor 
a_1
Actor 
a_0
Actor 
a_2
send m to a_1
create a_2
m
m
m'
m''
Figure 3.4: The Actor Model.
Next we present an operational semantics for the actor model. We follow the operational
semantics style taken in [61, 56, 62].
Operational Semantics
One can ﬁnd in the literature several approaches for deﬁning the actor model semantics.
Agha provides in [2] a denotational semantics for actors. The same author provides a con-
textual operational semantics in [56]. The latter is then adapted in [61] to include real-time
constraints.
The Actor model operational semantics is formalized as a transition relation over the set
of actor conﬁgurations.
Deﬁnition 3.1 (Actor Conﬁguration). An actor conﬁguration is a tuple ⟨α | µ⟩where α is
a set of actors, and µ is the set of pending messages. Dom(α) denotes the set of unique
actor names that identiﬁes each actor in α.
An actor conﬁguration is syntactically deﬁned according to the grammar presented in
Figure 3.5. The syntax presented at Figure 3.5 is not enforced by the bigActor model. Its
only purpose is to introduce syntactic notation in order to introduce the semantics of the
model.
The notation [E ⊢b]a denotes an actor with unique name a ∈Dom(α), local environment
E ∈E, and local behaviour b. The local behaviour is speciﬁed as a sequential composition
of actor commands, namely, send, ready, and new, and expressions eλ that manipulate the

CHAPTER 3. BIGACTORS
32
config :
⟨actor∗| msg∗⟩
actor :
[E ⊢b]a
b :
send(a, v) | ready(x) | new(b) | b; b | eλ | nil
msg :
⟨a ⇐v⟩
Figure 3.5: Grammar for actors syntax.
state of the actor. The behavior can also take the value nil. The notation ⟨a ⇐v⟩denotes
a message to an actor a ∈A with content v ∈V.
The semantics of the actor model is presented in Figure 3.6 and is an adaptation of
the semantics introduced in [61, 56, 62]. The actor model is a model of concurrency. The
⟨nil⟩
⟨α, [E ⊢nil]a | µ⟩→⟨α | µ⟩
⟨fun : a⟩
[E ⊢eλ; b]a →λ [E′ ⊢b]a
⟨α, [E ⊢eλ; b]a | µ⟩→⟨α, [E′ ⊢b]a | µ⟩
⟨new : a, a′⟩
⟨α, [E ⊢new(b′); b]a | µ⟩→⟨α, [E ⊢b]a, [E ⊢b′]h
a′ | µ⟩
⟨snd : a, ⟨a′ ⇐v⟩⟩
⟨α, [E ⊢send(a′, v); b]a | µ⟩→⟨α, [E ⊢b]a | µ, ⟨a′ ⇐v⟩⟩
⟨rcv : a, ⟨a ⇐v⟩
⟨α, [E ⊢ready(x); b]a | µ, ⟨a ⇐v⟩⟩→⟨α, [E[x 7→v] ⊢b]a | µ⟩
Figure 3.6: Actor operational semantics.
semantics of internal computation of actors is not addressed explicitly by the model and, as
such, it is left unspeciﬁed. For the sake of a complete formalization the actor model semantics
assumes that internal actor computation is modelled by the transition relation “→λ” that
is given by the semantics of an arbitrary language that is used for specifying the internal
behaviors of actors. In order to make the analysis of the actor semantics more readable
we assume that the language that speciﬁes the actors internal behavior has a sequential
composition operator where denoted by “;”. This approach is used by Nielson et al. [61].
For an actor semantics without the need for a sequential composition see [56].
The semantics consists of ﬁve inference rules. The rule ⟨nil⟩models the behaviour of an
actor a with behaviour nil. The rule simply removes a from the set of actors. The rule
⟨fun : a⟩models an internal computation of an actor a. It takes an expression eλ; b, executes
eλ, produces the corresponding side-eﬀects in the local state, and changes the behaviour of

CHAPTER 3. BIGACTORS
33
Actor commands
Scala Actors
send(a, m)
a ! m
ready(x)
react{
case x => ...
}
new(b)
actor{b}
Table 3.1: Encoding of Scala actor commands into the actors grammar.
a to b. The rule ⟨new : a, a′⟩models the creation of a new actor a′ spawned by a. The rule
takes an expression new(b′); b, creates a′ with behaviour b′, and changes the behaviour of a
to b. The rule ⟨snd : a, ⟨a′ ⇐v⟩⟩modes the an actor a sending a message with content v
addressed to a′. The rule takes an expression send(a′, v); b, adds a message ⟨a′ ⇐v⟩to the
set of pending messages, and changes the behaviour of a to b. The rule ⟨rcv : a, ⟨a ⇐v⟩
models an actor a receiving a message addressed to it with content v. The rule takes an
expression ready(x); b, and a message ⟨a ⇐v⟩from the set of pending messages, binds the
message content to the local variable x, and changes the behaviour of a to b.
In this thesis we use Scala Actors [23] as the implementation of the actor model. Scala
uses actors as its de facto concurrency model. Table 3.1 shows the syntactic encoding of
the actor commands send, ready, and new in the Scala Actor commands “!”, react2, and
actor.
Example 3.2. Consider a simple social network example. There are two actors, app and
social. app sends messages of kind (user, status) to social. The message is a tuple where
the ﬁrst element is the name of the user and the second is its status. social local state
contains a map named statusMap which contains pairs of users and their corresponding
status. When social receives a message of kind (user, status) it updates the value user
with the new status. Otherwise, it creates a new key-value pair in the map. Figure 3.7
presents the Scala code for app and social.
The encoding of app and social into the actor syntax is respectively
[{} ⊢send(social, (”Nina”, ”Feeling good”)); nil]app
(3.1)
[statusMap ⊢ready(x); eλ; nil]social
(3.2)
The execution trace of the actor system {app, social} is given in Figure 3.8.
2The variable x is locally scoped under the context of the react body and can be pattern-matched using
case alternatives.

CHAPTER 3. BIGACTORS
34
val app = actor{
social ! ("Nina","Feeling good")
}
val social = actor{
val statusMap = Map("Nina" -> "Put a spell on you",
"Miles" -> "Kind of Blue")
react{
case (user,status) => statusMap(user) = status
}
}
Figure 3.7: app and social actors.
3.3
BigActor Model
Recall Example 3.2. The actor system formed by app and social speciﬁes concurrent
computation. The actor app sends asynchronously a message to social which reacts upon
the reception of such message. In this actor system there is no explicit information of where
computation is being executed. For example, app might be hosted at a smartphone that
only has connectivity in certain parts of the city. One would beneﬁt from an app actor
that only sends updates to social when it has network connectivity. Or that would send
directions to the smartphone user to move toward an area of the city where it is known to
have a wireless hotspot where it could connect. In a pure actor system, these interactions
between app, its host (the smartphone), and its environment are not explicit. They would
have to be modelled as actors. For example, the smartphone could be modelled as an actor
that keeps the location and connectivity information and interacts with another actor that
models the spatial environment of the city. The choice of the spatial model and its correct
implementation is in the hands of the programmer since the actor model lacks any explicit
spatial abstractions.
Example 3.3. Figure 3.9 shows the Scala code for a new actor system for the scenario
presented in Example 3.2. The new code for app sends a message to smartphone asking if
there is network connectivity. Next app waits for the reply. If the answer is positive then
app proceeds by sending the status update to social. Otherwise, app requests smartphone
to navigate to another location (for the sake of simplicity we assume that there are only two
locations, loc0 and loc1). The actor smartphone interacts with the actor env modelling
the environment. smartphone keeps a record in its local state about its current connectivity
and location. It replies to requests from app asking for the connectivity state and interacts
with env that models the spatial environment and connectivity. The actor env keeps track
of the smartphone location and connectivity and models their dynamics. The connectivity is
check using an API call to a wiﬁdriver. The code for social is the same as per Example 3.2.

CHAPTER 3. BIGACTORS
35

{[{} ⊢send(social, (”Nina”, ”Feeling good”)); nil]app, [statusMap ⊢ready(x); eλ; nil]social} | {}

⟨snd:app,⟨social⇐(”Nina”,”Feeling good”)⟩⟩
−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

{[{} ⊢nil]app, [statusMap ⊢ready(x); eλ; nil]social} | {⟨social ⇐(”Nina”, ”Feelinggood”)⟩}

⟨rcv:social,⟨social⇐(”Nina”,”Feeling good”)⟩
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→

{[{} ⊢nil]app, [{statusMap, x 7→(”Nina”, ”Feelinggood”)} ⊢eλ; nil]social} | {}

⟨fun:social
−−−−−−−→

{[{} ⊢nil]app, [{statusMap′, x} ⊢nil]social} | {}

⟨nil⟩
−−−→

{[{statusMap′, x} ⊢nil]social} | {}

⟨nil⟩
−−−→
⟨{} | {} ⟩
Figure 3.8: Execution trace of the actor system {app, social}.

CHAPTER 3. BIGACTORS
36
val app = actor{
loop{
smartphone ! "connected?"
react{
case true => social ! ("Nina","Feeling good")
case false => smartphone ! "navigate"
}
}
}
val smartphone = actor{
var location = loc0
var connected = false
loop{
react{
case "connected?" => app ! connected
case "navigate" => env ! "move"
react{
case (newLoc,newConn) =>
location = newLoc
connected = newConn
}
}
}
}
val env = actor{
smartphoneLoc = loc0
smartphoneConn = false
loop{
react{
case "move" => {
smartphoneLoc = loc1
smartphoneConn = wifi.isConnected
smartphone ! (smartphoneLoc,smartphoneConn)
}
}
}
}
Figure 3.9: Actor system for Example 3.2 with new actors app, smartphone, and env.
With the bigActor model we make the interactions between actors and their spatial
environment explicit and formal. A bigActor system runs over a bigraphical model of space.

CHAPTER 3. BIGACTORS
37
The spatial model abstracts not only the location of components but also their connectivity.
This follows the Milner’s vision of space and mobility for ubiquitous systems [3].
Example 3.4. Figure 3.9 shows the Scala code for a bigActor system for the scenario
discussed in Example 3.3.
val app = BigActor hosted_at smartphone with_behavior{
loop{
observe(LINKED_TO(HOST))
react{
case obs.contains(srv) => social ! ("Nina","Feeling good")
case _ => {
control(MOVE_HOST_TO(street3))
control(CONNECT_HOST_TO(wlan0))
}
}
}
}
val social = BigActor hosted_at srv with_behavior{
val statusMap = Map("Nina" -> "Put a spell on you",
"Miles" -> "Kind of Blue")
react{
case (user,status) => statusMap(user) = status
}
}
Figure 3.10: BigActor system for scenario presented in Example 3.3.
The bigActors run over an environment modelled as the bigraph of Figure 2.3.
Note that the bigActor system of Figure 3.10 has two bigActors, app and social, just
as the original actor system of Figure 3.7). There is no need of extra actors to model the
environment and the machines as in the actor system of Figure 3.9.
The bigActor constructor has a new parameter: hosted at loc. This parameter deﬁnes
where the bigActor instance is going to be initially hosted. The bigActor app is hosted at the
bigraph node smartphone denoting the smartphone, while social is hosted at srv denoting
the server where the social network is running.
Comparing with its actor counterpart provide by Figure 3.7, the bigActor app performs
two new kind of commands. It ﬁrst observes the structure of the world using the query
LINKED TO(HOST), which queries the bigraph for the nodes connected to the host node,
i.e., app. The query language used by BigActors to query bigraphs is described in detail in
Chapter 2. Upon receiving the observation, app checks if srv is contained in the observation.
If it is, then it sends the message with the updated status. Otherwise it requests to change
location and connect to a wireless local area network using, respectively, the commands

CHAPTER 3. BIGACTORS
38
control(MOVE HOST TO(street3)) and control(CONNECT HOST TO(wlan0)). The con-
trol commands are Bigraph Reaction Rules (BRR). The application of BRRs over bigraphs
is explained in detail in Chapter 2. The BRRs MOVE HOST TO(street3) and CONNECT -
HOST TO(wlan0) result from the instantiation of the BRRs presented in Figure 3.11. The
HOST
Loc
Loc
0
0
HOST
MOVE_HOST_TO Loc
HOST
HOST
Wlan
Wlan
CONNECT_HOST_TO Wlan 
Figure 3.11: BRRs MOVE HOST TO(Loc) and CONNECT HOST TO(Wlan).
instantiation replaces HOST by app, Loc by street3, and Wlan by wlan0.
The commands observe(LINKED TO(HOST)), control(MOVE HOST TO(street3)), and
control(CONNECT HOST TO(wlan0)), specify formally and explicitly the interactions be-
tween the bigActor app and the underlying bigraph. They model, respectively, an observation
using a query language and two control actions using bigraph reaction rules. The correct
manipulation of space is no longer in the hands of the programmer but rather speciﬁed in
the semantics of bigraphs and bigraph reaction rules.
Note that both observations and control commands are speciﬁed without any reference
to smartphone but with respect to the host of the bigActor. Thus, the same bigActor code
can be reused with other hosts, e.g., one could create a new app hosted by a tablet by simply
replacing smartphone by tablet in the code at Figure 3.10.
Note that the actors smartphone and env of Figure 3.9 contain spatial information in
their local state, e.g., the location and connectivity of the smartphone. The programmer
must ensure that this information is consistent at all time. This is not needed in the bigActor
example since all the spatial information is entailed in the bigraph and can be queried by
diﬀerent bigActors at diﬀerent instances of time.
Next we introduce the formal semantics for the BigActor model.
3.4
BigActors Operational semantics
We deﬁne the semantics of the BigActor model as an extension of the Actor model
operational semantics deﬁned in Section 3.2. A bigActor conﬁguration extends an actor

CHAPTER 3. BIGACTORS
39
conﬁguration as follows.
Deﬁnition 3.2 (BigActor Conﬁguration). A BigActor conﬁguration is a tuple ⟨α | host |
µ | η | B⟩where α is a set of bigActors, host : Dom(α) →VB is the hosting function, µ is a
set of pending messages, η is a set of pending requests, and B is a bigraph.
The set α is a set of bigActors, just as in the actor model it is a set of actors. The set
of pending messages µ is exactly as in the actor model. The set of pending request η, the
hosting map host and the bigraph B are speciﬁc to the bigActors semantics.
A bigActor conﬁguration is syntactically deﬁned according to the grammar presented in
Figure 3.12.
config :
⟨bigActor∗| h∗| msg∗| req∗| B⟩
bigActor :
[E ⊢b]a
b :
cmd | ready(x) | new(b) | b; b | eλ | nil
cmd :
send(a, v) | observe(q) | control(u) | migrate(h)
h :
a 7→v
msg :
⟨a ⇐v⟩
req :
(a, cmd)
Figure 3.12: Grammar for bigActors syntax.
The notation [E ⊢b]a is the same as per the actor semantics, i.e., it denotes a bigActor
with a unique name a ∈A, with local environment E ∈E, and local behaviour b. The local
behaviour is speciﬁed as a sequential composition of bigActor commands send, observe,
control, migrate, ready, and new, expressions eλ that manipulate the state of the bigActor,
or nil. BigActors are hosted at bigraph nodes speciﬁed by the hosting function host. The
notation ⟨a ⇐v⟩denotes a message to a bigActor a ∈A with content v ∈V.
Deﬁnition 3.3 deﬁnes an execution of the BigActor model as a sequence of conﬁgurations.
Deﬁnition 3.3. A BigActor execution is a sequence c0, c1, c2, . . . where each ci
λi
−→ci+1 and
λi
−→is derived by a semantic rule labelled λi. The labels λi are the labels that name each
inference rule provided by Figure 3.13.
The semantics is modelled as a transition system over the universe of bigActor conﬁgu-
rations. The transitions are given by the inference rules presented in Figure 3.13.
The semantics can be understood as follows.
A BigActor can perform actor compu-
tations. This is asserted by the rules ⟨nil, a⟩, ⟨fun : a⟩, ⟨new : a, a′⟩, ⟨snd : a, ⟨a′ ⇐m⟩⟩
and ⟨rcv : a, m⟩. This rules are the similar as their actor counterparts in Figure 3.6 except
⟨snd : a, ⟨a′ ⇐m⟩⟩. The expansion of the conﬁguration to include host, η and B has no

CHAPTER 3. BIGACTORS
40
⟨nil, a⟩
⟨α, [E ⊢nil]a | host | µ | η | B⟩→⟨α | host | µ | η | B⟩
⟨fun : a⟩
[E ⊢eλ; b]a →λ [E′ ⊢b]a
⟨α, [E ⊢eλ; b]a | host | µ | η | B⟩→⟨α, [E′ ⊢b]a | host | µ | η | B⟩
⟨new : a, a′⟩
⟨α, [E ⊢new(b′); b]a | host | µ | η | B⟩→
⟨α, [E ⊢b]h
a, [E ⊢b′]a′ | host ∪a′ 7→h | µ | η | B⟩
⟨rcv : a, ⟨a ⇐v⟩
⟨α, [E ⊢ready(x); b]a | host | µ, ⟨a ⇐v⟩| η | B⟩→
⟨α, [E[x 7→v] ⊢b]a | host | µ | η | B⟩
⟨req : a, r⟩
r ∈{send(a′, m), observe(q), control(u), migrate(h′)}
⟨α, [E ⊢r; b]a | host | µ | η | B⟩→⟨α, [E ⊢b]a | host | µ | η, (a, r) | B⟩
⟨obs : a, q, Bobs⟩
Bobs = [[q]]B
host(a)
q ∈Q
⟨α | host | µ | η, (a, observe(q)) | B⟩→⟨α | host | µ, ⟨a ⇐Bobs⟩| η | B⟩
⟨ctr : a, u⟩
u = (R →R′)
local(R)h
B
B = C ◦R ◦d
B′ = C ◦R′ ◦d
⟨α | µ | η, (a, control(u)) | B⟩→⟨α | µ | η | B′⟩
⟨mgrt : a, h′⟩
h′ ∈VB ∃p ∈Pts(host(a)).∃p′ ∈Pts(h′).link(p) = link(p′)
⟨α | host | µ | η, (a, migrate(h′)) | B⟩→⟨α | host[a 7→h′] | µ | η | B⟩
⟨snd : a, ⟨a′ ⇐m⟩⟩
∃p ∈Pts(host(a)).∃p′ ∈Pts(host(a′)).link(p) = link(p′) ∨(host(a) = host(a′))
⟨α | µ | η, (a, send(a′, m)) | B⟩→⟨α | µ, m | η | B⟩
Figure 3.13: BigActors operational semantics.
signiﬁcance in the rules ⟨nil, a⟩, fun, and rcv. In the rule ⟨new : a, a′⟩the host map is
augmented so that the new actor a′ will have the same host as its creator, in this case a.
The local environment E in the rules of Figure 3.13 is as the actor model.
A bigActor model executes commands send(a′, m), observe(q), control(u) and migrate(h′)
asynchronously.
The semantics of these expressions are unique to this model and given
ﬁrst by the rule ⟨req : a, r⟩which produces requests in η and then by the rules labelled
as ⟨snd : a, ⟨a′ ⇐m⟩⟩, ⟨obs : a, q, Bobs⟩, ⟨ctr : a, u⟩and ⟨mgrt : a, h′⟩which consumes re-
quests from η. The req rule asserts that when any of the expressions send(a′, m), observe(q),
control(u) or migrate(h′) the program evolves and a tuple of the kind (a, r) is added to
the set η where a is the bigActor address and r is the request to execute the desired com-

CHAPTER 3. BIGACTORS
41
mand. When η contains a tuple of kind (a, send(a′, m)), (a, observe(q)), (a, control(u))
or (a, migrate(h′)) such tuple can be consumed and the BigActor model can further ad-
vance by application of the rules ⟨snd : a, ⟨a′ ⇐m⟩⟩, ⟨obs : a, q, Bobs⟩, ⟨ctr : a, u⟩and
⟨mgrt : a, h′⟩.
The rule ⟨snd : a, ⟨a′ ⇐m⟩⟩consumes a send request. The rule checks if the host of a
and the host of a′ are connected, i.e. if they share a link in the bigraph. If the premise is true,
then a new message gets generated in the set of pending messages µ. We see the linking graph
as a mean for modelling the communication infrastructure. This is the reasoning behind the
premise of requesting hosts to share a link if their bigActors want to share messages.
The rule ⟨obs : a, q, Bobs⟩takes an observe request, interprets the respective query over
the current bigraph with respect to the host, and generates a message to a inside the set of
pending messages µ. The interpretation of a query into an observation of a given bigraph B
relative to a host h is speciﬁed by the map:
[[·]]B
h : query →B
(3.3)
Queries and observations are addressed in detail in Chapter 2.
The observation is then
consumed as a standard message using the rule ⟨rcv : a, m⟩.
The rule ⟨ctr : a, u⟩takes a control request control request, checks if the rule is local
up to the host of the requesting bigActor, checks if the redex has a match in the current
bigraph, and if the premisses are satisﬁed then it changes the bigraph replacing the redex
with the reactum.
At last, the rule ⟨mgrt : a, h′⟩takes a migrate request, checks if the current host of a
is connected to the desired host, and if this premise is satisﬁed it changes the hosting map
host(a) to h′. We think of migration process as sharing information between hosts about
the structure of the bigActor and its current state. Thus, like in the send case, we request
the host to be connected, meaning that there is some sort of communication infrastructure
that can support the migration procedure.
Next we present an example of a bigActor system and its corresponding formal execution
trace.
Example 3.5. Recall the bigraph of Figure 2.3. Consider a new app named app2 hosted
at the smartphone sp that is programmed to give instructions to the user to go to street1,
take a picture of the street and its buildings, then move to street3, connect to the internet
and upload the picture to social2.
The bigActor system that speciﬁes the required behaviour is given by two bigActors given
in Figure 3.14.
Figure 3.15 depicts the bigActors of Figure 3.14 embedded in the bigraph of Figure 2.3.
The bigActor app2 uses the bigraph reaction rule MOVE HOST TO from Figure 3.11 to
move from street2 to street1 and then to street3. While in street1, app2 observes the
world using a query CHILDREN(PARENT(HOST)) and saves the observation result in photo.
When its host reaches street3, app2 connects to wlan0 using the bigraph reaction rule
CONNECT HOST TO(wlan0) and ﬁnally sends photo to social2 which logs it in a local list.

CHAPTER 3. BIGACTORS
42
val app2 = BigActor hosted_at sp with_behavior{
control(MOVE_HOST_TO(street1))
observe(CHILDREN(PARENT(HOST)))
react{
case photo =>
control(MOVE_HOST_TO(street3))
control(CONNECT_HOST_TO(wlan0))
social2 ! photo
}
}
val social2 = BigActor hosted_at srv with_behavior{
var log = List()
react{
case photo =>
log = photo :: log
}
}
Figure 3.14: BigActor system for scenario presented in Example 3.5.
internet
Figure 3.15: BigActors of Figure 3.14 embedded in the bigraph of Figure 2.3.
In order to formally analyse the semantics of the bigActors of Figure 3.14, we need to
encode the Scala syntax into the bigActor syntax given by the grammar in Figure 3.12. The
bigActor app2 is encoded as:
[∅⊢control(r); observe(q); ready(Q); control(r′); control(r′′); send(Q); nil]app2
where

CHAPTER 3. BIGACTORS
43
• r = MOVE HOST TO(street1),
• r′ = MOVE HOST TO(street3),
• r′′ = CONNECT HOST TO(wlan0), and
• q = CHILDREN(PARENT(HOST)).
The observation is saved in the variable Q. The bigActor social2 is encoded as:
[log ⊢ready(photo); eλ; nil]social2
Figure 3.16 presents an execution trace for the bigActor system presented in Figure 3.14.
For the sake of succinctness we represent the behavior of app2 as P, the behaviour without
the ﬁrst command as P′, the behaviour without the two ﬁrst commands as P′′, and so on.
Likewise, we denote the behavior of social2 as R. We numbered each conﬁguration to ease
referencing them in the text.
Figure 3.17 depicts the trace at Figure 3.16 embedded in the respective Bigraph Reactive
System. The execution trace formalized in Figure 3.16 and depicted in Figure 3.17.
The execution trace produced in Example 3.5 can now be understood as follows. The
ﬁrst conﬁguration models the two bigActors app2 and social2 hosted at respectively sp and
srv. The trace from conﬁguration 0 to conﬁguration 2 models the request and execution
of the bigraph reaction rule MOVE HOST TO(street1) over the bigraph B0 changing it to
B1. Since app2 is the bigActor requesting such control action, the keyword HOST is referring
to sp. Thus, the bigraph reaction rule MOVE HOST TO(street1) produces a new bigraph
where sp moves its location from street2 to street1. The execution of control commands
is asynchronous, i.e. the request and the execution of the action occurs at two diﬀerent time
steps labelled as req and ctr. The transition labelled with req adds a request to the set
of requests η. The transition labelled with ctr consumes such request and produces the
respective side-eﬀects in the bigraph. We request the bigraph reaction rule to be local with
respect of the host of the bigActor, i.e. the rule can aﬀect the host of the bigActor and
its surroundings. We address in detail local control actions in Section 2.3. The traces from
5 to 7 and 7 to 9 also model the execution of control actions requested by app2, namely
MOVE HOST TO(street3) and CONNECT HOST TO(wlan0).
The trace from conﬁguration 2 to 3 models the request of a observation command with the
query CHILDREN(PARENT(HOST)), the interpretation of such query over the current bigraph,
and the generation of a message with app2 (the bigActor that requested the observation)
with the value of the interpretation. This is also done asynchronously, with ﬁrst depositing
a request at η using a transition labelled with req and later executing the observation over
the current bigraph using the transition rule obs. obs consumes a request from η, interprets
the respective query and adds a message to the bigActor that originated the request with
the value resulting from the interpretation. The interpretation of the query is also a bigraph.
In this example, the interpretation of CHILDREN(PARENT(HOST)) returns a bigraph with all

CHAPTER 3. BIGACTORS
44
0. ⟨[∅⊢control(r); P′]app2, [log ⊢R]social2 | host | ∅| ∅| B0⟩
⟨req:app2,control(r)⟩
−−−−−−−−−−−−→
1. ⟨[∅⊢P′]app2, [log ⊢R]social2 | host | ∅| (app2, control(r)) | B0⟩
⟨ctr:r⟩
−−−−→
2. ⟨[∅⊢observe(q); P′′]app2, [log ⊢R]social2 | host | ∅| ∅| B1⟩
⟨req:app2,observe(q)⟩
−−−−−−−−−−−−→
3. ⟨[∅⊢P′′]app2, [log ⊢R]social2 | host | ∅| (app2, observe(q)) | B1⟩
⟨obs:q,Bobs=[[q]]host(app2)
B1
⟩
−−−−−−−−−−−−−−−→
4. ⟨[∅⊢ready(Q); P′′′]app2, [log ⊢R]social2 | host | ⟨app2 ⇐Bobs⟩| ∅| B1⟩
⟨rcv:⟨app2⇐Bobs⟩⟩
−−−−−−−−−−−→
5. ⟨[photo 7→Bobs ⊢control(r′); P′′′′]app2, [log ⊢R]social2 | host | ∅| ∅| B1⟩
⟨req:app2,control(r′)⟩
−−−−−−−−−−−−−→
6. ⟨[photo ⊢P′′′′]app2, [log ⊢R]social2 | host | ∅| (app2, control(r′)) | B1⟩
⟨ctr:r′⟩
−−−−→
7. ⟨[photo ⊢control(r′′); P′′′′′]app2, [log ⊢R]social2 | host | ∅| ∅| B2⟩
⟨req:app2,control(r′′)⟩
−−−−−−−−−−−−−→
8. ⟨[photo ⊢P′′′′′]app2, [log ⊢R]social2 | host | ∅| (app2, control(r′′)) | B2⟩
⟨ctr:r′′⟩
−−−−−→
9. ⟨[photo ⊢send(social2, photo); nil]app2, [log ⊢R]social2 | host | ∅| ∅| B3⟩
⟨req:app2,send(social2,photo)⟩
−−−−−−−−−−−−−−−−−−→
10. ⟨[photo ⊢nil]app2, [log ⊢R]social2 | host | ∅| (app2, send(social2, photo)) | B3⟩
⟨snd:⟨social2⇐photo⟩⟩
−−−−−−−−−−−−−→
11. ⟨[photo ⊢nil]app2, [log ⊢ready(photo); R′]social2 | host | ⟨social2 ⇐photo⟩| ∅| B3⟩
⟨rcv:⟨social2⇐photo⟩⟩
−−−−−−−−−−−−−→
12. ⟨[photo ⊢nil]app2, [log, photo ⊢eλ; nil]social2 | host | ∅| ∅| B3⟩
⟨fun:social2⟩
−−−−−−−−→
13. ⟨[photo ⊢nil]app2, [log′, photo ⊢nil]social2 | host | ∅| ∅| B3⟩
⟨nil:app2⟩
−−−−−−→
14. ⟨[log′, photo ⊢nil]social2 | host | ∅| ∅| B3⟩
⟨nil:social2⟩
−−−−−−−−→
15. ⟨∅| host | ∅| ∅| B3⟩
Figure 3.16: Execution trace for the bigActor system of Figure 3.14.
the nodes inside the parent of the host. The observed bigraph is depicted in Figure 3.17

CHAPTER 3. BIGACTORS
45
internet
internet
<req:app2,MOVE_HOST_TO street1>
<ctr:MOVE_HOST_TO street1>
internet
<req:app2,CHILDREN_PARENT_HOST>
<obs:CHILDREN_PARENT_HOST>
<rcv:app2,photo>
internet
<req:app2,MOVE_HOST_TO street3>
<ctr:MOVE_HOST_TO street3>
internet
<req:app2,CONNECT_HOST_TO wlan0>
<ctr:CONNECT_HOST_TO wlan0>
sp
sp
sp
sp
sp
internet
<req:app2,send(social2,photo)>
<snd:<social2<=photo>>
<rcv:<social2<=photo>>
sp
B0
B1
B2
B3
B1
B3
Figure 3.17: Execution trace over the respective Bigraph Reactive System.

CHAPTER 3. BIGACTORS
46
highlighted on top of the main bigraph in the third step of the trace. Just as in the control
case, observations are also speciﬁed with respect to the host of the bigActor. Observations
must also be local with respect to the host of the bigActor requesting them, i.e. a bigActor
can only observe the surroundings of its host. Local observations are addressed in detail in
Section 2.2. The trace from 3 to 4 models app2 consuming the message with the observation
and saving its value in a local variable named photo. This is done with a semantic rule
labelled as rcv which is identical to the actor semantic rule with the same name.
The trace from 9 to 11 models app2 sending asynchronously a message with the value
saved in photo to social2. Just like any bigActor command, the execution of sending a
message also requests two steps: ﬁrst req models the request of such command and later snd
models the consumption of such request and the generation of a new message in the set of
pending messages. The actor semantics models this as a single step depositing the message
immediately to the set of pending messages µ. The main diﬀerence is that our send command
involves ﬁrst checking in the bigraph if the hosts of the sender and the receiver are connected.
In practice this would mean to check if the bigActors are both connected by some commu-
nication protocol and infrastructure, providing means for exchanging actor messages (e.g.
wireless connection, 3G, etc.). We create in η requests for any command that deals with the
bigraph in some way. Thus, since sending a message demands ﬁrst checking the connectivity
graph in the bigraph, we create a request in η. This decision facilitates the implementation
of the model since one can create a component (which we name bigraphScheduler) that is
fully responsible for interacting with the bigraph. The bigraphScheduler then only needs
to look for requests in η. The details on the implementation of the model are provided in
Chapter 4.
The trace from 11 to 12 models a transition labelled with rcv where social2 consumes
a message from the set of pending messages µ and saves the value in its local state.
The trace from 12 to 13 models an internal computation of the bigActor. This transition
is labelled as fun and it plays the same role as in the actor semantics. Just as in the actor
semantics, fun is left unspeciﬁed, modelling the fact that the bigActor model is agnostic to
the language that is used for specify internal computation. In this case, fun is in practice is
denoting the Scala command for appending photo to the Scala list log creating a new list
log′.
The trace from 13 to 15 models the consumption of nil from both bigActors, which
represents the end of the computation and thus the removal of the bigActors from the
conﬁguration.
The example does not illustrate the rule mgrt for the expression migrate. This rule
behaves much like the others.
A BigActor can request a migration by the expression
migrate(h′) where h′ is a node in the bigraph.
If the host of the BigActor and h′ are
connected by a link in the bigraph, the request can be consumed by the rule mgrt and
the host of the BigActor will be changed. Note the bigraph remains unchanged. There is
only a change in the hosting relationship between the actors and the bigraph. The link is
interpreted as the physical network required for the ﬂow of a nomadic program.
We conclude the analysis of the bigActor semantics with a few remarks.

CHAPTER 3. BIGACTORS
47
Remark 3.1. The program in Figure 3.14, and the respective graphical representation in
Figure 3.15, is concise and formal. We see the conciseness of the program and the formal
interactions with a spatial model contributions of the model in the area of spatial computing.
Remark 3.2. We see the relationship between bigActors and bigraphs like the relationship
between a program and its machine. Actor programs are concurrent programs and so the
machine can be a distributed one. The actors model the programs and the bigraph a shared
distributed machine. The programs can observe the machine (rule obs) and change the ma-
chine (rule ctr). Control can move, add, or remove nodes and do the same with connections
(links). The hosting relationship is the distribution of the program over the machine. The
programs can change their distribution (rule mgrt). The programs can exchange messages
(rules snd, rcv) but only up to the machine (bigraph links). The programs can compute
(rules fun, term) and create new programs (rule new) and locate them in the machine
(locally). They could migrate thereafter. We see the BigActor model as a formal model
of interactions between programs and machines and thus as a contribution to the area of
bridging models for worlds with dynamic structure.
Remark 3.3. In the BigActor semantics the coupling of bigActors and bigraphs is asyn-
chronous. Program execution puts requests in η. The requests aﬀect the bigraph, hosting
relationship, or observations at a later instant of model time. This means a bigActor can
make requests executable in the bigraph at request time but unexecutable at the later time.
Section 3.6 addresses this issue.
Remark 3.4. Control is local. If a BigActor seeks to replace component R of a bigraph with
R′ then the rule ctr requires the BigActor host to be local in R. This is investigated in detail
in Section 2.3. We show in Section 2.2 that observation is also local. Agent-based systems
embedded in spatial environments often require local observation and control. Thus, we see
bigActors as suitable for agent-based modelling and programming.
Remark 3.5. The bigActor semantics follows Milner’s abstract idea of “towers of models”
where diﬀerent models of computation are combined by introducing just enough semantical
“glue” in order to deﬁne yet another model.
In the case of the bigActor model, we picked the actor model and bigraph reactive systems
and introduced an operational semantics that models interactions between the two models.
This extra semantics is formalized in a way that one can look at a bigActor in a bigraphical
perspective by considering solely the bigraphs of the bigActor conﬁgurations and the bigraph
reaction rules that change them. Likewise, one can look at a bigActor trace from an actor
perspective by abstracting out host, η and the bigraph out of the bigActor conﬁgurations
and all the transitions labelled as req, ctr, obs, and mgrt. Next we formalise this kind of
projections over bigActor traces.
Projections of BigActor traces
Let TBA(c) be the universe of bigActor traces starting with conﬁguration c = ⟨α | host |
µ | η | B0⟩and let T‵Bg(K,R) be the universe of bigraph traces from reaction system ‵Bg(K, R)

CHAPTER 3. BIGACTORS
48
with signature K and reaction rules R. The projection of a bigActor trace into its respective
bigraph trace is provided by the map
projectBg : TBA(c) →T‵Bg(K,R)
(3.4)
projectBb(c0
l0−→c1
l1−→. . .
ln−1
−−→cn) 7→(B0
r0
−→B1
r1
−→. . .
rm−1
−−−→Bm)
(3.5)
where (B0, B1, . . . , Bm) is the sequence of diﬀerent bigraphs in (c0, c1, . . . , cn), and each ri
represent bigraph reaction rule that creates Bi+1 due to a bigActor transition labelled as
lj = ⟨ctr : a,ri⟩.
Example 3.6. The application of projectBg to the trace of Figure 3.17 results into the
bigraph trace depicted in Figure 2.7.
Let TAct(ca
0) be the universe of actor traces starting with the actor conﬁguration ca
0 = ⟨αa |
µa⟩.
projectAct : TBA(c) →TAct(ca)
(3.6)
projectAct(c0
l0−→c1
l1−→. . .
ln−1
−−→cn) 7→(ca
0
λ0
−→ca
1
λ1
−→. . .
λm−1
−−−→ca
m)
(3.7)
where ca
i = ⟨αa
i | µa
i ⟩denotes an element of the sequence of actor conﬁguration, and λi denotes
the elements of the sequence of actor semantics rules labels.
Synthesizing the sequence
of labels λi is quite trivial.
One must simply abstract away all the bigActor semantics
labels that are either req, ctr, obs, and mgrt. We also need to remove all labels rcv that
are produced due to the consumption of messages with observations.
All the remaining
bigActor labels (namely, fun, new, snd, rcv, and nil) represent exactly the actor semantics
labels. After synthesizing the sequence of labels one must synthesize the actor conﬁgurations
ca
i = ⟨αa
i | µa
i ⟩.
The sets of pending messages µa
i can be obtained by abstracting away
all messages from in the bigActor conﬁguration coming from observation commands. The
synthesis of the sequence of actors is more complex αa
i since one must produce a set of actors
at αa
0 which execution matches exactly the derived sequence λi. This synthesis process is
out of the scope of this work. Nevertheless, we present an example to provide the intuition
behind the process.
Example 3.7. Consider again the bigActor system of Figure 3.14 and the respective trace
of Figure 3.16. Recall the sequence of bigActor semantic labels:
(⟨req : app2, control(r)⟩, ⟨ctr : r⟩, ⟨req : app2, observe(q)⟩, ⟨obs : q, Bobs = [[q]]host(app2)
B1
⟩,
⟨rcv : ⟨app2 ⇐Bobs⟩⟩, ⟨req : app2, control(r′)⟩, ⟨ctr : r′⟩, ⟨req : app2, control(r′′)⟩, ⟨ctr : r′′⟩,
⟨req : app2, send(social2, photo)⟩, ⟨snd : ⟨social2 ⇐photo⟩⟩, ⟨rcv : ⟨social2 ⇐photo⟩⟩,
⟨fun : social2⟩, ⟨nil : app2⟩, ⟨nil : social2⟩)

CHAPTER 3. BIGACTORS
49
We proceed by removing all the bigActor-speciﬁc labels obtaining the following trace:
(⟨snd : ⟨social2 ⇐photo⟩⟩, ⟨rcv : ⟨social2 ⇐photo⟩⟩,
⟨fun : social2⟩, ⟨nil : app2⟩, ⟨nil : social2⟩)
The behaviour that remains in the trace is the actor-speciﬁc behaviour, i.e. the concurrent
asynchronous message-passing semantics. The actor system of Figure 3.18 produces such
trace.
val app2 = actor{
social2 ! photo
}
val social2 = actor{
var log = List()
react{
case photo => log = photo :: log
}
}
Figure 3.18: Actor system synthesized to produce the projected trace of Figure 3.16.
Note that the behaviour speciﬁcation of social2 in Figure 3.18 is the same that its bi-
gActor counterpart in Figure 3.14. This is expected since the bigActor version itself does not
perform any bigActor-speciﬁc commands. The behaviour speciﬁcation of app2 in Figure 3.18
only contains one command, social2 ! photo. This is expected as well since, by looking
into its bigActor counterpart in Figure 3.14, social2 ! photo is the only actor-speciﬁc
command of app2.
Scheduling policy
The BigActor Model semantics does not force a scheduling policy for the execution of
requests. Nonetheless, it is often of practical use to deﬁne a scheduling semantics. For the
scope of this thesis we assume that requests are served according to a First-Come First-Served
scheduling policy.
Let Λ denote the set of labels for the semantic rules stated in Figure 3.13. Let Λη ⊂Λ
denote the set of labels produced by the rule ⟨req : a, r⟩and Λπ denote the set of labels
produced by the rules ⟨obs : a, q, o⟩, ⟨ctr : a, u⟩, ⟨mgrt : a, h′⟩, and ⟨snd : a, ⟨a′ ⇐m⟩⟩.
Consider a function schdt : Λπ →Λη where, for a given execution t = c0
λ0
→c1
λ1
→. . .,
schdt(λπ) returns the request consumed while executing λπ. Let ≺t⊆Λ × Λ be a total order
induced by the index i of λi in t.

CHAPTER 3. BIGACTORS
50
Deﬁnition 3.4 (FCFS). An execution t = c0
λ0
→c1
λ1
→. . . follows a First-Come First-Served
(FCFS) discipline if:
λi ≺t λj ⇒schd(λi) ≺t schd(λj)
where λi, λj ∈Λπ.
In other words, FCFS discipline requests that requests are served in the order that are
requested.
3.5
Communication back-channelling
In the actor model state is local. The memory of an actor inﬂuences another only up to
the messages ﬂowing between them. In the BigActor model the Bigraph is a shared structure,
and some might argue this globalizes state. For example, one may communicate between
bigActors by placing and removing nodes in the bigraph and never send any inter-actor
messages at all. We would consider this misuse of the model, but have nevertheless elected
to provide the bigraph as a shared structure to keep the model expressive. The BigActor
formalism is a model for actors operating in spatial worlds, which may in many applications
be a shared space to the actors.
This misuse of the bigraph (and bigraph reaction rules) in the bigActor model can create
communication back-channelling between actors. There are ways to close this channel. One
may simply make the bigraph encapsulated into an actor.
Then all req, obs, ctr, and
mgrt actions would appear as the ﬂow of messages between actors and the entire physical
world would become the local state of one actor. This solves the problem but does not
address the fundamental diﬃculty of coordinating observing and changing a shared machine.
Therefore we have presented a semantics in which the bigraph is not encapsulated in an
actor and extended the actor conﬁguration to include explicitly the bigraph, the hosting
map, and η which models requests that aﬀects them. By making these interactions explicit,
the programmer can become aware of the programming style that we advocate with the
bigActor model.
The model does support a suﬃcient condition, derived from its semantics for closing
the bigraph communication back-channelling. One may require that two bigActors never
control and observe the same region of the bigraph. The semantics of a BigActor permits us
to derive the area of inﬂuence of a bigActor as expressed in Deﬁnition 3.5.
Area of inﬂuence
Communication back-channelling is deﬁned as the explicit use of the bigraph between
two bigActors for exchanging information instead of the asynchronous message passing.
Deﬁnition 3.5 (Area of inﬂuence). Let a be a bigActor and Ra = {R0 →R′
0, R1 →
R′
1, . . . , Rn →R′
n} the set of all concrete BRRs used by it. The area of inﬂuence of a over a

CHAPTER 3. BIGACTORS
51
internet
app2
B0
A
internet
B0
social2
B0
A
Figure 3.19: Areas of inﬂuence AB0
app2 and AB0
social2.
bigraph B is the bigraph AB
a formed by the set of nodes VAB
a such that v ∈VAB
a ⇒∃i.B =
C ◦Ri ◦d ∧v, h ∈VRi.
Example 3.8. Consider the bigActors app2 and social2 both hosted at respectively sp
and srv. By design decision let MOVE HOST TO(Loc) and CONNECT HOST TO(Wlan) be the
two kinds of BRRs allowed for both bigActors.
The area of inﬂuence AB0
app2 is the bigraph formed by nodes sp, street0, street1,
street2, street3, and street4 while the area of inﬂuence AB0
social2 is the bigraph formed
by nodes srv, street5, and wlan2. Figure 3.19 depicts AB0
app2 and AB0
social2.
Deﬁnition 3.6 (Reachable area of inﬂuence). Let ˆAB
a denote the reachable area of inﬂuence
of a starting at bigraph B, i.e. the bigraph formed by all the nodes in AB′
a
where B′ is
obtainable from B by the the application of a ﬁnite number of rules from Ra.
Dually to the concept of area of inﬂuence, we deﬁne the area of observation of a bigActor
as follows.
Deﬁnition 3.7 (Area of observation). Let a be a bigActor and Qa = {q0, q1, . . . , qn} the set
of all queries used by it. The area of observation of a over a bigraph B is the bigraph OB
a
formed by the set of nodes VOB
a such that v ∈VOB
a ⇒∃i.Bobs = [[qi]]B
host(a) ∧v ∈VBobs.
Deﬁnition 3.8 (Reachable area of observation). Let ˆOB
a denote the reachable area of ob-
servation of a starting at bigraph B, i.e. the bigraph formed by all the nodes in OB′
a
where

CHAPTER 3. BIGACTORS
52
B′ is obtainable from B by the the application of a ﬁnite number of rules from Ra or by a
migration of a.
Theorem 3.1. Let c0 →c1 →. . . be an execution trace where c0 = ⟨α | host | µ | η | B⟩
is a BigActor conﬁguration and →is given by the BigActor semantics. Consider any two
bigActors a, a′ ∈α where a ̸= a′ . If the nodes of ˆAB
a and the nodes of ˆOB
a′ are disjoint sets,
then a and a′ are free from communication back-channelling.
Proof. By deﬁnition of communication back-channelling, two bigActors can communicate
through back-channelling if one can modify the bigraph and the other can observe such
modiﬁcation. Thus, by requiring that the reachable area of inﬂuence of a bigActor is disjoint
from the reachable area of observation of another then the two bigActors are trivially free
from communication back-channelling.
Example 3.9. Consider two bigActors a and a′ hosted respectively in sp and srv of Figure
3.15. Consider that such bigActors can use bigraph reaction rules of the kind MOVE HOST -
TO(Loc) and CONNECT HOST TO(Wlan), and can observe the bigraph using the queries HOST,
PARENT HOST, and CHILDREN(PARENT(HOST)). Consider that only a is allowed to migrate.
Note that there are no bigraph reaction rule that let a′ move its host srv out of its original
location, or change the bigraph in any way. Moreover, with the queries speciﬁed above, a′
can only observe its host srv, the parent of the host wlan2 and the nodes inside wlan2
(which is solely srv). Also note that using solely control actions, a can move to any street
except street5 and can connect to any wireless hotspot except wlan2. It is possible for a
to migrate to srv for example after moving to street3 and connect to wlan0. Nevertheless,
after being hosted in srv, a can not perform any of the allowed reaction rules. Thus, since
a can not change the structure that a′ can observe there are no means for communication
back-channelling.
3.6
Correctness of BigActor Model Semantics
The BigActor model is an expressive programming model and, as such, it provides the
programmer with means for writing good but also bad programs. This is common in general-
purpose programming models where expressiveness is mandatory. For example, one can write
in the actor model a program where an actor keeps sending messages in a loop to an actor
that never receives them. This is in general considered a bad program that could in practice
lead to a memory leak.
Although this is still a valid behaviour up to the actor model
semantics.
For the same generality argument, we do not want to constrain the bigActor model
expressiveness. Every behaviour that is in the scope of the bigActor semantics is considered
a valid behaviour. Nevertheless, the bigraph of a bigActor system is a shared environment
and it is susceptible of issues that may lead conﬁgurations that can not progress any-more
according to the bigActor semantics. We call such conﬁgurations unsafe.

CHAPTER 3. BIGACTORS
53
A BigActor Model execution may lead to unsafe conﬁgurations due to two main issues:
• A bigActor requests a control, a migration, or a send command that can not be exe-
cuted.
• Concurrency between bigActors turns executable requests unexecutable.
Example 3.10 (Misbehaved Token Grabber). Consider the bigActor grabberBA depicted
at Figure 3.20 and execution depicted in Figure 3.21. grabberBA is hosted at bag0 and
its behaviour consists of picking tokens t0 and t1 and putting them inside bag0.
The
val grabberBA = BigActor hosted_at bag0 with_behavior{
control(GRAB(t0))
control(GRAB(t1))
}
Figure 3.20: BigActor grabberBA.
bigraph does not include a token t1. The bigActor execution trace reaches a conﬁguration
with a request ⟨req : grabberBA, control(GRAB(t1))⟩that can not be executed. Thus, this
conﬁguration is unsafe.
Figure 3.21: Example of an execution of grabberBA leading to an unsafe conﬁguration.
Example 3.11 (Concurrent Token Grabbers). Consider the bigActor system formed by
the two bigActors provided at Figure 3.22. Consider now two bigActors grabberBA0 and
grabberBA1 hosted at respectively bag0 and bag1. The behavior of grabberBA0 consists
of requesting to pick the tokens t0 and t1, while the behavior of grabberBA1 attempts at
grabbing t1 and t2. The execution, depicted by Figure 3.23, shows grabberBA0 grabbing
t0, then grabberBA1 grabs t1. When grabberBA0 requests to grab t1 the token is not
available and, thus, the execution reaches an unsafe conﬁguration. Note that if we consider
the same bigActor system but with only one of the bigActors, the execution terminates in a
safe conﬁguration without any requests left. Concurrency is the reason for the execution to
reach an unsafe conﬁguration. This situation is also known as a race-condition.
We adapt the notion of progress and preservation from Benjamin Pierce’s“Types and
Programming Languages” [63] to deﬁne safe bigActor conﬁgurations and present suﬃcient
conditions for safe bigActor executions.

CHAPTER 3. BIGACTORS
54
val grabberBA0 = BigActor hosted_at bag0 with_behavior{
control(GRAB(t0))
control(GRAB(t1))
}
val grabberBA1 = BigActor hosted_at bag1 with_behavior{
control(GRAB(t0))
control(GRAB(t1))
}
Figure 3.22: BigActors grabberBA0 and grabberBA1.
Figure 3.23: Example of an execution of multiple bigActors leading to an unsafe conﬁgura-
tion.
Progress and Preservation
First we need to deﬁne a terminal conﬁguration, i.e. a bigActor conﬁguration where
there is noting remaining to be executed.
Deﬁnition 3.9 (Terminal Conﬁguration). Let c = ⟨α | µ | η | B⟩be a BigActor conﬁgura-
tion. c is terminal if µ = ∅, η = ∅, and α = ∅or all bigActors in α are waiting to receive a
message (i.e. their next command is ready(·)).
Deﬁnition 3.10 (Progress). A conﬁguration c is safe if it is terminal or it can make progress,
i.e. there exits a bigActor semantics rule with label λ from Figure 3.13 such that c
λ−→c′.

CHAPTER 3. BIGACTORS
55
We call preservation to the property a safe conﬁguration always transitioning to another
safe conﬁguration.
Deﬁnition 3.11 (Preservation). Let c be a safe bigActor conﬁguration. If c
λ→c′ then c′ is
safe.
Safety of a single bigActor
The ﬁrst step towards safety is to require that a single bigActor itself never requests
operations that will lead to an unsafe conﬁguration.
Deﬁnition 3.12 (Feedback BigActor). Let t = c0
λ0
→c1
λ1
→. . . be a bigActor execution. For
clarity we augment λi to λa
i . a is called feedback for all r and r′ that are either control,
migrate, or send the following are true:
1. ∀j.λj = ⟨req : a, r⟩⇒∃i < j.λi = ⟨obs : a, q, Bobs⟩
2. ∀i.∀k.k > i∧λi = ⟨req : a, r⟩∧λk = ⟨req : a, r′⟩⇒∃j.i < j < k∧λj = ⟨obs : a, q, Bobs⟩
3. Let Ba,λi
obs denote the last observation of a preceding λi.
∀i.λi = ⟨req : a, r⟩⇒∃c′.⟨α | ∅| {r} | Ba,λi
obs ⟩
λ′
i→c′ where λ′
i consumes the request
(a, r)
The ﬁrst requirement states that before any request r by a, there must be an observation
by the same bigActor. The second requirement states that between two requests r and r′
by a there must be an observation by the same bigActor. The last requirement states that,
given a conﬁguration formed by a bigraph Ba,λi
obs and a single request r then there is a new
conﬁguration obtained by consuming r. In other words, it reqeires that r can be executed
over the observation bigraph and thus also executable over the bigraph at the observation
time.
Theorem 3.2. Consider a BigActor execution t = c0
λ0
→c1
λ1
→. . .
λn
→cn that follows a FCFS
discipline (Assumption 3.2.1). Assume that αi contains a single BigActor a for all i and a
is a feedback BigActor (Assumption 3.2.2). Assume that η and µ are empty at c0 and c0 is
safe (Assumption 3.2.3). Then cn is safe.
Proof. By mathematical induction in the the number of transitions.
Base case Given c0
λ0
→c1, c1 is safe.
By Assumption 3.2.3 a must be busy otherwise c0 is terminal (Deﬁnition 3.9) and
λ→can
not be triggered. If a is busy then it can trigger any of the following rules leading to c1: fun,
new, term, and req. Since the overall execution is assumed to have only one bigActor new is
excluded. By Assumption 3.2.3, the rules ctr, mgrt, obs, snd can not be executed since η is
still empty. fun, and term are internal to the actor and can not generate a transition to an

CHAPTER 3. BIGACTORS
56
unsafe conﬁguration. By Deﬁnition 3.12 item 1, the rule req can only request an observation
because a control, migrate, or a send require a previous observations.
Inductive step Given ci−1
λi−1
→ci where ci is safe then ci
λi→ci+1 and ci+1 is safe.
Since ci is safe then λi can be given by one of the following rules: fun, rcv, term, req,
ctr, mgrt, obs, and snd (new is excluded by Assumption 2).
By the semantics presented in Figure 3.13, the rules fun, rcv, and term model internal
computation of bigActors and, thus, do not produce nor consume requests that can make
the conﬁguration unsafe.
The rule req can produce a new request, i.e. ηi+1 = ηi ∪{r}. If r corresponds to an
observation then ci+1 is correct since the observations do not change the bigraph. If r is
either a control, a migration or a send request then it must produce a correct conﬁguration
upon Ba,r
obs. By Deﬁnition 3.12, a alternates between observation and control/migrate/send
then the bigraph Bi at conﬁguration ci can be decomposed as Bi = C ◦Ba,r
obs ◦d where Ba,r
obs
is the last observation prior to r. By Deﬁnition 3.12 item 3, r must be executable over Ba,r
obs.
Since Bi = C ◦Ba,r
obs ◦d then r also produces a correct conﬁguration under Bi.
The rules ctr, mgrt, and obs consume one request r out of ηi. By Assumption 3.2.1,
all requests of a are served in order. Since all requests in ηi were generated by a (single)
feedback BigActor, then ci+1 with ηi+1 = ηi \ {r} is safe.
Note that the proof preserves both progress and preservation for all conﬁgurations.
Safety of concurrent bigActors
In the multiple bigActor case, the feedback condition is not suﬃcient for safety. A bigAc-
tor may request an operation executable at request time, but not executable when the request
is executed. This is a consequence from concurrency and asynchrony of the bigActor seman-
tics. We take two strategies to prevent unsafe conﬁgurations due to concurrency: prevent
undesired interleaving (atomic read-write semantics); prevent shared resources (partitioning
semantics).
Deﬁnition 3.13 (Atomic read-write semantics). Let Λθ denote the set of all req, ctr, mgrt,
and snd labels and let Λa
θ be the subset of labels from Λθ produced by serving requests from
a. An execution t = c0
λ0
→c1
λ1
→. . .
λn−1
→cn follows an atomic read-write semantics if for any
λi = ⟨obs : a, ·⟩for which there exists a λi+k ∈Λa
θ then there are no λi+j ∈Λa′
θ where a ̸= a′,
j ∈{1, . . . , ˆk −1}, and ˆk = min{k|λi+k ∈Λa
θ}.
In other words, an atomic read-write semantics requires that between any obs from a
and subsequent ctr, mgrt, or snd from the same bigActor, no other ctr, mgrt, or snd can
occur from another bigActor a′.
Theorem 3.3. Consider a BigActor execution t = c0
λ0
→c1
λ1
→. . .
λn−1
→cn that follows a FCFS
discipline (Assumption 3.3.1) and the execution follows an atomic read-write semantics (As-

CHAPTER 3. BIGACTORS
57
sumption 3.3.2). Assume that all bigActors are feedback (Assumption 3.3.3). Assume that
η and µ are empty at c0 and c0 is safe (Assumption 3.3.4). Then cn is safe.
Proof. Without loss of generality, assume that the conﬁgurations at execution t contains
only two bigActors a and a′ (two feedback bigActors is suﬃcient to lead to an unsafe con-
ﬁguration). By Assumption 3.3.1 and Assumption 3.3.2 the execution has no interleaving
between observations and ctr/mgrt/send of two diﬀerent bigActors. Thus, one can parti-
tion the sequence t into subsequences ta
0, ta′
0 , ta
1, ta′
1 . . . where each ta
k denotes the execution
of a single BigActor a (and possibly labels regarding rules fun, term, new and rcv which
are internal to bigActors and do not lead to unsafe conﬁgurations). Since each bigActor a
is feedback (Assumption 3.3.3), by Theorem 3.2, each ta
k = c →. . . →c′, c′ is safe. Thus, cn
is also safe.
Deﬁnition 3.14 (Partitioning semantics). Consider an execution t = c0
λ0
→c1
λ1
→. . .
λn−1
→cn.
Let Aa
i denote the area of inﬂuence of a at ci, i.e., the portion of the bigraph that can be
changed by means of Bigraph Reaction Rules applied with respect to the host of a. An
execution follows a partitioning semantics if, for every two bigActors a and a′, the following
holds:
1. ∀i.∀j.Aa
i ∩Aa′
j = ∅
2. ∀i.∀j.∀v ∈Aa
i .∀v′ ∈Aa′
j .Lks(v) ∩Lks(v′) = ∅
where Lks : VB →P(EB ⊎YB) is a function that returns the set of links connected to ports
of a given node.
In other words, partitioning semantics requires the areas of inﬂuence of any two bigActors
and their links be disjoint at every time.
Theorem 3.4. Consider a BigActor execution t = c0
λ0
→c1
λ1
→. . .
λn
→cn that follows a FCFS
discipline (Assumption 3.4.1) and the execution follows a partitioning semantics (Assump-
tion 3.4.2). Assume that all bigActors are feedback (Assumption 3.4.3). Assume that η and
µ are empty at c0 and c0 is safe (Assumption 3.4.4). Then cn is safe.
Proof. Without loss of generality assume the execution of two bigActors a and a′.
By
Deﬁnition 3.14, the areas of inﬂuence and corresponding links are disjoint throughout the
overall trace t = c0
λ0
→c1
λ1
→. . .
λn−1
→cn. Then each Bi at conﬁguration ci can be decomposed
into Bi = Ba
i ◦Ba′
i where Ba
i and Ba′
i are disjoint (without sharing any nodes nor edges nor
names). Thus, each conﬁguration ci = ⟨{a, a′} | µi | ηi | Bi⟩can be decomposed into two
conﬁgurations ca
i = ⟨{a} | µa
i | ηa
i | Ba
i ⟩and ca′
i = ⟨{a′} | µa′
i | ηa′
i | Ba′
i ⟩where µi = µa
i ∪µa′
i
and ηi = ηa
i ∪ηa′
i . Since a and a′ are feedback, then by Theorem 3.2, there exists two traces
where ca
0 →. . . →ca
n and ca′
0 →. . . →ca′
n where ca
n and ca′
n are safe. cn can be either ca
n or
ca′
n . Thus, cn is safe.

CHAPTER 3. BIGACTORS
58
3.7
Final remarks
In this chapter we introduce the BigActor model for modelling structure-aware compu-
tation, i.e., computation that interacts with its environment by sensing and controlling its
location and connectivity. The model combines the Actor model [2] for modelling reactive,
concurrent and distributed systems and the Bigraph model to model the structure of physical
machines [3]. The BigActor Model provides a bridge between programs and machines with
dynamic structure. Programs are written as actors while bigraphs describe the structure of
the world in terms of the location and connectivity of computing machines.
We introduce an operational semantics for the BigActor model as an extension of the
Actor model semantics. The semantics is enriched with three rules that provide means for
bigActors to observe, control the bigraph, and migrate. Observations are speciﬁed using the
query language introduced in Chapter 2.
We analyse the correctness of bigActor executions in terms of progress and preservation,
i.e., the ability to a conﬁguration to progress to another conﬁguration while preserving
correctness. We introduce a programming pattern for bigActors called feedback where a
bigActor always observes the space that is willing to control and thus, avoiding creating
control actions that could lead to unsafe conﬁgurations. We provide suﬃcient conditions for
correct executions of feedback bigActors with the presence of concurrency. Atomic read-write
semantics requests that between an observation and a control action of a feedback bigActor,
no other bigActor can alter the bigraph. Partitioning semantics requests concurrent feedback
bigActors to operate at disjoint areas of space.

59
Chapter 4
BigActor Programming Language
The BigActor Programming language (BAL) is an embedded Domain Speciﬁc Language
(DSL) hosted in the Scala Programming Language [23]. The bigActor semantics is imple-
mented as a library that extends the standard Scala Actor library. As an embedded DSL
the syntax of BAL is by deﬁnition the syntax of Scala.
Nonetheless, BAL uses Scala’s
type system together with high-order functions and implicit conversions in order to create a
domain-speciﬁc syntactic constructs.
BigActors operate over bigraphical abstractions of the world. In BAL, the bigraphical
abstractions are expressed using a bigraph term language known as BGM. BigActors request
observations of the underlying bigraph using a query language and request to change the
bigraph using Bigraph Reacion Rules (BRRs). The execution of BRRs over the bigraph
is performed using the bigraph model checker BigMC [64]. The BigActor Runtime System
(BARS) is responsible for mediating the execution of bigActor instances over a bigraphical
abstraction handled by BigMC.
BARS operating over BigMC provides a framework for executing bigActors over a sim-
ulated bigraphical world. The interactions with the physical world are investigated in the
second part of this dissertation.
The remainder of this chapter goes as follows. Section 4.1 presents a brief introduction
to the Embedded DSLs. Section 4.2 provides an overview of the Scala programming lan-
guage, in particular the Actor library and the RemoteActor library. Section 4.3 introduces
the BigActor Programming Language and each major component of the BigActor Runtime
System (BARS). Section 4.4 presents a simulation environment for BigActors which uses the
bigraphical model checker BigMC to handle the bigraphical executions. Section 4.5 presents
a case study in mobile robotics, where vehicles and sensors perform a oil-spill monitoring
mission speciﬁed using bigActors. We conclude in Section 4.6 with some ﬁnal remarks.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
60
4.1
What is an Embedded DSL
DSLs are programming languages that provide programmers with constructs targeting
a speciﬁc application.
The objective of a DSL is to facilitate the programmer to write
software to a particular domain quickly and eﬀectively, producing programs that are easy
to understand and reason [65]. This contrasts with General Purpose Languages (GPLs)
that aim at reaching wider communities of programmers by providing expressive language
constructs that are independent of application domains.
DSLs are commonly divided into two categories: external and internal (also known as
embedded). External DSLs have their own custom syntax. Building an external DSL re-
quires the implementation of an infrastructure for scanning, parsing, compilation and/or
interpretation, as well as tools for supporting the programmer such as debuggers, editors,
integrated development environments, etc.
Embedded DSLs are built over a given host language (usually a General Purpose Lan-
guage). The semantics of the target domain is implemented using the host language. This
strategy has the advantage of not having to develop any language infrastructure. The de-
signer of the DSL focuses mostly on the implementation of the domain semantics.
The
syntax of the DSL is limited to use the core syntax of the host language. There are two
ways of embedding a DSL in a host language: shallow and deep. Shallow embeddings are
libraries written in the host language. The library deﬁnes the abstractions, operations, and
composition rules of the DSL. Deep embeddings use the host language data structures to
represent DSL programs as Abstract Syntax Trees (ASTs) and provide means to interpret
them.
Diﬀerent host languages provide diﬀerent semantic abstractions. As such, it is convenient
to choose a host language with semantical constructs as close as possible to the ones desired
for the embedded DSL. Haskell, Groovy, and Scala are popular host languages. They are
equipped with means such as static type checking, type inference, Algebraic Data Types
(ADTs), high-order functions, and implicit type conversion that can be used for achieving a
domain-speciﬁc syntax without the need to construct a parser and a compilere. Ghosh [66]
describes several techniques to use this languages in order to develop DSLs.
We designed BAL as a shallow embedded DSL hosted at Scala. The BigActor model is
built semantically over the Actor model. Thus, we looked for hosting languages with actors
as the main concurrency model. This requirement is satisﬁed by Scala, which uses actors
as the primary concurrency model. Another factor that inﬂuenced our decision is Scala’s
capabilities for hosting DSLs. Next we provide a brief overview of Scala, focusing on the
capabilities that are relevant for the implementation of BAL.
4.2
Scala Programming Language
Scala is a modern programming language that runs over the Java Virtual Machine (JVM).
It is a multi-paradigm language, providing the programmer with functional and object-

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
61
oriented abstractions. Scala is statically typed. However, it provides a type-inference mech-
anism that liberates the programmer from writing heavily type-annotated programs as in
Java. The language provides an implicit type conversion mechanism. Implicit conversion
is used to convert automatically the type of a value from its original type to a new type
that provides additional methods or ﬁelds. Implicit conversions is used as part of a DSL
construction pattern for chaining data and commands [66]. Nonetheless, this is a powerful
feature and should be used with extra care since it makes types weaker.
The de facto concurrency model of Scala is the actor model. Next we provide a brief
overview of the Scala Actor and RemoteActor libraries1.
The Actor Model in Scala
The Actor library provides means to instantiate and invoke actors by extending the Actor
trait. There are two ways of deﬁning an actor. One can create a class that extends the Actor
trait, override the act method to specify the desired behaviour, and then instantiate and
invoke actor objects from the deﬁned class. Figure 4.1 shows the deﬁnition of a simple actor
class and its instantiation and invocation. The actor prints the word World as soon as it
receives a message Hello. The other way to deﬁne an actor is to use the actor method
class HelloActor extends Actor{
def act(){
react{
case "Hello" => println("World")
}
}
}
val a = new HelloActor
a.start()
Figure 4.1: A simple actor class and its instantiation and invocation.
deﬁned in the Actor companion object. This provides a way to deﬁne an actor on-the-ﬂy
without the need to deﬁne a class a priori. Figure 4.2 presents the same actor of Figure 4.1
but instantiated and invoked with the actor method.
The Actor library provides commands that implement the asynchronous message-passing
concurrency semantics of the actor model [2]. An actor can send a message to another actor
using the “!” command. For example, a ! "Hello" sends a message "Hello" to a.
1The Actor and the RemoteActor libraries are deprecated since Scala 2.11 in favour of the Akka frame-
work. Our implementation also supports Akka actors. Nonetheless, for the sake of keeping the notation con-
sistent throughout our work we decided to describe the implementation over the Actor and the RemoteActor
libraries.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
62
val a = actor{
react{
case "Hello" => println("World")
}
}
Figure 4.2: A simple actor instantiated and invoked using the actor method.
The react method takes a body consisting of a sequence of case statements.
The
messages received in an actor’s mailbox are passed to the case statements to be pattern-
matched. The ﬁrst case to be matched by the message is the one that is executed.
The RemoteActor Library
The RemoteActor library provides methods to create and select actors that are instan-
tiated in diﬀerent machines. A remote actor needs to be identiﬁed by a unique ID of type
Symbol. The symbol is unique to the JVM instance on which the remote actor is executed.
A Symbol is created by pre-pending a “’” before the desired name, e.g. ’myActor.
Figure 4.3 shows a code sketch to create a remote actor. The method alive deﬁnes the
actor {
alive(9000)
register(’myActor, self)
// behaviour definition
}
Figure 4.3: Remote actor instantiation.
TCP port that the actor is going to use to communicate. The method register takes the
unique ID symbol and the actor instance name to be registered in the remote actor system.
A Symbol name can only be registered with a single actor at a time. Only when the actor is
terminated, can its Symbol name be reused.
Figure 4.4 shows how to select and use a remote actor. The method select takes an
actor {
val c = select(Node("127.0.0.1", 9000), ’myActor)
c ! msg
// ...
}
Figure 4.4: Remote actor selection and use.
object of kind Node and a Symbol denoting the ID of the remote actor to be selected and

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
63
returns a actor instance that can be used just as a regular actor. The Node constructor takes
the IP address of the machine where the actor is being hosted and the TCP port.
4.3
BARS - The BigActor Runtime System
In this section we discuss the architecture and implementation of BAL. BAL programs
run over the BigActor Runtime System (BARS). Figure 4.5 shows the main components
of BARS and their interactions. The top layer depicts the bigActor instances. The mid-
HOSTING_REQUEST
OBSERVATION_REQUEST
CONTROL_REQUEST
MIGRATION_REQUEST
SEND_REQUEST
HOSTING_SUCCESSFUL
Messages and observations
BigActors
BigActorSchdl
BigraphManager
BIGRAPH_REQUEST
EXECUTE_BRR
BIGRAPH_RESPONSE
Figure 4.5: BigActor Runtime System.
dle layer, named BigActorSchdl, represents the scheduler that takes requests from the
bigActor instances and executes them. The bottom layer, named BigraphManager, repre-
sents the component that is responsible to handle the bigraphical abstraction of the world.
BigraphManager takes requests from BigActorSchdl to get the latest bigraph and to exe-
cute BRRs. The architecture presented in Figure 4.5 implements the asynchronous bigActor
semantics introduced in Chapter 3.
Next we explain each component and what makes this implementation faithful to the
bigActor semantics.
BigActor library
The BigActor library is deﬁned as a class named BigActor that extends the Actor trait
mixed with BigActorCommands trait. Figure 4.6 presents the code skeleton of BigActor and
BigActorCommands. BigActor is an abstract class with an function named behavior. This
function is implemented by each bigActor in order to deﬁne its behavior. This function plays
the same role as act in the Actor class deﬁnition.
BigActor overrides the function act.
The implementation of act sends ﬁrst a mes-
sage HOSTING REQUEST(hostID) to the BigActor Scheduler, named BigActorSchdl. If the

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
64
abstract class BigActor(hostID: Symbol) extends Actor with BigActorCommands{
def behavior
def act{
bigActorSchdl !
HOSTING_REQUEST(hostID)
receive{
case HOSTING_SUCCESSFUL => println("BigActor successfully hosted")
}
behavior
}
}
trait BigActorCommands{
def observe(query: Query) = {
BigActorSchdl ! OBSERVATION_REQUEST(query)
}
def control(brr: BRR){
BigActorSchdl ! CONTROL_REQUEST(brr)
}
def migrate(newHostID: Symbol){
BigActorSchdl ! MIGRATION_REQUEST(newHostID)
}
def send(msg: Message,rcv: BigActor){
BigActorSchdl ! SEND_REQUEST(msg,rcv)
}
}
Figure 4.6: Deﬁnition of BigActor class.
BigActor Scheduler successfully hosts the bigActor, it replies with a message HOSTING -
SUCCESSFUL. After this point, act executes behavior.
The instantiation of a bigActor is similar to the instantiation of a regular actor except
that we need to provide the host node to the constructor and override the method behavior
instead of act.
Figure 4.7 provides a skeleton of the instantiation and invocation of a
bigActor.
val ba = new BigActor(’hostNode){
def behavior{
//bigActor’s behavior
}
}
ba.start
Figure 4.7: Instantiation and invocation of a BigActor.
The BigActor library also provides a DSL pattern based on typed abstractions [66]. This

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
65
pattern provides strategies for removing as much syntactic noise as possible from the host
language. For more details about implementing DSLs using implicit conversion see [66]. We
use implicit conversions together with the high-order functions to provide programmers with
a cleaner way of instantiating bigActors. Figure 4.8 provides the skeleton. Figure 4.8 shows
BigActor hosted_at "hostNode" with_behavior{
//bigActor’s behavior
}
Figure 4.8: Instantiation and invocation of a BigActor.
a distilled and readable syntax. It removes the need for parentheses. The new keyword
is removed. Scala allows the “dot” notation to be removed while calling methods. The
bigActor is invoked as soon as it is created. Thus, there is no need to execute the method
start.
The trait BigActorCommands provides the implementation of the bigActor commands
for observing (observe), controlling via BRRs to change the bigraph (control), changing
the host (migrate) as well as sending messages to other bigActors (send). Each method
sends messages to an actor named BigActorSchdl that implements the BigActor Sched-
uler. The messages are parametrized with the information required to perform the desired
command. For example, the observe(q) sends a message OBSERVATION REQUEST(q) to
BigActorSchdl. The use of actor messages for modelling bigActor requests implements the
asynchrony nature of such requests deﬁned by the BigActor semantics.
The functions deﬁned in BigActorCommands implement the semantic rule ⟨req : a, r⟩of
Figure 3.13 that adds request to the set of pending requests η. The set η is the modelled by
the mailbox of the actor BigActorSchdl.
BigActor Scheduler
The BigActor Scheduler is modelled as an actor named BigActorSchdl. It takes requests
from bigActors, i.e., hosting, observation, control, send, and migration, schedules and exe-
cutes them upon the current bigraph. It also keeps track and updates the hosting relation.
Since we are using a Scala actor to dispatch commands, the scheduling policy for the ex-
ecution of bigActor commands becomes the one used in the Scala Actor library, which is
First-Come First-Served (FCFS).
The interactions with BigActorSchdl are deﬁned using a set of case classes that extends
a trait named BigActorSchdlAPI (see Figure 4.9). This pattern of creating case classes
that inherit from a trait or abstract class is known as Algebraic Data Types (ADT). The
trait BigActorSchdlAPI is treated as the type constructor while all the case classes as data
constructors.
Figure 4.10 provides the skeleton of the class deﬁnition for BigActorSchdl. BigActorSchdl
has a local hash map named hostRelation that models the hosting relation between bigAc-
tors and bigraph nodes. BigActorSchdl has a react body nested in a loop body. The react

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
66
sealed trait BigActorSchdlAPI
case class HOSTING_REQUEST(hostId: Symbol) extends BigActorSchdlAPI
case class HOSTING_SUCCESSFUL extends BigActorSchdlAPI
case class OBSERVATION_REQUEST(query: String) extends BigActorSchdlAPI
case class CONTROL_REQUEST(brr: BRR) extends BigActorSchdlAPI
case class MIGRATION_REQUEST(newHostId: Symbol) extends BigActorSchdlAPI
case class SEND_REQUEST(msg: Any, rcv:BigActor) extends BigActorSchdlAPI
Figure 4.9: Algebraic data type BigActorSchdlAPI that deﬁnes a set of messages to interact
with BigActorSchdl.
object BigActorSchdl extends Actor{
val hostRelation = new HashMap[BigActor,BigraphNode]
def act(){
loop{
react{
case HOSTING_REQUEST(hostID) =>
//hosts the requester at hostID and replies back
//if the process was successful
case OBSERVATION_REQUEST(q) =>
//interprets q in the current bigraph
//sends the result back to the requester
case CONTROL_REQUEST(brr) =>
//executes brr in the current bigraph
case MIGRATE_REQUEST(hostID) =>
//migrates id to hostID
case SEND_REQUEST(msg,receiver) =>
//checks connectivity between the hosts of sender and receiver
//if hosts are connected it sends msg to receiver
case _ => println("UNKNOWN REQUEST")
}
}
}
}
Figure 4.10: Code skeleton for BigActorSchdl.
body is composed of several case alternatives. Each alternative pattern-matches upon mes-
sages deﬁned by the ADT BigActorSchdlAPI. When a request is received, BigActorSchdl
ﬁnds the corresponding alternative and executes the respective behavior.
From a bigActor semantics point of view, consuming messages from the BigActorSchdl
mailbox and their respective execution of case alternatives implements the execution of
requests from the set of pending requests η. Thus, we have a case alternative for each of the
following semantic rules: ⟨obs : a, q, o⟩, ⟨ctr : a, u⟩, ⟨mgrt : a, h′⟩, and ⟨snd : a, ⟨a′ ⇐m⟩⟩.
The case alternative that matches the message OBSERVATION REQUST(q) implements the

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
67
interpretation of a query q and sending a message to the requester with the result of the
observation.
The case alternative that matches the message CONTROL REQUST(brr) implements the
execution of brr over the current bigraph (if a match exists).
The case alternative that matches the message MIGRATE REQUEST(hostID) implements
the migration of the requester bigActor from its current host to hostID.
The case alternative that matches the message SEND REQUEST(msg,rcv) implements a
message msg being asynchronously sent to receiver after conﬁrming that the host of the
sender and the host of receiver are connected in the current bigraph.
Bigraph Manager
In order to request observations and control actions over the bigraphical abstraction of the
world, the BigActor Scheduler interacts with the Bigraph Manager, which is implemented as
an actor named BigraphManager. The Bigraph Manager is in charge of keeping an updated
bigraph abstraction and change it upon requests from the BigActor Scheduler.
BigraphManagerAPI is an ADT that speciﬁes the interactions with BigraphManager.
See Figure 4.11 for the deﬁnition of BigraphManagerAPI. BIGRAPH REQUEST is a request
sealed trait BigraphManagerAPI
case class BIGRAPH_REQUEST extends BigraphManagerAPI
case class BIGRAPH_RESPONSE(bigraph: Bigraph) extends BigraphManagerAPI
case class EXECUTE_BRR(brr: BRR) extends BigraphManagerAPI
Figure 4.11: Algebraic data type BigraphManagerAPI that deﬁnes a set of messages to
interact with BigraphManager.
to BigraphManager, which replies with a message BIGRAPH RESPONSE(bigraph) that en-
capsulates the current bigraphical abstraction. EXECUTE BRR(brr:
BRR) is a request to
execute a bigraph reaction rule brr over the current bigraph. BigraphManager is responsible
to check if the BRR has a match over the current bigraph, and handle its execution. The
dynamics of the bigraph is handled by a bigraph model checker. This is explained in detail
in Section 4.4.
Remote BigActor library
We extended the BigActor library to include means for instantiating and invoking bi-
gActors remotely.
For this matter we use the Scala RemoteActor library to create the
RmoteBigActor library.
A remote bigActor is registered, selected and used similarly to a remote actor (see Figure
4.12).
Figure 4.13 shows an alternative way of instantiate remote bigActors that handles the
registering and port attribution.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
68
//registering a remote bigActor
alive(9000)
register(’myBigActor, self)
//selection and use
val c = select(Node("127.0.0.1", 9000), ’myBigActor)
c ! msg
Figure 4.12: Remote bigActor registering, selection and use.
’myBigActor hosted_at "myHost" with_behavior{
//behavior definition
}
Figure 4.13: Remote bigActor instantiation.
The ports and IPs of bigActors are deﬁned in a conﬁguration ﬁle.
This provides a
separation of concerns between programming a bigActor program and conﬁguring the system
for its execution. We assume that the conﬁguration ﬁle is accessible to the overall scope of
the bigActor system.
In a remote bigActor system, the actors BigActorSchdl and BigraphManager are also
remote actors. We assume that there are one BigActorSchdl and one BigraphManager for
each remote bigActor system. A distributed solution is discussed in Chapter 6.
4.4
A simulation environment for BigActors
The Bigraph Manager serves as an interface between the world of bigActors and the world
of bigraphs. Diﬀerent applications require diﬀerent means of constructing and handling the
bigraphical abstraction. In this section we describe an infrastructure that allows the instan-
tiation of bigActors over simulated bigraphical abstractions. This provides programmers to
specify their own bigraphical abstractions for their domain and simulate the operation of
bigActors over the abstraction. The simulation of the bigraph dynamics is handled by a
model checker named BigMC [64]. Next we brieﬂy describe BigMC and the integration with
BARS.
The Bigraphical Model Checker - BigMC
BigMC (Bigraphical Model Checker) is a model-checker designed to operate on Bigraph-
ical Reactive Systems. In provides a framework for designing bigraphical models and their
dynamics, and check if they meet a given speciﬁcation. The speciﬁcation is written in pred-
icate logic enriched with two temporal commands, predecessor and successor. The bigraphs
are speciﬁed using the BGM format which follows Milner’s bigraph term language [3]. The

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
69
grammar for the BGM term language is provided in Figure 4.14. The “.” operator nests
0.
Term ::= Node.Term
1.
Term ::= (Term)
2.
Term ::= Term | Term
3.
Term ::= Term || Term
4.
Term ::= $int
5.
Term ::= Node
6.
Term ::= nil
7.
Node ::= name[names]
8.
Node ::= name
9.
names ::= n , names
10.
names ::= name
11.
name ::= [a-z A-Z][a-z A-Z 0-9]*
12.
int ::= [0-9]+
Figure 4.14: BGM grammar.
terms, e.g. Node0.Node1 means that Node0 is the parent of Node1. The “|” operator de-
ﬁnes to siblings, e.g. Node0|Node1 means that Node0 and Node1 are siblings. The “||”
operator deﬁnes two terms in two diﬀerent regions, e.g. Node0||Node1 means that Node0
is at region 0 while Node1 is at region 1. The “$” operator is used to identify holes, e.g.
$0 is the hole number 0. The nil value is used as the base case for the recursive nesting
of terms, e.g. Node.nil means that nothing is nested inside Node. A node is deﬁned as
nodeID[n0,n1,...n] where nodeID is the node name identiﬁer and [n0,n1,...n] is the
list of link names. It is also possible to deﬁne nodes without link names. A BRR is deﬁned
by the inﬁx operator “->”, Term0 -> Term1 denotes a BRR with redex Term0 and reactum
Term1.
Example 4.1. Figure 4.15 presents a bigraph term that models the bigraph depicted at
Figure 2.3. The term language implemented in BigMC does not provide means for closing
street0[road].(building0 |
building1) |
street1[road].(building2 | building3) |
street2[road].sp[e] |
street3[road].wlan0[internet] |
street4[road].wlan1[internet] |
street5[e0].srv[internet]
Figure 4.15: Term specifying the bigraph of Figure 2.3
links. Thus, all edges on the bigraph are also outer names.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
70
BARS on BigMC
Figure 4.16 shows the architecture of BARS on BigMC. The components in orange,
HOSTING_REQUEST
OBSERVATION_REQUEST
CONTROL_REQUEST
MIGRATION_REQUEST
SEND_REQUEST
HOSTING_SUCCESSFUL
Messages and observations
BigActor instances
BigActor Scheduler
Bigraph Manager
BIGRAPH_REQUEST
EXECUTE_BRR
BIGRAPH_RESPONSE
Bigraph Visualizer
Current bigraph (BGM)
BRR (BGM)
Initial bigraph (BGM)
BigMC
(bigraph execution engine)
ANTLR/Java Frontend
BigActor Runtime System
Figure 4.16: BigActor Runtime Syste on BigMC.
namely the BigActors, the BigActorSchld, and the BigraphManager, deﬁne the BigActor
Programming Language environment and are the essentially the same as the ones discussed
in Section 4.3.
The only diﬀerence is that the BigraphManager is now provided with a frontend to
interact with a bigraph deﬁned in BigMC using the BGM term language. This interactions
are mediated by a ANTLR/Java frontend that translates bigraphs in BGM format to a
Java object speciﬁed according to a Java bigraph library. The BigraphManager (which is
implemented on Scala) uses the Java bigraph library instead of dealing directly with BGM
terms.
The frontend is a translator implemented using ANTLR2 - a framework for the
implementation of lexical analysers, parsers and Abstract Syntax Tree (AST) walkers [67].
The Java Bigraph Library provides methods to call BigMC with a bigraph and a set of
BRRs, fetch the current bigraph, and render a bigraph graphically in a Java Swing compo-
nent.
The implementation shown in Figure 4.16 works as a stand-alone bigActor simulation
environment. The model checker BigMC takes the role of bigraph execution engine. BigMC
takes a bigraph and a BRR from the bigraph manager and performs reachability analysis of
only one step and returns the resulting bigraph to the bigraph manager.
2Acronym for “Another Tool for Language Recognition”.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
71
BARS on BigMC is open source and can be obtained at the repository in the URL
https://bitbucket.org/eloipereira/bigactors.
4.5
A case study in mobile robotics
We proceed with a case study in the domain of mobile robotics. The case study is adapted
from the paper [68] and consists of modelling and specifying the reactive and collaborative
behavior of a team of autonomous vehicles performing a bilge dumping monitoring mission.
Example 4.2. Consider the following scenario. An operator a the European Maritime Safety
Agency (EMSA) headquarters detects an oil spill by analysing high-resolution optical satellite
imagery and SAR imagery from the Integrated Maritime Data Environment (IMDatE) [69].
The operator suspects of a bilge dumping illegal activity by an oil tanker. In order to take
legal actions, EMSA must collect evidences in the form of images and water samples of the
oil-spill. To obtain such evidences the operator requests a collaborative robotic mission.
The mission is conducted by a network of three kinds of vehicles - Unmanned Aerial
Vehicles (UAVs), Navy vessels, and Autonomous Underwater Vehicles (AUVs). UAVs are
used for detecting and tracking oil spills as well as for collecting information of tankers that
broadcast their location using Autonomous Identiﬁcation System (AIS). The role of the Navy
vessels is to carry AUVs to the vicinities of an oil-spill, deploy and operate them in order to
take samples.
Next we explain the bigraphical abstraction for the scenario of Example 4.2, its dynamics,
and the mission speciﬁcation using bigActors.
Bigraphical abstraction
The signature for the logical-space model is as follows.
K = {Loc : 0, Tanker : 1, Vessel : 2, Auv : 1, Uav : 2, HQ : 2}
(4.1)
The kind Loc : 0 is used to denote geographical spaces delimited by polygons, e.g., the
space that comprises an air ﬁeld, and the space that entails an oil-spill. Nodes of kind Loc
have arity 0, i.e., do not share any links. The kind Tanker : 1 is used to denote the location
and connectivity of oil tankers. The connectivity of a node of kind Tanker models that the
respective tanker is broadcasting AIS messages. The kind Vessel : 2 denotes the location
and connectivity of Navy vessels. Nodes of kind Vessel have one link denoting connectivity
to a 3G network and a second denoting connectivity to an acoustic command and control
link used to operate AUVs. The kind Auv : 1 denotes the location and connectivity of AUVs.
Nodes of kind Auv have one link denoting the connectivity to an acoustic command and
control link. The kind Uav : 2 denotes the location and connectivity of UAVs. Nodes of kind
Uav have one link denoting connectivity to a 3G network and a second denoting the reception

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
72
of AIS messages. The kind HQ : 2 denotes the location and connectivity of command and
control headquarters. The connectivity of nodes of kind HQ is similar to the ones of kind Uav
Table 4.1 provides the sorting discipline for building bigraphs for this case study.
Type
Sorting
Placing
Uav, Vessel, and Tanker nodes can only be nested inside Loc nodes
Placing
Auv nodes can be nested inside Loc and Vessel nodes
Placing
Uav, Auv, Tanker, and HQ nodes are atomic
Linking
Auv nodes are connected to only one Vessel node
Table 4.1: Sorting discipline for the mobile robotics case study.
Figure 4.17 presents an example of a bigraph that respects the sorting discipline presented
in Table 4.1. Nodes airField, shore, and searchArea are of kind Loc. Nodes uav0 and
spill0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
tanker0
auv0
auv1
vessel0
a0
a1
ais0
uav0
ais1
ais2
Figure 4.17: Example of a bigraph generation for the mobile robotics case study.
uav1 are of kind Uav. Nodes auv0 and auv1 are of kind Auv. Nodes vessle0 and vessel1
are of kind Vessel. The node emsaHQ is of kind HQ. The BGM term that models the bigraph
of Figure 4.17 is presented at Figure 4.18.
Bigraph reaction rules
We deﬁne two sets of bigraph reaction rules: the set of control reaction rules Rc and the
set of environment reaction rules Re. Rc models the set of control actions that bigActors
can request. Re models the set of events performed by the environment. In the bigActor
semantics, only bigActors can request the execution of BRRs. In order to be faithful to the
semantics, we model the environment as a bigActor named env that can arbitrarily request
control actions from Re.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
73
searchArea.(tanker0[ais0]
|
spill0
|
uav0[3G,ais0]
|
auv0[a0]
|
vessel0[3G,a0])
|
shore.(vessel1[3G,a1].(auv1[a1]))
|
airfield.(uav1[3G,ais1])
|
emsaHQ[3G,ais2]
Figure 4.18: BGM term for the bigraph depicted in Figure 4.17.
Using the Discrete Event Systems terminology, one can interpret the transitions triggered
by rules on Rc as the set of controllable events while transitions triggered by rules from Re
as the set of uncontrollable events [70, 71].
Figure 4.19 presents a set of abstract BRRs modelling Rc. The rule MOVE HOST TO(loc)
models a vehicle moving from its current location to the location speciﬁed by loc. The term
HOST in the rule is replaced by the host of the bigActor that requests the rule. The kind of
HOST for this particular rule is either Uav or Vessel. The rule DEPLOY(auv) models a vessel
deploying auv. The term HOST in the rule is replaced by the host of the bigActor, which
must be of kind Vessel. The rule COLLECT(auv) is the dual of the rule DEPLOY(auv). The
rule SAMPLE(auv, oil) models a vessel requesting auv to take a sample of oil. The sample
is a node nested inside auv with a name oilSample. The term HOST in the rule is replaced
by the host of the bigActor, which must be of kind Vessel.
Figure 4.20 presents a set of abstract BRRs modelling Re. The rule CONNECT TO(link, x)
models a link x being connected to link. The rule DISCONNECT FROM(link, x) is the dual
of the rule CONNECT TO(link, x). The rule NEW OIL(oil, loc) models a new node of kind
Loc named oil being generated inside the node loc. The rule NEW TANKER(tanker, loc) is
similar to NEW OIL(oil, loc) excepts that it generates a new node of kind Tanker named
tanker.
Mission speciﬁcation
The bigActor provided in Figure 4.21 speciﬁes the oil-spill monitoring mission. The bi-
gActor is hosted at emsaHQ. It starts by requestion an observation with query LINKED TO(HOST).
This observation models the operator at EMSA accessing which resources, i.e., UAVs and

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
74
MOVE_HOST_TO(loc)
DEPLOY(auv)
HOST
loc
0
1
loc
HOST
0
1
HOST
auv
HOST
auv
SAMPLE(auv,oil)
HOST
auv
oil
HOST
auv
oil
oilSample
COLLECT(auv)
HOST
auv
HOST
auv
Figure 4.19: Abstract BRRs modelling the set of control actions.
NEW_TANKER(tanker,loc)
loc
loc
tanker
CONNECT_TO(link,x)
link
link
NEW_OIL(oil,loc)
loc
loc
oil
DISCONNECT_FROM(link,x)
link
link
x
x
Figure 4.20: Abstract BRRs modelling the set of environment actions.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
75
BigActor hosted_at "emsaHQ" with_behavior{
observe(LINKED_TO(HOST))
react{
case obs =>
val uavs = obs.filter(isUav)
val vessels = obs.filter(isVessel)
if(!uavs.isEmpty & !vessels.isEmpty){
BigActor hosted_at uavs[0] with_behavior track_oilSpills(vessels[0])
BigActor hosted_at uavs[0] with_behavior ais_receiver(this)
val log = new MutableList[Any]
loop{
react{
case msg => log += msg
}
}
}
else log.error("Not enough resources.")
}
}
Figure 4.21: BigActor specifying the oil-spill monitoring mission.
vessels, she has available. When the observation arrives, it is assigned to the local variable
obs. obs is ﬁltered in order to select the available UAVs and vessels. In case obs does
not contain at least one UAV and one vessel, the bigActor returns an error. Otherwise it
selects the ﬁrst UAV and vessel to perform the mission. Next, two bigActors are created,
both hosted at the ﬁrst UAV from the list of observed UAVs. The ﬁrst bigActor has a be-
havior speciﬁed by the function track oilSpills described at Figure 4.22. The behavior
track oilSpills takes as argument a bigraph node denoting the vessel selected to perform
the mission. It requests the host of the bigActor, i.e., the UAV, to move to the location
named searchArea.
Then, in a loop, the bigActor performs an observation with query
CHILDREN(PARENT(HOST)). Observations are bounded to the variable obs. For each oil-spill
found in obs, the bigActor requests a control action to move its host to the location of the
oil-spill. Next, it creates a new bigActor hosted at vessel with behavior speciﬁed by the
function sample spill described at Figure 4.23. The behavior sample spill performs an
observation in order to ﬁnd which AUVs are inside the vessel. If there is at least an AUV,
the bigActor takes the ﬁrst one, requests to deploy it, sample the oil-spill, and collects it
back. Otherwise, the bigActor returns an error.
The other bigActor spawned by the bigActor described in Figure 4.21 is hosted at the
UAV with behavior speciﬁed by the function ais receiver described at Figure 4.24. This
bigActor models the AIS receiver. It observes in a loop the connectivity of its host using
the query LINKED TO(HOST) and, in case the observation contains any tanker, sends the
observation to the bigActor address rcv passed as argument. Note that in the bigActor of

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
76
def track_oilSpills(vessel: BigraphNode) = {
control(MOVE_HOST_TO(searchArea))
loop{
observe(CHILDREN(PARENT(HOST)))
react{
case obs =>
val spills = obs.filter(isOilSpill)
spills.foreach{spill =>
control(MOVE_HOST_TO(spill))
BigActor hosted_at vessel with_behavior sample_spill(spill)
}
}
}
}
Figure 4.22: Deﬁnition of track oilSpills.
def sample_spill(spill: BigraphNode) = {
observe(CHILDREN(PARENT(HOST)))
react{
case obs =>
val auvs = obs.filter(isAUV)
if (!auv.isEmpty){
control(DEPLOY(auv[0]))
control(SAMPLE(spill))
control(COLLECT(auv[0]))
}
else log.error("Not enough resources.")
}
}
Figure 4.23: Deﬁnition of sample spill.
Figure 4.21, the argument rcv is assigned to the bigActor that originates the mission. This
bigActor receives all messages and logs them in a logger named log.
Figure 4.25 depicts the timeline for an execution of this bigActor system. On the left-
hand side of Figure 4.25 one can see the timelines for the four bigActors created throughout
the execution plus the timeline of the BigActor Schdeduler and the Bigraph Driver. On
the right-hand side we depict the bigraphical execution. Time ﬂows downward. We explic-
itly represent all interactions using arrows labelled with the messages exchanged between
bigActors, BigActor Scheduler, and Bigraph Manager. In order to make the diagram less
cluttered we use diﬀerent colors for the interactions of each bigActor. The only action from
the environment in this particular example is the ais connection established between uav0

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
77
def ais_receiver(rcv: BigActor) = {
loop{
observe(LINKED_TO(HOST))
react{
case obs =>
val tankers = obs.filter(isTanker)
if(!tankers.isEmpty)
rcv ! tankers
}
}
}
Figure 4.24: Deﬁnition of ais receiver.
and tanker0. For the sake of space we do not explicitly show this interaction in the diagram.
4.6
Final remarks
In this chapter we present an implementation of the BigActor model introduced in Chap-
ter 3. The BigActor Programming Language (BAL) is a spatial programming language,
where programs and written as actors [2], while the space is described as bigraphs [3].
BAL is developed as a Embedded DSL over the Scala Programming Language. Scala is a
function/object-oriented language that provides actors as its main concurrency model. It is
also a language with constructs that eases the development of Embedded DSLs.
In BAL, a programmer can specify bigActors that can perform the regular actor com-
mands, i.e., send messages asynchronously to another bigActor and spawn new bigActors.
Additionally, a bigActor can interact with the spatial environment modelled as a bigraph by
requesting local observations and control actions.
Space is modelled symbolically as bigraphs. Any physical entity modelled as a bigraph
node, e.g., a vehicle or a sensor, is treated logically as a location. Thus, by performing spatial
observations, a bigActor can observe which vehicles and sensors are available and use them
to instantiate new bigActors. This technique is used in the bigActor depicted in Figure 4.21
in order to select a UAV and a vessel to perform the oil-spill mission.
The query language is extended to query not only the bigraph but also the hosting rela-
tion. For example, a bigActor to query for other bigActor names hosted at speciﬁc locations.
This provides means to model clusters of bigActors. Consider the command broadcast de-
ﬁned in Figure 4.26. This command uses a query HOSTED AT(LINKED TO(HOST)) to send
a message to all the nodes linked to the host of the bigActor executing the command. In
the pure actor model, an actor can only know the address of another actor by exchanging
messages. A broadcasting command using pure actors would require the programmer to
handle the propagation of address information throughout the actor system.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
78
BigActor hosted_at emsaHQ
BigActorSchdl
BigraphManager
HOSTING_REQUEST(emsaHQ)
HOSTING_SUCCESSFUL
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
OBSERVATION_REQUEST(LINKED_TO(HOST))
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
obs
BigActor hosted_at uav0
BigActor hosted_at uav0
HOSTING_REQUEST(uav0)
HOSTING_SUCCESSFUL
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
HOSTING_REQUEST(uav0)
HOSTING_SUCCESSFUL
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
CONTROL_REQUEST(MOVE_HOST_TO(searchArea))
EXECUTE_BRR
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
OBSERVATION_REQUEST(CHILDREN(PARENT(HOST)))
obs
CONTROL_REQUEST(MOVE_HOST_TO(spill0))
EXECUTE_BRR
BigActor hosted_at vessel0
HOSTING_REQUEST(vessel0)
HOSTING_SUCCESSFUL
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
EXECUTE_BRR
CONTROL_REQUEST(MOVE_HOST_TO(searchArea))
EXECUTE_BRR
CONTROL_REQUEST(DEPLOY(auv0))
EXECUTE_BRR
CONTROL_REQUEST(SAMPLE(auv0,spill0))
EXECUTE_BRR
CONTROL_REQUEST(COLLECT(auv0))
BIGRAPH_REQUEST
BIGRAPH_RESPONSE
OBSERVATION_REQUEST(LINKED_TO(HOST))
obs
tankers
EXECUTE_BRR
CONTROL_REQUEST(MOVE_HOST_TO(shore))
MOVE_HOST_TO(searchArea)
MOVE_HOST_TO(spill0)
MOVE_HOST_TO(searchArea)
DEPLOY(auv0)
SAMPLE(auv0,spill0)
COLLECT(auv0)
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
tanker0
spill0
ais0
uav0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
tanker0
spill0
ais0
uav0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
uav0
ais0
vessel0
auv0
a0
tanker0
spill0
ais2
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
uav0
tanker0
spill0
ais0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
tanker0
spill0
ais0
uav0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
tanker0
spill0
sample0
ais0
uav0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
tanker0
spill0
sample0
ais0
uav0
shore
searchArea
airField
uav1
vessel1
3G
emsaHQ
auv1
a1
ais1
ais2
vessel0
auv0
a0
tanker0
spill0
sample0
ais0
uav0
MOVE_HOST_TO(shore)
Figure 4.25: Timeline for an exectuion of the BigActor system that speciﬁes the oil-spill
monitoring example.

CHAPTER 4. BIGACTOR PROGRAMMING LANGUAGE
79
def broadcast(msg: Any) = {
observe(HOSTED_AT(LINKED_TO(HOST)))
react{
case obs =>
obs.foreach{b =>
b ! msg
}
}
}
Figure 4.26: Deﬁnition of broadcast command that broadcasts a message to all bigActors
hosted at nodes linked to the host of the bigActors executing the command.
Querying the hosting relation also provides a way of observing if a bigActor is still alive.
For example, a bigActor may stop because of a machine failure. One can deﬁne a supervisory
bigActor that persistently observes the hosting relation and spawn new bigActors at run-time
whenever a given bigActor dies.
The evolution of the bigraph as a spatial model is made in discrete, event-driven time.
Time advances due to the execution of BRRs. One could beneﬁt from real-time abstractions
in order to specify actions that would only happen at a speciﬁc time, e.g., search a given area
for oil-spill during 2 hours. This can be achieved by extending the bigActor semantics with
time constraints in similar way that the actor model is extended by Nielsen and Agha [61].
Combining the bigActor model with a new model of time follows Milner’s view of “Tower of
Models” [20] where diﬀerent models of computation are combined semantically. Nonetheless,
this extension is not in the scope of this dissertation and remains as future work.

80
Part II
Bridging logical and physical
machines

81
Chapter 5
Logical-Space Computing
5.1
Introduction
Computation is becoming ubiquitously and spatially embedded in our environment. Mo-
bile cyber-physical systems such as smartphones and robots are equipped with sensors and
actuators that observe and manipulate their spatial environment. This kind of computation
that exhibits a behavior in space is commonly known as spatial computing [12]. In this thesis
we call spatial programming to the practice of specifying spatial computing behaviours and
spatial programming language to any infrastructure or framework that provides means for
spatial programming.
Arguably, the common practice of spatial programming is to deﬁne the behavior of en-
tities in a geometrical coordinate system, such as GPS coordinates and indoor local coordi-
nates [72]. Geometrical coordinates result from a direct measure of physical properties, e.g., a
GPS location, commonly known as latitude and longitude, is deﬁned as the angular distance
from, respectively, the equator and the Greenwich meridian. Thus, we call physical-space
programming to the practice of programming using geometrical coordinates.
Example 5.1. Consider the example of an Unmanned Aerial Vehicle (UAV) collecting im-
agery of an oil-spill due to a suspicious illegal bilge dumping activity by an oil tanker. The
exact location of the oil-spill is unknown a priori, although, due to Automatic Identiﬁcation
System (AIS) information collected from the tanker, it is known to be within a given rectan-
gular area parametrized by its North-East and South-West GPS locations, (37.04, −8.59) and
(36.94, −8.79). The UAV operator performs the following steps: select an UAV to perform
the mission; specify a searching pattern comprised by the sequence of GPS locations to be
visited inside the suspected area; as soon as the operator gets the information of the oil-spill
location by some source, specify a new location to be visited. The mission is speciﬁed as a
sequence of waypoints using a given format such as the Waypoint File Format (WFF) of the
Mavlink Waypoint Protocol (MWP) [73]. Figure 5.1 depicts the physical-space execution of
this example.

CHAPTER 5. LOGICAL-SPACE COMPUTING
82
→
→
→
Figure 5.1: Physical-space execution for Example 5.1.
Programming over physical-space gives the programmer with a large expressiveness over
the spatial behavior. The UAV operator of Example 5.1 can send the UAV to any GPS
location that UAV is physically capable of executing. This large expressiveness puts the
responsibility for the correct speciﬁcation of spatial behaviors in the hands of the program-
mer. For example, a simple mistake in the speciﬁcation of the GPS coordinates of the UAV
waypoints can lead to a completely unexpected behavior. Physical-space models also do not
model explicitly relations between spaces. For example, it would be important for the UAV
operator to know if the UAV is at the search area without the need to perform any further
calculations.
The literature presents several programming models that approaches spatial computing
from a physical level, such as Amorphous Computing [74], Spatial Programming [44], and
the framework Gaia [46].
Another common approach on spatial computing is to model space symbolically, where
locations are deﬁned as symbols and explicit relations over those symbols [72]. An everyday
example of a symbolic location model is a mailing address system, which speciﬁes locations
using house numbering, street names, city names, and postal codes. Mailing address systems
provide an explicit containment relation between locations For example, the US Postal ad-
dress “920 Grizzly Peak Boulevard, Berkeley, CA” tells us that the house denoted by “920”
is physically at the street named “Grizzly Peak Boulevard” which is physically located in
the city of “Berkeley” and physically contained by the state of “CA”.
In contrast to physical-space programming, we call symbolic-space programming to the
practice of programming using symbolic-space models. One of the pioneer symbolic-space
programming models is the Ambient Calculus by Luca Cardelli [18]. A mobile ambient is a
computing entity that can only compute at bounded locations and is allowed to communicate
to other mobile ambients that share its location. In Ambient Calculus locations form a tree-
like structure.
Robin Milner introduced the Bigraphical model [3] that combines a nested location model
with a model of connectivity. With Bigraphs, Milner combines the tree-like location model of
the Ambient Calculus with the dynamic connectivity that he introduced in the π−calculus.
A bigraph changes to another bigraph upon the application of a Bigraph Reaction Rule
(BRR).
Example 5.2. Recall the Example 5.1. Figure 5.2 shows a symbolic-space execution for the
oil-spill monitoring mission using bigraphs. The execution results from the application of

CHAPTER 5. LOGICAL-SPACE COMPUTING
83
→
→
→
Figure 5.2: Symbolical-space execution for Example 5.1.
the BRRs given by Figure 5.3.
Figure 5.3: BRRs that generates the symbolic-space execution depicted in Figue 5.2.
Symbolical-space programming provides an abstract spatial model with explicit relations
between locations. These models are in general convenient for specifying and formally ver-
ifying high-level spatial behaviours. However, they are oblivious to information from the
physical space, which is necessary to specify the behaviour of the physical machines. For
example, a conventional autopilot that equips a UAV requests waypoints to be deﬁned by
their GPS coordinates. Physical time is also not considered in a logical-space model. For
example, in a symbolic model, the action of moving an UAV from its current location to
another location is executed as soon as it is requested. In reality, this control action does not
execute instantaneously. It might not even execute at all due to some adversarial condition
from the environment.
To overcome the lack of physical information on symbolic space models, one can ﬁnd in the
literature symbolic models that are augmented with physical information. These models are
commonly known as hybrid location models. Jiang and Steenkiste [75] introduce Aura Loca-
tion Identiﬁers (ALI) that combine hierarchical symbolic locations with physical coordinates.
Recall the the Example 5.1. The UAV location when it is over the oil-spill can be speciﬁed

CHAPTER 5. LOGICAL-SPACE COMPUTING
84
as the following Aura Location Identiﬁer:
ali://sea/searchArea/oilSpill#(36.99,-8.69).
Hybrid-space models provide means for synthesizing control actions that can be deployed in
the physical machines. However, the programmer is now in charge of handling both physical
and symbolic information and can introduce inconsistencies between logical and physical
model. For example, the ALI
ali://sea/searchArea/oilSpill#(36.99,-8.69)is inconsis-
tent if the physical location of the oil-spill does not contain the GPS location (36.99, −8.69).
In this chapter we introduce logical-space computing. In logical space computing, the
programmer manipulates a symbolical abstraction of the world, named the logical-space
model, while the runtime system is in charge of manipulating a physical abstraction of the
world, named the physical-space model. Both abstractions are loosely coupled by the logical-
space semantics, which provides an asynchronous semantics for the execution of control
actions and for the observation of the structure.
The remainder of this chapter goes as follows. We provide deﬁne physical spaces, and
logical spaces, and introduce a mathematical formalism to bind these two models together
called spatial structures. Next we introduce the formal semantics of logical-space computing
as spatial agents that operate over spatial structures. Spatial agents are embedded in the
logical model and are able to observe and request control actions. The logical-space com-
puting semantics speciﬁes the interactions with the physical model. We proceed by showing
how the BigActor model [1] can be used for logical-space programming and we conclude with
an analysis of the correctness of logical-space behaviours.
5.2
Spatial Structures
We deﬁne a logical model as a set of logical places, i.e., symbols, and a set of relations
between logical places, e.g., parenting relation.
Deﬁnition 5.1 (Logical-space model). A logical-space model L is an algebraic structure
with domain dom(L) denoting a set of symbolic locations (names) and nL relations σL =
(relL
0 , relL
1 , . . . , relL
nL−1), where relL
i is a symbol denoting a relation over dom(L) with arity
provided by arL : σL →N1.
A physical model is deﬁned similarly. A physical model has a set of physical places, e.g.,
a set of polygons deﬁned using some geometrical coordinates, and a set of relations between
physical places, e.g., containment relation of polygons.
Deﬁnition 5.2 (Physical-space model). A physical-space model P is a mathematical struc-
ture with domain dom(P) denoting a set of physical locations, e.g. polygons deﬁned using
GPS coordinates, and nP relations σP = (relP
0 , relP
1 , . . . , relP
nP −1) where relP
i is a relation
over dom(P) with arity provided by arP : σP →N.
1For convenience of notation we overload the relation symbols relL
i to also denote their interpretation.

CHAPTER 5. LOGICAL-SPACE COMPUTING
85
A spatial structure binds these two abstractions together using two maps: an interpreta-
tion of logical locations in physical locations, e.g., the logical name “Berkeley” is physically
interpreted as the polygon that deﬁnes the city limits, and an interpretation of logical rela-
tions in physical relations, e.g., the relation between “Berkeley” and “California” is physically
interpreted as the the containment relation between the two polygons that deﬁne both the
city and the state.
Deﬁnition 5.3 (Spatial structure). A spatial structure is a tuple (L, P, β) where:
1. L is a logical-space model,
2. P is a physical-space model,
3. β : dom(L) ,→dom(P)2 is the physical interpretation of logical locations, and
4. for each logical relation relL
i deﬁned in σL there is a corresponding physical relation
relP
i deﬁned in σP, i.e., there is a one-to-one correspondence between logical relations
and physical relations.
5.3
Bigraphs and Polygons
Consider a spatial structure (B, P, β), where B is a bigraph and P is a physical model
composed of polygons and relations over polygons. he domain of B is a set of bigraph nodes
and a set of link names and σB = (parentB, linkingB)3. The relation parent deﬁnes the
placing structure of a bigraph as a tree, i.e., (n′, n) ∈parentB means that n′ is the parent of
n where both n and n′ are bigraph nodes. The relation linking deﬁnes the linking structure
as an hypergraph, i.e., (link, n0, n1, . . . , nj) ∈linking means that the bigraph nodes n0, n1,
. . ., nj are connected through a link named link. Note that the link names must be included
in the domain of the logical-space model. This is necessary since link names are part of
bigraph support. Starting with π−calculus [17] and later with Bigraphs [3] treat channels
and links as means of mobility. As such, they are treated abstractly as logical locations. See
Section 2.1 and [17, 3] for further details.
The domain of P is a set of polygons and physical connections deﬁned as dom(P) =
{β(n) | n ∈dom(B), β(n) is deﬁned} and σP = (parentP, linkingP). Physical locations are
deﬁned as tuples (name, poly) where the ﬁrst element of the tuple is a unique name4 and the
second element is a sequence of geometrically deﬁned coordinates deﬁning a polygon. We
also admit polygons with only one coordinate, i.e., a point.
The relation parentP is the physical counterpart of the bigraph parenting relation denoted
as parentB, while linkingP is the physical counterpart of the bigraph linking relation denoted
2The notation f : A ,→B denotes a partial function f with domain A and co-domain B.
3The original deﬁnition of Bigraphs by Milner [3] formalizes the parenting and connectivity of nodes
using functions. For the sake of a more general approach we treat the parenting and linking as relations.
4For the sake of convenience, we assume that polygons take the same named as their logical counterparts.

CHAPTER 5. LOGICAL-SPACE COMPUTING
86
as linkingB. In order to cope with Milner’s bigraph deﬁnition we must enforce that the
resulting parenting relation forms a tree. This limitation can be removed by using Sevegnani’s
Bigraphs with Sharing [76] but this is outside the scope of this thesis. Thus, the physical
counterpart of the parenting relation must also form trees. A polygon can not be partially
contained on another polygon, otherwise, the resulting parenting relation may form a cycle.
Example 5.3. Figure 5.4 shows an example of a spatial structure using bigraphs and poly-
gons as, respectively, logical and physical space models. There are three polygons denoted in
seearchArea0
oilSpill0
shore
uav0
Figure 5.4: Logical space and physical space.
Figure 5.4, i.e., (searchArea0, ((37.04, −8.59), (37.04, −8.79), (36.94, −8.79), (36.94, −8.59))),
(shore, ((37.17, −8.61), (37.17, −8.56), (37.11, −8.56), (37.11, −8.61))), and (uav0, (36.97, −8.64)).
We allow the physical interpretation β to be a partial function, i.e., there might exist
some l ∈dom(l) where β(l) is undeﬁned. This design decision has an important practical
implication. One can model logical locations that get their physical interpretation later in
the execution or that are purely logical and do not have a physical interpretation at all.
Example 5.4. Recall the Example 5.1. Consider that the logical location oilSpill0 is
known to be contained by searchArea0 but its physical location is initially unknown. During
the execution, sensors equipping the UAV detect and georeference the oil-spill, providing
a physical interpretation to oilSpill0. Figure 5.5 shows the logical-space execution for
Example 5.1. The physical interpretation of the execution depicted in Figure 5.5 is provided
in Table 5.1.
The names of physical locations remain invariant during execution while the physical
relations may change over time. For example, uav0 is physically contained by shore in the

CHAPTER 5. LOGICAL-SPACE COMPUTING
87
β0
y
→
β1
y
→
β2
y
→
β3
y
→
→
→
Figure 5.5: Logical-space execution for Example 5.1.
ﬁrst step of the execution depicted by Figure 5.5, i.e., (uav0, shore) ∈parentP, but this is
false for the remaining steps.
Note that oilSpill0 does not have a physical interpretation in the beginning of the exe-
cution, i.e., β0(oilSpill0) is undeﬁned. Nonetheless, the parent of oilSpill0, searchArea0,
has a physical interpretation β0(searchArea0). Thus, there is enough physical information
to generate a searching pattern inside the polygon of the corresponding physical interpre-
tation of searchArea0.
Later, when oilSpill0 acquires a physical interpretation, i.e.,
β2(searchArea0), one can specify a new waypoint inside the respective polygon. This iter-
ative execution using the parenting relation between logical locations is later formalized in
Section 5.5.
The linking graph of bigraphs can be used for deﬁning diﬀerent kinds of connectivity
between entities, e.g., communication links and physical adjacency. We primarily use the
linking graph to model the communication infrastructure between physical computing enti-
ties. The linking graph is deﬁned as a hypergraph, i.e., each link can have an zero or more
nodes. In concrete bigraphs, links are named by a support. Let N be the set of link names.
In order to incorporate the support in our logical model we assume that the link names are
locations, i.e., N ⊂dom(L). Without lost of generality, the linking graph is modelled by
the binary relation linkingL ⊆N × (dom(L) \ N). For example, consider two hyperlinks
named wlan0, and lan0 where wlan0 connects smartphone0, tablet0, and lan0 connects
pc0. Then, linkingL = {(wlan0, smartphone0), (wlan0, tablet0), (lan0, pc0)}. The physi-
cal counterpart is named linkingP.
Example 5.5. UAVs are often controlled by more than one Control Station (CS) in the
same mission. For example, an UAV can get under the control authority of a CS installed
in a vessel in order to improve its range. The manoeuvre of changing control authority of
an UAV from one CS to another is known as handover. For UAVs equipped with Piccolo
autopilots [77], the handover manoeuvre goes as follows. Consider that an UAV is under the

CHAPTER 5. LOGICAL-SPACE COMPUTING
88
t0
t1
t2
t3
oilSpill0
-
-
(oilSpill0,
((36.99, −8.63),
(36.98, −8.60),
. . . ,
(36.99, −8.67)))
(oilSpill0,
((36.99, −8.63),
(36.98, −8.60),
. . . ,
(36.99, −8.67)))
searchArea0
(searchArea0,
((37.04, −8.59),
(37.04, −8.79),
(36.94, −8.79),
(36.94, −8.59)))
(searchArea0,
((37.04, −8.59),
(37.04, −8.79),
(36.94, −8.79),
(36.94, −8.59)))
(searchArea0,
((37.04, −8.59),
(37.04, −8.79),
(36.94, −8.79),
(36.94, −8.59)))
(searchArea0,
((37.04, −8.59),
(37.04, −8.79),
(36.94, −8.79),
(36.94, −8.59)))
shore
(shore,
((37.17, −8.61),
(37.17, −8.56),
(37.11, −8.56),
(37.11, −8.61)))
(shore,
((37.17, −8.61),
(37.17, −8.56),
(37.11, −8.56),
(37.11, −8.61)))
(shore,
((37.17, −8.61),
(37.17, −8.56),
(37.11, −8.56),
(37.11, −8.61)))
(shore,
((37.17, −8.61),
(37.17, −8.56),
(37.11, −8.56),
(37.11, −8.61)))
uav0
(uav0,
(37.15, −8.58))
(uav0,
(37.01, −8.62))
(uav0,
(37.01, −8.62))
(uav0,
(36.97, −8.64))
Table 5.1: Physical interpretation for the logical-space execution depicted by Figure 5.5
control authority of Alice at CS A using the communication channel 0. Alice wants to hand
the control authority to Bob at CS B onboard of a navy vessel.
1. Bob sets CS B to listen to channel 1 and reports by radio to Alice that he is ready for
handover.
2. Alice at CS A changes the UAV communication channel from channel 0 to channel 1.
At this point, Alice looses communication with the UAV.
3. As soon as the UAV establishes communication with CS B, Bob assumes control au-
thority and declares a successful handover to Alice, which turns oﬀhis communication
link
4. If the communication is not established before a given timeout, the UAV changes
automatically its channel back to 0 and returns to control authority of Alice.
We consider ﬁve logical locations, i.e., shore, uav0, searchArea0, csA, and csB. The logical
locations are interpreted in polygons just as per Example 5.4.
We consider two logical
connections named ch0 and ch1 that are interpreted in two physical communication channels
(channel0 and channel1) of the Piccolo communication protocol.
The logical-space execution is depicted in Figure 5.6. We physically depict the communi-

CHAPTER 5. LOGICAL-SPACE COMPUTING
89
csA
csB
ch0
ch1
Channel 0
csA
csB
ch0
ch1
Channel 0
csA
csB
ch0
ch1
Channel 0
Channel 1
Channel 1
csA
csB
ch0
ch1
Channel 0
Channel 1
Figure 5.6: Logical-space execution for Example 5.5.
cation channels by a circle surrounding the respective CS. The UAV is depicted as a triangle
and assumes the color of the communication channel in use, or black if no communication link
is established. Note that ch1 does not have initially a physical interpretation. Nonetheless,
it is known that Bob uses this channel and, as such, there is a logical link between csB and
ch1. As soon as Bob turns channel1 on, ch1 becomes physically interpreted. When Alice
changes the UAV to channel1, even though she looses communication, the UAV remains
logically under her command since if the manoeuvre fails, the UAV returns to channel0. As
such, the connectivity of uav0 in the logical model only changes to ch1 when the manoeuvre
is succeeded.
5.4
Consistency of spatial structures
A spatial structure establishes a map between a logical model and a physical model.
Consistency is a property about the correctness of this map.
Deﬁnition 5.4 (Consistency). A spatial structure (L, P, β) is consistent if for each relation
relL
i deﬁned in σL:
∀(l0, . . . , ln−1) ∈relL
i .p0 = β(l0) ∧. . . ∧pn−1 = β(ln−1) ⇒(p0, . . . , pn−1) ∈relP
i
(5.1)
where n = arL(reli). In other words, a structure (L, P, β) is consistent if the map β between
logical locations and physical locations preserves the relations.
Note that if a given logical location does not have a physical interpretation then consis-
tency is vacuously true.
Example 5.6. Figure 5.7 depicts an inconsistent structure. Note that the parent of uav0
in the logical model is shore while at the physical level, the physical interpretation of uav0
is contained by the physical interpretation of searchArea0.

CHAPTER 5. LOGICAL-SPACE COMPUTING
90
seearchArea0
oilSpill0
shore
uav0
Figure 5.7: Inconsistent structure.
Consistency is a strong property for spatial structures. However, it can be expensive to
ensure since it requires checking the physical interpretation of the overall logical model. It
is often suﬃcient to check if a structure is locally consistent with respect to a given region
of interest of the logical model.
In order to deﬁne local consistency one must ﬁrst deﬁne what it means for a logical model
to be contained by another.
Deﬁnition 5.5 (Logical containment). We deﬁne the logical containment as a binary relation
over logical-space models and denote it by ⊆L. Let L and L′ be two logical-space models.
L ⊆L L′ iﬀdom(L) ⊆dom(L′) and ∀i.(l0, l1, . . . , ln−1) ∈relL
i ⇒(l0, l1, . . . , ln−1) ∈relL′
i .
We deﬁne a similar relation ⊆P for physical spaces.
Deﬁnition 5.6 (Physical containment). We deﬁne the physical containment as a binary
relation over physical-space models and denote it by ⊆P. Let P and P ′ be two logical-space
models. P ⊆P P ′ iﬀdom(P) ⊆dom(P ′) and ∀i.(l0, l1, . . . , ln−1) ∈relP
i ⇒(l0, l1, . . . , ln−1) ∈
relP ′
i .
Deﬁnition 5.7 (Local Consistency). Let S = (L, P, β) be a spatial structure. S is locally
consistent with respect to L′ if L′ ⊆L L and (L′, P, β) is consistent.
Local consistency is a weaker property that is necessary and suﬃcient for a sound logical
space computation. Next we deﬁne the semantics of logical-space computing and formally
prove this statement.

CHAPTER 5. LOGICAL-SPACE COMPUTING
91
5.5
Logical-Space Computing Semantics
We formalize logical-space computing semantics as a set of spatial agents that operate
over a spatial structure. Spatial agents are computing entities with local state and local
behavior. Their deﬁnition follows the same notation of Actors and BigActors introduced in
Chapter 3.
Deﬁnition 5.8 (Spatial Agent). A spatial agent is a computing entity denoted as [E ⊢b]a
where a is a unique identiﬁer, E is the local state, and b is the local behavior. The behaviour
of the agent is speciﬁed by some host language enriched with syntax and semantics for spatial
interaction. The syntax is deﬁned by the following grammar:
b := exp(; exp)∗
exp := f|observe(q)|react(x)|control(r)
where f denotes the core syntax of a given host language, q is a query in some query language
Q, x is a local variable over the set of variables X, r ∈L×L is a spatial reaction rule denoted
as R ⇒R′ where R is a logical-model called the redex and R′ is a logical-model called the
reactum. The application of R ⇒R′ over a model L replaces R with R′ if R ⊆L L5 producing
a new model L′ where R′ ⊆L L′.
In other words, the behavior of a spatial agent is a sequence of commands of the kind:
• f denotes abstractly any internal computation performed by a given host language
• observe(q) requests an observation of the logical model speciﬁed by a query q.
• react(x) assigns to a local variable x the value of a requested observation.
• control(r) requests the execution of a control action over the logical model speciﬁed
by a spatial reaction rule r = R ⇒R′.
The purpose of the grammar is to introduce syntactic means to deﬁne the semantics of spatial
agents. The behavior of spatial agents can be speciﬁed by diﬀerent kinds of host languages
with their own syntactic constructs. In this dissertation, we use Scala as the host language
enriched with the BigActors commands described in Chapter 4.
The logical-space computing semantics is modelled as a transition system over spatial-
computing conﬁgurations.
Deﬁnition 5.9 (Spatial Computing Conﬁguration). A conﬁguration is a tuple ⟨α | S | η⟩
where:
• α is a ﬁnite set of spatial agents,
5Spatial reaction rules is an adaptation of the Bigraph Reaction Rule introduced by Milner [3] to logical-
space models.

CHAPTER 5. LOGICAL-SPACE COMPUTING
92
• S is a spatial structure, and
• η is a ﬁnite set of requests.
The requests in η are of the following kind:
• OBS(a, q) is a request from agent a ∈α for an observation speciﬁed by the query q ∈Q
• READY(a, obs) is a pending observation to be delivered to a ∈α where obs ∈L is a
logical-space model resulting from an observation
• CTR(a, R ⇒R′) is a control request from a ∈α speciﬁed by the spatial reaction rule
R ⇒R′ ∈L × L
The logical-space computing semantics is modeled abstractly in order to ﬁt diﬀerent log-
ical and physical models. The semantics is written in an operational style, largely inﬂuenced
by [2, 78, 1]. It is formalized as a transition system over the space of spatial-computing
conﬁgurations, speciﬁed by seven inference rules.
Computation
The rule denoted as ⟨fun : a⟩models an internal computation performed by agent a,
i.e., the change of the local state of a speciﬁed by the semantics of a given programming
language.
⟨fun : a⟩
E ⊢f; b →λ E′ ⊢b
⟨α, [E ⊢f; b]a | S | η⟩→⟨α, [E′ ⊢b]a | S | η⟩
(5.2)
Observation
There are three rules for modelling observations.
⟨req obs : a, observe(q)⟩
⟨α, [E ⊢observe(q); b]a | S | η⟩→⟨α, [E ⊢b]a | S | η, OBS(a, q)⟩
(5.3)
⟨sense : OBS(a, q)⟩
(Lq, Pq, βq) = [[q]](L, P, β)
Lq ⊆L L′
⟨α | (L, P, β) | η, OBS(a, q)⟩→⟨α | (L′, P, β′) | η, READY(a, Lq)⟩
(5.4)
where β′(l) =
(
βq(l)
l ∈dom(Lq)
β(l)
l ∈dom(L) ∧l ̸∈dom(Lq)
(5.5)

CHAPTER 5. LOGICAL-SPACE COMPUTING
93
⟨rcv obs : a, react(x)⟩
E′ = E[x/obs]
⟨α, [E ⊢react(x); b]a | S | η, READY(a, obs)⟩→⟨α, [E′ ⊢b]a | S | η⟩
(5.6)
Rule ⟨req obs : a, observe(q)⟩models an agent a requesting an observation deﬁned by
query q of the logic-space model. The request is deﬁned as OBS(a, q) and it is stored in the
set of pending requests η. Rule ⟨sense : OBS(a, q)⟩models the runtime system taking an
observation request OBS(a, q) from the set of pending requests, interpreting the query over
the physical structure, and generating a new logical abstraction Lq.
Deﬁnition 5.10 (Query interpretation). The function [[·]] : Q × S →S takes a query,
a spatial structure, and returns a spatial structure. We denote (Lq, Pq, βq) = [[q]](L, P, β)
for a query q interpreted over the structure (L, P, β).
Lq is the logical model resulting
from interpreting the query q over L and P, and βq : dom(Lq) ,→dom(Pq) is the physical
interpretation of Lq over Pq.
For the sake of a more readable notation we overload the
notation of (Lq, ∅P, ∅β) = [[q]](L, ∅P, ∅β) to Lq = [[q]](L), where ∅P denotes the empty physical-
space model, while ∅β denotes the empty β function. In addition, we require that:
• (Lq, Pq, βq) is consistent,
• Pq ⊆P P, i.e., querying does not introduce new physical locations, and
• ∀Lq.∃q.Lq = [[q]](Lq), i.e., in the absence of a physical model and for any logical model,
there exists a query that returns the overall logical model
(Lq, Pq, βq) = [[q]](L, P, β) provides the logical abstraction Lq interpreting q over L and
P. The query returns a consistent structure (Lq, Pq, βq). Since (L, P, β) can be inconsistent,
the query interpretation returns a new physical interpretation βq : dom(Lq) ,→dom(Pq) that
is required to make Lq and Pq consistent. A query interpretation does not introduce new
physical locations. Hence, Pq ⊆P P. At last, we require that, in the absence of a physical
model, for each logical model, there exists a query that returns the overall model.
The physical interpretation β is updated to β′ in order to include the new physical
interpretations βq. For example, consider that the logical location oilSpill0 is known to be
at searchArea0 but at an unknown physical location. After performing a query, the query
interpreted ﬁnds a physical interpretation for oilSpill0 in P, e.g., an UAV was able to
physically detect and geo-reference the oil-spill and provided that information in P.
Note that the rule ⟨sense : OBS(a, q)⟩requests that Lq ⊆L L′. In other words, the logical-
space model L must be updated to L′ in order to contain the freshly observed logical-space
model Lq.
The result is stored in the set of pending requests as READY(a, Lq). This rule is responsible
for the keeping the logical model and the physical model locally consistent with respect to
the observed space, i.e., if two observed physical locations are related, then their logical
counterparts are also related. Local consistency is ensured by changing L to L′ and β to

CHAPTER 5. LOGICAL-SPACE COMPUTING
94
β′. Rule ⟨rcv obs : a, react(x)⟩delivers an observation READY(a, Lq) to a by assigning Lq
to the local variable x. Note that observation is asynchronous, i.e., an agent ﬁrst requests
an observation, the runtime system gets the necessary data from sensors, and delivers the
result as soon as possible.
Control
There are two rules for modelling control actions from spatial agents and one from envi-
ronmental sources.
⟨req ctr : a, control(R ⇒R′)⟩
⟨α, [E ⊢control(R ⇒R′); b]a | S | η⟩→⟨α, [E ⊢b]a | S | η, CTR(a, R ⇒R′)⟩
(5.7)
⟨actuate : CTR(a, R ⇒R′)⟩
R ⊆L L
R′ ⊆L L′
PR ⊆P P
PR′ ⊆P P ′
⟨α | (L, P, β) | η, CTR(a, R ⇒R′)⟩→⟨α | (L′, P ′, β) | η)⟩
(5.8)
(5.9)
where PR is the canonical physical interpretation of R given by Deﬁnition 5.11.
Deﬁnition 5.11 (Canonical Physical Interpretation). Let (L, P, β) be a spatial structure.
Let R be a logical model such that R ⊆L L. PR is the canonical physical interpretation of
R iﬀ:
1. dom(PR) = {β(l) ∈dom(P) | l ∈dom(R), β(l) is deﬁned}
2. For each relR
i deﬁned in σR,
∀(l0, . . . , ln−1) ∈relR
i .p0 = β(l0) ∧. . . ∧pn−1 = β(ln−1) ⇐⇒(p0, . . . , pn−1) ∈relPR
i
In other words, PR is the physical model that includes the physical interpretations of
locations from dom(R). PR preserves the relations for locations with physical interpretation.
As such, R and PR are consistent. Note that R is allowed to have locations without physical
interpretation without aﬀecting the consistency of R and PR. The model PR′ is obtained in
the same way.
Note that the semantics allows for requesting partially physically interpreted reactive
rules. In fact, a rule is allowed to be completely logical, i.e., where all the locations in the
redex are not physically interpreted. This provides means for deﬁning logical locations that
acquire physical interpretation later in the execution, or for deﬁning pure logical locations.
Rule ⟨req ctr : a, control(R ⇒R′)⟩models an agent a requesting a control action
over the the logical structure speciﬁed by the reaction rule R ⇒R′, where R speciﬁes the

CHAPTER 5. LOGICAL-SPACE COMPUTING
95
part of the logic model to be changed and R′ speciﬁes how it is intended to be changed. The
rule generates a request CTR(a, R ⇒R′) in the set of pending requests. Rule ⟨actuate :
CTR(a, R ⇒R′)⟩models the runtime system taking a request CTR(a, R ⇒R′), checking if it
can be applied over the logical and physical space models, and executing the rule over both
models. The physical models PR and PR′ are the physical counterparts of the logical models
R and R′. The rule requests the spatial structure to be locally consistent with respect to
R and keeps the structure locally consistent with respect to R′. This is formalized later in
Section 5.6.
Note that if a single agent observes ﬁrst the space that is willing to control, locally
consistency is ensured and control action can be successfully executed. Nonetheless, in the
presence of concurrency, one must ensure that the space being controlled is by agents is free
of race-conditions. This is discussed on Section 5.6.
Environment
The eﬀects of the environment are modelled by rule ⟨env : P ′⟩, which changes the physical
model to P ′. This rule models eﬀects of the environment over the physical model. For
example, a new polygon is generated in P ′ to model an oil-spill being detected by a sensor
on board of an UAV.
⟨env : P ′⟩
⟨α | (L, P, β) | η⟩→⟨α | (L, P ′, β) | η⟩
(5.10)
Example 5.7. Figure 5.8 shows an example of a bigActor as a spatial agent that operates
over a bigraphical model of the world. The physical world is modeled as polygons deﬁned
using GPS coordinates. The bigActor speciﬁed in Figure 5.8 uses the query language deﬁned
in Chapter 2 to observe the logical-space for oil-spills and BRRs to move the UAV from its
current location to a new one. In order to understand the eﬀects of each rule of the logical-
space computing semantics we present the overall execution semantics of the logical-space
program of Figure 5.8. The sequence of conﬁgurations is given at Figure 5.9. For the sake
of a less cluttered execution we do not represent the changes in the state and behavior of
a. The analysis of the execution trace shows the asynchronous nature of both observation
and control. Note that after the step ⟨env : P ′′⟩, the oil-spill is modelled at P ′′ but not at
L′. However, the step ⟨sense : OBS(a, q)⟩changes L′ to L′′ by adding the logical location
oilSpill0 which is physically interpreted by the new polygon in P ′′.
5.6
Correctness of control actions
The execution of a logical-space program is said to be correct if control actions requested
at a logical level produce expected eﬀects at the physical level. It is of the programmer

CHAPTER 5. LOGICAL-SPACE COMPUTING
96
Figure 5.8: Spatial agent modelled as a bigActor.
Figure 5.9: Logical-space execution for the spatial agent of Figure 5.8.

CHAPTER 5. LOGICAL-SPACE COMPUTING
97
responsibility to write programs that are logically executable, i.e., to request control actions
that are feasible over the current logical model. Nonetheless, if a control action is requested
over an inconsistent structure, there are no means for ensuring that it will execute correctly,
i.e., the control action can be physically non-executable. The runtime system must provide
the programmer with means for ensuring that if a control action is logically executable then
it is also physically executable.
Deﬁnition 5.12 (Logically executable). Consider the conﬁguration ⟨α, (L, P, β), η⟩. A con-
trol request CTR(a, R ⇒R′) ∈η where a ∈α is logically executable if R ⊆L L.
Logically non-executable control requests result from badly written spatial agents, e.g.,
a requesting to move a vehicle to a location that does not exists. This is not desirable but
semantically acceptable. We do not wish to constraint the expressiveness of the language to
cope with these kind of mistakes.
Deﬁnition 5.13 (Physically executable). Consider the conﬁguration ⟨α, (L, P, β), η⟩.
A
control request CTR(a, R ⇒R′) ∈η where a ∈α is physically executable if PR ⊆P P, i.e., if
the canonical physical interpretation of R is contained in the physical model P.
Physically non-executable control requests result from inconsistencies in the spatial struc-
ture. This may occur because a spatial agent requested a control action that is logically non-
executable or because the structure became inconsistent due to an environmental action.
Conditions for physical executable control actions
In this section we analyse which conditions makes control actions physical executable.
First, we prove the following lemma that relates the logical containment ⊆L with the
physical containment ⊆P.
Lemma 5.1. Let (L, P, β) be a consistent structure. If R ⊆L L , then PR ⊆P P where PR
is the canonical physical interpretation of R using β.
Proof. Since R ⊆L L, by Deﬁnition 5.5, dom(R) ⊆dom(L).
Let PR be the canonical
interpretation of R over P.
By Deﬁnition 5.11(1.), dom(PR) = {β(l) ∈dom(P) | l ∈
dom(R), β(l) is deﬁned}. Thus, dom(PR) ⊆dom(P).
For each relPR
i , let (p0, . . . , pn−1) ∈relPR
i . By Deﬁnition 5.11(2.), ∃(l0, . . . , ln−1) ∈relR
i
where pi = β(li). Since R ⊆L L, by Deﬁnition 5.5, (l0, . . . , ln−1) ∈relL
i . Since (L, P, β) is
consistent, by Deﬁnition 5.4, (p0, . . . , pn−1) ∈relP
i . Thus, by Deﬁnition 5.6, PR ⊆P P.
Theorem 5.1. Let c = ⟨α | S | η⟩be a spatial computing conﬁguration where S = (L, P, β),
and CTR(a, R ⇒R′) ∈η be a control request. If S is consistent and CTR(a, R ⇒R′) is
logically executable, then CTR(a, R ⇒R′) is physically executable.

CHAPTER 5. LOGICAL-SPACE COMPUTING
98
Proof. Since CTR(a, R ⇒R′) is logically executable, by Deﬁnition 5.12, R ⊆L L. In addition,
since S is consistent, by Lemma 5.1, PR ⊆P P. Thus, by Deﬁnition 5.13, CTR(a, R ⇒R′) is
physically executable.
Consistency is a suﬃcient condition for a control action to be physically executable but it
is not necessary. This can be demonstrated with a counterexample. Let c = ⟨α | (L, P, β) | η⟩
be a conﬁguration and CTR(a, R ⇒R′) ∈η be a control action. Let R ⊆L L and PR ⊆P P,
i.e., CTR(a, R ⇒R′) is logically and physically executable. Assume that there exists a logical
model C where C ⊆L L but R ̸⊆L C. Assume that (C, P, β) is inconsistent and thus, (L, P, β)
is also inconsistent. Let PC be the physical interpretation of C. Assume that PC ⊆P P but
PR ̸⊆P PC. Thus, PR ⊆P P still holds and CTR(a, R ⇒R′) is still physically executable over
the inconsistent structure (L, P, β).
The previous counterexample shows that consistency is not required as soon as the part
of the logical model is not inconsistent. In other words, it is suﬃcient for the structure to be
local consistency with respect to the redex of the control action in order to make it physically
executable.
Corollary 5.1. Let c = ⟨α | S | η⟩be a spatial computing conﬁguration where S = (L, P, β),
and CTR(a, R ⇒R′) ∈η be a control request. If S is locally consistent with respect to R and
CTR(a, R ⇒R′) is logically executable, then CTR(a, R ⇒R′) is physically executable.
Proof. Since CTR(a, R ⇒R′) is logically executable, by Deﬁnition 5.12 R ⊆L L. Since S is
locally consistent with respect to R and R ⊆L L, by Deﬁnition 5.7, (R, P, β) is consistent.
Since R ⊆L L and (R, P, β) is consistent, by Lemma 5.1, PR ⊆P P. Thus, by Deﬁnition 5.13,
CTR(a, R ⇒R′) is physically executable.
In general, local consistency is also not a necessary condition for a logically executable
control action to be physically executable. Let c = ⟨α | (L, P, β) | η⟩be a conﬁguration and
CTR(a, R ⇒R′) ∈η be a control action where R ⊆L L. Consider that all logical locations
speciﬁed by R do not have a physical interpretation. Thus, dom(PR) = ∅and, thus, PR ⊆P P
even if the structure is locally inconsistent with respect to R. In other words, if a spatial
agent requests a purely logical control action, then consistency is not necessary.
Nonetheless, under the assumption that at least one logical location from R has a phys-
ical interpretation, then local consistency is a necessary condition for a logically executable
control action to be physically executable.
Theorem 5.2. Let c = ⟨α | S | η⟩be a spatial computing conﬁguration where S = (L, P, β)
and let CTR(a, R ⇒R′) ∈η be a logically executable control request. Assume that there exists
a l ∈dom(L) such that β(l) is deﬁned. If CTR(a, R ⇒R′) is physically executable, then S is
locally consistent with respect to R.
Proof. Since, by hypothesis, CTR(a, R ⇒R′) is logically and physically executable, then
by Deﬁnition 5.12 and Deﬁnition 5.13, R ⊆L L and PR ⊆P P.
Consider the structure
(R, PR, β). Since, by hypothesis, there exists a l ∈dom(L) such that β(l) is deﬁned, the

CHAPTER 5. LOGICAL-SPACE COMPUTING
99
set dom(PR) = {β(l) | l ∈dom(R), β(l) is deﬁned} in Deﬁnition 5.11 is non-empty. By
the construction of Deﬁnition 5.11, if PR is the canonical physical interpretation of R then
(R, PR, β) is consistent. Since PR ⊆P P, then (R, P, β) is also consistent. Since R ⊆L L ,
then by Deﬁnition 5.7, (L, P, β) is locally consistent with respect to R.
5.7
Using the semantics to enforce local consistency
In the previous section, we deﬁne correctness of control actions in terms of their ability to
logically and physically execute. We have also shown that local consistency is a key property
to make control actions physically executable. In this section we analyse how one can use the
logical-space computing semantics in order to achieve physically executable control actions.
Whenever a observation is performed, the semantics rule sense forces the structure to
be local consistent with respect to the observed portion of the logical model.
Lemma 5.2. Consider a transition
⟨α | (L, P, β) | η, OBS(a, q)⟩
⟨sense:OBS(a,q)⟩
−−−−−−−−−→⟨α | (L′, P, β′) | η⟩.
Then (L′, P, β′) is locally consistent with respect to Lq where (Lq, , Pq, βq) = [[q]](L, P, β).
Proof. By Deﬁnition 5.10, (Lq, Pq, βq) is consistent. By Deﬁnition 5.10, Pq ⊆P P. Thus, by
Deﬁnition 5.4, (Lq, P, βq) is consistent. By deﬁnition of β′ in Equation 5.5, β′ restricted to
Lq is equal to βq. Thus, by Deﬁnition 5.4, (Lq, P, β′) is consistent. By the premisses of the
rule ⟨sense : OBS(a, q)⟩, Lq ⊆L L′. Thus, by Deﬁnition 5.7, (L′, P, β′) is locally consistent
with respect to Lq.
On the other hand, a control request can only be executed if the structure is locally
consistent with respect to the redex that speciﬁes that portion of the logical model to be
modiﬁed.
Lemma 5.3. Consider the transition
⟨α | (L, P, β) | η, CTR(a, R ⇒R′)⟩
⟨actuate:CTR(a,R⇒R′)⟩
−−−−−−−−−−−−−→⟨α | (L′, P ′, β) | η⟩.
(L, P, β) is locally consistent with respect to R and (L′, P ′, β) is locally consistent with respect
to R′.
Proof. By the premisses of rule ⟨actuate : CTR(a, R ⇒R′)⟩(Equation 5.8), R ⊆L L and
PR ⊆P P. By the construction of Deﬁnition 5.11, (R, PR, β) is consistent. Since R ⊆L L
and PR ⊆P P, then by Deﬁnition 5.7, (L, P, β) is locally consistent with respect to R.
By the premisses of rule ⟨actuate : CTR(a, R ⇒R′)⟩(Equation 5.8), R′ ⊆L L′ and
PR′ ⊆P P ′. By Deﬁnition 5.11, (R′, PR′, β) is consistent. Since R′ ⊆L L′ and PR′ ⊆P P ′,
then by Deﬁnition 5.7, (L′, P ′, β) is locally consistent with respect to R′.

CHAPTER 5. LOGICAL-SPACE COMPUTING
100
Lemma 5.2 shows how the semantics provides means for enforcing local consistency.
Lemma 5.3 shows that if the structure is locally consistent with respect to the logical-space
that one is willing to control, then the control request can be actuated. Next we show how
one can write a program that uses these semantic resources.
Theorem 5.3. Consider a conﬁguration c0 = ⟨α, a | S | η⟩where S0 = (L0, P0, β0) and
[E ⊢observe(q); ready(x); control(x ⇒f(x))]a for some f : L →L and some query q. If
the spatial agent a requests a control action CTR(a, x ⇒f(x)) where dom(x) ̸= ∅then there
exists a trajectory starting from the conﬁguration c0 where CTR(a, x ⇒f(x)) is requested and
actuated.
Proof. We prove by constructing t = c0
λ0
−→c1
λ1
−→c2
λ2
−→c3
λ3
−→c4
λ4
−→c5, where:
• c0 = ⟨α, [E ⊢observe(q); ready(x); control(x ⇒f(x))]a | S | η⟩
• λ0 = ⟨req obs : a, observe(q)⟩
– By deﬁnition of the rule denoted as ⟨req obs : a, observe(q)⟩(Equation 5.3), the
spatial agent reduces to [E ⊢ready(x); control(x ⇒f(x))]a and an observation
request OBS(a, q) is generated in η1.
λ0 does not aﬀect the structure.
Thus,
S1 = S0.
• c1 = ⟨α, [E ⊢ready(x); control(x ⇒f(x))]a | S1 | η, OBS(a, q)⟩
• λ1 = ⟨sense : OBS(a, q)⟩
– By Lemma 5.2, the rule ⟨sense : OBS(a, q)⟩can ﬁre, making S2 is locally consistent
with respect to Lq, where (Lq, Pq, βq) = [[q]](L1, P1, β1).
• c2 = ⟨α, [E ⊢ready(x); control(x ⇒f(x))]a | S2 | η, READY(a, Lq)⟩
• λ2 = ⟨rcv obs : a, ready(x)⟩
– By deﬁnition of the rule ⟨rcv obs : a, ready(x)⟩(Equation 5.6), READY(a, Lq) is
consumed, and [E′ ⊢control(x ⇒f(x))]a where E′ = E[x/Lq].
• c3 = ⟨α, [E′ ⊢control(x ⇒f(x))]a | S3 | η⟩
• λ3 = ⟨req ctr : a, control(R ⇒R′)⟩
– By deﬁnition of the rule denoted as ⟨req ctr : a, control(x ⇒f(x))⟩(Equa-
tion 5.7), the spatial agent reduces to [E ⊢]a and a control request CTR(a, x ⇒
f(x)) is generated in η4. λ3 does not aﬀect the structure so local consistency with
respect to Lq is preserved in S4.
• c4 = ⟨α, [E′ ⊢]a | S4 | η, CTR(a, x ⇒f(x))⟩

CHAPTER 5. LOGICAL-SPACE COMPUTING
101
• λ4 = ⟨actuate : CTR(a, x ⇒f(x))⟩
– Since S4 is locally consistent with respect to x = Lq. Thus, the rule ⟨actuate :
CTR(a, x ⇒f(x))⟩(Equation 5.8) can ﬁre. By Lemma 5.3, CTR(a, x ⇒f(x)) is
actuated, i.e., it is executed and removed from the bag of requests. By the same
lemma, S5 is now locally consistent with respect to f(x)
• c5 = ⟨α, [E′ ⊢]a | S5 | η⟩
Theorem 3.2 shows that if a spatial agent observes the space that is willing to control
than there is an execution that actuates its control request. In an analogy to control theory,
we call these agents, feedback.
Example 5.8. Figure 5.10 provides an example of a feedback controller. Note that the
BigActor hosted_at uav0 with_behavior{
loop{
observe(CHILDREN(PARENT(HOST)))
react{
case obs.contains(oilSpill0) => control(MOVE_HOST_TO(oilSpill0))
case _ =>
}
}
}
Figure 5.10: Example of a feedback speciﬁed as a bigActor.
bigActor executes MOVE HOST TO(oilSpill0) only if it observes oilSpill0.
Being a feedback agent is not suﬃcient to make control requests executable. This is due
to two factors: environmental actions and concurrency. The environment or other agents
may preclude execution by changing the physical structure after the control request is made
by the feedback agent.
Since space is a ﬁrst class concept in our model, it can express the partitioning of agents
in space to avoid conﬂicts due to concurrency in time. This is formalized in Theorem 5.4.
To set up the theorem, we deﬁne an unobtrusive environment (Deﬁnition 5.14) and then a
partitioned control policy for a set of concurrent agents (Deﬁnition 5.15).
Deﬁnition 5.14 (Unobtrusive environment). Let c = ⟨α | (L, P, β) | η, CTR(a, R ⇒R′)⟩
be a spatial structure. An environmental action ⟨env : P ′⟩is unobtrusive with respect to
CTR(a, R ⇒R′) if PR ⊆P P ′ where PR is the canonical interpretation of R.

CHAPTER 5. LOGICAL-SPACE COMPUTING
102
Deﬁnition 5.15 (Partitioning control). A set of agents {a0, a1, . . . , an−1} follow a partition-
ing control if there exists logical models La0, La1, . . . , Lan−1 such that, for any two spatial
agents ai and aj, dom(Lai) ∧dom(Laj) = ∅, and for any control request CTR(ai, Ri ⇒R′
i),
dom(Ri) ⊆dom(Lai) and dom(R′
i) ⊆dom(Lai).
If each agent operates only in its own space, local consistency can be preserved.
Theorem 5.4. Consider a conﬁguration c0 = ⟨a0, a1, . . . , am−1, aw | S0 | η0⟩where S0 =
(L0, P0, β0) is consistent. Let [E ⊢control(R ⇒R′)]aw be a spatial agent where R ⊆L L0.
Assume that a0, a1, . . . , am−1 follow a partitioning control policy. Assume that all environ-
mental actions are unobtrusive with respect to R. Let t = c0
λ0
−→c1
λ1
−→c2
λ2
−→. . .
λn−1
−−−→cn be
a trajectory where there exists a λi = ⟨req ctr : aw, control(R ⇒R′)⟩. CTR(a, R ⇒R′) in
any conﬁguration following ci+1, i.e., in any cn with n > i + 1 can be actuated.
Proof. We prove by showing that local consistency with respect to R is preserved.
By
hypothesis, S0 is consistent. By hypothesis, R ⊆L L0 Thus, by Deﬁnition 5.7, S0 is locally
consistent with respect to R.
There are two kinds of semantic rules that change the physical space making space locally
inconsistent with respect to R: actuate and ⟨env : P ′⟩. Let λj be an arbitrary event where
j > 0 and j ̸= i.
Let λj = ⟨env : P ′⟩By assumption, all environmental actions are
unobtrusive with respect to R. By Deﬁnition 5.14, PR ⊆P Pj+1. Thus, Sj+1 remains locally
consistent with respect to R.
Let λj = ⟨actuate : CTR(ak, Rk ⇒R′
k)⟩. By construction of Deﬁnition 5.15, for all agents
ak ̸= aw requesting CTR(ak, Rk ⇒R′
k), dom(Rk)∧dom(Law) = ∅and dom(R′
k)∧dom(Law) =
∅. Since, dom(R) ⊆dom(Law), Sj+1 remains locally consistent with respect to R.
By hypothesis, λi = ⟨req ctr : aw, control(R ⇒R′)⟩. Thus, ci+1 = ⟨a0, a1, . . . , am−1, aw |
Si+1 | ηi, CTR(aw, R ⇒R′)⟩. Without lost of generality, assume that n = j + 1. Since,
local consistency with respect to R is preserved for any arbitrary Sj+1, by Lemma 5.3,
λn = ⟨actuate : CTR(ai, R ⇒R′)⟩can semantically execute producing cn+1.
Theorem 5.4, shows that under controlled concurrency and environment, one can write
spatial agents that eventually have their control requests actuated.
5.8
Final remarks
In this chapter, we introduce logical-space computing - a new spatial computing paradigm
where programs interact with a logical abstraction of spatial location of computing machines
while a runtime system is in charge of mediating the interactions between the logical space
and the physical space.
Logical-space computing handles a hybrid model of space since
it combines both physical and symbolical abstractions of space.
It contrasts with other
hybrid approaches in the literature since it keeps the programs free of any physical space
information. By constraining programs to operating over symbolic locations, logical-space
computing removes the burden of correctly deﬁne physical behaviors from the programmer.

CHAPTER 5. LOGICAL-SPACE COMPUTING
103
We provide a deﬁnition for logical and physical spaces and a physical interpretation that
binds these two abstractions together. The physical interpretation is modelled as a partial
function, i.e., we allow logical locations to not have a physical interpretation. This design
decision has two practical implications. One can deﬁne logical locations that are “purely”
logical, e.g., modelling the logical location of a cloud-based application on a smartphone,
while is true physical location is unknown and not relevant. One can also deﬁne logical
locations that do not have a physical interpretation at a given point in time but acquires a
physical interpretation later in the execution, e.g., a a person with a smartphone is known to
be inside a car although, the GPS signal in the smartphone is too weak to provide a physical
location. We say that the structure that entails a logical model and a physical model is
consistent if the physical interpretation preserves the relations from the logical model in the
physical model.
Logical-space programs are speciﬁed as spatial agents. A spatial agent have local state,
local behavior, and can interact with the logical space by asynchronously requesting ob-
servations and control actions. We provide the formal semantics for spatial agents in an
operational style as a set of inference rules that deﬁne a transition system over the universe
of spatial-computing conﬁgurations.
We analyse the correctness of logical-space executions in terms of the executability of
the requested control actions. Consistency is a key property to ensure that control actions
are executable. Theorem 5.1 shows that consistency is a suﬃcient condition for logically
executable control actions to be physically executable. As a corollary of Theorem 5.1, we
prove that it is suﬃcient for the structure to be locally consistency for the control action to
be physically executable. In fact, if the control action is not purely logical, i.e., there exists
at least a node in the redex that has a physical interpretation, then local consistency is a
necessary condition. This is formalized by Theorem 5.2.
We explore how to use the logical-space computing semantics to enforce local consis-
tency and, thus, to ensure that control actions are physically executable. We propose a
programming pattern for spatial agents called feedback. Feedback spatial agents get their
requests executed by observing the space that are willing to control. This is formalized by
Theorem 5.3.
Nonetheless, being a feedback is not suﬃcient for getting control actions executed. The
environment and concurrency can make control actions non-executable. We introduced a
condition over the environment named unobtrusive that requests that requests the envi-
ronment to keep control requests physically executable. We also introduced a concurrency
condition named partitioning control that requests spatial agents to actuate over disjoint
spaces. Theorem 5.4 shows that, under controlled concurrency and environmental actions,
logically executable control actions operating over consistent structures are eventually actu-
ated.

104
Chapter 6
Case study: oil-spill monitoring
mission
We have used Logical Space Programming to execute an oil spill monitoring mission in
the Atlantic Ocean as a case study with a UAV, a satellite, drifters, and three control stations
distributed over 20 km. The case study is a collaborative eﬀort with the European Maritime
Safety Agency (EMSA), the Portuguese Air Force Pitvant project, and the Portuguese Navy.
Our contribution is the logical-space program, and the runtime system coordinating all the
entities. Installation of the runtime system on the Air Force and Naval hardware is a joint
eﬀort. The mission itself is executed by the Air Force, Navy, and EMSA. The author of
this dissertation participated in the 30 person execution team as an oﬃcer of the Air Force
holding the rank of Captain.
Our ﬁeld test demonstrates the role of unmanned vehicles and sensors for complementing
satellites for collecting evidence of illegal bilge dumping. The software infrastructure im-
plemented for this case study is named Logical-Space Runtime System (LSRS) and follows
the semantics described in Chapter 5. LSRS was designed speciﬁcally for this ﬁeld test.
It is our ﬁrst step towards programming mobile computing systems using the logical-space
computing.
6.1
The bilge dumping problem
Illegal bilge dumping has been identiﬁed as a serious form of maritime pollution. States
holding jurisdiction over large waters need technology and policies to reduce bilge dumping.
EMSA is an agency created by the European Commission (EC) with the speciﬁc mission
of providing the European member states with means to enforce maritime safety. Approxi-
mately half of EMSA’s budget (around 58.8 million of Euros in 2013 [79]) is dedicated to the
ﬁeld of marine pollution. Its activity focus on responding to ship-source marine pollution,
ﬁrstly oil pollution and then pollution by hazardous and noxious substances.
The global magnitude of the problem is diﬃcult to assess due to the lack of historical

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
105
data [80]. Nonetheless, there are increasing reports of tankers discharging in open waters
without the consent of the country of jurisdiction. According to EMSA, there were 674
conﬁrmed mineral oil-spills out of 2579 inspections in European Member State coastal waters
between 2007 and 2010 [81].
Gathering suﬃcient evidence to prosecute a suspect of illegal bilge dumping is hard.
The testimony of an illegal discharge (either in person or video footage) is not suﬃcient.
One must gather physical evidences of the crime in the form of water samples both from
the vicinities of the tanker and the tanker itself [82].
The most common technique for
detecting oil spill is satellite imagery, from optical and Synthetic Aperture Radar (SAR)
sources [83], correlated with Automatic Identiﬁcation System (AIS) information [84, 85].
AIS is the de facto identiﬁcation protocol for Vessel Traﬃc Services (VTS) [86]. Vessels
broadcast their GPS location and a unique identiﬁcation number, known as MMSI1, using
VHF radio-frequency transmission.
In order to perform this mission, EMSA provides three tools: CleanSeaNet, SafeSeaNet,
and IMDatE. CleanSeaNet is a satellite-based monitoring system for oil-spill detection in
European waters [87, 88, 89]. CleanSeaNet is a service based on SAR imagery covering
all European sea areas. SafeSeaNet is a vessel traﬃc monitoring and information system
that collects vessel traﬃc information using AIS. IMDatE stands for Integrated Maritime
Data Environment [90] and is used as a tool for integrating maritime data from diﬀerent
sources such as CleanSeaNet and SafeSeaNet. In order to search for illegal bilge dumping,
imagery from CleanSeaNet is analysed and correlated with information from SafeSeaNet.
This analysis is performed at IMDatE, which can provide both real-time and historical
maritime data. If a oil spill is detected, an alert message is delivered to the country of
interest. Figure 6.1 illustrates CleanSeaNet and SafeSeaNet providing evidence for bilge
dumping oﬀthe coast of Spain.
Using satellite imagery and AIS is not suﬃcient for collecting evidence of illegal bilge
dumping. Tasking satellites is limited in time and space and is inﬂuenced by the presence
of clouds [83]. Moreover, there is the need for collecting water samples from the vicinity of
the oil-spill and from suspect tankers. Thus, remote sensing is not suﬃcient. Academia and
law enforcement organizations have been interested in supplementing satellite imagery with
data collected from autonomous vehicles, such as Autonomous Underwater Vehicles (AUVs),
Unmanned Aerial Vehicles (UAVs), and Autonomous Surface Vehicles (ASVs) [91, 92, 93, 94].
These vehicles have been studied as an alternative and a complement of manned systems to
achieve persistent surveillance of maritime environments, including bilge dumping detection
and monitoring [95, 92, 96]. The aim is to combine the aerial sensing capabilities of UAVs,
satellite imagery, AUVs for sampling the water in the vicinity of a tanker, and ASVs as
communication relays [68]. AUVs have limited communication capabilities, often low-rate
acoustic modems. The ASVs are used to relay information between AUVs and other players.
Our case study explores the use of vehicles and sensors to complement satellite imagery for
collecting evidence of illegal bilge dumping. Next we present the speciﬁcation that inﬂuenced
1Acronym for Maritime Mobile Service Identity.

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
106
Figure 6.1: CleanSeaNet SAR image with evidences of bilge dumping acquired in June 2009
oﬀthe coast of Spain.
The suspected vessel was also detected in the SAR image.
The
satellite image is compared with SafeSeaNet AIS database in order to identify the suspected
ship. Source: EOMag [4].
our design decisions.
Speciﬁcation
The procedure of collecting evidence of bilge dumping goes as follows [97]. An operator
identiﬁes a feature in the sea that resembles an oil-spill using satellite imagery, either SAR or
optical. The operator analyses the trajectories of vessels in the vicinities of the oil-spill using
AIS historical data. A vessel is labelled as a suspect if it shows a trajectory that matches
the oil-spill both in space and time. Further evidence is needed to make a vessel formally a
suspect. There is the need for in situ data (imagery and identiﬁcation) of the vessel and the
oil-spill, and a water sample from both the oil-spill, and from the suspect vessel’s tanker.
The speciﬁcation for the ﬁeld test was provided by EMSA, the Portuguese Air Force, and
the Portuguese Navy. EMSA provided the requirements that drove the design of the case
study, while the Portuguese Air Force and the Portuguese Navy provided inputs regarding the

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
107
join operation of aerial and surface vehicles. Next we enumerate each requirement together
with a brief discussion.
Requirement 6.1. Demonstrate the use of alternative means for collecting evidence of illegal
bilge dumping activity.
Tasking satellites is limited in time and space. EMSA’s CleanSeaNet service uses 4 low-
earth orbit satellites, which acquire images in segments of up to 1400 km and swaths of
up to 500 km [98]. Nonetheless, images must be tasked in advance and take from 30 to
60 minutes to be delivered. Therefore, EMSA, in coordination with the involved Member
States, currently uses aerial imagery from conventional aircraft to persistently survey oil-
spills and vessels at real-time. EMSA is interested on studying the use of alternative means
such as autonomous vehicles for collecting data from vessels and oil-spills that complement
the use of satellites [99].
The Portuguese Air Force and the Portuguese Navy decided to address Requirement 6.1
using UAVs for collecting imagery and AIS information, drifters for forecasting the trajectory
of the oil-spill and for sampling the oil-spill, and a Navy vessel to deploy the drifters. The
operation of such a spatially distributed heterogeneous system posed operational-speciﬁc
requirements that are discussed next.
Requirement 6.2. Implement a software infrastructure that collects information from het-
erogeneous sources, e.g., UAV’s autopilot and AIS receivers, and generates a common loca-
tion model
Spatial information is provided by diﬀerent systems in diﬀerent formats, e.g., telemetry
messages sent by the UAV autopilot and AIS messages broadcast by drifters and vessels.
There is the need to ﬁnd a common location model and software means to collect information
from heterogeneous sources and generate location abstractions on demand.
Requirement 6.3. Implement networking capabilities to provide consistent location model
to all mission players, e.g., UAV’s operators and vessel’s commanders
The operation of an UAV often requires more than one operator taking control of the
UAV from spatially distributed ground control stations during a single mission. For example,
it is common to have an operator at an airﬁeld responsible for taking-oﬀand landing, and
an operator onboard a vessel to conduct the operation at increased range. Operators must
know at all time where the UAV is located and which operator has control authority. All
operators need consistent views of the location and connectivity of the UAV location model
as well as its connectivity.
Requirement 6.4. Implement a programming model that speciﬁes the mobility of the UAV,
abstracting low-level physical details.
Conventional UAVs autopilots provide operators with a GPS waypoint controller inter-
face, i.e., an operator speciﬁes the latitude and longitude of the desired destination and the

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
108
autopilot takes care of controlling the actuators. In our ﬁeld test, the oil-spill is delimited
by the drifters that provide its GPS location. In a conventional setting, in order to send the
UAV to visit the oil-spill, the UAV operator would have to read the location of the drifters
and calculate a GPS coordinates for the waypoint, e.g., at the centroid of the polygon formed
by the drifters. This is undesirable since the oil-spill is constantly moving creating room for
the operator to make a mistake and send the UAV to a undesirable location.
Our scenario aimed at emulating, as close as possible, a mission of vehicles and sen-
sors collecting evidence of a bilge dumping activity from a tanker crossing waters under
Portuguese jurisdiction. The Portuguese Navy emulated the oil-spill by releasing 100kg of
popcorn in the ocean in the southern coast of Portugal, around 6 miles oﬀthe coast of the
village of Portim˜ao. EMSA tasked a satellite to take a high-resolution optical picture of the
emulated oil-spill (see Figure 6.2).
Figure 6.2: High-resolution satellite image from the oil spill. Courtesy of EMSA.
The reminder of this chapter goes as follows. In Section 6.2 we present the vehicles and
sensors used in the ﬁeld test. This addresses Requirement 6.1. In Section 6.3 we describe
the software architecture named Logical-Space Runtime System, which provides the means
for programming the oil-spill monitoring scenario using logical-space computing as discussed
in Chapter 5. This addresses Requirement 6.4.
The requirements 6.2 and 6.3 are addressed in Section 6.4 where we describe the Logical-
Space Execution Engine (LSEE). LSEE is responsible for interfacing vehicles and sensors
and building location abstractions in the form of bigraphs. Bigraphs are used to model
the location and connectivity of the UAV, the Navy vessel, and the drifters, as well as
the location of the oil-spill, and other spaces of interest such as the airﬁeld, the search

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
109
area, and the segregated airspace. LSEE uses the Robot Operating System (ROS) - an
open-source middleware for robotic applications [100] - in order to create a software layer
that abstracts the heterogeneous hardware. LSEE fetches physical information from ROS
and generates consistent bigraphical abstractions. This addresses Requirement 6.2. LSEE
provides a communication infrastructure to share location information between spatially
distributed components. LSEE establishes a network between UAV ground control stations
and the Navy vessel using the internet and provides means for ﬂooding location information
throughout the network. This way, further local processing gives each actor a consistent
bigraphical view of the state of the mission. This addresses Requirement 6.3. LSEE also
provides means for controlling UAVs logically. A programmer speciﬁes control actions in a
logical-space, while LSEE is responsible for interpreting them and generate the corresponding
command in the physical space. For example, a programmer uses a single command MOVE -
HOST TO(oilSpill0) to send a UAV to the oil-spill location even though the physical
interpretation of oilSpill0 might change over time. This addresses Requirement 6.4.
6.2
Vehicles and Sensors
The Requirement 6.1 is addressed using the following machinery: one Air Force UAV,
three ground control stations, four drifters that broadcast their position using AIS, and one
Navy vessel equipped with a small speedboat. The UAV is used to collect imagery from the
oil-spill and AIS information broadcast by vessels and drifters. The UAV is controlled from
three diﬀerent ground control stations. One is solely dedicated for take-oﬀand landing from
the Portim˜ao aerodrome. The other ground control stations are used to control the mission.
They are placed near the shore and on board the Navy vessel in order to increase the range
of the mission. The drifters are used to forecast the trajectory of the oil-spill. They are
equipped with GPS and an AIS transmitter to broadcast their location. The Navy vessel
are used for ﬂushing the popcorn emulating a tanker ﬂushing its tanks. The speedboat is
used to release the drifters in the oil-spill.
We used two kinds of UAVs developed at the Portuguese Air Force Academy under the
PITVANT project, the Alfa and the Alfa-Extended (Figure 6.3). The Alfa-Extended is a
gas-powered UAV with 3 m wingspan, equipped with a Piccolo autopilot for stable low-level
control, and a PC-104 computing board for high-level control and vision processing. Each
UAV is equipped with a gimballed optic camera and an AIS receiver. Figure 6.4 shows
a picture collected from the Alfa-Extended UAV depicting the oil-spill (yellow patch), the
Navy vessel (left-upper corner) and the small speedboat used to deploy the drifters in the
middle.
The Unmanned Aerial System included three ground control stations (GCS) denoted as
gcs0, gcs1, and gcs2. gcs0 was situated in an air ﬁeld and was responsible for take-oﬀand
landing maneuvers, gcs1 was located at the shore and took control authority of the UAVs
during emergencies and unforeseen situations, and gcs2 was located at the shore and was
responsible for the UAV mission. In one particular scenario, gcs2 was located on a Navy

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
110
Figure 6.3: Alfa Extended UAV.
Figure 6.4: Onboard UAV picture of the oil-spill (popcorn) and Navy vessel.
vessel to extend the operational range of the mission.
The drifters used in this demonstration were AIS beacons commonly used for locating
ﬁshing nets. They were equipped with GPS and transmitted their position up to a range of 10
miles. Drifters were identiﬁed by unique MMSI numbers. Figure 6.5 provides a screenshot of
the visualization tool implemented to follow the mission execution. One can see the physical
location of the UAV and the drifters.
6.3
Logical-Space Runtime System
Logical-space computing provides the programmer with a logical representation locations
of computation.
LSRS provides a bridge between the logical-space abstraction and the
physical space. LSRS addresses Requirement 6.4 by specifying logically the spatial behavior

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
111
Figure 6.5: Mission Visualization Tool.
of a UAV using bigActors.
For more about BigActors and the BigActor Programming
Language see Chapter 3 and Chapter 4 of this dissertation.
The logical-space rutime system is implemented as an extension of the the BigActor
Runtime System (BARS) presented in Chapter 4. The model checker BigMC which serves
as a bigraphical execution engine in BARS is now replaced by the Logical-Space Execu-
tion Engine (LSEE). The LSEE interacts with the physical world and produces bigraphical
abstractions. The LSEE is implemented on ROS, a popular open-source middleware for
robotics. This implementation is developed primarily for specifying the spatial behavior of
vehicles and sensors performing an environmental monitoring mission. Its interfaces with
physical components are kept application-agnostic in order to facilitate its extension to pro-
gram other kinds of physical systems.
Figure 6.6 depicts the logical-space runtime system architecture. The left-hand side of
Figure 6.6 shows bigActor instances running over the BigActor Runtime System (BARS).
BARS is introduced in Chapter 4 and enables programming with bigActors over bigraphical
models of space. The right-hand side of Figure 6.6 depicts the LSEE, which provides BARS
with a bigraphical abstraction and implements the logical-space computing semantics. It
replaces BigMC used as a bigraphical execution engine in the implementation described
in Chapter 4 with an execution engine that interfaces with the physical world, i.e., ROS
middelware. LSEE is described in Section 6.4.
6.4
Logical-Space Execution Engine
LSEE has the following roles: serve as a middleware for sensors and actuators, generate
bigraphs from physical properties, consistent distribute bigraphs constructed at one location
to the other locations of computation, and interpret BRRs into control commands that can be

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
112
Figure 6.6: BigActor Runtime System for Logical-Space Programming.
executed by the appropriate actuator. Next we present the components that are responsible
for these tasks.
Middleware
The middleware component of the LSEE is named ros vehicle. It addresses Require-
ment 6.2 by creating a middleware layer that abstracts hardware such as the UAV autopilot
and AIS receivers.
ros vehicle instances run on computing entities that we call vehi-
cles. Each ros vehicle instance is equipped with software drivers named plugins and with
additional services for inter-vehicle communication and naming.
Plugins are implemented over ROS, which provides a publish-subscribe communication
mechanism. Plugins interact with software and hardware components that produce location
and connectivity information or consume control commands. These components can be for
example a GPS device, an autopilot, a computer vision system, or a cloud-based location
service accessed over the internet.
For the oil-spill scenario we implemented ﬁve plugins. The Autopilot Plugin handles the
execution of GPS waypoints over the autopilot and fetches the UAV state information, like
GPS location, velocity, and control authority. The AIS Plugin receives, decodes, and ﬁlters
AIS messages received from an onboard AIS receiver. AIS messages are broadcasted from
vessels and drifters, providing GPS location information and the unique identiﬁer of the
vessel or drifter, i.e., the MMSI. The Camera Plugin uses a video camera driver to capture
and process video frames2.
2The purpose of the camera plugin is to automatically process video frames, automatically detect oil-
spills, and produce the corresponding location information. At the time of the demonstration, the camera
plugin was incomplete. The detection of oil-spills was performed with an operator in the loop.

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
113
A plugin has a well-deﬁned interface. It can subscribe mobility commands and publish
physical properties deﬁned using ROS messages. Mobility commands specify actions to be
executed by physical platforms, e.g., a GPS waypoint to be executed by an UAV. Figure 6.7
provides the message deﬁnition for MobilityCommand, where vehicleID is the name of the
vehicle that is going to execute the command, timeStamp is a globally-deﬁned time stamp,
type is an integer that denotes the kind of command to execute, e.g. type=1 denotes a way-
point command, and cmdParam is a list of parameters deﬁned using JSON that parametrizes
the command, e.g., the GPS latitude and longitude of a waypoint.
uint64
timeStamp
# Timestamp in milliseconds since Unix Epoch
uint8
vehicleId
# Unique id of vehicle to execute the MobilityCommand
string
props
# Properties as JSON
uint8
type
# Type
uint8 MT_WAYPOINT=0
uint8 MT_LOITER=1
uint8 MT_OTHER=2
Figure 6.7: ROS message deﬁnition for MobilityCommand.
Physical properties specify spatial information provided from physical platforms. A phys-
ical property may contain static information, such as a polygon describing the airﬁeld area,
or dynamic information, such as the GPS location and connectivity of an UAV or the oil-spill
location. Figure 6.8 provides the message deﬁnition for PhysicalProp, where vehicleId is
the ID of the vehicle that produced the physical property, timeStamp is a globally-deﬁned
time stamp, locations is a list of locations, and connections is a list of connections.
uint64
timeStamp
# Timestamp in milliseconds since Unix Epoch
uint8
vehicleId
# Unique id of vehicle that produced the PhysicalProp
Location[]
locations
# List of locations
Connection[]
connections
# List of connections
Figure 6.8: ROS message deﬁnition for PhysicalProp.
Locations are deﬁned by the type Location speciﬁed by the ROS message in Figure 6.9,
where locationId is a unique ID, name is a unique name, props is a list of properties written
in JSON that deﬁnes the location, e.g., GPS coordinates deﬁning the vertices of a polygon,
and type is the location type, i.e., a GPS point, a circle, or a polygon.
Connections are deﬁned by the type Connection speciﬁed by the ROS message in Fig-
ure 6.10, where connectionId is a unique ID, name is a unique name, locIds is a list of IDs
of the locations that share this connection, and type is the connection type, e.g., Wiﬁ, 3G,
or a command and control link.
The ros vehicle is also equipped with a Naming Service and a Communication Service.
The Naming Service is responsible for assigning unique names to physical properties and can

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
114
uint64
timeStamp
# Timestamp in milliseconds since Unix Epoch
uint32
locationId
# Unique id
string
name
# Location name
string
props
# Properties as JSON
uint8
type
# Type
uint8 LT_POINT=0
uint8 LT_CIRCLE=1
uint8 LT_POLYGON=2
Figure 6.9: ROS message deﬁnition for Location.
uint64 timeStamp
# Timestamp in milliseconds since Unix Epoch
uint32 connectionId
# Unique id
string name
# Name
uint32[] locIds
# IDs of the connected locations
uint8
type
# Type
uint8 CT_WIFI=0
uint8 CT_3G=1
uint8 CT_C2=2
uint8 CT_OTHER=4
Figure 6.10: ROS message deﬁnition for Connection.
be implemented using diﬀerent naming conventions. The Naming Service implemented for
the oil-spill scenario uses the autopilot serial number to identify the location of the UAV and
the AIS MMSI to identify the locations of the drifters.
The Communication Service speciﬁcally addresses Requirement 6.3. It is responsible for
sharing local observations between ros vehicles. For the oil-spill scenario, the Commu-
nication Service supports the TCP and UDP transport protocols. When operating over a
local WiFi network we use UDP to avoid congestion. When operating over the internet
we use TCP. The communication service assumes that each ros vehicle has a unique IP.
For our ﬁeld test, the communication service shares physical properties between diﬀerent
ros vehicles at diﬀerent ground stations. Computers running ros vehicles had internet
access through 3G USB wireless modems. The internet provider used in the ﬁeld test pro-
vided a public IP for each 3G modem. This practice can not be used in general since some
internet providers deliver NAT3 private IPs to these devices. This problem can be overcome
using port forwarding.
3Network Access Translation is a methodology of remapping one IP address space into another by
modifying network address information in datagram packet headers while they are in transit across a router.

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
115
Generation of bigraphs
Recall the logical-space computing formalized in Chapter 5. Lemma 5.2 states that a
transition c
⟨sense:OBS(a,q)⟩
−−−−−−−−−→c′ makes the spatial structure at conﬁguration c′ locally consis-
tent. In other words, whenever a spatial agent requests an observation, the runtime system
is responsible for making the logical-space abstraction locally consistent with respect to the
portion of observed physical space.
The logical-space runtime system ensures local con-
sistency through the Bigraph Driver.
When a bigActor performs a query, the BigActor
Scheduler requests the Bigraph Manager for the respective bigraphical abstraction. The Bi-
graph Manager gets bigraphs from the Bigraph Driver, which interacts with ros vehicle
to ensure consistency. Recall the spatial structure S = (B, P, β) presented in Section 5.3
where the logical-space B is a bigraph and the physical-space P is a set of polygons and
relations over those polygons, namely parentP and linkingP. Given any P, the Bigraph
Driver generates a logical-space model B and β such that S is consistent.
The software component that implements the Bigraph Driver subscribes to messages of
kind PhysicalProp which model the physical-space and publishes messages of kind Bigraph
which model the logical-space. The Bigraph message deﬁnition is provided in Figure 6.11,
where bgm is a bigraph term speciﬁed using BGM. The syntax for BGM is introduced in
Chapter 4.
uint64 timeStamp
# Timestamp in milliseconds since Unix Epoch
string bgm
# Bigraph defined as bgm term
Figure 6.11: ROS message deﬁnition for Bigraph.
The Bigraph Driver names each bigraph using the name of the corresponding physical
interpretation, which is uniquely assigned by the ros vehicle Naming Service.
Recall that physical spaces in LSEE are speciﬁed using messages of kind PhysicalProp,
deﬁned by the ROS message in Figure 6.8. A message PhysicalProp deﬁnes a list of locations
that can be points, polygons, or circles. Also recall the parenting relation for polygons where
(p′, p) ∈parentP iﬀp′ is the smallest polygon or circle that totally contains the the point,
polygon or circle deﬁned by p. The relation parentP is checked using the JTS topology suite
library [101].
The linking graph is generated using connectivity information provided by PhysicalProp
messages.
The relation linkingP is implicitly provided at each PhysicalProp message
through the list connections. Each connection in the list connections has a unique name
and the list of IDs of locations that share the respective connection. The Bigraph Driver
creates a hyperlink in the bigraph for each connection in connections.
Figure 6.12 depicts the generation of a bigraph from physical properties produced by
a network of vehicles and sensors. Note that the Bigraph Driver not only generated the
parenting relation, e.g., the parent of uav0 is oilSpill, but also the linking graph, e.g., ais
is deﬁned as a link shared between uav0 and drifter0...N.

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
116
Figure 6.12: Bigraph Driver example.
Bigraphs distribution
The Bigraph Driver implemented for the oil-spill ﬁeld test uses the Communication Ser-
vice to exchange observed physical properties between ros vehicles. The Bigraph Driver
hosted at each ros vehicle generates a bigraphical estimate of the global bigraphical ab-
straction. The bigraphical abstractions “ﬂood” over the network of ros vehicles eventually
converging to a distributed bigraph estimate which is also globally consistent. In order to
solve ambiguities between observations of the same physical space by diﬀerent robots we
augment each physical property with a global time-stamp. We use GPS time-stamps. If the
Bigraph Driver receives a physical property that was already observed, it disregards the old
one and re-generates the bigraphical abstraction.
During our ﬁeld test, the UAV operators at each ground station and the military personnel
onboard of the Navy vessel had access to distributed bigraph estimates.
This addresses
Requirement 6.3. Since the number of machines involved in our ﬁeld test was small it was
easy to enforce global consistency. In order for the system to scale, one should rely on local
consistency since it requires less communication. This remains as future work.
Example 6.1 shows the use of the Communication Service to extend the situation aware-
ness of UAV operators during a manoeuvre for handing-over control authority between op-
erators.
Example 6.1. Consider an UAV uav0 that starts a mission under the control of gcs0 and, at
a given point, hands control over to gcs1 on-board of a navy vessel. Figure 6.13 depicts this
situation. Each operator has a local and limited observation of the world. The operator on
the vessel does not know where the UAV is located until the handover has been successfully
completed. The use of the Communication Service allows the operators to have access to an

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
117
extended bigraphical abstraction. With this information, both operators have access to the
location of the UAV before and after hand-over.
Figure 6.13: Distributed bigraph example.
Generation of control commands
The BRR Driver translates BRRs to control commands that can be executed by a given
vehicle. This addresses Requirement 6.4. In order to synthesize the physical control com-
mands, the BRR Driver must also have access to the physical interpretations of the nodes in
the BRR. To derive the physical interpretation, the BRR Driver subscribes physical prop-
erties from ros vehicle. For example, the generation of a waypoint command to move an
UAV to a given destination needs the GPS location of the destination. Figure 6.14 depicts
the execution of a BRR for moving an UAV to the oil-spill location. The BRR Driver gener-
ates a GPS waypoint command to the centroid of the polygon that deﬁnes the the oil-spill.
This command is subscribed by the Autopilot Plugin from the ros vehicle instance that
is responsible for managing the execution of the waypoint.
Logical-space programs
Next we present some bigActors used in our ﬁeld test. The bigActor deﬁned in Figure 6.15
speciﬁes the behavior of the UAV. The bigActor requests periodically to move the UAV to
logical locations, e.g., move uav0 to oilSpill0 location. A period of one minute is enforced

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
118
Figure 6.14: BRR Driver example.
BigActor hosted_at uav0 with_behavior{
control(MOVE_HOST_TO(searchArea0))
observe(CHILDREN(PARENT(HOST)))
loop{
react{
case obs.contains(oilSpill0) => control(MOVE_HOST_TO(oilSpill0))
case _ => observe(CHILDREN(PARENT(HOST)))
}
Thread.sleep(60000)
}
}
Figure 6.15: Logical-space program for observing and tracking the oil-spill.
by the command Thread.sleep(60000)4. Since the oil-spill moves over time, each execution
of the same instruction at the logical level maps to a diﬀerent instruction at the physical
level. In other words, a new waypoint command must be generated each time the logical
location moves its physical location. Without logical-space programming, the operator would
have to specify the new waypoints in physical-space which is inconvenient and could lead to
mistakes. With logical-space programming, the command is the same, e.g., MOVE HOST -
TO(oilSpill0).
The LSEE is in charge of ensuring that the waypoint has the correct
physical coordinates.
The bigActor in Figure 6.16 observes the bigraph with a query LINKED TO(HOST) and
4The use of Thread.sleep is not recommended since it blocks the actor’s thread. One can create a
non-blocking actor implementation for a periodic loop. Nonetheless, for the sake of keeping the example
simple, we use Thread.sleep.

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
119
displays the result. The bigActor also matches messages handover and emergency. The ﬁrst
results in a BRR handing over the control authority for uav0 to ground station gcs0 and
the second to gcs1. Due to the absence of interfaces in the autopilot Software Development
Kit (SDK), the control action HANDOVER was performed manually by the operator using the
command and control interface provided by the UAV autopilot vendor. We implemented
a simple Graphical User Interface that sends messages handover and emergency under the
request of the UAV operator.
BigActor hosted_at gcs2 with_behavior {
observe(LINKED_TO(HOST))
loop {
react {
case obs: Observation =>
display(obs)
observe(LINKED_TO(HOST))
case "handover" => control(HANDOVER(uav0,gcs0))
case "emergency" => control(HANDOVER(uav0,gcs1))
}
}
}
Figure 6.16: Code for bigActor handover.
Our operators were able to watch bigraphs evolve as the ﬁeld test progressed. The logical
abstraction proved particularly useful for UAV handovers, since it provided the operators
with information to be aware of the UAV location and connectivity regardless of which
ground station held the control authority. The Bigraph Driver provided local bigraph esti-
mates that where globally synchronized between ground stations over the internet using the
communication service. The prior practice was to watch the ground station screen provided
by the autopilot vendor and only see the UAV when under the control of the ground station.
Correct termination used to be ensured by radio communication between operators. This
communication was discontinued as the military operators came to understand and trust the
logical bigraph abstractions being computed.
6.5
Final remarks
This chapter discusses the software implementation for a oil-spill monitoring mission
using the logical-space programming paradigm.
The ﬁeld test addresses speciﬁcally the
use of vehicles and sensors for complementing satellite imagery in the quest to monitor
illegal bilge dumping activities. The ﬁeld test uses an UAV with a camera and drifters with
AIS modems and GPS to monitor an oil-spill. The oil-spill is emulated by a Navy vessel
dropping 100 kg of pop-corn 6 km south of the shore of Portim˜ao, Portugal.
This is a

CHAPTER 6. CASE STUDY: OIL-SPILL MONITORING MISSION
120
small oil-spill of the kind that might be created by a large ship ﬂushing its oil tanks. We
demonstrate the use of the logical-space programming paradigm for specifying the spatial
behavior of vehicles and sensors used in the ﬁeld test.
The software implementation is
named the Logical-Space Runtime System and follows the logical-space computing semantics
presented in Chapter 5. The software infrastructure was successfully tested using real vehicles
and sensors.
The implementation was particularly valued for controlling UAVs logically
and leaving the generation of GPS waypoints to the runtime system. It also made a large
operational impact on the handover of UAV control authority from one ground control station
to another.
LSRS is a ﬁrst attempt towards a more general runtime system addressing a larger
number of diﬀerent computing machines. Next we present some lessons learned from this
experience. Bigraphs are a suitable model for modelling location and connectivity of vehicles
and sensors. Nonetheless, shared locations are not a ﬁrst-class citizen in pure bigraphs. We
believe that, in situations where vehicles operate in shared environments, one might need to
use a location model allowing shared locations, e.g., Sevegnani’s bigraphs with sharing [22].
The implemented BRR Driver was limited to the BRRs used in the ﬁeld test. One must
study more general approaches that work for a wide variety of control commands performed
by diﬀerent machines such as indoor robots and smartphones. We believe this requires the
deﬁnition of a set of canonical mobility commands that work on many physical machines.
The naming service and the communication service were not implemented with scalability
as a requirement.
For a scalable implementation one must study diﬀerent protocols for
providing logical names to logical locations. The communication service currently requires
vehicles to be assigned with a unique IP addresses. This practice is restrictive since most
internet providers hide mobile devices under NAT addresses. One must ﬁnd more scalable
addressing schemes to extend the use of LSRS to mobile devices such as smartphones.

121
Chapter 7
Conclusions
In this dissertation we investigate the how to bridge programs with mobile computing
machinery. We propose the BigActor Model as a bridging model between programs and
logical-space models. The BigActor model [1] is described in Chapter 3 and combines He-
witt and Agha’s Actor model [2] for specifying concurrent reactive programs with Robin
Milner’s Bigraphical Model [3] for specifying the location and connectivity of the computing
machines. The BigActor Model makes location and connectivity ﬁrst-class citizens in dis-
tributed machines. This is analogous to another bridging model, the von Neumann machine,
which makes ﬁrst-class citizens of memory, instructions, and their sequentiality.
The BigActor Programming Language (BAL) is an implementation of the BigActor
Model for logical space programming. It has a runtime system named the BigActor Runtime
System (BARS). The BARS targets an abstract machine (bigraphs). The abstract machine
has to be realized on a physical space of mobile and distributed computing machines. The
realization is produced by the Logical-Space Execution Engine (LSEE), which bridges bi-
graphs with the physical space. The Logical-Space Runtime System (LSRS) extends BARS
with LSEE so that programs written in BAL can seamlessly execute over physical spaces.
The second part of this dissertation is concerned with the formalization and implementation
of the interactions between logical spaces and physical spaces.
First, we approach this problem formally, by introducing the logical-space computing
semantics. This is presented in Chapter 5. In logical-space computing, spatial agents operate
over logical-space models while the runtime system is in charge of interacting with the
physical space. In Chapter 6 we presented an implementation that follows the logical-space
computing semantics of Chapter 5.
The LSRS uses the LSEE to generate logical-space
models using bigraphs. The physical space is modelled using polygons deﬁned using GPS
coordinates. The spatial agents are bigActors. Our implementation programs robots and
sensors in logical-space to execute an oil-spill monitoring exercise in the Atlantic. BigActor
programs execute over BARS, which interacts with physical spaces through the LSEE. LSEE
executes over the Robot Operating System (ROS) - an open-source middleware for robotics.
The physical machinery used in the demonstration consisted of one Air Force UAV, three
ground control stations, four drifters that broadcast their position using AIS, and one Navy

CHAPTER 7. CONCLUSIONS
122
vessel equipped with a small speedboat. The Portuguese Navy emulated the oil-spill by
releasing 100kg of popcorn in the ocean.
As future work we want to investigate the use of speciﬁc formalisms for modelling and
controlling physical spaces. The logical-space computing semantics deﬁnes physical spaces
abstractly and our implementation uses polygons as physical space models.
One would
beneﬁt from the deﬁnition of a concrete physical-space model that can still be useful for
a large spectrum of mobile computing applications. This is particularly interesting for the
deﬁnition of mobility commands that can be transparently used for controlling heterogeneous
mobile computing machines, e.g., an autonomous vehicle or a person with a smartphone.
Bigraphs are a suitable model for the location and connectivity of vehicles and sensors.
Nonetheless, shared locations is not a ﬁrst-class citizen in pure bigraphs. We believe that, in
situations where vehicles operate in shared environments, one might need to use a location
model that allow the model of shared locations. This problem can be addressed by extending
the formalism to use Sevegnani’s bigraphs with sharing [22].
Our implementation of the Logical-Space Runtime system addresses our case study. We
want to build the implementation to program a large spectrum of mobile computing appli-
cations. We envision the need for a scalable naming service. A possible approach is to adopt
a standard naming service such as Common Object Service (COS) Naming from CORBA,
Domain Naming System (DNS) from the internet, and Java Naming and Directory Interface
(JNDI) from Java.
Our implementation requires computing machinery to have an unique IP addresses. This
practice is restrictive since most internet providers hide mobile devices under NAT addresses.
One must ﬁnd more scalable addressing schemes to extend the use of LSRS to mobile devices
such as smartphones.

123
Bibliography
[1]
E. Pereira, C. Kirsch, R. Sengupta, and J. Borges de Sousa.
Bigactors - a model
for structure-aware computation. In 4th International Conference on Cyber-Physical
Systems. ACM/IEEE, April 2013.
[2]
Gul Agha. Actors: a model of concurrent computation in distributed systems. MIT
Press, Cambridge, MA, USA, 1986.
[3]
Robin Milner. The Space and Motion of Communicating Agents. Cambridge University
Press, 2009.
[4]
EOMag. EMSA 2 : CleanSeaNet : An oil spill detection service for European seas,
2009.
[5]
Dina Goldin and Peter Wegner. Principles of interactive computation. In Interactive
Computation, pages 25–37. Springer, 2006.
[6]
Robin Milner. Turing, computing and communication. In Interactive Computation,
pages 1–8. Springer, 2006.
[7]
John von Neumann. First draft of a report on the EDVAC. Technical report, University
of Pennsylvania, June 1945.
[8]
Leslie G Valiant. A bridging model for parallel computation. Communications of the
ACM, 33(8):103–111, 1990.
[9]
D.Q. Goldin, S.A. Smolka, and P. Wegner. Interactive computation: The new paradigm.
Springer-Verlag New York Inc, 2006.
[10]
Franco Zambonelli and Marco Mamei. Spatial computing: An emerging paradigm
for autonomic computing and communication. In Autonomic Communication, pages
44–57. Springer, 2005.
[11]
Marco Mamei and Franco Zambonelli. Programming pervasive and mobile computing
applications: The tota approach. ACM Transactions on Software Engineering and
Methodology (TOSEM), 18(4):15, 2009.

BIBLIOGRAPHY
124
[12]
Jacob Beal, S Dulman, and K Usbeck. Organizing the aggregate: Languages for spatial
computing. In Formal and Practical Aspects of Domain-Speciﬁc Languages, pages 1–60.
Information Science Reference, 2012.
[13]
Akash Deshpande, Aleks Gollu, and Luigi Semenzato. The shift programming lan-
gauge for dynamic networks of hybrid automata. In IEEE Transactions on Automatic
Control, volume 43. April 1998.
[14]
Fabian Kratz, Oleg Sokolsky, George Pappas, and Insup Lee. R-charon, a modeling
language for reconﬁgurable hybrid systems. In Lecture Notes in Computer Science,
pages 392–406. Springer-Verlag, 2006.
[15]
E. Pereira and R. Sengupta. An algebraic model of computation for systems with
dynamic structure. In Applied Computing Conference. IADIS, 2012.
[16]
Nancy A. Lynch. Distributed Algorithms. Morgan Kaufmann Publishers Inc., San
Francisco, CA, USA, 1996.
[17]
R. Milner. Communicating and mobile systems: the π-calculus. Cambridge Univ Press,
1999.
[18]
L. Cardelli and A. Gordon. Mobile ambients. In Foundations of Software Science and
Computation Structures, pages 140–155. Springer, 1998.
[19]
S. Debois. Computation in the informatic jungle. To appear. Draft available at http:
// www. itu. dk/ people/ debois/ pubs/ computation. pdf , 2010.
[20]
Robin Milner. The tower of informatic models. From semantics to Computer Science,
2009.
[21]
E. Pereira, C. Kirsch, and R. Sengupta.
Computation over worlds with dynamic
structure. In 3rd International Workshop on Bigraphs, February 2013.
[22]
Michele Sevegnani and Eloi Pereira. Towards a bigraphical encoding of actors. In 1st
International Workshop on Meta Models for Process Languages (MeMo 2014), Berlin,
Germany, 2014.
[23]
Martin Odersky, Philippe Altherr, Vincent Cremet, Burak Emir, Sebastian Maneth,
St´ephane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman, and Matthias
Zenger. An overview of the scala programming language. Technical report, Citeseer,
2004.
[24]
Robert Virding, Claes Wikstr¨om, and Mike Williams. Concurrent Programming in
ERLANG (2Nd Ed.). Prentice Hall International (UK) Ltd., Hertfordshire, UK, UK,
1996.

BIBLIOGRAPHY
125
[25]
Edward A Lee, Stephen Neuendorﬀer, and Michael J Wirthlin. Actor-oriented design of
embedded hardware and software systems. Journal of circuits, systems, and computers,
12(03):231–260, 2003.
[26]
Akka Scala Documentation - Release 2.2.0. Technical report, Typesafe Inc, 2013.
[27]
Jeﬀrey Hightower and Gaetano Borriello. Location systems for ubiquitous computing.
Computer, 34(8):57–66, 2001.
[28]
Christian Becker and Frank D¨urr.
On location models for ubiquitous computing.
Personal and Ubiquitous Computing, 9(1):20–31, 2005.
[29]
Sebastian Thrun. Learning metric-topological maps for indoor mobile robot navigation.
Artiﬁcial Intelligence, 99:21–71, 1998.
[30]
Vassileios Tsetsos, Christos Anagnostopoulos, Panayiotis Kikiras, P Hasiotis, and
Stathes Hadjiefthymiades. A human-centered semantic navigation system for indoor
environments. In International Conference on Pervasive Services (ICPS’05), 2005.
[31]
Bernhard Lorenz, HJ Ohlbach, and EP Stoﬀel. A hybrid spatial model for representing
indoor environments. Web and Wireless Geographical Information Systems, pages 102–
112, 2006.
[32]
Benjamin Kuipers and YT Byun. A robot exploration and mapping strategy based
on a semantic hierarchy of spatial representations. Robotics and autonomous systems,
8:47–63, 1981.
[33]
Hadas Kress-Gazit, Georgios E Fainekos, and George J Pappas. Temporal-logic-based
reactive mission and motion planning. Robotics, IEEE Transactions on, 25(6):1370–
1381, 2009.
[34]
Lisa A Walton and Michael Worboys. A qualitative bigraph model for indoor space.
In Geographic Information Science, pages 226–240. Springer, 2012.
[35]
L. Walton and M. Worboys. An algebraic approach to image schemas for geographic
space. Spatial Information Theory, pages 357–370, 2009.
[36]
L. Birkedal, S. Debois, E. Elsborg, T. Hildebrandt, and H. Niss. Bigraphical models of
context-aware systems. In Foundations of software science and computation structures,
pages 187–201. Springer, 2006.
[37]
H Zender and O Mart´ınez Mozos. Conceptual spatial representations for indoor mobile
robots. Robotics and Autonomous Systems, 6:493–502, 2008.
[38]
C Galindo and A Saﬃotti.
Multi-hierarchical semantic maps for mobile robotics.
IEEE/RSJ International Conference on Intelligent Robots and Systems, (August),
2005.

BIBLIOGRAPHY
126
[39]
E. Pereira, C. Krainer, P. Silva, C. Kirsch, and R. Sengupta. A runtime system for
logical-space computing.
In 2nd Swarm at the Edge of the Cloud Workshop (CP-
SWeek’15). ACM, April 2015.
[40]
E. Pereira, P. Silva, C. Krainer, C. Kirsch, and R. Sengupta.
Logical space com-
puting.
Technical report, December 2014.
http://cpcc.berkeley.edu/papers/
logicalSpaceComputingWorkingPaper.pdf.
[41]
Jacob Beal and Gerald Sussman. Biologically-inspired robust spatial programming.
Technical Report January, 2005.
[42]
Jonathan Bachrach and Jacob Beal. Programming a Sensor Network as an Amor-
phous Medium. Technical report, MIT - Computer Science and Artiﬁcial Intelligence
Laboratory, 2006.
[43]
Jacob Beal and Jonathan Bachrach. Infrastructure for Engineered Emergence on Sen-
sor/Actuator Networks. Intelligent Systems, IEEE, 2006.
[44]
C. Borcea, C. Intanagonwiwat, P. Kang, U. Kremer, and L. Iftode. Spatial program-
ming using smart messages: design and implementation. In 24th International Con-
ference on Distributed Computing Systems, 2004. Proceedings., pages 690–699. Ieee,
2004.
[45]
Porlin Kang, Cristian Borcea, Gang Xu, Akhilesh Saxena, Ulrich Kremer, and Liviu
Iftode. Smart messages: A distributed computing platform for networks of embedded
systems. The Computer Journal, 47(4):475–494, 2004.
[46]
Manuel Roman and RH Campbell. Gaia: enabling active spaces. Proceedings of the
9th workshop on ACM ..., pages 229–234, 2000.
[47]
JL Giavitto and O Michel. Mgs: a rule-based programming language for complex
objects and collections. Electronic Notes in Theoretical Computer Science, 2001.
[48]
UP Schultz.
Towards a Robust Spatial Computing Language for Modular Robots
(Position Paper). Spatial Computing 2012 colocated with AAMAS, pages 45–51, 2012.
[49]
Jonathan Bachrach, James McLurkin, and Anthony Grue. Protoswarm: a language
for programming multi-robot systems using the amorphous medium abstraction. In
Proceedings of the 7th international joint conference on Autonomous agents and multi-
agent systems-Volume 3, pages 1175–1178. International Foundation for Autonomous
Agents and Multiagent Systems, 2008.
[50]
Jonathan Bachrach, Jacob Beal, and James McLurkin. Composable continuous-space
programs for robotic swarms.
Neural Computing and Applications, 19(6):825–847,
2010.

BIBLIOGRAPHY
127
[51]
Mirko Bordignon, Kasper Stoy, and Ulrik Pagh Schultz.
A virtual machine-based
approach for fast and ﬂexible reprogramming of modular robots.
In Robotics and
Automation, 2009. ICRA’09. IEEE International Conference on, pages 4273–4280.
IEEE, 2009.
[52]
Savas Konur, Clare Dixon, and Michael Fisher. Analysing Robot Swarm Behaviour
via Probabilistic Model Checking. Robotics and Autonomous Systems, 60(2):199–213,
2012.
[53]
E. Klavins, R. Ghrist, and D. Lipsky. A Grammatical Approach to Self-Organizing
Robotic Systems. IEEE Transactions on Automatic Control, 51(6):949–962, June 2006.
[54]
J. Love, J. Jariyasunant, E. Pereira, M. Zennaro, K. Hedrick, C. Kirsch, and R. Sen-
gupta. Csl: A language to specify and re-specify mobile sensor network behaviors. In
Real-Time and Embedded Technology and Applications Symposium, 2009. RTAS 2009.
15th IEEE, pages 67–76. IEEE, 2009.
[55]
G. Perrone, S. Debois, and T. Hildebrandt. Bigraphical reﬁnement. Reﬁnement Work-
shop - Electronic Proceedings in Theoretical Computer Science, 2011.
[56]
G. Agha, I.A. Mason, S.F. Smith, and C.L. Talcott. A foundation for actor computa-
tion. Journal of Functional Programming, 7(1):1–72, 1997.
[57]
J. Armstrong, R. Virding, C. Wikstr, M. Williams, et al. Concurrent programming in
erlang. 1996.
[58]
P. Haller and M. Odersky. Scala actors: Unifying thread-based and event-based pro-
gramming. Theoretical Computer Science, 410(2-3):202–220, 2009.
[59]
J. Epstein, A.P. Black, and S. Peyton-Jones. Towards haskell in the cloud. In Proceed-
ings of the 4th ACM symposium on Haskell, pages 118–129. ACM, 2011.
[60]
Edward A Lee, Stephen Neuendorﬀer, and Michael J Wirthlin. Actor-oriented de-
sign of embedded hardware and software systems. Journal of Circuits, Systems, and
Computers, 2002.
[61]
B. Nielsen and Gul Agha. Semantics for an actor-based real-time language. Proceedings
of the 4th International Workshop on Parallel and Distributed Real-Time Systems,
pages 223–228, 1996.
[62]
G. Weiss. Multiagent systems: a modern approach to distributed artiﬁcial intelligence.
The MIT press, 1999.
[63]
Benjamin C. Pierce. Types and programming languages. MIT Press, 2002.

BIBLIOGRAPHY
128
[64]
G. Perrone, S. Debois, and T.T. Hildebrandt.
A model checker for bigraphs.
In
Proceedings of the 27th Annual ACM Symposium on Applied Computing, pages 1320–
1325. ACM, 2012.
[65]
Paul Hudak. Modular domain speciﬁc languages and tools. In Software Reuse, 1998.
Proceedings. Fifth International Conference on, pages 134–142. IEEE, 1998.
[66]
Debasish Ghosh. DSLs in action. Manning Publications Co., 2010.
[67]
Terence J. Parr and Russell W. Quong. Antlr: A predicated-ll (k) parser generator.
Software: Practice and Experience, 25(7):789–810, 1995.
[68]
E. Pereira, C. Potiron, C. Kirsch, and R. Sengupta. Modeling and controlling the
structure of heterogeneous mobile robotic systems: A bigactor approach. In IEEE
Systems Conference. IEEE, April 2013.
[69]
Ryszard Wawruch. Development of the coastal and global ships traﬃc monitoring
systems. In Telematics in the Transport Environment, pages 319–327. Springer, 2012.
[70]
Peter J. Ramadge and W. Murray Wonham. Supervisory control of a class of discrete
event processes. SIAM Journal on Control and Optimization, 25(1):206–230, January
1987.
[71]
Peter J. Ramadge and W. Murray Wonham. The control of discrete event systems.
Proceedings of the IEEE, 77(1):81–98, January 1989.
[72]
Basil Becker, Dirk Beyer, Holger Giese, Florian Klein, and Daniela Schilling. Symbolic
invariant veriﬁcation for systems with dynamic structural adaptation. Proceeding of
the 28th international conference on Software engineering - ICSE ’06, page 72, 2006.
[73]
Mavlink waypoint protocol.
http://qgroundcontrol.org/mavlink/waypoint_
protocol. Accessed: 2014-12-09.
[74]
H Abelson, D Allen, D Coore, C Hanson, G Homsy, T Knight, R Nagpal, E Rauch,
G Sussman, and R Weiss. Amorphous Computing. Communications of the ACM,
43(5):74–82, 2000.
[75]
Changhao Jiang and Peter Steenkiste. A hybrid location model with a computable
location identiﬁer for ubiquitous computing. In UbiComp 2002: Ubiquitous Computing,
pages 246–263. Springer, 2002.
[76]
Michele Sevegnani. Bigraphs with sharing and applications in wireless networks. PhD
thesis, University of Glasgow, 2012.
[77]
Bill Vaglienti, Ross Hoag, and Marius Niculescu. Piccolo system users guide. Cloud
Cap Technology, Oregon, 2005.

BIBLIOGRAPHY
129
[78]
G. Agha, I.A. Mason, S.F. Smith, and C.L. Talcott. A foundation for actor computa-
tion. Journal of Functional Programming, 7(1):1–72, 1997.
[79]
Emsa budget 2013. http://www.emsa.europa.eu/. Accessed: 2015-04-25.
[80]
Sally Ann Lentz and Fred Felleman. Oil spill prevention: a proactive approach. In
International Oil Spill Conference, volume 2003, pages 3–27. American Petroleum
Institute, 2003.
[81]
Popa George-Dorel. European maritime safety agency. Constanta Maritime University
Annals, 20(2):271–274, 2013.
[82]
Richard W Sanders. Probe for oil pollution evidence in the environment (popeie). In In-
ternational Oil Spill Conference, volume 2005, pages 1089–1093. American Petroleum
Institute, 2005.
[83]
Camilla Brekke and Anne HS Solberg. Oil spill detection by satellite remote sensing.
Remote sensing of environment, 95(1):1–13, 2005.
[84]
SkyTruth.
Bilge dumping?
busted using satellite images and ais data.
http:
//blog.skytruth.org/2012/06/bilge-dumping-busted-using-satellite.html,
June 2012.
[85]
SkyTruth.
Bilge dumping oﬀvietnam.
http://blog.skytruth.org/2012/02/
bilge-dumping-off-vietnam-february-22.html, February 2012.
[86]
Ingo Harre. AIS adding new quality to VTS systems. Journal of Navigation, pages
527–539, 2000.
[87]
Samuel Djavidnia and Jorge Del Rio Vera.
European maritime safety agency
cleanseanet activities in the baltic sea. 2012.
[88]
S Berescu. Marine environment protection through cleanseanet within black sea. Ma-
rine Navigation and Safety of Sea Transportation: Maritime Transport & Shipping,
page 59, 2013.
[89]
Marc Journel, Leedert Bal, Samuel Djavidnia, Heli Haapasaari, Anne Marie, Pedro
Lourenco, Machteld Price, and Olaf Trieschmann. CleanSeaNet: the EU remote sensing
based monitoring service for marine oil spill detection and surveillance in European
waters. In Fourth IMO R&D Forum on Hazardous and Noxious Substances (Interspill
2009), Marseille, France, 2009. International Maritime Organization.
[90]
Marin Chintoan-Uta and Marin Chintoan. Integrated maritime safety & surveillance
systems integrated maritime data environment (imdate) platform= emsa capability to
provide real time integrated maritime information services.

BIBLIOGRAPHY
130
[91]
J. Clark and R. Fierro. Cooperative hybrid control of robotic sensors for perimeter
detection and tracking. In American Control Conference, 2005. Proceedings of the
2005, pages 3500–3505 vol. 5, June 2005.
[92]
Richard Camilli, Christopher M Reddy, Dana R Yoerger, Benjamin AS Van Mooy,
Michael V Jakuba, James C Kinsey, Cameron P McIntyre, Sean P Sylva, and James V
Maloney.
Tracking hydrocarbon plume transport and biodegradation at deepwater
horizon. Science, 330(6001):201–204, 2010.
[93]
Victor Klemas. Tracking oil slicks and predicting their trajectories using remote sensors
and models: case studies of the sea princess and deepwater horizon oil spills. Journal
of Coastal Research, pages 789–797, 2010.
[94]
Shayok Mukhopadhyay, Chuanfeng Wang, Steven Bradshaw, Valerie Bazie, Sean
Maxon, Lisa Hicks, Mark Patterson, and Fumin Zhang. Controller performance of
marine robots in reminiscent oil surveys. In Intelligent Robots and Systems (IROS),
2012 IEEE/RSJ International Conference on, pages 1766–1771. IEEE, 2012.
[95]
P McGillivary, K Rajan, JB de Sousa, F Leroy, and R Martins.
Integrating au-
tonomous underwater vessels, surface vessels and aircraft as persistent surveillance
components of ocean observing studies. In Autonomous Underwater Vehicles (AUV),
2012 IEEE/OES, pages 1–5. IEEE, 2012.
[96]
Oliver Zielinski. Airborne pollution surveillance using multi-sensor systems: New sen-
sors and algorithms for improved oil spill detection and polluter identiﬁcation. Sea
Technology, 2003.
[97]
Samuel Djavidnia and Jorge Del Rio Vera.
European maritime safety agency
cleanseanet activities in the baltic sea. In Oil Pollution in the Baltic Sea, pages 41–51.
Springer, 2014.
[98]
Cleanseanet
-
how
it
works.
http://www.emsa.europa.eu/csn-menu/
csn-how-it-works.html. Accessed: 2015-04-25.
[99]
Olaf Trieschmann. Oil spill issue and the capability of monitoring the problem by
remote sensing. International conference on marine aﬀairs and the Law of the Sea,
page 169, 2008.
[100] Morgan Quigley, Ken Conley, Brian Gerkey, Josh Faust, Tully Foote, Jeremy Leibs,
Rob Wheeler, and Andrew Y Ng. Ros: an open-source robot operating system. In
Proc. ICRA Workshop on Open Source Software, volume 3, 2009.
[101] Jts topology suite.
http://sourceforge.net/projects/jts-topo-suite/.
Ac-
cessed: 2015-01-28.

