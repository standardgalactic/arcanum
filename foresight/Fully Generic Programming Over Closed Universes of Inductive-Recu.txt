Portland State University 
Portland State University 
PDXScholar 
PDXScholar 
Dissertations and Theses 
Dissertations and Theses 
Spring 6-6-2017 
Fully Generic Programming Over Closed Universes of 
Fully Generic Programming Over Closed Universes of 
Inductive-Recursive Types 
Inductive-Recursive Types 
Larry Diehl 
Portland State University 
Follow this and additional works at: https://pdxscholar.library.pdx.edu/open_access_etds 
 Part of the Computer Sciences Commons 
Let us know how access to this document benefits you. 
Recommended Citation 
Recommended Citation 
Diehl, Larry, "Fully Generic Programming Over Closed Universes of Inductive-Recursive Types" (2017). 
Dissertations and Theses. Paper 3647. 
https://doi.org/10.15760/etd.5531 
This Dissertation is brought to you for free and open access. It has been accepted for inclusion in Dissertations 
and Theses by an authorized administrator of PDXScholar. Please contact us if we can make this document more 
accessible: pdxscholar@pdx.edu. 

Fully Generic Programming
Over Closed Universes of Inductive-Recursive Types
by
Larry Diehl
A dissertation submitted in partial fulﬁllment of the
requirements for the degree of
Doctor of Philosophy
in
Computer Science
Dissertation Committee:
Tim Sheard, Chair
James Hook
Mark P. Jones
Andrew Tolmach
Robert Bass
Portland State University
2017

i
ABSTRACT
Dependently typed programming languages allow the type system to express
arbitrary propositions of intuitionistic logic, thanks to the Curry-Howard isomor-
phism. Taking full advantage of this type system requires deﬁning more types
than usual, in order to encode logical correctness criteria into the deﬁnitions of
datatypes. While an abundance of specialized types helps ensure correctness, it
comes at the cost of needing to redeﬁne common functions for each specialized
type.
This dissertation makes an eﬀort to attack the problem of code reuse in de-
pendently typed languages. Our solution is to write generic functions, which can
be applied to any datatype. Such a generic function can be applied to datatypes
that are deﬁned at the time the generic function was written, but they can also
be applied to any datatype that is deﬁned in the future. Our solution builds upon
previous work on generic programming within dependently typed programming.
Type theory supports generic programming using a construction known as a
universe. A universe can be considered the model of a programming language, such
that writing functions over it models writing generic programs in the programming
language. Historically, there has been a trade-oﬀbetween the expressive power of
the modeled programming language, and the kinds of generic functions that can
be written in it. Our dissertation shows that no such trade-oﬀis necessary, and
that we can write future-proof generic functions in a model of a dependently typed
programming language with a rich collection of types.

ii
ACKNOWLEDGMENTS
I would like to thank Tim Sheard, my advisor, for giving me the freedom to ex-
plore my own research interests, for always being available to listen and provide
constructive feedback, and for instilling in me the importance of thoroughly ex-
plaining background material, supplemented by plenty of examples.
I would also like to thank my parents, for supporting my decision to pursue aca-
demic interests, despite needing to abandon a lucrative job and career in software
development.
Finally, I would like to thank Conor McBride, for inspiring me to work on
the topic of generic programming. This inspiration is in part due to his academic
publications and artifacts resulting from the Epigram programme, and is in part
due to him warmly and enthusiastically welcoming a naive industry programmer.

iii
TABLE OF CONTENTS
Abstract
i
Acknowledgments
ii
List of Figures
ix
Color Conventions
x
Part I
Prelude
1
Chapter 1
Introduction
2
1.1 Dependently Typed Languages & Motivation
. . . . . . . . . . . . .
3
1.1.1 Curry-Howard Isomorphism
. . . . . . . . . . . . . . . . . . .
3
1.1.2 Indexed Types . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.1.3 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.2 A Taste of Fully Generic Programming . . . . . . . . . . . . . . . . .
6
1.2.1 Traditional Generic Programming . . . . . . . . . . . . . . . .
7
1.2.2 Fully Generic Programming . . . . . . . . . . . . . . . . . . . .
9
1.2.3 Universes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.2.4 Fully Generic versus Deriving . . . . . . . . . . . . . . . . . . .
14
1.3 Class of Supported Datatypes . . . . . . . . . . . . . . . . . . . . . .
14
1.3.1 Dependent Algebraic Types . . . . . . . . . . . . . . . . . . . .
14
1.3.2 Indexing versus Induction-Recursion . . . . . . . . . . . . . . .
15
1.3.3 Smallness versus Largeness . . . . . . . . . . . . . . . . . . . .
16
1.4 Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
1.4.1 Thesis Statement
. . . . . . . . . . . . . . . . . . . . . . . . .
18
1.4.2 Contributions
. . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.4.3 Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19

iv
Chapter 2
Types & Universes
24
2.1 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
2.1.1 Function Types
. . . . . . . . . . . . . . . . . . . . . . . . . .
25
2.1.2 Non-Inductive Types
. . . . . . . . . . . . . . . . . . . . . . .
26
2.1.3 Inductive Types . . . . . . . . . . . . . . . . . . . . . . . . . .
27
2.1.4 Parameterized Types
. . . . . . . . . . . . . . . . . . . . . . .
27
2.1.5 Indexed Types . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
2.1.6 Type Families . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
2.1.7 Derived Types . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
2.1.8 Inﬁnitary Types . . . . . . . . . . . . . . . . . . . . . . . . . .
34
2.1.9 Inductive-Recursive Types
. . . . . . . . . . . . . . . . . . . .
35
2.1.10 Algebraic Types . . . . . . . . . . . . . . . . . . . . . . . . . .
37
2.1.11 Computational Families . . . . . . . . . . . . . . . . . . . . . .
38
2.1.12 Open Types . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.1.13 Closed Types
. . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.2 Universes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.2.1 Universe Model
. . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.2.2 Open Universes
. . . . . . . . . . . . . . . . . . . . . . . . . .
41
2.2.3 Closed Universes . . . . . . . . . . . . . . . . . . . . . . . . . .
43
2.2.4 Inductive Universes . . . . . . . . . . . . . . . . . . . . . . . .
44
2.2.5 Non-Inductive Universes
. . . . . . . . . . . . . . . . . . . . .
44
2.2.6 Subordinate Universes . . . . . . . . . . . . . . . . . . . . . . .
45
2.2.7 Autonomous Universes
. . . . . . . . . . . . . . . . . . . . . .
45
2.2.8 Derived Universes . . . . . . . . . . . . . . . . . . . . . . . . .
46
2.2.9 Parameterized Universes
. . . . . . . . . . . . . . . . . . . . .
47
Chapter 3
Generic Programming
50
3.1 Parametric Polymorphism . . . . . . . . . . . . . . . . . . . . . . . .
51
3.1.1 Parametric over Types
. . . . . . . . . . . . . . . . . . . . . .
51
3.1.2 Parametric over Levels
. . . . . . . . . . . . . . . . . . . . . .
51
3.2 Ad Hoc Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . .
52
3.2.1 Ad Hoc by Overloading . . . . . . . . . . . . . . . . . . . . . .
52
3.2.2 Ad Hoc by Coercion . . . . . . . . . . . . . . . . . . . . . . . .
53
3.2.3 Ad Hoc by Overloading & Coercion . . . . . . . . . . . . . . .
54
3.3 Abstractness & Concreteness
. . . . . . . . . . . . . . . . . . . . . .
54
3.3.1 Abstract Types
. . . . . . . . . . . . . . . . . . . . . . . . . .
55

v
3.3.2 Concrete Types
. . . . . . . . . . . . . . . . . . . . . . . . . .
55
3.3.3 Abstract Data Types . . . . . . . . . . . . . . . . . . . . . . .
56
3.3.4 Fully Generic Programming . . . . . . . . . . . . . . . . . . . .
56
3.4 Totality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.4.1 Non-Dependent Domain Change . . . . . . . . . . . . . . . . .
57
3.4.2 Non-Dependent Codomain Change . . . . . . . . . . . . . . . .
58
3.4.3 Dependent Domain Change . . . . . . . . . . . . . . . . . . . .
58
3.4.4 Dependent Codomain Change
. . . . . . . . . . . . . . . . . .
59
3.4.5 Domain Predicates versus Domain Supplements
. . . . . . . .
60
Chapter 4
Closed Type Theory
62
4.1 Closed Vector Universe . . . . . . . . . . . . . . . . . . . . . . . . . .
63
4.1.1 Closed Vector Types
. . . . . . . . . . . . . . . . . . . . . . .
63
4.1.2 Fully Generic Functions . . . . . . . . . . . . . . . . . . . . . .
65
4.2 Closed Algebraic Universe . . . . . . . . . . . . . . . . . . . . . . . .
69
4.2.1 Closed Well-Order Types . . . . . . . . . . . . . . . . . . . . .
70
4.2.2 Open Well-Order Types . . . . . . . . . . . . . . . . . . . . . .
71
4.2.3 Inadequacy of Well-Orders . . . . . . . . . . . . . . . . . . . .
73
Part II
Open Type Theory
76
Chapter 5
Open Algebraic Universes
77
5.1 Open Non-Dependent Types . . . . . . . . . . . . . . . . . . . . . . .
79
5.1.1 Categorical Model . . . . . . . . . . . . . . . . . . . . . . . . .
79
5.1.2 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
5.1.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
5.2 Open Inﬁnitary Types . . . . . . . . . . . . . . . . . . . . . . . . . .
91
5.2.1 Categorical Model . . . . . . . . . . . . . . . . . . . . . . . . .
91
5.2.2 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
5.2.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
96
5.3 Open Dependent Types
. . . . . . . . . . . . . . . . . . . . . . . . .
99
5.3.1 Categorical Model . . . . . . . . . . . . . . . . . . . . . . . . .
99
5.3.2 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
5.3.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
5.4 Open Inductive-Recursive Types
. . . . . . . . . . . . . . . . . . . . 111
5.4.1 Categorical Model . . . . . . . . . . . . . . . . . . . . . . . . . 112

vi
5.4.2 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
5.4.3 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
5.4.4 Agda Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Part III
Closed Type Theory
133
Chapter 6
Closed Algebraic Universe
134
6.1 Open Inductive-Recursive Types
. . . . . . . . . . . . . . . . . . . . 135
6.1.1 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
6.1.2 Source of Openness . . . . . . . . . . . . . . . . . . . . . . . . 137
6.2 Closed Inductive-Recursive Types . . . . . . . . . . . . . . . . . . . . 139
6.2.1 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
6.2.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
6.2.3 Kind-Generalized Universes . . . . . . . . . . . . . . . . . . . . 150
6.3 How to Close a Universe . . . . . . . . . . . . . . . . . . . . . . . . . 152
6.3.1 Procedure
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
6.3.2 Example Procedure Run
. . . . . . . . . . . . . . . . . . . . . 153
6.4 Types versus Kinds . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.4.1 Open Types and Kinds . . . . . . . . . . . . . . . . . . . . . . 157
6.4.2 Gratuitous Kinds
. . . . . . . . . . . . . . . . . . . . . . . . . 160
6.4.3 Types versus Descriptions . . . . . . . . . . . . . . . . . . . . . 161
6.4.4 Kind-Parameterized Types . . . . . . . . . . . . . . . . . . . . 162
Chapter 7
Fully Generic Functions
167
7.1 Fully Generic Count . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
7.1.1 Generic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
7.1.2 Counting All Values . . . . . . . . . . . . . . . . . . . . . . . . 172
7.1.3 Counting Algebraic Arguments . . . . . . . . . . . . . . . . . . 173
7.1.4 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
7.2 Fully Generic Lookup
. . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.2.1 Generic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
7.2.2 Looking Up All Values
. . . . . . . . . . . . . . . . . . . . . . 188
7.2.3 Looking Up Algebraic Arguments
. . . . . . . . . . . . . . . . 190
7.2.4 Splitting Functions
. . . . . . . . . . . . . . . . . . . . . . . . 193
7.2.5 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3 Fully Generic AST . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

vii
7.3.1 Generic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
7.3.2 Marshalling Initial Algebras
. . . . . . . . . . . . . . . . . . . 200
7.3.3 Marshalling All Values
. . . . . . . . . . . . . . . . . . . . . . 201
7.3.4 Marshalling Algebraic Arguments
. . . . . . . . . . . . . . . . 202
7.3.5 Generic Template . . . . . . . . . . . . . . . . . . . . . . . . . 204
Chapter 8
Closed Hierarchy of Universes
206
8.1 Closed Hierarchy of Well-Order Types . . . . . . . . . . . . . . . . . 209
8.1.1 Formal Model . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
8.1.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
8.1.3 Agda Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
8.2 Closed Hierarchy of Inductive-Recursive Types
. . . . . . . . . . . . 220
8.2.1 Agda Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
8.2.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
8.3 Leveled Fully Generic Functions . . . . . . . . . . . . . . . . . . . . . 235
8.3.1 Counting in Universe Zero
. . . . . . . . . . . . . . . . . . . . 236
8.3.2 Counting in Universe One
. . . . . . . . . . . . . . . . . . . . 238
8.3.3 Leveled Generic Template . . . . . . . . . . . . . . . . . . . . . 241
Part IV
Postlude
243
Chapter 9
Related Work
244
9.1 Fixed Open or Closed Universes . . . . . . . . . . . . . . . . . . . . . 244
9.2 Extendable Open or Closed Well-Order Universes . . . . . . . . . . . 246
9.3 Extendable Open Algebraic Universes
. . . . . . . . . . . . . . . . . 247
9.4 Previous Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
Chapter 10 Future Work
253
10.1 Universe Polymorphism
. . . . . . . . . . . . . . . . . . . . . . . . . 253
10.2 Large Induction-Recursion . . . . . . . . . . . . . . . . . . . . . . . . 254
10.3 Induction-Induction
. . . . . . . . . . . . . . . . . . . . . . . . . . . 255
10.4 High-Level Generic Programming . . . . . . . . . . . . . . . . . . . . 255
10.5 Eﬃcient Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 256
10.6 Termination of Intensional Closed Type Theory . . . . . . . . . . . . 256
10.7 Inductive Deﬁnitions over Inﬁnitary Domain . . . . . . . . . . . . . . 257
Chapter 11 Conclusion
258

viii
References
260
Appendices
267
Appendix A
Open Non-Algebraic Types
267
Appendix B
Open Universe of Algebraic Types
268
Appendix C
Closed Universe of Algebraic Types
269
Appendix D
Closed Hierarchy of Universes
270
Appendix E
Internalized Constructor Signatures
273

ix
LIST OF FIGURES
7.1 The natural number 1, as a closed algebraic type. . . . . . . . . . . . 178
7.2 The natural number 2, as a closed algebraic type. . . . . . . . . . . . 179
7.3 The length-1 vector of pairs of strings [("a", "x")], as a closed
algebraic type.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
7.4 The length-2 vector of pairs of strings [("a", "x"), ("b", "y")],
as a closed algebraic type. . . . . . . . . . . . . . . . . . . . . . . . . 184
7.5 Deﬁnitions of the helper splitting functions (splitΣ, splitσ, and splitδ)
used in Section 7.2.2 and Section 7.2.3.
The helpers are all just
shallow wrappers around the splitFin function (Section 7.2.4).
. . . . 195
7.6 The inductive-recursive component of the length-1 vector of pairs of
strings [("b", "y")], as a closed algebraic type. This ﬁgure depicts
the inductive-recursive ﬁrst component of the vector encoded as a
dependent pair (the second component is the length constraint). . . . 197
8.1 Closed natural number deﬁnitions in universe level 0. . . . . . . . . . 236
8.2 Fully generic counting of values (count) and algebraic arguments
(counts) in universe level 0.
. . . . . . . . . . . . . . . . . . . . . . . 237
8.3 Fully generic counting of values (Count) and algebraic arguments
(Counts) in universe level 1. . . . . . . . . . . . . . . . . . . . . . . . 239
8.4 Fully generic counting of types (CountSet) and algebraic arguments
(CountDesc) in universe level 1. . . . . . . . . . . . . . . . . . . . . . 240

x
COLOR CONVENTIONS
This dissertation can be read in black and white, but it beneﬁts from being read
in color. The main programming language used in this dissertation is Agda, which
is dependently typed.
Agda does not use any syntactic conventions, like capi-
talization, to distinguish identiﬁers of various program elements, like datatypes,
deﬁnitions, and constructors (this is partially due to the fact most program ele-
ments can be legally used at both the type and value levels of the dependently
typed language).
Knowing which program element an identiﬁer stands for depends on the envi-
ronment. In other words, readers of the black and white version of the dissertation
can check previous deﬁnitions to see what an identiﬁer was declared as, in or-
der to understand a particular piece of code. Readers of the colored version of the
dissertation can understand a piece of code by being aware of color conventions (de-
scribed below), without needing to consult previous deﬁnitions of identiﬁers. The
Agda system keeps track of what identiﬁers were declared as in the environment,
allowing the appropriate color to be emitted when displaying syntax highlighted
code (because the syntax highlighting depends on the environment, it may make
sense to think of the output of Agda as semantics highlighted code).
We use the following Agda source code highlighting color conventions: Keywords
are orange, comments are red (and preﬁxed by a dash), strings are red (and
enclosed in quotes), datatypes are dark blue, deﬁnitions are light blue, constructors
are green, record projections are pink, and variables are purple.

1
Part I
Prelude

2
Chapter 1
INTRODUCTION
In this dissertation we expand the class of functions that can be written generically
for all types, in a type-safe manner, within a dependently typed language [3, 39].
Below, we contrast traditional generic programming [5, 32] with the approach we
describe in this thesis, which we call fully generic programming.
Traditional Generic Programming
Traditional generic programming cap-
tures the pattern of folding an algebra through the inductive occurrences of an
algebraic datatype. For example, we could write a generic size function, that can
be applied to any datatype. For any constructor of any datatype, size returns 1
plus the sum of:
⋄The number of non-inductive arguments.
⋄The recursive size of the inductive arguments.
Applying size to a single-element list containing a pair of booleans ((True, False):[])
results in 3: the sum of the cons constructor, the pair, and the nil constructor. Be-
cause the pair is a non-inductive argument from the perspective of the list, its size
is counted atomically as 1 (it would be counted as 1 even if it were a value of an
inductive datatype other than lists, like a tree, since it is not inductive with respect
to lists).
Fully Generic Programming
Fully generic programming (Section 3.3.4) cap-
tures the pattern of folding an algebra through both the non-inductive and in-
ductive occurrences of an algebraic datatype. For example, we could write a fully

3
generic count function that can also be applied to any datatype. For any construc-
tor of any datatype, count returns 1 plus the sum of:
⋄The recursive count of the non-inductive arguments.
⋄The recursive count of the inductive arguments.
Applying count to a single-element list containing a pair of booleans ((True,
False):[]) results in 5: the sum of the cons constructor, the pair (,) constructor,
the two booleans constructors, and the nil constructor. Notably, count (unlike size)
additionally recurses through the components of the pair.
In the remainder of this introduction we provide an overview of dependently
typed languages and motivate our work (Section 1.1), give an example of fully
generic programming over a limited collection of datatypes (Section 1.2), describe
the class of datatypes that we have been able to extend the fully generic pro-
gramming approach to (Section 1.3), and ﬁnally cover our thesis statement and
contributions (Section 1.4).
1.1
DEPENDENTLY TYPED LANGUAGES & MOTIVATION
A standard dependently typed language [38, 45] is purely functional (meaning an
absence of side eﬀects), total (meaning all inductively deﬁned functions terminate
and cover all possible inputs), and has a type system that captures the notion of
dependency. In this thesis we use the dependently typed language Agda [47] for
all of our developments.1
1.1.1
Curry-Howard Isomorphism
A single term language is used to write programs at the value and type levels. The
combination of total programming at the type level and a notion of dependency
1 This dissertation is written as a literate Adga program. The literate Agda source ﬁle and
accompanying code can be found at: https://github.com/larrytheliquid/thesis

4
between types allows any proposition of intuitionistic logic to be expressed as a
type.
A value (or equivalently, a total program) inhabiting a type encoding a
proposition serves as its intuitionistic proof. This correspondence between values
and types, and proofs and propositions, is known as the Curry-Howard isomor-
phism [33]. For example, below we compare universally quantiﬁed propositions to
dependent function types, and existentially quantiﬁed propositions to dependent
pair types.
∀x. P(x) ≈(x : A) →P x
∃x. Q(x) ≈Σ A (λ x →Q x)
Using the Curry-Howard isomorphism, we can encode logical preconditions and
postconditions at the type level. For example, below we give the type of a lookup
function over lists with a precondition constraining the natural number (n) index
to be less than the length of the list (xs) being looked up. This allows an otherwise
partial lookup function to be deﬁned totally by preventing out-of-bounds indexing.
lookup : (n : N) (xs : List A) →n < length xs →A
As another example, we give the type of an append function over lists with a
postcondition constraining the length of the output list (zs) to be equal to the sum
of the lengths of the input lists (xs and ys).
append : (xs ys : List A) →Σ (List A) (ń zs →length zs ≡length xs + length ys)
The types of lookup and append correspond to the following two logical propo-
sitions respectively.
∀n, xs. n < |xs| ⇒∃x. ⊤
∀xs, ys. ∃zs. |zs| = |xs| + |ys|

5
1.1.2
Indexed Types
The less-than (<) precondition and equality (≡) postcondition in the examples
above are relations in the language of logic, and are called indexed types [19, 20]
in the language of dependent types. Indexed types are (commonly) types whose
arguments are values (rather than types). For example, less-than (<) takes two
natural number (N) arguments, and equality (≡) takes two values of some type A.
Rather than constraining a datatype (like lists) using relations after-the-fact, we
can create more speciﬁc (i.e., indexed) variants of datatypes that encode certain
properties before-the-fact.
For example, the type of vectors (Vec A n) is like a length-indexed version of
lists. Compared to lists, the type former of vectors gains an additional natural
number parameter (n) constraining its length. Because the property of the length
of a vector is encoded at the type level, we can write a variant of append where
calls to length have been replaced by an index.
append : (m n : N) (xs : Vec A m) (ys : Vec A n) →Vec A (m + n)
Additionally, the explicit equality proof (≡) postcondition can be dropped in
favor of expressing the postcondition directly in the index position of the output
vector. In other words, the extrinsic equality postcondition has been dropped in
favor of an intrinsic property about the codomain of append.
Another example of an indexed type is the type of ﬁnite sets (Fin n), indexed
by a natural number constraining the size of the ﬁnite set. A ﬁnite set is like
a subset of the natural numbers from 0 to n - 1. This subset property (whose
maximum value is n - 1) is the perfect datatype to act as an intrinsic version
of the extrinsic less-than (<) precondition of lookup. Hence, we can rewrite an
intrinsic-precondition version of lookup using vectors and ﬁnite sets as follows.
lookup : (n : N) (xs : Vec A n) (i : Fin n) →A

6
1.1.3
Motivation
Programmers of non-dependently typed languages already struggle with the issue
of needing to deﬁne logically similar versions of functions (like count, lookup, etc.)
for their various algebraic types (e.g., natural numbers, lists, binary trees, etc.).
This problem is more pronounced in a dependently typed language, where pro-
grammers also deﬁne indexed variants of types (e.g., ﬁnite sets, vectors, balanced
binary trees, etc.) that intrinsically capture preconditions and postconditions.
Rather than punishing programmers for creating new datatypes, our moti-
vation is to reward them with fully generic functions (like count, lookup, etc.),
which are new mechanisms for code reuse. Fully generic functions are predeﬁned
once-and-for-all to work with any datatype of the language, whether it is deﬁned
now or will be deﬁned in the future. Programmers deﬁning new types should be
able to apply fully generic functions to them, and programmers should also be able
to deﬁne new fully generic functions themselves.
1.2
A TASTE OF FULLY GENERIC PROGRAMMING
Generic programming in dependently typed languages [3, 39] is accomplished using
a construction known as a universe (Section 2.2). Rather than explaining how
universes work in detail (which we do in Section 2.2) in this introduction, we
develop our dependently typed Agda examples using universes in parallel with
examples in Haskell [35] using type classes [30, 36]. Later we learn why our analogy
with Haskell type classes makes sense, as ad hoc polymorphism (Section 3.2) is a
form of generic programming.
In the following, we ﬁrst develop the size function using traditional generic
programming (in Haskell and Agda), and then develop the count function using
fully generic programming (albeit over a ﬁxed and small language, and also in
Haskell and Agda), both described in the introduction.

7
1.2.1
Traditional Generic Programming
Recall (from the introduction) that size returns the sum of all inductive construc-
tors, inductive arguments, and non-inductive arguments. Notably, size only re-
curses into inductive constructor arguments.
Haskell
In Haskell, we start by deﬁning a type class (Size) for the size function.
class Size a where
size :: a -> Int
The size of a boolean is just 1. This is because it has no other non-inductive
or inductive arguments to sum.
instance Size Bool where
size b = 1
The size of a pair is 3, which is the sum of the pair constructor (1) and both
of its non-inductive arguments (1 + 1).
instance Size (a, b) where
size (a, b) = 3
The size of an empty list is just 1, because it has no arguments. The size of a
“cons” is the sum of the “cons” constructor (1), its single non-inductive argument
(1), and the recursive size of its single inductive argument.
instance Size [a] where
size [] = 1
size (x : xs) = 2 + size xs
Note that the Size type class is just ad hoc polymorphism by overloading
(Section 3.2.1), as each of its instances can be deﬁned independently because they
only recurse into inductive arguments.

8
Agda
In Agda, we start by declaring a new type (Size), which is a syntactic
reiﬁcation of the types we wish to generically program size for. Unlike the Haskell
version, we must choose the types for which we will provide “instances” upfront.
data Size : Set1 where
‘Bool : Size
‘Pair : (A B : Set) →Size
‘List : (A : Set) →Size
Each constructor of Size is not a type, but rather an encoding of a type. Next,
we deﬁne a function (J_K) that interprets each encoded Size type as an actual Agda
type (i.e., a Set).
J_K : Size →Set
J ‘Bool K = Bool
J ‘Pair A B K = A × B
J ‘List A K = List A
We can generically deﬁne size as a dependent function from a code (A : Size),
to a value of the encoded type (J A K), to a number (N). We case-analyze the ﬁrst
(Size) argument of size to distinguish each diﬀerent “instance”. After that, each
second argument and body follows the same logic as the instances in the Haskell
version above.
size : (A : Size) →J A K →N
size ‘Bool b = 1
size (‘Pair A B) (a , b) = 3
size (‘List A) nil = 1
size (‘List A) (cons x xs) = 2 + size (‘List A) xs
A signiﬁcant diﬀerence with the Haskell version is that we supply the encoded
type explicitly in recursive calls (i.e., ‘List A in the cons case).2
2 It is possible to make this an implicit argument so the Agda surface language also infers
it. However, the argument would still be explicit in the underlying core language to which the
surface language elaborates.

9
1.2.2
Fully Generic Programming
Recall (from the introduction) that count returns the sum of all inductive con-
structors, non-inductive constructors, inductive arguments, and non-inductive ar-
guments. Notably, count recurses into inductive and non-inductive constructor
arguments.
Haskell
Again, we start by deﬁning a Haskell type class (Count) for the count
function.
class Count a where
count :: a -> Int
The count of a boolean is still 1, because it has no arguments.
instance Size Bool where
size b = 1
The count of a pair is the sum of the pair constructor (1), and the recur-
sive count of both of its non-inductive arguments. Notably, count (unlike size)
recurses into its non-inductive arguments.
instance (Count a, Count b) => Count (a, b) where
count (a, b) = 1 + count a + count b
The count of an empty list is still 1. The count of a “cons” is the sum of the
“cons” constructor (1), the recursive count of its single non-inductive argument,
and the recursive count of its single inductive argument. Notably, count (unlike
size) recurses into its non-inductive argument.
instance (Count a) => Count [a] where
count [] = 1
count (x : xs) = 1 + count x + count xs

10
The Count instances for pairs and lists are able to recurse into their non-
inductive arguments because they have type class premises for their type parame-
ters (e.g., the left of the arrow in (Count a) => Count [a] in the list instance).
This allows instances of one type to recurse into instances of other types, and is
called ad hoc polymorphism by coercion (Section 3.2.2). The etymology of the
name is the idea that count for lists can be deﬁned by “coercing” the meaning of
count for the parameter type of the lists.
Agda
In Agda, we declare a new type (Count), reifying the types over which
we will generically program count. Unlike Size, Count is an inductive type, as the
arguments to ‘Pair and ‘List are inductive (i.e., the A and B arguments have type
Count below, but they have type Set in the Size datatype).
data Count : Set where
‘Bool : Count
‘Pair : (A B : Count) →Count
‘List : (A : Count) →Count
The types encoded by Count are interpreted (by the J_K function) as actual
Agda types. The J_K function interprets the inductive arguments of ‘Pair and ‘List
(representing datatype parameters) recursively.
J_K : Count →Set
J ‘Bool K = Bool
J ‘Pair A B K = J A K × J B K
J ‘List A K = List J A K
In Haskell, the Count instances for pairs and lists have Count type class premises
for their type parameters. This allows count to recurse into non-inductive argu-
ments of the parameterized types. In Agda, count can recurse into non-inductive ar-
guments (in addition to the inductive arguments) because its parameterized types

11
are encoded inductively in Count.
count : (A : Count) →J A K →N
count ‘Bool b = 1
count (‘Pair A B) (a , b) = 1 + count A a + count B b
count (‘List A) nil = 1
count (‘List A) (cons x xs) = 1 + count A x + count (‘List A) xs
The logic of count closely follows that of the count instances, except encoded
types are explicitly supplied in recursive calls. Signiﬁcantly, count has access to
Count type encodings (A and B) in the pair (,) and cons cases, and these type
encodings are supplied to recursive calls of non-inductive arguments (a, b, and x).
Finally, count still recurses into the inductive argument xs in the cons case using
the encoded type ‘List A.
1.2.3
Universes
In Agda, generic programming (like the count function) is accomplished using
a universe (Section 2.2).
A universe is the combination of a type of codes for
types (e.g., Count) and a meaning function (e.g., J_K) mapping codes to actual
types. Generic functions (over all types of the universe) are dependent function
parameterized over all type codes (Code below) and the meaning (Meaning below)
of the particular code supplied.
(c : Code) (m : Meaning c) →...
Fixed Types Universe
In the count example (using the Count universe), we
have a seen how to perform a limited version of fully generic programming, in
which recursion into both non-inductive and inductive arguments is possible. The
problem with the Count universe is that it is ﬁxed to a particular collection of
types, chosen ahead of time.
We can add more types (as in Section 2.2.3) to this universe (like natural

12
numbers, vectors, ﬁnite sets, dependent pairs, dependent functions, etc), naming
the new type of codes Type, until it contains enough types to model a depen-
dently typed language with a primitive collection of built-in types. Fully generic
programming over this universe then models fully generic programming over the
entire language modeled by the universe:
(A : Type) (a : J A K) →...
However, most modern dependently typed language allow users to declare new
algebraic datatypes. The Type universe does not model a language with datatype
declarations, as users can only work with the built-in types that have been ﬁxed
ahead of time.
Extensible Algebraic Types Universe
Alternatively, we may deﬁne a uni-
verse that models algebraic datatypes (as in Section 5.3). We call the type of codes
for this universe Desc, as they describe algebraic datatype declarations. The mean-
ing function for this universe, named µ, interprets a declaration as the declared
type.3 The Desc universe models an extensible collection of algebraic datatypes.
Generic programming over this universe allows users to write functions that can
be applied to any algebraic datatype a user might declare (whether the type is
already declared now or will be declared in the future):
(D : Desc) (x : µ D) →...
Actually, dependently typed languages can only contain the strictly positive
(Section 2.1.8) subset of algebraic datatypes (this restriction keeps the language
total, hence consistent as a logic under the Curry-Howard isomorphism). A conse-
quence of deﬁning Desc as a strictly positive datatype is that generic programming
3 As we see in the next section, another way to think about Desc is a reiﬁcation of pattern
functors from initial algebra semantics, whose least ﬁxed point is calculated by µ.

13
over it corresponds to ordinary generic programming (like the size function), in
which recursion is restricted to inductive arguments.
Fixed Types Closed Under Algebraic Extension Universe
A primary
contribution of this thesis is deﬁning a universe that combines the ﬁxed collection of
built-in types universe (Type) with the extensible collection of algebraic datatypes
universe (Desc), in a way that supports fully generic programming (while remaining
consistent under the Curry-Howard isomorphism).
One important property of what makes fully generic programming possible in
Count is that the arguments to its codes (i.e., the arguments to ‘Pair and ‘List) are
inductive. This makes Count a universe of booleans closed under pair formation and
list formation. Closure properties are an important deﬁning feature of a universe.
The key to deﬁning our combined universe it to make the Type universe not
only closed under expected types (like dependent pairs and dependent functions),
but also closed under algebraic datatype formation (µ) from datatype declarations
(Desc). The details of how to make this work are beyond the scope of this intro-
duction (see Section 6.2 for the full construction). However, the central idea has
to do with deﬁning the Type and Desc universes mutually. Thus, fully generic pro-
gramming over this mutual universe corresponds to writing mutually dependent
functions over the following type signatures:
(A : Type) (a : J A K) →...
(D : Desc) (x : µ D) →...
Essentially, in our mutual universe Type is closed under Type formers (like ‘µ)
that can have Desc arguments, and Desc is closed under Desc formers that can
have Type arguments. The consequence of our closed universe is that it models
a dependently typed language supporting datatype declarations and fully generic
programming.

14
1.2.4
Fully Generic versus Deriving
Finally, we would like to make an analogy: Having access to fully generic functions
(e.g., count) deﬁned for all possible types is like deriving a type class instance for
a datatype in Haskell. In both cases, users get to declare a new datatype and have
access to functions operating over it (i.e., fully generic count or derived count) for
free.
The big diﬀerence is that users of a closed but extensible dependently typed
language (like a variant of Agda) may deﬁne fully generic functions themselves.
Furthermore, because these are ordinary dependent functions deﬁned within the
language, they are ensured to be type-safe. In contrast, users of a non-dependently
typed language like Haskell must rely on compiler writers to provide them with
derivable functions for a ﬁxed collection of type classes.
1.3
CLASS OF SUPPORTED DATATYPES
Previously (in Section 1.2) we introduced the idea of fully generic programming
over a mutually deﬁned universe, encoding a ﬁxed collection of primitive types and
an extensible collection of algebraic datatypes. This section addresses the following
question: What properties of algebraic datatypes should we support to adequately
describe all possible types deﬁnable in a dependently typed language like Agda?
We explain why we choose inductive-recursive types, instead of indexed types,
as the answer to this question. Non-expert readers may wish to skim this section
and come back to it after ﬁnishing Part I: Prelude.
1.3.1
Dependent Algebraic Types
We certainly want to support algebraic datatypes with dependencies between their
arguments. In a non-dependent language like Haskell, the types of all arguments to
constructors of an algebraic datatype can be deﬁned independently. In Agda, the

15
types of subsequent constructor arguments can depend on the values of previous
constructor arguments.
There are 2 common generic encodings (i.e., semantic
models) of dependent algebraic datatypes:
⋄Containers (Section 4.2.2) These are data structures that represent types
using an analogy of shapes (capturing inductive structure) and positions
(capturing contained values).
The least ﬁxed points of containers [1] are
well-orderings [21], or W types.
⋄Dependent Polynomials (Section 5.3) These are pattern functors [26] from
initial algebra semantics, whose least ﬁxed point is returned by the µ oper-
ator. The Desc type of Section 1.2 is a syntactic reiﬁcation of dependent
polynomial pattern functors, whose meaning function is µ when considered
as a universe of dependent algebraic types.
A universe closed under W types, supporting fully generic programming, is
trivial to deﬁne (Section 4.2.1). Unfortunately, while W types adequately encode
algebraic types in Extensional Type Theory (as implemented by NuPRL [9]), they
inadequately [40] (Section 4.2.3) encode ﬁrst-order algebraic types in Intensional
Type Theory (as implemented by Agda [47]). For this reason, we choose depen-
dent polynomials to model dependent algebraic types.
1.3.2
Indexing versus Induction-Recursion
Besides supporting algebraic types with dependencies between arguments, Agda
also supports algebraic types capturing intrinsic correctness properties.
There
are 2 main special kinds of algebraic types used to capture intrinsic correctness
properties:
⋄Indexed Types (Section 2.1.5) These are collections of algebraic types,
indexed by some type I, such that each type in the collection may vary for
any particular value of I. For example, Vectors of A values are indexed by

16
the natural numbers and map to lists whose lengths are constrained to equal
the natural number index.
⋄Inductive-Recursive Types (Section 2.1.9) These are algebraic datatypes
mutually deﬁned with a decoding function whose domain is the algebraic
type and codomain is some type O. For example, Arithmetic expressions
(Section 2.1.9) of “Big Pi” formulae are an inductive-recursive type, mutually
deﬁned with an evaluation function (as their decoding function) returning the
number they encode. The upper bound of “Big Pi” arithmetic expressions is
calculated using the mutually deﬁned evaluation function.
Somewhat surprisingly, indexed types [19, 20] and inductive-recursive types [22,
23] deﬁne isomorphic classes of datatypes [31]. That is, any indexed type (like Vec)
can be deﬁned as an inductive-recursive type, and any inductive-recursive type (like
Arith) can be deﬁned as an indexed type.
Thus, picking either indexed or inductive-recursive types is adequate to capture
all of the algebraic types we would like to encode in our closed universe. We choose
inductive-recursive types because there is little research on using them to even
do traditional generic programming, so we hope to make inductive-recursive types
more popular by providing more examples of programming with them.
1.3.3
Smallness versus Largeness
There are two more signiﬁcant reasons why picking induction-recursion to showcase
generic programming is important. The ﬁrst is merely an issue of encoding, but the
second emphasizes that the isomorphism between indexed and inductive-recursive
does not scale to “large” cases, deﬁned below:
⋄Intensionality Even though indexed and inductive-recursive types are iso-
morphic, encoding “naturally” inductive-recursive types (like Arith) as in-
dexed types means reasoning about the low-level encoding rather than the

17
high-level intended type deﬁnition. Similarly, writing generic functions over
inductive-recursive types produces more “natural” results when applied to
“naturally” inductive-recursive types, as opposed to encoded indexed types.
⋄Largeness In this thesis we only cover small closed universe fully generic
programming, meaning the codomain of the inductive-recursive decoding
function is a type (like the natural numbers). In contrast, large inductive-
recursive types may have kinds (Set) as the codomain of their decoding func-
tions. The isomorphism between indexed and inductive-recursive types no
longer applies in the large case. Therefore, fully generic programming over
small inductive-recursive types may serve as a guide for how to do it in
the large case (where one cannot simply use indexed types and apply the
isomorphism).
Our arguments (the intensionality of functions and the lack of an isomorphism
in the large case) could also be used to justify choosing indexed types (where
we consider “naturally” indexed types and large type indices). Once again, we
choose inductive-recursive because they are less studied in the generic programming
literature.
Finally, because the isomorphism fails in the large case, the ideal choice would
be to use indexed inductive-recursive [24] algebraic types. These are a 3rd
option for expressing intensional correctness properties of datatypes, where both
indexing and induction-recursion are expressed naturally.4 While it is not tech-
nically challenging to extend our work on fully generic programming over closed
universes to indexed inductive-recursive types, we do not do this for pedagogical
reasons. The necessary background material to explain this combined approach,
and the resulting complexity it introduces in generic functions and examples, would
4 Interestingly, even indexed inductive-recursive types are isomorphic to indexed types and
inductive-recursive types in the small case [31].

18
obscure our lessons on how to deﬁne closed universes and perform fully generic pro-
gramming.
1.4
THESIS
Now we cover our thesis statement, contributions, and outline the remainder of
the dissertation.
1.4.1
Thesis Statement
Fully generic programming, supporting functions deﬁned by recursion into all
non-inductive and inductive constructor arguments of all types in the universe, is
possible over a universe that:
⋄(Section 6.2) Models a dependently typed language (or type theory, sup-
porting the Curry-Howard isomorphism) with datatype declarations.
⋄(Section 5.4) Adequately (in intensional type theory) models small inductive-
recursive algebraic types via initial algebra semantics (in contrast to the
inadequate model of ﬁrst-order types in the universe of Section 4.2).
⋄(Section 3.3.4) Supports the elimination of all (i.e., inductive and non-inductive)
values by:
– (Section 2.2.4) being inductively deﬁned, allowing types to be closed
under other types.
– (Section 2.2.3) being closed, by not containing values deﬁned using Set.
– (Section 2.2.7) being autonomous, by only containing values whose
types are in the universe.
– (Section 3.3.2) being concrete, by only containing types that have some
elimination principle.

19
1.4.2
Contributions
We make the following 3 primary contributions to the ﬁeld of generic programming
using dependently typed languages:
1. Deﬁning (Chapter 6) a closed universe (in Section 6.2), as an adequate
model of a dependently typed language with datatype declarations for inductive-
recursive types, supporting fully generic programming. Additionally, we de-
ﬁne a procedure (in Section 6.3) to close any universe.
2. Examples (Chapter 7) of writing fully generic functions over all values of
our universe, including count (in Section 7.1), lookup (in Section 7.2), and
marshalling (ast, in Section 7.3) to an abstract syntax tree.
3. Extending (Chapter 8) our closed universe to a closed hierarchy of uni-
verses (in Section 8.2), supporting fully generic functions over all types in
the universe hierarchy (in addition to values), via fully generic programming
at any universe level (in Section 8.3).
1.4.3
Outline
The dissertation is broken up into 4 parts, the Prelude, a part on Open Type
Theory, a part on Closed Type Theory, and the Postlude:
Part I: Prelude
The prelude reviews background information on dependently typed programming,
and serves as a mini-version of our dissertation, in a simpliﬁed but unfortunately
inadequate setting.
Chapter 1: Introduction
This chapter concludes the introduction. We already
reviewed dependently typed languages, and how code reuse serves as our motiva-
tion (Section 1.1). We also demonstrated what fully generic programming looks

20
like in a limiting setting, and compared how it works in Agda with how it works
in Haskell (Section 1.2). Finally, we explained why we chose inductive-recursive
types as the class of algebraic types we wish to write fully generic functions over
(Section 1.3).
Chapter 2: Types & Universes
We review the concept of types (Section 2.1)
and universes (Section 2.2) in type theory. In particular, we classify both types
and universes according to a detailed account of various properties they can have.
Chapter 3:
Generic Programming
We clarify what we mean by generic
programming (i.e., programming over many types, using various forms of polymor-
phism [51]), because the meaning of this term is overloaded. We compare and
contrast generic programming as parametric polymorphism (Section 3.1) and ad
hoc polymorphism (Section 3.2). Additionally, we introduce the idea of concrete-
ness (Section 3.3) to help clarify what we mean by fully generic programming.
Programming total functions in type theory can be non-trivial, especially as the
class of types we program over expands during generic programming, so we review
techniques to make total programming possible (Section 3.4).
Chapter 4: Closed Type Theory
This chapter contains examples of closed
type theories (i.e., those that do not contain Set) supporting fully generic program-
ming. We present (Section 4.1) the closed type theory of Closed Vector Types,
modeling a language with a built-in collection of types related to vector oper-
ations. We show how to write a fully generic sum function over the language of
Closed Vector Types. Then we present (Section 4.2) the closed type theory of Closed
Well-Order Types, modeling a language with algebraic datatype declarations. Un-
fortunately, while this closed universe model is easy to deﬁne and supports fully
generic programming, the W type it uses to model algebraic types is inadequate for
our purposes. Even though W types are inadequate for our purposes, it is helpful

21
to understand a closed universe of dependent types in this simpler setting, before
understanding the more complicated (but adequate) version in Chapter 6.
Part II: Open Type Theory
In this part we focus on modeling algebraic datatypes in open type theory, whose
collection of types grows as more types are declared. While algebraic types deﬁned
using W are inadequate (in open type theory and closed type theory), types deﬁned
using initial algebra semantics are not. This part explains how to model initial
algebra semantics in type theory (by deﬁning the Desc and µ types), which is much
more involved than deﬁning the W type.
Chapter 5: Open Algebraic Universes
In this chapter we progress through
a series of initial algebra semantics for incrementally more expressive classes of
datatypes, starting with non-dependent algebraic types and ending with inductive-
recursive types. We motivate the (formal) type theory models with their category
theory equivalents. We also give examples of modeling values, not just types, using
initial algebra semantics.
Part III: Closed Type Theory
In this part we switch back to closed type theory, returning back to the setting
from which we diverged in Section 4.2.1, but this time using an adequate equivalent
of the language of Closed Well-Order Types. We also go one step further, deﬁning
a closed hierarchy of closed types.
Chapter 6: Closed Algebraic Universe
In this chapter we deﬁne the closed
type theory of Closed Inductive-Recursive Types. This adapts the previous initial
algebra semantics from an open type theory setting to a closed type theory setting.
We deﬁne the Closed Inductive-Recursive Types in Agda, serving as a formal model

22
of a closed dependently typed language supporting datatype declarations.
Chapter 7: Fully Generic Functions
In this chapter we provide examples
of writing fully generic functions over Closed Inductive-Recursive Types. These
functions can be applied to values of any type in our model, can recurse into non-
inductive and inductive arguments, and can eliminate any value in our model.
Signiﬁcantly, our generic functions are examples of how to deal with dependencies
among inductive arguments, as such dependencies only exist for inductive-recursive
types.
Chapter 8: Closed Hierarchy of Universes
Up to this point we have worked
with a closed type theory modeling the ﬁrst universe of a hierarchy, which con-
tains values but not types. In this chapter we show how to extend a closed type
theory to a hierarchy of universes, which contains types (in addition to values) at
every level of the hierarchy beyond the ﬁrst. The chapter reviews how to model a
hierarchy of Closed Well-Order Types, and then deﬁnes a model of the hierarchy
of Closed Inductive-Recursive Types. We highlight the subtleties necessary to ade-
quately deﬁne a hierarchy containing algebraic types modeled using initial algebra
semantics.
In this chapter we also show how to extend fully generic functions to also be
universe-level generic. We call such functions leveled fully generic functions, and
show that they can be applied to any type at any level of the universe hierarchy.
Importantly, leveled fully generic programming is possible because our universe
hierarchy model is closed (i.e., the hierarchy still does not contain Set, but addi-
tionally does not contain Level).

23
Part IV: Postlude
Finally, we address Chapter 9: Related Work, Chapter 10: Future Work,
and summarize our dissertation in Chapter 11: Conclusion.
Major Ideas
Each chapter (besides the introduction and the postlude chapters) is preceded by
a paragraph titled Major Ideas.
This paragraph explains the purpose of the
chapter, and anything unconventional, to help prevent readers from getting lost
in the details and forgetting the motivation. This paragraph may assume ideas
explained within the chapter, so it may be necessary to reference the major ideas
as the chapter is read.

24
Chapter 2
TYPES & UNIVERSES
A type is a collection of values, and a universe is a collection of types (possibly
closed under certain type formers). In this section we review diﬀerent classes of
types (e.g., indexed types, inﬁnitary types, etc). This allows us to be clear about
what each class adds to the expressive power of a language (i.e., what sorts of new
values we can construct.)
We also review properties of both types and universes (e.g., inductiveness,
openness, etc).
These properties determine how we can use values (i.e., what
elimination principles are valid for them).
With a thorough understanding of
classiﬁcations and properties of types and universes, we can precisely describe
which classiﬁcations and properties we need to perform the main goal of this thesis,
fully generic programming (Chapter 3) within closed type theory (Chapter 4).
Major Ideas
The purpose of this chapter is to review mostly standard termi-
nology used to classify types and universes in DTT. Expert readers may wish to
skip this review. One deviation we make from standard terminology is calling a
universe inductively deﬁned (Section 2.2.4). If the datatype of codes of a universe is
inductive, then the universe represented by the codes is “closed under” certain type
formers. Nevertheless, we call the universe inductive to not confuse that concept
with the idea of a closed universe (one not deﬁned in terms of Set, as described in
Section 2.2.3).
We also introduce some new terminology for describing universes, namely sub-
ordinate (Section 2.2.6) and autonomous (Section 2.2.7) universes. Although the

25
concept of open-versus-closed types and universes is well established, we focus on
this uncommon distinction in this dissertation (we do so because a closed universe
is essential for fully generic programming). By deﬁning all of these concept, we
can precisely capture the universe properties that are necessary to perform fully
generic programming in Section 3.3.4.
2.1
TYPES
In programming languages, a type is a construct used to capture the notion of
a collection of values. In this section we introduce many diﬀerent properties of
types so that we may precisely describe types in future parts of this thesis. As the
primary motivation of a functional programming language is writing functions, we
also accompany datatype deﬁnitions with example functions operating over said
types.
2.1.1
Function Types
Dependently typed functional languages include dependent functions as a primi-
tive. The codomain of a dependent function type may depend on a value of its
domain.
(a : A) →B a
Values of function types are lambda expressions, such as the lambda expression
in the body of the identity function (id) below.
id : (A : Set) →A →A
id = ń A →ń a →a

26
2.1.2
Non-Inductive Types
A non-inductive type is any type that is not recursively deﬁned. A type can have
one or more constructors used to introduce its values. The deﬁnition of a non-
inductive type does not mention itself in the types of any of the arguments to its
constructors.
Functions are an example of a non-inductive type because the domain and
codomain of a λ does not recursively mention the function type. Booleans are
another example because the true and false constructors do not have arguments.
Below is the type of booleans, deﬁned with the negation function not as an example.
data Bool : Set where
false true : Bool
not : Bool →Bool
not false = true
not true = false
An even simpler example is the unit type, which only has a single constructor
without any arguments.
data ⊤: Set where
tt : ⊤
A non-trivial example is the “maybe” type specialized to booleans (MaybeBool).
The just constructor has an argument, but its type is Bool rather than the type
being deﬁned (MaybeBool).
data MaybeBool : Set where
nothing : MaybeBool
just : Bool →MaybeBool

27
2.1.3
Inductive Types
An inductive type mentions itself in its deﬁnition. That is, at least one constructor
has one argument whose type is the type being deﬁned. For example, below is the
type of natural numbers (deﬁned with the addition function + as an example).
The successor constructor of the type of natural numbers takes a natural number
argument, making it inductive.
data N : Set where
zero : N
suc : N →N
_+_ : N →N →N
zero + m = m
suc n + m = suc (n + m)
An alternative deﬁnition of an inductive type is a collection of values closed
under certain value constructors (e.g., N as zero closed under suc).
2.1.4
Parameterized Types
A parameterized type is a collection of types, parameterized by some type A, such
that the collection is uniformly deﬁned for each of its types regardless of what A
is.
For example, below the type of disjoint unions (⊎) is non-dependent, non-
inductive, and parameterized by two types A and B. We deﬁne the type of disjoint
unions along with a function to case-analyze them.
data _⊎_ (A B : Set) : Set where
inj1 : A →A ⊎B
inj2 : B →A ⊎B
case : {A B C : Set} →A ⊎B →(A →C) →(B →C) →C
case (inj1 a) f g = f a

28
case (inj2 b) f g = g b
Dependent pairs (Σ) are another example. They are dependent, non-inductive,
and parameterized by a type A and a function type B (whose domain is A and
codomain is Set). We deﬁne the type of dependent pairs along with its dependent
projections.
data Σ (A : Set) (B : A →Set) : Set where
_,_ : (a : A) (b : B a) →Σ A B
proj1 : ∀{A B} →Σ A B →A
proj1 (a , b) = a
proj2 : ∀{A B} (ab : Σ A B) →B (proj1 ab)
proj2 (a , b) = b
A third example is the type of polymorphic lists. They are non-dependent,
inductive, and parameterized by some type A. The example function append com-
bines two lists into a single list.
data List (A : Set) : Set where
nil : List A
cons : A →List A →List A
append : ∀{A} →List A →List A →List A
append nil ys = ys
append (cons x xs) ys = cons x (append xs ys)
2.1.5
Indexed Types
An indexed type is a collection of types, indexed by some type I, such that each
type in the collection may vary for any particular value of I. For example, the type
of vectors (Vec), or length-indexed lists. Vectors are indexed by a natural number
n (representing their length) and also parameterized by some type A.
data Vec (A : Set) : N →Set where

29
nil : Vec A zero
cons : ∀{n} →A →Vec A n →Vec A (suc n)
Below we encode the 2-length vector of booleans [true,false] and the 3-
length vector of natural numbers [1,2,3] using Vec.
bits : Vec Bool 2
bits = cons true (cons false nil)
nums : Vec N 3
nums = cons 1 (cons 2 (cons 3 nil))
The example function append ensures that the length of the output vector is
the sum of the lengths of the input vectors.
append : ∀{A n m} →Vec A n →Vec A m →Vec A (n + m)
append nil ys = ys
append (cons x xs) ys = cons x (append xs ys)
Another example is the type of ﬁnite sets (Fin), indexed by the natural numbers.
For each natural number n, the type Fin n represents the subset of natural numbers
from 1 to n.1
data Fin : N →Set where
here : ∀{n} →Fin (suc n)
there : ∀{n} →Fin n →Fin (suc n)
The type Fin 3 encodes the ﬁnite set {1,2,3}. Below we construct the numbers
1, 2, and 3 as values of the Fin 3 type.
one : Fin 3
one = here
two : Fin 3
two = there here
1 Note that the ﬁnite set Fin 0 is uninhabited, as the subset of natural numbers from 1 to 0
does not have any values.

30
three : Fin 3
three = there (there here)
We give an example function using ﬁnite sets, named prod, which computes the
product of a list of n natural numbers. However, we represent a list of numbers as
a function from Fin n to N. The idea is that each member of the ﬁnite set maps to
a number (a member of our “list”). For example, the list [1,2,3] is represented
as the function below.2
nums : Fin 3 →N
nums here = 1
nums (there here) = 2
nums (there (there here)) = 3
nums (there (there (there ())))
Once again, prod takes this functional list representation as an input and returns
the mathematical product of all members of the “list”. 3
The base case represents the empty list, for which we return the number one
(the identity of the product operation). The recursive case multiplies the current
number at the head position of the list (accessed by applying f to the here con-
structor of ﬁnite sets) with the recursive call on the tail of the list (we compute
the tail of a list represented as a function by composing the function with the there
constructor of ﬁnite sets).
prod : (n : N) (f : Fin n →N) →N
prod zero f = suc zero
prod (suc n) f = f here * prod n (f ◦there)
Hence, prod applied to 3 and nums produces 6. This is the result of reducing
2 Technically this is a length-3 vector rather than a list. However, prod also takes a natural
number argument, and a dependent pair consisting of a number n and a vector of length n is
isomorphic to a list. See Section 2.1.7 on derived types for more discussion.
3 The ﬁnal clause serves as a proof that Fin 3 has no inhabitants beyond three. The parentheses
() serve as a witness that a value of the type that would be there there (Fin 0 in this case, which
is Fin 3 minus 3 theres) is uninhabited. Such witnesses are required for type checking to be
decidable in Agda.

31
the expression 1 · 1 · 2 · 3. Note that the ﬁrst 1 is from the zero case of prod, and
the second 1 is the ﬁrst element of nums.
2.1.6
Type Families
A type family is a collection of types, represented as a function from some domain
A to the codomain Set.
A →Set
Any parameterized datatype is a type family, for example the type of lists.
List : Set →Set
Any indexed type is also a type family, for example the type of vectors.
Vec : Set →N →Set
Although the type of vectors contains two arguments rather than one, it is isomor-
phic to an uncurried version with a single argument:
Vec : Set × N →Set
2.1.7
Derived Types
Thus far we have only seen primitive types. The type of functions already existed
as a primitive in the language.
We deﬁned each other type using a datatype
declaration, extending our language with a new primitive type.
Alternatively,
many types can be derived from existing types. A derived datatype should be
isomorphic to the type we have in mind. Rather than writing a function for each
derived type, we derive its constructors as examples of how the derived type is
used. For example, we can derive the type of booleans as the disjoint union of two
unit types.
Bool : Set
Bool = ⊤⊎⊤

32
false : Bool
false = inj1 tt
true : Bool
true = inj2 tt
An indexed type can be derived as a function by computing an appropriate
existing type from its index. This is because the type former of an indexed type
(such as the type of vectors or ﬁnite sets) is a function.
For example, we can derive the indexed type of vectors of length n as a right-
nested tuple of pairs containing n values of type A. Each occurrence of A represents
a cons). The tuple terminates in the unit type, representing nil.
Vec : Set →N →Set
Vec A zero = ⊤
Vec A (suc n) = A × Vec A n
nil : ∀{A} →Vec A zero
nil = tt
cons : ∀{A n} →A →Vec A n →Vec A (suc n)
cons x xs = x , xs
As another example, consider the type of ﬁnite sets. The ﬁnite set type can
be derived as a right-nested tuple of disjoint unions of unit types, ending with a
bottom type (⊥, the type without any constructors). This makes sense because
the ﬁnite set of zero elements is uninhabited, and the ﬁnite set of any other number
n oﬀers a choice (of heres and theres) to index any sub-number of n. Here “choice”
is interpreted as disjoint union.
Fin : N →Set
Fin zero = ⊥
Fin (suc n) = ⊤⊎Fin n

33
here : ∀{n} →Fin (suc n)
here = inj1 tt
there : ∀{n} →Fin n →Fin (suc n)
there p = inj2 p
Besides deriving vectors as a function whose type is computed from its index,
we can also derive the type of vectors as a constant function. Vectors are a special
case of a class of datatypes called containers [1], which are functions from datatype
positions to contained values. Below, the type of vectors is represented as a con-
stant function (i.e., one that does not vary for n) whose domain is a ﬁnite set of n
elements, and whose codomain is A. Think of the function as an n-ary projection
for each A value in the vector.
Vec : Set →N →Set
Vec A n = Fin n →A
nil : ∀{A} →Vec A zero
nil ()
cons : ∀{A n} →A →Vec A n →Vec A (suc n)
cons x f here = x
cons x f (there p) = f p
Above, the nil function receives bottom (⊥) as an argument, so we need not
deﬁne it. The cons function “extends” the function f by returning x if the ﬁnite set
points to the head of the vector, and otherwise calls the “tail” by applying f to the
sub-index p. Notice that in Section 2.1.5 the “list” argument to prod was actually
this functional vector representation, so it could have been written as:
prod : (n : N) (f : Vec N n) →N
Finally, we can derive non-indexed types from indexed types by using a depen-
dent pair. The dependent pair acts like an existential, where the ﬁrst component
is a value from the index domain and acts as a witness, and the second component

34
is the indexed type former applied to the witness and acts like a predicate. For
example, we can derive the type of lists from the type of vectors as follows.
List : Set →Set
List A = Σ N (ń n →Vec A n)
nil : {A : Set} →List A
nil = zero , vnil
cons : {A : Set} →A →List A →List A
cons x (n , xs) = suc n , vcons x xs
The ﬁrst component is zero for the nil constructor. For the cons constructor,
the ﬁrst component is the successor of the natural number n contained within the
list being extended (the second argument to cons) represented as a pair.
2.1.8
Inﬁnitary Types
An inﬁnitary type is an inductive type where at least one constructor has one
function argument whose codomain is the type being deﬁned.4 The domain can
never be the type being deﬁned because negative datatypes make type theory
inconsistent [11]. For example, the datatype below is inconsistent with type theory.
{-# NO_POSITIVITY_CHECK #-}
data Neg : Set where
neg : (Neg →Neg) →Neg
To motivate the deﬁnition of an inﬁnitary type, consider the type of rose trees
containing values in node positions and allowing each node to have any ﬁnite
number of branches.
data Rose (A : Set) : Set where
4 Inﬁnitary types are also referred to as generalized inductive deﬁnitions [37].

35
rose : A →List (Rose A) →Rose A
Now recall the derived deﬁnitions of vectors and lists from Section 2.1.7.
Vec : Set →N →Set
Vec A n = Fin n →A
List : Set →Set
List A = Σ N (ń n →Vec A n)
If we expand this derived deﬁnition of lists (and the inner derived deﬁnition of
vectors) in the deﬁnition of Rose above, we arrive at an alternative but isomorphic
deﬁnition of rose trees.
data Rose (A : Set) : Set where
rose : A →(n : N) (f : Fin n →Rose A) →Rose A
Our new deﬁnition of rose trees is an example of an inﬁnitary type, as it contains
an argument (f) whose domain is a ﬁnite set but whose codomain is the type being
deﬁned (Rose).
2.1.9
Inductive-Recursive Types
An inductive-recursive type is a collection of values mutually deﬁned with a func-
tion parameterized by said type. The mutually deﬁned function is called the decod-
ing function. An example of an inductive-recursive type is the type of arithmetic
expressions Arith. Values of type Arith encode “Big Pi” mathematical arithmetic
product equations up to some ﬁnite bound, such as the one below.
3
Y
i=1
i
The intuition is that this expression should evaluate to something (the number
6 in this case). The mutually deﬁned (decoding) function is exactly the evaluation
function. The type is deﬁned as follows.
mutual

36
data Arith : Set where
Num : N →Arith
Prod : (a : Arith) (f : Fin (eval a) →Arith) →Arith
eval : Arith →N
eval (Num n) = n
eval (Prod a f) = prod (eval a) (ń i →eval (f i))
A literal number is represented using the Num constructor, evaluating to said
number. A mathematical product is represented using the Prod constructor, where
the ﬁrst argument a is the upper bound of the product as an arithmetic expression
(3 in the example above), and the second argument f is the body of the product
(i in the example above) as a functional representation of a vector of arithmetic
expressions. Note that Arith is also an inﬁnitary type, as the codomain of f is Arith.
The length of the vector (the argument to Fin in the type of f) should be
the evaluation of the upper bound a. Hence, the evaluation function eval must
be mutually deﬁned with the type Arith. The Prod constructor evaluates to the
product computed with our prod function from Section 2.1.5. We can represent
the mathematical equation given earlier as follows.
six : Arith
six = Prod (Num 3) (ń i →Num (num i))
The result of applying eval to the inductive-recursive (Arith) equation six is the
natural number 6. An Arith equation may be nested in its upper bound (a) or
body (codomain of f), but the lower bound is always 1. Note that above we deﬁne
the expression six with the helper function num, which converts the ﬁnite set value
i to a natural number using one-based indexing.
A more typical example of an inductive-recursive type is a universe modeling
a dependently typed language, which we will see in Section 2.2.3.

37
2.1.10
Algebraic Types
An algebraic type is a type deﬁned as the ﬁxpoint of a suitable algebra. Although
this ﬁxpoint construction is not given directly, it is the semantics of types deﬁned
using data declarations. For example, the inductive type of lists is deﬁned as the
ﬁxpoint below.
List ≜λA. µX. 1 + A · X
In the equation, X is used to ask for recursive arguments (such as the second
argument to cons).
A non-inductive type like booleans can also be deﬁned by
ignoring X.
Bool ≜µX. 1 + 1
We would like to emphasize that this deﬁnition of booleans corresponds to the
semantics of deﬁning Bool using a data declaration (as in Section 2.1.2). Although
it looks syntactically similar to the derived deﬁnition of booleans using unit and
disjoint union in Section 2.1.7, that derived deﬁnition is not algebraic because it is
not deﬁned with µ (either syntactically or semantically). However, some derived
types can be algebraic if we internalize µ as a type former µ [12], and use this
type former to derive type deﬁnitions. In the scope of this thesis, an algebraic
type is one deﬁned using a data declaration, a µ type former, or a W type former
(introduced in Section 4.2.2).
Although W types are not syntactically ﬁxpoint
constructions, they are semantically very similar so we still call them algebraic.
Finally, below is an example of an indexed type deﬁned algebraically.
The
index is given as a lambda argument (n) just like the parameter (A). However, the
nil and cons constructor must appropriately constrain the index argument (to zero
or the successor of the previous vector respectively). Additionally, the recursive
argument X takes the index as an argument.
Vec ≜λA. λn. µX. (n = zero) + ((m : N) · A · X m · n = suc m)

38
Notice that in cons (i.e., the second summand) the index of the previous vector
is given as an explicit argument (m), and the index (n) is constrained to be the
successor of that argument.
2.1.11
Computational Families
A computational family is an indexed type deﬁned by computing over its index.
We have already seen a non-algebraic computational family, namely the derived
type of vectors from Section 2.1.7.
Vec : Set →N →Set
Vec A zero = ⊤
Vec A (suc n) = A × Vec A n
However, computational families can also be algebraic. In the previous section,
vectors are algebraically deﬁned by constraining the input index given as a lambda
argument. As a computational algebraic family, we case-analyze the lambda in-
dex argument to determine the algebra that we take the ﬁxpoint of rather than
constraining the input.
Vec ≜λA. λn. µX. case n of
zero 7→1
suc n 7→A · X n
Agda does not currently support a high-level syntax (like data) for deﬁning
computational algebraic families. Nonetheless, we semantically model them using
an internalized µ type [12].

39
2.1.12
Open Types
An open type is any type whose deﬁnition mentions the type of types (Set).5 In an
open type theory datatype declarations add new types to the language, extending
Set with additional type formers. Therefore the collection of type formers (values of
type Set) is considered to be “open”. Consequently, open languages must prohibit
case analysis over Set, because a total function matching against currently deﬁned
types becomes partial when a new datatype is declared. One example of an open
datatype is the type of heterogenous lists (HList).
data HList : Set1 where
nil : HList
cons : {A : Set} →A →HList →HList
append : HList →HList →HList
append nil ys = nil
append (cons x xs) ys = cons x (append xs ys)
HList is an open type because its cons constructor has an argument A of type
Set, and an argument a whose type is the open type A.
The parametric lists from Section 2.1.4 are another example of an open type, as
the a argument in the cons constructor has type A. The type of lists parameterized
by A is open because cons uses A, and A has type Set.
2.1.13
Closed Types
A closed type is any type whose deﬁnition does not mention Set. For example, if
we specialize the type of parametric lists to booleans (as the type Bits) the source
5 A type is open if its deﬁnition directly mentions Set, for example as an argument to one of its
constructors. However, a type is also open if its deﬁnition indirectly mentions Set. For example,
an argument to one of its constructors may be another open type (which is open because it either
directly or indirectly mentions Set).

40
of openness (the parameter A of type Set) disappears.
Bits : Set
Bits = List Bool
all : Bits →Bool
all nil = true
all (cons false xs) = false
all (cons true xs) = all xs
2.2
UNIVERSES
A universe is a collection of types, possibly closed under certain type formers.
Just as we accompanied types with example functions operating over them in
Section 2.1, we accompany universes with example generic functions in this section.
A generic function is any function deﬁned over multiple types.
2.2.1
Universe Model
In a dependently typed language, a universe can be modeled as a type of codes
(representing the actual types of the universe), and a meaning function (mapping
each code to its actual type).
For example the BoolStar universe is comprised of the type of booleans, lists
of booleans, lists of lists of booleans, and so on. In other words, it is the Kleene
star version of Bits (non-nested lists of booleans) from Section 2.1.13. The type
of codes is BoolStar, and its meaning function is J_K. As a convention, we preﬁx
constructors of the code type with a backtick to emphasize the distinction between
a code (e.g., ‘Bool) and the actual type it denotes (e.g., Bool).
data BoolStar : Set where
‘Bool : BoolStar
‘List : BoolStar →BoolStar

41
J_K : BoolStar →Set
J ‘Bool K = Bool
J ‘List A K = List J A K
To get the actual universe type, we apply the dependent pair type former (Σ) to
the codes and meaning function. Therefore, values of the universe are dependent
pairs whose ﬁrst component is a code and second component is a value (the type
of the value is the meaning function applied to the code).
BoolStarU : Set
BoolStarU = Σ BoolStar J_K
As a convention, we append the letter U to the type of codes to deﬁne the
universe type. Our ﬁrst example member of this universe represents the list of
booleans [true, false].
bits1 : BoolStarU
bits1 = ‘List ‘Bool , cons true (cons false nil)
Our second example universe value represents the list of lists of booleans
[[true], [false]].
bits2 : BoolStarU
bits2 = ‘List (‘List ‘Bool) , cons (cons true nil) (cons (cons false nil) nil)
Our example generic function over this universe is all, which returns true if all
the booleans in any potential list and nested sublists are true.
all : (A : BoolStar) →J A K →Bool
all ‘Bool b = b
all (‘List A) nil = true
all (‘List A) (cons x xs) = all A x ∧all (‘List A) xs
2.2.2
Open Universes
An open universe mentions Set in its type of codes or meaning function. Just
as open types grow their collection of values when new types are declared, open

42
universes grow their collection of types when new types are declared.
An example open universe is DynStar, the universe of dynamic lists closed under
list formation. A dynamic list may contain values of any type, but the type must
be shared by all values.
data DynStar : Set1 where
‘Dyn : Set →DynStar
‘List : DynStar →DynStar
J_K : DynStar →Set
J ‘Dyn A K = A
J ‘List A K = List J A K
Again, we can encode the actual Kleene star of dynamic types universe (rather
than just its codes or meaning function) using a dependent pair.
DynStarU : Set1
DynStarU = Σ DynStar J_K
In our ﬁrst example, we represent the list of booleans [true, false]. The
‘Dyn part of the ﬁrst component of the pair indicates the type of values contained
in our list, namely Bool.
bits1 : DynStarU
bits1 = ‘List (‘Dyn Bool) , cons true (cons false nil)
Our second example represents the list of lists of natural numbers [[1], [2]].
This time, ‘Dyn is applied to the type of natural numbers (N).
nums2 : DynStarU
nums2 = ‘List (‘List (‘Dyn N)) , cons (cons 1 nil) (cons (cons 2 nil) nil)
A common function to deﬁne over parameterized lists is “concat”, which ﬂattens
a list of lists to a single list. Ordinarily we might deﬁne multiple versions of this
function, each ﬂattening an increasing number of outer lists.
concat1 : {A : Set} →List (List A) →List A

43
concat2 : {A : Set} →List (List (List A)) →List A
concat3 : {A : Set} →List (List (List (List A))) →List A
Using the DynStar universe, we can deﬁne a generic concat function that ﬂattens
any number of outer lists. The return type of this function should be a List of As,
where A is the dynamic type for the dynamic lists to be ﬂattened. Thus, we ﬁrst
deﬁne a function Dyn to extract the dynamic type from a DynStar code by recursing
down to the base case ‘Dyn.
Dyn : (A : DynStar) →Set
Dyn (‘Dyn A) = A
Dyn (‘List A) = Dyn A
Note that Dyn is a computational family (Section 2.1.11). Later in the thesis we
introduce more speciﬁc terminology, calling Dyn a computational argument family
(Section 3.4.3) that serves as a domain supplement (Section 3.4.5). Having deﬁned
Dyn, we can deﬁne a generic concat function to return a ﬂattened list of dynamic
universe values.
concat : (A : DynStar) →J A K →List (Dyn A)
concat (‘Dyn A) x = cons x nil
concat (‘List A) nil = nil
concat (‘List A) (cons x xs) = append (concat A x) (concat (‘List A) xs)
Note that a dynamic ‘Dyn value is ﬂattened by turning it into a single-element
list.
2.2.3
Closed Universes
A closed universe does not mention Set in its type of codes or meaning function.
The BoolStar universe of Section 2.2.1 is an example of a closed universe.
As an edge case, consider the universe (HListStar) of heterogenous lists closed
under list formation below.
data HListStar : Set where

44
‘HList : HListStar
‘List : HListStar →HListStar
J_K : HListStar →Set1
J ‘HList K = HList
J ‘List A K = List J A K
Even though HListStar does not mention Set directly in its codes or meaning
function, it does mention it indirectly because the ‘HList code maps to the open
type HList (which mentions Set). Therefore, the HListStar universe is open!
2.2.4
Inductive Universes
We call a universe inductive if its types are closed over one or more type formers.
For example, the BoolStar, DynStar, and HListStar universes above are inductive
because they are closed under List formation (via the inductive ‘List code construc-
tor).
2.2.5
Non-Inductive Universes
A universe is non-inductive if its types are not closed under any type formers. For
example, the Truthy universe below represents types that we want to consider as
boolean conditional values.
data Truthy : Set where
‘Bool ‘N ‘Bits : Truthy
J_K : Truthy →Set
J ‘Bool K = Bool
J ‘N K = N
J ‘Bits K = List Bool
Below we deﬁne the isTrue operation, allowing us to consider any value of the
universe as being true or false.
isTrue : (A : Truthy) →J A K →Bool

45
isTrue ‘Bool b = b
isTrue ‘N zero = false
isTrue ‘N (suc n) = true
isTrue ‘Bits nil = true
isTrue ‘Bits (cons false xs) = false
isTrue ‘Bits (cons true xs) = isTrue ‘Bits xs
2.2.6
Subordinate Universes
A universe is subordinate if one of its types contains a nested type that is not a
member of the universe. Hence, a universe is subordinate if one of its types has a
constructor with an argument whose type is not a member of the universe.
For example, the open HListStar universe from Section 2.2.3 is subordinate
because it contains HList, which has a Set argument in the cons constructor, and
Set is not a member of HListStar.
Closed universes can be subordinate too, for example the universe BitsStar
contains lists of booleans closed under list formation.
The ‘Bits values of this
universe contain booleans in cons positions, but booleans are not members of the
universe.
data BitsStar : Set where
‘Bits : BitsStar
‘List : BitsStar →BitsStar
J_K : BitsStar →Set
J ‘Bits K = List Bool
J ‘List A K = List J A K
2.2.7
Autonomous Universes
A universe is autonomous if all nested types of its types are also types in the
universe. Hence, the type of every argument to every constructor of a universe
type must also be a type in the universe.

46
For example, the closed BoolStar universe of Section 2.2.1 is closed because Bool
does not have constructor arguments, and because the universe is closed under List
formation (thus any sublist only contains types also in the universe).
Note that open universes can be autonomous.
For example, DynStar from
Section 2.2.2 includes all types A (of type Set) via the ‘Dyn constructor. Regardless
of any other types (such as lists) in the universe, DynStar is autonomous because
any type can be injected using ‘Dyn.
2.2.8
Derived Universes
Thus far we have constructed universes with certain properties from scratch, ex-
tending the primitive types of our language with a primitive universe. However,
we can also derive a universe from any type family by considering the type of its
indices as the codes and the type family itself as the meaning function. If we do
this for the indexed type of ﬁnite sets (Fin), we get a universe (Pow) like powerset
but without the empty set (because Fin zero is not inhabited).
Pow : Set
Pow = Σ N Fin
one1 : Pow
one1 = 1 , here
one2 : Pow
one2 = 2 , here
two2 : Pow
two2 = 2 , there here
That is, for every natural number (each N code) we get the subset of the natural
numbers from zero to that number minus one (the Finite set).
We can use the same method to derive type of dynamic lists (DList) from the
type of parameterized lists. Note that this is the type of dynamic lists, rather than

47
the Kleene star of dynamic values (DynStar from Section 2.2.2).
DList : Set1
DList = Σ Set List
bits : DList
bits = Bool , cons true (cons false nil)
nums : DList
nums = N , cons 1 (cons 2 nil)
Reﬂect on the fact that universes are modeled in type theory as a dependent
pair consisting of codes and a meaning function. This pair is just another type,
therefore whether we consider Pow and DList to be derived types (Section 2.1.7)
or derived universes is merely a matter of perspective.
2.2.9
Parameterized Universes
A parameterized universe is a collection of universes, parameterized by some type
A, such that the collection is uniformly deﬁned for each universe regardless of what
A is.
The model of a parameterized universe (i.e., its representation in type the-
ory) may depend on its parameter in its codes, meaning function, or both. The
Kleene star universes of booleans (BoolStar), heterogenous lists (HListStar) and
bits (BitsStar) all have a similar structure, namely a specialized base type closed
under list formation. Our example parameterized universe abstracts out the base
type as a parameter.
data ParStar : Set where
‘Par : ParStar
‘List : ParStar →ParStar
J_K : ParStar →Set →Set
J ‘Par K X = X

48
J ‘List A K X = List (J A K X)
The ‘Par code represents the parameterized type, and is interpreted as the sec-
ond argument to the meaning function. To more easily see how this is a “param-
eterized” universe, we give the type of the universe as a parameterized dependent
pair below.
ParStarU : Set →Set
ParStarU X = Σ ParStar (ń A →J A K X)
bits1 : ParStarU Bool
bits1 = ‘List ‘Par , cons true (cons false nil)
bits2 : ParStarU Bool
bits2 = ‘List (‘List ‘Par) , cons (cons true nil) (cons (cons false nil) nil)
We can still write concat by injecting values of the parameterized type into
a singleton list as with DynStar (Section 2.2.2). Recall that concat for DynStar
required a special function Dyn to extract the base type. When deﬁning concat for
ParStar, the base type is already an explicit parameter that we can refer to in the
return type.
concat : ∀{X} (A : ParStar) →J A K X →List X
concat ‘Par x = cons x nil
concat (‘List A) nil = nil
concat (‘List A) (cons x xs) = append (concat A x) (concat (‘List A) xs)
We’ve seen how to derive a universe from a type family in Section 2.2.8, but we
can also derive a universe from a universe family. As an example, we derive the
DynStar universe from the ParStar universe. In Section 2.2.2 we deﬁned the type of
DynStar codes as a primitive, whereas below we derive DynStar codes as the pair
of ParStar and Set (the parameter type of ParStarU).
DynStarU : Set1
DynStarU = Σ (ParStar × Set) (ń { (A , X) →J A K X })

49
bits1 : DynStarU
bits1 = (‘List ‘Par , Bool) , cons true (cons false nil)
bits2 : DynStarU
bits2 = (‘List (‘List ‘Par) , Bool) , cons (cons true nil) (cons (cons false nil) nil)

50
Chapter 3
GENERIC PROGRAMMING
Generic programming is the act of writing functions that can be applied to values
of a collection of types (a universe). Given a collection of types, a generic function
can be applied to values of any type in the collection. A polymorphic function
universally quantiﬁes over some collection of values and references an arbitrary
member of that collection in its type signature. Therefore, generic functions are
merely polymorphic functions. The type of the quantiﬁed variable can be seen as
the codes of the universe, followed by the meaning function applied to a particular
code, followed by the remainder of the type signature.
(c : Code) (m : Meaning c) →...
We have already seen many generic functions ﬁtting this pattern in Section 2.1
and Section 2.2. Below we reconsider some of them, while classifying them by
diﬀerent forms of polymorphism. In each of these examples, we emphasize the
deﬁnition of Code (i.e., what the function is polymorphic over).
Major Ideas
This chapter clariﬁes our deﬁnition of generic programming, re-
lating it to parametric (Section 3.1) and ad hoc (Section 3.2) polymorphism. It
also introduces non-standard terminology, namely the properties of abstractness
(Section 3.3.1) and concreteness (Section 3.3.2), which can apply to both types and
universes. This ﬁnal bit of terminology allows us to precisely capture the universe
properties (along with properties from Section 2.1 and Section 2.2) necessary to
perform fully generic programming in Section 3.3.4.

51
We also include a section on dependently typed programming techniques used
to write total functions (Section 3.4), which often become necessary when writing
suﬃciently complex generic functions. The techniques of Section 3.4 are primarily
used in Chapter 7.
3.1
PARAMETRIC POLYMORPHISM
A parametrically polymorphic function is deﬁned uniformly over its codes and their
meanings. That is, the function does not inspect the type of codes and therefore
does not behave diﬀerently for any code or its interpretation (i.e., it does not behave
diﬀerently for diﬀerent values in the type returned by the meaning function applied
to a code).
3.1.1
Parametric over Types
A common form of parametric polymorphism is over types( i.e., where Code is
deﬁned to be Set).
append : {A : Set} →List A →List A →List A
append nil ys = ys
append (cons x xs) ys = cons x (append xs ys)
Notice that append over lists behaves the same way for any type A that it is
applied to.
3.1.2
Parametric over Levels
Functions can also be deﬁned parametrically over universe Levels.1 Types in Agda
are arranged in a hierarchy, where base types are classiﬁed by Set0, kinds are
1 Here, a “universe” refers to all types, or all kinds, or all superkinds, etc. This use of the
word universe is distinct from a type of codes and a meaning function. While these are related
(the former is the image of the meaning function of the latter), the former refers to a level in a
hierarchy of types, while the latter is a technical formal device used for generic programming or
modeling a domain.

52
classiﬁed by Set1, superkinds are classiﬁed by Set2, and so on. Rather than deﬁning
diﬀerent functions operating over types in each of these levels, we can deﬁne a single
function level-polymorphically.
append : {ℓ: Level} {A : Set ℓ} →List A →List A →List A
append nil ys = ys
append (cons x xs) ys = cons x (append xs ys)
Note that append now behaves the same way for any type at any level that it
is applied to.
3.2
AD HOC POLYMORPHISM
An ad hoc polymorphic function is deﬁned non-uniformly over its codes or their
meanings.
That is, the function may inspect codes and its interpretation (the
values in the type returned by the meaning function applied to a code).
3.2.1
Ad Hoc by Overloading
If the type of Codes for our universe is algebraic and non-inductive, then generic
functions over the universe amount to a kind of syntactic overloading of function
names.
For example, consider the isTrue function from Section 2.2.5 over the Truthy
universe. Before deﬁning isTrue for the universe, we can deﬁne versions of the
function for each type in the universe.
isTrueBool : Bool →Bool
isTrueBool b = b
isTrueN : N →Bool
isTrueN zero = false
isTrueN (suc n) = true
isTrueBits : List Bool →Bool

53
isTrueBits nil = true
isTrueBits (cons false xs) = false
isTrueBits (cons true xs) = isTrueBits xs
Now we can deﬁne isTrue by matching on each type code, and returning the
appropriate function specialized to that type.
isTrue : (A : Truthy) →J A K →Bool
isTrue ‘Bool = isTrueBool
isTrue ‘N = isTrueN
isTrue ‘Bits = isTrueBits
Another way to say this is that we can make recursive calls on interpretations,
but not codes. For example, below we inline the specialized functions as is done
in Section 2.2.5. The ‘Bits cases make recursive calls on inductive values, but the
codes stay constant in recursive calls.
isTrue : (A : Truthy) →J A K →Bool
isTrue ‘Bool b = b
isTrue ‘N zero = false
isTrue ‘N (suc n) = true
isTrue ‘Bits nil = true
isTrue ‘Bits (cons false xs) = false
isTrue ‘Bits (cons true xs) = isTrue ‘Bits xs
3.2.2
Ad Hoc by Coercion
If the type of Codes for our universe is algebraic, inductive, and autonomous, then
generic functions over the universe can make recursive calls on both codes and their
interpretations. Because we can make recursive calls on types of our universe, we
can eﬀectively coerce recursive values of our universe to an appropriate output
type.
For example, consider the concat function from Section 2.2.2 over the DynStar
universe. Each value and subvalue of this dynamic Kleene star universe can be

54
coerced to a dynamic list.
concat : (A : DynStar) →J A K →List (Dyn A)
concat (‘Dyn A) x = cons x nil
concat (‘List A) nil = nil
concat (‘List A) (cons x xs) = append (concat A x) (concat (‘List A) xs)
3.2.3
Ad Hoc by Overloading & Coercion
Ad hoc polymorphic functions may also be a hybrid of the overloading and coercion
styles. For example, if universe Codes are algebraic, inductive, and subordinate then
we can recurse on the codes and interpretations for the autonomous types in the
universe (coercion), but can only recurse on the interpretations of the subordinate
types (overloading). For example, consider the all function for the BitsStar universe
of Section 2.2.6.
all : (A : BitsStar) →J A K →Bool
all ‘Bits nil = true
all ‘Bits (cons false xs) = false
all ‘Bits (cons true xs) = all ‘Bits xs
all (‘List A) nil = true
all (‘List A) (cons x xs) = all A x ∧all (‘List A) xs
The ‘Bits cases only recurse over the interpretation (keeping the code constant),
hence they are deﬁned by overloading. The ‘List cases recurse both over the codes
and the interpretation, hence they are deﬁned by coercion.
3.3
ABSTRACTNESS & CONCRETENESS
In this section we deﬁne additional non-standard terminology for types and uni-
verses, namely abstractness and concreteness.
We cover these properties here
rather than in Section 2.1 on types and Section 2.2 on universes because the ter-
minology (as it is used) and our emphasis on it is unique to this thesis.

55
3.3.1
Abstract Types
An abstract type is any type that does not have an elimination principle. For
example, open types (Section 2.1.12) mentioning Set are abstract because you
cannot pattern match on values of Set (or otherwise eliminate Set).
Types mentioning Level (used to indicate which level in a hierarchy a type
inhabits) are also abstract. Once again, Agda types are arranged in a hierarchy,
where base types are classiﬁed by Set0, kinds are classiﬁed by Set1, superkinds are
classiﬁed by Set2, and so on. Rather than deﬁning diﬀerent datatypes inhabiting
each of these levels, we can deﬁne a single datatype that can be instantiated at
any level.
In the example below, we deﬁne parameterized lists that can be instantiated
at any level in the type hierarchy. The deﬁnition also enforces the constraint that
a list must inhabit the same level as its type parameter.
data List {ℓ: Level} (A : Set ℓ) : Set ℓwhere
nil : List A
cons : A →List A →List A
Just like Set, Agda does not expose an elimination principle for Level (thus you
cannot, for example, pattern match on levels in a function deﬁnition).2
3.3.2
Concrete Types
A concrete type is any type that does have an elimination principle.
For the
purpose of this thesis, this will mean any type that does not mention Set or Level.
Therefore, concrete types have the special properties that all of its values and
subvalues may be eliminated. Algebraic datatypes are concrete and they may be
eliminated by pattern matching. Function types are concrete and they may be
eliminated by application.
2 Nevertheless, we can write parametrically level-polymorphic functions over List as in Sec-
tion 3.1.2.

56
3.3.3
Abstract Data Types
This thesis does not consider abstract data types (ADT’s), but we touch upon them
brieﬂy here to relate them to our terminology of abstract and concrete types.
An ADT allows the user to expose a type former, constructors, and elimination
principles while hiding their implementation. For example, a dictionary may be
exposed as a list of key/value pairs but internally be implemented as a balanced
binary search tree. Therefore, an ADT deﬁned to expose its type former and con-
structors, but not its elimination principle, is abstract by our deﬁnition. However,
if such an ADT also exposed its elimination principle we would call it concrete
(despite the fact that the ADT would be hiding its true implementation).
3.3.4
Fully Generic Programming
We call a universe abstract if at least one of the types it contains is abstract. We
call a universe concrete if all of the types it contains are concrete. This brings us
to the primary ambition of this thesis, which we call fully generic programming. A
fully generic function is a special kind of ad hoc polymorphic function by coercion
(Section 3.2.2) with the additional property that the universe is concrete.3
By
consequence, fully generic functions can eliminate any value or subvalue (includ-
ing both inductive and non-inductive constructor arguments) and recurse on any
universe code.
For example, the BoolStar universe (Section 2.2.1) allows us to deﬁne nor as a
fully generic function (returning true if all values and subvalues contain false).
nor : (A : BoolStar) →J A K →Bool
nor ‘Bool true = false
nor ‘Bool false = true
nor (‘List A) nil = true
3 Because the universe is both inductively deﬁned (Section 2.2.4) and concrete (Section 3.3.2),
it is also closed (Section 2.2.3).

57
nor (‘List A) (cons x xs) = nor A x ∧nor (‘List A) xs
In addition to making recursive calls on codes and interpretations (thanks to
an algebraic, inductive, and autonomous universe) for the ‘List cases, we can also
pattern match on all [sub]codes and all [sub]values (thanks to concreteness). Com-
pare this to concat for DynStar in Section 3.2.2. The concat function cannot pat-
tern match on the interpretation of the ‘Dyn base case because the type is Set (the
source of abstractness). By contrast, nor can match on the interpretation of ‘Bool
by distinguishing between true and false (because Bool is a concrete type).
3.4
TOTALITY
Functions written in dependent type theory (DTT) must be total (deﬁned over all
inputs). Thus, partial functions written in traditional languages cannot be directly
encoded as functions in DTT. In this section, we explain a general technique for
altering the type signature of a partial function so that it may be encoded as a total
function in DTT. We use the head function as our running example of a partial
function that we wish to encode in a total language.
head : {A : Set} →List A →A
Applying head to a non-empty list should return the ﬁrst element, but applying
head to an empty list should be undeﬁned. Below we explain how to encode head
as a total function by altering either the domain or codomain, ﬁrst by using non-
dependent types and then by taking advantage of dependent types.
3.4.1
Non-Dependent Domain Change
In a non-dependent language, we could write head as a total function by adding
an extra A argument to the domain. This extra argument serves as a “default”

58
argument to return in the (otherwise partial) empty list case.
head : {A : Set} →List A →A →A
head nil y = y
head (cons x xs) y = x
3.4.2
Non-Dependent Codomain Change
In a non-dependent language, we could also write head as a total function by
changing the return type to Maybe A. This allows us to dynamically model par-
tiality by failing with nothing in the empty list case, and succeeding with just in
the non-empty list case.
head : {A : Set} →List A →Maybe A
head nil = nothing
head (cons x xs) = just x
3.4.3
Dependent Domain Change
Without dependent types we can add a default argument to head. Unfortunately,
a user must supply this default argument even if they are taking the head of a
non-empty list. With dependent types, we can add an extra dependent argument
to head. The type of the extra argument depends on the input list, and is deﬁned
below as a computational argument type (a type family deﬁned as a computation
as in Section 2.1.11, in an argument position of a function).
HeadArg : {A : Set} →List A →Set
HeadArg {A = A} nil = A
HeadArg (cons x xs) = ⊤
If the input list is empty, HeadArg computes to A, the type of the default
argument that is required. If the input list is non-empty, HeadArg returns the unit
type (⊤). Because a value of type unit can always be trivially constructed, this is
equivalent to not having an extra argument at all when the input list is non-empty.

59
Now we can deﬁne head with HeadArg as its extra argument.
head : {A : Set} (xs : List A) →HeadArg xs →A
head nil y = y
head (cons x xs) tt = x
Notice that head only receives the default argument y in the empty list case.
Otherwise, it receives the trivial tt constructor of the unit type.
3.4.4
Dependent Codomain Change
Without dependent types we can change the codomain to dynamically model par-
tiality using the Maybe type. Dependent types allow us to statically enforce par-
tiality. We deﬁne the return type to be a computational return type (a type family
deﬁned as a computation, in the return type position of a function).
HeadRet : {A : Set} →List A →Set
HeadRet nil = ⊤
HeadRet {A = A} (cons x xs) = A
If the input list is non-empty, HeadRet computes the standard return type A.
However, if the list is empty then HeadRet computes the unit type. A function
returning unit may as well be undeﬁned, as its output is uniquely determined to
be tt.
head :{A : Set} (xs : List A) →HeadRet xs
head nil = tt
head (cons x xs) = x
Rather than dynamically enforcing partiality by returning a nothing failure
value for non-empty lists, head is statically “partial” as its deﬁnition for the empty
list case is uniquely determined.

60
3.4.5
Domain Predicates versus Domain Supplements
We have seen two diﬀerent ways (in Section 3.4.3 and Section 3.4.4) to make head
total using dependent types, ﬁrst by adding missing data (the default argument
A), and second by eﬀectively making the function undeﬁned for its “partial” cases.
A more common approach is to directly model partiality as a computational
argument type that requests an argument of the empty type for the empty list
case. This in contrast to modeling partiality as a computational return type (Sec-
tion 3.4.4) that returns unit for the empty list case.
HeadArg : {A : Set} →List A →Set
HeadArg {A = A} nil = ⊥
HeadArg (cons x xs) = ⊤
This allows us to leave the empty list case undeﬁned, as a value of type ⊥is
known not to exist.
head : {A : Set} (xs : List A) →HeadArg xs →A
head nil ()
head (cons x xs) tt = x
It is clear that the computational argument type HeadArg above acts a domain
predicate, reﬁning the domain of all lists to be undeﬁned for the empty list by
asking the user to provide a value of the empty type (⊥). Compare this to the
version of HeadArg in Section 3.4.3, which requests an extra argument (A) in the
empty list case. The Section 3.4.3 HeadArg is also technically a domain predicate,
as it restricts the input of all lists to supply additional data (A) in the empty list
case (i.e., head is no longer deﬁned for all lists, only those with additional data).
However, this usage of the word “predicate” feels unnatural, as predicates are
associated with logically restricting a domain (rather than requesting additional
data).
For this reason, we prefer to call the Section 3.4.3 HeadArg a domain
supplement (this is a non-standard term that we are introducing). Thus, we have
two options when embedding a partial function in type theory:

61
1. Use a domain predicate to restrict the domain, avoiding deﬁnitions for the
partial cases. For example, adding an empty type argument or returning
unit.
2. Use a domain supplement to request additional data, computing results for
the partial cases using the additional data. For example, returning a default
value provided as an additional argument.
This thesis focuses more on the second option. Functions made total using
domain supplements are more interesting than ones using domain predicates, as
the supplement adds computationally relevant data rather than just restricting
the domain to be undeﬁned for certain cases. Thus, a domain supplement is like a
proof-relevant version of a domain predicate (even though both technically restrict
the domain).
Conclusion
We have seen how to encode partial functions within total type theory by mod-
ifying the domain or codomain of a function, with and without the beneﬁts af-
forded by dependent typing.
Previously, when writing ordinary functions over
types (Section 2.1), and especially when writing generic functions over universes
(Section 2.2), we deliberately chose examples that were naturally total to avoid
using the techniques of this section.
However, as we write generic programs over larger universes (those containing
more types), it often becomes necessary to use computational argument or return
types to make generic functions total. This is particularly true when writing fully
generic functions (Section 3.3.4), as it might not be possible to deﬁne them for
certain values of a universe without domain supplements.

62
Chapter 4
CLOSED TYPE THEORY
A closed type theory is a dependently typed language with a built-in collection
of types (i.e., primitives) that will never be extended. Such a type theory can
be modeled as a fully closed universe.
To qualify as a closed type theory, we
require that its collection of types is at least closed under dependent function (Π)
formation.
It is reasonable to assume that programming in a closed type theory would
be limiting, as programmers can only work with the types that are built into the
theory (compared to an open theory where users may extend the language with
custom types). However, it turns out that a closed theory with an appropriate
collection of primitives can be used to model any custom type using only the
primitives. Hence, instead of extending an open theory with custom types using
datatype declarations, isomorphic versions of custom types may be formed in a
closed theory from its primitives.
Therefore, a closed type theory can model a dependently typed programming
language supporting custom types.
Assume that we make the universe model
of such a theory algebraic, inductive, autonomous, and concrete. This language
supports fully generic programming (Section 3.3.4), allowing programmers to write
functions over all types of the language, including custom types!1
1 By analogy, consider generic functions (like equality via Eq or comparison via Ord) that a
language like Haskell can derive for any appropriate type using the deriving keyword. While
users of Haskell are limited to deriving the generic functions built into the compiler, users of such
a closed type theory may write their own generic functions operating over any appropriate type.

63
Major Ideas
This chapter gives two examples of closed universes that can serve
as models of dependently typed languages. The ﬁrst universe models a language
with a ﬁxed collection of of built-in types related to vectors (Section 4.1). The
second universe models a language supporting user-declared types, by including
the type of well-orderings (W) as a built-in type (Section 4.2.1). Although we could
perform fully generic programming over this universe, the universe is inadequate
for our purposes (Section 4.2.3). Nevertheless, it is easy to understand, and is good
background material for the universe of user-declared types in Chapter 6 that we
actually use for fully generic programming (which replaces the built-in well-order
type W with a built-in ﬁxpoint type µ1).
4.1
CLOSED VECTOR UNIVERSE
In this section we present one example of a closed type theory, which we call
the universe of Closed Vector Types. This universe contains some standard types
along with some types speciﬁcally for writing programs operating over vectors.
The Closed Vector Types universe is an example of a simple closed type theory
(or programming language) with a ﬁxed set of primitives that does not support
custom user-deﬁned types.
4.1.1
Closed Vector Types
Below is the formal model (that is, the model within type theory) of the Closed
Vector Types universe. It has standard types like the empty type (⊥), the unit
type (⊤), booleans (Bool) and is closed under dependent pair formation (Σ) and
dependent function (Π) formation. However, we call it the Closed Vector Types
universe because it also includes types for writing vector-manipulating programs,
namely the natural numbers (N) and ﬁnite sets (Fin), and is closed under vector

64
(Vec) formation.
data ‘Set : Set where
‘⊥‘⊤‘Bool ‘N : ‘Set
‘Fin : N →‘Set
‘Vec : ‘Set →N →‘Set
‘Σ ‘Π : (A : ‘Set) (B : J A K →‘Set) →‘Set
J_K : ‘Set →Set
J ‘⊥K = ⊥
J ‘⊤K = ⊤
J ‘Bool K = Bool
J ‘N K = N
J ‘Fin n K = Fin n
J ‘Vec A n K = Vec J A K n
J ‘Σ A B K = Σ J A K (ń a →J B a K)
J ‘Π A B K = (a : J A K) →J B a K
Recall our naming convention of preﬁxing universe code constructors (e.g.,
‘Bool) with a backtick to distinguish the code (the “quoted” version of the type)
from the actual type it models (in this case Bool, which is the result of applying
the meaning function to the code). For closed type theories we establish the new
naming convention of preﬁxing the type of codes (e.g., ‘Set) with a backtick. Thus
the type of the meaning function is a function whose domain is ‘Set (a “quoted”
type of types) and whose codomain is Set (the actual type of types). This promotes
our deﬁnition-level quoting analogy (J ‘Bool K = Bool) to the type signature level
(J_K : ‘Set →Set).
Finally, notice that ‘Set is inductive-recursive (Section 2.1.9), as its ‘Σ and ‘Π
constructors refer to the meaning function in their codomain argument (B). Any
universe modeling a dependently typed language is similarly inductive-recursive,
as the universe must have Π types to qualify as a model for DTT.

65
4.1.2
Fully Generic Functions
Just like the fully closed BoolStar universe of Section 3.3.4, ‘Set also supports
writing fully generic functions. Fully generic functions, over a universe model of
a closed type theory, model pattern matching on types (Set) by pattern matching
on codes (‘Set) instead. Therefore, a generic function over all values of all types is
modeled by matching on a code, then a value from the interpretation of that code,
followed by any additional arguments and the return type.
(A : ‘Set) →J A K →...
Thus pattern matching on types is supported in a closed type theory, because
we know ahead of time that the collection of types will never be extended (hence
total functions over types never become partial).
Fully Generic Sum without Function Body
Our example fully generic function is sum, summing up all natural numbers (and
values that can be coerced into natural numbers) contained within a value of the
closed vector universe.2
sum : (A : ‘Set) (a : J A K) →N
Let’s begin with summing values of base types (non-function type formers, like
Bool): Summing a natural number just means returning it. We can never receive a
value of the empty type, so we need not deﬁne that case. The sum of unit is 0. The
sum of a boolean is 0 if it is false, and 1 if it is true (true is the second constructor
of Bool, just as suc zero is the second value in the ordered natural numbers). The
sum of a ﬁnite set Fin value is 0 for the here index, and the successor of the previous
2 The sum function is diﬀerent from the count function (from Section 1.2.2, which sums the
total number of nodes). Instead, sum returns the sum of all values that have been interpreted as
natural numbers by coercion.

66
index for the there case.
sum ‘N n = n
sum ‘⊥()
sum ‘⊤tt = 0
sum ‘Bool true = 0
sum ‘Bool false = 1
sum (‘Fin (suc n)) here = 0
sum (‘Fin (suc n)) (there p) = suc (sum (‘Fin n) p)
We sum a vector by adding together all of the values it contains, where each
value is interpreted as a natural number by recursive application of sum. The
empty vector contains no values, so its sum is 0.
sum (‘Vec A zero) nil = 0
sum (‘Vec A (suc n)) (cons x xs) = sum A x + sum (‘Vec A n) xs
A pair is like a two-element vector, so we sum a pair by adding its components.
Finally, the sum of a function is 0.
sum (‘Σ A B) (x , xs) = sum A x + sum (B x) xs
sum (‘Π A B) f = 0
Deﬁning the sum of a function to be 0 may seem unsatisfying, as its body
contains other values of our closed vector universe. Consider the types of variables
in context when deﬁning the function case of sum:
B : J A K →‘Set
f : (x : J A K) →J B x K
The sum cases for pairs and functions are actually for dependent pairs (‘Σ) and
functions (‘Π). Notice that, in our deﬁnition of sum for pairs, the recursive call of
sum for the second component applies the codomain B to an J A K value. Luckily,
the ﬁrst component of the pair (x) is exactly the value we need. If we wanted
to provide an alternative deﬁnition of sum for functions, we would have no such
luck because the value we are summing (f) is itself a function (i.e., there is no x in

67
sight). In the next section we change our deﬁnitions to end up with an x in the
function case that we can pass to both B and f.
Fully Generic Sum with Function Body
Step back for a moment and consider what the sum of a function should mean.
One interpretation is to consider the sum of a function to be many possible sums,
one for each argument in the domain of the function. Under this interpretation our
sum is missing an argument, one that provides a domain value for each occurrence
of a function in the closed vector universe value we wish to sum.
In other words, we consider our previous deﬁnition of sum to be a partial
function (we cannot appropriately deﬁne the function case). In Section 3.4.5 we
learned how to create a total function from a partial one by adding a domain
supplement. Below, we deﬁne the computational argument family Sum to be used
as a domain supplement for sum.
The most signiﬁcant case is the supplement for functions, in which we request
the interpretation of A as an additional argument (let’s call it x). When deﬁning
sum we will want to use x to recursively sum the body of the function, so we also
recursively request a supplement for the codomain of our function (B) applied to
x.
Sum : (A : ‘Set) →J A K →Set
Sum (‘Π A B) f = Σ J A K (ń x →Sum (B x) (f x))
A pair may contain functions in either of its components, so we recursively
request supplements for its domain and codomain. An empty vector requires no
supplement, but a non-empty vector requires one for each of its elements. Finally,
the base types do not need supplemental values to sum them, so their supplement
is a trivial unit value.
Sum (‘Σ A B) (x , xs) = Sum A x × Sum (B x) xs
Sum (‘Vec A zero) nil = ⊤

68
Sum (‘Vec A (suc n)) (cons x xs) = Sum A x × Sum (‘Vec A n) xs
Sum A a = ⊤
Below the domain of sum’s type is altered to take the supplement Sum as an
additional argument.
sum : (A : ‘Set) (a : J A K) →Sum A a →N
The only change we make to deﬁning sum for base types and Fin is to ignore the
additional trivial unit value (tt), and to supply it as an argument in the recursive
case of ‘Fin.
sum ‘⊥() tt
sum ‘⊤tt tt = 0
sum ‘Bool false tt = 0
sum ‘Bool true tt = 1
sum ‘N n tt = n
sum (‘Fin (suc n)) here tt = 0
sum (‘Fin (suc n)) (there p) tt = suc (sum (‘Fin n) p tt)
Summing pairs and vectors is also relatively unchanged. For pairs the only
diﬀerence is that we thread along the left component of the supplement (y) when
summing the left component of the pair (x), and the right component of the sup-
plement (ys) when summing the right component of the pair (xs). Summing a
non-empty vector is similar to summing a pair, and summing an empty vector
remains 0.
sum (‘Σ A B) (x , xs) (y , ys) = sum A x y + sum (B x) xs ys
sum (‘Vec A zero) nil tt = 0
sum (‘Vec A (suc n)) (cons x xs) (y , ys) = sum A x y + sum (‘Vec A n) xs ys
Finally, we can sum a function by summing its body. Its body is obtained
by applying the function f to x (whose type is the interpretation of A), readily
available in the domain supplement. Of course, the body may have additional

69
functions to sum, so we thread along the domain supplement y for any of those.
sum (‘Π A B) f (x , y) = sum (B x) (f x) y
Conclusion
The Closed Vector Types universe has enough types to write a lot of interesting
functions, but the speciﬁc collection of types that our closed type theory contains
is arbitrarily chosen.
What if we later decide we also want binary trees?
By
deﬁnition we cannot add custom types to a closed type theory (and if we did it
would violate the totality of generic functions over the original universe). Next (in
Section 4.2) we see how to model a closed type theory that does support custom
user-deﬁned types.
4.2
CLOSED ALGEBRAIC UNIVERSE
On one hand, we would like a closed type theory because it supports fully generic
programming (Section 3.3.4) via pattern matching on types (modeled by pattern
matching on codes of types). On the other hand, we want to support custom user-
deﬁned types (like an open type theory) that may not be present in the closed
collection of types we ﬁxed ahead of time.
What if our closed theory had enough primitive base types and type families
to simulate adding new algebraic datatypes to the language? That is, we want to
support translating any “new” type declaration into an isomorphic type deﬁned in
terms of our closed collection of primitive types. In this section we present such a
theory and call it the Closed Well-Order Types universe.

70
4.2.1
Closed Well-Order Types
The type of well-orderings (W) is used to deﬁne the semantics of inductive datatypes
in type theory, and is the key to solving our problem. After pruning some deriv-
able types from the previous universe and adding W types, we get a closed type
theory (the Closed Well-Order Types universe) that can internally represent any
type that would normally extend the language in an open type theory. Before
explaining what W types are and how they can be used to derive inductive types
(Section 4.2.2), we use them below to deﬁne a closed type theory universe sup-
porting custom user-deﬁned types.
data ‘Set : Set where
‘⊥‘⊤‘Bool : ‘Set
‘Σ ‘Π ‘W : (A : ‘Set) (B : J A K →‘Set) →‘Set
J_K : ‘Set →Set
J ‘⊥K = ⊥
J ‘⊤K = ⊤
J ‘Bool K = Bool
J ‘Σ A B K = Σ J A K (ń a →J B a K)
J ‘Π A B K = (a : J A K) →J B a K
J ‘W A B K = W J A K (ń a →J B a K)
The closed type theory above consisting of the empty type (⊥), the unit type
(⊤), and booleans (Bool) closed under dependent pair (Σ) formation, dependent
function (Π) formation, and well-order (W) formation allows us to model datatype
declarations. We show how to model datatype declarations by translating them
into W types and other primitive types in Section 4.2.2. In Section 4.2.3 we show
that the universe of this section is suﬃcient for all such translations.

71
4.2.2
Open Well-Order Types
The type of well-orderings [21] (W) can be used to model inductive datatype decla-
rations as well-founded trees.3 It is deﬁned below, where the A parameter encodes
non-inductive arguments for each constructor of an algebraic datatype, and the
cardinality of B a encodes the number of inductive arguments for each construc-
tor.4 The W type of well-orderings is open due to its two open type parameters,
A and B (in contrast, the arguments of the closed ‘W constructor are closed ‘Set
types.).
data W (A : Set) (B : A →Set) : Set where
sup : (a : A) (f : B a →W A B) →W A B
We show how to model the semantics of inductive datatypes using W by:
1. Starting with a high-level inductive datatype declaration.
2. Translating between a series of isomorphic datatype declarations.
3. Finally reaching a datatype declaration that can be encoded using a W type.
As an example of elaborating a datatype declaration to a W type, we begin
with the Tree type below. In the series of paragraphs that follow, we change the
deﬁnition of Tree by applying isomorphisms. Our binary Tree type begins with
leaves containing A values and binary branches containing B values in the middle
of each branch.
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : Tree A B →B →Tree A B →Tree A B
3 The etymology of “well-orderings” comes from W being the constructive version of the
classical notion of a well-order.
A well-order interprets a set as an ordinal α and a relation
specifying which ordinals are less than α. However, in this thesis we focus on the more practical
interpretation of W types as a means to deﬁne algebraic datatypes.
4 Besides cardinailty, the content of the B parameter also determines the domain of inﬁnitary
arguments [37].

72
A × B →C ∼= A →B →C
Replace multiple arguments of constructors by a
single uncurried argument. Single argument constructors remain unchanged.
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : Tree A B × B × Tree A B →Tree A B
A × B ∼= B × A
By commutativity of pairs, rearrange inductive constructor
arguments to all appear at the end.
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : B × Tree A B × Tree A B →Tree A B
A × B ∼= Π Bool (ń b →if b then A else B)
A non-dependent pair can
be deﬁned as a dependent function from a boolean to each component of the
pair. Replace all pairs of inductive constructor arguments with such a dependent
function whose domain cardinality is equal to the number of inductive arguments
for that constructor (i.e., Bool for 2 inductive arguments and ⊥for 0 inductive
arguments).
data Tree (A B : Set) : Set where
leaf : A × (⊥→Tree A B) →Tree A B
branch : B × (Bool →Tree A B) →Tree A B
(A →C) ⊎(B →C) ∼= A ⊎B →C
Replace the collection of constructors
with a single constructor. The new constructor’s argument type is the tuple of
right-nested disjoint unions formed from the argument types of each old construc-
tor.
data Tree (A B : Set) : Set where
list : (A × (⊥→Tree A B))

73
⊎(B × (Bool →Tree A B))
→Tree A B
(A × B) ⊎(A’ × B’) ∼= Σ (A ⊎A’) (ń x →if isLeft x then B else B’)
Replace the disjoint union of pairs whose domain is non-inductive arguments and
codomain is inductive arguments, with a single pair whose domain is the disjoint
union of non-inductive arguments and codomain is the disjoint union of inductive
arguments.5
data Tree (A B : Set) : Set where
list : Σ (A ⊎B) (ń x →if isLeft x
then (⊥→Tree A B)
else (Bool →Tree A B))
→Tree A B
data ∼= W
Encode the ﬁnal datatype declaration as a W type by using the ﬁrst
component of the pair for the A parameter, and the domains of each function in
the second component of the pair for the B parameter.
Tree : Set →Set →Set
Tree A B = W (A ⊎B) ń x →if isLeft x
then ⊥
else Bool
4.2.3
Inadequacy of Well-Orders
It would seem like W is a suﬃcient datatype to represent any inductive datatype
a user would deﬁne. Any Open Well-Order Type (i.e., any open algebraic type
deﬁned using W) can be translated to a Closed Well-Order Type, or a value of type
‘Set, by using the suﬃcient collection of primitive ‘Set constructors.
5 For datatypes with inﬁnitary arguments, B and B’ may depend on A and A’ respectively,
so the if conditional is replaced by case analysis.

74
For example, below we derive closed disjoint unions in terms of closed dependent
pairs (‘Σ) and booleans (‘Bool), and then translate the open Tree type to a closed
version deﬁned using the closed well-ordering (‘W) type former.
_‘⊎_ : ‘Set →‘Set →‘Set
A ‘⊎B = ‘Σ ‘Bool (ń b →if b then A else B)
‘Tree : ‘Set →‘Set →‘Set
‘Tree A B = ‘W (A ‘⊎B) ń x →if (not (proj1 x))
then ‘⊥
else ‘Bool
If W were adequate for our purposes, then this thesis could focus on writing fully
generic functions over the Closed Well-Order Type universe (‘Set) of Section 4.2.
We could write functions similar to sum from Section 2.2.3, except they would
work for any custom user-deﬁned type!
W types can be extended to support
deﬁnitions of indexed types (Section 2.1.5), which are isomorphic to inductive-
recursive (Section 2.1.9) types. However, there is one major issue:
Inadequacy
The base cases of inductively deﬁned datatypes using W have an
inﬁnite number of intensionally distinct values. Recall that the base case leaf had
⊥→Tree A B as its inductive argument. Because the domain of the function
is bottom, we can write it many diﬀerent ways (i.e., elim⊥, elim⊥◦elim⊥, etc.).
Even though all leaves containing such functions are extensionally equivalent, it
is inadequate [40] to have an inﬁnite number of intensionally (or, deﬁnitionally)
distinct canonical forms for the model of Tree (whose initial declaration was ﬁrst-
order).6
6 McBride also explains [40] that W types are inadequate for representing inductive types in
Observational Type Theory (OTT) [4], where evidence of extensional equality is internalized in
the types of the theory (unlike Extensional Type Theory, where the evidence is at the judgmental
level). In OTT, coercion between extensionally equal values requires explicit evidence of the
extensional equality, but this evidence is erased when coercing between equal values (rather than
neutral terms, and also assuming that the evidence is a value rather than a neutral term). In

75
W types are inadequate for our purposes because we are interested in depen-
dently typed languages (like Agda) implementing intensional type theory, rather
than extensional type theory. For this reason, we represent algebraic datatypes
using initial algebra semantics (instead of W types), as covered in Chapter 5. In
Chapter 6 we deﬁne a universe suitable for modeling closed type theory (i.e., a
dependently typed language supporting fully generic programming), using closed
initial algebra semantics, and analogous to the Closed Well-Order Types universe
of Section 4.2.
OTT, the induction principle of an inductive type can be derived from the induction principle
of W. However, coercion only erases the equality evidence used in the deﬁnition of the derived
induction principle for one of the inﬁnitely many base cases of an inductive type (for example,
zero as elim⊥would be erased, but elim⊥◦elim⊥, and subsequent compositions of elim⊥, would
not).

76
Part II
Open Type Theory

77
Chapter 5
OPEN ALGEBRAIC UNIVERSES
In Section 4.2.2 we derived custom user-deﬁned types as well-founded trees, or
well-orderings (W types). W types can be used to model datatype declarations in
a closed type theory (Section 4.2.1), without actually extending the metalanguage
as done in open type theory. Unfortunately, W types are inadequate (Section 4.2.3)
models of ﬁrst-order canonical terms.
In this chapter we present an adequate alternative to modeling datatype decla-
rations, using initial algebra semantics. In initial algebra semantics a datatype is
modeled as the least ﬁxed point (or ﬁxpoint for short) of a pattern functor. First,
we deﬁne an initial algebra semantics for datatypes in the language of category
theory, denoting types by their categorical model. Then, we show the equivalent
initial algebra semantics in the language of type theory (as implemented by Agda),
denoting types by their formal model. We do not fully deﬁne the constructions in
the categorical model, but rather appeal to widely known concepts to inspire and
elucidate the equivalent constructions in the formal model. For example, the syn-
tax of pattern functors from the categorical model becomes the type of descriptions
(Desc) in the formal model, and the ﬁxpoint operator from the categorical model
becomes the µ type (parameterized by Desc) in the formal model.
This chapter deﬁnes the initial algebra semantics for a series of progressively
more expressive classes of datatypes. All formal models in the series are expressed
as an open universe. The series ends with a formal model for inductive-recursive
types, which can also be used to model indexed types. In Chapter 6 we adapt the
formal model of inductive-recursive types as an open universe (Section 5.4) to a

78
closed universe (Section 6.2), suitable for fully generic programming.
Major Ideas
The purpose of this chapter is to deﬁne the type of ﬁxpoints (µ1)
used to model inductive-recursive types. This ﬁxpoint type is added as a built-in
type to our closed universe of user-declared types in Chapter 6, over which we per-
form fully generic programming in Chapter 7. This chapter reviews initial algebra
semantics for datatypes, and does not contain any novel technical contributions.
But, we build up to deﬁning inductive-recursive ﬁxpoints by starting from ﬁxpoints
for non-dependent types (Section 5.1), then moving to inﬁnitary non-dependent
types (Section 5.2), then moving to dependent types (Section 5.3), and ﬁnally
arriving at ﬁxpoints for inductive-recursive types (Section 5.4).
Our non-technical contribution is relating initial algebra semantics for these
progressively more complex classes of datatypes using common terminology, while
providing both a categorical and formal model of each class of datatypes. The
model of non-dependent types in Section 5.1 is the same as the model given by
Norell [48]. We make a minor extension of that model in Section 5.2 to support
inﬁnitary types. The model of inductive-recursive types in Section 5.4 is due to
Dybjer and Setzer [22, 23]. In Section 5.3 we present a restriction of the model of
Dybjer and Setzer to support dependent and inﬁnitary types, but not inductive-
recursive types. This restriction is somewhat interesting because its functors are
still deﬁned as a sequence of dependent pairs, ending in the unit type, or a “depen-
dent tuple”. More conventionally, dependent polynomials are not restricted to such
a dependent tuple format. We only use dependent tuple functors for dependent
types in Section 5.3 so that the explanation of functors for inductive-recursive types
in Section 5.4 progresses naturally from the explanation of functors for dependent
types in Section 5.3.

79
5.1
OPEN NON-DEPENDENT TYPES
In this section we review the initial algebra semantics for non-dependent and po-
tentially inductive (Section 2.1.3) types. We begin with the categorical model, and
then transition to the formal model (i.e., within type theory) by converting ab-
stract mathematical constructs to concrete datatypes (analogous to how we model
the abstract notion of a universe as concrete code and meaning function types in
Section 2.2.1).1 Henceforth, when we say “categorical model” or “formal model”,
we omit clarifying that these models are used as an initial algebra semantics of
types.
5.1.1
Categorical Model
The categorical model of an inductive datatype is the least ﬁxed point of a poly-
nomial equation represented as a pattern functor (F : Set →Set). The pattern
functor is an endofunctor from the category of sets to itself. We are only concerned
with the object map of the pattern functor, which maps a Set (representing a type)
to another Set.
The input of the pattern functor (conventionally named X) represents the in-
ductive set being deﬁned, and its output must be a set formed by polynomial
set constructions. The polynomial set constructions are denoted 1, (+), (·), and
X, and represent the unit set, the sum of two sets, the product of two sets, and
inductive occurrences of the set. Hence, algebraic datatypes can be encoded as
sums-of-products by using pattern functors, where “pattern” means that the func-
tors are restricted to the language of polynomial set expressions.
1 Here the words “abstract” and “concrete” have their general meanings, not the technical
meanings we deﬁned in Section 3.3.

80
Natural Numbers
For example, consider the datatype declaration for the nat-
ural numbers.
data N : Set where
zero : N
suc : N →N
The categorical model of the N type is the following ﬁxpoint equation.
N ≜µX. 1 + X
The plus operator (+) represents a choice between constructors, and is analo-
gous to the disjoint union type (⊎). Thus, above the left summand (1) represents
the zero constructor and the right summand (X) represents the suc constructor.
The zero constructor is represented by 1 (analogous to the unit type ⊤) because
it lacks arguments (or isomorphically, it has a single trivial argument). The suc
constructor is represented by the variable X, indicating that it takes an inductive
argument. This is because µ is binding X (in the semantic expression µX. 1 + X)
so that it may be used for inductive occurrences of N.
The equation used above is actually a shorthand for explicitly deﬁning a pattern
functor F : Set →Set and obtaining its least ﬁxed point by applying µ : (Set →
Set) →Set.
F ≜λX. 1 + X
N ≜µ F
Consider the notation using µ as a binder to be a shorthand for taking the
ﬁxpoint of an anonymous functor obtained by replacing the binding with a λ.
µX. 1 + X ≜µ (λX. 1 + X)

81
Binary Trees
As another example, consider the type of binary trees (parame-
terized by A and B) containing A’s in leaf positions and B’s in branch positions (as
presented in Section 4.2.2).
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : Tree A B →B →Tree A B →Tree A B
The categorical model of the Tree type is the following ﬁxpoint equation.
Tree ≜λA. λB. µX. A + X · B · X
The leaf constructor takes a single argument of type A, so the constructor
is represented by A (which is bound by a λ). The branch constructor has two
inductive arguments and a non-inductive argument of type B. Thus, its inductive
arguments are represented by X (bound by µ) and its non-inductive argument is
represented by B (bound by another λ). The multiplication operator (·) represents
multiple arguments of a constructor as a conjunction, and is analogous to the pair
type (×). Hence, the multiplication operator is used to deﬁne the “products” part
of a constructor with multiple arguments, in the sum-of-products representation
of datatypes.
5.1.2
Formal Model
To take advantage of a categorical model of initial algebra semantics within type
theory, we create a formal model by translating abstract deﬁnitions to concrete
datatypes and functions. Recall that µ semantically deﬁnes a datatype by taking
the ﬁxpoint (using µ) of a pattern functor F : Set →Set. It is called a pat-
tern functor because its “pattern” must be restricted to using the polynomial set
constructions covered in Section 5.1.1.
Informally (in the categorical model), we can check that a functor is deﬁned
under these restrictions, but in type theory (in the formal model) we must formally

82
capture these restrictions. We deﬁne the formal model by reifying:
1. The pattern fragment (enforcing the restriction to a polynomial language) of
functors as a datatype (Desc below).
2. The actual pattern functor as a computational type family (J_K below)
3. The ﬁxpoint operator as a datatype (µ below).
Descriptions
The ﬁrst part of our formal model is the type of descriptions
(Desc), a syntax for the pattern fragment of functors.
A Desc is the syntactic
reiﬁcation of the polynomial expression language that must be used for a functor
to qualify as a pattern functor (i.e., a Desc “describes” a valid, or pattern, functor).
Rather than deﬁning a pattern functor directly, we ﬁrst represent it as a Desc such
that any well-typed description can be converted into a functor meeting all pattern
restrictions.
Below, the Desc constructors ‘1, ‘X, (‘+), and (‘•) respectively reify a syntax
for the 1, X, (+), and (·) polynomial set constructions. Of special note is the
‘κ constant constructor. The constant constructor reiﬁes a syntax for injecting
non-inductive constructor arguments (such as A in the leaf constructor of Tree). 2
data Desc : Set1 where
‘1 ‘X : Desc
_‘+_ _‘•_ : Desc →Desc →Desc
‘κ : Set →Desc
For example, below is the description for the natural numbers datatype.
NatD : Desc
NatD = ‘1 ‘+ ‘X
Technically, ‘1 is subsumed by ‘κ applied to the unit type (⊤), but we keep
2 As is often the case with injections, its syntax is implicit (i.e., invisible) when deﬁning
pattern functors using polynomial set constructions. For example, the categorical model of trees,
using κ for explicit non-inductive arguments, would be λA. λB. µX. κ A + X · κ B · X.

83
‘1 for legibility. For example, natural numbers can equivalently be described as
follows.
NatD : Desc
NatD = ‘κ ⊤‘+ ‘X
Finally, note that we establish another convention of “quoting” description
constructors with a backtick (e.g., ‘X for X). This emphasizes that they are a
syntactic encoding of polynomial set constructions. As we will see, quoting Desc
constructors is natural as they also act as codes of a universe (Section 8.2.1).
Pattern Functors
The next part of our formal model is the reiﬁcation of pattern
functors (F : Set →Set) as type families (Section 2.1.6) with Set as their domain
(F : Set →Set). Rather than deﬁning F directly, we deﬁne a computational type
family (Section 2.1.11) to interpret (J_K : Desc →Set →Set) the language of
polynomial set constructions (Desc) as a pattern functor.
J_K : Desc →Set →Set
J ‘1 K X = ⊤
J ‘X K X = X
J A ‘+ B K X = J A K X ⊎J B K X
J A ‘• B K X = J A K X × J B K X
J ‘κ A K X = A
By partially applying the interpretation function to a description, we get a
model of a pattern functor F (rather than an arbitrary non-pattern functor).
∀D. J D K ≜F
For example, below we instantiate D to be the description of natural numbers
(NatD, deﬁned as ‘1 ‘+ ‘X), and demonstrate the functor produced by partially
applying the interpretation function to NatD.
J NatD K ≡(ń X →⊤⊎X)
Recall that the input to the pattern functor (F : Set →Set) represents the

84
inductive occurrences of the datatype being modeled. A sound model must rule
out pattern functors representing datatypes that are not consistent in type theory,
such as negative datatypes like Neg of Section 2.1.8.
In Agda, we could directly deﬁne the functor for Neg to be (F X = X →X),
modeling the negative inductive occurrence of Neg in the argument to neg by using
X in the domain of the function type. However, deﬁning a ﬁxpoint datatype for
such a negative functor would be rejected by Agda’s positivity checker, as it would
make the language unsound.
Instead, we choose to deﬁne functors indirectly by partially applying a descrip-
tion to the interpretation function (rather than deﬁning functors directly like the
one for Neg above). In other words, the output Set of F is only composed of type
theory equivalents of polynomial set constructions. For example, the output Set
may use disjoint unions (⊎), modeling (+), by interpreting the (‘+) description. It
may not use other arbitrary types lacking a polynomial set construction equivalent
(because their is no Desc for them), like functions (→) with negative occurrences
of X.
Finally, note that it may appear that ‘κ could be used to inject many non-
polynomial types. While this is true, it is not problematic because the type (A)
that ‘κ injects must be non-inductive. The non-inductivity of A is enforced because
A must be a type deﬁned independently of X. In other words, the interpretation
of ‘κ (i.e., J ‘κ A K X = A) does not pass X to A.
Fixpoints
The ﬁnal part of our formal model is the reiﬁcation of the least ﬁxed
point operator (µ : (Set →Set) →Set) for pattern functors. We reify the least
ﬁxed point operator (µ : Desc →Set) as a datatype parameterized by a description,
rather than a pattern functor (Set →Set).
While the categorical model applies the least ﬁxpoint operator directly to a
pattern functor (µ F), our model instead applies it to a description (µ D). The

85
pattern functor (Set →Set) argument of µ can be derived by the model µ by
partially applying the interpretation function to the description argument (J D K :
Set →Set). Below is the datatype declaration for the ﬁxpoint operator (µ), and
its constructor (init) is declared shortly thereafter.
data µ (D : Desc) : Set where
In the categorical model the initial algebra (αinit) is used to construct values of
the ﬁxpoint of a functor F.
αinit : F (µ F) →µ F
Applying F to its least ﬁxed point (µ F) results in a type isomorphic to its
ﬁxpoint.
In other words, the Set (or Set in the formal model) resulting from
F (µ F) represents the types of constructors (and the types of their arguments)
of µ F.
Therefore, the formal model of the ﬁxpoint operator (µ) has a single
constructor named init (for initial algebra), corresponding to αinit in the categorical
model.
init : J D K (µ D) →µ D
Recall that we model the pattern functor (F) by partially applying (J D K)
the interpretation function to the description of the pattern functor. Additionally,
our model of the ﬁxpoint operator applies it to a description (µ D), rather than a
pattern functor directly. Therefore, the type of the argument to init represents the
types of the constructors (and the types of their arguments) for µ D.
For example, we can deﬁne the type of natural numbers (described by NatD as
‘1 ‘+ ‘X) as follows.
N : Set
N = µ NatD
Natural numbers are constructed by applying init to values of the following

86
type.
J NatD K N ≡(⊤⊎N)
Finally, notice that descriptions and ﬁxpoints can also be interpreted as a
universe (i.e., the universe of open algebraic types) by considering them to be
codes (Desc : Set) and a meaning function (µ : Desc →Set) respectfully.
5.1.3
Examples
Having formally modeled initial algebra semantics by reifying parts of the cate-
gorical model as datatypes of type theory, now we provide examples of modeling
speciﬁc type formers and values (using the formal model).
Natural Numbers
We have already seen how to encode the type of natural
numbers as the disjunction of the unit type and an inductive occurrence.
NatD : Desc
NatD = ‘1 ‘+ ‘X
N : Set
N = µ NatD
Recall that the type of the argument to the init constructor represents a choice of
which constructor to use, and the types of the arguments for the chosen constructor.
For the natural numbers, this type specializes as follows.
J NatD K N ≡(⊤⊎N)
To model the zero constructor, we choose the left injection of the disjoint union
type (deﬁned in Section 2.1.4), and apply it to the trivial unit constructor.
zeroArgs : ⊤⊎N
zeroArgs = inj1 tt
To construct a value of a ﬁxpoint (e.g., µ NatD), rather than the meaning

87
function applied to its ﬁxpoint, we must apply the initial algebra (init). We leave
out describing this step explicitly in future exposition.
zero : N
zero = init zeroArgs
To model the suc constructor, we apply the right injection of disjoint union to
the previous natural number (n), given as a function argument.
suc : N →N
suc n = init (inj2 n)
There is no need to provide examples of using natural numbers encoded using
our formal model. Once we model the type former and constructors according
to their standard interface (i.e., their standard type signatures), their usage is
indistinguishable from using type formers and constructors deﬁned using datatype
declarations (rather than µ).
two : N
two = suc (suc zero)
The example above expands to the encoded term below, but by using the
standard interface of type formers and constructors we do not need to construct it
manually.
two’ : µ (‘1 ‘+ ‘X)
two’ = init (inj2 (init (inj2 (init (inj1 tt)))))
Similarly, any function deﬁned by pattern matching can retain its standard ap-
pearance of pattern matching on declared constructors by using pattern synonyms.
Pattern synonyms are a notational feature of Agda that expands the left hand
syntax to the term on the right hand side. Pattern synonyms can be used in the
pattern matching fragment of the language. Thus, by deﬁning pattern synonyms
for zero and suc to expand into their init encodings, we can write functions like

88
plus in a way that is oblivious to the underlying encoding.
pattern zero = init (inj1 tt)
pattern suc n = init (inj2 n)
plus : N →N →N
plus zero m = m
plus (suc n) m = suc (plus n m)
The addition function above expands to the version below, deﬁned by pattern
matching on constructors of our encoding (init et al.). The encoding also expands
in the body of the function, such as the successor case of the addition function.
plus’ : µ (‘1 ‘+ ‘X) →µ (‘1 ‘+ ‘X) →µ (‘1 ‘+ ‘X)
plus’ (init (inj1 tt)) m = m
plus’ (init (inj2 n)) m = init (inj2 (plus’ n m))
In future examples, we omit examples of non-constructor values and functions
deﬁned over modeled types. As explained, once we have derived the type former
and constructors of a type using the primitives of our formal model, using the types
to deﬁne values and function deﬁnitions is indistinguishable from using declared
types thanks to syntactic conveniences aﬀorded by Agda.
Hence, all functions
deﬁned over declared types in Section 2.1 can be reused as functions over our
formally modeled algebraic types.
Binary Trees
The type of binary trees (Section 5.1.1) is modeled by a function
taking its parameters (A and B), and returning the description of the disjoint
union of A (encoding the leaf constructor), and the triple (as 2 right-nested pairs)
consisting of two inductive occurrences and B (encoding the branch constructor).
TreeD : Set →Set →Desc
TreeD A B = ‘κ A ‘+ (‘X ‘• (‘κ B ‘• ‘X))
Tree : Set →Set →Set

89
Tree A B = µ (TreeD A B)
J TreeD A B K (Tree A B) ≡(A ⊎(Tree A B × (B × Tree A B)))
To model the leaf constructor, we apply the left disjoint union injection to the
function argument of type A (i.e., the node value for the leaf).
leaf : {A B : Set} →A →Tree A B
leaf a = init (inj1 a)
To model the branch constructor, we apply the right disjoint union injection to
a triple (2 right-nested pairs). The triple consists of the ﬁrst inductive function
argument (i.e., the left branch), the function argument of type B (i.e., the node
value for the branch), and the second inductive function argument (i.e., the right
branch).
branch : {A B : Set} →Tree A B →B →Tree A B →Tree A B
branch t1 b t2 = init (inj2 (t1 , (b , t2)))
λ-Calculus Terms
We introduce the type of untyped λ-calculus terms (Term)
as a ﬁnal and slightly more complex example (i.e., modeling a type with more than
2 constructors). Below we declare the Term type consisting of variable references
(var), lambda abstractions (lam), and applications (app).
data Term : Set where
var : (n : N) →Term
lam : (b : Term) →Term
app : (f : Term) (a : Term) →Term
Our untyped lambda calculus terms use a deBruijn [15] encoding for variables.
A deBruijn-encoded term references variables by a natural number index, where 0
refers to the variable bound by the most recent λ (and 1 refers to the next most
recent, and so on).
For example, below is a high-level syntax for the Church-
encoded [8] numeral one and its deBruijn-encoded equivalent. In the example,

90
the term on the left names its variables, while the term on the right uses deBruijn
variables, but both terms Church-encode the numeral one.
one ≜λf. λx. f x ≜λ (λ 1 0)
As a Term, we write the deBruijn-encoded numeral one as follows. Note the
applications of the variable constructor (var) to natural numbers (N) to refer to
variables by their deBruijn index.3
one : Term
one = lam (lam (app (var 1) (var 0)))
To model Term, we describe the disjoint union of the natural numbers (encoding
var) with the disjoint union of an inductive occurrence (encoding lam) and a pair
of inductive occurrences (encoding app). This models three constructors using two
right-nested disjoint unions.
TermD : Desc
TermD = ‘κ N ‘+ (‘X ‘+ (‘X ‘• ‘X))
Term : Set
Term = µ TermD
J TermD K Term ≡(N ⊎(Term ⊎(Term × Term)))
To model the var constructor, we apply the left disjoint union injection to the
natural number argument.
var : N →Term
var n = init (inj1 n)
To model the lam constructor, we apply the left disjoint union injection to: the
3 Our Term type is not scope safe in the sense that their could be natural numbers that are out
of bounds with respect to the number of lam occurrences. We could index Term by the natural
numbers to enforce scope safety, but this additional complexity only makes later examples (of
the semantics for Term, already deﬁned using indexed types) harder to read without introducing
new concepts.

91
right disjoint union injection applied to the inductive argument.
lam : Term →Term
lam b = init (inj2 (inj1 b))
To model the app constructor, we apply the left disjoint union injection to:
another left disjoint union injection but applied to a pair of inductive arguments.
app : Term →Term →Term
app f a = init (inj2 (inj2 (f , a)))
5.2
OPEN INFINITARY TYPES
In this section we review the initial algebra semantics for inﬁnitary (Section 2.1.8)
non-dependent types. We extend our previous categorical model, formal model,
and examples, to support inﬁnitary constructor arguments.
5.2.1
Categorical Model
The categorical model of inﬁnitary inductive datatypes reuses the 1, (+) and (·)
polynomial set constructions. However, the inductive occurrences construction X
is subsumed by the inﬁnitary occurrences construction XA.
Functions are the
type theoretic equivalent of exponential terms, where X raised to the power of A
is equivalent to a function with domain A and codomain X.4
XA ≜(A →X)
Therefore, XA is notation for an inﬁnitary polynomial set construction whose
domain is A and whose codomain is an inductive occurrence. Any non-inﬁnitary
inductive argument X can be isomorphically expressed as an inﬁnitary argument
by raising X to the power of 1 (or equivalently, a function whose domain is 1 and
whose codomain is X).
4 If A and X are ﬁnite sets, then the cardinality of XA is equal to the cardinality of the graph
of the function A →X.

92
X ∼= (X1 ≜1 →X)
Natural Numbers
For example, consider the inﬁnitary (but isomorphic) dec-
laration of the natural numbers below. The inductive argument to the suc con-
structor has been replaced with the inﬁnitary argument f, using the unit type as
its domain.
data N : Set where
zero : N
suc : (f : ⊤→N) →N
The categorical model of the inﬁnitary N type is the ﬁxpoint equation below.
N ≜µX. 1 + X1
The only diﬀerence between the non-inﬁnitary and inﬁnitary N is that con-
structing it with suc must supply a function ignoring a ⊤argument, and destruc-
ting suc requires applying f to the trivial value tt to access the inductive value in
the body of f.
Binary Trees
Below is a straightforward inﬁnitary encoding of binary trees,
replacing both inductive arguments of branch with inﬁnitary ones by using the
unit type as the domain.
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : (f : ⊤→Tree A B) (b : B) (g : ⊤→Tree A B) →Tree A B
This translates to the categorical model of inﬁnitary binary trees below, without
any surprises.
Tree ≜λA. λB. µX. A + X1 · B · X1
However, recall our series of isomorphic translations of the binary tree declara-
tion used to model Tree via W types (Section 4.2.2). We can borrow two of those

93
isomorphisms to transform Tree into a less trivial instance of an inﬁnitary type
(i.e., one whose inﬁnitary domains are types other than unit).
First, we reorder the b argument (of type B) to the front via symmetry (A ×
B ∼= B × A), swapping b and the inductive argument t1 so that both inductive
arguments (t1 and t2) to appear at the end of branch.
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : (b : B) (t1 : Tree A B) (t2 : Tree A B) →Tree A B
Second, we appeal to the isomorphism that deﬁnes a non-dependent pair (the
two arguments t1 and t2 above) as a dependent function (f below) from Bool to
each component of the pair (A × B ∼= Π Bool (ń b →if b then A else B)).
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : (b : B) (f : Bool →Tree A B) →Tree A B
This translates both inductive arguments into a single inﬁnitary argument,
where the domain is now Bool instead of ⊤. It makes sense for the domain (i.e.,
branching factor) to be Bool, as we are deﬁning binary trees.
Given that the
cardinality of Bool is 2, we use initial algebra semantics to deﬁne a categorical
model of inﬁnitary binary trees by raising X to the power of 2 in the encoding of
the branch constructor.
Tree ≜λA. λB. µX. A + B · X2
5.2.2
Formal Model
To formally model inﬁnitary types, we make minor changes to our previous non-
inﬁnitary formal model (Section 5.1.2). In all aspects of our formal model, we
change from modeling merely inductive occurrences of types (X) to inﬁnitary oc-
currences (XA).

94
Descriptions
Our formal model of descriptions stays the same, except that we
replace the syntax for inductive occurrences (‘X) with a syntax for inﬁnitary oc-
currences (‘X^). While inductive occurrences (‘X) have no arguments, inﬁnitary
occurrences (‘X^) have a Set argument representing the domain of the inﬁnitary
function type.
data Desc : Set1 where
‘1 : Desc
_‘+_ _‘•_ : Desc →Desc →Desc
‘κ ‘X^ : Set →Desc
For example, below we convert the suc constructor in the description of natural
numbers to take an inﬁnitary argument with a trivial domain.
NatD : Desc
NatD = ‘1 ‘+ ‘X^ ⊤
Finally, note that the “caret” in the syntax of inﬁnitary occurrences (‘X^)
connotes raising an inductive occurrence to some power (the power being the car-
dinality of the domain argument of type Set).
Pattern Functors
Again, pattern functors (F : Set →Set) are not formally
modeled directly. Instead, the formal model of a pattern functor (F : Set →Set)
is the result of partially applying the interpretation function to a description (J_K
: Desc →Set →Set).
The interpretation of all patterns besides the inﬁnitary pattern ‘X^ remains the
same. The inﬁnitary pattern ‘X^ A is interpreted as a function with domain A and
codomain X. It is crucial that X (representing an inductive occurrence) appears
in the codomain (rather than domain) of the function. Otherwise, our subsequent
ﬁxpoint construction (µ) would support negative datatypes (the Agda positivity
checker prevents us from deﬁning µ with X in the interpreted function domain

95
even if we tried).
J_K : Desc →Set →Set
J ‘1 K X = ⊤
J A ‘+ B K X = J A K X ⊎J B K X
J A ‘• B K X = J A K X × J B K X
J ‘κ A K X = A
J ‘X^ A K X = A →X
Partially applying NatD (‘1 ‘+ ‘X^ ⊤) to the interpretation function results in
the following pattern functor for an inﬁnitary encoding of natural numbers.
J NatD K ≡(ń X →⊤⊎(⊤→X))
Notice how the argument of the suc constructor, which is the type to the right of
the disjoint union, is an function from the unit type to the inductive X occurrence.
Fixpoints
The initial algebra semantics for least ﬁxed points (µ : (Set →
Set) →Set) of inﬁnitary types is formally modeled (µ : Desc →Set) the same
way as the non-inﬁnitary version. The init constructor of µ, modeling the initial
algebra (αinit), is also unchanged.
data µ (D : Desc) : Set where
init : J D K (µ D) →µ D
The natural numbers can be deﬁned as a ﬁxpoint of their description, as before.
N : Set
N = µ NatD
The type of the argument to the initial algebra of natural numbers is like the
type of the natural number pattern functor, except with X replaced by the type
of natural numbers. This makes the argument to the suc constructor an inﬁnitary
type, as the codomain ends with an inductive occurrence (the N) type.
J NatD K N ≡(⊤⊎(⊤→N))

96
5.2.3
Examples
Now we repeat the examples of formal models of non-inﬁnitary types (Section 5.1.2),
converting models to their inﬁnitary counterparts. A straightforward translation
from the non-inﬁnitary to the inﬁnitary models inﬁnitary versions of both the
pattern functors and the exposed datatypes.
Alternatively, we can expose a model of non-inﬁnitary datatypes that are de-
ﬁned in terms of unexposed inﬁnitary pattern functors. In this scenario type for-
mers do not require special treatment (i.e., their deﬁnitions can be equivalent to
their non-inﬁnitary counterparts). However, we must take special care when mod-
eling constructors by exposing a non-inﬁnitary type signature (i.e., interface) that
is deﬁned in terms of an inﬁnitary (hidden, or unexposed) implementation.
Natural Numbers
Let’s begin with the straightforward model of inﬁnitary nat-
ural numbers, deﬁned with a model of an inﬁnitary pattern functor. The inﬁnitary
(due to the f argument) deﬁnition of natural numbers is below.
data N : Set where
zero : N
suc : (f : ⊤→N) →N
The inﬁnitary pattern functor for this type is described by NatD. Its type former
N appears below, and is modeled the same way as its non-inﬁnitary counterpart
in Section 5.1.2.
NatD : Desc
NatD = ‘1 ‘+ ‘X^ ⊤
N : Set

97
N = µ NatD
J NatD K N ≡(⊤⊎(⊤→N))
The model of the zero constructor is also the same as its non-inﬁnitary coun-
terpart.
zero : N
zero = init (inj1 tt)
The model of the suc constructor is diﬀerent, because it takes an inﬁnitary
argument (f).
suc : (⊤→N) →N
suc f = init (inj2 f)
But what if we wanted to model the non-inﬁnitary deﬁnition of natural numbers
below, even though we can only Describe inﬁnitary pattern functors?
data N : Set where
zero : N
suc : N →N
To expose a model of a non-inﬁnitary type, with an unexposed inﬁnitary pattern
functor, we never need to change the type former (so our deﬁnition of N above
suﬃces). Because zero was never inﬁnitary to begin with, its previous deﬁnition
can also be reused.
However, we take special care to expose a model of a non-inﬁnitary suc con-
structor in terms of its underlying (unexposed) inﬁnitary pattern functor NatD.
We expose the non-inﬁnitary type signature of suc, acting as an interface. The
implementation of the inﬁnitary pattern functor of the formal model is hidden by
this interface.
suc : N →N

98
suc n = init (inj2 (ń u →n))
The implementation ignores the trivial argument u when constructing the pre-
decessor as an inﬁnitary function using the inductive input n.
Binary Trees
Our pattern functor for binary trees models the inﬁnitary deﬁni-
tion of binary trees below.
data Tree (A B : Set) : Set where
leaf : A →Tree A B
branch : (b : B) (f : Bool →Tree A B) →Tree A B
The description of the binary tree pattern functor, and its type former, are
given below.
TreeD : Set →Set →Desc
TreeD A B = ‘κ A ‘+ (‘κ B ‘• ‘X^ Bool)
Tree : Set →Set →Set
Tree A B = µ (TreeD A B)
J TreeD A B K (Tree A B) ≡(A ⊎(B × (Bool →Tree A B)))
The model of the leaf constructor is straightforward, as it is not inﬁnitary.
leaf : {A B : Set} →A →Tree A B
leaf a = init (inj1 a)
However, we model a non-inﬁnitary branch constructor in terms of its underly-
ing inﬁnitary pattern functor. Below the model of the branch constructor is non-
inﬁnitary because its type signature does not contain any inﬁnitary arguments
(despite the fact that its implementation supplies inﬁnitary values to the initial
algebra, deﬁned in terms of an inﬁnitary pattern functor).
branch : {A B : Set} →Tree A B →B →Tree A B →Tree A B

99
branch t1 b t2 = init (inj2 (b , (ń x →if x then t1 else t2)))
The second component of the pair (in the right disjoint union injection) is an
inﬁnitary function from Bool to Tree A B. Therefore, we simulate a non-inﬁnitary
branch by applying a conditional to the boolean argument of the function, returning
the inductive t1 argument in the true case and the inductive t2 argument in the
false case.
Above, we use the inﬁnitary domain of Bool (which is isomorphic to ⊤⊎⊤) to
model 2 inductive arguments. In general, the number of inductive arguments can
be modeled with an appropriate type according to the pattern below.
0
⊥
1
⊤
2
⊤⊎⊤
3
⊤⊎⊤⊎⊤
n
...
5.3
OPEN DEPENDENT TYPES
In this section, we review the initial algebra semantics for dependent types. We ex-
tend our previous inﬁnitary and non-dependent categorical model (Section 5.2.1),
and formal model (Section 5.2.1), to support constructor argument types that
depend on previous constructor arguments.
5.3.1
Categorical Model
Compared to non-dependent types, the categorical model’s “type signatures” for
pattern functors (F : Set →Set) and least ﬁxed points (µ : (Set →Set) →Set)
remain unchanged in the setting of dependent initial algebra semantics. However,
we change the language of polynomial set constructions to be able to describe
pattern functors of types involving dependencies.

100
We mostly keep the syntax of the non-dependent polynomial set constructions
1, (+), (·), and X. However, the meaning of the product of two sets (·) is actually
the dependent product (or dependent pair). The syntax of a dependent product
uses type ascription (e.g., (x : A) · B x), allowing the type (B) of the second
component of the pair to depend on the value (x) of the ﬁrst. In contrast, the
syntax of a non-dependent product (e.g., A·B) does not name the type of the ﬁrst
component of the pair. For example, dependent product can be used to express the
set of pairs of natural numbers and ﬁnite sets (whose size depends on the natural
number ﬁrst component of the pair).
(n : N) · Fin n
While we continue to use the sum of two sets operator (+), it can now be derived
using dependent (·) rather than be a primitive polynomial set construction. The
deﬁnition of (+) is derived as the dependent product of a boolean (the 2-element
set) and a choice of either subterm.
(+) ≜λA. λB. (b : 2) · if b then A else B
We impose an additional restrictions on pattern functors (which are already
restricted to contain only positive inductive occurrences) to always end in the unit
set 1. That is, pattern functors must take the form of a (possibly empty) sequence
of products (of either non-dependent or dependent arguments), ending in 1.5 For
example, below is the product of a dependent natural number, a non-dependent
inﬁnitary occurrence, and 1.
F ≜λX. (n : N) · XFin n · 1
In general, the pattern functor is a (possibly dependent) product of n (possibly
0) sets, ending in a multiplication by the unit set 1.
Each of the n sets (i.e.,
5 Any set A is isomorphic to A · 1. This is analogous to any type A being isomorphic to the
pair type A × ⊤, as the unit type only adds trivial (tt) information.

101
each Ai below) may dependent on the values of previous sets (i.e., each xi below).
Additionally, each Ai may be non-inductive (not using X) or inﬁnitary (using X).
F ≜λX. (x0 : A0) · (x1 : A1 x0) · (x2 : A2 x1 x2) · ... · (xn : An x0 ... xn−1) · 1
The purpose of these additional constraints may not be readily apparent now.
However, they allow us to seamlessly extend the categorical model of dependent
types to include induction-recursion (in Section 5.4).
Finally, note that any use of sums (+) obeys our constraint as long as the left
and right subterms obey the constraint. This is because the derived deﬁnition of
(+) expands to a product.
F ≜(λX. 1 + 1) ≜(b : 2) · if b then 1 else 1
Natural Numbers
We reuse the inﬁnitary deﬁnition of the natural numbers
from Section 5.2.1.
data N : Set where
zero : N
suc : (f : ⊤→N) →N
Compared to the inﬁnitary and non-dependent (Section 5.2.1) natural numbers
ﬁxpoint, the only diﬀerence in our dependent setting is that the suc constructor
ends by multiplying by 1 (obeying our constraint).
N ≜µX. 1 + X1 · 1
Technically, the (+) is just notation so the true ﬁxpoint is the expanded deﬁ-
nition below.
N ≜µX. (b : 2) · if b then 1 else X1 · 1

102
Rose Trees
We use the inﬁnitary deﬁnition of ﬁnitely branching rose trees from
Section 2.1.8. In this deﬁnition of Rose, the list-of-branches argument is isomor-
phically expressed as a natural number and an inﬁnitary argument with a ﬁnite
set (whose size is equal to the natural number) as its domain.
data Rose (A : Set) : Set where
rose : A →(n : N) (f : Fin n →Rose A) →Rose A
The categorical model of inﬁnitary rose trees must be deﬁned in terms of de-
pendent product, as the ﬁnite set (Fin n) inﬁnitary domain is dependent on the
natural number (n) argument.
Rose ≜λA. µX. A · (n : N) · XFin n · 1
5.3.2
Formal Model
Our formal model of least ﬁxed points is similar to previous versions. However,
formally modeling dependencies in pattern functors requires signiﬁcant changes,
especially changes to the structure of pattern functor descriptions.
Descriptions
Recall from Section 5.3.1 that we constrained dependent pattern
functors to be a sequence of products ending in 1. Recall also that descriptions
are the reiﬁcation (or formal model) of the language used to create legal pattern
functors. Hence, we change the type of descriptions to enforce that pattern functors
(representing deﬁnitions of datatypes) are sequences of dependent pairs (Σ) ending
in the unit type (⊤). Now we explain the deﬁnition of Desc for dependent algebraic
types, and subsequently compare it to the Desc for non-dependent types from
Section 5.2.2.
Below (in the deﬁnition of Desc), the ‘Ì constructor models the pattern of ending
a functor with the unit type. For now, this is simply a renaming of the former

103
‘1 constructor.6 The ‘σ constructor models a dependent (but non-inﬁnitary, thus
also non-inductive) argument. The ‘δ constructor models an inﬁnitary (but non-
dependent) argument.7 Thus, while the pattern functor of the categorical model
uses a single product (·) for any argument, our new description syntax distinguishes
between dependent (‘σ) and inﬁnitary non-dependent (‘δ) arguments.
data Desc : Set1 where
‘Ì : Desc
‘σ : (A : Set) (D : A →Desc) →Desc
‘δ : (A : Set) (D : Desc) →Desc
Compare this with the non-dependent description datatype (Section 5.2.2).
The non-dependent pair (‘•) there is replaced by the (no longer inﬁx) dependent
pair ‘σ and inﬁnitary non-dependent pair ‘δ. For example, RoseD, deﬁned below,
is the description of Rose trees. RoseD uses ‘σ to request a dependent A argument
(although the dependency a is unused), then uses ‘σ to request a dependent nat-
ural number argument (n), then uses ‘δ to request a non-dependent but inﬁnitary
argument (whose domain is Fin n), and ﬁnally ends with ‘Ì.
RoseD : Set →Desc
RoseD A = ‘σ A (ń a →‘σ N (ń n →‘δ (Fin n) ‘Ì))
When ‘σ is used to request an argument of type A, the rest of the description
D may depend on a value of A. This is formally modeled by the inﬁnitary type
of D, namely A →Desc. Notice that the ﬁrst argument of the non-dependent
pair (‘•) from Section 5.2.2 is a description (Desc), but the ﬁrst argument of the
dependent pair ‘σ is a type (Set). Imagine that A was a description, and that
6 However, in our subsequent extension supporting inductive-recursive types (Section 5.4)), ‘Ì
gains additional arguments.
7 At this point it does not make sense for an inﬁnitary argument (‘δ) to be dependent. At
the time a datatype is deﬁned, no functions exist that could operate over it. Hence, inductive
occurrences need not be dependent arguments because there is no way to use the type being de-
ﬁned yet. However, once we extend descriptions to model inductive-recursive types (Section 5.4)
we will need to add a notion of dependency to ‘δ.

104
D could depend on a value of the inductive type being deﬁned (as the argument
to the inﬁnitary domain of D). Then, our type of descriptions (Desc) would be
negative (and we could subsequently use it to model pattern functors of negative
types). Hence, the ﬁrst component of a dependent pair (A) must be restricted to
a Set (guaranteed to be non-inductive) so that the inﬁnitary type D (representing
subsequent arguments in the description) remains positive.
The inﬁnitary pair constructor ‘δ is like a specialized combination of the former
inﬁnitary constructor ‘X^ and the non-dependent pair constructor (‘•). The A
argument represents the domain of the inﬁnitary function (like the argument to
‘X^), and the non-dependent D argument represents the rest of the description
(which cannot depend on the inductive occurrence because the inductive type has
not been deﬁned yet).
We can use ‘σ to derive (‘+) as a dependent pair of a boolean and a choice
of branches, similar to how we derived sums (+) from dependent products (·) for
pattern functors (Section 5.3.1).
_‘+_ : Desc →Desc →Desc
D ‘+ E = ‘σ Bool (ń b →if b then D else E)
Additionally, we can derive ‘κ and ‘X^ using ‘σ and ‘δ respectfully, then im-
mediately ending with ‘Ì (as these derived constructors do not require additional
arguments).
‘κ : Set →Desc
‘κ A = ‘σ A (ń a →‘Ì)
‘X^ : Set →Desc
‘X^ A = ‘δ A ‘Ì
Finally, we emphasize that (‘•) cannot be derived from ‘σ and ‘δ. It is not clear
whether the ﬁrst argument (a Desc) to (‘•) contains an inﬁnitary (hence inductive)

105
occurrence, so we cannot decide whether to proceed by using ‘σ (disallowing in-
ductiveness) or ‘δ (allowing inductiveness). Additionally, we would somehow need
to convert the ﬁrst argument of (‘•), a Desc, to the ﬁrst argument of ‘σ or ‘δ, a
Set.
Pattern Functors
Now we deﬁne the interpretation function (J_K : Desc →Set
→Set) that can be partially applied to descriptions of dependent types to produce
formal models (F : Set →Set) of pattern functors (F : Set →Set) for dependent
types. The type signatures of these constructions (J_K and F) remains the same
when adding dependent arguments, but the implementations change (because the
constructors of Desc changed).
J_K : Desc →Set →Set
J ‘Ì K X = ⊤
J ‘σ A D K X = Σ A (ń a →J D a K X)
J ‘δ A D K X = (A →X) × J D K X
We interpret the ‘Ì constructor as the unit type (⊤).
We interpret the ‘σ
constructor as a dependent pair (Σ) whose ﬁrst component is an A, and whose
second component is the interpretation of the rest of the description (which may
depend on the ﬁrst component). We interpret the ‘δ constructor as a non-dependent
pair (×) whose ﬁrst component is an inﬁnitary function from A to X (representing
an inductive occurrence), and whose second component is the interpretation of the
rest of the description (which may not depend on the ﬁrst component).
Partially applying RoseD (along with its parameter A) to the interpretation
function results in the following pattern functor for rose trees.
RoseD : Set →Desc

106
RoseD A = ‘σ A (ń a →‘σ N (ń n →‘δ (Fin n) ‘Ì))
J RoseD A K ≡(ń X →Σ A (ń a →Σ N (ń n →(Fin n →X) × ⊤)))
Notice how the A and natural number arguments are interpreted using de-
pendent pairs (Σ), and how the inﬁnitary argument is interpreted using a non-
dependent pair (×).
Fixpoints
The formal model (µ : Desc →Set) of least ﬁxed points (µ : (Set →
Set) →Set) of dependent types is unchanged, as is the formal model (init) of the
initial algebra (αinit).
data µ (D : Desc) : Set where
init : J D K (µ D) →µ D
As an example, below is the datatype of rose trees deﬁned as a ﬁxpoint.
Rose : Set →Set
Rose A = µ (RoseD A)
J RoseD A K (Rose A) ≡Σ A (ń a →Σ N (ń n →(Fin n →Rose A) × ⊤))
5.3.3
Examples
Now we model the type formers and constructors of (possibly) dependent datatypes.
The descriptions of these datatypes are interpreted as models of pattern functors
constrained to be sequences of dependent and non-dependent inﬁnitary pairs, end-
ing in the unit type.
Rose Trees
We begin by modeling rose trees, because they demonstrate depen-
dencies between argument types while also being simple because they only have a
single constructor. First, we repeat the deﬁnition of the rose tree description, its

107
pattern functor, and its type former as a ﬁxpoint.
RoseD : Set →Desc
RoseD A = ‘σ A (ń a →‘σ N (ń n →‘δ (Fin n) ‘Ì))
Rose : Set →Set
Rose A = µ (RoseD A)
J RoseD A K (Rose A) ≡Σ A (ń a →Σ N (ń n →(Fin n →Rose A) × ⊤))
Now we model the single constructor (rose) of Rose trees. Note that we are
modeling the inﬁnitary rose constructor (Section 2.1.8), rather than its List of roses
variant, as indicated by the type signature of our derived rose constructor.
rose : {A : Set} (a : A) (n : N) (f : Fin n →Rose A) →Rose A
rose a n f = init (a , (n , (f , tt)))
Because our dependent types are modeled as least ﬁxed points of functors
constrained to be sequences of pair types, values (e.g., like the rose constructor)
are simply the initial algebra of a tuple encoded as a sequence of right-nested pairs
(ending in the trivial unit value tt).
Natural Numbers
Let’s encode a model of natural numbers using descriptions
for dependent types.
We begin with the pattern functor for a dependent and
inﬁnitary encoding of the natural numbers. The zero constructor immediately ends
with ‘Ì. The suc constructor uses ‘δ to demand a trivial (i.e., where the domain is
the unit type) inﬁnitary argument (similar to Section 5.2.3), then ends with ‘Ì.
NatD : Desc
NatD = ‘Ì ‘+ ‘δ ⊤‘Ì
Recall from Section 5.3.2 that a choice of constructors (‘+) is derived as a
dependent pair with a boolean domain and a choice between descriptions, so the

108
NatD above expands to the version below.
NatD : Desc
NatD = ‘σ Bool (ń b →if b then ‘Ì else ‘δ ⊤‘Ì)
For legibility (especially when describing types with more than 2 constructors),
we often create a specialized enumeration type (NatT below) that takes the place
of Bool. Then, we deﬁne the second argument to ‘σ as a separate function (NatDs
below) mapping enumeration tags (representing constructors) to descriptions (rep-
resenting constructor arguments). For example, we can encode the description of
natural numbers by matching on “tags” of the enumeration type NatT.
data NatT : Set where
zeroT sucT : NatT
NatDs : NatT →Desc
NatDs zeroT = ‘Ì
NatDs sucT = ‘δ ⊤‘Ì
NatD : Desc
NatD = ‘σ NatT NatDs
By convention, names of tags are suﬃxed with "T".
Tags are merely enu-
merations and do not have arguments themselves. Rather, we match on tags in
descriptions to declare the descriptions of arguments for each constructor (where
each constructor is represented by a tag case).
Now let’s ﬁnish by modeling the type of natural numbers as a ﬁxpoint, and its
constructors as initial algebras of that ﬁxpoint.
N : Set
N = µ NatD
zero : N
zero = init (zeroT , tt)
suc : N →N

109
suc n = init (sucT , ((ń u →n) , tt))
Now we are encoding constructor choices as the initial algebra applied to a
dependent pairs whose domain is an enumeration of tags and codomain is the
description of arguments for each constructor tag.
Hence, the ﬁrst component
(e.g., zeroT or sucT) in the tuple that the initial algebra is applied to is always the
tag name.
Finally, note that the same pair constructor (,) is used for both dependent pair
arguments (encoded by σ), and non-dependent inﬁnitary pair arguments (encoded
by δ). This is because our Agda deﬁnition of non-dependent pairs (×) is deﬁned
as a special case of dependent pairs (Σ) that ignores its ﬁrst argument.
λ-Calculus Terms
As a ﬁnal example, we model the untyped λ-calculus terms
introduced in Section 5.1.3 using descriptions of dependent types. We will ﬁrst
encode Term using nested booleans for constructor choices, and then repeat the
example with named constructor enumeration tags.
Compared to the model of natural numbers, no new concepts are required to
encode Terms. However, because Term has 3 constructors, we gain a greater appre-
ciation of the legibility aﬀorded by constructor tags compared to nested constructor
choices encoded using booleans. Let’s refamiliarize ourselves with the high-level
declaration of Term.
data Term : Set where
var : (n : N) →Term
lam : (b : Term) →Term
app : (f : Term) (a : Term) →Term
First, let’s describe the 3 constructors as a right-nested tuple of 3 choices using
(‘+). The 1st choice describes var, the 2nd choice describes lam, and the 3rd choice
describes app.
TermD : Desc

110
TermD = ‘σ N (ń n →‘Ì) ‘+ (‘δ ⊤‘Ì ‘+ ‘δ Bool ‘Ì)
Let’s expand the deﬁnition of (‘+) to see the nested choices.
TermD : Desc
TermD = ‘σ Bool ń b →if b
then ‘σ N (ń n →‘Ì)
else ‘σ Bool ń b →if b
then ‘δ ⊤‘Ì
else ‘δ Bool ‘Ì
The var constructor is encoded in the true branch of the ﬁrst choice, and the
lam and app constructors are encoded in a nested choice within the false branch.
Below we model the type former and constructors of Term.
Term : Set
Term = µ TermD
var : N →Term
var n = init (true , n , tt)
lam : Term →Term
lam b = init (false , true , (ń u →b) , tt)
app : Term →Term →Term
app f a = init (false , false , (ń b →if b then f else a) , tt)
Notice how the 2nd and 3rd constructors (lam and app) are both deﬁned as two
nested choices, using false as the ﬁrst pair component, and then another choice
(true and false respectively) as their second component. Additionally, we expose
an inductive (non-inﬁnitary) model of app (having two non-inﬁnitary Term argu-
ments) using an if to branch on the inﬁnitary Bool domain (as we did for Tree in
Section 5.2.3).
Below we repeat the entire Term model, but using constructor tags instead of

111
nested boolean choices.
data TermT : Set where
varT lamT appT : TermT
TermDs : TermT →Desc
TermDs varT = ‘σ N (ń n →‘Ì)
TermDs lamT = ‘δ ⊤‘Ì
TermDs appT = ‘δ Bool ‘Ì
TermD : Desc
TermD = ‘σ TermT TermDs
Term : Set
Term = µ TermD
var : N →Term
var n = init (varT , n , tt)
lam : Term →Term
lam b = init (lamT , (ń u →b) , tt)
app : Term →Term →Term
app f a = init (appT , (ń b →if b then f else a) , tt)
Note how, in the tagged construction, the ﬁrst component of the pair is always
a single tag, hence lam and app are not deﬁned with nested choices.
5.4
OPEN INDUCTIVE-RECURSIVE TYPES
In this section, we extend the initial algebra semantics of inﬁnitary and dependent
types (Section 5.3) to inductive-recursive types (Section 2.1.9).
An inductive-
recursive type is mutually deﬁned with a decoding function that may be used in
the inductive deﬁnition of the type.

112
5.4.1
Categorical Model
In all of the previous categorical models we have worked with, the pattern functors
were endofunctors between the category of sets. That is, each functor (F : Set →
Set) mapped each set to another set. Consequently, the ﬁxpoint (µ : (Set →
Set) →Set) of such a functor gave us back a set (µ F : Set). Hence, previously
each type could be semantically modeled as a set (Set).
To deﬁne a categorical model of inductive-recursive types, we need to model
a type (X : Set) along with its mutually deﬁned decoding function (d : X →
O), mapping values of the type to values of some output type (O : Set). For
example, Section 2.1.9 presents the type of arithmetic expressions (X ≜Arith)
mutually deﬁned with a decoding function (d ≜eval : Arith →N) that evaluates
an expression to its natural number (O ≜N) result. Thus, the categorical model
of inductive-recursive sets involves the dependent product of a set and its decoding
function. Such a dependent product is called a slice, notated as Set/O (where O
is the output set).
Set/O ≜(X : Set) · (X →O)
Pattern functors for inductive-recursive types are endofunctors (F : Set/O →
Set/O) of the slice category Set/O8, and the ﬁxpoint (µ : (Set/O →Set/O) →
Set/O) of such a pattern functor returns a slice (µF : Set/O). It is convenient to
separate the deﬁnition of F into 2 parts, where we denote the part by a subscript
(i.e., F1 and F2).
F1 : Set/O →Set
F2 : (R : Set/O) →F1 R →O
The ﬁrst part (F1) maps a slice to a set (modeling a type), similar to the
8 Objects of the slice category Set/O are functions f : X →O (where X is some object-
speciﬁc set and O is a set ﬁxed for the category). Its morphisms are functions h : X →Y
between objects f : X →O and g : Y →O such that f = g ◦h.

113
functors of previous subsections. The second part (F2) maps a slice and a member
of the set mapped by F1, to a member of O (modeling a decoding function). By
convention we use the letter R to refer to the slice argument to distinguish it from
the contained set X and decoding function d. We can put these two components
of the functor together as a dependent pair to form the actual endofunctor over
slices.
F : Set/O →Set/O ≜λR. (F1 R, F2 R)
We can separate the deﬁnition of least ﬁxed points to be deﬁned similarly in
terms of a ﬁxed point operator (µ1, returning a set), and its decoding function (µ2,
taking an µ1 F and returning an O).
µ1 : (Set/O →Set/O) →Set
µ2 : (F : Set/O →Set/O) →µ1 F →O
µ : (Set/O →Set/O) →Set/O ≜λF. (µ1 F, µ2 F)
Recall our restriction of pattern functors to a sequence of dependent products
of non-inductive or inﬁnitary arguments, terminating in 1.
F1 ≜λ(X, d). (x0 : A0) · (x1 : A1 x0) · (x2 : A2 x1 x2) · ... · (xn : An x0 ... xn−1) · 1
Before, it only made sense for non-inductive arguments to be dependent. For
example, we could have a functor like the following (where A : Set and B : A →
Set).
F1 ≜λ(X, d). (x1 : A) · (x2 : B a) · 1
With the introduction of inductive-recursive types, it is now actually possible
to use an inductive dependent argument by applying the decoding function (d).
Below, we deﬁne functors like F in 2 parts, where F1 deﬁnes the ﬁrst (set) part
and F2 is deﬁnes the second (decoding function) part. For example, now we can
have a functor like the following (where A : Set and B : O →Set).
F1 ≜λ(X, d). (x1 : X) · (x2 : B (d x1)) · 1

114
Any decoder (F2) of F1 has a tuple of arguments similar to the dependencies in
the sequence of products deﬁned in F1 (the only diﬀerence is that the tuple ends in
the unit argument •, corresponding to the unit set 1 that terminates the product).
For example, below the arguments x1 and x2 in F2 correspond to the dependencies
x1 and x2 in F1 (where f : (x : X) →B (d x) →O).
F2 ≜λ(X, d). λ(x1, x2, •). f x1 x2
Now we ﬁnally introduce a new notation that takes advantage of our structure
of pattern functors as a sequence of dependent products terminating in 1. The new
notation gives us a succinct way to simultaneously deﬁne the F1 and F2 parts of
the pattern functor F by exploiting the shared structure between the dependencies
in F1 and arguments in F2.
Now we deﬁne F by terminating the sequence of
products with ι (replacing 1) applied to an element of O. Because ι appears at
the end of the sequence, it can be deﬁned with access to all of the dependencies of
the product that came before it. For example, below we deﬁne F directly (where
f : (x : X) →B (d x) →O).
F ≜λ(X, d). (x1 : X) · (x2 : B (d x1)) · ι (f x1 x2)
Once again, this is merely notation for directly deﬁning F as a dependent pair
(a member of the slice Set/O). Hence, ι is also just notation rather than being
a primitive set construction. For example, the notation above expands to the F
below (ﬁrst in terms of F1 and F2, and second once the deﬁnitions of F1 and F2
have been expanded).
F ≜λ(X, d). (F1 (X, d), F2 (X, d))
F ≜λ(X, d). ((x1 : X) · (x2 : B (d x1) · 1, λ(x1, x2, •). f x1 x2))
In general, our new notation for inductive-recursive pattern functors is a se-
quence of dependent products of non-inductive or inﬁnitary arguments, terminat-
ing in ι applied to an element of O, with dependencies x0 through xn in scope

115
(where n is the number of products).
F ≜λ(X, d). (x0 : A0) · (x1 : A1 x0) · ... · (xn : An x0 ... xn−1) · ι (f x0 ... xn)
Natural Numbers
Any ordinary inductive type can instead be modeled as a
trivial inductive-recursive type by combining the inductive type with a trivial de-
coding function from its values to unit. The inductive type can thus be deﬁned
normally, without referring to its trivial function. For example, below we deﬁne
the type of natural numbers along with the trivial function (point) from natural
numbers to unit.9
data N : Set where
zero : N
suc : (⊤→N) →N
point : N →⊤
point _ = tt
Borrowing from our previous subscript notation for functors and ﬁxpoints, we
can rename the inductive deﬁnition of N to N1 and its trivial decoding func-
tion point to N2. Then we can isomorphically model the natural numbers as an
inductive-recursive type by combining the type and its decoding function using a
pair.
data N1 : Set where
zero : N1
suc : (⊤→N1) →N1
N2 : N1 →⊤
N2 n = tt
9 The intuition behind the name of the decoding function, point, is that any inhabitant of
the function is forced to eventually return tt, the sole inhabitant of the unit type (⊤). Hence,
all point functions are extensionally equivalent, as they all “point” to tt. Additionally, the single
inhabitant tt of ⊤can be considered a “point”.

116
N : Σ Set (ń A →A →⊤)
N = N1 , N2
First we deﬁne the categorical model for this trivially inductive-recursive type
using the componentized deﬁnition of µ in terms of its set (µ1) and decoding
function (µ2). Below, 1 (similar to ⊤) is the name of the unit set and • (similar
to tt) is the name of its single inhabitant.
N1 ≜µ1(X, d). 1 + X1 · 1
N2 ≜µ2(X, d). λn. •
N ≜µR. (µ1 R, µ2 R)
Alternatively, we can deﬁne N directly as a dependent pair where we inline the
deﬁnition of N1 into the ﬁrst component, and inline the deﬁnition of N2 into the
second component.
N ≜µ(X, d). ((1 + X1 · 1), (λn. •))
Finally, we can deﬁne it most succinctly with our ι notation as follows.
N ≜µ(X, d). ι • +X1 · ι •
Because ι • appears twice, once on either side of (+), the ι-based N technically
models the decoding function N2 below, which matches against zero and suc but
returns tt in either case.
N2 : N1 →⊤
N2 zero = tt
N2 (suc f) = tt
As a ﬁnal example, consider a pattern functor of the natural numbers that takes
advantage of the decoding function (d below) and dependency on an inﬁnitary
argument (f below).
N ≜µ(X, d). ι • +(f : X1) · ι (d (f •))

117
Above the result of applying the decoding function to a successor of a natural
number is speciﬁed to be a recursive call of the decoding function d applied to:
the inﬁnitary predecessor f applied to the unit value •. Hence, the pattern above
is the categorical model of the decoding function below (notice the recursive call
of decoding function N2 in the suc case).
N2 : N1 →⊤
N2 zero = tt
N2 (suc f) = N2 (f tt)
Now we understand the essence of induction-recursion: While the X param-
eter of the ﬁxpoint operator µ allows us to construct inductive arguments, the d
parameter allows us to perform recursive calls of the decoding function.
5.4.2
Formal Model
In this section we extend the formal model of dependent types (Section 5.3.2)
to support inductive-recursive types. The previous description type (Desc), in-
terpretation function (J_K) and least ﬁxed point operator µ are all modiﬁed to
be parameterized over an output type (O : Set), the codomain of the decoding
function.
Descriptions
Descriptions (of Section 5.3.2) must be modiﬁed to be parameter-
ized over an output type O. Recall that descriptions are the syntactic reiﬁcation
of legal pattern functors. In Section 5.4.1 we presented 3 diﬀerent ways to deﬁne
pattern functors for inductive-recursive types.
1. Single pattern functors (F) as a dependent pair.
2. Two-part pattern functors (F1 and F2).
3. Single pattern functors (F) using ι.
Our descriptions formally model the syntax of the 3rd (ι) version of legal pattern
functors. Recall that ι is applied to an O, hence we had an argument o of type

118
O to the ‘Ì constructor. However, we also change ‘δ in a more subtle way (from
Section 5.3.2).
data Desc (O : Set) : Set1 where
‘Ì : (o : O) →Desc O
‘σ : (A : Set) (D : A →Desc O) →Desc O
‘δ : (A : Set) (D : (A →O) →Desc O) →Desc O
Recall that ‘σ denotes a dependent non-inductive argument (of type A) that
subsequent arguments, encoded by D, may depend on in. With induction-recursion,
‘δ denotes an inﬁnitary (hence inductive) argument (whose domain is A) that sub-
sequent arguments (D) may depend on. However, subsequent arguments in D do
not depend directly on an inﬁnitary argument (i.e., A →X). Instead, D depends
on a function (i.e., A →O) that is an implicit composition of the decoding function
and the inﬁnitary function. This implicit composition hides the underlying inﬁni-
tary argument, preventing an inductive argument (X) from appearing negatively
in the domain of the inﬁnitary argument D (instead, O appears). Below is an
example of the natural numbers encoded as a trivially (i.e., where the codomain
of the decoding function O is the unit type ⊤) inductive-recursive description.10
NatD : Desc ⊤
NatD = ‘σ Bool (ń b →if b then ‘Ì tt else ‘δ ⊤(ń f →‘Ì (f tt)))
In the example above ‘Ì tt is returned in the zero branch.
The suc branch
returns the result of applying the composition (f) of the decoding function and the
inﬁnitary function to tt. This describes the deﬁnition of natural numbers below.
data N1 : Set where
zero : N1
suc : (⊤→N1) →N1
N2 : N1 →⊤
10 It also happens to be a trivially inﬁnitary type, because ‘δ is applied to ⊤, encoding a trivial
inﬁnitary domain.

119
N2 zero = tt
N2 (suc n) = N2 (n tt)
N : Σ Set (ń A →A →⊤)
N = N1 , N2
To understand where the implicit composition of the decoding function and
the inﬁnitary function is happening, recognize that in the successor case of the
deﬁnitions of NatD and N2 above, f = N2 ◦n.
Pattern Functors
Now we turn to the task of formally modeling pattern func-
tors (F : Set/O →Set/O) of inductive-recursive types.
Before we can even
consider doing so, we must formally model the concept of a slice Set/O. A slice is
formally modeled as a dependent pair type (Σ) parameterized by an output type
(O). The ﬁrst component of the pair is a type and the second component is its
decoding function.
Set/ : Set →Set1
Set/ O = Σ Set (ń A →(A →O))
We formally model pattern functors (F : Set/O →Set/O) as the functor
(F : Set/ O →Set/ O) resulting from the partial application of a description to
the interpretation function (J_K : {O : Set} →Desc O →Set/ O →Set/ O).
In Section 5.4.1 we showed the categorical model of F in terms of a component
mapping slices to sets (F1) and a component mapping slices to a decoding function
(F2). Our formal model similarly deﬁnes the interpretation function (J_K) in terms
of a type component (J_K1) and a decoding function component (J_K2), which also
result in the pattern functor components (F1 and F2) when partially applied to a
description.
J_K : {O : Set} →Desc O →Set/ O →Set/ O

120
J D K R = J D K1 R , J D K2 R
First, consider the interpretation function component (J_K1) mapping slices to
types. The ‘Ì and ‘σ cases are much like they were for the interpretation function
of dependent types in Section 5.3.2.
J_K1 : {O : Set} →Desc O →Set/ O →Set
J ‘Ì o K1 R = ⊤
J ‘σ A D K1 R = Σ A (ń a →J D a K1 R)
J ‘δ A D K1 R@(X , d) = Σ (A →X) ń f →J D (d ◦f) K1 R
The inﬁnitary ‘δ case now needs to be interpreted as a dependent pair type.
The left component of the pair is the inﬁnitary argument (f : A →X). The right
component is the interpretation of the description D applied to the composition
of the decoding function (d) and the dependent inﬁnitary argument (f). Thus the
subsequent argument types contained in D can depend on the composed function
(returning an O), but cannot directly depend on the inﬁnitary function (returning
an inductive X).
Before providing an example, we redeﬁne the description of natural numbers by
extracting the “if-statement” component into a separate deﬁnition. This separate
deﬁnition (NatDs) returns the description of a particular constructor when applied
to the appropriate boolean branch.
NatDs : Bool →Desc ⊤
NatDs b = if b then ‘Ì tt else ‘δ ⊤(ń f →‘Ì (f tt))
NatD : Desc ⊤
NatD = ‘σ Bool NatDs
To keep the example simple, we look at the result of applying the type compo-
nent of the interpretation function to the description of the successor constructor

121
(rather than the entire natural numbers description).
J NatDs false K1 ≡ń { (X , d) →Σ (⊤→X) (ń f →⊤) }
The left component of the pair type is the inﬁnitary argument of suc. The
right component is just the unit type that terminates every sequence of dependent
arguments, ignoring f (the composition of the decoding function and inﬁnitary
argument).
Second, consider the interpretation function component (J_K2) mapping slices
to decoding functions. The decoding function works by consuming the arguments
(of type J D K1 R) while recursing down to the ‘Ì base case and returning the o it
contains.
J_K2 : {O : Set} (D : Desc O) (R : Set/ O) →J D K1 R →O
J ‘Ì o K2 R tt = o
J ‘σ A D K2 R (a , xs) = J D a K2 R xs
J ‘δ A D K2 R@(X , d) (f , xs) = J D (d ◦f) K2 R xs
The arguments are consumed by applying dependent descriptions (D) to the
head argument (a non-inductive a or inﬁnitary f), and recursively consuming the
tail (xs). The ‘σ case recursively searches the subsequent arguments xs, which
are described by the dependent description (D) applied to the non-inductive ﬁrst
component (a). The ‘δ case also searches the subsequent arguments (xs), but they
are described by the dependent description (D) applied to the composition of the
decoding function (d) and the inﬁnitary argument f.
Fixpoints
The ﬁxpoint operator (µ : (Set/O →Set/O) →Set/O) of inductive-
recursive types is reiﬁed as a derived function (µ : {O : Set} →Desc O →Set/ O),
parameterized by the output type O and producing slices from descriptions. The
pattern functor argument (Set/O →Set/O) of µ can be derived by the formal
model of µ by partially applying the interpretation function to the description
argument (J D K : Set/ O →Set/ O).

122
In Section 5.4.1 we showed the categorical model of the ﬁxpoint operator µ,
deﬁning it in terms of a set component (µ1) and a decoding function component
(µ2).
Our formal model similarly derives the ﬁxpoint (µ) as a dependent pair
consisting of a type component (µ1) and a decoding function component (µ2). We
deﬁne these 3 constructions (a type synonym µ, a datatype µ1, and a function µ2)
mutually below.11
mutual
µ : {O : Set} →Desc O →Set/ O
µ D = µ1 D , µ2 D
data µ1 {O : Set} (D : Desc O) : Set where
init : J D K1 (µ D) →µ1 D
µ2 : {O : Set} (D : Desc O) →µ1 D →O
µ2 D (init xs) = J D K2 (µ D) xs
The argument to the initial algebra needs to be a type representing construc-
tors (of µ1, and their arguments). This type is computed by applying the ﬁrst
component (J_K1) of the interpretation function to the description (D) and its ﬁx-
point (µ D). The output of the decoding function (µ2) is computed by applying
the description (D), its ﬁxpoint (µ D), and the argument of the initial algebra (xs)
to the second component (J_K2) of the interpretation function.
5.4.3
Examples
Now we formally model the type formers and constructors of inductive-recursive
datatypes. Typically inductive-recursive datatypes are deﬁned mutually in terms
of a type and its decoding function. In our formal model, a single description
captures deﬁnition of both the type and its decoding function.
11 The type µ1 and the function µ2 in this section can only be deﬁned by disabling Agda’s
positivity and termination checkers. In Section 5.4.4, we present an alternative model that need
not disable any Agda checkers.

123
Natural Numbers
Let’s refamiliarize ourselves with the deﬁnition of natural
numbers as a trivially inductive-recursive datatype.
We use the variant of the
inductive-recursive natural numbers where the suc case of decoding function (point)
is deﬁned recursively (rather than constantly returning tt).
data N : Set where
zero : N
suc : N →N
point : N →⊤
point zero = tt
point (suc n) = point n
We expose the formal model of the non-inﬁnitary natural numbers presented
above. As in Section 5.3.3, this means our type former and constructors will have
the names and types corresponding to the ones above. However, our underlying
pattern functor formally models the inﬁnitary and slice-based deﬁnition of natural
numbers below.
The non-inﬁnitary type N above corresponds to inﬁnitary type N1 below. The
decoding function point above corresponds to N2 below. Finally, the slice N below
does not correspond to anything above. While slices are commonly used to describe
the semantics of inductive-recursive types, they are rarely used in conventional
programming with inductive-recursive types.
data N1 : Set where
zero : N1
suc : (⊤→N1) →N1
N2 : N1 →⊤
N2 zero = tt
N2 (suc n) = N2 (n tt)
N : Set/ ⊤

124
N = N1 , N2
Now we specify the pattern functor of the datatype as an inductive-recursive
description. We use a datatype of tags (NatT), representing each constructor (as
in Section 5.3.2). We also explicitly deﬁne the function (NatDs) taking tags to the
description of arguments for the constructor that each tag represents.
data NatT : Set where
zeroT sucT : NatT
NatDs : NatT →Desc ⊤
NatDs zeroT = ‘Ì tt
NatDs sucT = ‘δ ⊤(ń f →‘Ì (f tt))
NatD : Desc ⊤
NatD = ‘σ NatT NatDs
We model the type (N) and decoding function (point) by applying the type
component (µ1) and decoding function component (µ2) of the ﬁxpoint operator to
the description (NatD). Once again, we are modeling the non-inﬁnitary and slice-
less type of natural numbers in terms of its underlying inﬁnitary and slice-based
pattern functor.
N : Set
N = µ1 NatD
point : N →⊤
point = µ2 NatD
Finally, we model the constructors. As done previously, the suc constructor
creates an inﬁnitary argument as a function ignoring the inﬁnitary domain value
(u), and constantly returning the non-inﬁnitary predecessor (n).
zero : N
zero = init (zeroT , tt)

125
suc : N →N
suc n = init (sucT , (ń u →n) , tt)
Arithmetic Expressions
Now we model a non-trivially inductive-recursive and
non-trivially inﬁnitary type, namely the type of arithmetic expressions (Arith).
You may wish to revisit Section 2.1.9 for examples of what arithmetic expressions
represent. An Arith can be evaluated to the natural number that the arithmetic
expression represents, using the eval decoding function.
mutual
data Arith : Set where
Num : N →Arith
Prod : (a : Arith) (f : Fin (eval a) →Arith) →Arith
eval : Arith →N
eval (Num n) = n
eval (Prod a f) = prod (eval a) (ń i →eval (f i))
Our pattern functor models the slice-based and inﬁnitary version of the arith-
metic expressions below.
mutual
data Arith1 : Set where
Num : N →Arith1
Prod : (a : ⊤→Arith1) (f : Fin (Arith2 (a tt)) →Arith1) →Arith1
Arith2 : Arith1 →N
Arith2 (Num n) = n
Arith2 (Prod a f) = prod (Arith2 (a tt)) (ń i →Arith2 (f i))
Arith : Set/ N
Arith = Arith1 , Arith2
The description of the slice-based pattern functor is deﬁned in terms of a func-
tion (ArithDs) taking arithmetic expression constructor tags (ArithT) to descrip-
tions of the arguments for the constructor that each tag represents.

126
Compare the index that Fin is applied to in the type Arith1 above and de-
scription ArithDs below. Notice that the dependent inﬁnitary a in the description
below represents the composition of the decoding function Arith2 and the inﬁnitary
a above.
data ArithT : Set where
NumT ProdT : ArithT
ArithDs : ArithT →Desc N
ArithDs NumT = ‘σ N ń n →‘Ì n
ArithDs ProdT =
‘δ ⊤ń a →
‘δ (Fin (a tt)) ń f →
‘Ì (prod (a tt) f)
ArithD : Desc N
ArithD = ‘σ ArithT ArithDs
Also notice how each description, in the NumT and ProdT cases of ArithDs, ends
in ‘Ì. The description prior to ‘Ì represents the type Arith1 above, and the natural
number contained in ‘Ì represents the output of the decoding function Arith2 above.
Finally, the arguments of the decoding function cases are represented by the non-
inductive (‘σ) and inﬁnitary (‘δ) dependencies of the description prior to ‘Ì.
We model the type (Arith) and decoding function (eval) by applying the type
component (µ1) and decoding function component (µ2) of the ﬁxpoint operator to
the description (ArithD).
Arith : Set
Arith = µ1 ArithD
eval : Arith →N

127
eval = µ2 ArithD
The same techniques used to model the non-inﬁnitary and slice-less construc-
tors of the N type are used to model the constructors of the Arith type.
Num : N →Arith
Num n = init (NumT , n , tt)
Prod : (a : Arith) (f : Fin (eval a) →Arith) →Arith
Prod a f = init (ProdT , (ń u →a) , f , tt)
Vectors
Now we show how to derive an indexed type, like vectors, from a non-
trivially inductive-recursive type. But ﬁrst, let’s refamiliarize ourselves with the
high-level indexed vector deﬁnition we wish to derive.
data Vec (A : Set) : N →Set where
nil : Vec A zero
cons : (n : N) (a : A) (xs : Vec A n) →Vec A (suc n)
Before describing the transformation [31] to turn this indexed type into an
isomorphic type using induction-recursion, we describe the intuition behind the
transformation. A well-known derived (isomorphic) representation of vectors is
the dependent pair (Σ) of a List and a constraint on its length, using the equality
type (≡).
data List (A : Set) : Set where
nil : List A
cons : (a : A) (xs : List A) →List A
length : {A : Set} →List A →N
length nil = zero
length (cons a xs) = suc (length xs)
Vec : Set →N →Set

128
Vec A n = Σ (List A) (ń xs →length xs ≡n)
While this is a nice and simple translation, it doesn’t capture the notion of a
vector as intensionally as we would like. Speciﬁcally, the cons constructor of List
does not a contain the non-inductive natural number argument (n). Additionally,
while the outermost derived Vec contains the index constraint (≡), the inductive
List argument (xs) of cons does not.
Instead of deriving Vec from List and length like above, we can use induction-
recursion to mutually deﬁne these 3 components. Induction-recursion allows us
to derive an inductive datatype (Vec1, analogous to List) with the same collection
of non-inductive constructor arguments as our high-level indexed Vec, and adds
index constraints to go along with every inductive-argument.
mutual
data Vec1 (A : Set) : Set where
nil : Vec1 A
cons : (n : N) (a : A) (xsq : Vec A n) →Vec1 A
Vec2 : {A : Set} →Vec1 A →N
Vec2 nil = zero
Vec2 (cons n x xsq) = suc n
Vec : Set →N →Set
Vec A n = Σ (Vec1 A) (ń xs →Vec2 xs ≡n)
We transform (as above) a high-level indexed type (like Vec) into a derived
version (like Vec), using induction-recursion, by changing 3 things:
1. The original indexed type (Vec) becomes an inductive-recursive type (Vec1),
with a decoding function (Vec2). The inductive-recursive type (Vec1) still
contains all non-inductive arguments (like n of cons).
2. Original inductive arguments (xs) of the indexed type are replaced by a
value (xsq) of a derived dependent pair type (Vec).
The ﬁrst component

129
of the dependent pair is the inductive-recursive type Vec1, and the second
component constrains the index of the original inductive argument (n) to
equal what the decoding function (Vec2) returns.
3. The decoding function (Vec2) is deﬁned by matching on the constructors of
the inductive-recursive type (Vec1), and returning what the original high-
level indexed type (Vec) had in the index position of the codomain for the
corresponding constructor.
Finally, we make one last change, allowing us to formally model the indexed
type of vectors using our initial algebra semantics of inductive-recursive types. The
inductive-recursive type Vec1 curries inductive occurrences of the derived depen-
dent pair (Vec) as 2 separate arguments. Below, xsq is replaced by xs (the inductive
argument of Vec1) and q (the constraint). By consequence, the dependent pair Vec
no longer needs to be deﬁned mutually.
mutual
data Vec1 (A : Set) : Set where
nil : Vec1 A
cons : (n : N) (a : A) (xs : Vec1 A) (q : Vec2 xs ≡n) →Vec1 A
Vec2 : {A : Set} →Vec1 A →N
Vec2 nil = zero
Vec2 (cons n x xs q) = suc n
Vec : Set →N →Set
Vec A n = Σ (Vec1 A) (ń xs →Vec2 xs ≡n)
Now we formally model the slice-based pattern functor of the inductive-recursive
Vec1 type.
data VecT : Set where
nilT consT : VecT
VecDs : Set →VecT →Desc N

130
VecDs A nilT = ‘Ì zero
VecDs A consT =
‘σ N ń n →
‘σ A ń a →
‘δ ⊤ń xs →
‘σ (xs tt ≡n) ń q →
‘Ì (suc n)
VecD : Set →Desc N
VecD A = ‘σ VecT (VecDs A)
We model the inductive-recursive type (Vec1) and decoding function (Vec2) by
applying the type component (µ1) and decoding function component (µ2) of the
ﬁxpoint operator to the description (VecD).
Vec1 : Set →Set
Vec1 A = µ1 (VecD A)
Vec2 : (A : Set) →Vec1 A →N
Vec2 A = µ2 (VecD A)
Finally, we model the indexed type (Vec) as a dependent pair, derived in terms
of the inductive-recursive type (Vec1) and an index constraint using the decoding
function (Vec2).
Vec : Set →N →Set
Vec A n = Σ (Vec1 A) (ń xs →Vec2 A xs ≡n)
The main thing to notice about the way we model the constructors is that our
model of indexed vectors (Vec) is in terms of a dependent pair.
nil : {A : Set} →Vec A zero
nil = init (nilT , tt) , reﬂ
cons : {A : Set} →(n : N) (a : A) (xs : Vec A n) →Vec A (suc n)
cons n a (xs , q) = init (consT , n , a , (ń u →xs) , q , tt) , reﬂ
Both nil and cons return an inductive-recursive Vec1 in the ﬁrst component of

131
the pair, and an index constraint proof (in terms of Vec2) in the second component
of the pair. Additionally, cons destructs its “inductive” Vec arguments in terms of
the underlying pair components xs and q.
5.4.4
Agda Model
In previous sections on non-dependent types (Section 5.1.2), inﬁnitary types (Sec-
tion 5.2.2), and dependent types (Section 5.3.2), the formal model (i.e., a model in
type theory) corresponded to the Agda model (i.e., a model in an implementation
of type theory). Unfortunately, this is not the case for the formal model presented
for inductive-recursive types in Section 5.4.2.
Although we used Agda syntax in the formal model of Section 5.4.2, we had to
turn oﬀthe positivity and termination checkers when inductive-recursively deﬁning
the ﬁxpoint datatype (µ1) and its decoding function (µ2).
Even though Agda
(the implementation of type theory that we are using) cannot conﬁrm that this
deﬁnition preserves consistency, Dybjer and Setzer have proven the consistency of
the construction in a model of set theory (extended by the Mahlo cardinal) [23].
To pass Agda’s positivity and termination checkers, we deﬁne the following
Agda model as an alternative to the formal model in Section 5.4.2. Our Agda
model mutually deﬁnes the pattern functor interpretation functions (J_K1 for the
interpretation of types, and J_K2 for the interpretation of decoding functions),
along with the inductive-recursive ﬁxpoint type µ1 and ﬁxpoint decoding function
(µ2).
mutual
J_K1 : {O : Set} (D R : Desc O) →Set
J ‘Ì o K1 R = ⊤
J ‘σ A D K1 R = Σ A (ń a →J D a K1 R)
J ‘δ A D K1 R = Σ (A →µ1 R) ń f →J D (ń a →µ2 R (f a)) K1 R
J_K2 : {O : Set} (D R : Desc O) →J D K1 R →O

132
J ‘Ì o K2 R tt = o
J ‘σ A D K2 R (a , xs) = J D a K2 R xs
J ‘δ A D K2 R (f , xs) = J D (ń a →µ2 R (f a)) K2 R xs
data µ1 {O : Set} (D : Desc O) : Set where
init : J D K1 D →µ1 D
µ2 : {O : Set} (D : Desc O) →µ1 D →O
µ2 D (init xs) = J D K2 D xs
Notice that the types of the pattern functor interpretation functions (J_K1 and
J_K2) have changed. In the type of the interpretation functions, the R argument is
now a description (Desc O), instead of a slice (Set/ O). Because R is now a descrip-
tion (rather than a slice), partially applying a description D to the interpretation
function (J_K, deﬁned as the dependent pair of J_K1 and J_K2 in Section 5.4.2)
no longer results in a pattern endofunctor on slices. While we lose some of the
beautiful correspondence with our categorical model, we have eﬀectively inlined
a specialized version of the interpretation functions that allows Agda to conﬁrm
that the type ﬁxpoint component (µ1) is positive and that the decoding function
ﬁxpoint component (µ2) terminates.
All of our earlier examples of inductive-recursive type encodings (Section 5.4.3)
still work. This is because our examples of type formers and constructors only rely
on the interfaces exposed by µ1 and µ2, so changing their implementations to
mutually be deﬁned in terms of J_K1 and J_K2 does not break anything.
Finally, this construction of open algebraic types can also be found in Ap-
pendix B. In the Appendix, we remove backticks from the Desc constructor names,
so that we may distinguish open descriptions from closed descriptions in Chapter 6.
We also change the O parameter of µ1 to be an explicit argument. The primitive
types assumed in the construction of Appendix B are deﬁned in Appendix A.

133
Part III
Closed Type Theory

134
Chapter 6
CLOSED ALGEBRAIC UNIVERSE
In this chapter1 we formally model a closed type theory, or dependently typed
language, supporting declared datatypes and fully generic programming.
The
high-level idea is to deﬁne a closed type theory, similar to the Closed Well-Order
Types universe of Section 4.2.1, but replacing W types (Section 4.2.2) with ﬁx-
points (µ1) of descriptions (formally modeling initial algebra semantics, as in Sec-
tion 5.4.2).
Initial algebra semantics, unlike well-orderings, adequately models
declared datatypes in intensional (as opposed to extensional) type theory.
We begin with a naive, failing attempt at deﬁning a closed type theory using
ﬁxpoints (Section 6.1). After explaining why the simple but naive attempt actually
deﬁnes an open (rather than closed) type theory, we explain how to properly close
the theory (Section 6.2). Then, we deﬁne a procedure to close any type theory
(Section 6.3), rather than just the universe we chose for generic programming in
this dissertation. Finally, we conclude by comparing and contrasting types and
kinds (Section 6.4).
Major Ideas
The purpose of this chapter is to deﬁne a closed universe that
models a dependently typed language supporting user-declared types, so that we
may perform fully generic programming over it in Chapter 7. The key to deﬁning
the universe is to deﬁne a closed universe of built-in types, which includes the type
of ﬁxpoints (µ1) from Section 5.4 as a built-in type. Essentially, we are replacing
the W type in the closed universe of Section 4.2 with the ﬁxpoint type µ1.
1 This chapter is adapted from work by myself and Sheard [18], as explained in Section 9.4.

135
Crucially, this requires us to mutually deﬁne the universe of closed built-in
types (‘Set in Section 6.2) with a closed equivalent (‘Desc in Section 6.2) of the
open descriptions (Desc) from Section 5.4. This way, the code of closed ﬁxpoints
(‘µ1) can take a closed description (‘Desc) as its argument, and the closed functor
description codes for non-inductive arguments (‘σ‘) and inﬁnitary arguments (‘δ)
can take a closed type (‘Set) as an argument (for the non-inductive argument type
and the non-inductive inﬁnitary domain, respectively).
The closed codes of built-in types (‘Set) and the closed codes of functor descrip-
tions (‘Desc) both have meaning functions that map the closed codes to their open
equivalents. Speciﬁcally, the type meaning function (J_K) maps a closed type ‘Set
to an open type Set, and the description meaning function («_») maps a closed
description ‘Desc to an open description Desc.
6.1
OPEN INDUCTIVE-RECURSIVE TYPES
In this section, we present a naive, failing attempt at creating a closed universe
using ﬁxpoints. It is a failing attempt because it actually deﬁnes an open universe.
We will deﬁne a universe similar to the Closed Well-Order Types of Section 4.2.2,
but replacing W with µ1 (of Appendix B), and adding the identity (or equality)
type Id. First, let’s remind ourselves of the deﬁnitions of the identity type, and
the type of ﬁxpoints for inductive-recursive deﬁnitions.
data Id (A : Set) (x : A) : A →Set where
reﬂ: Id A x x
data µ1 (O : Set) (D : Desc O) : Set where
init : J D K1 D →µ1 O D
The identity type allows us to state propositionally that two values (x and y)
are equal. If they are indeed equal, the constructor reﬂserves as a proof of the
proposition. In previous parts of this dissertation, we used an inﬁx version of the

136
identity type (≡), in which the type of the compared values is implicit. Here, we
use Id so we can explicitly refer to the type (A) of the compared values. Similarly,
above we deﬁne a version of the ﬁxpoint operator (µ1) that explicitly takes the
codomain (O) of the inductive-recursive decoding function. The ﬁxpoint operator
(µ1) also takes an explicit description argument (D), as before, where the kind of
inductive-recursive descriptions (Desc) is deﬁned in Section 5.4.2.
6.1.1
Formal Model
In the vector example of Section 5.4.3 we saw that indexed types can be derived
from inductive-recursive types and equality constraints (i.e., use of identity type).
In our universe below, we want to encode indexed types in addition to inductive-
recursive types, thus we replace ‘W with ‘µ1, and add ‘Id.
mutual
data ‘Set : Set1 where
‘⊥‘⊤‘Bool : ‘Set
‘Σ ‘Π : (A : ‘Set) (B : J A K →‘Set) →‘Set
‘Id : (A : ‘Set) (x y : J A K) →‘Set
‘µ1 : (O : ‘Set) (D : Desc J O K) →‘Set
J_K : ‘Set →Set
J ‘⊥K = ⊥
J ‘⊤K = ⊤
J ‘Bool K = Bool
J ‘Σ A B K = Σ J A K (ń a →J B a K)
J ‘Π A B K = (a : J A K) →J B a K
J ‘Id A x y K = Id J A K x y
J ‘µ1 O D K = µ1 J O K D
Nothing immediately problematic stands out as our universe looks quite like
the Closed Well-Order Types universe. Let’s take a closer look at why the addition
of the identity type (‘Id) is not problematic, but the addition of ﬁxpoints (‘µ1)
is, by constructing values of both. First, we construct the (uninhabited) boolean

137
proposition that true is equal to false, using the identity type.
‘Bottom : ‘Set
‘Bottom = ‘Id ‘Bool true false
Above, the proposition (‘Bottom) can be encoded in the universe (i.e., deﬁned
as a value of ‘Set) by using the encoded identity type (‘Id, rather than Id). Addi-
tionally, the type of the compared values in the proposition can also be encoded
in the universe (as ‘Bool, rather than Bool).
Hence, the identity type (Id) can be encoded in the universe using its backtick
equivalent (‘Id). Additionally, its type argument can be ‘Bool, the backtick universe
encoding of type Bool. Next (in Section 6.1.2), we will see that, while the ﬁxpoint
type (µ1) can be encoded in the universe using its backtick equivalent (‘µ1), its
description argument cannot be a backtick encoding of a Desc constructor, which
is the source of openness of our universe.
6.1.2
Source of Openness
To discover why ‘Set actually deﬁnes an open universe, let’s try to deﬁne the type
of natural numbers in the universe (i.e., as a member of ‘Set).
NatDs : Bool →Desc ⊤
NatDs true = Ì tt
NatDs false = δ ⊤(ń u →Ì tt)
NatD : Desc ⊤
NatD = σ Bool NatDs
‘N : ‘Set
‘N = ‘µ1 ‘⊤NatD
Above, the type of natural numbers (‘N) and the codomain of the decoding
function can be deﬁned within the universe (using ‘µ1 and ‘⊤respectively, rather
than µ1 and ⊤). However, the description (NatD) of the natural numbers is deﬁned

138
outside of the universe. This is because σ and δ are respectively applied to the
types Bool and ⊤, which are not members of the universe ‘Set. Instead, they are
types (Set) of our open metatheory (Agda). The second argument (D) of encoded
ﬁxpoints (‘µ1) has type Desc, which seems harmless. However, let’s inspect the
deﬁnition of descriptions.
data Desc (O : Set) : Set1 where
Ì : (o : O) →Desc O
σ : (A : Set) (D : A →Desc O) →Desc O
δ : (A : Set) (D : (A →O) →Desc O) →Desc O
The root of the problem is that the A argument of σ and δ has Agda’s type Set,
rather than a code of our universe ‘Set. Hence, the universe ‘Set that we deﬁned is
actually open because ‘µ1 has an argument D of type Desc, which is an open type
because it has Set arguments. There are 2 major consequences resulting from ‘µ1
having an open type argument (D):
1. Encodings of declared algebraic datatypes can include non-inductive argu-
ments (and decoding codomains) whose types are not in the universe ‘Set.
For example, a constructor could have a vector (Vec) argument, which is in
Agda’s open universe Set, rather than our universe ‘Set (that we intended to
be closed).
2. We cannot write fully generic functions over the universe, which requires
deﬁning generic functions that work over any ‘µ1 applied to any Desc. We
would get suck on the σ and δ cases of such functions because we could not
case-analyze (or recurse into) the A arguments of type Set.
Both of these consequences are a result of Desc being a valid model of algebraic
datatype declarations in an open universe (where we can use any type, or Set, of
the Agda metalanguage to construct a Desc), but not in a closed universe (where
we need to restrict Desc to only be constructed from closed types, or ‘Sets). We

139
overcome these problems, by truly deﬁning ‘Set as a closed universe (in terms of a
closed equivalent of descriptions, named ‘Desc), in the next section.
6.2
CLOSED INDUCTIVE-RECURSIVE TYPES
The key to creating an adequate2 closed universe of algebraic datatypes in in-
tensional type theory, is paying attention not only to types (Set), but also kinds
(Set1). Previously, we created the Closed Vector Types universe (Section 4.1) and
the Closed Well-Order Types universe (Section 4.2). In those universes, the kind
(Set1) of types (Set) is the only kind around. Now we create the Closed Inductive-
Recursive Types universe, where we additionally account for the kind (Set1) of
descriptions (Desc of Appendix B).3 The lesson to learn is that closing a universe
is not only about closing over some collection of types, but more generally some
collection of kinds.
6.2.1
Formal Model
We wish to formally model a closed type theory, supporting user-declared datatypes,
within an open type theory (Agda). To do so, we deﬁne a type of closed types (‘Set),
and a meaning function mapping each closed type (‘Set) to an open type (Set) of
our model.
We saw in Section 6.1 that descriptions (Desc) are actually open. Therefore,
to model closed type theory we must also close over descriptions! To do so, we
deﬁne a type of closed descriptions (‘Desc), and a meaning function mapping each
2 By adequate we mean that values of algebraic types have intensionally unique canonical
forms. This property is violated when values of algebraic types are encoded using well-orderings,
as explained in Section 4.2.3. In contrast, encoding values of algebraic types using descriptions
and ﬁxpoints (like the examples in Section 5.4.3) is adequate.
3 The “type” of types is actually a kind because Set : Set1. Similarly, the “type” of descriptions
is actually a kind because Desc : (O : Set) →Set1. Distinctively, the type former of descriptions
is a function. Even though the function domain (O) is a type (Set), descriptions are still kinds
because the codomain of the functional type former is a kind (Set1). In other words, the codomain
of a type former determines whether it is a type or a kind, not its domain.

140
closed description (‘Desc) to an open description (Desc) of our model.
Below,
we mutually deﬁne closed types (‘Set) and closed descriptions (‘Desc), and their
meaning functions (J_K and «_» respectively).
mutual
data ‘Set : Set where
‘⊥‘⊤‘Bool : ‘Set
‘Σ ‘Π : (A : ‘Set) (B : J A K →‘Set) →‘Set
‘Id : (A : ‘Set) (x y : J A K) →‘Set
‘µ1 : (O : ‘Set) (D : ‘Desc O) →‘Set
J_K : ‘Set →Set
J ‘⊥K = ⊥
J ‘⊤K = ⊤
J ‘Bool K = Bool
J ‘Σ A B K = Σ J A K (ń a →J B a K)
J ‘Π A B K = (a : J A K) →J B a K
J ‘Id A x y K = Id J A K x y
J ‘µ1 O D K = µ1 J O K « D »
data ‘Desc (O : ‘Set) : Set where
‘Ì : (o : J O K) →‘Desc O
‘σ : (A : ‘Set) (D : J A K →‘Desc O) →‘Desc O
‘δ : (A : ‘Set) (D : (o : J A K →J O K) →‘Desc O)
→‘Desc O
«_» : {O : ‘Set} →‘Desc O →Desc J O K
« ‘Ì o » = Ì o
« ‘σ A D » = σ J A K (ń a →« D a »)
« ‘δ A D » = δ J A K (ń o →« D o »)
Closed ﬁxpoints (‘µ1) of closed types (‘Set) now take a closed description (‘Desc)
as their D argument, compared to Section 6.1, where D was an open description
(Desc). Correspondingly, closed non-inductive arguments (‘σ) and closed inﬁnitary
arguments (‘δ) of closed descriptions (‘Desc) now take a closed type (‘Set) as their
A argument. In contrast, the A argument of σ and δ in the deﬁnition of open

141
descriptions (Desc) is an open type (Set).
Before, the meaning function (J_K) for closed types only recursed on closed
types (‘Set), but now it must mutually recurse using the meaning function («_»)
for closed descriptions (‘Desc).
For example, consider the case of deﬁning the
meaning of closed ﬁxpoints (‘µ1), where J_K is recursively applied to the closed
type O, and «_» is recursively applied to the closed description (D).
Conversely, the ‘σ case of the meaning function («_») for closed descriptions
(‘Desc) must mutually recurse using the meaning function (J_K) for closed types
(‘Set). For example, consider the case of deﬁning the meaning of non-inductive
arguments (‘σ), where «_» is recursively applied to the closed description (D a),
and J_K is recursively applied to the closed type A.
Notice that closed descriptions (‘Desc) are parameterized by closed types (O of
type ‘Set). Take a look at the type of the meaning function («_») for descriptions,
mapping a closed description (‘Desc O) to an open description (Desc J O K). Be-
cause open descriptions expect an open type (Set) parameter, we must apply the
meaning function of types (J_K) to the closed type O, to ensure that our parameter
for open descriptions is well-typed (i.e., is a Set rather than a ‘Set).
Finally, recall that our naive attempt (in Section 6.1) at closing the universe
failed because the resulting universe is actually open. In Section 6.1, ‘Set contains
a D argument (in ‘µ1) whose kind (Set1) is Desc. Therefore, ‘Set of Section 6.1 must
be a kind, to account for the size of its D argument. In contrast, the closed universe
of types (‘Set) of this section, and the closed universe of descriptions (‘Desc), are
merely types (Set). Moreover, a measure of success for closing a universe is the
ability to ﬁt it in the size of types (Set) rather kinds (Set1). The closed universe
of algebraic types presented in this section can also be found in Appendix C.

142
6.2.2
Examples
In Section 5.4.3 we demonstrated various examples of encoding types and construc-
tors using the universe of open inductive-recursive types (Section 5.4.2). Now, we
repeat these examples in our closed universe (Section 6.2).
Datatypes encoded with open descriptions (Appendix B) can use any open type
(Set) for the O parameter of descriptions (Desc), and the A argument of σ and δ.
In contrast, closed descriptions (‘Desc) may only use closed types (‘Set) for the O
parameter and A argument.
Natural Numbers
We will encode a closed version of the following trivially
inﬁnitary and trivially inductive-recursive deﬁnition of the natural numbers.
data N : Set where
zero : N
suc : (⊤→N) →N
point : N →⊤
point zero = tt
point (suc f) = point (f tt)
Below, we encode the closed description of the natural numbers. Compared
to the description in Section 5.4.3, the one below uses the closed type ‘⊤in the
codomain of NatDs and argument to ‘δ, and uses the closed type ‘Bool in the
argument to ‘σ.
NatDs : Bool →‘Desc ‘⊤
NatDs true = ‘Ì tt
NatDs false = ‘δ ‘⊤(ń f →‘Ì (f tt))
NatD : ‘Desc ‘⊤
NatD = ‘σ ‘Bool NatDs
Below, we deﬁne the type former for natural numbers in two parts. First, we
deﬁne the code for the closed type of natural numbers, naming it ‘N and having

143
type ‘Set. Second, we deﬁne the interpretation of the closed code for the natural
number type into our open formal model, naming it N and having kind Set. By
convention, we preﬁx closed type formers with a backtick to distinguish them from
their interpretation in our open formal model.
‘N : ‘Set
‘N = ‘µ1 ‘⊤NatD
N : Set
N = J ‘N K
Deﬁning the decoding function point for closed natural numbers amounts to
applying the decoding function component µ2 (from our open model of algebraic
types in Section 5.4.2) to an open description. Hence, we apply the interpreta-
tion function («_») to our closed description (‘Desc) of natural numbers (NatD),
translating it to the open description (Desc) expected by µ2.
point : N →⊤
point = µ2 « NatD »
Deﬁning the constructors for the natural numbers is no diﬀerent from the open
version in Section 5.4.3. While we encode the closed type of natural numbers as
‘N, we also interpret it as the open type N in our formal model. While we encode
types in a closed way, we can use values of the underlying open formal model.
That is why constructors (e.g., zero and suc, below) appear no diﬀerently than in
Section 5.4.3.
zero : N
zero = init (true , tt)
suc : N →N
suc n = init (false , (ń u →n) , tt)
It is worth pointing out that creating named constructor tags, like the NatT
below, is no longer possible in our closed universe. Instead, a choice of constructors

144
is encoded by applying ‘σ to ‘Bool, in a derived-sum way. Creating named tags like
NatT requires extending an open theory with the new enumeration type, which is
not possible in a closed theory.
data NatT : Set where
zeroT sucT : NatT
Vectors
Next, we will encode a closed version of the trivially inﬁnitary and
non-trivially inductive-recursive vectors using the translation from indexed types
to inductive-recursive types described in Section 5.4.3. We will encode a closed
version of the vector type below.
mutual
data Vec1 (A : Set) : Set where
nil : Vec1 A
cons : (n : N) (a : A) (xs : Vec1 A) (q : Id N (Vec2 xs) n) →Vec1 A
Vec2 : {A : Set} →Vec1 A →N
Vec2 nil = zero
Vec2 (cons n x xs q) = suc n
Vec : Set →N →Set
Vec A n = Σ (Vec1 A) (ń xs →Id N (Vec2 xs) n)
We get the closed description of vectors from the open description in Sec-
tion 5.4.3 by replacing every instance of an open type with a closed type. For
example, the decoding function codomain is the natural numbers, as speciﬁed by
applying the type of closed descriptions (‘Desc) to the type of closed natural num-
bers (i.e., ‘N, which we just deﬁned above). Every ﬁrst argument to ‘σ and ‘δ is a
closed type (i.e., one with a backtick). The A parameter of VecDs and Vec is also
a closed type (‘Set).
VecDs : ‘Set →Bool →‘Desc ‘N
VecDs A true = ‘Ì zero

145
VecDs A false =
‘σ ‘N ń n →
‘σ A ń a →
‘δ ‘⊤ń xs →
‘σ (‘Id ‘N (xs tt) n) ń q →
‘Ì (suc n)
VecD : ‘Set →‘Desc ‘N
VecD A = ‘σ ‘Bool (VecDs A)
Next, we deﬁne the codes for the closed inductive-recursive vector type (‘Vec1),
its decoding function (‘Vec2), and the indexed vector type (‘Vec).
Again, this
mostly involves adding backticks to type arguments.
‘Vec1 : ‘Set →‘Set
‘Vec1 A = ‘µ1 ‘N (VecD A)
‘Vec2 : (A : ‘Set) →J ‘Vec1 A K →N
‘Vec2 A = µ2 « VecD A »
‘Vec : ‘Set →N →‘Set
‘Vec A n = ‘Σ (‘Vec1 A) (ń xs →‘Id ‘N (‘Vec2 A xs) n)
Above, the “length” decoding function (‘Vec2), and the closed indexed vec-
tor type former (‘Vec), take interpreted closed codes as their second arguments.
The former does this by applying the type interpretation function (J_K) to closed
inductive-recursive vectors codes (‘Vec1), while the latter takes closed natural num-
bers (N), which were also previously deﬁned by applying the type interpretation
function (J_K) to closed natural number codes (N1).
Additionally, the body of the deﬁnition of the closed decoding function (‘Vec2)
must apply the open decoding function ﬁxpoint component (µ2) to an open descrip-
tion, which it obtains by applying the description interpretation function («_») to
the closed description deﬁned by VecD.
Finally, we can deﬁne the formal model of closed indexed vectors and their

146
constructors.
Vec : ‘Set →N →Set
Vec A n = J ‘Vec A n K
nil : {A : ‘Set} →Vec A zero
nil = init (true , tt) , reﬂ
cons : {A : ‘Set} {n : N} (a : J A K) (xs : Vec A n) →Vec A (suc n)
cons {n = n} a (xs , reﬂ) = init (false , n , a , (ń u →xs) , reﬂ, tt) , reﬂ
Above, the types of the vector type former and its constructors are visually
similar to the type data declaration (of Vec) presented at the beginning. One key
diﬀerence is that every open type (Set) is replaced by a closed type (‘Set). While
the natural number argument (N) is deﬁned as the interpretation of the natural
numbers, the type argument (‘Set) remains uninterpreted.
Keeping the closed
type (‘Set) argument uninterpreted is the key to writing fully generic functions (in
Chapter 7) by pattern matching against closed type codes (i.e., the constructors
of ‘Set).
Finite Sets
Now we give the type of ﬁnite sets (Fin) as another example (in
addition to Vec) of modeling an open indexed type as an open inductive-recursive
type. First, review the high-level open indexed type of ﬁnite sets.
data Fin : N →Set where
here : (n : N) →Fin (suc n)
there : (n : N) (i : Fin n) →Fin (suc n)
Using the same procedure to derive indexed vectors from inductive-recursive
vectors (in Section 5.4.3), we derive indexed ﬁnite sets (Fin) from the inductive-
recursive type of ﬁnite sets (Fin1) and its decoding function (Fin2). The decoding

147
function computes the index of the codomain of each constructor, from its argu-
ments.
mutual
data Fin1 : Set where
here : (n : N) →Fin1
there : (n : N) (i : Fin1) (q : Id N (Fin2 i) n) →Fin1
Fin2 : Fin1 →N
Fin2 (here n) = suc n
Fin2 (there n i q) = suc n
Fin : N →Set
Fin n = Σ (Fin1) (ń i →Id N (Fin2 i) n)
Converting the open type above to a closed description follows the same rules
that we followed to convert open vectors to a closed description. The primary
diﬀerence is that the description of closed ﬁnite sets is not parameterized by a
closed type A, because the type of ﬁnite sets is not parameterized.
FinDs : Bool →‘Desc ‘N
FinDs true = ‘σ ‘N ń n →‘Ì (suc n)
FinDs false =
‘σ ‘N ń n →
‘δ ‘⊤ń i →
‘σ (‘Id ‘N (i tt) n) ń q →
‘Ì (suc n)
FinD : ‘Desc ‘N
FinD = ‘σ ‘Bool FinDs
Finally, we deﬁne the closed type code components (‘Fin1, ‘Fin2, and ‘Fin) of
ﬁnite sets. We also deﬁne the type former (Fin) and its constructors (here and
there) by interpreting closed codes in our open model.
‘Fin1 : ‘Set
‘Fin1 = ‘µ1 ‘N FinD

148
‘Fin2 : J ‘Fin1 K →N
‘Fin2 = µ2 « FinD »
‘Fin : N →‘Set
‘Fin n = ‘Σ ‘Fin1 (ń i →‘Id ‘N (‘Fin2 i) n)
Fin : N →Set
Fin n = J ‘Fin n K
here : {n : N} →Fin (suc n)
here {n} = init (true , n , tt) , reﬂ
there : {n : N} (i : Fin n) →Fin (suc n)
there {n} (i , reﬂ) = init (false , n , (ń u →i) , reﬂ, tt) , reﬂ
Nothing new is required to understand the constructions above. One minor
change, compared to the data declaration of indexed ﬁnite sets earlier, is that we
expose an implicit natural number (n) argument in the here and there constructors.
We presented the closed type of ﬁnite sets for two reasons. First, as another
example of an indexed (but not parameterized) type derived from an inductive-
recursive type. Second, our next example is deﬁning closed arithmetic expressions
(Arith), which depends on closed ﬁnite sets as an argument.
Arithmetic Expressions
Now we will close the type of arithmetic expres-
sions (Arith), an example of a non-trivially inﬁnitary and non-trivially inductive-
recursive type. All previous examples were trivially inﬁnitary (N, Fin, and Vec).
Additionally, arithmetic expressions are “naturally” inductive-recursive, whereas
Vec and Fin are indexed types derived from inductive-recursive encodings. First,
review the high-level declaration of arithmetic expressions.
mutual
data Arith : Set where
Num : N →Arith

149
Prod : (a : Arith) (f : Fin (eval a) →Arith) →Arith
eval : Arith →N
eval (Num n) = n
eval (Prod a f) = prod (eval a) (ń i →eval (f i))
Below, we deﬁne the closed description of arithmetic expressions, which is quite
similar to its open description in Section 5.4.3. The interesting diﬀerence is that
the second ‘δ encodes the inﬁnitary domain of f to be a closed ﬁnite set (‘Fin).
Hence, there is no issue deﬁning closed inductive-recursive types that use closed
indexed types derived from closed inductive-recursive types.
ArithDs : Bool →‘Desc ‘N
ArithDs true = ‘σ ‘N ń n →‘Ì n
ArithDs false =
‘δ ‘⊤ń a →
‘δ (‘Fin (a tt)) ń f →
‘Ì (prod (a tt) f)
ArithD : ‘Desc ‘N
ArithD = ‘σ ‘Bool ArithDs
Now we can deﬁne the closed type of (codes for) arithmetic expressions (‘Arith),
and its decoding function (eval).
‘Arith : ‘Set
‘Arith = ‘µ1 ‘N ArithD
eval : J ‘Arith K →N
eval = µ2 « ArithD »
Finally, we deﬁne the type former (Arith) and its constructors (Num and Prod)
by interpreting closed codes in our open model.
In the deﬁnition of Prod, we
expose a non-inﬁnitary a argument (of type Arith), so its position in the init tuple
of arguments is wrapped in a trivially inﬁnitary function that ignores its u argument
(of type unit). In contrast, the second argument f is naturally inﬁnitary, hence no

150
such wrapping is necessary for f, within init.
Arith : Set
Arith = J ‘Arith K
Num : N →Arith
Num n = init (true , n , tt)
Prod : (a : Arith) (f : Fin (eval a) →Arith) →Arith
Prod a f = init (false , (ń u →a) , f , tt)
6.2.3
Kind-Generalized Universes
Because we are claiming that we are formally modeling a closed universe (Sec-
tion 2.2), we must be able to inhabit the type of codes and its meaning function.
A universe (Univ) can be formally modeled as a dependent record consisting of a
Code type, and a Meaning function mapping codes to types (Set).4
record Univ : Set1 where
ﬁeld
Code : Set
Meaning : Code →Set
As expected, we can model the Closed Inductive-Recursive Types universe as a
member Univ, by using ‘Set for the codes and J_K for the meaning function.
‘SetU : Univ
‘SetU = record { Code = ‘Set ; Meaning = J_K }
Thus, ‘SetU is the evidence that Closed Inductive-Recursive Types deﬁnes a
universe, where closed type codes ‘Set are formally modeled by the kind of open
types Set via the meaning function J_K. Now that we have deﬁned a closed universe
4 In Section 2.2, universes are modeled as a dependent pair (Σ) type, where the ﬁrst component
is the type of codes and the second is the meaning function. The Univ record is really just a
dependent pair that we have named Univ, and whose components we have named Code and
Meaning.

151
modeled in terms of the kind of open types (Set), can we similarly deﬁne a closed
universe modeled in terms of our other kind, namely the kind of open descriptions
(Desc)?
We can, and we call it the Closed Inductive-Recursive Descriptions universe.
But ﬁrst, we must generalize what it means to be a universe. Previously, we deﬁned
the Univ record with a Meaning function whose codomain is the kind Set. Now,
we deﬁne a generalized version where the codomain of the Meaning function is an
arbitrary kind (K : Set1).
record Univ (K : Set1) : Set1 where
ﬁeld
Code : Set
Meaning : Code →K
We can still deﬁne Closed Inductive-Recursive Types as a kind-generalized uni-
verse by specializing K to the kind Set.
‘SetU : Univ Set
‘SetU = record { Code = ‘Set ; Meaning = J_K }
However, now we can also deﬁne Closed Inductive-Recursive Descriptions as a
kind-generalized universe by specializing K to the kind Desc.
‘DescU : (O : ‘Set) →Univ (Desc J O K)
‘DescU O = record { Code = ‘Desc O ; Meaning = «_» }
Thus, ‘DescU is the evidence that Closed Inductive-Recursive Descriptions
is a parameterized universe (Section 2.2.9), where the parameter O represents
the codomain of the decoding function of the closed inductive-recursive algebraic
datatypes. If we modeled standard (i.e., not inductive-recursive) dependent alge-
braic datatypes (like in Section 5.3.2), then this parameter would disappear.
By creating a closed universe of types that includes closed user-declared datatypes
modeled using initial algebra semantics, we learn that the standard notion of a uni-
verse in type theory can be generalized. A universe normally maps codes to types

152
(Set), but more generally the meaning function can map codes to any kind, such
as descriptions (Desc). This generalization explains why we call J_K the meaning
function for closed types (‘Set), but also call «_» the meaning function for closed
descriptions (‘Desc).
6.3
HOW TO CLOSE A UNIVERSE
The closed universe of Section 6.2 is a ﬁne result, because it supports user-declared
datatypes, but also fully generic programming (demonstrated in Chapter 7). How-
ever, readers may be curious how we arrived at this universe.
Perhaps, more
importantly, what procedure turns an open universe into a closed version? You
may want to support fully generic programming over a universe that represents
algebraic datatypes with diﬀerent properties, or uses a diﬀerent encoding of de-
scriptions, or uses an entirely diﬀerent style of semantics. We describe a procedure
to close a universe below.
6.3.1
Procedure
1. Select a kind K, then mutually:
(a) Declare a kind ‘K, representing (what will be) closed codes of K.
(b) For each formation rule of K, encode it as a constructor of ‘K.
(c) Deﬁne a meaning function (J_K) mapping each encoded constructor of
‘K to the actual K formation rule it represents.
2. In the kind former and constructors of ‘K, and in the body of the meaning
function (J_K), simultaneously:
(a) Replace occurrences of the kind K with its closed encoding ‘K.
(b) Replace references to A of kind K with the meaning function applied to
the reference (J A K).

153
3. Recursively apply this procedure for another kind J.
(a) Select J from the arguments of either the kind former, or formation
rules, of K.
(b) In the recursive Step 1, for any K that has already been closed over,
implicitly replace K and its references with ‘K and applications of its
meaning function (J_K).
4. Change ‘K from a kind to a type, by replacing Set with Set1 in the codomain
of the kind former of ‘K.
In the procedure above, all closed codes ‘K, and their meaning functions (J_K),
are mutually deﬁned. Once the procedure terminates, all closed codes ‘K will be
types (Set), rather than kinds (Set1), thanks to Step 4.
6.3.2
Example Procedure Run
Typically, we are interested in closing over a universe of types, so our initial K will
be the kind of open types (Set), and its formation rules will be some ﬁnite collection
of type formers (e.g., Bool, Id, Σ, µ1, etc.) Subsequently, other kinds K (e.g., Desc)
that we encounter have constructors (e.g., Ì, σ, and δ) as their formation rules. For
example, consider closing over the subset of the kind Set below.
data N : Set where
zero : N
suc : N →N
data Vec (A : Set) : N →Set where
nil : Vec A zero
cons : {n : N} →A →Vec A n →Vec A (suc n)
data µ1 (O : Set) (D : Desc O) : Set where
init : J D K1 D →µ1 O D

154
Step 1
We select K to be kind Set, and the type formers of the collection of types
above are its formation rules. Once this step is complete, ‘K is ‘Set (representing
what will be closed types), and its meaning function is J_K.
We present both
below.
data ‘Set : Set1 where
‘N : ‘Set
‘Vec : (A : Set) (n : N) →‘Set
‘µ1 : (O : Set) (D : Desc O) →‘Set
J_K : ‘Set →Set
J ‘N K = N
J ‘Vec A n K = Vec A n
J ‘µ1 O D K = µ1 O D
Step 2
Next, we replace occurrences of Set with ‘Set, and references A of kind
Set with J A K.
data ‘Set : Set1 where
‘N : ‘Set
‘Vec : (A : ‘Set) (n : N) →‘Set
‘µ1 : (O : ‘Set) (D : Desc J O K) →‘Set
J_K : ‘Set →Set
J ‘N K = N
J ‘Vec A n K = Vec J A K n
J ‘µ1 O D K = µ1 J O K D
At this point, our universe is quite like our failing attempt of a closed universe
(Section 6.1), because Desc in argument D of ‘µ1 is not closed yet.
Step 3
Next, we encounter the kind of descriptions (Desc) in the D argument of
the ‘µ1 constructor, so we must recursively apply the procedure by choosing J to
be Desc. For the next part of this procedure run, we need to start over at Step
1 when recursively closing over the kind Desc. However, we will instead call this

155
Step 3.1, where the 3 preﬁx indicates that the recursion was initiated by Step 3
when closing over the kind Set. For reference, we present the kind of descriptions
(Desc) below.
data Desc (O : Set) : Set1 where
Ì : (o : O) →Desc O
σ : (A : Set) (D : A →Desc O) →Desc O
δ : (A : Set) (D : (A →O) →Desc O) →Desc O
Step 3.1
The constructors of Desc above are its formation rules. Once this step
is complete, ‘J is ‘Desc (representing what will be closed descriptions), and its
meaning function is «_». We present both below.
data ‘Desc (O : ‘Set) : Set1 where
‘Ì : (o : J O K) →‘Desc O
‘σ : (A : ‘Set) (D : J A K →Desc J O K) →‘Desc O
‘δ : (A : ‘Set) (D : (J A K →J O K) →Desc J O K) →‘Desc O
«_» : {O : ‘Set} →‘Desc O →Desc J O K
« ‘Ì o » = Ì o
« ‘σ A D » = σ J A K D
« ‘δ A D » = δ J A K D
Notice that the kind former argument O (of ‘Desc) already has kind ‘Set (rather
than Set) because Set was previously encoded as ‘Set. Similarly, A arguments of
‘Desc constructors, and the O argument in the type of the closed descriptions
meaning function («_»), already have kind ‘Set. In all three of these places, and
in the body of the closed descriptions meaning function («_»), references (e.g., A)
to kinds ‘Set already have the meaning function of closed types applied to them
(e.g., J A K).

156
Step 3.2
Next, we replace occurrences of Desc with ‘Desc, and references D of
kind Desc with « D ».
data ‘Desc (O : ‘Set) : Set1 where
‘Ì : (o : J O K) →‘Desc O
‘σ : (A : ‘Set) (D : J A K →‘Desc O) →‘Desc O
‘δ : (A : ‘Set) (D : (J A K →J O K) →‘Desc O) →‘Desc O
«_» : {O : ‘Set} →‘Desc O →Desc J O K
« ‘Ì o » = Ì o
« ‘σ A D » = σ J A K (ń a →« D a »)
« ‘δ A D » = δ J A K (ń o →« D o »)
Notice that ‘Desc (which replaced Desc in the D arguments of the ‘µ1, ‘σ, and
‘δ constructors) is applied to O, without the closed types meaning function (J_K),
because the ‘Desc kind former expects a closed type (‘Set).
Additionally, the ‘σ and ‘δ cases of the closed descriptions meaning function
(«_») now recursively apply «_» to the result of the inﬁnitary function D.
Step 4
Because there are no kinds left to recursively apply the procedure to,
Step 4.1 and Step 4.2 can be completed by changing closed types (‘Set) and
closed descriptions (‘Desc) from kinds to types. Any kinds that were arguments
of the original collection of type formers have been replaced by types, making the
ﬁnal universe closed. Below is the ﬁnal result of the procedure.
mutual
data ‘Set : Set where
‘N : ‘Set
‘Vec : (A : ‘Set) (n : N) →‘Set
‘µ1 : (O : ‘Set) (D : ‘Desc O) →‘Set
J_K : ‘Set →Set
J ‘N K = N
J ‘Vec A n K = Vec J A K n
J ‘µ1 O D K = µ1 J O K « D »

157
data ‘Desc (O : ‘Set) : Set where
‘Ì : (o : J O K) →‘Desc O
‘σ : (A : ‘Set) (D : J A K →‘Desc O) →‘Desc O
‘δ : (A : ‘Set) (D : (J A K →J O K) →‘Desc O) →‘Desc O
«_» : {O : ‘Set} →‘Desc O →Desc J O K
« ‘Ì o » = Ì o
« ‘σ A D » = σ J A K (ń a →« D a »)
« ‘δ A D » = δ J A K (ń o →« D o »)
Reﬂecting upon how the procedure operates, we come to understand that only
kind arguments of the original type formers are encoded, and the meaning function
is only applied to members of kinds. This explains why the N argument of the
vector type former (encoded as ‘Vec) did not get encoded. Hence, we did not create
a code (i.e., ‘N) and meaning function for the type of natural numbers, but we did
(i.e., ‘Desc) for the kind of descriptions. Additionally, the type meaning function
(J_K) does not recurse on n in the ‘Vec case, nor does the description meaning
function («_») recurse on o in the ‘Ì case, because both n and o are values of a
type rather than members of a kind.
6.4
TYPES VERSUS KINDS
In Section 6.3 we explain how to close over a subset of types, mutually by closing
over descriptions. In this section we examine the distinctions between kinds and
types in more detail. In particular, we compare and contrast the kind of types (Set
: Set1) and the kind of descriptions (Desc : Set →Set1), and where they show up
(and do not show up) in the universe construction.
6.4.1
Open Types and Kinds
While both types (Set) and descriptions (Desc) are open kinds (Set1), somehow
Desc feels “more closed” than Set. We will precisely identify the properties that

158
cause that feeling, by comparing and contrasting the open kinds Set and Desc.
First, let’s revisit the idea of open types from Section 2.1.12.
Lists
Consider the type of lists (List below), parameterized by some type A
(representing the type of the elements of the list). List is an open type, because its
collection of values is open. Hence, whenever a new type is declared (in open type
theory), it can be used as the A parameter (e.g., by applying List to Bool, Tree,
etc.). This is because the kind of the A parameter is Set, the canonical source of
openness.
data List (A : Set) : Set where
nil : List A
cons : (a : A) (xs : List A) →List A
While the type of lists (List) is open, it is inductively deﬁned by a closed col-
lection of constructors. This may seem obvious, but we will return to this point
when discussing the diﬀerence between the kinds Set and Desc.
Descriptions
Now let’s consider the kind of descriptions (Desc below), param-
eterized by some type O, representing the codomain of the inductive-recursive
decoding function. Desc is an open kind, because its collection of elements is open.
Henceforth, we refer to the inhabitants of kinds as large values (we could emphasize
the distinction with inhabitants of types by calling them small values).
data Desc (O : Set) : Set1 where
Ì : (o : O) →Desc O
σ : (A : Set) (D : A →Desc O) →Desc O
δ : (A : Set) (D : (A →O) →Desc O) →Desc O
Similar to why List is an open type, Desc is an open kind because its collection
of large values grows as its O parameter is instantiated to diﬀerent types, and
is used as the type of the o argument in the Ì constructor. Another reason why
descriptions are an open kind is that the A argument of the σ and δ constructors

159
have kind Set. Because Desc constructors deﬁne elements of a kind, we sometimes
call them large constructors.
While the kind of descriptions (Desc) is open, it is inductively deﬁned by a
closed collection of constructors. The List type and Desc kind are both open, but
are deﬁned by a closed collection of constructors, because they are both inductively
deﬁned.
Types
Finally, consider the kind of types (Set). The kind of types is open, as
it is the canonical source of openness. Unlike Desc, Set is not inductively deﬁned.
Every time a new type is declared, its type former becomes a new “constructor”
of the kind of types (Set). For example, consider the datatype declarations below.
data N : Set where
zero : N
suc : N →N
data Vec (A : Set) : N →Set where
nil : Vec A zero
cons : {n : N} →A →Vec A n →Vec A (suc n)
data µ1 (O : Set) (D : Desc O) : Set where
init : J D K1 D →µ1 O D
We can split a datatype declaration into 2 parts.
1. The signature, containing the type former between data and where keywords.
2. The body, containing the constructors after the where keyword.
The formation rules of kind Set are deﬁned by the signature part of datatype
declarations, but the collection of formation rules is open to extension (i.e., when-
ever a new type is declared).
In contrast, the formation rules of kind Desc is
deﬁned by the body part of its datatype declaration, using the closed collection of
constructors in the body.

160
6.4.2
Gratuitous Kinds
An algebraic declaration introduces a type into our open theory if the codomain
of the signature of the declaration is Set. In contrast, an algebraic declaration
introduces a kind into our open theory if the codomain of the signature of the
declaration is Set1.
But what determines that a declaration needs to be a kind, as opposed to a
type? If all non-inductive arguments of all constructors are classiﬁed by types (like
n : N, b : Bool, and a : A where A : Set), then we can choose to algebraically
declare a type. For example, lists (List, below) can be declared as a type because
the only non-inductive constructor argument is a of type A (where A : Set, and is
the parameter of the lists).
data List (A : Set) : Set where
nil : List A
cons : (a : A) (xs : List A) →List A
However, we may choose to declare lists gratuitously as a kind (List1, below),
even though it is consistent to declare them as a type.
data List1 (A : Set) : Set1 where
nil : List1 A
cons : (a : A) (xs : List1 A) →List1 A
If at least one algebraic constructor has an argument that is classiﬁed by a kind
(like A : Set, D : Desc O, etc.), then we must algebraically declare a kind. For
example, heterogenous lists (HList, below) must be declared as a kind, because the
cons constructor contains argument A of kind Set.
data HList : Set1 where
nil : HList
cons : {A : Set} →A →HList →HList
Finally, we emphasize that both types and kinds can be closed or open, so the
type versus kind distinction is orthogonal to the closed versus open distinction.

161
For example, the type of parameterized lists (List, above) is open (we explain how
parameterization makes this possible in Section 6.4.4). On the other hand, below
we gratuitously declare closed natural numbers (N1) as a kind.
data N1 : Set1 where
zero : N1
suc : (n : N1) →N1
6.4.3
Types versus Descriptions
In an open type theory like Agda, Set is a unique kind because it is not inductively
deﬁned (i.e., it has an open collection of formation rules, extended by type formers
in the signature of datatype declarations). Every other kind (like Desc) is deﬁned
by a closed collection of formation rules (i.e., the constructors in the body of the
datatype declaration for the kind).
The open-versus-closed formation rules distinction between kinds Set and Desc,
and the diﬀerence in the way the formation rules are deﬁned by datatype decla-
ration signatures or bodies, is what made coming up with an adequate deﬁnition
of a closed universe diﬃcult. In fact, we ﬁrst deﬁned an inadequate deﬁnition of
a closed universe [18], where certain algebraic types (like natural numbers) were
(adequately) encoded in the ﬁrst universe, but others (like parameterized lists)
needed to be (inadequately) lifted to the second universe.
The solution to deﬁning a closed universe adequately (as in Section 6.2, fol-
lowing the procedure in Section 6.3) is to create codes for types (‘Set) mutually
with codes for descriptions (‘Desc). At ﬁrst, this may seem odd because descrip-
tions (Desc) can already be viewed as codes (whose interpretation function is the
ﬁxpoint operator µ1). Hence, ‘Desc can be viewed as a code for codes. However,
this is necessary because Desc codes are open descriptions, while ‘Desc codes are
closed descriptions.
Part of what led us to realizing that codes for closed types (‘Set) need to

162
be deﬁned mutually with codes for closed descriptions (‘Desc), was viewing the
“constructors” of kinds Set and Desc in a unifying way as kind formers. Rather
than focusing on the syntactic diﬀerence that a type former (of Set) appears in the
signature of a declaration, and a large constructor (of Desc) appears in the body
of a declaration, we can simply focus on the fact they are both formation rules of
some kind. For example, below we list the formation rules for the kind Set and
the kind Desc in a uniﬁed way.
Set : Set1
Desc : (O : Set) →Set1
N : Set
Ì : (o : O) →Desc O
Vec : (A : Set) (n : N) →Set
σ : (A : Set)
(D : A →Desc O) →Desc O
µ1 : (O : Set) (D : Desc O) →Set
δ : (A : Set)
(D : (A →O) →Desc O) →Desc O
The ﬁrst row contains the kind formers Set and Desc. Subsequent rows in the
ﬁrst column contain type formers, serving a role analogous to large constructors,
but for kind Set. Subsequent rows in the second column contain the large con-
structors of kind Desc. This uniﬁed way of presenting Set and Desc leads us to
refer to large constructors of Desc as description formers.
6.4.4
Kind-Parameterized Types
To perform fully generic programming, our original goal was to create a closed
universe of types. This universe corresponds to the ﬁrst universe in a hierarchy
of universes (we deﬁne the hierarchy in Chapter 8). For the ﬁrst universe to be
adequate, it should contain all possible small values. In other words, ‘Set should
encode types like ‘Bool, ‘Σ, and ‘Vec, whose elements are small values. However, it
should not encode kinds like ‘Set and ‘Desc, whose elements would be large values.
Encoding large values in the ﬁrst universe leads to inconsistency due to a type in
type paradox [28, 34].

163
If ‘Desc should not be encoded in our ﬁrst universe, then why do we need to
close over it when deﬁning our universe at all? The answer is that the kind Desc
appears as an argument to the type former of µ1. This is similar to how the kind
Set appears as an argument to the type former of Vec. However, this leads us to
the next question: why can a type like Vec have a kind-level type former argument
(i.e., its parameter A of kind Set) while remaining a type itself (rather than being
lifted to a kind)? The answer has to do with both Vec and µ1 being deﬁned as
kind-parameterized types.
Vectors
Consider the type of vectors, parameterized by elements of some type
A, and indexed by the natural numbers.
data Vec (A : Set) : N →Set where
nil : Vec A zero
cons : {n : N} →A →Vec A n →Vec A (suc n)
Vectors are types, rather than kinds, because the codomain of their type former
is Set (rather than Set1). An algebraic datatype can consistently be classiﬁed as a
type so long as its constructors do not contain a kind (e.g., Set) as a formal argu-
ment. Datatype parameters give us a way to refer to A (of kind Set) in the vector
constructors, without actually taking A as a formal argument in the declaration of
each constructor. Hence, the declarations of the nil and cons constructors do not
have an A argument. However, if we consider the types of the constructors (rather
than their declarations), we see that A appears as an informal argument to each
constructor.
nil : {A : Set} →Vec A zero
cons : {A : Set} {n : N} (a : A) →Vec A n →Vec A (suc n)
Notice that the cons constructor must take n as a formal argument so that it
may determine the index to be suc n. We call A an informal argument because the
underlying constructor declaration does not store the type A (even though cons

164
does store the value a of type A, because a is not a parameter of Vec). It is exactly
this fact, that the declaration of the nil and cons constructors do not formally store
A (of kind Set) as an argument, that allows Vec to be a type (Set) rather than a
kind (Set1). To see the diﬀerence, we deﬁne vectors to be indexed by A, rather
than parameterized by A, below.
data Vec : (A : Set) →N →Set1 where
nil : {A : Set} →Vec A zero
cons : {A : Set} {n : N} →A →Vec A n →Vec A (suc n)
The type former Vec declares A to be an index because it appears to the right
of the colon in the datatype declaration signature (appearing to the left makes it a
parameter). Now the nil and cons constructors must take A as a formal argument,
because it is no longer available as a parameter. Because A is a kind (Set), and it
appears as formal constructor arguments, the indexed vector type must be a kind
(hence, the codomain of its former is Set1).
Fixpoints
Now let’s reconsider the deﬁnition of the type of ﬁxpoints, parameter-
ized by the decoding codomain O and the description D. Below, we only present
the deﬁnition of the interpretation function (J_K1) and the ﬁxpoint datatype (µ1).
For the full deﬁnition, including the decoding function, see Section 5.4.2.
J_K1 : {O : Set} (D R : Desc O) →Set
J Ì o K1 R = ⊤
J σ A D K1 R = Σ A (ń a →J D a K1 R)
J δ A D K1 R = Σ (A →µ1 _ R) ń f →J D (µ2 R ◦f) K1 R
data µ1 (O : Set) (D : Desc O) : Set where
init : J D K1 D →µ1 O D
Both parameters (O and D) of the ﬁxpoint datatype (µ1) are kinds (Set and
Desc, respectively). Hence, µ1 can be a type (Set), rather than a kind (Set1), be-
cause its constructor (init) does not contain any formal arguments that are classiﬁed

165
by kinds. While the type parameter (O) is used similarly to the type parameter
(A) of vectors, the description parameter (D) is used in a signiﬁcant way. The
interpretation function (J_K1) is applied to the D parameter to compute the type
of the argument to init. While J_K1 takes a kind (D) as an input, it returns a
type as an output. Hence, init never actually stores a description (i.e., a kind) as
a formal argument.
We discuss the signiﬁcance of computing over a large (i.e., a kind) parameter
in a constructor argument of a type in Chapter 10. The consequence is that ﬁx-
points can be deﬁned as a type, hence they model algebraic datatypes as types,
whose inhabitants are (small) values. It would be inadequate to model algebraic
datatypes (like natural numbers or vectors) at the level of kinds, because users ex-
pect to declare them as types. Signiﬁcantly, by deﬁning closed descriptions (‘Desc)
mutually with closed types (‘Set), we preserve the adequate encoding of ‘µ1 as a
closed type, allowing our formal model of closed algebraic datatypes (like in ‘N and
‘Vec in Section 6.2.2) to adequately classify small values (like ‘zero and ‘nil).
Heterogenous Lists
We have learned that certain datatypes can be declared
as types, rather than kinds, by changing datatype indices to datatype parameters.
However, if a datatype is not indexed, then this change is not applicable, and the
type must be declared as a kind. For example, consider the kind of heterogenous
lists (HList below).
data HList : Set1 where
nil : HList
cons : {A : Set} →A →HList →HList
Because the cons constructor of heterogenous lists takes A of kind Set as a
formal argument, there is no choice but to make HList a kind (Set1). We could
imagine indexing HList by the collection of types it contains, and then using our
trick to turn the index into a parameter. However, this would not adequately deﬁne

166
heterogenous lists, because the types of elements would be statically determined.
For similar reasons, the descriptions (Desc) must be a kind, rather than a type.
The ﬁrst closed universe (of Section 6.2) cannot encode kinds like Set, Desc, and
HList. However, Chapter 8 deﬁnes a closed hierarchy of universes, allowing kinds
to be represented in the next (i.e., second) universe (i.e., the universe of closed
kinds). Further levels of the universe correspond to closed superkinds (Set2), and
so on (Set3, Set4, ... , Setω).

167
Chapter 7
FULLY GENERIC FUNCTIONS
In this chapter1 we formally model fully generic programming in a closed de-
pendently typed language.
We write fully generic functions in the universe of
Section 6.2, supporting user-declared datatypes while remaining closed.
Thus far we have focused on deﬁning concrete datatypes in our universe of
(inductive-recursive) algebraic types.
Smart constructors (deﬁned as functions,
ﬁrst demonstrated in Section 5.1.3), for the type former and constructors of a
concrete algebraic datatype, allow us to construct concrete types and their values
while hiding their generic encoding in terms of initial algebra semantics. Similarly,
pattern synonyms (demonstrated in Section 5.1.3), for constructors of concrete
types encoded using initial algebra semantics, allow us to deconstruct generically
encoded values by writing functions deﬁned by pattern matching while hiding
underlying algebraic encodings.
While smart constructors and pattern synonyms shelter users from generic en-
codings when they construct and deconstruct concrete datatypes, fully generic
programming requires users to understand how to generically construct and de-
construct encoded datatypes, by applying and matching against the initial algebra
constructor of µ1. By deﬁnition, fully generic functions can be applied to (and
may return) values of any user-declared type, thus understanding the underlying
generic encoding (or something isomorphic to it) is necessary. In this chapter we
deﬁne three fully generic functions:
1 This chapter is adapted from work by myself and Sheard [18], as explained in Section 9.4.

168
1. count, in Section 7.1, counting the number of nodes in a generically encoded
value.
2. lookup, in Section 7.2, looking up any subnode of a generically encoded value.
3. ast, in Section 7.3, marshalling any generically encoded value to an abstract
syntax tree (AST), deﬁned as a rose tree.
Major Ideas
The purpose of this chapter is to demonstrate examples of fully
generic programming over the universe deﬁned in Section 6.2 (which also appears
in Appendix C). Traditional generic programs (as explained in the introduction
of Chapter 1) only recurse into inductive constructor arguments. We could write
a traditional generic size function, like the one in Section 1.2.1, over the open
universe of inductive-recursive types in Section 5.4.4. We could also write other
traditional generic functions that only need to recurse into inductive constructor
arguments, such as map and fold.
In contrast, this chapter focuses on writing fully generic programs, like the
count function of Section 1.2.2. Fully generic programs can recurse into both the
inductive and non-inductive arguments of constructors. In Section 7.1, we deﬁne
a fully generic count function over the closed universe of Section 6.2, modeling a
dependently typed language supporting user-declared types. Functions that mar-
shal data into another format (such as binary, JSON, XML, etc.) are a prime
example of fully generic programming. When marshaling data, it is not enough to
marshal just the inductive structure of values, we also want to marshal all of the
non-inductive values contained in the structure.
Section 7.3 features a fully generic function (ast) that marshals data into a
common rose tree format, used to visualize values with Graphviz [25]. The primary
thing to notice in this chapter is that the deﬁnitions of generic functions recurse
into non-inductive arguments. This includes recursion into both components of the
built-in type of pairs (in the ‘Σ case of closed built-in types ‘Set), and recursion into

169
non-inductive constructor arguments (in the ‘σ case of closed functor descriptions
‘Desc).
7.1
FULLY GENERIC COUNT
In this section, we develop a fully generic count function that counts the number
of nodes that make up a generically encoded value. The count function is used
in the type of the subsequently-deﬁned generic lookup in Section 7.2. The count
function is used as the maximum bound for the index argument of lookup.
7.1.1
Generic Types
Before covering the details of implementing count, we return to the introduction of
our dissertation to clarify our intuition about the type signatures of fully generic
functions. In Section 1.2.3, we hinted that any fully generic function can be de-
ﬁned by mutually deﬁning a function over all types and another function over all
descriptions (whose ﬁxpoint is a special case of the function over all types).
(A : Type) (a : J A K) →...
(D : Desc) (x : µ D) →...
Specializing this template to a generic count, and making some changes to work
with our closed universe of Section 6.2 (discussed below), results in the following
two mutually deﬁned functions.
count : (A : ‘Set) →J A K →N
countµ : {O : ‘Set} (D : ‘Desc O) →µ1 J O K « D » →N
The intuition (presented in Section 1.2.3 of the introduction) behind the closed
count function is largely correct. The only diﬀerence is that we have renamed Type
to ‘Set, to notationally emphasize that its interpretation as a Set is obtained by
“removing the backtick”.

170
However, the intuition behind the closed countµ function is simpliﬁed in the
introduction. A minor diﬀerence is that we must add an O parameter, to account
for the codomain of the inductive-recursive decoding function.
The ﬁrst major diﬀerence is that the intuition from the introduction leads to
deﬁning countµ over all open descriptions (Desc), but fully generic programming
demands that we deﬁne it over all closed descriptions (‘Desc). Let’s remind our-
selves of the deﬁnition (from Section 5.4.4) of the type component of the ﬁxpoint
operator:
data µ1 (O : Set) (D : Desc O) : Set where
init : J D K1 D →µ1 O D
Recall that µ1 expects O to be the kind of open types (Set), and D to be the
kind of open descriptions (Desc). When we write the type of a generic function,
like countµ, we quantify over all closed types O (of type ‘Set), and all closed
descriptions D (of type ‘Desc).
The third argument to countµ is the result of applying the type meaning func-
tion (J_K) to the closed type (‘µ1 O D), which deﬁnitionally reduces to µ1 applied
the type meaning (J_K) of O and the description meaning («_») of D. This models
values of closed types within our open metalanguage, Agda (using open types like
µ1).
The second major diﬀerence between the types we use for fully generic program-
ming, and the types behind the intuition in the introduction, is that we cannot
directly deﬁne a function like countµ over all closed descriptions. The problem is
that the inductive hypothesis is not general enough in the inﬁnitary (hence, also
inductive) ‘δ case. If we tried to write countµ directly, we would not remember the
original inductive description when we reach the ‘δ case, because countµ would be
deﬁned by recursively destructing the description argument.
Instead of mutually deﬁning count with countµ (a function over all algebraic

171
types), we mutually deﬁne count with counts (a function over all arguments of al-
gebraic types, isomorphic to countµ). The counts function has an extra description
argument, R, that stays constant to remember the original description as the D
description argument is recursively destructed.
counts : {O : ‘Set} (D R : ‘Desc O) →J « D » K1 « R » →N
Recall that J_K1 (deﬁned below, for reference) is the type component of the
interpretation function for descriptions. It appears as the sole argument to the
initial algebra constructor of µ1.
Because µ1 O D is isomorphic to J D K1 D,
deﬁning counts is an acceptable alternative to deﬁning countµ.
J_K1 : {O : Set} (D R : Desc O) →Set
J Ì o K1 R = ⊤
J σ A D K1 R = Σ A (ń a →J D a K1 R)
J δ A D K1 R = Σ (A →µ1 _ R) ń f →J D (ń a →µ2 R (f a)) K1 R
The interpretation function (J_K1) recurses over the ﬁrst argument (D) to de-
termine the type of constructor arguments, while holding the second argument (R)
constant. This allows J_K1 to remember the original complete description (R) of
the algebraic type, even though it is destructing a copy of it (D) as it recurses.
By remembering the original description (R), the open δ case can request an
inﬁnitary (hence, also inductive) argument as the ﬁrst argument to Σ. For anal-
ogous reasons, counts is generically deﬁned over all descriptions (D), but also a
copy (R) of the original complete description that it can use to count inﬁnitary
arguments in the closed ‘δ case.
In summary, we deﬁne how to generically count values of the closed universe in
terms of 2 mutually deﬁned functions, count and counts. The ﬁrst is deﬁned over
all closed types (‘Set) and the second is deﬁned over all closed descriptions (‘Desc).

172
7.1.2
Counting All Values
First, let’s deﬁne count fully generically for all values of all types (of Appendix C).
This involves calling counts in the ‘µ1 case, deﬁned mutually (in Section 7.1.3) over
all arguments of the initial algebra. Below, we restate the type of count, and then
deﬁne count by case analysis and recursion over all of its closed types.
count : (A : ‘Set) →J A K →N
Recall that we wish to deﬁne count as the sum of all constructors and the
recursive count of all constructor arguments. It may be helpful to review count for
the ﬁxed closed universe in the introduction (Section 1.2.2), to see how it compares
to our new count, deﬁned over an extendable closed universe (by user-declared
datatypes).
Dependent Pair
We count a dependent pair by summing the recursive count of
both its components (a and b), plus 1 to also count the pair constructor (,).
count (‘Σ A B) (a , b) = 1 + count A a + count (B a) b
Notice that the dependent type of the second component (b) is computed by
applying the codomain of the dependent pair (B) to the ﬁrst component (a).
Algebraic Fixpoint
We count an algebraic ﬁxpoint by recursively counting its
arguments (xs) using counts, plus 1 to account for the init constructor.
count (‘µ1 O D) (init xs) = 1 + counts D D xs
When we initially call counts, D is used for both of its arguments. However, as
counts recurses, the ﬁrst description argument will be destructed while the second
(original) description argument is held constant.
Remaining Values
All constructors of the remaining types (such as Bool) do
not have arguments, so we count them as 1 (for their constructor, plus 0 for their

173
arguments). Note that this includes functions (the ‘Π case), which we treat as
a black box by counting the λ constructor as 1, without recursively counting its
body.
count A a = 1
7.1.3
Counting Algebraic Arguments
Second, let’s deﬁne counts fully generically for all arguments of the initial algebra.
This involves calling count in the ‘σ and ‘δ cases, deﬁned mutually (in Section 7.1.2)
over all values of all types. Below, we restate the type of counts, and then deﬁne
counts by case analysis and recursion over all of its closed descriptions (for refer-
ence, the declaration of Desc appears in Appendix B).
counts : {O : ‘Set} (D R : ‘Desc O) →J « D » K1 « R » →N
Recursion is performed over the ﬁrst description argument (D), while the second
argument (R) is kept constant, so we have access to the original description in the
inductive ‘δ case.
Finally, our intention is to count an algebraic value init xs as 1 (for init) plus
the recursive sum of all of its arguments (for xs). Even though xs is technically
implemented as a sequence of dependent pairs (,), we will not add 1 for each
pair constructor (,), which we choose to view as part of the encoding rather than
something to be counted. Hence, counts treats its argument xs as a single n-tuple,
rather than several nested pairs.2
2 Although we are hiding the nested-pairs (of the initial algebra) aspect of the encoding, we
are exposing the encoding when counting constructors. Constructors are encoded as a depen-
dent pair, representing a disjoint union. Our count function counts the boolean and the pair
constructor, rather than hiding that aspect of the encoding. We could create a separate universe
of codes that explicitly represents constructors, along with a new meaning function mapping to
the underlying Descriptions, so that our generic count could hide the encoding of constructors
as derived disjoint unions. However, we chose not to do so to make the presentation easier to
follow.

174
Non-Inductive Argument
When we come across a non-inductive argument in
a sequence of arguments, we sum the count of the non-inductive argument (a) with
the counts of the remainder of the sequence of arguments (xs).
counts (‘σ A D) R (a , xs) = count A a + counts (D a) R xs
Note that a is counted using our mutually deﬁned count over all values, and
xs is recursively counted (via counts) using the description resulting from applying
the dependent description D (of ‘σ) to the value a. The original description R is
passed to counts unchanged.
Inductive Argument
When we come across an inductive argument, in a se-
quence of arguments, we sum the count of the inductive argument (x) with the
counts of the remainder of the sequence of arguments (xs).
counts (‘δ ‘⊤D) R (f , xs) = count (‘µ1 _ R) (f tt) +
counts (D (µ2 « R » ◦f)) R xs
Inductive arguments are a special case of inﬁnitary arguments where the domain
of the inﬁnitary function is the unit type (⊤). The ﬁrst argument to the closed
description ‘δ is a closed type. Because the ﬁrst argument is a closed type, we can
pattern match against the closed unit type (‘⊤). This allows us to distinguish how
we count inductive arguments from how we count inﬁnitary arguments, and is only
possible because our universe is closed (i.e., if the argument had kind Set, it would
be open and we could not pattern match against it)!
The inductive argument is obtained by applying the inﬁnitary argument f to the
trivial value tt. But what type should we use to count it? Because it is an inductive
(hence, algebraic) value, the type should be the ﬁxpoint (‘µ1) applied to some
description. We kept the original description (R) to count inductive arguments for
exactly this case.
The remaining sequence of arguments (xs) is recursively counted (via counts)

175
using the description resulting from applying the dependent description D (of ‘δ) to
the composition of the decoding function ﬁxpoint component (µ2) and the inﬁnitary
value f. Recall (from Section 5.4.2) that the D argument of ‘δ is a description that
depends on the decoding function for our inductive-recursive type. The type of the
decoding function is the implicit composition of the decoding ﬁxpoint component
(µ2) and the inﬁnitary value f (the nature of the implicit composition is explained
in Section 5.4.2). In our generic function above, we explicitly create the value of this
decoding function to satisfy the implicit expectation in the type of its description.
Inﬁnitary Argument
When we come across an inﬁnitary argument, in a se-
quence of arguments, we add 1 to the counts of the remainder of the sequence of
arguments (xs). This counts the inﬁnitary λ constructor as 1, treating it as a black
box, analogous to how we count the ‘Π case as 1.
counts (‘δ A D) R (f , xs) = 1 + counts (D (µ2 « R » ◦f)) R xs
The remaining sequence of arguments (xs) is recursively counted just like the
inductive (‘δ ‘⊤) case, where the dependent description D is applied to the com-
position of the ﬁxpoint interpretation component (µ2) and the inﬁnitary argument
(f).
Last Argument
Every sequence of algebraic constructor arguments terminates
in the trivial value tt of type unit (⊤), which we count as 1.
counts (‘Ì o) R tt = 1
We could choose to count the trivial (tt) last argument as 0, hiding the aspect
of the encoding that every sequence of arguments is terminated by tt. However, we
choose to count tt as 1 because the subsequently deﬁned generic function, lookup
in Section 7.2, treats the result of count as an index into all values and subvalues

176
of a type.3
7.1.4
Examples
Now that we’ve deﬁned count fully generically, let’s run it on some examples to
better understand how it works. The key lesson to take away is that count and
counts use a depth-ﬁrst traversal to count values and subvalues.
Natural Numbers
First, we consider counting the closed encoding of the nat-
ural number 0. It may be helpful to review the closed deﬁnition of the natural
numbers in Section 6.2.2. The natural number 0 is encoded (below) by zero as
the initial algebra applied to a dependent pair (,) consisting of the boolean true
(selecting the zero-constructor branch of the dependent description used to encode
the natural numbers), and the unit value (tt).
zero : J ‘N K
zero = init (true , tt)
We generically count the closed zero by summing 1 for the initial algebra con-
structor, 1 for the true argument, and 1 for the terminating unit argument (tt),
3 Given our generic encoding of inductive-recursive types, the ability to count or lookup the
trivial value (tt) may not seem useful. Nevertheless, we include this functionality because it
becomes useful when generalizing our universe to include indexed algebraic types. In the initial
algebra semantics for indexed types, the ﬁnal unit type (⊤) is replaced by the identity type (Id),
used as a constraint on the index of the algebraic type. Being able to count and lookup the
constraint is important in the indexed universe.

177
resulting in 3.4
count ‘N zero ≡3
Next, let’s deﬁne the closed natural number 1. We can deﬁne one by applying
our closed successor (from Section 6.2.2) to our closed zero.
one : J ‘N K
one = suc zero
Expanding these deﬁnitions results in the closed encoding of 1 below.
one ≡init (false , (ń _ →init (true , tt)) , tt)
The false value in the closed one deﬁnition selects the successor branch of the
description, and the next argument contains the inlined deﬁnition of zero, wrapped
in a function ignoring its trivial unit argument. Recall that inductive natural num-
bers are encoded as trivially inﬁnitary types, using the unit type (⊤) as the domain
of the inﬁnitary function. The Inductive case of counts is able to recursively count
the inductive body of the successor (i.e., zero) because it is able to pattern match
against the closed type ‘⊤to distinguish counting inductive (or trivially-inﬁnitary)
arguments from counting (truly) inﬁnitary arguments.
count ‘N one ≡6
Finally, we count closed one as 6, adding up 1 for each constructor appearing
in the encoded deﬁnition (init, false, init, true, tt, and tt), from left to right. The
reason behind that order is that count and counts recursively add 1 for each encoded
constructor by doing a depth-ﬁrst traversal. To help visualize the traversal, and
4 Once again, this is an encoding-aware count, because it is used to index which nodes (in
a generically encoded data structure) to lookup (in Section 7.2). It would also be possible to
deﬁne an encoding-unaware count, that does not count true (encoding constructor choice) and
tt (encoding the end of the sequence of constructors). Encoding-unaware count could be generi-
cally deﬁned over a universe of constructor-aware descriptions, equipped with an interpretation
function to translate constructor-aware descriptions into our constructor-unaware descriptions.
Applying an encoding-unaware count to zero would result in 0, as it would not count constructor
choice data (like true) or argument sequence data (like tt).

178
aid in the legibility of encoded values, refer to Figure 7.1. The edges of Figure 7.1
are labeled according to a depth-ﬁrst traversal of nodes (where 0 is an implicit
edge for the root node).
Because count (and counts) traverses in a depth-ﬁrst
manner, each edge represents the aggregate count at the time count is called for
the corresponding node. Note that the result of applying count to the root node
is 1 plus the ﬁnal edge (1 + 5, above).5
init
false
1
init
2
tt
5
true
3
tt
4
Figure 7.1: The natural number 1, as a closed algebraic type.
The depth-ﬁrst labeling of edges pointing to nodes that count performs makes
it an ideal function to index positions of arguments in generically encoded values.
For example, in Figure 7.1 we can see value zero at edge 2, and value one at edge
0 (the root node). Finally, let’s deﬁne closed two.
two : J ‘N K
5 All algebraic types in ﬁgures hide the inﬁnitary λ constructor at inductive argument posi-
tions, because count (whose depth-ﬁrst traversal the Figure represents) implicitly applies trivially
inﬁnitary functions to tt in the Inductive (‘δ) case.

179
two = suc one
init
false
1
init
2
tt
8
false
3
init
4
tt
7
true
5
tt
6
Figure 7.2: The natural number 2, as a closed algebraic type.
Counting closed two results in 9, as can be seen in Figure 7.2 (by adding 1 to
the ﬁnal edge 8). In Figure 7.2, two appears at edge 0, one appears at edge 2, and
zero appears at edge 4.
count ‘N two ≡9
Vectors
Now let’s encode the closed 0-length empty vector ([]). Again, it may
be helpful to review the closed deﬁnition of vectors in Section 6.2.2. Recall that
indexed vectors are encoded as a dependent pair whose ﬁrst component is an
inductive-recursive ‘Vec1 (like a list, but with natural number arguments and index

180
constraints on inductive occurrences), and whose second component constrains (via
the equality type Id) the decoding (via ‘Vec2, or the length function) of the ﬁrst
component to be the appropriate index.
Below, the closed empty vector [] is encoded by nil as such a dependent pair,
where the ﬁrst component is an initial algebra value (of type ‘Vec1), and the second
component is a proof (using reﬂ, the constructor of equality type Id) that ‘Vec2
applied to the ﬁrst component is indeed zero (the expected length of the empty
vector, as speciﬁed by its type).
nil : {A : ‘Set} →J ‘Vec A zero K
nil = init (true , tt) , reﬂ
Our examples count vectors of pairs of strings. The generic count of the empty
vector (i.e., nil) of pairs of strings is 5, the sum of 1 for init, true, tt, (,), and reﬂ.
count (‘Vec (‘String ‘× ‘String) zero) nil ≡5
Next, let’s deﬁne length-1 closed vector of pairs of strings [("a", "x")]. We
can deﬁne vec1 by applying our closed cons constructor (from Section 6.2.2) to our
closed zero constructor.
vec1 : J ‘Vec (‘String ‘× ‘String) one K
vec1 = cons ("a" , "x") nil
Expanding these deﬁnitions results in the closed encoding of [("a", "x")]
below.
vec1 ≡(init
( false
, init (true , tt)
, ("a" , "x")
, (ń _ →init (true , tt))
, reﬂ
, tt)

181
, reﬂ)
To understand this, it is worth remembering that indexed vectors (‘Vec) are
deﬁned as a constraint paired with an inductive-recursive (but not indexed) version
of the vector (‘Vec1). Below, we directly deﬁne the indexed vector vec1 (of type
‘Vec), without using the smart constructors cons and nil, in terms of the auxiliary
deﬁnition vec11 for the inductive-recursive (‘Vec1) left component of the pair (of
type ‘Vec1).
_,_
init
1
reﬂ
14
false
2
init
3
_,_
6
init
9
reﬂ
12
tt
13
true
4
tt
5
"a"
7
"x"
8
true
10
tt
11
Figure 7.3: The length-1 vector of pairs of strings [("a", "x")], as a closed alge-
braic type.
vec11 : J ‘Vec1 (‘String ‘× ‘String) K
vec11 = init
( false
, init (true , tt)
, ("a" , "x")

182
, (ń _ →init (true , tt))
, reﬂ
, tt)
vec1 : J ‘Vec (‘String ‘× ‘String) one K
vec1 = vec11 , reﬂ
To understand how vec1 is counted (as 15), we refer to our visual presentation
in Figure 7.3, depicting the depth-ﬁrst traversal of count. The root node is vec1
(of type ‘Vec), the dependent pair. Node 14 is the constraint (of type Id) that the
left component has length one. Node 1 is the inductive-recursive vec11 (of type
‘Vec1).
We establish the convention that suﬃxing a term or constructor by 1 refers
to the inductive-recursive (of type ‘Vec1) equivalent of the constraint pair of type
‘Vec. For example, nil1 refers to an empty inductive-recursive vector of type ‘Vec1,
the left component of the constraint pair nil of type ‘Vec (mirroring the relationship
between vec11 and vec1, above).
In Figure 7.3 (and all of our ﬁgures), we draw boxes around the outermost
occurrence of an inductive value. For example, the root node does not have a
box around it, because it is a non-inductive pair (of type ‘Σ). However, node 1
has a box around it, for the inductive ‘Vec1 value (vec11). Within a box, any
occurrence of init represents an inductive occurrence whose type shares the type
of the box. For example, node 9 is a nil1 value of type ‘Vec1. Recall that each
inductive argument of the inductive-recursive ‘Vec1 is packaged with a constraint
on its length (calculated by the inductive-recursive decoding function ‘Vec2). Node
12 is the constraint that the length of node 9 (encoding the inductive occurrence
of nil1 within the box for vec11, at node 1) is 0.
Node 2 is false, representing the choice of the cons1 constructor in the de-
scription of ‘Vec1. Node 6 is the non-inductive pair (_,_) of strings "a" and "b"

183
contained by the vector. Node 3 contains a box around it, meaning it is an occur-
rence of an inductive type distinct from ‘Vec1. Speciﬁcally, node 3 is the natural
number zero, constrained to equal the length of the empty vector (nil1) at node
9, in the type of the constraint (reﬂ) at node 12. Finally, nodes 5, 11, and 13 all
represent the terminating unit (tt) of an algebraic sequence of arguments.
count (‘Vec (‘String ‘× ‘String) one) vec1 ≡15
Finally, let’s deﬁne the length-2 closed vector of pairs of strings [("a", "x"),
("b", "y")]. We can deﬁne vec2 with our closed constructors nil and cons of
closed Vectors.
vec2 : J ‘Vec (‘String ‘× ‘String) two K
vec2 = cons ("a" , "x") (cons ("b" , "y") nil)
The fully generic count of vec2 is 28, as justiﬁed by Figure 7.4. In Figure 7.4,
node 12 is the length-1 "b" and "y" component of type ‘Vec1. Node 14 is the
natural number zero, the length of nil1 at node 20. Node 3 is the natural number
zero, the length of the "b" and "y" vector at node 12.
count (‘Vec (‘String ‘× ‘String) two) vec2 ≡28
We conclude this section by reﬂecting on how the relationship between al-
gebraically deﬁned length-indexed vectors and their algebraically deﬁned natural
numbers is elegantly captured in Figure 7.4. Notice how natural numbers (nodes 3
and 14) appear at the same level, and have the same height, as their vector equiv-
alents (nodes 12 and 20). This visually demonstrates how the natural number
argument of cons is mirrored by the structure of the inductive argument of cons,
enforced by their relationship in the deﬁnition of the indexed type of vectors.

184
_,_
init
1
reﬂ
27
false
2
init
3
_,_
9
init
12
reﬂ
25
tt
26
false
4
init
5
tt
8
true
6
tt
7
"a"
10
"x"
11
false
13
init
14
_,_
17
init
20
reﬂ
23
tt
24
true
15
tt
16
"b"
18
"y"
19
true
21
tt
22
Figure 7.4: The length-2 vector of pairs of strings [("a", "x"), ("b", "y")], as a closed algebraic type.

185
7.2
FULLY GENERIC LOOKUP
In this section, we develop a fully generic lookup function that can retrieve any
node of a generically encoded value. The input to lookup is a value and an index
into a position within the value. To prevent out-of-bounds errors during lookups,
we generalize the type of lookup for vectors (Vec).
To retrieve a value within a vector, we apply lookup to a vector (Vec) and a
ﬁnite set (Fin), where Fin acts as an index whose maximum value is constrained to
equal the length of the vector. Recall the type of ﬁnite sets from Section 2.1.5.
data Fin : N →Set where
here : {n : N} →Fin (suc n)
there : {n : N} →Fin n →Fin (suc n)
We think of the type of ﬁnite sets as a 0-based index whose maximum value
is the natural number that Fin is applied to, minus 1.
For all n, there are n
inhabitants of Fin n (representing indices 0 through n-1), where the ﬁrst is here,
and the rest are successive applications of there (ending in here). For example, the
inhabitants of Fin 3 are here (for index 0), there here (for index 1), and there (there
here) (for index 2).
To lookup a Vector of length n, we index by Fin n. The implementation of
lookup returns the head of the vector (at index position 0) if the index is here. If
the index is there, lookup recursively searches the tail of the vector (until it ﬁnally
ﬁnds a value to return, indicated by peeling oﬀenough theres to arrive at a here).
lookup : {A : Set} {n : N} →Vec A n →Fin n →A
lookup (cons x xs) here = x
lookup (cons x xs) (there i) = lookup xs i
Instead of using vectors, we can deﬁne lookup equivalently over lists, by com-
puting the maximum bound of the index (Fin) from the length of the List.
lookup : {A : Set} (xs : List A) →Fin (length xs) →A

186
lookup nil ()
lookup (cons x xs) here = x
lookup (cons x xs) (there i) = lookup xs i
The implementation for Lists is the same as the implementation for Vectors,
other than needing to supply explicit evidence by pattern matching against the
uninhabited empty Fin 0 index (using empty parentheses, which is Agda syntax
for explicitly pattern matching against an uninhabited type) in the nil case.
Our fully generic lookup is deﬁned similarly to the List lookup, except that
length (calculating the bound of index Fin) is replaced by our fully generic count
from Section 7.1. Recall that count sums the number of nodes in a generic value
according to a depth-ﬁrst traversal. Therefore, looking up a node in a generic value
(using lookup) corresponds to supplying a Fin index representing the depth-ﬁrst
label of the node (seen in the ﬁgures of Section 7.1.4).
7.2.1
Generic Types
Before covering the details of implementing lookup, let’s consider what its type
should be. As mentioned above, we expect lookup to have a Fin index argument
whose bound is calculated by the generic count of the value that lookup is applied
to.
Looking up a List A results in an A, but looking up a node in a generic value
causes the return type of lookup to depend on the type of node being looked up.
Thus, we must deﬁne a computational return type (Section 3.4.4), named Lookup
below, to determine what the return type of lookup should be. In other words, the
Lookup function, with an uppercase ’L’, computes the return type of the lookup
function, with a lowercase ’l’.
Lookup : (A : ‘Set) (a : J A K)
→Fin (count A a) →Set
lookup : (A : ‘Set) (a : J A K)

187
(i : Fin (count A a)) →Lookup A a i
We must also mutually deﬁne Lookups, to compute the return type when looking
up an argument of an algebraic constructor, via lookups. The lookups and Lookups
functions are deﬁned over all closed descriptions (‘Desc), analogous to how the
lookup and Lookup functions are deﬁned over all closed types (‘Set).
Lookups : {O : ‘Set} (D R : ‘Desc O) (xs : J « D » K1 « R »)
→Fin (counts D R xs) →Set
lookups : {O : ‘Set} (D R : ‘Desc O) (xs : J « D » K1 « R »)
(i : Fin (counts D R xs)) →Lookups D R xs i
The computational return types (Lookup and Lookups) are deﬁned by pattern
matching on some arguments. The functions using these types (lookup and lookups)
must match the same arguments in the same way, in order for the computational
return types to deﬁnitionally unfold. Instead of deﬁning the value and type func-
tions separately, thereby repeating the pattern matching structure twice, we will
actually deﬁne single functions returning dependent pairs (Σ).
lookup : (A : ‘Set) (a : J A K)
→Fin (count A a) →Σ Set (ń T →T)
lookups : {O : ‘Set} (D R : ‘Desc O) (xs : J « D » K1 « R »)
(i : Fin (counts D R xs)) →Σ Set (ń T →T)
The ﬁrst component of the pair corresponds to the computational return type
(Lookup or Lookups), and the second component of the pair corresponds to the
function typed by the ﬁrst component (the formerly named lookup or lookups).
We can still recover the original type and value functions by taking the ﬁrst (proj1)
and second (proj2) projections of the dependent pairs (Σ) resulting from the new
versions of lookup and lookups. By convention, we refer to the ﬁrst projection (type
component) of these functions by suﬃxing 1 (e.g., lookup1), and to the second
projection (value component) version by suﬃxing 2 (e.g., lookup2).

188
7.2.2
Looking Up All Values
First, let’s deﬁne lookup fully generically for all values of all types. This involves
calling lookups in the ‘µ1 case, deﬁned mutually (in Section 7.2.3) over all argu-
ments of the initial algebra. Below, we restate the type of lookup, and then deﬁne
lookup by case analysis and recursion over all of its closed types, and its Fin indices.
lookup : (A : ‘Set) (a : J A K) →Fin (count A a) →Σ Set (ń T →T)
Before we actually deﬁne lookup, let’s consider what the type of the index Fin
argument could be before we pattern match against it, and what lookup should
return once we do match against the index. Below, we give a template of 3 diﬀer-
ent Fin types that appear when when deﬁning lookup (as well as lookups). Each
template represents a possible type of Fin, due to partially unfolding a case of
count (in Section 7.1.2) or counts (in Section 7.1.3).
1. Case (Fin 1) There is only one possible index, so we deﬁne a here case that
returns the value at this index.
2. Case (Fin (1 + n)) We deﬁne a here case (for the 1), returning the value at
this index. We also deﬁne a there case (for the n), giving us a new argument
of type Fin n. In the there case, we return the recursive call of lookup or
lookups, depending on whether n is count or counts.
3. Case (Fin (1 + n + m)) We deﬁne a here case (for the 1), returning the value
at this index. We also deﬁne a there case (for the n + m), giving us a new
argument of type Fin (n + m). Within the there case, we must translate the
single Fin (n + m) index to the disjoint union of the two potential indices Fin
n ⊎Fin m. After case-analyzing the disjoint union (⊎), we make a recursive
call using the index within the left (inj1) or right (inj2) injection. Once again,
the recursive call is either lookup or lookups, depending on whether n or m
(whichever one we ﬁnd in the disjoint union) is count or counts.

189
To know which Case template to use for lookup at some type A, match the
template with the case of count in Section 7.1.2 that A corresponds to.
Algebraic Fixpoint
For the there case of algebraic ﬁxpoints (Case 2), we re-
cursively lookup its arguments (xs), using the mutually deﬁned lookups.
– i :
Fin (counts D D xs)
lookup (‘µ1 O D) (init xs) (there i) = lookups D D xs i
For clarity, we include the type of the index i (the argument of the there con-
structor) as a comment. In Agda, comments are colored red and are preﬁxed by
a dash. In the type of i, the value that Fin is applied to corresponds to the value
of n in Case 2.
Dependent Pair
For the there case of dependent pairs (Case 3), we use the
helper function splitΣ (deﬁned in Figure 7.5) to turn i, a single index (Fin) con-
taining a sum (+), into a disjoint union (⊎) of two indices.
– i :
Fin (count A a + count (B a) b)
lookup (‘Σ A B) (a , b) (there i) with splitΣ A B a b i
– j :
Fin (count A a)
... | inj1 j = lookup A a j
– j :
Fin (count (B a) b)
... | inj2 j = lookup (B a) b j
If the disjoint union is the left injection (inj1), we recursively lookup the ﬁrst
component of the pair (a). If the disjoint union is the right injection (inj2), we
recursively lookup the second component of the pair (b). The two possible values
that Fin is applied to in the two possible types of j correspond to n and m in Case
3.
Remaining Values
Finally, the here case can be deﬁned uniformly over all types.
If the index points to here, we simply return the value a at this position, along

190
with the type meaning function (J_K) applied to the closed type (A) of the value,
as a dependent pair (,).6
lookup A@(‘Σ _ _) a here = J A K , a
For ‘µ1 this is the here component of the deﬁnition of Case 2, and for ‘Σ this
is the here component of the deﬁnition of Case 3. For all other types, this is the
deﬁnition of Case 1 (which does not have a there component).
7.2.3
Looking Up Algebraic Arguments
Second, let’s deﬁne lookups fully generically for all arguments of the initial alge-
bra. This involves calling lookup in the ‘σ and ‘δ cases, deﬁned mutually (in Sec-
tion 7.2.2) over all values of all types. Below, we restate the type of lookups, and
then deﬁne lookups by case analysis and recursion over all of its closed descriptions,
and its Fin indices.
lookups : {O : ‘Set} (D R : ‘Desc O) (xs : J « D » K1 « R »)
→Fin (counts D R xs) →Σ Set (ń T →T)
We will also classify the cases in the deﬁnition of lookups by the Case template
numbers. Below, we repeat the ﬁrst 2 Case templates from Section 7.2.2 verbatim.
However, the 3rd template is diﬀerent because it lacks a “1 + ...” preﬁx.7
1. Case (Fin 1) There is only one possible index, so we deﬁne a here case that
returns the value at this index.
6 We use an @-pattern to bind A to the matched ‘Σ type. Unfortunately Agda makes us
repeat this deﬁnition for all other remaining types, but at least the right-hand sides are all the
same because of the @-pattern. The problem with lookup is that count appears in its type, which
is deﬁned using a catch-all pattern clause. Unfortunately, we cannot write lookup using the same
catch-all pattern structure, and must instead enumerate all types and duplicate their right-hand
sides manually. Deﬁning lookup by repeating the catch-all structure of count would be possible
if Agda were changed to type-check code after coverage checking.
7 The lack of the “1 + ...” preﬁx is because we allow indexing into any argument of a sequence,
but prevent indexing into the sequence itself or subsequences. Instead, we hide that aspect of the
algebraic encoding, making init (containing the sequence of arguments) seem like one big n-ary
tuple, rather than containing n nested pairs.

191
2. Case (Fin (1 + n)) We deﬁne a here case (for the 1), returning the value at
this index. We also deﬁne a there case (for the n), giving us a new argument
of type Fin n. In the there case, we return the recursive call of lookup or
lookups, depending on whether n is count or counts.
3. Case (Fin (n + m)) There is only one possible index, so we deﬁne its there
case (for n + m). Within the there case, we must translate the single Fin
(n + m) index to the disjoint union of the two potential indices Fin n ⊎
Fin m. After case-analyzing the disjoint union (⊎), we make a recursive call
using the index within the left (inj1) or right (inj2) injection. Once again,
the recursive call is either lookup or lookups, depending on whether n or m
(whichever one we ﬁnd in the disjoint union) is count or counts.
To know which Case template to use for lookups at some description D, match
the template with the D case of counts in Section 7.1.3.
Non-Inductive Argument
For the (only) there case of a non-inductive argu-
ment (Case 3), in a sequence of arguments, we use the helper function splitσ
(deﬁned in Figure 7.5). The helper function turns i, a single index (Fin) containing
a sum (+), into a disjoint union (⊎) of two indices. While splitΣ operates over a
dependent pair, splitσ is specialized to operate over a non-inductive argument (a)
and its dependent sequence (xs).
– i :
Fin (count A a + counts (D a) R xs)
lookups (‘σ A D) R (a , xs) i with splitσ A D R a xs i
– j :
Fin (count A a)
... | inj1 j = lookup A a j
– j :
Fin (counts (D a) R xs)
... | inj2 j = lookups (D a) R xs j
If the disjoint union is the left injection (inj1), we recursively lookup the non-
inductive argument (a). If the disjoint union is the right injection (inj2), we recur-
sively lookups the tail of the sequence of arguments (xs).

192
Inductive Argument
For the (only) there case of an inductive argument (Case
3), in a sequence of arguments, we use the helper function splitδ (deﬁned in Fig-
ure 7.5). The helper function turns i, a single index (Fin) containing a sum (+),
into a disjoint union (⊎) of two indices. The splitδ function is specialized to work
with an inductive (i.e., not inﬁnitary) argument, and its dependent sequence (xs).
Hence, we apply splitδ to (f tt), computing the inductive codomain from the triv-
ially inﬁnitary f.
– i :
Fin (count (‘µ1 _ R) (f tt) + counts (D (µ2 « R » ◦f)) R xs)
lookups (‘δ ‘⊤D) R (f , xs) i with splitδ (D ◦const) R (f tt) xs i
– j :
Fin (count (‘µ1 _ R) (f tt))
... | inj1 j = lookup (‘µ1 _ R) (f tt) j
– j :
Fin (counts (D (µ2 « R » ◦f)) R xs)
... | inj2 j = lookups (D (µ2 « R » ◦f)) R xs j
Inﬁnitary Argument
For the there case of an inﬁnitary argument (Case 2),
in a sequence of arguments, we recursively call lookups on its arguments (xs).
lookups (‘δ A@‘Bool D) R (f , xs) (there i) = lookups (D (µ2 « R » ◦f)) R xs i
For the here case of an inﬁnitary argument (Case 1), we return the inﬁnitary
function. The type of inﬁnitary function has the type meaning (J_K) of A as its
domain, and the type component of the ﬁxpoint µ1, applied to the description
meaning («_») of R, as its codomain.
lookups D@(‘δ A@‘Bool _) R (f , xs) here = (J A K →µ1 _ « R ») , f
Recall that lookup (in Section 7.2.2, as a special case of Remaining Values)
only has a here case for functions (‘Π). Similarly, there is only a here case of lookups
for inﬁnitary functions (‘δ, where A is not ‘⊤). This is because we treat functions as
a black box, so we can point at an entire function (using here), but not something
within its body (using there).

193
Last Argument
Finally, the here case of the last argument (Case 1), described
by ‘Ì , simply returns the unit type and value.
lookups (‘Ì o) R tt here = ⊤, tt
Note also that ‘Ì does not have a there case, because it encodes the ﬁnal (trivial)
argument, so there is nothing left to index.
7.2.4
Splitting Functions
When deﬁning lookup (in Section 7.2.2) and lookups (in Section 7.2.3), we appealed
to the helper functions splitΣ, splitσ, and splitδ.
All three of these helpers are
deﬁned as shallow wrappers (in Figure 7.5) around a more general function, splitFin.
Recall that if we match against index there i in Case 3 of Section 7.2.2, then
i has type Fin (n + m), where n and m each represent either count or counts. In
an instance of Case 3, such as the ‘Σ case of lookup (Section 7.2.2), we need to
convert i into the disjoint union of Fin n and Fin m, so that we may recursively
lookup the ﬁrst component of the pair (a) using the left injection, or the second
component of the pair (b) using the right injection. The splitFin function helps us
do this.
splitFin : (n m : N) (i : Fin (n + m)) →Fin n ⊎Fin m
We only need to deﬁne splitFin by pattern matching on the ﬁrst (n) and third
(i) arguments, but not the second argument (m). This is related to the fact that
addition (+) is deﬁned by pattern matching on its ﬁrst argument, so we only need
to match n (not m) for the type of i, namely Fin (n + m), to reduce.
Because lookup is deﬁned as a depth-ﬁrst search, the splitFin function must be
left-biased (i.e., biased to return a Fin index whose bound is n, the left component
of the sum). Hence, splitFin should return the left injection if index i points to

194
here, and n is greater than 0 (i.e., it is the successor of some other number).
splitFin (suc n) m here = inj1 here
If n is zero, then the left injection is uninhabited (because it has type Fin 0),
so we are forced to return the right injection (of type Fin m).
splitFin zero m i = inj2 i
Finally, if n is greater than 0 and the index is there i, then we recursively split
i.
splitFin (suc n) m (there i) with splitFin n m i
... | inj1 j = inj1 (there j)
... | inj2 j = inj2 j
If the recursive call of splitFin on i results in a left injection, it will have type
Fin n. Hence, we must wrap the left injection in another there to bump the index
and get the expected return type (Fin (suc n)). If the recursive call of splitFin on i
results in a right injection, it already has the expected return type (Fin (suc m)).
In the input pattern of case above, there i has type Fin (suc (n + m)). In the
recursive call, i has type Fin (n + m). Hence, in the recursive call n becomes
smaller (compared to suc n), while m remains the same. This explains why we
bump the index (using there) if the recursive call results in a left injection, but not
if it results in a right injection.
7.2.5
Examples
Now we run lookup on some examples.
The expected behavior of lookup is to
return the value associated with the nth (where n is the Fin index) position in a
depth-ﬁrst search. Hence, here of type Fin corresponds to the position 0, and there
i of type Fin corresponds to the successor of the position associated with i.

195
splitΣ : (A : ‘Set) (B : J A K →‘Set)
(a : J A K) (b : J B a K) →
Fin (count A a + count (B a) b) →
Fin (count A a) ⊎Fin (count (B a) b)
splitΣ A B a b i = splitFin (count A a) (count (B a) b) i
splitσ : {O : ‘Set} (A : ‘Set) (D : J A K →‘Desc O) (R : ‘Desc O)
(a : J A K) (xs : J « D a » K1 « R ») →
Fin (count A a + counts (D a) R xs) →
Fin (count A a) ⊎Fin (counts (D a) R xs)
splitσ A D R a xs i = splitFin (count A a) (counts (D a) R xs) i
splitδ : {O : ‘Set} (D : J O K →‘Desc O) (R : ‘Desc O)
(x : µ1 J O K « R ») (xs : J « D (µ2 « R » x) » K1 « R ») →
Fin (count (‘µ1 O R) x + counts (D (µ2 « R » x)) R xs) →
Fin (count (‘µ1 O R) x) ⊎Fin (counts (D (µ2 « R » x)) R xs)
splitδ D R x xs i = splitFin (count (‘µ1 _ R) x) (counts (D (µ2 « R » x)) R xs) i
Figure 7.5: Deﬁnitions of the helper splitting functions (splitΣ, splitσ, and splitδ)
used in Section 7.2.2 and Section 7.2.3. The helpers are all just shallow
wrappers around the splitFin function (Section 7.2.4).
Natural Numbers
Let’s lookup2 some values in the closed natural number two.8
To see the expected value of lookup2 for two at some index, simply consult Fig-
ure 7.2. The labels in the Figure 7.2 correspond to natural number indices, ordered
according to a depth-ﬁrst search. Thus, by viewing here of Fin as zero of N, and
there of Fin as suc of N, we can always consult the ﬁgure to determine the expected
return value of lookup2.
Looking up index here corresponds to position 0, or the root node in Figure 7.2.
8 Recall that we deﬁne lookup as a dependent pair, where the ﬁrst component is a type and
the second component is a value (whose type is the ﬁrst component). As a shorthand, lookup1
refers to the type component, while lookup2 refers to the value component.

196
Hence, lookup2 using index here is the identity function.
lookup2 ‘N two here ≡two
If we lookup position 1 (using index there here) of two (visualized by Figure 7.2),
we get false (encoding the choice of the cons constructor).
lookup2 ‘N two (there here) ≡false
If we lookup position 2 (using index there (there here)) of two (visualized by
Figure 7.2), we get one (visualized by Figure 7.1).
lookup2 ‘N two (there (there here)) ≡one
To make lookups of higher positions more readable, we use a helper function
(#) coercing natural numbers to ﬁnite sets by converting zero to here, and suc to
there. Therefore, we can repeat the lookup2 of position 2 above as follows.
lookup2 ‘N two (# 2) ≡one
Finally, looking up position 4 of two results in zero.
lookup2 ‘N two (# 4) ≡zero
Vectors
Looking up vectors is just as easy as looking up natural numbers, by
considering the Fin argument as a natural number index of a depth-ﬁrst traversal
of the closed value. For example, the lookup2 of vec2 (visualized by Figure 7.4) at
position 3 is the natural number one (visualized by Figure 7.1).
lookup2 (‘Vec (‘String ‘× ‘String) two) vec2 (# 3) ≡one
The lookup2 of vec2 (visualized by Figure 7.4) at position 10 is the string "x".
lookup2 (‘Vec (‘String ‘× ‘String) one) vec1 (# 8) ≡"x"
Finally, the lookup2 of vec2 (visualized by Figure 7.4) at position 12 is the

197
init
false
1
init
2
_,_
5
init
8
reﬂ
11
tt
12
true
3
tt
4
"b"
6
"y"
7
true
9
tt
10
Figure 7.6: The inductive-recursive component of the length-1 vector of pairs of
strings [("b", "y")], as a closed algebraic type. This ﬁgure depicts
the inductive-recursive ﬁrst component of the vector encoded as a de-
pendent pair (the second component is the length constraint).
inductive-recursive component of the vector [("b", "y")] (visualized by Fig-
ure 7.6).
lookup2 (‘Vec (‘String ‘× ‘String) two) vec2 (# 12) ≡cons1 ("b" , "y") nil
7.3
FULLY GENERIC AST
In this section we develop a fully generic function (ast) to marshal values to an
abstract syntax tree (AST). Previously (in Section 7.1.4 and Section 7.2.5), we
visualized generically encoded data in ﬁgures (such as Figure 7.6). Those ﬁgures
were created using fully generic programming, rather than drawn by hand. They
are the result of applying ast to the value they visualize, converting the resulting
AST to a graph in the DOT language [27], and rendering the DOT code using

198
Graphviz [25].9
The result of ast is a specialized version of a Rose tree. We use the standard
List-based rose tree, rather than an inﬁnitary version (Section 2.1.8). Additionally,
throughout this section the “cons” constructor of List is denoted by (::), an inﬁx
constructor, and the “nil” constructor of List is denoted by [].
data Rose (A : Set) : Set where
tree : A →List (Rose A) →Rose A
Speciﬁcally, the result of ast is a Rose tree containing Node values. A Node is
one of the following constructors.
data Node : Set where
non str : String →Node
ind : Bool →Node
lam : Node
Each Node constructor is translated to a DOT node diﬀerently (for example,
the constructor determines the name of the DOT node, and the color of the name).
Below, we describe what each Node constructor represents and how it aﬀects the
translation to DOT code:
⋄non: Used for non-inductive constructors, such as the pair constructor (_,_
of type Σ). The name of the node is determined by the String argument, and
is colored green.
⋄str: Used for string values. The name of the node is determined by the String
argument. The string argument is colored red and is enclosed in quotes.
⋄ind: Used for the inductive initial algebra constructor (init of type µ1). The
name of the node is “init”, and is colored green. If the Bool argument is true,
then a rectangle is drawn around the node.
9 In this dissertation, we deﬁne the fully generic function ast to convert any value to an AST.
The function to convert the AST to DOT code does not involve generic programming, so it can
be found in the accompanying source code of this dissertation.

199
⋄lam: Used for higher-order values (i.e., the function case ‘Π and the inﬁnitary
case ‘δ). The name of the node is “λ”, and is colored black.
Finally, we abbreviate the result of ast as the type synonym AST, standing for
Rose trees specialized to contain Nodes.
AST : Set
AST = Rose Node
7.3.1
Generic Types
Before implementing the fully generic marshalling functions, we consider the func-
tions involved and their generic types. Two functions are unsurprising: ast deﬁned
over all closed types (‘Set) and asts deﬁned over all closed descriptions (‘Desc).
But, we will deﬁne one extra generic function, named astInd, also over all closed
descriptions (‘Desc).
As expected, we will deﬁne (in Section 7.3.3) ast to fully generically translate
any value to an AST.
ast : (A : ‘Set) (a : J A K) →AST
Additionally, we will deﬁne (in Section 7.3.4) asts to fully generically translate
algebraic arguments (of init), to a list of ASTs. Recall that the ﬁrst argument of
the tree constructor of AST (i.e., Rose specialized to Node) is a Node. The second
argument to tree is a list of other rose trees (or ASTs). Hence, asts returns a List
of ASTs, as it will be used for the second argument of tree.
asts : {O : ‘Set} (D R : ‘Desc O) →J « D » K1 « R » →List AST
Finally, we will deﬁne one additional helper function, astInd (in Section 7.3.2).
The astInd function is deﬁned fully generically over the ﬁxpoint of any description.
astInd : {O : ‘Set} (D : ‘Desc O) →µ1 J O K « D » →Bool →AST
Normally, we inline the deﬁnition of such a function by pattern matching on

200
init (in the ‘µ1 case of ast, and the ‘δ ‘⊤case of asts), and applying asts to the
contained algebraic arguments. However, we prefer to extract the deﬁnition of
astInd to deﬁne ast and asts.
Notice that astInd has an extra Bool argument. We will supply this argument
to the ind constructor of Node, indicating whether or not to draw a box around the
inductive node. Recall from Section 7.1.4 that we draw boxes in ﬁgures around the
ﬁrst occurrence of an inductive value, and suppress drawing boxes for any contained
inductive arguments of the same type. However, inductive values of diﬀerent types
should start process over, beginning by drawing a box around the inductive node.
In Section 7.3.3 and Section 7.3.4 (when deﬁning ast and asts), we will see how
passing the appropriate boolean to astInd implements this box drawing logic.
7.3.2
Marshalling Initial Algebras
First, let’s deﬁne astInd fully generically over all descriptions and their ﬁxpoints.
Below, we restate the type of astInd, and deﬁne the only case that needs to be
considered, the case for the lone initial algebra constructor of µ1.
astInd : {O : ‘Set} (D : ‘Desc O) →µ1 J O K « D » →Bool →AST
astInd D (init xs) b = tree (ind b) (asts D D xs)
The ﬁrst argument of the rose tree constructor has type Node. Because initial
algebras encode inductive types, we use the ind node. The boolean b argument is
also passed along to the ind node.
The second argument of the rose tree constructor is a List of rose trees. Hence,
the second argument to tree is the result of recursively applying the mutually de-
ﬁned asts function to the algebraic arguments (xs). Hence, the number of children
of the resulting rose tree is equal to the number of arguments in xs.

201
7.3.3
Marshalling All Values
Second, let’s deﬁne ast fully generically for all values of all types. Below, we restate
the type of ast before deﬁning it by its cases.
ast : (A : ‘Set) (a : J A K) →AST
Algebraic Fixpoint
To deﬁne the ﬁxpoint case, we simply apply the mutually
deﬁned astInd function to the algebraic argument x.
ast (‘µ1 A D) x = astInd D x true
Importantly, we use true for the boolean argument of astInd. Hence, applying
ast to any algebraic value (having type ‘µ1) results in drawing a box around it
using the DOT language.
Dependent Pair
The dependent pair case creates a rose tree with two chil-
dren (in the second argument to tree, below), by recursively applying ast to each
component of the pair (a and b).
ast (‘Σ A B) (a , b) = tree (non "_,_") (ast A a :: ast (B a) b :: [])
Because dependent pairs are non-inductive types, the ﬁrst (Node) argument to
tree is non. The argument to non is a string representing the name of the inﬁx
dependent pair constructor (_,_).
Dependent Function
We treat higher-order values, like dependent functions,
as black boxes. Hence, the ast of a function is a childless tree, whose Node is lam.
ast (‘Π A B) f = tree lam []

202
String
Strings are non-inductive values, so we use the str constructor of Node.
Strings also have no additional arguments, so their AST tree has no children.
ast ‘String x = tree (str x) []
Note that the string value x is supplied as the argument to the str constructor
of Node, so a quoted version of x can act as the name of the node when interpreted
as DOT code.
Remaining Non-Inductive Values
All remaining non-inductive values use the
non constructor of Node, and are childless (except for the ‘⊥value, which is unin-
habited).
ast ‘⊥()
ast ‘⊤tt = tree (non "tt") []
ast ‘Bool true = tree (non "true") []
ast ‘Bool false = tree (non "false") []
ast (‘Id A x y) reﬂ= tree (non "refl") []
Each occurrence of non is applied to a string name corresponding to the name
of the marshalled constructor.
7.3.4
Marshalling Algebraic Arguments
Third, let’s deﬁne asts fully generically for all arguments of the initial algebra.
Below, we restate the type of asts before deﬁning it by its cases.
asts : {O : ‘Set} (D R : ‘Desc O) →J « D » K1 « R » →List AST
Recall (from Section 7.1.3) that the arguments of the initial algebra are treated
as one big n-tuple, rather than n nested pairs. This is why each case of asts returns
a List of ASTs, rather than tree (non "_,_") applied to such a list.10
10 If each case of asts did return such a tree (non "_,_") xs, then each init constructor in ﬁgures
would have a pair (_,_) as its child node. The ﬁrst component of the pair would be the head of
xs. The second component of the pair child node would be a nested sequence of pairs, i.e., the

203
Non-Inductive Argument
The non-inductive argument case results in a list
whose head is the AST of the non-inductive argument (a), and whose tail is the
List of ASTs for the remaining arguments (xs).
asts (‘σ A D) R (a , xs) = ast A a :: asts (D a) R xs
Inductive Argument
The inductive argument case results in a list whose head
is the AST of the inductive argument (f tt), and whose tail is the List of ASTs for
the remaining arguments (xs).
asts (‘δ ‘⊤D) R (f , xs) =
astInd R (f tt) false :: asts (D (µ2 « R » ◦f)) R xs
Note that the AST of the inductive argument (f tt) is computed by astInd.
Importantly, false is supplied as the boolean argument to astInd. This is because
the inductive argument we are marshalling is known to be one of the arguments
of some previous initial algebra (that was already marshalled with a box in the ‘µ1
case of ast). Hence, we do not want to draw a box around this inductive argument
occurrence, so we choose false as the argument to astInd.
Inﬁnitary Argument
The inﬁnitary argument case results in a list whose head
is a childless lam node, and whose tail is the List of ASTs for the remaining argu-
ments (xs).
asts (‘δ A D) R (f , xs) = tree lam [] :: asts (D (µ2 « R » ◦f)) R xs
The reason why the head of the returned list is a lam node, is because we treat
the higher-order inﬁnitary function f as a black box. This is similar to how we
treat functions as black boxes in the ‘Π of ast.
nested representation of the tail of arguments xs.

204
Last Argument
Finally, the asts of the last argument (in the sequence of initial
algebra arguments) results in a single element list.
asts (‘Ì o) R tt = tree (non "tt") [] :: []
The single element of the returned list is a childless non node (because the type
of tt is ⊤, which is non-inductive). The name of the non is “tt”, after the name of
the trivial value tt.
7.3.5
Generic Template
We conclude this chapter by presenting a generic template that can be used to
deﬁne fully generic algorithms. If the return type of a fully generic algorithm is
not dependent on its inputs, then the algorithm can be implemented by mutually
deﬁning 2 functions.
generic : (A : ‘Set) →J A K →· · ·
generics : {O : ‘Set} (D R : ‘Desc O) →J « D » K1 « R » →· · ·
The ﬁrst function (generic) is deﬁned over all closed types (‘Set) and their
values. The second function (generics) is deﬁned over all closed descriptions (‘Data)
and arguments of the described initial algebra.
If the return type of a fully generic algorithm is dependent on its inputs, then
the algorithm can be implemented by mutually deﬁning 4 functions.
Generic : (A : ‘Set) →J A K →Set
generic : (A : ‘Set) (a : J A K) →Generic A a
Generics : {O : ‘Set} (D R : ‘Desc O) →J « D » K1 « R » →Set
generics : {O : ‘Set} (D R : ‘Desc O)
(xs : J « D » K1 « R ») →Generics D R xs
The 2 uppercase functions (Generic and Generics) determine the return types of
the 2 lowercase functions (generic and generics). Alternatively, we may mutually

205
deﬁne 2 functions that return dependent pairs (Σ).
generic : (A : ‘Set) (a : J A K) →Σ Set (ń T →T)
generics : {O : ‘Set} (D R : ‘Desc O)
(xs : J « D » K1 « R ») →Σ Set (ń T →T)
The ﬁrst component of the pair corresponds to the generic dependent type
of the function (Generic and Generics), and the second component corresponds to
its generic inhabitant (formerly generic and generics, from the 4 mutually deﬁned
functions).

206
Chapter 8
CLOSED HIERARCHY OF UNIVERSES
Chapter 6 demonstrates closing a universe of algebraic (inductive-recursive) types,
and Chapter 7 demonstrates fully generic programming over that universe. In this
chapter1, we expand the closed universe of Section 6.2 to also include kinds, su-
perkinds, and an inﬁnite hierarchy of such classiﬁcations. Types (Set) are classiﬁed
by kinds (Set1).
Set : Set1
Going one level up, kinds (Set1) are classiﬁed by superkinds (Set2).
Set1 : Set2
This pattern repeats itself indeﬁnitely. We refer to any such construction (e.g.,
a type, or a kind, or a superkind, etc.) as a universe.2 In Section 6.2, we only
considered the ﬁrst (or zeroth, because we count universe levels by starting with
0) closed universe (i.e., the universe of types, classiﬁed by kinds). Now, we expand
this notion to a closed inﬁnite hierarchy of universes, where each universe in the
hierarchy is classiﬁed by another universe, one level above.
Setn : Setsuc n
There are three primary things we achieve by creating a closed hierarchy of
universes:
1 This chapter is adapted from work by myself and Sheard [16], as explained in Section 9.4.
2 In this context, a universe refers to a level in a hierarchy of types (e.g. the types level, or
the kinds level, or the superkinds level, etc.). This is distinct from a universe as a formal device
consisting of a type of codes and a meaning function. Although these are distinct concepts, the
image of a particular meaning function could be a universe level of a hierarchy.

207
1. We can encode formers and constructors of kinds (as well as superkinds,
etc.) in the closed hierarchy. This includes the two primitive kinds, closed
types (‘Set) and closed descriptions (‘Desc). It also includes closed algebraic
user-declared kinds, such as heterogenous lists (‘HList).
2. We can write leveled fully generic functions. By this we mean universe poly-
morphic fully generic functions, which can be applied to members of any
universe in the hierarchy. Hence, we can extend fully generic functions (like
count, lookup, ast, etc.) from working over all types and their values, to
working over all kinds and their types (and all superkinds and their kinds,
etc.).
3. We can internalize the kind (and superkind, etc.)
signatures of formers,
constructors, and functions, by writing them as the meaning of a closed code
in our universe.
Let’s clarify what we mean by the third point, above. Throughout this disser-
tation we have written the signatures of closed formers, constructors, and functions
using our Agda metatheory, which is external to our closed universe. For example,
consider the type signature of the successor of closed natural numbers, below.
suc : (n : J ‘N K) →J ‘N K
The type signature of suc uses Agda’s open dependent function type (→).
Instead, we may internalize the type signature of suc as the meaning (J_K) of a
closed dependent function (‘Π).
suc : J ‘Π ‘N (ń n →‘N) K
Another way to look at this, is that we can ﬁt the entire type signature of suc
into the meaning brackets (J_K), as a single closed type (‘Set). In contrast, let’s

208
consider the kind signature of the cons constructor of closed parameterized lists.
cons : (A : ‘Set) (a : J A K) (xs : J ‘List A K) →J ‘List A K
We cannot internalize the kind signature of the cons function. Even though
cons returns a list value, its signature is kinded because the A argument is a kind
(‘Set). We would like to internalize the kind of cons as three nested uses of ‘Π (for
arguments A, a, and xs). However, the domain of the ﬁrst ‘Π would need to be a
constructor of closed kinds (‘Set), which does not exist in the universe of closed
types (Appendix C).
Similarly, we cannot internalize the kind signature of fully generic functions
(like count), or even parametrically polymorphic functions (like the identity func-
tion), because they need to quantify over all closed types. By deﬁning a closed
hierarchy of universes in Section 8.2, we can internalize kind (and superkind, etc.)
signatures, thereby ﬁtting them within meaning brackets. In the ﬁnal examples of
Section 8.1.2, we also discuss a sanity check for our closed hierarchy of inductive-
recursive universes, making sure that the signature of every constructor in the
universe can be internalized (the evidence is in Appendix E).
Major Ideas
The purpose of this chapter is to expand the closed universe of
types from Section 6.2 to a hierarchy of universes, including kinds, superkinds,
etc. Because the universe of Section 6.2 only models the types of a dependently
typed language, it does not model a language that supports polymorphism. This
is because there is no way to quantify over all types or descriptions (i.e., there
is no code for ‘Set or ‘Desc). Because types and descriptions are kinds, a model
of a language supporting polymorphism must model kinds in addition to types.
We go one step further and model the entire closed hierarchy of universes (in
Section 8.2.1). Hence, the closed hierarchy of universes in this chapter models a
dependently typed language that supports polymorphic functions, including fully
generic ones!

209
The fully generic functions of Chapter 7, like count of Section 7.1, are written
using the function space of Agda (our metalanguage), by quantifying over ‘Set
and ‘Desc. In contrast, in Section 8.3, we write a fully generic count within the
dependently typed language that we are modeling, because the kind signature of
the generic function can be internalized using codes from our hierarchy of universes
(i.e., by quantifying over kind codes ‘Set and ‘Desc).
8.1
CLOSED HIERARCHY OF WELL-ORDER TYPES
In this section we extend the Closed Well-Order Types universe of Section 4.2.1 to a
closed hierarchy of universes. At ﬁrst, we present a formal model (in Section 8.1.1)
of the hierarchy. Agda does not recognize our deﬁnition of the universe hierarchy
type to be positive. However, we explain why the formal model presented in this
section is consistent, and use it as motivation to deﬁne a model (in Section 8.1.3)
that Agda recognizes as positive.
By extending the Closed Well-Order Types universe to a hierarchy, we can
explain how a hierarchy is formalized in a simpler setting where Set is the only
kind being closed over (Section 8.1.1 and Section 8.1.3). With this background
material under our belt, we move on to extending the Closed Inductive-Recursive
Types universe in Section 8.2.1. There, we must close over a hierarchy involving
two kinds, Set and Desc.
8.1.1
Formal Model
Now we deﬁne a formal model of a Closed Hierarchy of Well-Order Universes.
We do this by mutually deﬁning a type of universe codes (‘Set[_]), indexed by
the natural numbers, and a meaning function (J_|_K) mapping a universe in the
hierarchy to an Agda type (i.e., a type of our metalanguage). Henceforth, we refer
to ‘Set[_] as the leveled types and J_|_K as the leveled type meaning function.

210
The natural number index represents the universe level, in a hierarchy of uni-
verses. For example, ‘Set[ 0 ] models closed types (whose open equivalent is Set),
‘Set[ 1 ] models closed kinds (whose open equivalent is Set1), ‘Set[ 2 ] models closed
superkinds (whose open equivalent is Set2), and so on.
Closed Leveled Types
Below, we state the type former of of the closed leveled
types, and subsequently deﬁne its constructors.
data ‘Set[_] : N →Set where
The name of the indexed type (‘Set[_]) is Agda syntax for deﬁning an inﬁx
operator, such that the natural number index appears where the underscore is
located. For example, the universe of closed types is represented by ‘Set[ 0 ]. The
left component of the inﬁx operator name is ‘Set[, and the right component of the
name is ].
Closed Types
Now let’s deﬁne the closed types. The closed types inhabit ‘Set[
0 ], where the natural number index is 0, encoding the zeroth universe of types.
However, we want a version of all closed types (especially closed type formers like
‘Π) to appear at higher universes as well.
‘⊥‘⊤‘Bool : ∀{ℓ} →‘Set[ ℓ]
‘Σ ‘Π ‘W : ∀{ℓ} (A : ‘Set[ ℓ]) (B : J ℓ| A K →‘Set[ ℓ]) →‘Set[ ℓ]
‘Id : ∀{ℓ} (A : ‘Set[ ℓ]) (x y : J ℓ| A K) →‘Set[ ℓ]
Above, the index in the codomain of all constructors is ℓ. Thus, we have deﬁned
closed types as the special case where ℓis 0, and a copy of the closed types at all
higher levels. The constructors of these types are similar to the constructors of
‘Set in Section 4.2.1, but with an extra polymorphic level (ℓ) threaded throughout.
Closed Kinds
Now let’s deﬁne the closed kinds. The closed types inhabit ‘Set[
1 ], where the natural number index is 1, encoding the ﬁrst universe of kinds. We

211
also want a version of all closed kinds to appear at higher universes.
‘Set : ∀{ℓ} →‘Set[ suc ℓ]
‘J_K : ∀{ℓ} →‘Set[ ℓ] →‘Set[ suc ℓ]
Above, the index in the codomain of all constructors is suc ℓ. Thus, we have
deﬁned closed kinds as the special case where ℓis 0, and a copy of the closed kinds
at all higher levels.
At universe level 1, ‘Set is the closed kind of types (‘Set : ‘Set[ 1 ]). At universe
level 0, the ‘Set constructor is uninhabited because its index speciﬁes that it should
be greater than or equal to 1.
We have also added a closed meaning function constructor (‘J_K), allowing us
to lift a type from the previous universe to be a kind in the current universe. The
closed meaning function (‘J_K), or type lifting operator, ensures that our universes
form a hierarchy. This is because we can apply the type lifting operator ‘J_K to
any universe ‘Set[ ℓ], making the lifted value a member of the subsequent universe
‘Set[ suc ℓ].
Meaning of Closed Leveled Types
Second, we state the signature of the
meaning function of closed leveled types.
J_|_K : (ℓ: N) →‘Set[ ℓ] →Set
The name of the meaning function (J_|_K) is Agda syntax for deﬁning a mixﬁx
operator. The natural number argument (ℓ) appears in the location of the ﬁrst
underscore, and the closed leveled type (‘Set[_]) argument appears in the location
of the second underscore.
Meaning of Closed Types
The meaning of closed types (or their copies at
higher levels) is straightforward.
J ℓ| ‘⊥K = ⊥
J ℓ| ‘⊤K = ⊤

212
J ℓ| ‘Bool K = Bool
J ℓ| ‘Σ A B K = Σ J ℓ| A K (ń a →J ℓ| B a K)
J ℓ| ‘Π A B K = (a : J ℓ| A K) →J ℓ| B a K
J ℓ| ‘W A B K = W J ℓ| A K (ń a →J ℓ| B a K)
J ℓ| ‘Id A x y K = Id J ℓ| A K x y
The leveled closed type meaning function (J_|_K) is similar to the unleveled
version (J_K) in Section 4.2.1, but with an extra polymorphic level (ℓ) threaded
throughout.
Meaning of Closed Kinds
The meaning of closed kinds interprets the code of
types ‘Set as a leveled type ‘Set[_], and the code of the closed meaning function
‘J_K as the leveled meaning function J_|_K.
J suc ℓ| ‘Set K = ‘Set[ ℓ]
J suc ℓ| ‘J A K K = J ℓ| A K
Importantly, the level decreases, from suc ℓto ℓ, when interpreting closed kinds
(and their copies at higher universe levels). Hence, we interpret the code of types
in this universe (‘Set) as the actual leveled type of the previous universe (‘Set[ ℓ
]).
Consider the case where ‘Set : ‘Set[ 1 ]. This implies that the interpretation
J 1 | ‘Set K is equal to ‘Set[ 0 ]. In this model, the level decreasing (from 1 to 0)
captures the high-level notion that Set0 : Set1, preventing a “type in type” (or
“kind in kind”, etc.) paradox (i.e., Set1 : Set1, if the level did not decrease).
Failing Positivity Check
The problem with the formal model presented above
is that it fails Agda’s positivity checker. The meaning function (J_|_K) appears in
the domain of the B argument of the ‘Σ, ‘Π, and ‘W constructors of leveled types
(‘Set[_]). If this meaning function is applied to the code of types (e.g., J 1 | ‘Set K),
then the result will be a leveled type (e.g., ‘Set[ 0 ]), making B a negative inﬁnitary
argument.

213
By external analysis of the deﬁnition of the leveled types indexed by the nat-
ural numbers, we can see that the index decreases (from 1 to 0) when a negative
occurrence manifests. Furthermore, there are no constructors of ‘Set[_] with an
argument whose level increases. Therefore, no leveled type in the hierarchy con-
tains types from levels above it (it only contains types from levels below it). Hence,
argument B is not actually a negative occurrence, because it only contains lower
types, which cannot contain any types at the current level. Currently, Agda’s pos-
itivity checker cannot perform such an analysis, so Section 8.1.3 deﬁnes an Agda
model that reiﬁes our positivity argument in its structure.
8.1.2
Examples
Let’s consider some examples where we internalize the signatures of functions using
codes of our universe hierarchy.
Negation Function
First, we deﬁne the negation function (not), whose type is
deﬁned using a dependent function (→), external to our closed hierarchy (i.e., from
our Agda metalanguage). Below, we insert the type of not in open type theory as
a comment.
– not :
(b :
Bool) →Bool
not : (b : J 0 | ‘Bool K) →J 0 | ‘Bool K
not true = false
not false = true
Note that the signature is a type because the universe level (i.e., the ﬁrst ar-
gument to the meaning function) is 0. Now, we internalize the type signature of
negation.
not : J 0 | ‘Π ‘Bool (ń b →‘Bool) K
not true = false

214
not false = true
It is good that we can internalize the type of negation, but we could already
do that using our universe of closed types in Section 4.2.1. Our next example
(the identity function) shows how to internalize a kind, which the universe of
Section 4.2.1 cannot do.
Identity Function
First, we deﬁne the identity function (id), whose type is
deﬁned using a dependent function (→) external to our closed hierarchy. Below,
we insert the type of id in open type theory as a comment.
– id :
(A : Set) (a :
A) →A
id : (A : ‘Set[ 0 ]) (a : J 0 | A K) →J 0 | A K
id A a = a
The type of the identity function quantiﬁes over all types in the zeroth uni-
verse. Hence, the universe of closed types (in Section 4.2.1) cannot internalize the
signature of id, because it is a kind signature that requires quantifying over all
types. The universe of closed types (in Section 4.2.1) does not have a code for
closed types (‘Set), making such a quantiﬁcation impossible.
id : J 1 | ‘Π ‘Set (ń A →‘Π ‘J A K (ń a →‘J A K)) K
id A a = a
Above, we have internalized the kind signature of id. The signature is a kind,
because the universe level (i.e., the ﬁrst argument to the meaning function) is 1.
At universe level 1, the closed type constructor ‘Set and closed meaning function
constructor (‘J_K) are inhabited, allowing us to internalize the signature of id as a
closed kind.
Note that the argument A in the closed kind of id is the meaning of ‘Set. At
kind level 1, the meaning function of ‘Set returns a closed type (‘Set[ 0 ], at level
0). Hence, the second argument of id, and the codomain of id, must lift (using
‘J_K) the type A (at level 0), so that the entire signature of id can be a kind (at

215
level 1).
8.1.3
Agda Model
Now we deﬁne an Agda model of a Closed Hierarchy of Well-Order Universes. Pre-
viously (in Section 8.1.1), we deﬁned a formal model of the hierarchy as a datatype
indexed by the natural numbers, which Agda fails to recognize as a positive deﬁ-
nition. The Agda model of a Closed Hierarchy of Well-Order Universes is due to
McBride [42].
Now, we deﬁne the hierarchy in 2 stages, allowing Agda to recognize the pos-
itivity of the deﬁnition. In the ﬁrst stage, we deﬁne an open datatype (SetForm),
parameterized by an abstract notion of the previous universe level (Level). In the
second stage, we deﬁne the closed hierarchy (‘Set[_]) of universes, indexed by the
natural numbers, but as a computational family (Section 2.1.11). In other words,
we model the indexed deﬁnition (‘Set[_]) by deriving it as a function from the
natural numbers to types, and this function is deﬁned in terms of the parame-
terized deﬁnition (SetForm). Correspondingly, we also deﬁne a meaning function
abstracted over the previous universe level (J_/_K), which is used to derive the
meaning function over all levels (J_|_K).
Abstract Universe Levels
First, we deﬁne the abstract notion of the previous
universe (whose level is the predecessor of the current universe), as the dependent
record Level. The Level record is used as the parameter of the type deﬁned in the
ﬁrst stage of our hierarchy construction.
record Level : Set1 where
ﬁeld
SetForm : Set
J_/_K : SetForm →Set
The SetForm ﬁeld represents a closed type from the previous universe, and the

216
J_/_K ﬁeld represents the closed type meaning function from the previous universe.
Note that Level is isomorphic to the Univ record of Section 6.2.3, just with diﬀerent
ﬁeld names. Additionally, note that SetForm is a Set, and the codomain of J_/_K
is Set, so Level is an open kind.
Pre-Closed Leveled Types
Next, we state the type former (SetForm) of a
type at an arbitrary level, parameterized by the universe at the previous level.
Technically, SetForm is an open type, due to its use of the open Level parameter.
However, we plan to ﬁll in the parameter with a closed universe in stage 2 of the
construction. Hence, we refer to SetForm, and associated constructions, as being
pre-closed.
data SetForm (ℓ: Level) : Set where
We name our parameterized pre-closed type “SetForm”.
Whereas ‘Set[_] is
indexed by natural numbers, SetForm is parameterized by the previous universe
level. We call this type SetForm, because we intend to “ﬁll in” the abstract universe
level with a concrete universe in the second stage of the construction (i.e., when
deriving the indexed type ‘Set[_]), just like we would “ﬁll in” a “form”.
Pre-Closed Types
The pre-closed type constructors of our parameterized type
(SetForm) are similar to the corresponding constructors of the indexed formal
model (‘Set[_]).
‘⊥‘⊤‘Bool : SetForm ℓ
‘Σ ‘Π ‘W : (A : SetForm ℓ) (B : J ℓ/ A K →SetForm ℓ) →SetForm ℓ
‘Id : (A : SetForm ℓ) (x y : J ℓ/ A K) →SetForm ℓ
Compared to ‘Set[_], the main diﬀerence is that the constructors of SetForm
do not take the level ℓas a formal argument. This is because ℓis now a parameter
(because it appears to the left of the colon in the datatype declaration), hence it
is an informal and implicit argument of all constructors. Importantly, this allows

217
SetForm to be a type, even though it is parameterized by Level, which is a kind (as
explained in Section 6.4.4).
Pre-Closed Kinds
The main change in the pre-closed kinds appears in the
pre-closed meaning function constructor (‘J_K).
‘Set : SetForm ℓ
‘J_K : Level.SetForm ℓ→SetForm ℓ
The indexed closed meaning function constructor takes ‘Set[ ℓ] as an argument
and returns a ‘Set[ suc ℓ]. In this parameterized version of the constructor, we
cannot return a SetForm ℓ, because the parameter ℓmust remain constant for
all constructors. However, we can make the argument to the constructor be a
pre-closed type from the previous universe, by projecting SetForm out of our Level
record parameter ℓ. Hence, the argument in the indexed and parameterized version
of the meaning function constructor (‘J_K) both represent a closed type from the
previous universe, just in diﬀerent ways.
Meaning of Pre-Closed Leveled Types
Now let’s deﬁne the meaning function
for pre-closed types parameterized by the previous universe.
J_/_K : (ℓ: Level) →SetForm ℓ→Set
The only diﬀerence in the syntax of the type signature is that we use a slash
(/), instead of a pipe (|), to distinguish the abstract Level version of the meaning
function (J_/_K) from the natural number version (J_|_K).
Meaning of Pre-Closed Types
The meaning of pre-closed types using abstract
levels is syntactically identical to the natural number version, besides replacing
pipes with slashes.
J ℓ/ ‘⊥K = ⊥
J ℓ/ ‘⊤K = ⊤

218
J ℓ/ ‘Bool K = Bool
J ℓ/ ‘Σ A B K = Σ J ℓ/ A K (ń a →J ℓ/ B a K)
J ℓ/ ‘Π A B K = (a : J ℓ/ A K) →J ℓ/ B a K
J ℓ/ ‘W A B K = W J ℓ/ A K (ń a →J ℓ/ B a K)
J ℓ/ ‘Id A x y K = Id J ℓ/ A K x y
Meaning of Pre-Closed Kinds
The meaning of pre-closed kinds is interpreted
by projecting the ﬁeld in the Level record ℓassociated with the pre-closed kind
being interpreted.
J ℓ/ ‘Set K = Level.SetForm ℓ
J ℓ/ ‘J A K K = Level.J ℓ/ A K
The meaning of a pre-closed type (‘Set) is a pre-closed type (SetForm) from
the previous universe (ℓ). The meaning of the pre-closed meaning function is the
meaning function (J_/_K) from the previous universe (ℓ).
Passing Positivity Check
In the deﬁnition of SetForm, the codomain of the B
argument of the ‘Σ, ‘Π, and ‘W constructors is still an application of the meaning
function (J_/_K). However, now the meaning of ‘Set of is an abstract Set from
the Level record parameter ℓ, whose ﬁeld we happened to call SetForm. This name
simply documents that we plan to instantiate the ﬁeld with a SetForm of the pre-
vious universe, in the second stage of our indexed universe hierarchy construction.
From the point of view of the deﬁnition of SetForm, SetForm contains an arbitrary
Set, so positivity is not violated when checking the inﬁnitary B argument.
Derived Indexed Hierarchy of Universes
Now we derive closed leveled types
(‘Set[_]), indexed by the natural numbers, from pre-closed leveled types (SetForm),
parameterized by levels (Level).
For each natural number, we need to apply SetForm to a closed Level encoding
the previous universe in the hierarchy that the natural numbers represent. To do

219
so, we deﬁne the level function that maps each natural number, representing the
current universe, to a Level, encoding the previous universe.
level : (ℓ: N) →Level
If the universe level is 0, then there is no previous universe. Hence, we deﬁne
the previous closed types (SetForm) to be uninhabited (i.e., the bottom type ⊥).
The meaning function J_/_K for these previous closed types is also uninhabited,
as indicated by a λ term matching against its empty argument (empty parenthe-
ses, in an argument position, is Agda syntax for matching against a value of an
uninhabited type).
level zero = record
{ SetForm = ⊥
; J_/_K = ń()
}
If the universe level is the successor of some natural number, then the previous
closed types (SetForm) are the pre-closed types (SetForm), whose parameter is
instantiated with level applied to the predecessor of the input natural number.
The previous closed meaning function (J_/_K) is deﬁned by the previous pre-closed
meaning function (J_/_K) in the same fashion.
level (suc ℓ) = record
{ SetForm = SetForm (level ℓ)
; J_/_K = J_/_K (level ℓ)
}
Thus, we inductively deﬁne closed universe Levels, for any natural number, by
applying pre-closed constructions to previous closed levels, and deﬁning the zeroth
level to be uninhabited.
Finally, we derive (indexed) closed leveled types (and their meaning functions)
by composing pre-closed types (and their meaning functions) with level.
‘Set[_] : N →Set

220
‘Set[ ℓ] = SetForm (level ℓ)
J_|_K : (ℓ: N) →‘Set[ ℓ] →Set
J ℓ| A K = J level ℓ/ A K
The indexed leveled types are derived from the parameterized pre-closed types,
because the pre-closed types are used to deﬁne level.
8.2
CLOSED HIERARCHY OF INDUCTIVE-RECURSIVE TYPES
In Section 8.1, we extend the Closed Well-Order Types universe of Section 4.2.1
to a Closed Hierarchy of Well-Order Universes. In this section, we extend the
Closed Inductive-Recursive Types universe of Section 6.2 to a Closed Hierarchy of
Inductive-Recursive Universes. We deﬁne the Agda model of the hierarchy (as in
Section 8.1.3), skipping the formal model (as in Section 8.1.1).
8.2.1
Agda Model
Now we deﬁne an Agda model of a Closed Hierarchy of Inductive-Recursive Uni-
verses. Just like the Agda model of the Closed Hierarchy of Well-Order Universes
in Section 8.1.3, we derive closed leveled types and their meaning from closed level
universes, deﬁned in terms of pre-closed constructions parameterized by Level.
Recall (from Section 6.2) that the Closed Inductive-Recursive Types universe
is mutually deﬁned by closed types (‘Set), closed descriptions (‘Desc), and their
respective closed meaning functions (J_K and «_»). Similarly, the Closed Hierarchy
of Inductive-Recursive Universes is mutually deﬁned by pre-closed leveled types
(SetForm), pre-closed leveled descriptions (DescForm), and their respective pre-
closed leveled meaning functions (J_/_K and «_/_»).
Abstract Universe Levels
Once again, we deﬁne a dependent record (Level)
as the abstract notion of the previous universe to be used as the parameter of

221
SetForm and DescForm.
record Level : Set1 where
ﬁeld
SetForm : Set
J_/_K : (A : SetForm) →Set
As before (in Section 8.1.3), the SetForm ﬁeld represents the closed types of the
previous universe, and the J_/_K ﬁeld is their meaning function. Now we require
three additional ﬁelds.
DescForm : (O : SetForm) →Set
J_/_K1 : {O : SetForm} (D R : DescForm O) →Set
µ1’ : (O : SetForm) (D : DescForm O) →Set
The DescForm represents the closed descriptions of the previous universe. The
µ1’ ﬁeld represents the type component of the ﬁxpoint operator of closed descrip-
tions from the previous universe. Recall (from Section 5.4.2) that the type compo-
nent of ﬁxpoints (µ1) is deﬁned in terms of the type component of the interpretation
function for descriptions (J_K1). The J_/_K1 ﬁeld represents the type component
of the interpretation function for closed descriptions of the previous universe.
Three Versions of Fixpoints
We now take a brief intermission to warn the
reader that there are three versions of closed ﬁxpoints in this closed leveled universe
construction. We explain why all three are necessary as this chapter unfolds, but
for now just recognize that they are distinct (watch out for backtick preﬁxes and
prime preﬁxes in the names of the three closed ﬁxpoints):
1. ‘µ1 This is a constructor of SetForm, and represents the ﬁxpoint of descrip-
tions in the current universe.
2. µ1’ This is a record ﬁeld of Level, and represents the abstract version of the
ﬁxpoint of descriptions in the previous universe.

222
3. ‘µ1’ This is a constructor of SetForm, and represents the concrete version
of the ﬁxpoint of descriptions in the previous universe. Hence, ‘µ1’ is the
concrete version of µ1’.
Recall that there is also µ1, the open ﬁxpoint operator of Section 5.4.2. We
now return you to your regularly scheduled generic programming.
Pre-Closed Leveled Types
Below we give the type former of pre-closed leveled
types, this time parameterized by our Level record containing description compo-
nents, in addition to type components, from the previous universe.
data SetForm (ℓ: Level) : Set where
Pre-Closed Types
The pre-closed types are no diﬀerent from the well-order
hierarchy of Section 8.1.3. The only exception is that we exchange the well-order
constructor (‘W) for the ﬁxpoint constructor (‘µ1).
‘⊥‘⊤‘Bool : SetForm ℓ
‘Σ ‘Π : (A : SetForm ℓ) (B : J ℓ/ A K →SetForm ℓ) →SetForm ℓ
‘Id : (A : SetForm ℓ) (x y : J ℓ/ A K) →SetForm ℓ
‘µ1 : (O : SetForm ℓ) (D : DescForm ℓO) →SetForm ℓ
Notice that the D argument of ‘µ1 is a mutually deﬁned DescForm, in the same
universe level (ℓ) as our current SetForm. This is a natural generalization of ‘µ1
from the closed universe in Section 6.2, which which takes a ‘Desc and constructs
a ‘Set.
Pre-Closed Kinds
The pre-closed kind of types (‘Set) and their meaning func-
tion (‘J_K) are no diﬀerent from the well-order hierarchy of Section 8.1.3.
‘Set : SetForm ℓ
‘J_K : Level.SetForm ℓ→SetForm ℓ
‘Desc : Level.SetForm ℓ→SetForm ℓ

223
‘J_K1 : {O : Level.SetForm ℓ} (D R : Level.DescForm ℓO) →SetForm ℓ
‘µ1’ : (O : Level.SetForm ℓ) (D : Level.DescForm ℓO) →SetForm ℓ
We now add the pre-closed kind of descriptions (‘Desc), and pre-closed kinds
for the interpretation (‘J_K1) and ﬁxpoint (‘µ1’) of descriptions. Recall that the
pre-closed meaning function of types (‘J_K) can also be considered a function that
lifts a type from the previous universe to the current universe.
Similarly, the
interpretation (‘J_K1) and ﬁxpoint (‘µ1’) of descriptions both lift a description
from the previous universe to the current universe.
Finally, we highlight the diﬀerence between the pre-closed ﬁxpoint (‘µ1), taking
a DescForm of the current universe, and the pre-closed lifting ﬁxpoint (‘µ1’, notice
the “prime” suﬃx), taking a DescForm from the previous universe. The former is
used to construct algebraic types (like the natural numbers) in the zeroth universe
or higher, while the latter is used to construct algebraic kinds (like heterogenous
lists) in the ﬁrst universe or higher.
If we use ‘Π to quantify over a ‘Set, then the domain (A) of the dependent
argument (B) will be the meaning of ‘Set, which is a TypeForm of the previous
universe. Thus, if we want to use A in the type of B, we must lift it to the current
universe with ‘J_K. Similarly, if we use ‘Π to quantify over ‘Desc, then we can
use the argument A in the type of B by lifting A (a DescForm) from the previous
universe to the current universe via ‘J_K1 or ‘µ1’. Distinctively, we could not apply
‘µ1 to A, because ‘µ1 expects a DescForm from the current universe, not a DescForm
from the previous universe.
Meaning of Pre-Closed Leveled Types
Let’s deﬁne the meaning function for
pre-closed leveled types, having the signature below.
J_/_K : (ℓ: Level) →SetForm ℓ→Set

224
Meaning of Pre-Closed Types
The meaning of pre-closed types is no diﬀerent
from the well-order hierarchy version (Section 8.1.3), except we replace the ‘W case
with the ‘µ1 case.
J ℓ/ ‘⊥K = ⊥
J ℓ/ ‘⊤K = ⊤
J ℓ/ ‘Bool K = Bool
J ℓ/ ‘Σ A B K = Σ J ℓ/ A K (ń a →J ℓ/ B a K)
J ℓ/ ‘Π A B K = (a : J ℓ/ A K) →J ℓ/ B a K
J ℓ/ ‘Id A x y K = Id J ℓ/ A K x y
J ℓ/ ‘µ1 O D K = µ1 J ℓ/ O K « ℓ/ D »
In the ﬁxpoint case (‘µ1), we compute the meaning of the description argument
(D) using the mutually deﬁned meaning of leveled pre-closed descriptions («_/_»).
Meaning of Pre-Closed Kinds
The meaning of each pre-closed kind code is
deﬁned using its corresponding Level ﬁeld, using the previous universe level ℓ.
J ℓ/ ‘Set K = Level.SetForm ℓ
J ℓ/ ‘J A K K = Level.J ℓ/ A K
J ℓ/ ‘Desc O K = Level.DescForm ℓO
J ℓ/ ‘J D K1 R K = Level.J ℓ/ D K1 R
J ℓ/ ‘µ1’ O D K = Level.µ1’ ℓO D
Note that the arguments of each pre-closed kind code have exactly the types
expected by the Level ﬁelds, so meaning translations (via J_/_K or «_/_») are
unnecessary.
Pre-Closed Leveled Descriptions
Let’s deﬁne the meaning function for pre-
closed leveled descriptions, having the signature below.
data DescForm (ℓ: Level) (O : SetForm ℓ) : Set where
Note that pre-closed leveled descriptions are parameterized by O, a pre-closed
type (SetForm) at the same level (ℓ) as the current pre-closed description (DescForm),

225
encoding the codomain of the decoding function for this inductive-recursive de-
scription.
Pre-Closed Descriptions
The leveled pre-closed description constructors are
just like the closed descriptions of Section 6.2.
The only diﬀerence is that we
replace closed constructions (‘Desc, ‘Set, and J_K) with their pre-closed leveled
counterparts (DescForm, SetForm, and J_/_K), at level ℓ.
‘Ì : (o : J ℓ/ O K) →DescForm ℓO
‘σ : (A : SetForm ℓ) (D : J ℓ/ A K →DescForm ℓO) →DescForm ℓO
‘δ : (A : SetForm ℓ) (D : (o : J ℓ/ A K →J ℓ/ O K) →DescForm ℓO)
→DescForm ℓO
Meaning of Pre-Closed Leveled Descriptions
Let’s deﬁne the meaning func-
tion for pre-closed leveled descriptions, having the signature below.
«_/_» : (ℓ: Level) {O : SetForm ℓ} →DescForm ℓO →Desc J ℓ/ O K
Meaning of Pre-Closed Descriptions
The meaning of leveled pre-closed de-
scriptions is also just like the meaning of closed descriptions in Section 6.2. This
time we replace closed meaning functions (J_K and «_») with their pre-closed lev-
eled counterparts (J_/_K and «_/_»), at level ℓ.
« ℓ/ ‘Ì o » = Ì o
« ℓ/ ‘σ A D » = σ J ℓ/ A K (ń a →« ℓ/ D a »)
« ℓ/ ‘δ A D » = δ J ℓ/ A K (ń o →« ℓ/ D o »)
Derived Indexed Hierarchy of Universes
Now that we’ve deﬁned pre-closed
leveled types and descriptions, parameterized by levels (Level), we can derive closed
leveled types and descriptions, indexed by natural numbers (as a computational
family). First, we deﬁne level to map each natural number to a Level representing

226
the previous universe (i.e., a natural number n is mapped to universe n-1).
level : (ℓ: N) →Level
At level 0, there is no previous universe. Thus, ﬁeld SetForm is bottom, ﬁeld De-
scForm is a constant function returning bottom, and the meaning functions match
against their uninhabited arguments (signiﬁed in Agda by empty parentheses in
the argument position).
level zero = record
{ SetForm = ⊥
; J_/_K = ń()
; DescForm = ń O →⊥
; J_/_K1 = ń ()
; µ1’ = ń ()
}
If the universe level is the successor of some natural number, then the previous
closed type and description ﬁelds (SetForm and DescForm) are the pre-closed types
and descriptions (SetForm and DataForm), whose parameters are instantiated with
level applied to the predecessor of the input natural number. The previous closed
meaning function for types ﬁeld (J_/_K) is deﬁned by the previous pre-closed
meaning function for types (J_/_K) in the same fashion.
level (suc ℓ) = record
{ SetForm = SetForm (level ℓ)
; J_/_K = J_/_K (level ℓ)
; DescForm = DescForm (level ℓ)
; J_/_K1 = ń D R →J « level ℓ/ D » K1 « level ℓ/ R »
; µ1’ = ń O D →µ1 J level ℓ/ O K « level ℓ/ D »
}
The closed description interpretation and ﬁxpoint ﬁelds (J_/_K1 and µ1’) are
deﬁned using the open description interpretation function and ﬁxpoint (J_K1 and
µ1) from Appendix B.

227
The open description interpretation function (J_K1) expects open description
arguments, but the ﬁeld J_/_K1 has leveled closed description arguments (D and
R). Thus, we translate the leveled closed descriptions (D and R) using the leveled
description meaning function («_/_») at the predecessor level (ℓ).
Similarly, the open description ﬁxpoint (µ1) expects an open type and an open
description, but the ﬁeld µ1’ has a leveled closed type argument (O) and a leveled
closed description argument (D). The closed type (O) is translated using the leveled
type meaning function (J_/_K), and the closed description (D) is translated using
the leveled description meaning function («_/_»). Both of the leveled meaning
functions are translated at the predecessor level (ℓ).
Finally, we can derive indexed closed leveled types (‘Set[_]) from parameterized
pre-closed leveled types (SetForm), by instantiating the parameter with the result
of applying level to the input natural number index, as in Section 8.1.3. The leveled
closed type meaning function (J_|_K) is also derived from the pre-closed version
(J_/_K), as in Section 8.1.3.
‘Set[_] : N →Set
‘Set[ ℓ] = SetForm (level ℓ)
J_|_K : (ℓ: N) →‘Set[ ℓ] →Set
J ℓ| A K = J level ℓ/ A K
Now, we additionally derive the indexed closed leveled descriptions (‘Desc[_])
from parameterized pre-closed leveled descriptions (DescForm), also by instantiat-
ing the parameter with the result of applying level to the input index. The leveled
closed description meaning function («_|_») is derived from the pre-closed version
(«_/_») in the same way.
‘Desc[_] : (ℓ: N) →‘Set[ ℓ] →Set
‘Desc[ ℓ] O = DescForm (level ℓ) O
«_|_» : (ℓ: N) {O : ‘Set[ ℓ]} →‘Desc[ ℓ] O →Desc J ℓ| O K

228
« ℓ| D » = « level ℓ/ D »
8.2.2
Examples
The Closed Inductive-Recursive Types universe examples in Section 6.2.2 corre-
spond to examples that we can demonstrate in the zeroth universe of our hier-
archy. The Closed Inductive-Recursive Types universe does not include the kinds
‘Set and ‘Desc, hence all of the signatures (e.g., NatDs, ‘N, etc.) used to construct
the examples were deﬁned externally to the universe (using types from our Agda
metalanguage, like the function space).
We can port all of the examples in Section 6.2.2 to the zeroth universe of
our hierarchy by patching them using the table below. For each deﬁnition (in its
signature and body), replace occurrences of the left table column with the right
table column.
Closed Types Universe
Universe 0 in Hierarchy
‘Set
‘Set[ 0 ]
‘Desc
‘Desc[ 0 ]
J A K
J 0 | A K
« D »
« 0 | D »
However, we can also choose to internalize the signatures used in the examples,
as we see below. By “internalize” we mean that each signature can be represented
as the leveled type meaning (J_|_K), of some closed type, at some level in our
hierarchy.
Natural Numbers
Let’s internalize the signatures used in the natural number
examples. The deﬁnition bodies remain the same as those in Section 6.2.2, so we
only present the signatures below. First, we internalize the signatures of the closed

229
description and type kinds (i.e., at universe level 1).
NatDs : J 1 | ‘Bool ‘→‘Desc ‘⊤K
NatD : J 1 | ‘Desc ‘⊤K
‘N : J 1 | ‘Set K
Crucially, internalizing the kinds above relies on having codes for closed types
(‘Set) and closed descriptions (‘Desc). If an internalized signature needs to refer to
a type, it must refer to the internalized “backtick” version of the type. Because we
can internalize all signatures, we no longer need to deﬁne non-backtick versions of
types (e.g., N). We can always recover a non-backtick version of a type by applying
the meaning function (J_|_K) to the backtick version, at the appropriate level.
zero : J 0 | ‘N K
suc : J 0 | ‘N ‘→‘N K
Above, we internalize the value (i.e., typed at universe level 0) constructors of
the natural numbers.
Vectors
Now, let’s internalize the kinds used to derive indexed vectors from
inductive-recursive vectors.
VecDs : J 1 | ‘Set ‘→‘Bool ‘→‘Desc ‘N K
VecD : J 1 | ‘Set ‘→‘Desc ‘N K
‘Vec1 : J 1 | ‘Set ‘→‘Set K
‘Vec2 : J 1 | ‘Π ‘Set (ń A →‘J ‘Vec1 A K ‘→‘J ‘N K) K
‘Vec : J 1 | ‘Set ‘→‘J ‘N K ‘→‘Set K
Notice that the decoding function (‘Vec2) quantiﬁes over the kind ‘Set, binding
variable A. The bound variable A is a type, the inhabitant of the kind ‘Set. Hence,
in order to ask for argument of ‘Vec1 applied to A, we must ﬁrst lift this type to
the kind level (using ‘J_K). Also recall that ‘N is deﬁned to be a type. Hence, when
asking for a natural number argument, in kind signatures of ‘Vec2 and ‘Vec, we

230
also lift the ‘N type to the kind level (using ‘J_K).
nil : J 1 | ‘Π ‘Set (ń A →‘J ‘Vec A zero K) K
cons : J 1 | ‘Π ‘Set (ń A →‘Π ‘J ‘N K (ń n →
‘J A K ‘→‘J ‘Vec A n K ‘→‘J ‘Vec A (suc n) K)) K
Above, we internalize the value constructors of the vectors. Even though the
signatures of nil and cons are kinds (at universe level 1), their codomains return
lifted (using ‘J_K) vector types (at universe level 0). For similar reasons, the natural
number argument of cons is actually a value of type ‘N, which has merely been
lifted to the kind level to ﬁt in the signature of cons.
To determine what level an argument or codomain lives at, substract the num-
ber of liftings (i.e., nested occurrences of ‘J_K) from the level of the signature (i.e.,
the number to the left of the pipe in the meaning function). For example, the
codomain of nil is 1 minus 1 lifting, thus nil returns a value of type (i.e., universe
level 0) ‘Vec, even though its signature is kinded (i.e., at universe level 1).
Finally, note that both nil and cons have explicit type arguments, and cons
also has an explicit natural number argument. To change these to be implicit
arguments, we would need to update our universe to include an implicit version of
the ‘Π code (this is easy to to do).
Heterogenous Lists
Previously, we deﬁned types, like the natural numbers,
whose signatures were kinds (at universe level 1). Now, we give an example of
deﬁning a kind, the heterogenous lists, whose signature is a superkind (at universe
level 2).
Deﬁning the kind of heterogenous lists is not possible in the Closed
Inductive-Recursive Types universe of Section 6.2, which only supports types. First,
let’s review the kind of heterogenous lists.
data HList : Set1 where
nil : HList

231
cons : (A : Set) →A →HList →HList
The signatures of the closed description and closed type, used to deﬁne het-
erogenous lists, are superkinded at universe level 2.
HListDs : J 2 | ‘Bool ‘→‘Desc ‘⊤K
HListDs true = ‘Ì tt
HListDs false =
‘σ ‘Set ń A →
‘σ ‘J A K ń a →
‘δ ‘⊤ń xs →
‘Ì tt
HListD : J 2 | ‘Desc ‘⊤K
HListD = ‘σ ‘Bool HListDs
‘HList : J 2 | ‘Set K
‘HList = ‘µ1 ‘⊤HListD
Notice that the description of the ﬁrst argument of the cons constructor (the
false case of HListDs) takes a type as an argument (‘Set), and the second argument
takes a value of the lifting of that type. We can also see that ‘HList is a closed
kind, because it is classiﬁed as a ‘Set at universe level 2. The meaning of ‘Set at
universe level 2 is the SetForm of the previous universe level, or Set[ 1 ]. Hence,
closed ‘HList is classiﬁed as a closed kind (Set[ 1 ]), just like open HList is classiﬁed
as an open kind (Set1).
nil : J 1 | ‘HList K
nil = init (true , tt)
cons : J 1 | ‘Π ‘Set (ń A →‘J A K ‘→‘HList ‘→‘HList) K
cons A a xs = init (false , A , a , (ń u →xs) , tt)
Above, we deﬁne the kind (i.e., universe level 1) constructors of the heteroge-
nous lists. We know that nil and cons construct kinds, because their codomains do
not have any liftings (i.e., occurrences of ‘J_K), so 1 - 0 leaves the codomains at

232
universe level 1, the level of kinds.
Identity Function
In Section 8.1.2, we demonstrate internalizing the signature
of the identify function in level 0 of the Closed Hierarchy of Well-Order Universes.
We can still do this in our Closed Hierarchy of Inductive-Recursive Universes, as
the internalized type below demonstrates.
id : J 1 | ‘Π ‘Set (ń A →‘Π ‘J A K (ń a →‘J A K)) K
id A a = a
For reference, we also present the external type signature that the meaning of
our internal type above expands to.
id : (A : ‘Set[ 0 ]) (a : J 0 | A K) →J 0 | A K
id A a = a
Dependent Pair
As a sanity check for the construction of our Closed Hierarchy
of Inductive-Recursive Universes (Section 8.2.1), we should be able to internalize
each signature (whether it be a type or kind) of every constructor of every datatype
in the universe. This sanity check can be found in Appendix E.
As one illustrative example, we show how to internalize the pair constructor of
dependent pairs. In open type theory (Appendix B), the pair constructor has the
following type.
_,_ : {A : Set} {B : A →Set} (a : A) →B a →Σ A B
Below, we deﬁne pair’ to be pair constructor init, while internalizing the kind
signature of _,_.
pair’ : J 1 | ‘Π ‘Set (ń A →‘Π (‘J A K ‘→‘Set) (ń B →
‘Π ‘J A K (ń a →‘Π ‘J B a K (ń b →
‘Σ ‘J A K (ń a →‘J B a K))))) K
pair’ A B a b = a , b
Internalizing the kind of the pair constructor (,) as pair’ takes advantage of being

233
able to quantify over closed types (‘Set), and the closed type meaning function
(‘J_K), used to lift types to the kind level. Really, it is just a slightly more involved
example of internalizing the signature of the identity function (id).
Note that we must use explicit function arguments for A and B, as our universe
does not currently support an implicit version of dependent functions (‘Π). For
reference, we also present the external type signature that the meaning of our
internal type above expands to.
pair’ : (A : ‘Set[ 0 ]) (B : J 0 | A K →‘Set[ 0 ])
(a : J 0 | A K) (b : J 0 | B a K)
→Σ J 0 | A K (ń a →J 0 | B a K)
pair’ A B a b = a , b
Initial Algebra
As our ﬁnal example, we internalize the signature of the initial
algebra constructor (init) of ﬁxpoints. The internalization of the signature for init
is unique, as it quantiﬁes over the closed kind of descriptions (‘Desc), and must
be deﬁned with description-lifting operations. First, review the type of the init
constructor in open type theory (Appendix B).
init : {O : Set} {D : Desc O} →J D K1 D →µ1 O D
Below, we deﬁne init’ to be init, while internalizing the kind signature of init.
init’ : J 1 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →
‘J D K1 D ‘→‘µ1’ O D)) K
init’ O D xs = init xs
We internalize the D argument by quantifying over a closed description (‘Desc).
Because D is a description from the previous universe, the subsequent argument
uses the lifting description interpretation function (‘J_K1). Similarly, the codomain
uses the lifting ﬁxpoint constructor (‘µ1’). Importantly, the codomain of init is
internalized with the prime-variant of closed ﬁxpoint constructor (‘µ1’), deﬁned
over descriptions of the previous universe, not the non-prime ﬁxpoint constructor

234
(‘µ1), deﬁned over descriptions of the current universe.
It is not obvious that the deﬁnition of our hierarchy needs ﬁxpoints of descrip-
tions in the current (‘µ1) and previous (‘µ1’) universes. It is also not obvious that
the hierarchy needs to internalize the description interpretation function (‘J_K1),
for descriptions of the previous universe. However, our sanity check, in Appendix E,
exposes that both ‘µ1’ and ‘J_K1 are necessary to internalize the kind signature of
the init constructor. For reference, we also present the external type signature that
the meaning of our internal type above expands to.
init’ : (O : ‘Set[ 0 ]) (D : ‘Desc[ 0 ] O)
→J « 0 | D » K1 « 0 | D » →µ1 J 0 | O K « 0 | D »
init’ O D xs = init xs
Lifting Functions
We conclude this section by reﬂecting upon the internaliza-
tion of the kind signatures for the pair (_,_) and initial algebra (init) constructors
(as pair’ and init’), in the examples above.
The former is evidence that we need to quantify over the kind of closed types
(‘Set), and then lift the quantiﬁer to the kind level using the closed meaning
function of types (‘J_K).
The latter is evidence that we need to quantify over the kind of closed de-
scriptions (‘Desc), and then lift the quantiﬁer to the kind level using the closed
interpretation function (‘J_K1) of descriptions, and the (lifting) closed ﬁxpoint op-
erator (‘µ1’) of descriptions.
Hence, our sanity check in Appendix E, that the signature of all datatype
constructors can be internalized in our closed universe hierarchy, drives the need
for quantiﬁcation over closed kinds (‘Set and ‘Desc). In turn, quantiﬁcation over
closed kinds drives results in types (i.e., the previous universe), which drives the
need for lifting functions appropriate to each kind (‘J_K, ‘J_K1, and ‘µ1’). Thus,
we recognize the sanity check in Appendix E as a good way to measure whether

235
we have appropriately closed our hierarchy, and are grateful for the structure that
the check provides to the deﬁnition of our hierarchy.
As one ﬁnal note, we emphasize that it is not enough that we can exhibit kind
signatures for every datatype constructors. It is also important that the meaning
of our closed kind signatures reduce to exactly the signatures expected by the
underlying Agda constructors of our open type theory model.
8.3
LEVELED FULLY GENERIC FUNCTIONS
Chapter 7 demonstrates writing fully generic functions (like count, lookup and ast)
over all values of the Closed Inductive-Recursive Types universe (of Section 6.2). In
this section, we show how to write leveled fully generic functions, or fully generic
functions at any level of the Closed Hierarchy of Inductive-Recursive Universes (of
Section 8.2).
In Section 8.3.1, we patch fully generic count (of Section 7.1.2), converting
it to work in level 0 of our hierarchy, over all values of types. Subsequently, in
Section 8.3.2, we deﬁne fully generic Count in level 1 of our hierarchy, over all types
of kinds. As we shall see, the Count function at level 1 must be deﬁned in terms
of the count function at level 0, because the values of level 0 are lifted to the type
level 1, which can be expected because our universes form a hierarchy.
We only patch count to work at level 0 (and extend it to work at level 1), but
other fully generic functions (like lookup and ast) can be similarly deﬁned as leveled
fully generic functions. Leveling a function primarily involves 2 things:
1. The type of the fully generic function must be internalized as a kind (i.e., we
move from level 0, to the subsequent level, 1).
2. Additional cases must be handled, for the closed kinds ‘Set and ‘Desc, and
their associated lifting functions (‘J_K, ‘J_K1, and ‘µ1’).

236
one : J 0 | ‘N K
one = suc zero
two : J 0 | ‘N K
two = suc one
_+_ : J 0 | ‘N ‘→‘N ‘→‘N K
init (true , tt) + m = m
init (false , n , tt) + m = n tt + m
Figure 8.1: Closed natural number deﬁnitions in universe level 0.
8.3.1
Counting in Universe Zero
Step 1 of patching the count function (deﬁned over all values in Section 7.1.2),
and the mutually deﬁned counts function (deﬁned over all algebraic arguments
in Section 7.1.3), to be deﬁned in level 0 of our hierarchy, is internalizing their
signatures, as follows.
count : J 1 | ‘Π ‘Set (ń A →‘J A K ‘→‘J ‘N K) K
counts : J 1 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →‘Π (‘Desc O) (ń R →
‘J D K1 R ‘→‘J ‘N K))) K
Because count and counts quantify over kinds (‘Set and ‘Desc, respectively),
they have internalized kind signatures (universe level 1). However, the A argument
of count, and the returned natural number (‘N) codomain are types, because they
are lifted using ‘J_K. Similarly, ‘J_K1 is used to lift the last argument of counts
from the type level to the kind level. Hence, count and counts operate on values,
classiﬁed by types, albeit lifted to the kind level in the signatures of count and
counts.
Both count and counts now return internalized natural numbers (‘N), hence we
must patch the body of count from Section 7.1.2 and counts from Section 7.1.3,
according to the table below. The left column of the table contains values external

237
count : J 1 | ‘Π ‘Set (ń A →‘J A K ‘→‘J ‘N K) K
count (‘Σ A B) (a , b) = one + count A a + count (B a) b
count (‘µ1 O D) (init xs) = one + counts O D D xs
count ‘Set ()
count (‘Desc ()) ()
count (‘J () K) a
count (‘J () K1 ()) xs
count (‘µ1’ () ()) x
count A a = one
counts : J 1 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →‘Π (‘Desc O) (ń R →
‘J D K1 R ‘→‘J ‘N K))) K
counts O (‘σ A D) R (a , xs) = count A a + counts O (D a) R xs
counts O (‘δ ‘⊤D) R (f , xs) = count (‘µ1 O R) (f tt) +
counts O (D (‘µ2 R ◦f)) R xs
counts O (‘δ A D) R (f , xs) = one + counts O (D (‘µ2 R ◦f)) R xs
counts O (‘Ì o) R tt = one
Figure 8.2: Fully generic counting of values (count) and algebraic arguments
(counts) in universe level 0.
to our closed hierarchical type theory, and the right side contains their internal
equivalents.3
Closed Types Universe
Universe 0 in Hierarchy
1 : N
one : J 0 | ‘N K
+ : N →N →N
+ : J 0 | ‘N ‘→‘N ‘→‘N K
The deﬁnitions of count and counts in universe level 0, which are the result
of patching their equivalents in Section 7.1.2 and Section 7.1.3, are in Figure 8.2.
Recall that step 2 of the patching process is to handle cases for the closed kinds
3 We use the closed deﬁnition of natural numbers at level 0 from Section 8.2.2, and the closed
deﬁnitions of one and +, appearing in the right column of the table, are deﬁned in Figure 8.1.

238
(‘Set and ‘Desc), and their lifting functions (‘J_K, ‘J_K1, and ‘µ1’), in the deﬁnition
of count.
In Figure 8.2, the ﬁrst argument of count is ‘Set, and the second argument is
its meaning (or lifting). However, at universe level 0 the meaning of ‘Set is ⊥,
so the second argument is empty parentheses, which is Agda syntax for matching
against an uninhabited argument. This makes sense intuitively because count at
level 0 is deﬁned over values, hence we do not need to deﬁne a case for counting
types (inhabitants of ‘Set). The same is true for the ‘Desc case. Finally, each lifting
function constructor (‘J_K, ‘J_K1, and ‘µ1’) takes a closed type or description as
one of its arguments. Because we know that closed types and descriptions are not
inhabited at universe level 0, we also do not need to deﬁne cases for the lifting
functions.
8.3.2
Counting in Universe One
Previously (Section 8.3.1), we deﬁned count and counts to count the inhabitants
of universe level 0 in our closed hierarchy. Now, we deﬁne fully generic functions
to count the inhabitants of universe level 1 in our closed hierarchy.
Counting Values
Even though we think of level 1 as the level of types, there
are copies of type constructors (like dependent pairs, or ‘Σ) at every level of our
hierarchy, whose values we must be able to count. Thus, we mutually deﬁne (in
Figure 8.3) Count for values at level 1, and Counts for algebraic arguments at level
1. Notice the capitalization of Count and Counts, indicating that they are the
universe level 1 equivalents of count and counts (from universe level 0).
Count : J 2 | ‘Π ‘Set (ń A →‘J A K ‘→‘J ‘J ‘N K K) K
Counts : J 2 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →‘Π (‘Desc O) (ń R →
‘J D K1 R ‘→‘J ‘J ‘N K K))) K
Notice that because the internalized superkind signatures of Count and Counts

239
Count : J 2 | ‘Π ‘Set (ń A →‘J A K ‘→‘J ‘J ‘N K K) K
Count (‘Σ A B) (a , b) = one + Count A a + Count (B a) b
Count (‘µ1 O D) (init xs) = one + Counts O D D xs
Count ‘Set A = CountSet A
Count (‘Desc O) D = CountDesc O D
Count (‘J A K) a = count A a
Count (‘J D K1 R) xs = counts _ D R xs
Count (‘µ1’ O D) (init xs) = one + counts O D D xs
Count A a = one
Counts : J 2 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →‘Π (‘Desc O) (ń R →
‘J D K1 R ‘→‘J ‘J ‘N K K))) K
Counts O (‘σ A D) R (a , xs) = Count A a + Counts O (D a) R xs
Counts O (‘δ ‘⊤D) R (f , xs) = Count (‘µ1 O R) (f tt) +
Counts O (D (‘µ2 R ◦f)) R xs
Counts O (‘δ A D) R (f , xs) = one + Counts O (D (‘µ2 R ◦f)) R xs
Counts O (‘Ì o) R tt = one
Figure 8.3: Fully generic counting of values (Count) and algebraic arguments
(Counts) in universe level 1.
are at level 2, we must lift the return type of natural numbers twice (because ‘N is
deﬁned in level 0). However, the A argument must only be lifted once, which lifts
the quantiﬁed kind (‘Set at level 1) to level 2 (the level of the superkind signature).
Recall (from Section 6.2) that the lifting constructor ‘J_K is deﬁned at every level
of our universe hierarchy (so is ‘Σ), but ‘N is only deﬁned at level 0.
The deﬁnitions of Count and Counts are in Figure 8.3. All cases are the same as
the level 0 count and counts variants of Figure 8.2, except for the kind (‘Desc and
‘Desc) and lifting (‘J_K, ‘J_K1, and ‘µ1’) cases. In the lifting cases, the inhabitant
argument comes from the previous universe, so we count the lifted inhabitants
using level 0 functions (count and counts). For the kind cases (‘Set and ‘Desc),
the inhabitants are closed types and descriptions. Hence, we must additionally

240
mutually deﬁne (in Figure 8.4) CountSet to count types and CountDesc to count
descriptions.
CountSet : J 1 | ‘Set ‘→‘J ‘N K K
CountSet (‘Σ A B) = two + CountSet A
CountSet (‘Π A B) = two + CountSet A
CountSet (‘Id A x y) = one + CountSet A + count A x + count A y
CountSet (‘µ1 O D) = one + CountSet O + CountDesc O D
CountSet (‘Desc ())
CountSet (‘J () K)
CountSet (‘J () K1 ())
CountSet (‘µ1’ () ())
CountSet A = one
CountDesc : J 1 | ‘Π ‘Set (ń O →‘Desc O ‘→‘J ‘N K) K
CountDesc O (‘Ì o) = one + count O o
CountDesc O (‘σ A D) = two + CountSet A
CountDesc O (‘δ A D) = two + CountSet A
Figure 8.4: Fully generic counting of types (CountSet) and algebraic arguments
(CountDesc) in universe level 1.
Counting Types and Descriptions
To write fully generic functions at level
1, to count closed types and descriptions, we must internalize their signatures as
follows.
CountSet : J 1 | ‘Set ‘→‘J ‘N K K
CountDesc : J 1 | ‘Π ‘Set (ń O →‘Desc O ‘→‘J ‘N K) K
Notice that CountSet and CountDesc are deﬁned in level 1. This is because they
are applied to the inhabitants of the ‘Set and ‘Desc cases of Count (Figure 8.3).
Because the inhabitants are classiﬁed as the meaning of the closed kind of ‘Set or
‘Desc, the inhabitants live at the previous level. Hence, while Count is deﬁned at
level 2, CountSet and CountDesc are deﬁned at level 1.

241
The deﬁnitions of CountSet and CountDesc are in Figure 8.4.
They count
each type (e.g., ‘Σ) and description (e.g., ‘σ) the same way that count and counts
(Figure 8.2) count values.
For example, the ‘Σ case of CountSet is counted as 2 plus a recursive call for
the A type. We count 1 for the ‘Σ itself, and add another 1 for the dependent
and higher-order B argument, which we treat as a black box (just like we do when
counting functions in Section 7.1.2, or inﬁnitary arguments in Section 7.1.3). For
the same reason, the ‘σ case of CountDesc is counted as 2 plus a recursive call for
the A type. Once again, the dependent and higher-order D argument is treated as
a black box.
Notice that the x and y arguments of the identity type ‘Id are actually values.
Hence, we apply count to them, rather than CountSet. The same is true for o in
the ‘Ì case of CountDesc. Finally, notice that the kind (‘Set and ‘Desc) and lifting
function cases of CountSet are undeﬁned. This is because CountSet counts types at
level 1, so kinds at level 2 are uninhabited. If we deﬁned another version of count
and all the associated function at universe level 3 (of superkinds), then the kind
and liﬁting cases of CountSet at level 3 would call their variants at level 2 (e.g.,
the ‘Set case of CountSet at level 3 would pass its argument to CountSet of level
2).
8.3.3
Leveled Generic Template
In Section 7.3.5, we conclude Chapter 7, on fully generic programming, with a
template for writing fully generic functions over all types (in universe 0).
We
conclude this chapter similarly, but this time we present a generic template for
writing fully generic functions over all types (in universe 1). In other words, we
generalize the signatures of Section 8.3.2, requiring the mutual deﬁnition of 4
functions.
Generic : J 2 | ‘Π ‘Set (ń A →‘J A K ‘→· · · ) K

242
Generics : J 2 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →‘Π (‘Desc O) (ń R →
‘J D K1 R ‘→· · · ))) K
GenericSet : J 1 | ‘Set ‘→· · · K
GenericDesc : J 1 | ‘Π ‘Set (ń O →‘Desc O ‘→· · · ) K
These 4 functions are deﬁned over diﬀerent things, described below, but all
functions inhabit universe level 1.
1. Generic is deﬁned over all values.
2. Generics is deﬁned over all algebraic arguments of the initial algebra.
3. GenericSet is deﬁned over all types.
4. GenericSet is deﬁned over all descriptions.
Recall (from Section 8.3.2) that the types that make up universe 0 are included
in the collection of values of universe 1. Hence, Generic must call GenericSet (in
the ‘Set case), as well as a version of lowercase generic (like count in Section 8.3.1)
of universe 0 (in the ‘J_K case).
The ellipses (· · · ) in the ﬁrst two functions (Generic and Generics) represents
a closed type (‘Set[ 1 ]). The ellipses (· · · ) in the next two functions (GenericSet
and GenericDesc) represents a closed kind (‘Set[ 2 ]). If our leveled fully generic
function has a dependent type, then we would need to deﬁne 8 functions instead
of 4. The additional 4 functions would compute the types of the 4 functions given
above. The additional 4 functions would be applied in the ellipses (· · · ) positions
of the 4 functions given above.

243
Part IV
Postlude

244
Chapter 9
RELATED WORK
The topic of this dissertation falls under the broad practice of generic programming,
but we will only discuss work related to generic programming within dependent
type theory. Namely, intrinsically type-safe generic programming as dependent
functions over some universe, taking a code argument (A : Code) and a subsequent
dependently typed argument, whose type is the meaning of the code (J A K) within
type theory:
generic : (A : Code) (a : J A K) →· · ·
9.1
FIXED OPEN OR CLOSED UNIVERSES
By a ﬁxed universe, we mean a universe that encodes some ﬁxed collection of
type formers, but does not support encoding user-declared datatypes.
Generic
programming over ﬁxed universes, whether they are open (as in Section 2.2.2) or
closed (as in Section 2.2.3), is standard dependently typed programming practice.
File Formats
For example, Oury and Swierstra [49] demonstrate “The Power
of Pi” (or dependently typed programming), by creating a ﬁle Format universe,
and writing fully generic parse and print functions for all ﬁle formats that the
universe encodes. The universe is closed under (among other things) dependent
pair formation (whose code they call Read), as well as a base universe (U) encoding
bits, characters, natural numbers, and even vectors.

245
Even though parse and print are fully generic functions, they are deﬁned over
a ﬁxed universe of types. This makes sense for the problem at hand, where ﬁle
formats should be able to use dependent pairs and vectors to encode the length of
the remaining ﬁle format, after reading a natural number specifying said length. In
their setting, it does not make sense to support arbitrary user-declared types when
deﬁning ﬁle formats. In contrast, our goal is to model an entire closed dependently
typed programming language (as in Section 6.2 or Section 8.2), rather than ﬁle
formats, so this dissertation concerns itself with a closed extendable universe (by
user-declared datatypes).
Termination
A more theoretical example of generic programming is Coquand’s
proof [10] that an operational semantics of type theory terminates. This is achieved
using a logical relation deﬁned as an inductive-recursive universe, which can be
viewed as an extension of a universe of natural numbers (‘N), closed under depen-
dent function formation (‘Π). Below, we give the signature for the type of expres-
sions (E), the indexed logical relation type (Ψ), and the logical relation meaning
function (ψ), used in Coquand’s formal development.
data E : Set where
mutual
data Ψ : (A : E) →Set where
ψ : (A : E) →Ψ A →(a : E) →Set
The codes (Ψ) of the logical relation are additionally indexed by a syntax of
expressions (A : E). The codes are inhabited for all the expressions corresponding
to types in the language.
The meaning function (ψ) of the logical relation is
indexed by two expressions, where the ﬁrst represents the type (A) and the second
represents values of that type (a). The meaning function is inhabited whenever
the expression value is a valid member of the expression type.
The meaning function is also indexed by the result of applying the code type

246
former (Ψ) to the expression index representing the type (A), or evidence that
the type is well-formed. One ﬁnal diﬀerence between the logical relation and an
ordinary universe of types, is that the logical relation also contains termination ev-
idence, in the form of inhabitants of the operational semantics judgement (deﬁned
as a type that is indexed by expressions).
Once again, we emphasize that the logical relation for a dependent type theory
can be considered a universe, albeit one with additional indexing and containing
additional data in the form of termination witnesses. The fundamental theorem,
used to prove that the operational semantics terminates, is deﬁned over this uni-
verse (i.e., the logical relation is one of its arguments). Hence, the fundamental
theorem can be seen as a fully generic function. Many lemmas used in the proof of
termination can likewise be seen as fully generic functions. Finally, we note that
even though these functions are fully generic, they operate over a ﬁxed universe of
natural numbers, closed under dependent function formation.
9.2
EXTENDABLE OPEN OR CLOSED WELL-ORDER UNIVERSES
Open Universes
Morris [44] demonstrates generic programming over small in-
dexed containers in an open universe. Because indexed containers can represent
arbitrary user-declared datatypes, the universe is also extendable.
Morris writes generic functions, like map, over the open universe of indexed
containers. This corresponds to writing generic functions over the open universe
of inductive-recursive types in Section 5.4.2, because small induction-recursion and
small indexing are equivalent [31].
Recursive containers are represented using the W type of well-orderings, which
is the ﬁxpoint of containers. As we explained in Section 4.2.3, W types inadequately
encode ﬁrst-order types in intensional type theory, which is why we use the more
complicated (but adequate) algebraic semantics of Section 5.4.4, deﬁned in terms
of Desc and µ1.

247
Closed Universes
We expect that it would be straightforward to extend the
generic functions that Morris wrote over an open universe of containers, to operate
over a closed universe of well-orderings (like the universe in Section 4.2.1). Once
again, we were not interested in this option for adequacy reasons (Section 4.2.3).
9.3
EXTENDABLE OPEN ALGEBRAIC UNIVERSES
There is a lot of work on generic programming over an open algebraic universe,
similar to the one in Section 5.4.2.
It should be possible to extend any such
generic functions, over an open universe, to be fully generic, over a closed universe
(or hierarchy of universes), using techniques from Chapter 7 (and Section 8.3).
Universal Algebra
Benke et al. [6] perform generic programming in the domain
of universal algebra. Various restrictions of the open inductive-recursive universe of
Section 5.4.2 are used for each algebra (e.g., one-sorted term algebras, many-sorted
term algebras, parameterized term algebras, etc.). Some of these algebras restrict
the universe to be ﬁnitary, some remain inﬁnitary, but all of them restrict the use of
induction-recursion. As they state, their work could have been instead deﬁned as
restrictions over a universe of indexed inductive types without induction-recursion.
Induction Principles
Chapman et al. [7] deﬁne Descriptions for indexed de-
pendent types (without induction-recursion). Deﬁning generic induction principles
for types encoded by Descriptions requires a computational argument type for all
the inductive hypotheses (All, also called Hyps). Although Desc is not inductive-
recursive, it is still inﬁnitary so generic functions over such types, like ind, share
many of the same properties as our generic functions.
Our previous work [17] expands upon the work of Chapman et al. [7], deﬁn-
ing an alternative interface to induction as generic type-theoretic eliminators for
Descriptions.
Deﬁning these eliminators involves several nested constructions,

248
where both computational argument types (to collect inductive hypotheses) and
return types (to produce custom eliminator types for each description) are used
for information retrieval but not modiﬁcation of inﬁnitary descriptions.
Ornaments
McBride [41] builds a theory of Ornaments on top of Descriptions
for indexed dependent types (without induction-recursion). Ornaments allow a
description of one type (such as a Vector) to be related to another type (such
as a List) such that a forgetful map from the more ﬁnely indexed type to the
less ﬁnely indexed type can be derived as a generic function.
This allows the
length function over lists (List) to be derived from the length function of (the more
ﬁnely) indexed vectors (Vec). Dagand and McBride [13] expand this work to also
work in the opposite direction, allowing functions over more ﬁnely indexed types
to be derived from functions over less ﬁnely indexed types, after providing some
structured missing information.
Disjointness and Injectivity
Goguen et al. [29] demonstrate how to elaborate
a high-level syntax of dependent pattern matching to low-level uses of eliminators.
Part of this elaboration process depends upon proofs that constructors are injective
and disjoint.
McBride et al. [43] deﬁne these proofs externally, at the level of
metatheory. Dagand [12] also internalizes these proofs, as generic programs over
the open universe of algebraic datatypes (using Desc and µ).
Strictly Positive Families
In addition to writing generic functions over open
container-based datatype encodings, Morris also writes generic functions over an
open universe of “Strictly Positive Families” (whose type is called SPT). He writes
functions like generic map, a generic decision procedure for equality (over the
ﬁrst-order subset of the universe), and generic zipper operations. The SPT uni-
verse can be considered an alternative way to deﬁne Desc and µ. Due to the way

249
SPT is deﬁned, you can write functions that can make recursive calls on induc-
tive arguments of varying types, in a way that feels very similar to fully generic
programming. Nonetheless, ultimately SPT is still an open universe, as function
domains and inﬁnitary domains are still encoded using the open Set type.
In Section 7.1, we deﬁne fully generic count to specialize the way it operates
over inductive arguments (inﬁnitary argument whose domain is the unit type ‘⊤),
as opposed to truly inﬁnitary arguments (whose domain is a type other than unit).
This would not be possible in the SPT universe, because we could not match on
the domain argument (of open kind Set, rather than closed type ‘Set).
Static Constructors and Arguments
Sijsling [50] deﬁnes an open algebraic
universe, using a “static” variant of the datatype of descriptions (Desc).
This
universe statically encodes the structure of constructors and their arguments, so
that we statically know the number of constructors and arguments of a datatype.
In contrast, the type of the second argument of the σ constructor (of Section 5.3.2),
depends on the value of the ﬁrst argument. Hence, we cannot statically determine
the number of remaining constructor arguments, encoded by the second argument
of σ, because its type may depend on the ﬁrst argument of σ (i.e., a value, only
dynamically available).
Sijsling reﬂects datatype declarations written in high-level Agda (using Agda’s
reﬂection machinery), and uses the reﬂected declarations to automatically derive
encodings of the datatypes in terms of his static Desc. He then writes generic
programs over his static Desc, some of which can be automatically converted be-
tween their high-level Agda representations and the low-level static Desc-based
representations.
Sijsling leaves extending his static Desc to account for inﬁnitary arguments and
induction-recursion as future work, which we believe is possible. We also do not
foresee any problems with deﬁning a closed universe in terms of such static Desc

250
types, by applying our closing procedure from Section 6.3.
Arity-Generic and Datatype-Generic Programming
Weirich and Casingh-
ino [53] demonstrate writing arity-generic and datatype-generic functions, such as
a map function for any type (i.e., the datatype-generic part) with any number
of datatype parameters (i.e., the arity-generic part). They also deﬁne generic zip
and equality functions. Note that all of these functions are traditional generic
programs, because they do not recurse into the structure of datatype parameters.
Instead, functions like equality are parameterized by a function to compare the
values of the parameterized types.
The universe used by Weirich and Casinghino captures the class of datatypes
that can be built from non-dependent functions, the unit type, natural numbers,
non-dependent pairs, and disjoint unions. Some indexed types can be built this
way, like vectors. But, their universe cannot represent indexed types whose con-
structor arguments have indices that are structurally larger than the index returned
by the constructor. This is because their indexed types are derived as computa-
tional families (Section 2.1.11), as a non-dependent function in their universe, so
a function deriving such an indexed type would not terminate. Additionally, their
universe cannot represent indexed types with dependencies between indices, be-
cause their function-space is non-dependent.
9.4
PREVIOUS WORK
Now we discuss how the contributions of this dissertation relate to our previously
published work.
Closed Universe Zero and Fully Generic Programming
In a previous pub-
lication [18], Sheard and I deﬁned the closed universe of inductive-recursive alge-
braic types, and wrote fully generic functions over the universe. That work is the

251
basis of Chapter 6 and Chapter 8. An important contribution of our disserta-
tion from Chapter 6, not present in our previous publication [18], is the generic
procedure to close any universe of kinds (Section 6.3).
The fully generic function count (Section 7.1) and ast (Section 7.3) functions
of Chapter 6 are also novel to this dissertation. In Section 7.2, we deﬁne a generic
lookup function, that takes a ﬁnite set (Fin) argument, which is indexed by the
count of the argument being looked up. We also deﬁne a lookup function in our
previous publication, but it is indexed by a custom index type (unique to each type
being looked up), rather than using Fin and a dependent application of count. Our
previous publication also features a generic update function. While this dissertation
treats higher-order arguments as black-boxes, our previous publication [18] uses
domain supplements (Section 3.4.5) to also recurse into higher-order arguments.
Closed Universe Hierarchy and Leveled Fully Generic Programming
In
another previous publication [16], Sheard and I deﬁned a closed hierarchy of alge-
braic (but not inﬁnitary or inductive-recursive) types. That work is the basis of
Chapter 8. The novel part of Chapter 8 is adapting McBride’s Closed Hierarchy
of Well-Order Universes [42] (reviewed in Section 8.1.3) to a Closed Hierarchy of
Inductive-Recursive Universes (presented in Section 8.2).
While our previous publication featured both description lifting functions, ‘J_K1
and ‘µ1’, it did not feature the non-lifting ﬁxpoint operator ‘µ1. At the time, we
did not know how to adequately represent datatypes of the current universe level.
This resulted in needing to inadequately deﬁne certain types at one level higher in
the hierarchy, so that they may be deﬁned in terms of the lifting ﬁxpoint ‘µ1’.
My (i.e., Diehl’s) novel solution to this problem appears in Chapter 8, where
I add a non-lifting ﬁxpoint ‘µ1, whose argument is a mutually deﬁned DescForm.
Hence, the novelty of Chapter 8 is combining the idea of mutually deﬁned code
types (‘Set and ‘Set) and mutually deﬁned translation functions (J_K and «_»),

252
from Chapter 6, with the idea of description lifting functions (‘J_K1 and ‘µ1’) from
our previous publication [16].

253
Chapter 10
FUTURE WORK
This dissertation demonstrates that leveled fully generic programming is possible,
using a universe modeling a closed dependently typed language supporting user-
declared datatypes. But, there is still much work left to do! We discuss a small
slice of this future work, below.
10.1
UNIVERSE POLYMORPHISM
In Section 8.2.2, we deﬁne the type (in universe 0) of closed natural numbers, whose
signature is a kind (in universe 1).
‘N : J 1 | ‘Set K
In Section 8.3.1, we deﬁne fully generic count over all values of all types (in
universe 0), whose signature is also a kind (in universe 1). When we use the type
of natural numbers in the kind signature of count, it must be lifted to the kind
level via ‘J_K.
count : J 1 | ‘Π ‘Set (ń A →‘J A K ‘→‘J ‘N K) K
In Section 8.3.2, we deﬁne fully generic Count over all types of all kinds (in
universe 1), whose signature is a superkind (in universe 2). When we use the type
of natural numbers in the superkind signature of Count, it must be lifted to the
kind level by using ‘J_K twice.
Count : J 2 | ‘Π ‘Set (ń A →‘J A K ‘→‘J ‘J ‘N K K) K
Types like dependent pairs (‘Σ) are built into the universe, and appear at

254
every level of the hierarchy. Therefore, we must handle the ‘Σ case of Count (in
universe 1) in exactly the same way that we handled it for count (in universe 0).
Furthermore, if we want to count all kinds of superkinds (in universe 2), we must
deﬁne yet fully generic counting function (and so on, for every level). We could
eliminate a lot of duplications by deﬁning both algebraic datatypes and functions
universe polymorphically, so they can be instantiated at any level of the universe.
‘N : (ℓ: N) →J suc ℓ| ‘Set K
count : (ℓ: N) →J suc ℓ| ‘Π ‘Set (ń A →‘J A K ‘→‘N (suc ℓ)) K
Notice that the natural number codomain of count does not need to be lifted,
because we can just request a version of the natural numbers at the succesor to
level ℓ. Also notice that we can deﬁne count once at every level, so we do not need
to separately deﬁne Count.
Unfortunately, universe polymorphic deﬁnitions rely on quantifying over lev-
els in our metalanguage.
In other words, universe polymorphic deﬁnitions do
not model fully generic programs that we could write in our modeled closed de-
pendently typed language. For future work, we would like to add universe level
quantiﬁcation as a code of our universe, so that the types of deﬁnitions like ‘N and
count can be internalized (i.e., made to appear within the brackets).
10.2
LARGE INDUCTION-RECURSION
In this dissertation, we close over inductive-recursive types (in Section 6.2), but
they are small. Inductive-recursive types are small if the codomain of the decoding
function can be any type, but it cannot be any kind (like ‘Set or ‘Desc). We are not
sure if it is possible to deﬁne a closed universe of large inductive-recursive types,
but we would like to try. It may be the case that we need a more expressive type
theory, like Homotopy Type Theory [52], to close over large inductive-recursive
types of Martin-Löf’s type theory [39].

255
If we are able to close over large inductive-recursive types, then we would
need to encode indexed inductive-recursive algebraic types. This is because the
isomorphism between indexed types and inductive-recursive types only holds in
the small case [31], so inductive-recursive algebraic types would not be enough.
Finally, note that we cannot achieve large induction-recursion simply by moving
up a universe level. At universe level 1, the codomain of a small decoding function
could be any kind, but a large decoding function would allow the codomain to be
any superkind.
10.3
INDUCTION-INDUCTION
We close over small inductive-recursive types in Section 6.2. We have also applied
our closing procedure (Section 6.3) to close over an encoding of small indexed
inductive-recursive types [24].
This dissertation does not cover the closed uni-
verse of indexed inductive-recursive because no problems arise when applying our
closing procedure. Nordvall has shown how to formally model inductive-inductive
types [46]. An inductive-inductive type is deﬁned as a pair of mutually deﬁned
types, where the second type is indexed by the ﬁrst. We have not yet attempted to
close over a universe of inductive-inductive types, but we plan to in future work.
10.4
HIGH-LEVEL GENERIC PROGRAMMING
In Chapter 7, we mention that we can hide our algebraic encodings via smart
constructors and pattern synonyms, when deﬁning concrete functions (i.e., over
concrete datatypes). However, we need to understand the underlying initial-algebra
base encoding, when deﬁning fully generic functions.
McBride [29] deﬁnes how to elaborate dependent pattern matching, a high-
level language feature, to eliminators, which can be considered low-level induction
principles of a core language. We would like to explore implementing a closed

256
dependently typed language. It would be nice if we had a high-level feature for
writing fully generic functions, that could be elaborated to the fully generic func-
tions of this dissertation, which explicitly match on low-level encodings (like the
initial algebra).
Just as McBride allows users to deﬁne functions by dependent pattern match-
ing, without understanding how to program directly with eliminators, we would
like users to be able to deﬁne fully generic functions, without understanding our
closed universe model. Finally, note that Dagand [14] has already shown how to
elaborate high-level datatype declarations to their description-based (Desc) encod-
ings.
10.5
EFFICIENT IMPLEMENTATION
Al-Sibahi [2] shows how to eﬃciently implement traditional generic programming
over a (description-based) open algebraic universe of non-inﬁnitary indexed types.1
He uses partial evaluation to remove most of the overhead associated with encoding
datatypes as ﬁxpoints of functor descriptions. It would be interesting to explore
extending Al-Sibahi’s work to fully generic programming over a closed universe,
to see if any complications arise in the closed setting. We expect that his open-
universe optimizations will continue to work in the closed-universe setting, and we
hope that further optimizations will be possible in the closed-universe setting.
10.6
TERMINATION OF INTENSIONAL CLOSED TYPE THEORY
In our related work (Chapter 9), we discus how Coquand [10] proves that an
operational semantics of type theory, consisting of the natural numbers closed
1 Al-Sibani also demonstrates a form of fully generic programming by writing functions like a
generic pretty printer (gshow). Rather than closing the universe of descriptions, he adds extra ar-
guments that constrain non-inductive constructor arguments (inspired by type class constraints).
Unlike fully generic programming over a closed universe, custom constraints must be deﬁned for
each fully generic function.

257
under dependent function formation, terminates.
The logical relation of this termination proof can be considered an extended ver-
sion of the closed universe model of natural numbers closed under dependent func-
tion formation. We would like to explore extending our model of closed inductive-
recursive types (Appendix C) to a logical relation (following Coquand’s approach),
and proving that an operational semantics of closed type theory, supporting user-
declared datatypes (via Desc and µ1), terminates.
10.7
INDUCTIVE DEFINITIONS OVER INFINITARY DOMAIN
Our fully generic count (Section 7.1), lookup (Section 7.2), and ast (Section 7.3)
functions all treat the case of inductive arguments of the initial algebra as a special
case of inﬁnitary arguments. Being able to pattern match against the domain of
an inﬁnitary argument, and ensuring that it is the unit type (‘⊤), demonstrates
the power of closed type theory (because we can match against a type).
In our previous work [18], we have also deﬁned higher-order domain supple-
ments (Section 3.4.5) that allow us to write fully generic functions over higher-
order data (like the body of functions, or truly inﬁnitary arguments). However,
neither the deﬁnition of count in Section 7.1 (which requires matching against ‘⊤),
nor the fully generic functions using higher-order domain supplements [18], are
deﬁned by induction on the higher-order domains (like the domain of functions or
the domain of inﬁnitary arguments). In the future, we would like to explore what
horizons have opened up to us now that our closed universe allows us to write
functions by induction on closed higher-order domains.

258
Chapter 11
CONCLUSION
Generic programming, within dependently typed programming languages, over a
universe closed under a ﬁxed collection of type formers (e.g., Section 4.1) has a rich
history. If we consider such a universe to be a model of a closed dependently typed
programming language, then users of that language may use its ﬁxed collection of
types, but may not declare their own domain-speciﬁc types.
Inspired by categorical models of algebraic semantics, which model algebraic
datatypes as least-ﬁxed points of pattern functors, type theorists have also deﬁned
formal models (i.e., in type theory) of algebraic semantics. We can view strictly-
positive polynomial functors (Desc) as codes of a universe, whose meaning is their
ﬁxpoints (µ1). Generic dependently typed programming over this algebraic uni-
verse also has a rich history. Algebraic semantics is modeled as an open universe,
which grows as users of the underlying open type theory declare new datatypes.
The ﬁrst major contribution of this dissertation (Chapter 6) is creating a closed
universe, modeling the types of a closed dependently typed programming language
that supports user-declared datatypes (‘Desc). We still do this by deﬁning a uni-
verse closed under a ﬁxed collection of type formers, but one of the type formers
is a closed variant of the ﬁxpoint operator (‘µ1) from algebraic semantics. This
variant is parameterized by a mutually deﬁned closed variant of strictly-positive
polynomial functors (‘Desc).
The second major contribution of this dissertation (Chapter 7) is demonstrating
what we call fully generic programming. Fully generic functions are deﬁned over
a closed universe including user-declared datatypes. They can be deﬁned once,

259
working over all current datatypes, but they continue to work as users declare
additional datatypes in the future.
The third major contribution of this dissertation (Chapter 8) is extending the
model of closed types (supporting user-declarations) to also model closed kinds,
closed superkinds, etc. Hence, we model a closed hierarchy of universes support-
ing user-declared datatypes. The closed hierarchy of universes models a closed
dependently typed programming language with a universe hierarchy, supporting
user-declared datatypes at every level of the hierarchy. We also demonstrate lev-
eled fully generic programming, or writing fully generic functions at any level in
the universe hierarchy (over values, types, kinds, superkinds, etc.). This achieves
our goal, of modeling fully generic programming in a closed dependently typed
programming language, supporting user-declared datatypes.

260
REFERENCES
[1] Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Containers: construct-
ing strictly positive types. Theoretical Computer Science, 342(1):3–27, 2005.
[2] Ahmad Salim Al-Sibahi. The Practical Guide to Levitation. Master’s thesis,
IT University of Copenhagen, 2014.
[3] Thorsten Altenkirch and Conor McBride. Generic programming within depen-
dently typed programming. In Generic Programming. Proceedings of the IFIP
TC2 Working Conference on Generic Programming, pages 1–20. Springer,
2003. Held in Schloss Dagstuhl.
[4] Thorsten Altenkirch, Conor McBride, and Wouter Swierstra. Observational
equality, now! In Proceedings of the 2007 workshop on Programming languages
meets program veriﬁcation, PLPV ’07, pages 57–68, New York, NY, USA,
2007. ACM. ISBN 978-1-59593-677-6. doi: 10.1145/1292597.1292608. URL
http://doi.acm.org/10.1145/1292597.1292608.
[5] Roland Backhouse, Patrik Jansson, Johan Jeuring, and Lambert Meertens.
Generic programming. In International School on Advanced Functional Pro-
gramming, pages 28–115. Springer, 1998.
[6] Marcin Benke, Peter Dybjer, and Patrik Jansson. Universes for generic pro-
grams and proofs in dependent type theory. Nord. J. Comput., 10(4):265–289,
2003.
[7] James Chapman, Pierre-Évariste Dagand, Conor McBride, and Peter Morris.
The Gentle Art of Levitation. In Proceedings of the 15th ACM SIGPLAN

261
International Conference on Functional Programming, ICFP ’10, pages 3–14,
New York, NY, USA, 2010. ACM. ISBN 978-1-60558-794-3. doi: 10.1145/
1863543.1863547. URL http://doi.acm.org/10.1145/1863543.1863547.
[8] Alonzo Church. The calculi of lambda-conversion, volume 6. Princeton Uni-
versity Press, 1941.
[9] Robert L. Constable, Stuart F. Allen, S. F. Allen, H. M. Bromley, W. R.
Cleaveland, J. F. Cremer, R. W. Harper, Douglas J. Howe, T. B. Knoblock,
N. P. Mendler, P. Panangaden, Scott F. Smith, James T. Sasaki, and S. F.
Smith. Implementing Mathematics with The Nuprl Proof Development System.
Prentice-Hall, 1986.
[10] Catarina Coquand. A realizability interpretation of Martin-Löf’s type theory.
In Twenty-Five Years of Constructive Type Theory. Proceedings of a Congress
Held in Venice, Oxford, 1998. Clarendon Press.
[11] Thierry Coquand and Christine Paulin. Inductively deﬁned types. In COLOG-
88, pages 50–66. Springer, 1990.
[12] Pierre-Evariste Dagand. A Cosmology of Datatypes. PhD thesis, University
of Strathclyde, 2013.
[13] Pierre-Evariste Dagand and Conor McBride. Transporting Functions Across
Ornaments. In Proceedings of the 17th ACM SIGPLAN International Confer-
ence on Functional Programming, ICFP ’12, pages 103–114, New York, NY,
USA, 2012. ACM. ISBN 978-1-4503-1054-3. doi: 10.1145/2364527.2364544.
URL http://doi.acm.org/10.1145/2364527.2364544.
[14] Pierre-Evariste Dagand and Conor Mcbride. Elaborating inductive deﬁnitions.
In JFLA-Journées francophones des langages applicatifs, 2013.

262
[15] Nicolaas Govert De Bruijn. Lambda calculus notation with nameless dummies,
a tool for automatic formula manipulation, with application to the Church-
Rosser theorem.
In Indagationes Mathematicae (Proceedings), volume 75,
pages 381–392. Elsevier, 1972.
[16] Larry Diehl and Tim Sheard. Leveling Up Dependent Types: Generic Pro-
gramming over a Predicative Hierarchy of Universes. In Proceedings of the
2013 ACM SIGPLAN Workshop on Dependently-typed Programming, DTP
’13, pages 49–60, New York, NY, USA, 2013. ACM.
ISBN 978-1-4503-
2384-0. doi: 10.1145/2502409.2502414. URL http://doi.acm.org/10.1145/
2502409.2502414.
[17] Larry Diehl and Tim Sheard. Generic constructors and eliminators from de-
scriptions: type theory as a dependently typed internal DSL. In Proceedings
of the 10th ACM SIGPLAN workshop on Generic programming, pages 3–14.
ACM, 2014.
[18] Larry Diehl and Tim Sheard.
Generic Lookup and Update for Inﬁnitary
Inductive-recursive Types. In Proceedings of the 1st International Workshop
on Type-Driven Development, TyDe 2016, pages 1–12, New York, NY, USA,
2016. ACM. ISBN 978-1-4503-4435-7. doi: 10.1145/2976022.2976031. URL
http://doi.acm.org/10.1145/2976022.2976031.
[19] Peter Dybjer. Inductive sets and families in Martin-Löf’s type theory and
their set-theoretic semantics. Logical frameworks, 2:6, 1991.
[20] Peter Dybjer. Inductive families. Formal aspects of computing, 6(4):440–465,
1994.
[21] Peter Dybjer.
Representing inductively deﬁned sets by wellorderings in
Martin-Löf’s type theory. Theoretical Computer Science, 176(1-2):329–335,
1997.

263
[22] Peter Dybjer. A general formulation of simultaneous inductive-recursive def-
initions in type theory. The Journal of Symbolic Logic, 65(02):525–549, 2000.
[23] Peter Dybjer and Anton Setzer. A ﬁnite axiomatization of inductive-recursive
deﬁnitions. In Typed Lambda Calculi and Applications, volume 1581 of Lecture
Notes in Computer Science, pages 129–146. Springer, 1999.
[24] Peter Dybjer and Anton Setzer. Indexed induction-recursion. In Proof Theory
in Computer Science, pages 93–113. Springer, 2001.
[25] John Ellson, Emden Gansner, Lefteris Koutsoﬁos, Stephen C North, and Gor-
don Woodhull. Graphviz—open source graph drawing tools. In International
Symposium on Graph Drawing, pages 483–484. Springer, 2001.
[26] Nicola Gambino and Martin Hyland. Wellfounded trees and dependent poly-
nomial functors. In International Workshop on Types for Proofs and Programs,
pages 210–225. Springer, 2003.
[27] Emden Gansner, Eleftherios Koutsoﬁos, and Stephen North. Drawing graphs
with dot, 2006.
[28] Jean-Yves Girard. Functional interpretation and elimination of superior order
arithmetic breaks. PhD thesis, Universite Paris VII, 1972.
[29] Healfdene Goguen, Conor McBride, and James McKinna. Eliminating de-
pendent pattern matching.
In Algebra, Meaning, and Computation, pages
521–540. Springer, 2006.
[30] Cordelia V Hall, Kevin Hammond, Simon L Peyton Jones, and Philip L
Wadler. Type classes in Haskell. ACM Transactions on Programming Lan-
guages and Systems (TOPLAS), 18(2):109–138, 1996.

264
[31] Peter Hancock, Conor McBride, Neil Ghani, Lorenzo Malatesta, and Thorsten
Altenkirch. Small induction recursion. In International Conference on Typed
Lambda Calculi and Applications, pages 156–172. Springer, 2013.
[32] Ralf Hinze. Generic Programs and Proofs. PhD thesis, Universität Bonn,
2000.
[33] William A Howard.
The formulae-as-types notion of construction.
In To
HB Curry: essays on combinatory logic, lambda calculus and formalism, vol-
ume 44, pages 479–490. Academic Press, 1980.
[34] Antonius JC Hurkens.
A simpliﬁcation of Girard’s paradox.
In Interna-
tional Conference on Typed Lambda Calculi and Applications, pages 266–278.
Springer, 1995.
[35] Simon L Peyton Jones. Haskell 98 language and libraries: the revised report.
Cambridge University Press, 2003.
[36] Simon Peyton Jones, Mark Jones, and Erik Meijer. Type classes: an explo-
ration of the design space. In Haskell workshop, pages 1–16, 1997.
[37] Per Martin-Löf. Hauptsatz for the intuitionistic theory of iterated inductive
deﬁnitions. Studies in Logic and the Foundations of Mathematics, 63:179–216,
1971.
[38] Per Martin-Löf. An intuitionistic theory of types: Predicative part. Studies
in Logic and the Foundations of Mathematics, 80:73–118, 1975.
[39] Per Martin-Löf. Intuitionistic type theory. Notes by Giovanni Sambin, 1984.
Bibliopolis, Naples.
[40] Conor McBride. W-types: good news and bad news. Blog post, March 2010.
URL http://mazzo.li/epilogue/index.html%3Fp=324.html.

265
[41] Conor McBride. Ornamental algebras, algebraic ornaments. 2011.
[42] Conor McBride. Hier Soir, an OTT Hierarchy. Blog post, November 2011.
URL http://mazzo.li/epilogue/index.html%3Fp=1098.html.
[43] Conor McBride, Healfdene Goguen, and James McKinna. A few constructions
on constructors. In Types for Proofs and Programs, pages 186–200. Springer,
2006.
[44] Peter Morris. Constructing Universes for Generic Programming. PhD thesis,
University of Nottingham, 2007.
[45] Bengt Nordström, Kent Petersson, and Jan M Smith. Programming in Martin-
Löf’s type theory, volume 85. Oxford University Press, 1990.
[46] Fredrik Nordvall Forsberg.
Inductive-inductive deﬁnitions.
PhD thesis,
Swansea University, 2013.
[47] Ulf Norell. Towards a practical programming language based on dependent
type theory. PhD thesis, Chalmers University of Technology, 2007.
[48] Ulf Norell. Dependently Typed Programming in Agda. In Proceedings of the
4th International Workshop on Types in Language Design and Implementa-
tion, TLDI ’09, pages 1–2, New York, NY, USA, 2009. ACM. ISBN 978-1-
60558-420-1. doi: 10.1145/1481861.1481862. URL http://doi.acm.org/10.
1145/1481861.1481862.
[49] Nicolas Oury and Wouter Swierstra. The Power of Pi. In Proceedings of the
13th ACM SIGPLAN International Conference on Functional Programming,
ICFP ’08, pages 39–50, New York, NY, USA, 2008. ACM. ISBN 978-1-59593-
919-7. doi: 10.1145/1411204.1411213. URL http://doi.acm.org/10.1145/
1411204.1411213.

266
[50] Yorick Sijsling. Generic programming with ornaments and dependent types.
Master’s thesis, Utrecht University, 2016.
[51] Christopher Strachey.
Fundamental Concepts in Programming Languages.
Higher Order Symbol. Comput., 13(1-2):11–49, April 2000.
ISSN 1388-
3690. doi: 10.1023/A:1010000313106. URL http://dx.doi.org/10.1023/A:
1010000313106.
[52] The Univalent Foundations Program.
Homotopy Type Theory: Univalent
Foundations of Mathematics. https://homotopytypetheory.org/book, In-
stitute for Advanced Study, 2013.
[53] Stephanie Weirich and Chris Casinghino. Arity-generic datatype-generic pro-
gramming.
In Proceedings of the 4th ACM SIGPLAN workshop on Pro-
gramming languages meets program veriﬁcation, PLPV ’10, pages 15–26, New
York, NY, USA, 2010. ACM. ISBN 978-1-60558-890-2. doi: 10.1145/1707790.
1707799. URL http://doi.acm.org/10.1145/1707790.1707799.

267
Appendix A
OPEN NON-ALGEBRAIC TYPES
data ⊥: Set where
record ⊤: Set where
constructor tt
data Bool : Set where
true false : Bool
inﬁxr 4 _,_
record Σ (A : Set) (B : A →Set) : Set where
constructor _,_
ﬁeld
proj1 : A
proj2 : B proj1
data Id (A : Set) (x : A) : A →Set where
reﬂ: Id A x x

268
Appendix B
OPEN UNIVERSE OF ALGEBRAIC TYPES
data Desc (O : Set) : Set1 where
Ì : (o : O) →Desc O
σ : (A : Set) (D : A →Desc O) →Desc O
δ : (A : Set) (D : (A →O) →Desc O) →Desc O
mutual
J_K1 : {O : Set} (D R : Desc O) →Set
J Ì o K1 R = ⊤
J σ A D K1 R = Σ A (ń a →J D a K1 R)
J δ A D K1 R = Σ (A →µ1 _ R) ń f →J D (ń a →µ2 R (f a)) K1 R
J_K2 : {O : Set} (D R : Desc O) →J D K1 R →O
J Ì o K2 R tt = o
J σ A D K2 R (a , xs) = J D a K2 R xs
J δ A D K2 R (f , xs) = J D (ń a →µ2 R (f a)) K2 R xs
data µ1 (O : Set) (D : Desc O) : Set where
init : J D K1 D →µ1 O D
µ2 : {O : Set} (D : Desc O) →µ1 O D →O
µ2 D (init xs) = J D K2 D xs

269
Appendix C
CLOSED UNIVERSE OF ALGEBRAIC TYPES
mutual
data ‘Set : Set where
‘⊥‘⊤‘Bool ‘String : ‘Set
‘Σ ‘Π : (A : ‘Set) (B : J A K →‘Set) →‘Set
‘Id : (A : ‘Set) (x y : J A K) →‘Set
‘µ1 : (O : ‘Set) (D : ‘Desc O) →‘Set
J_K : ‘Set →Set
J ‘⊥K = ⊥
J ‘⊤K = ⊤
J ‘Bool K = Bool
J ‘String K = String
J ‘Σ A B K = Σ J A K (ń a →J B a K)
J ‘Π A B K = (a : J A K) →J B a K
J ‘Id A x y K = Id J A K x y
J ‘µ1 O D K = µ1 J O K « D »
data ‘Desc (O : ‘Set) : Set where
‘Ì : (o : J O K) →‘Desc O
‘σ : (A : ‘Set) (D : J A K →‘Desc O) →‘Desc O
‘δ : (A : ‘Set) (D : (o : J A K →J O K) →‘Desc O)
→‘Desc O
«_» : {O : ‘Set} →‘Desc O →Desc J O K
« ‘Ì o » = Ì o
« ‘σ A D » = σ J A K (ń a →« D a »)
« ‘δ A D » = δ J A K (ń o →« D o »)

270
Appendix D
CLOSED HIERARCHY OF UNIVERSES
record Level : Set1 where
ﬁeld
SetForm : Set
J_/_K : (A : SetForm) →Set
DescForm : (O : SetForm) →Set
J_/_K1 : {O : SetForm} (D R : DescForm O) →Set
µ1’ : (O : SetForm) (D : DescForm O) →Set
mutual
data SetForm (ℓ: Level) : Set where
‘⊥‘⊤‘Bool ‘String : SetForm ℓ
‘Σ ‘Π : (A : SetForm ℓ) (B : J ℓ/ A K →SetForm ℓ) →SetForm ℓ
‘Id : (A : SetForm ℓ) (x y : J ℓ/ A K) →SetForm ℓ
‘µ1 : (O : SetForm ℓ) (D : DescForm ℓO) →SetForm ℓ
‘Set : SetForm ℓ
‘J_K : Level.SetForm ℓ→SetForm ℓ
‘Desc : Level.SetForm ℓ→SetForm ℓ
‘J_K1 : {O : Level.SetForm ℓ} (D R : Level.DescForm ℓO) →SetForm ℓ
‘µ1’ : (O : Level.SetForm ℓ) (D : Level.DescForm ℓO) →SetForm ℓ
J_/_K : (ℓ: Level) →SetForm ℓ→Set
J ℓ/ ‘⊥K = ⊥
J ℓ/ ‘⊤K = ⊤
J ℓ/ ‘Bool K = Bool
J ℓ/ ‘String K = String
J ℓ/ ‘Σ A B K = Σ J ℓ/ A K (ń a →J ℓ/ B a K)
J ℓ/ ‘Π A B K = (a : J ℓ/ A K) →J ℓ/ B a K
J ℓ/ ‘Id A x y K = Id J ℓ/ A K x y
J ℓ/ ‘µ1 O D K = µ1 J ℓ/ O K « ℓ/ D »

271
J ℓ/ ‘Set K = Level.SetForm ℓ
J ℓ/ ‘J A K K = Level.J ℓ/ A K
J ℓ/ ‘Desc O K = Level.DescForm ℓO
J ℓ/ ‘J D K1 R K = Level.J ℓ/ D K1 R
J ℓ/ ‘µ1’ O D K = Level.µ1’ ℓO D
data DescForm (ℓ: Level) (O : SetForm ℓ) : Set where
‘Ì : (o : J ℓ/ O K) →DescForm ℓO
‘σ : (A : SetForm ℓ) (D : J ℓ/ A K →DescForm ℓO) →DescForm ℓO
‘δ : (A : SetForm ℓ) (D : (o : J ℓ/ A K →J ℓ/ O K) →DescForm ℓO)
→DescForm ℓO
«_/_» : (ℓ: Level) {O : SetForm ℓ} →DescForm ℓO →Desc J ℓ/ O K
« ℓ/ ‘Ì o » = Ì o
« ℓ/ ‘σ A D » = σ J ℓ/ A K (ń a →« ℓ/ D a »)
« ℓ/ ‘δ A D » = δ J ℓ/ A K (ń o →« ℓ/ D o »)
level : (ℓ: N) →Level
level zero = record
{ SetForm = ⊥
; J_/_K = ń()
; DescForm = ń O →⊥
; J_/_K1 = ń ()
; µ1’ = ń ()
}
level (suc ℓ) = record
{ SetForm = SetForm (level ℓ)
; J_/_K = ń A →J level ℓ/ A K
; DescForm = DescForm (level ℓ)
; J_/_K1 = ń D R →J « level ℓ/ D » K1 « level ℓ/ R »
; µ1’ = ń O D →µ1 J level ℓ/ O K « level ℓ/ D »
}
‘Set[_] : N →Set
‘Set[ ℓ] = SetForm (level ℓ)
J_|_K : (ℓ: N) →‘Set[ ℓ] →Set
J ℓ| A K = J level ℓ/ A K

272
‘Desc[_] : (ℓ: N) →‘Set[ ℓ] →Set
‘Desc[ ℓ] O = DescForm (level ℓ) O
«_|_» : (ℓ: N) {O : ‘Set[ ℓ]} →‘Desc[ ℓ] O →Desc J ℓ| O K
« ℓ| D » = « level ℓ/ D »

273
Appendix E
INTERNALIZED CONSTRUCTOR SIGNATURES
bot’ : J 0 | ‘⊥‘→‘⊥K
bot’ p = p
tt’ : J 0 | ‘⊤K
tt’ = tt
true’ : J 0 | ‘Bool K
true’ = true
false’ : J 0 | ‘Bool K
false’ = false
pair’ : J 1 | ‘Π ‘Set (ń A →‘Π (‘J A K ‘→‘Set) (ń B →
‘Π ‘J A K (ń a →‘Π ‘J B a K (ń b →
‘Σ ‘J A K (ń a →‘J B a K))))) K
pair’ A B a b = a , b
lambda’ : J 1 | ‘Π ‘Set (ń A →‘Π (‘J A K ‘→‘Set) (ń B →
‘Π (‘Π ‘J A K (ń a →‘J B a K)) (ń f →
‘Π ‘J A K (ń a →‘J B a K)))) K
lambda’ A B f = ń a →f a
reﬂ’ : J 1 | ‘Π ‘Set (ń A →‘Π ‘J A K (ń a →‘Id ‘J A K a a)) K
reﬂ’ A a = reﬂ
init’ : J 1 | ‘Π ‘Set (ń O →‘Π (‘Desc O) (ń D →
‘J D K1 D ‘→‘µ1’ O D)) K
init’ O D xs = init xs

