An Introduction to
Programming in Emacs Lisp


An Introduction to
Programming in Emacs Lisp
Second Edition
by Robert J. Chassell

Copyright c⃝1990, 1991, 1992, 1993, 1994, 1995, 1997, 2001, 2002 Free
Software Foundation, Inc.
Published by the Free Software Foundation, Inc.
59 Temple Place, Suite 330
Boston, MA 02111-1307 USA
Edition 2.05, 2001 Jan 5
ISBN 1-882114-43-4
Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; there being no Invariant
Section, with the Front-Cover Texts being “A GNU Manual”, and with the
Back-Cover Texts as in (a) below. A copy of the license is included in the
section entitled “GNU Free Documentation License”.
(a) The FSF’s Back-Cover Text is: “You have freedom to copy and modify
this GNU Manual, like GNU software. Copies published by the Free Software
Foundation raise funds for GNU development.”

i
Short Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
1
List Processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2
Practicing Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3
How To Write Function Deﬁnitions . . . . . . . . . . . . . . . . . . 29
4
A Few Buﬀer–Related Functions . . . . . . . . . . . . . . . . . . . . 51
5
A Few More Complex Functions . . . . . . . . . . . . . . . . . . . . 63
6
Narrowing and Widening . . . . . . . . . . . . . . . . . . . . . . . . . 77
7
car, cdr, cons: Fundamental Functions . . . . . . . . . . . . . 81
8
Cutting and Storing Text. . . . . . . . . . . . . . . . . . . . . . . . . 89
9
How Lists are Implemented. . . . . . . . . . . . . . . . . . . . . . . 113
10
Yanking Text Back . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
11
Loops and Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
12
Regular Expression Searches . . . . . . . . . . . . . . . . . . . . . . 149
13
Counting: Repetition and Regexps. . . . . . . . . . . . . . . . . . 167
14
Counting Words in a defun. . . . . . . . . . . . . . . . . . . . . . 181
15
Readying a Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
16
Your ‘.emacs’ File. . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
17
Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
18
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Appendix A
The the-the Function . . . . . . . . . . . . . . . . . . 241
Appendix B
Handling the Kill Ring . . . . . . . . . . . . . . . . . . . 243
Appendix C
A Graph with Labelled Axes . . . . . . . . . . . . . . . 255
Appendix D
GNU Free Documentation License . . . . . . . . . . . 279
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287

ii

iii
Table of Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
On Reading this Text. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xi
For Whom This is Written. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xii
Lisp History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
A Note for Novices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Thank You . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiv
1
List Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1
Lisp Lists. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1.1
Lisp Atoms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1.2
Whitespace in Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.3
GNU Emacs Helps You Type Lists . . . . . . . . . . . . . . . 3
1.2
Run a Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3
Generate an Error Message . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.4
Symbol Names and Function Deﬁnitions . . . . . . . . . . . . . . . . . . 6
1.5
The Lisp Interpreter. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.5.1
Byte Compiling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.6
Evaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.6.1
Evaluating Inner Lists . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.7
Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.7.1
Error Message for a Symbol Without a Function. . 11
1.7.2
Error Message for a Symbol Without a Value . . . . 11
1.8
Arguments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.8.1
Arguments’ Data Types . . . . . . . . . . . . . . . . . . . . . . . . 13
1.8.2
An Argument as the Value of a Variable or List . . 13
1.8.3
Variable Number of Arguments . . . . . . . . . . . . . . . . . 14
1.8.4
Using the Wrong Type Object as an Argument . . 14
1.8.5
The message Function . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.9
Setting the Value of a Variable . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.9.1
Using set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.9.2
Using setq. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.9.3
Counting. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.10
Summary. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.11
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2
Practicing Evaluation . . . . . . . . . . . . . . . . . . . . . 23
2.1
Buﬀer Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2
Getting Buﬀers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3
Switching Buﬀers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.4
Buﬀer Size and the Location of Point . . . . . . . . . . . . . . . . . . . . 27
2.5
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

iv
3
How To Write Function Deﬁnitions . . . . . . . . 29
3.1
The defun Special Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.2
Install a Function Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
3.2.1
Change a Function Deﬁnition. . . . . . . . . . . . . . . . . . . 32
3.3
Make a Function Interactive . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.3.1
An Interactive multiply-by-seven . . . . . . . . . . . . . 34
3.4
Diﬀerent Options for interactive . . . . . . . . . . . . . . . . . . . . . . 35
3.5
Install Code Permanently . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.6
let . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.6.1
The Parts of a let Expression . . . . . . . . . . . . . . . . . . 37
3.6.2
Sample let Expression. . . . . . . . . . . . . . . . . . . . . . . . . 38
3.6.3
Uninitialized Variables in a let Statement. . . . . . . 39
3.7
The if Special Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3.7.1
The type-of-animal Function in Detail. . . . . . . . . 41
3.8
If–then–else Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.9
Truth and Falsehood in Emacs Lisp . . . . . . . . . . . . . . . . . . . . . 43
3.10
save-excursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
3.10.1
Template for a save-excursion Expression . . . . 45
3.11
Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
3.12
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
4
A Few Buﬀer–Related Functions. . . . . . . . . . . 51
4.1
Finding More Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
4.2
A Simpliﬁed beginning-of-buffer Deﬁnition. . . . . . . . . . . . 52
4.3
The Deﬁnition of mark-whole-buffer . . . . . . . . . . . . . . . . . . . 54
4.3.1
Body of mark-whole-buffer . . . . . . . . . . . . . . . . . . . 55
4.4
The Deﬁnition of append-to-buffer . . . . . . . . . . . . . . . . . . . . 56
4.4.1
The append-to-buffer Interactive Expression. . . 57
4.4.2
The Body of append-to-buffer . . . . . . . . . . . . . . . . 57
4.4.3
save-excursion in append-to-buffer. . . . . . . . . . 58
4.5
Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.6
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

v
5
A Few More Complex Functions . . . . . . . . . . . 63
5.1
The Deﬁnition of copy-to-buffer. . . . . . . . . . . . . . . . . . . . . . . 63
5.2
The Deﬁnition of insert-buffer. . . . . . . . . . . . . . . . . . . . . . . . 64
5.2.1
The Interactive Expression in insert-buffer. . . . 65
A Read-only Buﬀer. . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
‘b’ in an Interactive Expression. . . . . . . . . . . . . . . . . 65
5.2.2
The Body of the insert-buffer Function . . . . . . . 65
5.2.3
insert-buffer With an if Instead of an or. . . . . 66
5.2.4
The or in the Body. . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
5.2.5
The let Expression in insert-buffer . . . . . . . . . . 68
5.3
Complete Deﬁnition of beginning-of-buffer . . . . . . . . . . . . 69
5.3.1
Optional Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
5.3.2
beginning-of-buffer with an Argument . . . . . . . 71
What happens in a large buﬀer. . . . . . . . . . . . . . . . . 71
What happens in a small buﬀer . . . . . . . . . . . . . . . . 72
5.3.3
The Complete beginning-of-buffer . . . . . . . . . . . 73
5.4
Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
5.5
optional Argument Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
6
Narrowing and Widening. . . . . . . . . . . . . . . . . . 77
6.1
The save-restriction Special Form. . . . . . . . . . . . . . . . . . . . 77
6.2
what-line. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
6.3
Exercise with Narrowing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7
car, cdr, cons: Fundamental Functions . . . . . 81
7.1
car and cdr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
7.2
cons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
7.2.1
Find the Length of a List: length . . . . . . . . . . . . . . 84
7.3
nthcdr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7.4
nth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
7.5
setcar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
7.6
setcdr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
7.7
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

vi
8
Cutting and Storing Text . . . . . . . . . . . . . . . . . 89
8.1
zap-to-char . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
8.1.1
The interactive Expression . . . . . . . . . . . . . . . . . . . 90
8.1.2
The Body of zap-to-char. . . . . . . . . . . . . . . . . . . . . . 91
8.1.3
The search-forward Function . . . . . . . . . . . . . . . . . 92
8.1.4
The progn Special Form . . . . . . . . . . . . . . . . . . . . . . . 93
8.1.5
Summing up zap-to-char . . . . . . . . . . . . . . . . . . . . . 93
8.2
kill-region . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
8.2.1
condition-case. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
8.2.2
delete-and-extract-region . . . . . . . . . . . . . . . . . . 96
8.3
delete-and-extract-region: Digressing into C . . . . . . . . . 98
8.4
Initializing a Variable with defvar . . . . . . . . . . . . . . . . . . . . . 100
8.4.1
defvar and an asterisk. . . . . . . . . . . . . . . . . . . . . . . . 101
8.5
copy-region-as-kill. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
8.5.1
The Body of copy-region-as-kill. . . . . . . . . . . . 103
The kill-append function. . . . . . . . . . . . . . . . . . . . 104
The kill-new function . . . . . . . . . . . . . . . . . . . . . . . 105
8.6
Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
8.7
Searching Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
9
How Lists are Implemented . . . . . . . . . . . . . . 113
9.1
Symbols as a Chest of Drawers . . . . . . . . . . . . . . . . . . . . . . . . . 115
9.2
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
10
Yanking Text Back . . . . . . . . . . . . . . . . . . . . . 117
10.1
Kill Ring Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
10.2
The kill-ring-yank-pointer Variable . . . . . . . . . . . . . . . 117
10.3
Exercises with yank and nthcdr. . . . . . . . . . . . . . . . . . . . . . . 119
11
Loops and Recursion. . . . . . . . . . . . . . . . . . . . 121
11.1
while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
11.1.1
A while Loop and a List. . . . . . . . . . . . . . . . . . . . . 122
11.1.2
An Example: print-elements-of-list . . . . . . 123
11.1.3
A Loop with an Incrementing Counter . . . . . . . . 124
Example with incrementing counter . . . . . . . . . . . 125
The parts of the function deﬁnition. . . . . . . . . . . . 126
Putting the function deﬁnition together. . . . . . . . 127
11.1.4
Loop with a Decrementing Counter . . . . . . . . . . . 129
Example with decrementing counter . . . . . . . . . . . 129
The parts of the function deﬁnition. . . . . . . . . . . . 130
Putting the function deﬁnition together. . . . . . . . 130
11.2
Save your time: dolist and dotimes . . . . . . . . . . . . . . . . . . 131
The dolist Macro . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
The dotimes Macro . . . . . . . . . . . . . . . . . . . . . . . . . . 133

vii
11.3
Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
11.3.1
Building Robots: Extending the Metaphor. . . . . 134
11.3.2
The Parts of a Recursive Deﬁnition . . . . . . . . . . . 135
11.3.3
Recursion with a List . . . . . . . . . . . . . . . . . . . . . . . . 136
11.3.4
Recursion in Place of a Counter . . . . . . . . . . . . . . 137
An argument of 3 or 4. . . . . . . . . . . . . . . . . . . . . . . . 138
11.3.5
Recursion Example Using cond . . . . . . . . . . . . . . . 139
11.3.6
Recursive Patterns. . . . . . . . . . . . . . . . . . . . . . . . . . . 140
Recursive Pattern: every . . . . . . . . . . . . . . . . . . . . . 141
Recursive Pattern: accumulate . . . . . . . . . . . . . . . . 142
Recursive Pattern: keep . . . . . . . . . . . . . . . . . . . . . . 143
11.3.7
Recursion without Deferments . . . . . . . . . . . . . . . . 143
11.3.8
No Deferment Solution. . . . . . . . . . . . . . . . . . . . . . . 145
11.4
Looping Exercise. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
12
Regular Expression Searches . . . . . . . . . . . . 149
12.1
The Regular Expression for sentence-end . . . . . . . . . . . . . 149
12.2
The re-search-forward Function. . . . . . . . . . . . . . . . . . . . . 150
12.3
forward-sentence. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
The while loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
The regular expression search . . . . . . . . . . . . . . . . . . . . . . . . 154
12.4
forward-paragraph: a Goldmine of Functions . . . . . . . . . 155
The let* expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
The forward motion while loop . . . . . . . . . . . . . . . . . . . . . . 158
Between paragraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Within paragraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
No ﬁll preﬁx . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
With a ﬁll preﬁx . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
Summary. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
12.5
Create Your Own ‘TAGS’ File. . . . . . . . . . . . . . . . . . . . . . . . . . 163
12.6
Review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
12.7
Exercises with re-search-forward. . . . . . . . . . . . . . . . . . . . 166
13
Counting: Repetition and Regexps . . . . . . 167
13.1
The count-words-region Function . . . . . . . . . . . . . . . . . . . 167
13.1.1
The Whitespace Bug in count-words-region. . 170
13.2
Count Words Recursively . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
13.3
Exercise: Counting Punctuation. . . . . . . . . . . . . . . . . . . . . . . 179

viii
14
Counting Words in a defun . . . . . . . . . . . . . . 181
14.1
What to Count? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
14.2
What Constitutes a Word or Symbol? . . . . . . . . . . . . . . . . . 182
14.3
The count-words-in-defun Function . . . . . . . . . . . . . . . . . 183
14.4
Count Several defuns Within a File . . . . . . . . . . . . . . . . . . . 186
14.5
Find a File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
14.6
lengths-list-file in Detail . . . . . . . . . . . . . . . . . . . . . . . . . 188
14.7
Count Words in defuns in Diﬀerent Files . . . . . . . . . . . . . . 190
14.7.1
The append Function . . . . . . . . . . . . . . . . . . . . . . . . 191
14.8
Recursively Count Words in Diﬀerent Files. . . . . . . . . . . . . 192
14.9
Prepare the Data for Display in a Graph. . . . . . . . . . . . . . . 193
14.9.1
Sorting Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
14.9.2
Making a List of Files. . . . . . . . . . . . . . . . . . . . . . . . 194
14.9.3
Counting function deﬁnitions . . . . . . . . . . . . . . . . . 197
15
Readying a Graph . . . . . . . . . . . . . . . . . . . . . . 203
15.1
The graph-body-print Function. . . . . . . . . . . . . . . . . . . . . . 208
15.2
The recursive-graph-body-print Function. . . . . . . . . . . 210
15.3
Need for Printed Axes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
15.4
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
16
Your ‘.emacs’ File. . . . . . . . . . . . . . . . . . . . . . . 213
16.1
Site-wide Initialization Files. . . . . . . . . . . . . . . . . . . . . . . . . . . 213
16.2
Specifying Variables using defcustom. . . . . . . . . . . . . . . . . . 214
16.3
Beginning a ‘.emacs’ File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
16.4
Text and Auto Fill Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
16.5
Mail Aliases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
16.6
Indent Tabs Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
16.7
Some Keybindings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
16.8
Keymaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
16.9
Loading Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
16.10
Autoloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
16.11
A Simple Extension: line-to-top-of-window . . . . . . . . 224
16.12
X11 Colors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
16.13
Miscellaneous Settings for a ‘.emacs’ File . . . . . . . . . . . . . 227
16.14
A Modiﬁed Mode Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
17
Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
17.1
debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
17.2
debug-on-entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
17.3
debug-on-quit and (debug). . . . . . . . . . . . . . . . . . . . . . . . . . 234
17.4
The edebug Source Level Debugger. . . . . . . . . . . . . . . . . . . . 235
17.5
Debugging Exercises. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237

ix
18
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Appendix A
The the-the Function. . . . . . . . . . 241
Appendix B
Handling the Kill Ring . . . . . . . . 243
B.1
The rotate-yank-pointer Function . . . . . . . . . . . . . . . . . . . 243
B.1.1
The Body of rotate-yank-pointer . . . . . . . . . . . 244
The else-part of the if expression . . . . . . . . . . . . . 245
The % remainder function. . . . . . . . . . . . . . . . . . . . . 247
Using % in rotate-yank-pointer . . . . . . . . . . . . . 248
Pointing to the last element. . . . . . . . . . . . . . . . . . . 248
B.2
yank. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
Passing the argument . . . . . . . . . . . . . . . . . . . . . . . . 250
Passing a negative argument . . . . . . . . . . . . . . . . . . 251
B.3
yank-pop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
Appendix C
A Graph with Labelled Axes. . . 255
C.1
The print-graph Varlist. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
C.2
The print-Y-axis Function. . . . . . . . . . . . . . . . . . . . . . . . . . . 256
C.2.1
Side Trip: Compute a Remainder. . . . . . . . . . . . . . 258
C.2.2
Construct a Y Axis Element . . . . . . . . . . . . . . . . . . 259
C.2.3
Create a Y Axis Column. . . . . . . . . . . . . . . . . . . . . . 261
C.2.4
The Not Quite Final Version of print-Y-axis. . 262
C.3
The print-X-axis Function. . . . . . . . . . . . . . . . . . . . . . . . . . . 263
C.3.1
X Axis Tic Marks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
C.4
Printing the Whole Graph. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
C.4.1
Testing print-graph . . . . . . . . . . . . . . . . . . . . . . . . . 270
C.4.2
Graphing Numbers of Words and Symbols . . . . . 271
C.4.3
A lambda Expression: Useful Anonymity. . . . . . . 272
C.4.4
The mapcar Function. . . . . . . . . . . . . . . . . . . . . . . . . 274
C.4.5
Another Bug . . . Most Insidious . . . . . . . . . . . . . . 274
C.4.6
The Printed Graph. . . . . . . . . . . . . . . . . . . . . . . . . . . 277
Appendix D
GNU Free Documentation License
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287

x

On Reading this Text
xi
Preface
Most of the GNU Emacs integrated environment is written in the pro-
gramming language called Emacs Lisp. The code written in this program-
ming language is the software—the sets of instructions—that tell the com-
puter what to do when you give it commands. Emacs is designed so that
you can write new code in Emacs Lisp and easily install it as an extension
to the editor.
(GNU Emacs is sometimes called an “extensible editor”, but it does much
more than provide editing capabilities.
It is better to refer to Emacs as
an “extensible computing environment”. However, that phrase is quite a
mouthful.
It is easier to refer to Emacs simply as an editor.
Moreover,
everything you do in Emacs—ﬁnd the Mayan date and phases of the moon,
simplify polynomials, debug code, manage ﬁles, read letters, write books—all
these activities are kinds of editing in the most general sense of the word.)
Although Emacs Lisp is usually thought of in association only with
Emacs, it is a full computer programming language. You can use Emacs
Lisp as you would any other programming language.
Perhaps you want to understand programming; perhaps you want to ex-
tend Emacs; or perhaps you want to become a programmer. This introduc-
tion to Emacs Lisp is designed to get you started: to guide you in learning
the fundamentals of programming, and more importantly, to show you how
you can teach yourself to go further.
On Reading this Text
All through this document, you will see little sample programs you can
run inside of Emacs.
If you read this document in Info inside of GNU
Emacs, you can run the programs as they appear. (This is easy to do and
is explained when the examples are presented.) Alternatively, you can read
this introduction as a printed book while sitting beside a computer running
Emacs. (This is what I like to do; I like printed books.) If you don’t have a
running Emacs beside you, you can still read this book, but in this case, it
is best to treat it as a novel or as a travel guide to a country not yet visited:
interesting, but not the same as being there.
Much of this introduction is dedicated to walk-throughs or guided tours
of code used in GNU Emacs. These tours are designed for two purposes:
ﬁrst, to give you familiarity with real, working code (code you use every
day); and, second, to give you familiarity with the way Emacs works. It is
interesting to see how a working environment is implemented. Also, I hope
that you will pick up the habit of browsing through source code. You can
learn from it and mine it for ideas. Having GNU Emacs is like having a
dragon’s cave of treasures.
In addition to learning about Emacs as an editor and Emacs Lisp as
a programming language, the examples and guided tours will give you an

xii
Preface
opportunity to get acquainted with Emacs as a Lisp programming environ-
ment. GNU Emacs supports programming and provides tools that you will
want to become comfortable using, such as M-. (the key which invokes the
find-tag command). You will also learn about buﬀers and other objects
that are part of the environment. Learning about these features of Emacs is
like learning new routes around your home town.
Finally, I hope to convey some of the skills for using Emacs to learn
aspects of programming that you don’t know. You can often use Emacs to
help you understand what puzzles you or to ﬁnd out how to do something
new. This self-reliance is not only a pleasure, but an advantage.
For Whom This is Written
This text is written as an elementary introduction for people who are not
programmers. If you are a programmer, you may not be satisﬁed with this
primer. The reason is that you may have become expert at reading reference
manuals and be put oﬀby the way this text is organized.
An expert programmer who reviewed this text said to me:
I prefer to learn from reference manuals. I “dive into” each para-
graph, and “come up for air” between paragraphs.
When I get to the end of a paragraph, I assume that that subject
is done, ﬁnished, that I know everything I need (with the possible
exception of the case when the next paragraph starts talking about
it in more detail). I expect that a well written reference manual
will not have a lot of redundancy, and that it will have excellent
pointers to the (one) place where the information I want is.
This introduction is not written for this person!
Firstly, I try to say everything at least three times: ﬁrst, to introduce it;
second, to show it in context; and third, to show it in a diﬀerent context, or
to review it.
Secondly, I hardly ever put all the information about a subject in one
place, much less in one paragraph. To my way of thinking, that imposes
too heavy a burden on the reader. Instead I try to explain only what you
need to know at the time. (Sometimes I include a little extra information
so you won’t be surprised later when the additional information is formally
introduced.)
When you read this text, you are not expected to learn everything the ﬁrst
time. Frequently, you need only make, as it were, a ‘nodding acquaintance’
with some of the items mentioned. My hope is that I have structured the
text and given you enough hints that you will be alert to what is important,
and concentrate on it.
You will need to “dive into” some paragraphs; there is no other way to
read them. But I have tried to keep down the number of such paragraphs.

A Note for Novices
xiii
This book is intended as an approachable hill, rather than as a daunting
mountain.
This introduction to Programming in Emacs Lisp has a companion doc-
ument, The GNU Emacs Lisp Reference Manual. The reference manual has
more detail than this introduction. In the reference manual, all the infor-
mation about one topic is concentrated in one place. You should turn to it
if you are like the programmer quoted above. And, of course, after you have
read this Introduction, you will ﬁnd the Reference Manual useful when you
are writing your own programs.
Lisp History
Lisp was ﬁrst developed in the late 1950s at the Massachusetts Institute
of Technology for research in artiﬁcial intelligence. The great power of the
Lisp language makes it superior for other purposes as well, such as writing
editor commands and integrated environments.
GNU Emacs Lisp is largely inspired by Maclisp, which was written at
MIT in the 1960s. It is somewhat inspired by Common Lisp, which became
a standard in the 1980s. However, Emacs Lisp is much simpler than Common
Lisp. (The standard Emacs distribution contains an optional extensions ﬁle,
‘cl.el’, that adds many Common Lisp features to Emacs Lisp.)
A Note for Novices
If you don’t know GNU Emacs, you can still read this document prof-
itably. However, I recommend you learn Emacs, if only to learn to move
around your computer screen. You can teach yourself how to use Emacs
with the on-line tutorial. To use it, type C-h t. (This means you press and
release the ⟨CTRL⟩key and the h at the same time, and then press and release
t.)
Also, I often refer to one of Emacs’ standard commands by listing the
keys which you press to invoke the command and then giving the name of
the command in parentheses, like this: M-C-\ (indent-region). What this
means is that the indent-region command is customarily invoked by typing
M-C-\. (You can, if you wish, change the keys that are typed to invoke the
command; this is called rebinding. See Section 16.8, “Keymaps”, page 221.)
The abbreviation M-C-\ means that you type your ⟨META⟩key, ⟨CTRL⟩key
and ⟨\⟩key all at the same time. (On many modern keyboards the ⟨META⟩
key is labelled ⟨ALT⟩.) Sometimes a combination like this is called a keychord,
since it is similar to the way you play a chord on a piano. If your keyboard
does not have a ⟨META⟩key, the ⟨ESC⟩key preﬁx is used in place of it. In
this case, M-C-\ means that you press and release your ⟨ESC⟩key and then
type the ⟨CTRL⟩key and the ⟨\⟩key at the same time. But usually M-C-\
means press the ⟨CTRL⟩key along with the key that is labelled ⟨ALT⟩and, at
the same time, press the ⟨\⟩key.

xiv
Preface
In addition to typing a lone keychord, you can preﬁx what you type with
C-u, which is called the ‘universal argument’. The C-u keychord passes an
argument to the subsequent command. Thus, to indent a region of plain
text by 6 spaces, mark the region, and then type C-u 6 M-C-\. (If you do
not specify a number, Emacs either passes the number 4 to the command
or otherwise runs the command diﬀerently than it would otherwise.) See
section “Numeric Arguments” in The GNU Emacs Manual.
If you are reading this in Info using GNU Emacs, you can read through
this whole document just by pressing the space bar, ⟨SPC⟩. (To learn about
Info, type C-h i and then select Info.)
A note on terminology: when I use the word Lisp alone, I often am
referring to the various dialects of Lisp in general, but when I speak of
Emacs Lisp, I am referring to GNU Emacs Lisp in particular.
Thank You
My thanks to all who helped me with this book. My especial thanks to
Jim Blandy, Noah Friedman, Jim Kingdon, Roland McGrath, Frank Ritter,
Randy Smith, Richard M. Stallman, and Melissa Weisshaus.
My thanks
also go to both Philip Johnson and David Stampe for their patient encour-
agement. My mistakes are my own.
Robert J. Chassell

Lisp Atoms
1
1 List Processing
To the untutored eye, Lisp is a strange programming language. In Lisp
code there are parentheses everywhere. Some people even claim that the
name stands for ‘Lots of Isolated Silly Parentheses’. But the claim is un-
warranted. Lisp stands for LISt Processing, and the programming language
handles lists (and lists of lists) by putting them between parentheses. The
parentheses mark the boundaries of the list. Sometimes a list is preceded by
a single apostrophe or quotation mark, ‘’’. Lists are the basis of Lisp.
1.1 Lisp Lists
In Lisp, a list looks like this: ’(rose violet daisy buttercup). This
list is preceded by a single apostrophe. It could just as well be written as
follows, which looks more like the kind of list you are likely to be familiar
with:
’(rose
violet
daisy
buttercup)
The elements of this list are the names of the four diﬀerent ﬂowers, separated
from each other by whitespace and surrounded by parentheses, like ﬂowers
in a ﬁeld with a stone wall around them.
Lists can also have numbers in them, as in this list: (+ 2 2). This list
has a plus-sign, ‘+’, followed by two ‘2’s, each separated by whitespace.
In Lisp, both data and programs are represented the same way; that is,
they are both lists of words, numbers, or other lists, separated by white-
space and surrounded by parentheses. (Since a program looks like data, one
program may easily serve as data for another; this is a very powerful feature
of Lisp.) (Incidentally, these two parenthetical remarks are not Lisp lists,
because they contain ‘;’ and ‘.’ as punctuation marks.)
Here is another list, this time with a list inside of it:
’(this list has (a list inside of it))
The components of this list are the words ‘this’, ‘list’, ‘has’, and the
list ‘(a list inside of it)’. The interior list is made up of the words ‘a’,
‘list’, ‘inside’, ‘of’, ‘it’.
1.1.1 Lisp Atoms
In Lisp, what we have been calling words are called atoms. This term
comes from the historical meaning of the word atom, which means ‘indivis-
ible’. As far as Lisp is concerned, the words we have been using in the lists
cannot be divided into any smaller parts and still mean the same thing as
part of a program; likewise with numbers and single character symbols like

2
Chapter 1: List Processing
‘+’. On the other hand, unlike an atom, a list can be split into parts. (See
Chapter 7, “car cdr & cons Fundamental Functions”, page 81.)
In a list, atoms are separated from each other by whitespace. They can
be right next to a parenthesis.
Technically speaking, a list in Lisp consists of parentheses surrounding
atoms separated by whitespace or surrounding other lists or surrounding
both atoms and other lists.
A list can have just one atom in it or have
nothing in it at all. A list with nothing in it looks like this: (), and is called
the empty list. Unlike anything else, an empty list is considered both an
atom and a list at the same time.
The printed representation of both atoms and lists are called symbolic
expressions or, more concisely, s-expressions. The word expression by itself
can refer to either the printed representation, or to the atom or list as it
is held internally in the computer. Often, people use the term expression
indiscriminately. (Also, in many texts, the word form is used as a synonym
for expression.)
Incidentally, the atoms that make up our universe were named such when
they were thought to be indivisible; but it has been found that physical atoms
are not indivisible. Parts can split oﬀan atom or it can ﬁssion into two parts
of roughly equal size. Physical atoms were named prematurely, before their
truer nature was found. In Lisp, certain kinds of atom, such as an array, can
be separated into parts; but the mechanism for doing this is diﬀerent from
the mechanism for splitting a list. As far as list operations are concerned,
the atoms of a list are unsplittable.
As in English, the meanings of the component letters of a Lisp atom are
diﬀerent from the meaning the letters make as a word. For example, the
word for the South American sloth, the ‘ai’, is completely diﬀerent from the
two words, ‘a’, and ‘i’.
There are many kinds of atom in nature but only a few in Lisp: for
example, numbers, such as 37, 511, or 1729, and symbols, such as ‘+’, ‘foo’,
or ‘forward-line’. The words we have listed in the examples above are
all symbols. In everyday Lisp conversation, the word “atom” is not often
used, because programmers usually try to be more speciﬁc about what kind
of atom they are dealing with. Lisp programming is mostly about symbols
(and sometimes numbers) within lists.
(Incidentally, the preceding three
word parenthetical remark is a proper list in Lisp, since it consists of atoms,
which in this case are symbols, separated by whitespace and enclosed by
parentheses, without any non-Lisp punctuation.)

GNU Emacs Helps You Type Lists
3
In addition, text between double quotation marks—even sentences or
paragraphs—is an atom. Here is an example:
’(this list includes "text between quotation marks.")
In Lisp, all of the quoted text including the punctuation mark and the blank
spaces is a single atom. This kind of atom is called a string (for ‘string
of characters’) and is the sort of thing that is used for messages that a
computer can print for a human to read. Strings are a diﬀerent kind of atom
than numbers or symbols and are used diﬀerently.
1.1.2 Whitespace in Lists
The amount of whitespace in a list does not matter. From the point of
view of the Lisp language,
’(this list
looks like this)
is exactly the same as this:
’(this list looks like this)
Both examples show what to Lisp is the same list, the list made up of
the symbols ‘this’, ‘list’, ‘looks’, ‘like’, and ‘this’ in that order.
Extra whitespace and newlines are designed to make a list more readable
by humans.
When Lisp reads the expression, it gets rid of all the extra
whitespace (but it needs to have at least one space between atoms in order
to tell them apart.)
Odd as it seems, the examples we have seen cover almost all of what
Lisp lists look like! Every other list in Lisp looks more or less like one of
these examples, except that the list may be longer and more complex. In
brief, a list is between parentheses, a string is between quotation marks, a
symbol looks like a word, and a number looks like a number. (For certain
situations, square brackets, dots and a few other special characters may be
used; however, we will go quite far without them.)
1.1.3 GNU Emacs Helps You Type Lists
When you type a Lisp expression in GNU Emacs using either Lisp Interac-
tion mode or Emacs Lisp mode, you have available to you several commands
to format the Lisp expression so it is easy to read. For example, pressing
the ⟨TAB⟩key automatically indents the line the cursor is on by the right
amount. A command to properly indent the code in a region is customarily
bound to M-C-\. Indentation is designed so that you can see which elements
of a list belongs to which list—elements of a sub-list are indented more than
the elements of the enclosing list.
In addition, when you type a closing parenthesis, Emacs momentarily
jumps the cursor back to the matching opening parenthesis, so you can see
which one it is. This is very useful, since every list you type in Lisp must have

4
Chapter 1: List Processing
its closing parenthesis match its opening parenthesis. (See section “Major
Modes” in The GNU Emacs Manual, for more information about Emacs’
modes.)
1.2 Run a Program
A list in Lisp—any list—is a program ready to run. If you run it (for
which the Lisp jargon is evaluate), the computer will do one of three things:
do nothing except return to you the list itself; send you an error message; or,
treat the ﬁrst symbol in the list as a command to do something. (Usually,
of course, it is the last of these three things that you really want!)
The single apostrophe, ’, that I put in front of some of the example lists
in preceding sections is called a quote; when it precedes a list, it tells Lisp
to do nothing with the list, other than take it as it is written. But if there is
no quote preceding a list, the ﬁrst item of the list is special: it is a command
for the computer to obey. (In Lisp, these commands are called functions.)
The list (+ 2 2) shown above did not have a quote in front of it, so Lisp
understands that the + is an instruction to do something with the rest of the
list: add the numbers that follow.
If you are reading this inside of GNU Emacs in Info, here is how you
can evaluate such a list: place your cursor immediately after the right hand
parenthesis of the following list and then type C-x C-e:
(+ 2 2)
You will see the number 4 appear in the echo area. (In the jargon, what you
have just done is “evaluate the list.” The echo area is the line at the bottom
of the screen that displays or “echoes” text.) Now try the same thing with a
quoted list: place the cursor right after the following list and type C-x C-e:
’(this is a quoted list)
You will see (this is a quoted list) appear in the echo area.
In both cases, what you are doing is giving a command to the program
inside of GNU Emacs called the Lisp interpreter—giving the interpreter a
command to evaluate the expression. The name of the Lisp interpreter comes
from the word for the task done by a human who comes up with the meaning
of an expression—who “interprets” it.
You can also evaluate an atom that is not part of a list—one that is not
surrounded by parentheses; again, the Lisp interpreter translates from the
humanly readable expression to the language of the computer. But before
discussing this (see Section 1.7, “Variables”, page 10), we will discuss what
the Lisp interpreter does when you make an error.
1.3 Generate an Error Message
Partly so you won’t worry if you do it accidentally, we will now give a
command to the Lisp interpreter that generates an error message. This is a

Generate an Error Message
5
harmless activity; and indeed, we will often try to generate error messages
intentionally. Once you understand the jargon, error messages can be in-
formative. Instead of being called “error” messages, they should be called
“help” messages. They are like signposts to a traveller in a strange country;
deciphering them can be hard, but once understood, they can point the way.
The error message is generated by a built-in GNU Emacs debugger. We
will ‘enter the debugger’. You get out of the debugger by typing q.
What we will do is evaluate a list that is not quoted and does not have
a meaningful command as its ﬁrst element. Here is a list almost exactly the
same as the one we just used, but without the single-quote in front of it.
Position the cursor right after it and type C-x C-e:
(this is an unquoted list)
What you see depends on which version of Emacs you are running. GNU
Emacs version 21 provides more information than version 20 and before.
First, the more recent result of generating an error; then the earlier, version
20 result.
In GNU Emacs version 21, a ‘*Backtrace*’ window will open up and you
will see the following in it:
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
(this is an unquoted list)
eval((this is an unquoted list))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
Your cursor will be in this window (you may have to wait a few seconds
before it becomes visible). To quit the debugger and make the debugger
window go away, type:
q
Please type q right now, so you become conﬁdent that you can get out of
the debugger. Then, type C-x C-e again to re-enter it.
Based on what we already know, we can almost read this error message.
You read the ‘*Backtrace*’ buﬀer from the bottom up; it tells you what
Emacs did. When you typed C-x C-e, you made an interactive call to the
command eval-last-sexp. eval is an abbreviation for ‘evaluate’ and sexp
is an abbreviation for ‘symbolic expression’. The command means ‘evaluate
last symbolic expression’, which is the expression just before your cursor.
Each line above tells you what the Lisp interpreter evaluated next. The
most recent action is at the top. The buﬀer is called the ‘*Backtrace*’
buﬀer because it enables you to track Emacs backwards.

6
Chapter 1: List Processing
At the top of the ‘*Backtrace*’ buﬀer, you see the line:
Debugger entered--Lisp error: (void-function this)
The Lisp interpreter tried to evaluate the ﬁrst atom of the list, the word
‘this’. It is this action that generated the error message ‘void-function
this’.
The message contains the words ‘void-function’ and ‘this’.
The word ‘function’ was mentioned once before. It is a very important
word. For our purposes, we can deﬁne it by saying that a function is a set
of instructions to the computer that tell the computer to do something.
Now we can begin to understand the error message: ‘void-function
this’. The function (that is, the word ‘this’) does not have a deﬁnition of
any set of instructions for the computer to carry out.
The slightly odd word, ‘void-function’, is designed to cover the way
Emacs Lisp is implemented, which is that when a symbol does not have a
function deﬁnition attached to it, the place that should contain the instruc-
tions is ‘void’.
On the other hand, since we were able to add 2 plus 2 successfully, by
evaluating (+ 2 2), we can infer that the symbol + must have a set of in-
structions for the computer to obey and those instructions must be to add
the numbers that follow the +.
In GNU Emacs version 20, and in earlier versions, you will see only one
line of error message; it will appear in the echo area and look like this:
Symbol’s function definition is void: this
(Also, your terminal may beep at you—some do, some don’t; and others
blink. This is just a device to get your attention.) The message goes away
as soon as you type another key, even just to move the cursor.
We know the meaning of the word ‘Symbol’. It refers to the ﬁrst atom of
the list, the word ‘this’. The word ‘function’ refers to the instructions that
tell the computer what to do. (Technically, the symbol tells the computer
where to ﬁnd the instructions, but this is a complication we can ignore for
the moment.)
The error message can be understood: ‘Symbol’s function definition
is void: this’. The symbol (that is, the word ‘this’) lacks instructions for
the computer to carry out.
1.4 Symbol Names and Function Deﬁnitions
We can articulate another characteristic of Lisp based on what we have
discussed so far—an important characteristic: a symbol, like +, is not itself
the set of instructions for the computer to carry out. Instead, the symbol
is used, perhaps temporarily, as a way of locating the deﬁnition or set of
instructions. What we see is the name through which the instructions can
be found.
Names of people work the same way.
I can be referred to as

The Lisp Interpreter
7
‘Bob’; however, I am not the letters ‘B’, ‘o’, ‘b’ but am the consciousness
consistently associated with a particular life-form. The name is not me, but
it can be used to refer to me.
In Lisp, one set of instructions can be attached to several names. For
example, the computer instructions for adding numbers can be linked to the
symbol plus as well as to the symbol + (and are in some dialects of Lisp).
Among humans, I can be referred to as ‘Robert’ as well as ‘Bob’ and by
other words as well.
On the other hand, a symbol can have only one function deﬁnition at-
tached to it at a time. Otherwise, the computer would be confused as to
which deﬁnition to use. If this were the case among people, only one person
in the world could be named ‘Bob’. However, the function deﬁnition to which
the name refers can be changed readily. (See Section 3.2, “Install a Function
Deﬁnition”, page 31.)
Since Emacs Lisp is large, it is customary to name symbols in a way that
identiﬁes the part of Emacs to which the function belongs. Thus, all the
names for functions that deal with Texinfo start with ‘texinfo-’ and those
for functions that deal with reading mail start with ‘rmail-’.
1.5 The Lisp Interpreter
Based on what we have seen, we can now start to ﬁgure out what the Lisp
interpreter does when we command it to evaluate a list. First, it looks to see
whether there is a quote before the list; if there is, the interpreter just gives
us the list. On the other hand, if there is no quote, the interpreter looks at
the ﬁrst element in the list and sees whether it has a function deﬁnition. If
it does, the interpreter carries out the instructions in the function deﬁnition.
Otherwise, the interpreter prints an error message.
This is how Lisp works. Simple. There are added complications which
we will get to in a minute, but these are the fundamentals. Of course, to
write Lisp programs, you need to know how to write function deﬁnitions and
attach them to names, and how to do this without confusing either yourself
or the computer.
Now, for the ﬁrst complication. In addition to lists, the Lisp interpreter
can evaluate a symbol that is not quoted and does not have parentheses
around it.
The Lisp interpreter will attempt to determine the symbol’s
value as a variable. This situation is described in the section on variables.
(See Section 1.7, “Variables”, page 10.)
The second complication occurs because some functions are unusual and
do not work in the usual manner. Those that don’t are called special forms.
They are used for special jobs, like deﬁning a function, and there are not
many of them. In the next few chapters, you will be introduced to several
of the more important special forms.

8
Chapter 1: List Processing
The third and ﬁnal complication is this: if the function that the Lisp
interpreter is looking at is not a special form, and if it is part of a list, the
Lisp interpreter looks to see whether the list has a list inside of it. If there
is an inner list, the Lisp interpreter ﬁrst ﬁgures out what it should do with
the inside list, and then it works on the outside list. If there is yet another
list embedded inside the inner list, it works on that one ﬁrst, and so on.
It always works on the innermost list ﬁrst. The interpreter works on the
innermost list ﬁrst, to evaluate the result of that list. The result may be
used by the enclosing expression.
Otherwise, the interpreter works left to right, from one expression to the
next.
1.5.1 Byte Compiling
One other aspect of interpreting: the Lisp interpreter is able to interpret
two kinds of entity: humanly readable code, on which we will focus exclu-
sively, and specially processed code, called byte compiled code, which is not
humanly readable. Byte compiled code runs faster than humanly readable
code.
You can transform humanly readable code into byte compiled code by
running one of the compile commands such as byte-compile-file. Byte
compiled code is usually stored in a ﬁle that ends with a ‘.elc’ exten-
sion rather than a ‘.el’ extension. You will see both kinds of ﬁle in the
‘emacs/lisp’ directory; the ﬁles to read are those with ‘.el’ extensions.
As a practical matter, for most things you might do to customize or
extend Emacs, you do not need to byte compile; and I will not discuss
the topic here. See section “Byte Compilation” in The GNU Emacs Lisp
Reference Manual, for a full description of byte compilation.
1.6 Evaluation
When the Lisp interpreter works on an expression, the term for the ac-
tivity is called evaluation. We say that the interpreter ‘evaluates the expres-
sion’. I’ve used this term several times before. The word comes from its
use in everyday language, ‘to ascertain the value or amount of; to appraise’,
according to Webster’s New Collegiate Dictionary.
After evaluating an expression, the Lisp interpreter will most likely return
the value that the computer produces by carrying out the instructions it
found in the function deﬁnition, or perhaps it will give up on that function
and produce an error message. (The interpreter may also ﬁnd itself tossed,
so to speak, to a diﬀerent function or it may attempt to repeat continually
what it is doing for ever and ever in what is called an ‘inﬁnite loop’. These
actions are less common; and we can ignore them.) Most frequently, the
interpreter returns a value.

Evaluating Inner Lists
9
At the same time the interpreter returns a value, it may do something
else as well, such as move a cursor or copy a ﬁle; this other kind of action
is called a side eﬀect. Actions that we humans think are important, such as
printing results, are often “side eﬀects” to the Lisp interpreter. The jargon
can sound peculiar, but it turns out that it is fairly easy to learn to use side
eﬀects.
In summary, evaluating a symbolic expression most commonly causes the
Lisp interpreter to return a value and perhaps carry out a side eﬀect; or else
produce an error.
1.6.1 Evaluating Inner Lists
If evaluation applies to a list that is inside another list, the outer list may
use the value returned by the ﬁrst evaluation as information when the outer
list is evaluated. This explains why inner expressions are evaluated ﬁrst: the
values they return are used by the outer expressions.
We can investigate this process by evaluating another addition example.
Place your cursor after the following expression and type C-x C-e:
(+ 2 (+ 3 3))
The number 8 will appear in the echo area.
What happens is that the Lisp interpreter ﬁrst evaluates the inner ex-
pression, (+ 3 3), for which the value 6 is returned; then it evaluates the
outer expression as if it were written (+ 2 6), which returns the value 8.
Since there are no more enclosing expressions to evaluate, the interpreter
prints that value in the echo area.
Now it is easy to understand the name of the command invoked by the
keystrokes C-x C-e: the name is eval-last-sexp.
The letters sexp are
an abbreviation for ‘symbolic expression’, and eval is an abbreviation for
‘evaluate’. The command means ‘evaluate last symbolic expression’.
As an experiment, you can try evaluating the expression by putting the
cursor at the beginning of the next line immediately following the expression,
or inside the expression.
Here is another copy of the expression:
(+ 2 (+ 3 3))
If you place the cursor at the beginning of the blank line that immediately
follows the expression and type C-x C-e, you will still get the value 8 printed
in the echo area. Now try putting the cursor inside the expression. If you
put it right after the next to last parenthesis (so it appears to sit on top
of the last parenthesis), you will get a 6 printed in the echo area! This is
because the command evaluates the expression (+ 3 3).
Now put the cursor immediately after a number. Type C-x C-e and you
will get the number itself. In Lisp, if you evaluate a number, you get the
number itself—this is how numbers diﬀer from symbols. If you evaluate a
list starting with a symbol like +, you will get a value returned that is the

10
Chapter 1: List Processing
result of the computer carrying out the instructions in the function deﬁnition
attached to that name. If a symbol by itself is evaluated, something diﬀerent
happens, as we will see in the next section.
1.7 Variables
In Emacs Lisp, a symbol can have a value attached to it just as it can
have a function deﬁnition attached to it. The two are diﬀerent. The function
deﬁnition is a set of instructions that a computer will obey. A value, on the
other hand, is something, such as number or a name, that can vary (which
is why such a symbol is called a variable). The value of a symbol can be any
expression in Lisp, such as a symbol, number, list, or string. A symbol that
has a value is often called a variable.
A symbol can have both a function deﬁnition and a value attached to it
at the same time. Or it can have just one or the other. The two are separate.
This is somewhat similar to the way the name Cambridge can refer to the
city in Massachusetts and have some information attached to the name as
well, such as “great programming center”.
Another way to think about this is to imagine a symbol as being a chest of
drawers. The function deﬁnition is put in one drawer, the value in another,
and so on. What is put in the drawer holding the value can be changed
without aﬀecting the contents of the drawer holding the function deﬁnition,
and vice-versa.
The variable fill-column illustrates a symbol with a value attached to
it: in every GNU Emacs buﬀer, this symbol is set to some value, usually 72
or 70, but sometimes to some other value. To ﬁnd the value of this symbol,
evaluate it by itself. If you are reading this in Info inside of GNU Emacs,
you can do this by putting the cursor after the symbol and typing C-x C-e:
fill-column
After I typed C-x C-e, Emacs printed the number 72 in my echo area. This
is the value for which fill-column is set for me as I write this. It may
be diﬀerent for you in your Info buﬀer. Notice that the value returned as
a variable is printed in exactly the same way as the value returned by a
function carrying out its instructions. From the point of view of the Lisp
interpreter, a value returned is a value returned. What kind of expression it
came from ceases to matter once the value is known.
A symbol can have any value attached to it or, to use the jargon, we can
bind the variable to a value: to a number, such as 72; to a string, "such as
this"; to a list, such as (spruce pine oak); we can even bind a variable to
a function deﬁnition.
A symbol can be bound to a value in several ways.
See Section 1.9,
“Setting the Value of a Variable”, page 17, for information about one way
to do this.

Error Message for a Symbol Without a Value
11
1.7.1 Error Message for a Symbol Without a Function
When we evaluated fill-column to ﬁnd its value as a variable, we did
not place parentheses around the word. This is because we did not intend
to use it as a function name.
If fill-column were the ﬁrst or only element of a list, the Lisp interpreter
would attempt to ﬁnd the function deﬁnition attached to it.
But fill-
column has no function deﬁnition. Try evaluating this:
(fill-column)
In GNU Emacs version 21, you will create a ‘*Backtrace*’ buﬀer that says:
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
(fill-column)
eval((fill-column))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
(Remember, to quit the debugger and make the debugger window go away,
type q in the ‘*Backtrace*’ buﬀer.)
In GNU Emacs 20 and before, you will produce an error message that
says:
Symbol’s function definition is void: fill-column
(The message will go away away as soon as you move the cursor or type
another key.)
1.7.2 Error Message for a Symbol Without a Value
If you attempt to evaluate a symbol that does not have a value bound
to it, you will receive an error message. You can see this by experimenting
with our 2 plus 2 addition. In the following expression, put your cursor right
after the +, before the ﬁrst number 2, type C-x C-e:
(+ 2 2)
In GNU Emacs 21, you will create a ‘*Backtrace*’ buﬀer that says:
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
eval(+)
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
(As with the other times we entered the debugger, you can quit by typing q
in the ‘*Backtrace*’ buﬀer.)

12
Chapter 1: List Processing
This backtrace is diﬀerent from the very ﬁrst error message we saw,
which said, ‘Debugger entered--Lisp error: (void-function this)’. In
this case, the function does not have a value as a variable; while in the other
error message, the function (the word ‘this’) did not have a deﬁnition.
In this experiment with the +, what we did was cause the Lisp interpreter
to evaluate the + and look for the value of the variable instead of the function
deﬁnition. We did this by placing the cursor right after the symbol rather
than after the parenthesis of the enclosing list as we did before. As a conse-
quence, the Lisp interpreter evaluated the preceding s-expression, which in
this case was the + by itself.
Since + does not have a value bound to it, just the function deﬁnition,
the error message reported that the symbol’s value as a variable was void.
In GNU Emacs version 20 and before, your error message will say:
Symbol’s value as variable is void: +
The meaning is the same as in GNU Emacs 21.
1.8 Arguments
To see how information is passed to functions, let’s look again at our old
standby, the addition of two plus two. In Lisp, this is written as follows:
(+ 2 2)
If you evaluate this expression, the number 4 will appear in your echo
area. What the Lisp interpreter does is add the numbers that follow the +.
The numbers added by + are called the arguments of the function +.
These numbers are the information that is given to or passed to the function.
The word ‘argument’ comes from the way it is used in mathematics and
does not refer to a disputation between two people; instead it refers to the
information presented to the function, in this case, to the +. In Lisp, the
arguments to a function are the atoms or lists that follow the function. The
values returned by the evaluation of these atoms or lists are passed to the
function. Diﬀerent functions require diﬀerent numbers of arguments; some
functions require none at all.1
1 It is curious to track the path by which the word ‘argument’ came to have two diﬀer-
ent meanings, one in mathematics and the other in everyday English. According to
the Oxford English Dictionary, the word derives from the Latin for ‘to make clear,
prove’; thus it came to mean, by one thread of derivation, ‘the evidence oﬀered as
proof’, which is to say, ‘the information oﬀered’, which led to its meaning in Lisp.
But in the other thread of derivation, it came to mean ‘to assert in a manner against
which others may make counter assertions’, which led to the meaning of the word as a
disputation. (Note here that the English word has two diﬀerent deﬁnitions attached to
it at the same time. By contrast, in Emacs Lisp, a symbol cannot have two diﬀerent
function deﬁnitions at the same time.)

An Argument as the Value of a Variable or List
13
1.8.1 Arguments’ Data Types
The type of data that should be passed to a function depends on what
kind of information it uses. The arguments to a function such as + must
have values that are numbers, since + adds numbers. Other functions use
diﬀerent kinds of data for their arguments.
For example, the concat function links together or unites two or more
strings of text to produce a string. The arguments are strings. Concate-
nating the two character strings abc, def produces the single string abcdef.
This can be seen by evaluating the following:
(concat "abc" "def")
The value produced by evaluating this expression is "abcdef".
A function such as substring uses both a string and numbers as argu-
ments. The function returns a part of the string, a substring of the ﬁrst
argument. This function takes three arguments. Its ﬁrst argument is the
string of characters, the second and third arguments are numbers that in-
dicate the beginning and end of the substring. The numbers are a count
of the number of characters (including spaces and punctuations) from the
beginning of the string.
For example, if you evaluate the following:
(substring "The quick brown fox jumped." 16 19)
you will see "fox" appear in the echo area. The arguments are the string
and the two numbers.
Note that the string passed to substring is a single atom even though
it is made up of several words separated by spaces. Lisp counts everything
between the two quotation marks as part of the string, including the spaces.
You can think of the substring function as a kind of ‘atom smasher’ since it
takes an otherwise indivisible atom and extracts a part. However, substring
is only able to extract a substring from an argument that is a string, not
from another type of atom such as a number or symbol.
1.8.2 An Argument as the Value of a Variable or List
An argument can be a symbol that returns a value when it is evaluated.
For example, when the symbol fill-column by itself is evaluated, it returns
a number. This number can be used in an addition.
Position the cursor after the following expression and type C-x C-e:
(+ 2 fill-column)
The value will be a number two more than what you get by evaluating
fill-column alone. For me, this is 74, because the value of fill-column is
72.
As we have just seen, an argument can be a symbol that returns a value
when evaluated. In addition, an argument can be a list that returns a value
when it is evaluated. For example, in the following expression, the arguments

14
Chapter 1: List Processing
to the function concat are the strings "The " and " red foxes." and the
list (number-to-string (+ 2 fill-column)).
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
If you evaluate this expression—and if, as with my Emacs, fill-column
evaluates to 72—"The 74 red foxes." will appear in the echo area. (Note
that you must put spaces after the word ‘The’ and before the word ‘red’
so they will appear in the ﬁnal string.
The function number-to-string
converts the integer that the addition function returns to a string. number-
to-string is also known as int-to-string.)
1.8.3 Variable Number of Arguments
Some functions, such as concat, + or *, take any number of arguments.
(The * is the symbol for multiplication.) This can be seen by evaluating
each of the following expressions in the usual way. What you will see in the
echo area is printed in this text after ‘⇒’, which you may read as ‘evaluates
to’.
In the ﬁrst set, the functions have no arguments:
(+)
⇒0
(*)
⇒1
In this set, the functions have one argument each:
(+ 3)
⇒3
(* 3)
⇒3
In this set, the functions have three arguments each:
(+ 3 4 5) ⇒12
(* 3 4 5) ⇒60
1.8.4 Using the Wrong Type Object as an Argument
When a function is passed an argument of the wrong type, the Lisp
interpreter produces an error message. For example, the + function expects
the values of its arguments to be numbers. As an experiment we can pass it
the quoted symbol hello instead of a number. Position the cursor after the
following expression and type C-x C-e:
(+ 2 ’hello)
When you do this you will generate an error message. What has happened is
that + has tried to add the 2 to the value returned by ’hello, but the value
returned by ’hello is the symbol hello, not a number. Only numbers can
be added. So + could not carry out its addition.

Using the Wrong Type Object as an Argument
15
In GNU Emacs version 21, you will create and enter a ‘*Backtrace*’
buﬀer that says:
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
(wrong-type-argument number-or-marker-p hello)
+(2 hello)
eval((+ 2 (quote hello)))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
As usual, the error message tries to be helpful and makes sense after you
learn how to read it.
The ﬁrst part of the error message is straightforward; it says ‘wrong type
argument’. Next comes the mysterious jargon word ‘number-or-marker-p’.
This word is trying to tell you what kind of argument the + expected.
The symbol number-or-marker-p says that the Lisp interpreter is try-
ing to determine whether the information presented it (the value of the
argument) is a number or a marker (a special object representing a buﬀer
position). What it does is test to see whether the + is being given numbers to
add. It also tests to see whether the argument is something called a marker,
which is a speciﬁc feature of Emacs Lisp. (In Emacs, locations in a buﬀer
are recorded as markers.
When the mark is set with the C-@ or C-⟨SPC⟩
command, its position is kept as a marker. The mark can be considered a
number—the number of characters the location is from the beginning of the
buﬀer.) In Emacs Lisp, + can be used to add the numeric value of marker
positions as numbers.
The ‘p’ of number-or-marker-p is the embodiment of a practice started
in the early days of Lisp programming. The ‘p’ stands for ‘predicate’. In the
jargon used by the early Lisp researchers, a predicate refers to a function
to determine whether some property is true or false. So the ‘p’ tells us that
number-or-marker-p is the name of a function that determines whether it
is true or false that the argument supplied is a number or a marker. Other
Lisp symbols that end in ‘p’ include zerop, a function that tests whether its
argument has the value of zero, and listp, a function that tests whether its
argument is a list.
Finally, the last part of the error message is the symbol hello. This is the
value of the argument that was passed to +. If the addition had been passed
the correct type of object, the value passed would have been a number, such
as 37, rather than a symbol like hello. But then you would not have got
the error message.

16
Chapter 1: List Processing
In GNU Emacs version 20 and before, the echo area displays an error
message that says:
Wrong type argument: number-or-marker-p, hello
This says, in diﬀerent words, the same as the top line of the ‘*Backtrace*’
buﬀer.
1.8.5 The message Function
Like +, the message function takes a variable number of arguments. It is
used to send messages to the user and is so useful that we will describe it
here.
A message is printed in the echo area.
For example, you can print a
message in your echo area by evaluating the following list:
(message "This message appears in the echo area!")
The whole string between double quotation marks is a single argument
and is printed in toto. (Note that in this example, the message itself will ap-
pear in the echo area within double quotes; that is because you see the value
returned by the message function. In most uses of message in programs that
you write, the text will be printed in the echo area as a side-eﬀect, without
the quotes. See Section 3.3.1, “multiply-by-seven in detail”, page 34, for
an example of this.)
However, if there is a ‘%s’ in the quoted string of characters, the message
function does not print the ‘%s’ as such, but looks to the argument that
follows the string. It evaluates the second argument and prints the value at
the location in the string where the ‘%s’ is.
You can see this by positioning the cursor after the following expression
and typing C-x C-e:
(message "The name of this buffer is: %s." (buffer-name))
In Info, "The name of this buffer is: *info*." will appear in the echo
area. The function buffer-name returns the name of the buﬀer as a string,
which the message function inserts in place of %s.
To print a value as an integer, use ‘%d’ in the same way as ‘%s’. For
example, to print a message in the echo area that states the value of the
fill-column, evaluate the following:
(message "The value of fill-column is %d." fill-column)
On my system, when I evaluate this list, "The value of fill-column is
72." appears in my echo area2.
If there is more than one ‘%s’ in the quoted string, the value of the ﬁrst
argument following the quoted string is printed at the location of the ﬁrst
‘%s’ and the value of the second argument is printed at the location of the
second ‘%s’, and so on.
2 Actually, you can use %s to print a number. It is non-speciﬁc. %d prints only the part
of a number left of a decimal point, and not anything that is not a number.

Using set
17
For example, if you evaluate the following,
(message "There are %d %s in the office!"
(- fill-column 14) "pink elephants")
a rather whimsical message will appear in your echo area. On my system it
says, "There are 58 pink elephants in the office!".
The expression (- fill-column 14) is evaluated and the resulting num-
ber is inserted in place of the ‘%d’; and the string in double quotes, "pink
elephants", is treated as a single argument and inserted in place of the
‘%s’. (That is to say, a string between double quotes evaluates to itself, like
a number.)
Finally, here is a somewhat complex example that not only illustrates
the computation of a number, but also shows how you can use an expression
within an expression to generate the text that is substituted for ‘%s’:
(message "He saw %d %s"
(- fill-column 34)
(concat "red "
(substring
"The quick brown foxes jumped." 16 21)
" leaping."))
In this example, message has three arguments: the string, "He saw %d
%s", the expression, (- fill-column 32), and the expression beginning with
the function concat. The value resulting from the evaluation of (- fill-
column 32) is inserted in place of the ‘%d’; and the value returned by the
expression beginning with concat is inserted in place of the ‘%s’.
When I evaluate the expression, the message "He saw 38 red foxes
leaping." appears in my echo area.
1.9 Setting the Value of a Variable
There are several ways by which a variable can be given a value. One of
the ways is to use either the function set or the function setq. Another way
is to use let (see Section 3.6, “let”, page 36). (The jargon for this process
is to bind a variable to a value.)
The following sections not only describe how set and setq work but also
illustrate how arguments are passed.
1.9.1 Using set
To set the value of the symbol flowers to the list ’(rose violet daisy
buttercup), evaluate the following expression by positioning the cursor after
the expression and typing C-x C-e.
(set ’flowers ’(rose violet daisy buttercup))

18
Chapter 1: List Processing
The list (rose violet daisy buttercup) will appear in the echo area. This
is what is returned by the set function. As a side eﬀect, the symbol flowers
is bound to the list ; that is, the symbol flowers, which can be viewed as a
variable, is given the list as its value. (This process, by the way, illustrates
how a side eﬀect to the Lisp interpreter, setting the value, can be the primary
eﬀect that we humans are interested in. This is because every Lisp function
must return a value if it does not get an error, but it will only have a side
eﬀect if it is designed to have one.)
After evaluating the set expression, you can evaluate the symbol flowers
and it will return the value you just set. Here is the symbol. Place your
cursor after it and type C-x C-e.
flowers
When you evaluate flowers, the list (rose violet daisy buttercup) ap-
pears in the echo area.
Incidentally, if you evaluate ’flowers, the variable with a quote in front
of it, what you will see in the echo area is the symbol itself, flowers. Here
is the quoted symbol, so you can try this:
’flowers
Note also, that when you use set, you need to quote both arguments to
set, unless you want them evaluated. Since we do not want either argument
evaluated, neither the variable flowers nor the list (rose violet daisy
buttercup), both are quoted. (When you use set without quoting its ﬁrst
argument, the ﬁrst argument is evaluated before anything else is done. If
you did this and flowers did not have a value already, you would get an
error message that the ‘Symbol’s value as variable is void’; on the other
hand, if flowers did return a value after it was evaluated, the set would
attempt to set the value that was returned. There are situations where this
is the right thing for the function to do; but such situations are rare.)
1.9.2 Using setq
As a practical matter, you almost always quote the ﬁrst argument to set.
The combination of set and a quoted ﬁrst argument is so common that it
has its own name: the special form setq. This special form is just like set
except that the ﬁrst argument is quoted automatically, so you don’t need to
type the quote mark yourself. Also, as an added convenience, setq permits
you to set several diﬀerent variables to diﬀerent values, all in one expression.
To set the value of the variable carnivores to the list ’(lion tiger
leopard) using setq, the following expression is used:
(setq carnivores ’(lion tiger leopard))
This is exactly the same as using set except the ﬁrst argument is automat-
ically quoted by setq. (The ‘q’ in setq means quote.)

Counting
19
With set, the expression would look like this:
(set ’carnivores ’(lion tiger leopard))
Also, setq can be used to assign diﬀerent values to diﬀerent variables.
The ﬁrst argument is bound to the value of the second argument, the third
argument is bound to the value of the fourth argument, and so on.
For
example, you could use the following to assign a list of trees to the symbol
trees and a list of herbivores to the symbol herbivores:
(setq trees ’(pine fir oak maple)
herbivores ’(gazelle antelope zebra))
(The expression could just as well have been on one line, but it might not
have ﬁt on a page; and humans ﬁnd it easier to read nicely formatted lists.)
Although I have been using the term ‘assign’, there is another way of
thinking about the workings of set and setq; and that is to say that set
and setq make the symbol point to the list. This latter way of thinking is
very common and in forthcoming chapters we shall come upon at least one
symbol that has ‘pointer’ as part of its name. The name is chosen because the
symbol has a value, speciﬁcally a list, attached to it; or, expressed another
way, the symbol is set to “point” to the list.
1.9.3 Counting
Here is an example that shows how to use setq in a counter. You might
use this to count how many times a part of your program repeats itself. First
set a variable to zero; then add one to the number each time the program
repeats itself. To do this, you need a variable that serves as a counter, and
two expressions: an initial setq expression that sets the counter variable to
zero; and a second setq expression that increments the counter each time it
is evaluated.
(setq counter 0)
; Let’s call this the initializer.
(setq counter (+ counter 1))
; This is the incrementer.
counter
; This is the counter.
(The text following the ‘;’ are comments.
See Section 3.2.1, “Change a
Function Deﬁnition”, page 32.)
If you evaluate the ﬁrst of these expressions, the initializer, (setq
counter 0), and then evaluate the third expression, counter, the number 0
will appear in the echo area. If you then evaluate the second expression, the
incrementer, (setq counter (+ counter 1)), the counter will get the value
1. So if you again evaluate counter, the number 1 will appear in the echo
area. Each time you evaluate the second expression, the value of the counter
will be incremented.
When you evaluate the incrementer, (setq counter (+ counter 1)), the
Lisp interpreter ﬁrst evaluates the innermost list; this is the addition. In

20
Chapter 1: List Processing
order to evaluate this list, it must evaluate the variable counter and the
number 1. When it evaluates the variable counter, it receives its current
value.
It passes this value and the number 1 to the + which adds them
together. The sum is then returned as the value of the inner list and passed
to the setq which sets the variable counter to this new value. Thus, the
value of the variable, counter, is changed.
1.10 Summary
Learning Lisp is like climbing a hill in which the ﬁrst part is the steepest.
You have now climbed the most diﬃcult part; what remains becomes easier
as you progress onwards.
In summary,
• Lisp programs are made up of expressions, which are lists or single
atoms.
• Lists are made up of zero or more atoms or inner lists, separated by
whitespace and surrounded by parentheses. A list can be empty.
• Atoms are multi-character symbols, like forward-paragraph, single
character symbols like +, strings of characters between double quota-
tion marks, or numbers.
• A number evaluates to itself.
• A string between double quotes also evaluates to itself.
• When you evaluate a symbol by itself, its value is returned.
• When you evaluate a list, the Lisp interpreter looks at the ﬁrst symbol
in the list and then at the function deﬁnition bound to that symbol.
Then the instructions in the function deﬁnition are carried out.
• A single-quote, ’, tells the Lisp interpreter that it should return the
following expression as written, and not evaluate it as it would if the
quote were not there.
• Arguments are the information passed to a function. The arguments to
a function are computed by evaluating the rest of the elements of the
list of which the function is the ﬁrst element.
• A function always returns a value when it is evaluated (unless it gets
an error); in addition, it may also carry out some action called a “side
eﬀect”. In many cases, a function’s primary purpose is to create a side
eﬀect.
1.11 Exercises
A few simple exercises:
• Generate an error message by evaluating an appropriate symbol that is
not within parentheses.

Exercises
21
• Generate an error message by evaluating an appropriate symbol that is
between parentheses.
• Create a counter that increments by two rather than one.
• Write an expression that prints a message in the echo area when evalu-
ated.

22
Chapter 1: List Processing

Buﬀer Names
23
2 Practicing Evaluation
Before learning how to write a function deﬁnition in Emacs Lisp, it is
useful to spend a little time evaluating various expressions that have already
been written. These expressions will be lists with the functions as their ﬁrst
(and often only) element. Since some of the functions associated with buﬀers
are both simple and interesting, we will start with those. In this section, we
will evaluate a few of these. In another section, we will study the code of
several other buﬀer-related functions, to see how they were written.
Whenever you give an editing command to Emacs Lisp, such as the com-
mand to move the cursor or to scroll the screen, you are evaluating an ex-
pression, the ﬁrst element of which is a function. This is how Emacs works.
When you type keys, you cause the Lisp interpreter to evaluate an expres-
sion and that is how you get your results. Even typing plain text involves
evaluating an Emacs Lisp function, in this case, one that uses self-insert-
command, which simply inserts the character you typed. The functions you
evaluate by typing keystrokes are called interactive functions, or commands;
how you make a function interactive will be illustrated in the chapter on
how to write function deﬁnitions. See Section 3.3, “Making a Function In-
teractive”, page 33.
In addition to typing keyboard commands, we have seen a second way
to evaluate an expression: by positioning the cursor after a list and typing
C-x C-e. This is what we will do in the rest of this section. There are other
ways to evaluate an expression as well; these will be described as we come
to them.
Besides being used for practicing evaluation, the functions shown in the
next few sections are important in their own right. A study of these functions
makes clear the distinction between buﬀers and ﬁles, how to switch to a
buﬀer, and how to determine a location within it.
2.1 Buﬀer Names
The two functions, buffer-name and buffer-file-name, show the diﬀer-
ence between a ﬁle and a buﬀer. When you evaluate the following expression,
(buffer-name), the name of the buﬀer appears in the echo area. When you
evaluate (buffer-file-name), the name of the ﬁle to which the buﬀer refers
appears in the echo area. Usually, the name returned by (buffer-name) is
the same as the name of the ﬁle to which it refers, and the name returned
by (buffer-file-name) is the full path-name of the ﬁle.
A ﬁle and a buﬀer are two diﬀerent entities. A ﬁle is information recorded
permanently in the computer (unless you delete it). A buﬀer, on the other
hand, is information inside of Emacs that will vanish at the end of the editing
session (or when you kill the buﬀer). Usually, a buﬀer contains information
that you have copied from a ﬁle; we say the buﬀer is visiting that ﬁle. This
copy is what you work on and modify. Changes to the buﬀer do not change

24
Chapter 2: Practicing Evaluation
the ﬁle, until you save the buﬀer. When you save the buﬀer, the buﬀer is
copied to the ﬁle and is thus saved permanently.
If you are reading this in Info inside of GNU Emacs, you can evaluate
each of the following expressions by positioning the cursor after it and typing
C-x C-e.
(buffer-name)
(buffer-file-name)
When I do this, ‘"introduction.texinfo"’ is the value returned by eval-
uating (buffer-name), and ‘"/gnu/work/intro/introduction.texinfo"’
is the value returned by evaluating (buffer-file-name). The former is the
name of the buﬀer and the latter is the name of the ﬁle. (In the expres-
sions, the parentheses tell the Lisp interpreter to treat buffer-name and
buffer-file-name as functions; without the parentheses, the interpreter
would attempt to evaluate the symbols as variables. See Section 1.7, “Vari-
ables”, page 10.)
In spite of the distinction between ﬁles and buﬀers, you will often ﬁnd
that people refer to a ﬁle when they mean a buﬀer and vice-versa. Indeed,
most people say, “I am editing a ﬁle,” rather than saying, “I am editing a
buﬀer which I will soon save to a ﬁle.” It is almost always clear from context
what people mean. When dealing with computer programs, however, it is
important to keep the distinction in mind, since the computer is not as smart
as a person.
The word ‘buﬀer’, by the way, comes from the meaning of the word as
a cushion that deadens the force of a collision. In early computers, a buﬀer
cushioned the interaction between ﬁles and the computer’s central processing
unit. The drums or tapes that held a ﬁle and the central processing unit
were pieces of equipment that were very diﬀerent from each other, working
at their own speeds, in spurts. The buﬀer made it possible for them to work
together eﬀectively. Eventually, the buﬀer grew from being an intermediary,
a temporary holding place, to being the place where work is done. This
transformation is rather like that of a small seaport that grew into a great
city: once it was merely the place where cargo was warehoused temporarily
before being loaded onto ships; then it became a business and cultural center
in its own right.
Not all buﬀers are associated with ﬁles. For example, when you start
an Emacs session by typing the command emacs alone, without naming any
ﬁles, Emacs will start with the ‘*scratch*’ buﬀer on the screen. This buﬀer
is not visiting any ﬁle. Similarly, a ‘*Help*’ buﬀer is not associated with
any ﬁle.
If you switch to the ‘*scratch*’ buﬀer, type (buffer-name), position
the cursor after it, and type C-x C-e to evaluate the expression, the name
"*scratch*" is returned and will appear in the echo area. "*scratch*"
is the name of the buﬀer. However, if you type (buffer-file-name) in

Getting Buﬀers
25
the ‘*scratch*’ buﬀer and evaluate that, nil will appear in the echo area.
nil is from the Latin word for ‘nothing’; in this case, it means that the
‘*scratch*’ buﬀer is not associated with any ﬁle. (In Lisp, nil is also used
to mean ‘false’ and is a synonym for the empty list, ().)
Incidentally, if you are in the ‘*scratch*’ buﬀer and want the value
returned by an expression to appear in the ‘*scratch*’ buﬀer itself rather
than in the echo area, type C-u C-x C-e instead of C-x C-e. This causes the
value returned to appear after the expression. The buﬀer will look like this:
(buffer-name)"*scratch*"
You cannot do this in Info since Info is read-only and it will not allow you
to change the contents of the buﬀer. But you can do this in any buﬀer you
can edit; and when you write code or documentation (such as this book),
this feature is very useful.
2.2 Getting Buﬀers
The buffer-name function returns the name of the buﬀer; to get the
buﬀer itself, a diﬀerent function is needed: the current-buffer function. If
you use this function in code, what you get is the buﬀer itself.
A name and the object or entity to which the name refers are diﬀerent
from each other. You are not your name. You are a person to whom others
refer by name. If you ask to speak to George and someone hands you a
card with the letters ‘G’, ‘e’, ‘o’, ‘r’, ‘g’, and ‘e’ written on it, you might be
amused, but you would not be satisﬁed. You do not want to speak to the
name, but to the person to whom the name refers. A buﬀer is similar: the
name of the scratch buﬀer is ‘*scratch*’, but the name is not the buﬀer.
To get a buﬀer itself, you need to use a function such as current-buffer.
However, there is a slight complication: if you evaluate current-buffer
in an expression on its own, as we will do here, what you see is a printed
representation of the name of the buﬀer without the contents of the buﬀer.
Emacs works this way for two reasons: the buﬀer may be thousands of lines
long—too long to be conveniently displayed; and, another buﬀer may have
the same contents but a diﬀerent name, and it is important to distinguish
between them.
Here is an expression containing the function:
(current-buffer)
If you evaluate the expression in the usual way, ‘#<buffer *info*>’ appears
in the echo area. The special format indicates that the buﬀer itself is being
returned, rather than just its name.
Incidentally, while you can type a number or symbol into a program, you
cannot do that with the printed representation of a buﬀer: the only way to
get a buﬀer itself is with a function such as current-buffer.
A related function is other-buffer. This returns the most recently se-
lected buﬀer other than the one you are in currently. If you have recently

26
Chapter 2: Practicing Evaluation
switched back and forth from the ‘*scratch*’ buﬀer, other-buffer will
return that buﬀer.
You can see this by evaluating the expression:
(other-buffer)
You should see ‘#<buffer *scratch*>’ appear in the echo area, or the name
of whatever other buﬀer you switched back from most recently1.
2.3 Switching Buﬀers
The other-buffer function actually provides a buﬀer when it is used
as an argument to a function that requires one. We can see this by using
other-buffer and switch-to-buffer to switch to a diﬀerent buﬀer.
But ﬁrst, a brief introduction to the switch-to-buffer function. When
you switched back and forth from Info to the ‘*scratch*’ buﬀer to evaluate
(buffer-name), you most likely typed C-x b and then typed ‘*scratch*’2
when prompted in the minibuﬀer for the name of the buﬀer to which you
wanted to switch. The keystrokes, C-x b, cause the Lisp interpreter to eval-
uate the interactive function switch-to-buffer. As we said before, this is
how Emacs works: diﬀerent keystrokes call or run diﬀerent functions. For
example, C-f calls forward-char, M-e calls forward-sentence, and so on.
By writing switch-to-buffer in an expression, and giving it a buﬀer to
switch to, we can switch buﬀers just the way C-x b does.
Here is the Lisp expression:
(switch-to-buffer (other-buffer))
The symbol switch-to-buffer is the ﬁrst element of the list, so the Lisp
interpreter will treat it as a function and carry out the instructions that
are attached to it.
But before doing that, the interpreter will note that
other-buffer is inside parentheses and work on that symbol ﬁrst. other-
buffer is the ﬁrst (and in this case, the only) element of this list, so the Lisp
interpreter calls or runs the function. It returns another buﬀer. Next, the
interpreter runs switch-to-buffer, passing to it, as an argument, the other
buﬀer, which is what Emacs will switch to. If you are reading this in Info,
try this now. Evaluate the expression. (To get back, type C-x b ⟨RET⟩.)3
1 Actually, by default, if the buﬀer from which you just switched is visible to you in
another window, other-buffer will choose the most recent buﬀer that you cannot see;
this is a subtlety that I often forget.
2 Or rather, to save typing, you probably typed just part of the name, such as *sc, and
then pressed your TAB key to cause it to expand to the full name; and then typed your
RET key.
3 Remember, this expression will move you to your most recent other buﬀer that you
cannot see. If you really want to go to your most recently selected buﬀer, even if you
can still see it, you need to evaluate the following more complex expression:
(switch-to-buffer (other-buffer (current-buffer) t))

Buﬀer Size and the Location of Point
27
In the programming examples in later sections of this document, you will
see the function set-buffer more often than switch-to-buffer. This is
because of a diﬀerence between computer programs and humans: humans
have eyes and expect to see the buﬀer on which they are working on their
computer terminals. This is so obvious, it almost goes without saying. How-
ever, programs do not have eyes. When a computer program works on a
buﬀer, that buﬀer does not need to be visible on the screen.
switch-to-buffer is designed for humans and does two diﬀerent things:
it switches the buﬀer to which Emacs’ attention is directed; and it switches
the buﬀer displayed in the window to the new buﬀer. set-buffer, on the
other hand, does only one thing: it switches the attention of the computer
program to a diﬀerent buﬀer. The buﬀer on the screen remains unchanged (of
course, normally nothing happens there until the command ﬁnishes running).
Also, we have just introduced another jargon term, the word call. When
you evaluate a list in which the ﬁrst symbol is a function, you are calling
that function. The use of the term comes from the notion of the function as
an entity that can do something for you if you ‘call’ it—just as a plumber is
an entity who can ﬁx a leak if you call him or her.
2.4 Buﬀer Size and the Location of Point
Finally, let’s look at several rather simple functions, buffer-size, point,
point-min, and point-max. These give information about the size of a buﬀer
and the location of point within it.
The function buffer-size tells you the size of the current buﬀer; that
is, the function returns a count of the number of characters in the buﬀer.
(buffer-size)
You can evaluate this in the usual way, by positioning the cursor after the
expression and typing C-x C-e.
In Emacs, the current position of the cursor is called point. The expres-
sion (point) returns a number that tells you where the cursor is located as
a count of the number of characters from the beginning of the buﬀer up to
point.
You can see the character count for point in this buﬀer by evaluating the
following expression in the usual way:
(point)
As I write this, the value of point is 65724. The point function is frequently
used in some of the examples later in this book.
In this case, the ﬁrst argument to other-buffer tells it which buﬀer to skip—the
current one—and the second argument tells other-buffer it is OK to switch to a
visible buﬀer.
In regular use, switch-to-buffer takes you to an invisible window
since you would most likely use C-x o (other-window) to go to another visible buﬀer.

28
Chapter 2: Practicing Evaluation
The value of point depends, of course, on its location within the buﬀer.
If you evaluate point in this spot, the number will be larger:
(point)
For me, the value of point in this location is 66043, which means that there
are 319 characters (including spaces) between the two expressions.
The function point-min is somewhat similar to point, but it returns the
value of the minimum permissible value of point in the current buﬀer. This
is the number 1 unless narrowing is in eﬀect. (Narrowing is a mechanism
whereby you can restrict yourself, or a program, to operations on just a part
of a buﬀer. See Chapter 6, “Narrowing and Widening”, page 77.) Likewise,
the function point-max returns the value of the maximum permissible value
of point in the current buﬀer.
2.5 Exercise
Find a ﬁle with which you are working and move towards its middle.
Find its buﬀer name, ﬁle name, length, and your position in the ﬁle.

The defun Special Form
29
3 How To Write Function Deﬁnitions
When the Lisp interpreter evaluates a list, it looks to see whether the ﬁrst
symbol on the list has a function deﬁnition attached to it; or, put another
way, whether the symbol points to a function deﬁnition.
If it does, the
computer carries out the instructions in the deﬁnition. A symbol that has a
function deﬁnition is called, simply, a function (although, properly speaking,
the deﬁnition is the function and the symbol refers to it.)
All functions are deﬁned in terms of other functions, except for a few
primitive functions that are written in the C programming language. When
you write functions’ deﬁnitions, you will write them in Emacs Lisp and use
other functions as your building blocks. Some of the functions you will use
will themselves be written in Emacs Lisp (perhaps by you) and some will be
primitives written in C. The primitive functions are used exactly like those
written in Emacs Lisp and behave like them. They are written in C so we
can easily run GNU Emacs on any computer that has suﬃcient power and
can run C.
Let me re-emphasize this: when you write code in Emacs Lisp, you do
not distinguish between the use of functions written in C and the use of
functions written in Emacs Lisp. The diﬀerence is irrelevant. I mention
the distinction only because it is interesting to know. Indeed, unless you
investigate, you won’t know whether an already-written function is written
in Emacs Lisp or C.
3.1 The defun Special Form
In Lisp, a symbol such as mark-whole-buffer has code attached to it that
tells the computer what to do when the function is called. This code is called
the function deﬁnition and is created by evaluating a Lisp expression that
starts with the symbol defun (which is an abbreviation for deﬁne function).
Because defun does not evaluate its arguments in the usual way, it is called
a special form.
In subsequent sections, we will look at function deﬁnitions from the Emacs
source code, such as mark-whole-buffer. In this section, we will describe
a simple function deﬁnition so you can see how it looks.
This function
deﬁnition uses arithmetic because it makes for a simple example.
Some
people dislike examples using arithmetic; however, if you are such a person,
do not despair. Hardly any of the code we will study in the remainder of
this introduction involves arithmetic or mathematics. The examples mostly
involve text in one way or another.
A function deﬁnition has up to ﬁve parts following the word defun:
1. The name of the symbol to which the function deﬁnition should be
attached.
2. A list of the arguments that will be passed to the function. If no argu-
ments will be passed to the function, this is an empty list, ().

30
Chapter 3: How To Write Function Deﬁnitions
3. Documentation describing the function.
(Technically optional, but
strongly recommended.)
4. Optionally, an expression to make the function interactive so you can
use it by typing M-x and then the name of the function; or by typing an
appropriate key or keychord.
5. The code that instructs the computer what to do: the body of the
function deﬁnition.
It is helpful to think of the ﬁve parts of a function deﬁnition as being
organized in a template, with slots for each part:
(defun function-name (arguments...)
"optional-documentation..."
(interactive argument-passing-info)
; optional
body...)
As an example, here is the code for a function that multiplies its argument
by 7. (This example is not interactive. See Section 3.3, “Making a Function
Interactive”, page 33, for that information.)
(defun multiply-by-seven (number)
"Multiply NUMBER by seven."
(* 7 number))
This deﬁnition begins with a parenthesis and the symbol defun, followed
by the name of the function.
The name of the function is followed by a list that contains the arguments
that will be passed to the function. This list is called the argument list. In
this example, the list has only one element, the symbol, number. When the
function is used, the symbol will be bound to the value that is used as the
argument to the function.
Instead of choosing the word number for the name of the argument, I
could have picked any other name. For example, I could have chosen the
word multiplicand. I picked the word ‘number’ because it tells what kind
of value is intended for this slot; but I could just as well have chosen the
word ‘multiplicand’ to indicate the role that the value placed in this slot
will play in the workings of the function. I could have called it foogle, but
that would have been a bad choice because it would not tell humans what it
means. The choice of name is up to the programmer and should be chosen
to make the meaning of the function clear.
Indeed, you can choose any name you wish for a symbol in an argument
list, even the name of a symbol used in some other function: the name
you use in an argument list is private to that particular deﬁnition. In that
deﬁnition, the name refers to a diﬀerent entity than any use of the same name
outside the function deﬁnition. Suppose you have a nick-name ‘Shorty’ in
your family; when your family members refer to ‘Shorty’, they mean you.
But outside your family, in a movie, for example, the name ‘Shorty’ refers to
someone else. Because a name in an argument list is private to the function

Install a Function Deﬁnition
31
deﬁnition, you can change the value of such a symbol inside the body of a
function without changing its value outside the function. The eﬀect is similar
to that produced by a let expression. (See Section 3.6, “let”, page 36.)
The argument list is followed by the documentation string that describes
the function. This is what you see when you type C-h f and the name of a
function. Incidentally, when you write a documentation string like this, you
should make the ﬁrst line a complete sentence since some commands, such as
apropos, print only the ﬁrst line of a multi-line documentation string. Also,
you should not indent the second line of a documentation string, if you have
one, because that looks odd when you use C-h f (describe-function). The
documentation string is optional, but it is so useful, it should be included in
almost every function you write.
The third line of the example consists of the body of the function deﬁni-
tion. (Most functions’ deﬁnitions, of course, are longer than this.) In this
function, the body is the list, (* 7 number), which says to multiply the value
of number by 7. (In Emacs Lisp, * is the function for multiplication, just as
+ is the function for addition.)
When you use the multiply-by-seven function, the argument number
evaluates to the actual number you want used. Here is an example that
shows how multiply-by-seven is used; but don’t try to evaluate this yet!
(multiply-by-seven 3)
The symbol number, speciﬁed in the function deﬁnition in the next section,
is given or “bound to” the value 3 in the actual use of the function. Note
that although number was inside parentheses in the function deﬁnition, the
argument passed to the multiply-by-seven function is not in parentheses.
The parentheses are written in the function deﬁnition so the computer can
ﬁgure out where the argument list ends and the rest of the function deﬁnition
begins.
If you evaluate this example, you are likely to get an error message. (Go
ahead, try it!) This is because we have written the function deﬁnition, but
not yet told the computer about the deﬁnition—we have not yet installed (or
‘loaded’) the function deﬁnition in Emacs. Installing a function is the process
that tells the Lisp interpreter the deﬁnition of the function. Installation is
described in the next section.
3.2 Install a Function Deﬁnition
If you are reading this inside of Info in Emacs, you can try out the
multiply-by-seven function by ﬁrst evaluating the function deﬁnition and
then evaluating (multiply-by-seven 3). A copy of the function deﬁnition
follows. Place the cursor after the last parenthesis of the function deﬁnition
and type C-x C-e. When you do this, multiply-by-seven will appear in the
echo area. (What this means is that when a function deﬁnition is evaluated,

32
Chapter 3: How To Write Function Deﬁnitions
the value it returns is the name of the deﬁned function.) At the same time,
this action installs the function deﬁnition.
(defun multiply-by-seven (number)
"Multiply NUMBER by seven."
(* 7 number))
By evaluating this defun, you have just installed multiply-by-seven in
Emacs. The function is now just as much a part of Emacs as forward-
word or any other editing function you use. (multiply-by-seven will stay
installed until you quit Emacs. To reload code automatically whenever you
start Emacs, see Section 3.5, “Installing Code Permanently”, page 36.)
You can see the eﬀect of installing multiply-by-seven by evaluating the
following sample. Place the cursor after the following expression and type
C-x C-e. The number 21 will appear in the echo area.
(multiply-by-seven 3)
If you wish, you can read the documentation for the function by typing
C-h f (describe-function) and then the name of the function, multiply-
by-seven. When you do this, a ‘*Help*’ window will appear on your screen
that says:
multiply-by-seven:
Multiply NUMBER by seven.
(To return to a single window on your screen, type C-x 1.)
3.2.1 Change a Function Deﬁnition
If you want to change the code in multiply-by-seven, just rewrite it.
To install the new version in place of the old one, evaluate the function
deﬁnition again. This is how you modify code in Emacs. It is very simple.
As an example, you can change the multiply-by-seven function to add
the number to itself seven times instead of multiplying the number by seven.
It produces the same answer, but by a diﬀerent path. At the same time, we
will add a comment to the code; a comment is text that the Lisp interpreter
ignores, but that a human reader may ﬁnd useful or enlightening.
The
comment is that this is the “second version”.
(defun multiply-by-seven (number)
; Second version.
"Multiply NUMBER by seven."
(+ number number number number number number number))
The comment follows a semicolon, ‘;’. In Lisp, everything on a line that
follows a semicolon is a comment. The end of the line is the end of the
comment. To stretch a comment over two or more lines, begin each line
with a semicolon.
See Section 16.3, “Beginning a ‘.emacs’ File”, page 216, and section
“Comments” in The GNU Emacs Lisp Reference Manual, for more about
comments.

Make a Function Interactive
33
You can install this version of the multiply-by-seven function by eval-
uating it in the same way you evaluated the ﬁrst function: place the cursor
after the last parenthesis and type C-x C-e.
In summary, this is how you write code in Emacs Lisp: you write a
function; install it; test it; and then make ﬁxes or enhancements and install
it again.
3.3 Make a Function Interactive
You make a function interactive by placing a list that begins with the
special form interactive immediately after the documentation.
A user
can invoke an interactive function by typing M-x and then the name of the
function; or by typing the keys to which it is bound, for example, by typing
C-n for next-line or C-x h for mark-whole-buffer.
Interestingly, when you call an interactive function interactively, the value
returned is not automatically displayed in the echo area. This is because you
often call an interactive function for its side eﬀects, such as moving forward
by a word or line, and not for the value returned. If the returned value
were displayed in the echo area each time you typed a key, it would be very
distracting.
Both the use of the special form interactive and one way to display a
value in the echo area can be illustrated by creating an interactive version
of multiply-by-seven.
Here is the code:
(defun multiply-by-seven (number)
; Interactive version.
"Multiply NUMBER by seven."
(interactive "p")
(message "The result is %d" (* 7 number)))
You can install this code by placing your cursor after it and typing C-x C-e.
The name of the function will appear in your echo area. Then, you can use
this code by typing C-u and a number and then typing M-x multiply-by-
seven and pressing ⟨RET⟩. The phrase ‘The result is ...’ followed by the
product will appear in the echo area.
Speaking more generally, you invoke a function like this in either of two
ways:
1. By typing a preﬁx argument that contains the number to be passed,
and then typing M-x and the name of the function, as with C-u 3 M-x
forward-sentence; or,
2. By typing whatever key or keychord the function is bound to, as with
C-u 3 M-e.
Both the examples just mentioned work identically to move point forward
three sentences. (Since multiply-by-seven is not bound to a key, it could
not be used as an example of key binding.)

34
Chapter 3: How To Write Function Deﬁnitions
(See Section 16.7, “Some Keybindings”, page 220, to learn how to bind
a command to a key.)
A preﬁx argument is passed to an interactive function by typing the
⟨META⟩key followed by a number, for example, M-3 M-e, or by typing C-
u and then a number, for example, C-u 3 M-e (if you type C-u without a
number, it defaults to 4).
3.3.1 An Interactive multiply-by-seven
Let’s look at the use of the special form interactive and then at the
function message in the interactive version of multiply-by-seven. You will
recall that the function deﬁnition looks like this:
(defun multiply-by-seven (number)
; Interactive version.
"Multiply NUMBER by seven."
(interactive "p")
(message "The result is %d" (* 7 number)))
In this function, the expression, (interactive "p"), is a list of two ele-
ments. The "p" tells Emacs to pass the preﬁx argument to the function and
use its value for the argument of the function.
The argument will be a number. This means that the symbol number
will be bound to a number in the line:
(message "The result is %d" (* 7 number))
For example, if your preﬁx argument is 5, the Lisp interpreter will evaluate
the line as if it were:
(message "The result is %d" (* 7 5))
(If you are reading this in GNU Emacs, you can evaluate this expression
yourself.) First, the interpreter will evaluate the inner list, which is (* 7
5). This returns a value of 35. Next, it will evaluate the outer list, passing
the values of the second and subsequent elements of the list to the function
message.
As we have seen, message is an Emacs Lisp function especially designed
for sending a one line message to a user. (See Section 1.8.5, “The message
function”, page 16.) In summary, the message function prints its ﬁrst argu-
ment in the echo area as is, except for occurrences of ‘%d’, ‘%s’, or ‘%c’. When
it sees one of these control sequences, the function looks to the second and
subsequent arguments and prints the value of the argument in the location
in the string where the control sequence is located.
In the interactive multiply-by-seven function, the control string is ‘%d’,
which requires a number, and the value returned by evaluating (* 7 5) is
the number 35. Consequently, the number 35 is printed in place of the ‘%d’
and the message is ‘The result is 35’.
(Note that when you call the function multiply-by-seven, the message
is printed without quotes, but when you call message, the text is printed
in double quotes. This is because the value returned by message is what

Diﬀerent Options for interactive
35
appears in the echo area when you evaluate an expression whose ﬁrst element
is message; but when embedded in a function, message prints the text as a
side eﬀect without quotes.)
3.4 Diﬀerent Options for interactive
In the example, multiply-by-seven used "p" as the argument to
interactive. This argument told Emacs to interpret your typing either
C-u followed by a number or ⟨META⟩followed by a number as a command
to pass that number to the function as its argument. Emacs has more than
twenty characters predeﬁned for use with interactive.
In almost every
case, one of these options will enable you to pass the right information in-
teractively to a function. (See section “Code Characters for interactive”
in The GNU Emacs Lisp Reference Manual.)
For example, the character ‘r’ causes Emacs to pass the beginning and
end of the region (the current values of point and mark) to the function as
two separate arguments. It is used as follows:
(interactive "r")
On the other hand, a ‘B’ tells Emacs to ask for the name of a buﬀer that
will be passed to the function. When it sees a ‘B’, Emacs will ask for the
name by prompting the user in the minibuﬀer, using a string that follows
the ‘B’, as in "BAppend to buffer: ". Not only will Emacs prompt for the
name, but Emacs will complete the name if you type enough of it and press
⟨TAB⟩.
A function with two or more arguments can have information passed
to each argument by adding parts to the string that follows interactive.
When you do this, the information is passed to each argument in the same
order it is speciﬁed in the interactive list.
In the string, each part is
separated from the next part by a ‘\n’, which is a newline. For example,
you could follow "BAppend to buffer: " with a ‘\n’) and an ‘r’. This would
cause Emacs to pass the values of point and mark to the function as well as
prompt you for the buﬀer—three arguments in all.
In this case, the function deﬁnition would look like the following, where
buffer, start, and end are the symbols to which interactive binds the
buﬀer and the current values of the beginning and ending of the region:
(defun name-of-function (buffer start end)
"documentation..."
(interactive "BAppend to buffer: \nr")
body-of-function...)
(The space after the colon in the prompt makes it look better when you
are prompted. The append-to-buffer function looks exactly like this. See
Section 4.4, “The Deﬁnition of append-to-buffer”, page 56.)

36
Chapter 3: How To Write Function Deﬁnitions
If a function does not have arguments, then interactive does not require
any. Such a function contains the simple expression (interactive). The
mark-whole-buffer function is like this.
Alternatively, if the special letter-codes are not right for your application,
you can pass your own arguments to interactive as a list. See section
“Using Interactive” in The GNU Emacs Lisp Reference Manual, for more
information about this advanced technique.
3.5 Install Code Permanently
When you install a function deﬁnition by evaluating it, it will stay in-
stalled until you quit Emacs.
The next time you start a new session of
Emacs, the function will not be installed unless you evaluate the function
deﬁnition again.
At some point, you may want to have code installed automatically when-
ever you start a new session of Emacs.
There are several ways of doing
this:
• If you have code that is just for yourself, you can put the code for the
function deﬁnition in your ‘.emacs’ initialization ﬁle. When you start
Emacs, your ‘.emacs’ ﬁle is automatically evaluated and all the function
deﬁnitions within it are installed. See Chapter 16, “Your ‘.emacs’ File”,
page 213.
• Alternatively, you can put the function deﬁnitions that you want in-
stalled in one or more ﬁles of their own and use the load function to
cause Emacs to evaluate and thereby install each of the functions in the
ﬁles. See Section 16.9, “Loading Files”, page 222.
• On the other hand, if you have code that your whole site will use,
it is usual to put it in a ﬁle called ‘site-init.el’ that is loaded when
Emacs is built. This makes the code available to everyone who uses your
machine. (See the ‘INSTALL’ ﬁle that is part of the Emacs distribution.)
Finally, if you have code that everyone who uses Emacs may want, you
can post it on a computer network or send a copy to the Free Software Foun-
dation. (When you do this, please license the code and its documentation
under a license that permits other people to run, copy, study, modify, and
redistribute the code and which protects you from having your work taken
from you.) If you send a copy of your code to the Free Software Foundation,
and properly protect yourself and others, it may be included in the next
release of Emacs. In large part, this is how Emacs has grown over the past
years, by donations.
3.6 let
The let expression is a special form in Lisp that you will need to use in
most function deﬁnitions.

The Parts of a let Expression
37
let is used to attach or bind a symbol to a value in such a way that
the Lisp interpreter will not confuse the variable with a variable of the same
name that is not part of the function.
To understand why the let special form is necessary, consider the situa-
tion in which you own a home that you generally refer to as ‘the house’, as
in the sentence, “The house needs painting.” If you are visiting a friend and
your host refers to ‘the house’, he is likely to be referring to his house, not
yours, that is, to a diﬀerent house.
If your friend is referring to his house and you think he is referring to
your house, you may be in for some confusion. The same thing could happen
in Lisp if a variable that is used inside of one function has the same name
as a variable that is used inside of another function, and the two are not
intended to refer to the same value. The let special form prevents this kind
of confusion.
The let special form prevents confusion. let creates a name for a local
variable that overshadows any use of the same name outside the let ex-
pression. This is like understanding that whenever your host refers to ‘the
house’, he means his house, not yours. (Symbols used in argument lists work
the same way. See Section 3.1, “The defun Special Form”, page 29.)
Local variables created by a let expression retain their value only within
the let expression itself (and within expressions called within the let ex-
pression); the local variables have no eﬀect outside the let expression.
Another way to think about let is that it is like a setq that is temporary
and local. The values set by let are automatically undone when the let is
ﬁnished. The setting only eﬀects expressions that are inside the bounds of
the let expression. In computer science jargon, we would say “the binding
of a symbol is visible only in functions called in the let form; in Emacs Lisp,
scoping is dynamic, not lexical.”
let can create more than one variable at once.
Also, let gives each
variable it creates an initial value, either a value speciﬁed by you, or nil.
(In the jargon, this is called ‘binding the variable to the value’.) After let
has created and bound the variables, it executes the code in the body of the
let, and returns the value of the last expression in the body, as the value of
the whole let expression. (‘Execute’ is a jargon term that means to evaluate
a list; it comes from the use of the word meaning ‘to give practical eﬀect to’
(Oxford English Dictionary). Since you evaluate an expression to perform
an action, ‘execute’ has evolved as a synonym to ‘evaluate’.)
3.6.1 The Parts of a let Expression
A let expression is a list of three parts. The ﬁrst part is the symbol
let. The second part is a list, called a varlist, each element of which is
either a symbol by itself or a two-element list, the ﬁrst element of which is
a symbol. The third part of the let expression is the body of the let. The
body usually consists of one or more lists.

38
Chapter 3: How To Write Function Deﬁnitions
A template for a let expression looks like this:
(let varlist body...)
The symbols in the varlist are the variables that are given initial values by
the let special form. Symbols by themselves are given the initial value of
nil; and each symbol that is the ﬁrst element of a two-element list is bound
to the value that is returned when the Lisp interpreter evaluates the second
element.
Thus, a varlist might look like this: (thread (needles 3)). In this case,
in a let expression, Emacs binds the symbol thread to an initial value of
nil, and binds the symbol needles to an initial value of 3.
When you write a let expression, what you do is put the appropriate
expressions in the slots of the let expression template.
If the varlist is composed of two-element lists, as is often the case, the
template for the let expression looks like this:
(let ((variable value)
(variable value)
...)
body...)
3.6.2 Sample let Expression
The following expression creates and gives initial values to the two vari-
ables zebra and tiger. The body of the let expression is a list which calls
the message function.
(let ((zebra ’stripes)
(tiger ’fierce))
(message "One kind of animal has %s and another is %s."
zebra tiger))
Here, the varlist is ((zebra ’stripes) (tiger ’fierce)).
The two variables are zebra and tiger. Each variable is the ﬁrst element
of a two-element list and each value is the second element of its two-element
list. In the varlist, Emacs binds the variable zebra to the value stripes, and
binds the variable tiger to the value fierce. In this example, both values
are symbols preceded by a quote. The values could just as well have been
another list or a string. The body of the let follows after the list holding the
variables. In this example, the body is a list that uses the message function
to print a string in the echo area.

The if Special Form
39
You may evaluate the example in the usual fashion, by placing the cur-
sor after the last parenthesis and typing C-x C-e. When you do this, the
following will appear in the echo area:
"One kind of animal has stripes and another is fierce."
As we have seen before, the message function prints its ﬁrst argument,
except for ‘%s’. In this example, the value of the variable zebra is printed
at the location of the ﬁrst ‘%s’ and the value of the variable tiger is printed
at the location of the second ‘%s’.
3.6.3 Uninitialized Variables in a let Statement
If you do not bind the variables in a let statement to speciﬁc initial
values, they will automatically be bound to an initial value of nil, as in the
following expression:
(let ((birch 3)
pine
fir
(oak ’some))
(message
"Here are %d variables with %s, %s, and %s value."
birch pine fir oak))
Here, the varlist is ((birch 3) pine fir (oak ’some)).
If you evaluate this expression in the usual way, the following will appear
in your echo area:
"Here are 3 variables with nil, nil, and some value."
In this example, Emacs binds the symbol birch to the number 3, binds the
symbols pine and fir to nil, and binds the symbol oak to the value some.
Note that in the ﬁrst part of the let, the variables pine and fir stand
alone as atoms that are not surrounded by parentheses; this is because they
are being bound to nil, the empty list. But oak is bound to some and so
is a part of the list (oak ’some). Similarly, birch is bound to the number
3 and so is in a list with that number. (Since a number evaluates to itself,
the number does not need to be quoted. Also, the number is printed in the
message using a ‘%d’ rather than a ‘%s’.) The four variables as a group are
put into a list to delimit them from the body of the let.
3.7 The if Special Form
A third special form, in addition to defun and let, is the conditional if.
This form is used to instruct the computer to make decisions. You can write
function deﬁnitions without using if, but it is used often enough, and is
important enough, to be included here. It is used, for example, in the code
for the function beginning-of-buffer.

40
Chapter 3: How To Write Function Deﬁnitions
The basic idea behind an if, is that “if a test is true, then an expression
is evaluated.” If the test is not true, the expression is not evaluated. For
example, you might make a decision such as, “if it is warm and sunny, then
go to the beach!”
An if expression written in Lisp does not use the word ‘then’; the test
and the action are the second and third elements of the list whose ﬁrst
element is if. Nonetheless, the test part of an if expression is often called
the if-part and the second argument is often called the then-part.
Also, when an if expression is written, the true-or-false-test is usually
written on the same line as the symbol if, but the action to carry out if the
test is true, the “then-part”, is written on the second and subsequent lines.
This makes the if expression easier to read.
(if true-or-false-test
action-to-carry-out-if-test-is-true)
The true-or-false-test will be an expression that is evaluated by the Lisp
interpreter.
Here is an example that you can evaluate in the usual manner. The test is
whether the number 5 is greater than the number 4. Since it is, the message
‘5 is greater than 4!’ will be printed.
(if (> 5 4)
; if-part
(message "5 is greater than 4!"))
; then-part
(The function > tests whether its ﬁrst argument is greater than its second
argument and returns true if it is.)
Of course, in actual use, the test in an if expression will not be ﬁxed
for all time as it is by the expression (> 5 4). Instead, at least one of the
variables used in the test will be bound to a value that is not known ahead
of time. (If the value were known ahead of time, we would not need to run
the test!)
For example, the value may be bound to an argument of a function deﬁ-
nition. In the following function deﬁnition, the character of the animal is a
value that is passed to the function. If the value bound to characteristic
is fierce, then the message, ‘It’s a tiger!’ will be printed; otherwise, nil
will be returned.
(defun type-of-animal (characteristic)
"Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol ‘fierce’,
then warn of a tiger."
(if (equal characteristic ’fierce)
(message "It’s a tiger!")))

The type-of-animal Function in Detail
41
If you are reading this inside of GNU Emacs, you can evaluate the function
deﬁnition in the usual way to install it in Emacs, and then you can evaluate
the following two expressions to see the results:
(type-of-animal ’fierce)
(type-of-animal ’zebra)
When you evaluate (type-of-animal ’fierce), you will see the following
message printed in the echo area: "It’s a tiger!"; and when you evaluate
(type-of-animal ’zebra) you will see nil printed in the echo area.
3.7.1 The type-of-animal Function in Detail
Let’s look at the type-of-animal function in detail.
The function deﬁnition for type-of-animal was written by ﬁlling the
slots of two templates, one for a function deﬁnition as a whole, and a second
for an if expression.
The template for every function that is not interactive is:
(defun name-of-function (argument-list)
"documentation..."
body...)
The parts of the function that match this template look like this:
(defun type-of-animal (characteristic)
"Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol ‘fierce’,
then warn of a tiger."
body: the if expression)
The name of function is type-of-animal; it is passed the value of one
argument.
The argument list is followed by a multi-line documentation
string. The documentation string is included in the example because it is a
good habit to write documentation string for every function deﬁnition. The
body of the function deﬁnition consists of the if expression.
The template for an if expression looks like this:
(if true-or-false-test
action-to-carry-out-if-the-test-returns-true)
In the type-of-animal function, the code for the if looks like this:
(if (equal characteristic ’fierce)
(message "It’s a tiger!")))
Here, the true-or-false-test is the expression:
(equal characteristic ’fierce)
In Lisp, equal is a function that determines whether its ﬁrst argument is
equal to its second argument. The second argument is the quoted symbol

42
Chapter 3: How To Write Function Deﬁnitions
’fierce and the ﬁrst argument is the value of the symbol characteristic—
in other words, the argument passed to this function.
In the ﬁrst exercise of type-of-animal, the argument fierce is passed to
type-of-animal. Since fierce is equal to fierce, the expression, (equal
characteristic ’fierce), returns a value of true. When this happens, the
if evaluates the second argument or then-part of the if: (message "It’s
tiger!").
On the other hand, in the second exercise of type-of-animal, the argu-
ment zebra is passed to type-of-animal. zebra is not equal to fierce, so
the then-part is not evaluated and nil is returned by the if expression.
3.8 If–then–else Expressions
An if expression may have an optional third argument, called the else-
part, for the case when the true-or-false-test returns false. When this hap-
pens, the second argument or then-part of the overall if expression is not
evaluated, but the third or else-part is evaluated. You might think of this
as the cloudy day alternative for the decision ‘if it is warm and sunny, then
go to the beach, else read a book!”.
The word “else” is not written in the Lisp code; the else-part of an if
expression comes after the then-part. In the written Lisp, the else-part is
usually written to start on a line of its own and is indented less than the
then-part:
(if true-or-false-test
action-to-carry-out-if-the-test-returns-true
action-to-carry-out-if-the-test-returns-false)
For example, the following if expression prints the message ‘4 is not
greater than 5!’ when you evaluate it in the usual way:
(if (> 4 5)
; if-part
(message "5 is greater than 4!")
; then-part
(message "4 is not greater than 5!")) ; else-part
Note that the diﬀerent levels of indentation make it easy to distinguish the
then-part from the else-part. (GNU Emacs has several commands that au-
tomatically indent if expressions correctly. See Section 1.1.3, “GNU Emacs
Helps You Type Lists”, page 3.)
We can extend the type-of-animal function to include an else-part by
simply incorporating an additional part to the if expression.

Truth and Falsehood in Emacs Lisp
43
You can see the consequences of doing this if you evaluate the following
version of the type-of-animal function deﬁnition to install it and then
evaluate the two subsequent expressions to pass diﬀerent arguments to the
function.
(defun type-of-animal (characteristic)
; Second version.
"Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol ‘fierce’,
then warn of a tiger;
else say it’s not fierce."
(if (equal characteristic ’fierce)
(message "It’s a tiger!")
(message "It’s not fierce!")))
(type-of-animal ’fierce)
(type-of-animal ’zebra)
When you evaluate (type-of-animal ’fierce), you will see the following
message printed in the echo area: "It’s a tiger!"; but when you evaluate
(type-of-animal ’zebra), you will see "It’s not fierce!".
(Of course, if the characteristic were ferocious, the message "It’s not
fierce!" would be printed; and it would be misleading! When you write
code, you need to take into account the possibility that some such argument
will be tested by the if and write your program accordingly.)
3.9 Truth and Falsehood in Emacs Lisp
There is an important aspect to the truth test in an if expression. So
far, we have spoken of ‘true’ and ‘false’ as values of predicates as if they were
new kinds of Emacs Lisp objects. In fact, ‘false’ is just our old friend nil.
Anything else—anything at all—is ‘true’.
The expression that tests for truth is interpreted as true if the result of
evaluating it is a value that is not nil. In other words, the result of the test
is considered true if the value returned is a number such as 47, a string such
as "hello", or a symbol (other than nil) such as flowers, or a list, or even
a buﬀer!
Before illustrating a test for truth, we need an explanation of nil.
In Emacs Lisp, the symbol nil has two meanings. First, it means the
empty list. Second, it means false and is the value returned when a true-or-
false-test tests false. nil can be written as an empty list, (), or as nil. As
far as the Lisp interpreter is concerned, () and nil are the same. Humans,
however, tend to use nil for false and () for the empty list.
In Emacs Lisp, any value that is not nil—is not the empty list—is con-
sidered true. This means that if an evaluation returns something that is not

44
Chapter 3: How To Write Function Deﬁnitions
an empty list, an if expression will test true. For example, if a number is
put in the slot for the test, it will be evaluated and will return itself, since
that is what numbers do when evaluated. In this conditional, the if expres-
sion will test true. The expression tests false only when nil, an empty list,
is returned by evaluating the expression.
You can see this by evaluating the two expressions in the following ex-
amples.
In the ﬁrst example, the number 4 is evaluated as the test in the if
expression and returns itself; consequently, the then-part of the expression
is evaluated and returned: ‘true’ appears in the echo area. In the second
example, the nil indicates false; consequently, the else-part of the expression
is evaluated and returned: ‘false’ appears in the echo area.
(if 4
’true
’false)
(if nil
’true
’false)
Incidentally, if some other useful value is not available for a test that
returns true, then the Lisp interpreter will return the symbol t for true. For
example, the expression (> 5 4) returns t when evaluated, as you can see
by evaluating it in the usual way:
(> 5 4)
On the other hand, this function returns nil if the test is false.
(> 4 5)
3.10 save-excursion
The save-excursion function is the fourth and ﬁnal special form that
we will discuss in this chapter.
In Emacs Lisp programs used for editing, the save-excursion function
is very common. It saves the location of point and mark, executes the body
of the function, and then restores point and mark to their previous positions
if their locations were changed. Its primary purpose is to keep the user from
being surprised and disturbed by unexpected movement of point or mark.
Before discussing save-excursion, however, it may be useful ﬁrst to
review what point and mark are in GNU Emacs. Point is the current location
of the cursor.
Wherever the cursor is, that is point.
More precisely, on
terminals where the cursor appears to be on top of a character, point is
immediately before the character. In Emacs Lisp, point is an integer. The
ﬁrst character in a buﬀer is number one, the second is number two, and
so on. The function point returns the current position of the cursor as a
number. Each buﬀer has its own value for point.

Template for a save-excursion Expression
45
The mark is another position in the buﬀer; its value can be set with a
command such as C-⟨SPC⟩(set-mark-command). If a mark has been set, you
can use the command C-x C-x (exchange-point-and-mark) to cause the
cursor to jump to the mark and set the mark to be the previous position
of point. In addition, if you set another mark, the position of the previous
mark is saved in the mark ring. Many mark positions can be saved this way.
You can jump the cursor to a saved mark by typing C-u C-⟨SPC⟩one or more
times.
The part of the buﬀer between point and mark is called the region. Nu-
merous commands work on the region, including center-region, count-
lines-region, kill-region, and print-region.
The save-excursion special form saves the locations of point and mark
and restores those positions after the code within the body of the special form
is evaluated by the Lisp interpreter. Thus, if point were in the beginning
of a piece of text and some code moved point to the end of the buﬀer, the
save-excursion would put point back to where it was before, after the
expressions in the body of the function were evaluated.
In Emacs, a function frequently moves point as part of its internal work-
ings even though a user would not expect this. For example, count-lines-
region moves point. To prevent the user from being bothered by jumps that
are both unexpected and (from the user’s point of view) unnecessary, save-
excursion is often used to keep point and mark in the location expected by
the user. The use of save-excursion is good housekeeping.
To make sure the house stays clean, save-excursion restores the values
of point and mark even if something goes wrong in the code inside of it (or,
to be more precise and to use the proper jargon, “in case of abnormal exit”).
This feature is very helpful.
In addition to recording the values of point and mark, save-excursion
keeps track of the current buﬀer, and restores it, too. This means you can
write code that will change the buﬀer and have save-excursion switch you
back to the original buﬀer. This is how save-excursion is used in append-
to-buffer.
(See Section 4.4, “The Deﬁnition of append-to-buffer”,
page 56.)
3.10.1 Template for a save-excursion Expression
The template for code using save-excursion is simple:
(save-excursion
body...)
The body of the function is one or more expressions that will be evaluated
in sequence by the Lisp interpreter. If there is more than one expression
in the body, the value of the last one will be returned as the value of the
save-excursion function. The other expressions in the body are evaluated
only for their side eﬀects; and save-excursion itself is used only for its side
eﬀect (which is restoring the positions of point and mark).

46
Chapter 3: How To Write Function Deﬁnitions
In more detail, the template for a save-excursion expression looks like
this:
(save-excursion
ﬁrst-expression-in-body
second-expression-in-body
third-expression-in-body
...
last-expression-in-body)
An expression, of course, may be a symbol on its own or a list.
In Emacs Lisp code, a save-excursion expression often occurs within
the body of a let expression. It looks like this:
(let varlist
(save-excursion
body...))
3.11 Review
In the last few chapters we have introduced a fair number of functions
and special forms. Here they are described in brief, along with a few similar
functions that have not been mentioned yet.
eval-last-sexp
Evaluate the last symbolic expression before the current location
of point. The value is printed in the echo area unless the function
is invoked with an argument; in that case, the output is printed
in the current buﬀer. This command is normally bound to C-x
C-e.
defun
Deﬁne function.
This special form has up to ﬁve parts: the
name, a template for the arguments that will be passed to the
function, documentation, an optional interactive declaration,
and the body of the deﬁnition.
For example:
(defun back-to-indentation ()
"Move point to first visible character on line."
(interactive)
(beginning-of-line 1)
(skip-chars-forward " \t"))
interactive
Declare to the interpreter that the function can be used interac-
tively. This special form may be followed by a string with one
or more parts that pass the information to the arguments of the
function, in sequence. These parts may also tell the interpreter
to prompt for information. Parts of the string are separated by
newlines, ‘\n’.

Review
47
Common code characters are:
b
The name of an existing buﬀer.
f
The name of an existing ﬁle.
p
The numeric preﬁx argument. (Note that this ‘p’ is
lower case.)
r
Point and the mark, as two numeric arguments,
smallest ﬁrst. This is the only code letter that spec-
iﬁes two successive arguments rather than one.
See section “Code Characters for ‘interactive’” in The GNU
Emacs Lisp Reference Manual, for a complete list of code char-
acters.
let
Declare that a list of variables is for use within the body of the
let and give them an initial value, either nil or a speciﬁed
value; then evaluate the rest of the expressions in the body of
the let and return the value of the last one. Inside the body
of the let, the Lisp interpreter does not see the values of the
variables of the same names that are bound outside of the let.
For example,
(let ((foo (buffer-name))
(bar (buffer-size)))
(message
"This buffer is %s and has %d characters."
foo bar))
save-excursion
Record the values of point and mark and the current buﬀer
before evaluating the body of this special form.
Restore the
values of point and mark and buﬀer afterward.
For example,
(message "We are %d characters into this buffer."
(- (point)
(save-excursion
(goto-char (point-min)) (point))))
if
Evaluate the ﬁrst argument to the function; if it is true, evaluate
the second argument; else evaluate the third argument, if there
is one.
The if special form is called a conditional. There are other con-
ditionals in Emacs Lisp, but if is perhaps the most commonly
used.

48
Chapter 3: How To Write Function Deﬁnitions
For example,
(if (string-equal
(number-to-string 21)
(substring (emacs-version) 10 12))
(message "This is version 21 Emacs")
(message "This is not version 21 Emacs"))
equal
eq
Test whether two objects are the same. equal uses one meaning
of the word ‘same’ and eq uses another: equal returns true if
the two objects have a similar structure and contents, such as
two copies of the same book. On the other hand, eq, returns
true if both arguments are actually the same object.
<
>
<=
>=
The < function tests whether its ﬁrst argument is smaller than
its second argument. A corresponding function, >, tests whether
the ﬁrst argument is greater than the second. Likewise, <= tests
whether the ﬁrst argument is less than or equal to the second
and >= tests whether the ﬁrst argument is greater than or equal
to the second. In all cases, both arguments must be numbers or
markers (markers indicate positions in buﬀers).
string<
string-lessp
string=
string-equal
The string-lessp function tests whether its ﬁrst argument is
smaller than the second argument. A shorter, alternative name
for the same function (a defalias) is string<.
The arguments to string-lessp must be strings or symbols;
the ordering is lexicographic, so case is signiﬁcant. The print
names of symbols are used instead of the symbols themselves.
An empty string, ‘""’, a string with no characters in it, is smaller
than any string of characters.
string-equal provides the corresponding test for equality. Its
shorter, alternative name is string=. There are no string test
functions that correspond to >, >=, or <=.
message
Print a message in the echo area. The ﬁrst argument is a string
that can contain ‘%s’, ‘%d’, or ‘%c’ to print the value of arguments
that follow the string. The argument used by ‘%s’ must be a
string or a symbol; the argument used by ‘%d’ must be a number.
The argument used by ‘%c’ must be an ascii code number; it will
be printed as the character with that ascii code.

Review
49
setq
set
The setq function sets the value of its ﬁrst argument to the
value of the second argument. The ﬁrst argument is automati-
cally quoted by setq. It does the same for succeeding pairs of
arguments. Another function, set, takes only two arguments
and evaluates both of them before setting the value returned by
its ﬁrst argument to the value returned by its second argument.
buffer-name
Without an argument, return the name of the buﬀer, as a string.
buffer-file-name
Without an argument, return the name of the ﬁle the buﬀer is
visiting.
current-buffer
Return the buﬀer in which Emacs is active; it may not be the
buﬀer that is visible on the screen.
other-buffer
Return the most recently selected buﬀer (other than the buﬀer
passed to other-buffer as an argument and other than the
current buﬀer).
switch-to-buffer
Select a buﬀer for Emacs to be active in and display it in the
current window so users can look at it. Usually bound to C-x b.
set-buffer
Switch Emacs’ attention to a buﬀer on which programs will run.
Don’t alter what the window is showing.
buffer-size
Return the number of characters in the current buﬀer.
point
Return the value of the current position of the cursor, as an
integer counting the number of characters from the beginning of
the buﬀer.
point-min
Return the minimum permissible value of point in the current
buﬀer. This is 1, unless narrowing is in eﬀect.
point-max
Return the value of the maximum permissible value of point in
the current buﬀer. This is the end of the buﬀer, unless narrowing
is in eﬀect.

50
Chapter 3: How To Write Function Deﬁnitions
3.12 Exercises
• Write a non-interactive function that doubles the value of its argument,
a number. Make that function interactive.
• Write a function that tests whether the current value of fill-column
is greater than the argument passed to the function, and if so, prints an
appropriate message.

Finding More Information
51
4 A Few Buﬀer–Related Functions
In this chapter we study in detail several of the functions used in GNU
Emacs. This is called a “walk-through”. These functions are used as ex-
amples of Lisp code, but are not imaginary examples; with the exception of
the ﬁrst, simpliﬁed function deﬁnition, these functions show the actual code
used in GNU Emacs. You can learn a great deal from these deﬁnitions. The
functions described here are all related to buﬀers. Later, we will study other
functions.
4.1 Finding More Information
In this walk-through, I will describe each new function as we come to it,
sometimes in detail and sometimes brieﬂy. If you are interested, you can get
the full documentation of any Emacs Lisp function at any time by typing
C-h f and then the name of the function (and then ⟨RET⟩). Similarly, you
can get the full documentation for a variable by typing C-h v and then the
name of the variable (and then ⟨RET⟩).
In versions 20 and higher, when a function is written in Emacs Lisp,
describe-function will also tell you the location of the function deﬁnition.
If you move point over the ﬁle name and press the ⟨RET⟩key, which is this
case means help-follow rather than ‘return’ or ‘enter’, Emacs will take you
directly to the function deﬁnition.
More generally, if you want to see a function in its original source ﬁle,
you can use the find-tags function to jump to it. find-tags works with
a wide variety of languages, not just Lisp, and C, and it works with non-
programming text as well. For example, find-tags will jump to the various
nodes in the Texinfo source ﬁle of this document.
The find-tags function depends on ‘tags tables’ that record the locations
of the functions, variables, and other items to which find-tags jumps.
To use the find-tags command, type M-. (i.e., type the ⟨META⟩key and
the period key at the same time, or else type the ⟨ESC⟩key and then type
the period key), and then, at the prompt, type in the name of the function
whose source code you want to see, such as mark-whole-buffer, and then
type ⟨RET⟩. Emacs will switch buﬀers and display the source code for the
function on your screen. To switch back to your current buﬀer, type C-x b
⟨RET⟩. (On some keyboards, the ⟨META⟩key is labelled ⟨ALT⟩.)
Depending on how the initial default values of your copy of Emacs are
set, you may also need to specify the location of your ‘tags table’, which
is a ﬁle called ‘TAGS’. For example, if you are interested in Emacs sources,
the tags table you will most likely want, if it has already been created for
you, will be in a subdirectory of the ‘/usr/local/share/emacs/’ direc-
tory; thus you would use the M-x visit-tags-table command and spec-
ify a pathname such as ‘/usr/local/share/emacs/21.0.100/lisp/TAGS’

52
Chapter 4: A Few Buﬀer–Related Functions
or ‘/usr/local/src/emacs/lisp/TAGS’. If the tags table has not already
been created, you will have to create it yourself.
To create a ‘TAGS’ ﬁle in a speciﬁc directory, switch to that directory
in Emacs using M-x cd command, or list the directory with C-x d (dired).
Then run the compile command, with etags *.el as the command to exe-
cute
M-x compile RET etags *.el RET
For more information, see Section 12.5, “Create Your Own ‘TAGS’ File”,
page 163.
After you become more familiar with Emacs Lisp, you will ﬁnd that you
will frequently use find-tags to navigate your way around source code; and
you will create your own ‘TAGS’ tables.
Incidentally, the ﬁles that contain Lisp code are conventionally called
libraries. The metaphor is derived from that of a specialized library, such as
a law library or an engineering library, rather than a general library. Each
library, or ﬁle, contains functions that relate to a particular topic or activity,
such as ‘abbrev.el’ for handling abbreviations and other typing shortcuts,
and ‘help.el’ for on-line help. (Sometimes several libraries provide code
for a single activity, as the various ‘rmail...’ ﬁles provide code for reading
electronic mail.) In The GNU Emacs Manual, you will see sentences such as
“The C-h p command lets you search the standard Emacs Lisp libraries by
topic keywords.”
4.2 A Simpliﬁed beginning-of-buffer Deﬁnition
The beginning-of-buffer command is a good function to start with
since you are likely to be familiar with it and it is easy to understand. Used
as an interactive command, beginning-of-buffer moves the cursor to the
beginning of the buﬀer, leaving the mark at the previous position.
It is
generally bound to M-<.
In this section, we will discuss a shortened version of the function that
shows how it is most frequently used.
This shortened function works as
written, but it does not contain the code for a complex option. In another
section, we will describe the entire function. (See Section 5.3, “Complete
Deﬁnition of beginning-of-buffer”, page 69.)
Before looking at the code, let’s consider what the function deﬁnition has
to contain: it must include an expression that makes the function interactive
so it can be called by typing M-x beginning-of-buffer or by typing a
keychord such as C-<; it must include code to leave a mark at the original
position in the buﬀer; and it must include code to move the cursor to the
beginning of the buﬀer.

A Simpliﬁed beginning-of-buffer Deﬁnition
53
Here is the complete text of the shortened version of the function:
(defun simplified-beginning-of-buffer ()
"Move point to the beginning of the buffer;
leave mark at previous position."
(interactive)
(push-mark)
(goto-char (point-min)))
Like all function deﬁnitions, this deﬁnition has ﬁve parts following the
special form defun:
1. The name: in this example, simplified-beginning-of-buffer.
2. A list of the arguments: in this example, an empty list, (),
3. The documentation string.
4. The interactive expression.
5. The body.
In this function deﬁnition, the argument list is empty; this means that this
function does not require any arguments. (When we look at the deﬁnition
for the complete function, we will see that it may be passed an optional
argument.)
The interactive expression tells Emacs that the function is intended to be
used interactively. In this example, interactive does not have an argument
because simplified-beginning-of-buffer does not require one.
The body of the function consists of the two lines:
(push-mark)
(goto-char (point-min))
The ﬁrst of these lines is the expression, (push-mark). When this ex-
pression is evaluated by the Lisp interpreter, it sets a mark at the current
position of the cursor, wherever that may be. The position of this mark is
saved in the mark ring.
The next line is (goto-char (point-min)). This expression jumps the
cursor to the minimum point in the buﬀer, that is, to the beginning of the
buﬀer (or to the beginning of the accessible portion of the buﬀer if it is
narrowed. See Chapter 6, “Narrowing and Widening”, page 77.)
The push-mark command sets a mark at the place where the cursor was
located before it was moved to the beginning of the buﬀer by the (goto-
char (point-min)) expression. Consequently, you can, if you wish, go back
to where you were originally by typing C-x C-x.
That is all there is to the function deﬁnition!
When you are reading code such as this and come upon an unfamiliar
function, such as goto-char, you can ﬁnd out what it does by using the
describe-function command. To use this command, type C-h f and then
type in the name of the function and press ⟨RET⟩. The describe-function

54
Chapter 4: A Few Buﬀer–Related Functions
command will print the function’s documentation string in a ‘*Help*’ win-
dow. For example, the documentation for goto-char is:
One arg, a number.
Set point to that number.
Beginning of buffer is position (point-min),
end is (point-max).
(The prompt for describe-function will oﬀer you the symbol under or
preceding the cursor, so you can save typing by positioning the cursor right
over or after the function and then typing C-h f ⟨RET⟩.)
The end-of-buffer function deﬁnition is written in the same way as
the beginning-of-buffer deﬁnition except that the body of the function
contains the expression (goto-char (point-max)) in place of (goto-char
(point-min)).
4.3 The Deﬁnition of mark-whole-buffer
The mark-whole-buffer function is no harder to understand than the
simplified-beginning-of-buffer function. In this case, however, we will
look at the complete function, not a shortened version.
The mark-whole-buffer function is not as commonly used as the
beginning-of-buffer function, but is useful nonetheless: it marks a whole
buﬀer as a region by putting point at the beginning and a mark at the end
of the buﬀer. It is generally bound to C-x h.
In GNU Emacs 20, the code for the complete function looks like this:
(defun mark-whole-buffer ()
"Put point at beginning and mark at end of buffer."
(interactive)
(push-mark (point))
(push-mark (point-max))
(goto-char (point-min)))
Like all other functions, the mark-whole-buffer function ﬁts into the
template for a function deﬁnition. The template looks like this:
(defun name-of-function (argument-list)
"documentation..."
(interactive-expression...)
body...)
Here is how the function works: the name of the function is mark-whole-
buffer; it is followed by an empty argument list, ‘()’, which means that the
function does not require arguments. The documentation comes next.
The next line is an (interactive) expression that tells Emacs that
the function will be used interactively.
These details are similar to the
simplified-beginning-of-buffer function described in the previous sec-
tion.

Body of mark-whole-buffer
55
4.3.1 Body of mark-whole-buffer
The body of the mark-whole-buffer function consists of three lines of
code:
(push-mark (point))
(push-mark (point-max))
(goto-char (point-min))
The ﬁrst of these lines is the expression, (push-mark (point)).
This line does exactly the same job as the ﬁrst line of the body of
the simplified-beginning-of-buffer function, which is written (push-
mark). In both cases, the Lisp interpreter sets a mark at the current position
of the cursor.
I don’t know why the expression in mark-whole-buffer is written (push-
mark (point)) and the expression in beginning-of-buffer is written
(push-mark). Perhaps whoever wrote the code did not know that the ar-
guments for push-mark are optional and that if push-mark is not passed an
argument, the function automatically sets mark at the location of point by
default. Or perhaps the expression was written so as to parallel the struc-
ture of the next line. In any case, the line causes Emacs to determine the
position of point and set a mark there.
The next line of mark-whole-buffer is (push-mark (point-max). This
expression sets a mark at the point in the buﬀer that has the highest number.
This will be the end of the buﬀer (or, if the buﬀer is narrowed, the end of the
accessible portion of the buﬀer. See Chapter 6, “Narrowing and Widening”,
page 77, for more about narrowing.)
After this mark has been set, the
previous mark, the one set at point, is no longer set, but Emacs remembers
its position, just as all other recent marks are always remembered. This
means that you can, if you wish, go back to that position by typing C-u
C-⟨SPC⟩twice.
(In GNU Emacs 21, the (push-mark (point-max) is slightly more com-
plicated than shown here. The line reads
(push-mark (point-max) nil t)
(The expression works nearly the same as before.
It sets a mark at the
highest numbered place in the buﬀer that it can. However, in this version,
push-mark has two additional arguments. The second argument to push-
mark is nil. This tells the function it should display a message that says
‘Mark set’ when it pushes the mark. The third argument is t. This tells
push-mark to activate the mark when Transient Mark mode is turned on.
Transient Mark mode highlights the currently active region. It is usually
turned oﬀ.)
Finally, the last line of the function is (goto-char (point-min))). This
is written exactly the same way as it is written in beginning-of-buffer.
The expression moves the cursor to the minimum point in the buﬀer, that is,
to the beginning of the buﬀer (or to the beginning of the accessible portion

56
Chapter 4: A Few Buﬀer–Related Functions
of the buﬀer). As a result of this, point is placed at the beginning of the
buﬀer and mark is set at the end of the buﬀer. The whole buﬀer is, therefore,
the region.
4.4 The Deﬁnition of append-to-buffer
The append-to-buffer command is very nearly as simple as the mark-
whole-buffer command. What it does is copy the region (that is, the part
of the buﬀer between point and mark) from the current buﬀer to a speciﬁed
buﬀer.
The append-to-buffer command uses the insert-buffer-substring
function to copy the region. insert-buffer-substring is described by its
name: it takes a string of characters from part of a buﬀer, a “substring”, and
inserts them into another buﬀer. Most of append-to-buffer is concerned
with setting up the conditions for insert-buffer-substring to work: the
code must specify both the buﬀer to which the text will go and the region
that will be copied. Here is the complete text of the function:
(defun append-to-buffer (buffer start end)
"Append to specified buffer the text of the region.
It is inserted into that buffer before its point.
When calling from a program, give three arguments:
a buffer or the name of one, and two character numbers
specifying the portion of the current buffer to be copied."
(interactive "BAppend to buffer: \nr")
(let ((oldbuf (current-buffer)))
(save-excursion
(set-buffer (get-buffer-create buffer))
(insert-buffer-substring oldbuf start end))))
The function can be understood by looking at it as a series of ﬁlled-in
templates.
The outermost template is for the function deﬁnition. In this function,
it looks like this (with several slots ﬁlled in):
(defun append-to-buffer (buffer start end)
"documentation..."
(interactive "BAppend to buffer: \nr")
body...)
The ﬁrst line of the function includes its name and three arguments. The
arguments are the buffer to which the text will be copied, and the start
and end of the region in the current buﬀer that will be copied.
The next part of the function is the documentation, which is clear and
complete.

The Body of append-to-buffer
57
4.4.1 The append-to-buffer Interactive Expression
Since the append-to-buffer function will be used interactively, the func-
tion must have an interactive expression. (For a review of interactive,
see Section 3.3, “Making a Function Interactive”, page 33.) The expression
reads as follows:
(interactive "BAppend to buffer: \nr")
This expression has an argument inside of quotation marks and that argu-
ment has two parts, separated by ‘\n’.
The ﬁrst part is ‘BAppend to buffer: ’. Here, the ‘B’ tells Emacs to ask
for the name of the buﬀer that will be passed to the function. Emacs will
ask for the name by prompting the user in the minibuﬀer, using the string
following the ‘B’, which is the string ‘Append to buffer: ’.
Emacs then
binds the variable buffer in the function’s argument list to the speciﬁed
buﬀer.
The newline, ‘\n’, separates the ﬁrst part of the argument from the second
part. It is followed by an ‘r’ that tells Emacs to bind the two arguments
that follow the symbol buffer in the function’s argument list (that is, start
and end) to the values of point and mark.
4.4.2 The Body of append-to-buffer
The body of the append-to-buffer function begins with let.
As we have seen before (see Section 3.6, “let”, page 36), the purpose of
a let expression is to create and give initial values to one or more variables
that will only be used within the body of the let. This means that such
a variable will not be confused with any variable of the same name outside
the let expression.
We can see how the let expression ﬁts into the function as a whole
by showing a template for append-to-buffer with the let expression in
outline:
(defun append-to-buffer (buffer start end)
"documentation..."
(interactive "BAppend to buffer: \nr")
(let ((variable value))
body...)
The let expression has three elements:
1. The symbol let;
2. A varlist containing, in this case, a single two-element list, (variable
value);
3. The body of the let expression.

58
Chapter 4: A Few Buﬀer–Related Functions
In the append-to-buffer function, the varlist looks like this:
(oldbuf (current-buffer))
In this part of the let expression, the one variable, oldbuf, is bound to the
value returned by the (current-buffer) expression. The variable, oldbuf,
is used to keep track of the buﬀer in which you are working and from which
you will copy.
The element or elements of a varlist are surrounded by a set of parentheses
so the Lisp interpreter can distinguish the varlist from the body of the let.
As a consequence, the two-element list within the varlist is surrounded by a
circumscribing set of parentheses. The line looks like this:
(let ((oldbuf (current-buffer)))
... )
The two parentheses before oldbuf might surprise you if you did not realize
that the ﬁrst parenthesis before oldbuf marks the boundary of the varlist
and the second parenthesis marks the beginning of the two-element list,
(oldbuf (current-buffer)).
4.4.3 save-excursion in append-to-buffer
The body of the let expression in append-to-buffer consists of a save-
excursion expression.
The save-excursion function saves the locations of point and mark,
and restores them to those positions after the expressions in the body of the
save-excursion complete execution. In addition, save-excursion keeps
track of the original buﬀer, and restores it. This is how save-excursion is
used in append-to-buffer.
Incidentally, it is worth noting here that a Lisp function is normally for-
matted so that everything that is enclosed in a multi-line spread is indented
more to the right than the ﬁrst symbol. In this function deﬁnition, the let
is indented more than the defun, and the save-excursion is indented more
than the let, like this:
(defun ...
...
...
(let...
(save-excursion
...

save-excursion in append-to-buffer
59
This formatting convention makes it easy to see that the two lines in the
body of the save-excursion are enclosed by the parentheses associated
with save-excursion, just as the save-excursion itself is enclosed by the
parentheses associated with the let:
(let ((oldbuf (current-buffer)))
(save-excursion
(set-buffer (get-buffer-create buffer))
(insert-buffer-substring oldbuf start end))))
The use of the save-excursion function can be viewed as a process of
ﬁlling in the slots of a template:
(save-excursion
ﬁrst-expression-in-body
second-expression-in-body
...
last-expression-in-body)
In this function, the body of the save-excursion contains only two expres-
sions. The body looks like this:
(set-buffer (get-buffer-create buffer))
(insert-buffer-substring oldbuf start end)
When the append-to-buffer function is evaluated, the two expressions
in the body of the save-excursion are evaluated in sequence. The value of
the last expression is returned as the value of the save-excursion function;
the other expression is evaluated only for its side eﬀects.
The ﬁrst line in the body of the save-excursion uses the set-buffer
function to change the current buﬀer to the one speciﬁed in the ﬁrst argument
to append-to-buffer. (Changing the buﬀer is the side eﬀect; as we have
said before, in Lisp, a side eﬀect is often the primary thing we want.) The
second line does the primary work of the function.
The set-buffer function changes Emacs’ attention to the buﬀer to which
the text will be copied and from which save-excursion will return.
The line looks like this:
(set-buffer (get-buffer-create buffer))
The innermost expression of this list is (get-buffer-create buffer).
This expression uses the get-buffer-create function, which either gets the
named buﬀer, or if it does not exist, creates one with the given name. This
means you can use append-to-buffer to put text into a buﬀer that did not
previously exist.
get-buffer-create also keeps set-buffer from getting an unnecessary
error: set-buffer needs a buﬀer to go to; if you were to specify a buﬀer that
does not exist, Emacs would baulk. Since get-buffer-create will create a
buﬀer if none exists, set-buffer is always provided with a buﬀer.

60
Chapter 4: A Few Buﬀer–Related Functions
The last line of append-to-buffer does the work of appending the text:
(insert-buffer-substring oldbuf start end)
The insert-buffer-substring function copies a string from the buﬀer
speciﬁed as its ﬁrst argument and inserts the string into the present buﬀer.
In this case, the argument to insert-buffer-substring is the value of the
variable created and bound by the let, namely the value of oldbuf, which
was the current buﬀer when you gave the append-to-buffer command.
After insert-buffer-substring has done its work, save-excursion
will restore the action to the original buﬀer and append-to-buffer will
have done its job.
Written in skeletal form, the workings of the body look like this:
(let (bind-oldbuf-to-value-of-current-buffer)
(save-excursion
; Keep track of buﬀer.
change-buﬀer
insert-substring-from-oldbuf-into-buﬀer)
change-back-to-original-buﬀer-when-ﬁnished
let-the-local-meaning-of-oldbuf-disappear-when-ﬁnished
In summary, append-to-buffer works as follows: it saves the value of the
current buﬀer in the variable called oldbuf. It gets the new buﬀer, creating
one if need be, and switches Emacs to it. Using the value of oldbuf, it
inserts the region of text from the old buﬀer into the new buﬀer; and then
using save-excursion, it brings you back to your original buﬀer.
In looking at append-to-buffer, you have explored a fairly complex
function. It shows how to use let and save-excursion, and how to change
to and come back from another buﬀer. Many function deﬁnitions use let,
save-excursion, and set-buffer this way.
4.5 Review
Here is a brief summary of the various functions discussed in this chapter.
describe-function
describe-variable
Print the documentation for a function or variable. Convention-
ally bound to C-h f and C-h v.
find-tag
Find the ﬁle containing the source for a function or variable and
switch buﬀers to it, positioning point at the beginning of the
item. Conventionally bound to M-. (that’s a period following
the ⟨META⟩key).

Exercises
61
save-excursion
Save the location of point and mark and restore their values after
the arguments to save-excursion have been evaluated. Also,
remember the current buﬀer and return to it.
push-mark
Set mark at a location and record the value of the previous mark
on the mark ring. The mark is a location in the buﬀer that will
keep its relative position even if text is added to or removed
from the buﬀer.
goto-char
Set point to the location speciﬁed by the value of the argument,
which can be a number, a marker, or an expression that returns
the number of a position, such as (point-min).
insert-buffer-substring
Copy a region of text from a buﬀer that is passed to the function
as an argument and insert the region into the current buﬀer.
mark-whole-buffer
Mark the whole buﬀer as a region. Normally bound to C-x h.
set-buffer
Switch the attention of Emacs to another buﬀer, but do not
change the window being displayed. Used when the program
rather than a human is to work on a diﬀerent buﬀer.
get-buffer-create
get-buffer
Find a named buﬀer or create one if a buﬀer of that name does
not exist. The get-buffer function returns nil if the named
buﬀer does not exist.
4.6 Exercises
• Write your own simplified-end-of-buffer function deﬁnition; then
test it to see whether it works.
• Use if and get-buffer to write a function that prints a message telling
you whether a buﬀer exists.
• Using find-tag, ﬁnd the source for the copy-to-buffer function.

62
Chapter 4: A Few Buﬀer–Related Functions

The Deﬁnition of copy-to-buffer
63
5 A Few More Complex Functions
In this chapter, we build on what we have learned in previous chapters by
looking at more complex functions. The copy-to-buffer function illustrates
use of two save-excursion expressions in one deﬁnition, while the insert-
buffer function illustrates use of an asterisk in an interactive expression,
use of or, and the important distinction between a name and the object to
which the name refers.
5.1 The Deﬁnition of copy-to-buffer
After understanding how append-to-buffer works, it is easy to under-
stand copy-to-buffer.
This function copies text into a buﬀer, but in-
stead of adding to the second buﬀer, it replaces the previous text in the
second buﬀer.
The code for the copy-to-buffer function is almost the
same as the code for append-to-buffer, except that erase-buffer and
a second save-excursion are used. (See Section 4.4, “The Deﬁnition of
append-to-buffer”, page 56, for the description of append-to-buffer.)
The body of copy-to-buffer looks like this
...
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
(save-excursion
(set-buffer (get-buffer-create buffer))
(erase-buffer)
(save-excursion
(insert-buffer-substring oldbuf start end)))))
This code is similar to the code in append-to-buffer: it is only after
changing to the buﬀer to which the text will be copied that the deﬁnition
for this function diverges from the deﬁnition for append-to-buffer: the
copy-to-buffer function erases the buﬀer’s former contents. (This is what
is meant by ‘replacement’; to replace text, Emacs erases the previous text
and then inserts new text.) After erasing the previous contents of the buﬀer,
save-excursion is used for a second time and the new text is inserted.
Why is save-excursion used twice? Consider again what the function
does.
In outline, the body of copy-to-buffer looks like this:
(let (bind-oldbuf-to-value-of-current-buffer)
(save-excursion
; First use of save-excursion.
change-buﬀer
(erase-buffer)
(save-excursion
; Second use of save-excursion.
insert-substring-from-oldbuf-into-buﬀer)))

64
Chapter 5: A Few More Complex Functions
The ﬁrst use of save-excursion returns Emacs to the buﬀer from which
the text is being copied. That is clear, and is just like its use in append-
to-buffer.
Why the second use?
The reason is that insert-buffer-
substring always leaves point at the end of the region being inserted. The
second save-excursion causes Emacs to leave point at the beginning of the
text being inserted. In most circumstances, users prefer to ﬁnd point at the
beginning of inserted text. (Of course, the copy-to-buffer function returns
the user to the original buﬀer when done—but if the user then switches to
the copied-to buﬀer, point will go to the beginning of the text. Thus, this
use of a second save-excursion is a little nicety.)
5.2 The Deﬁnition of insert-buffer
insert-buffer is yet another buﬀer-related function.
This command
copies another buﬀer into the current buﬀer. It is the reverse of append-
to-buffer or copy-to-buffer, since they copy a region of text from the
current buﬀer to another buﬀer.
In addition, this code illustrates the use of interactive with a buﬀer
that might be read-only and the important distinction between the name of
an object and the object actually referred to.
Here is the code:
(defun insert-buffer (buffer)
"Insert after point the contents of BUFFER.
Puts mark after the inserted text.
BUFFER may be a buffer or a buffer name."
(interactive "*bInsert buffer: ")
(or (bufferp buffer)
(setq buffer (get-buffer buffer)))
(let (start end newmark)
(save-excursion
(save-excursion
(set-buffer buffer)
(setq start (point-min) end (point-max)))
(insert-buffer-substring buffer start end)
(setq newmark (point)))
(push-mark newmark)))
As with other function deﬁnitions, you can use a template to see an
outline of the function:
(defun insert-buffer (buffer)
"documentation..."
(interactive "*bInsert buffer: ")
body...)

The Body of the insert-buffer Function
65
5.2.1 The Interactive Expression in insert-buffer
In insert-buffer, the argument to the interactive declaration has
two parts, an asterisk, ‘*’, and ‘bInsert buffer: ’.
A Read-only Buﬀer
The asterisk is for the situation when the buﬀer is a read-only buﬀer—
a buﬀer that cannot be modiﬁed. If insert-buffer is called on a buﬀer
that is read-only, a message to this eﬀect is printed in the echo area and
the terminal may beep or blink at you; you will not be permitted to insert
anything into current buﬀer. The asterisk does not need to be followed by a
newline to separate it from the next argument.
‘b’ in an Interactive Expression
The next argument in the interactive expression starts with a lower case
‘b’. (This is diﬀerent from the code for append-to-buffer, which uses an
upper-case ‘B’.
See Section 4.4, “The Deﬁnition of append-to-buffer”,
page 56.) The lower-case ‘b’ tells the Lisp interpreter that the argument for
insert-buffer should be an existing buﬀer or else its name. (The upper-
case ‘B’ option provides for the possibility that the buﬀer does not exist.)
Emacs will prompt you for the name of the buﬀer, oﬀering you a default
buﬀer, with name completion enabled.
If the buﬀer does not exist, you
receive a message that says “No match”; your terminal may beep at you as
well.
5.2.2 The Body of the insert-buffer Function
The body of the insert-buffer function has two major parts: an or
expression and a let expression. The purpose of the or expression is to
ensure that the argument buffer is bound to a buﬀer and not just the name
of a buﬀer. The body of the let expression contains the code which copies
the other buﬀer into the current buﬀer.
In outline, the two expressions ﬁt into the insert-buffer function like
this:
(defun insert-buffer (buffer)
"documentation..."
(interactive "*bInsert buffer: ")
(or ...
...
(let (varlist)
body-of-let... )

66
Chapter 5: A Few More Complex Functions
To understand how the or expression ensures that the argument buffer
is bound to a buﬀer and not to the name of a buﬀer, it is ﬁrst necessary to
understand the or function.
Before doing this, let me rewrite this part of the function using if so that
you can see what is done in a manner that will be familiar.
5.2.3 insert-buffer With an if Instead of an or
The job to be done is to make sure the value of buffer is a buﬀer itself
and not the name of a buﬀer. If the value is the name, then the buﬀer itself
must be got.
You can imagine yourself at a conference where an usher is wandering
around holding a list with your name on it and looking for you: the usher is
“bound” to your name, not to you; but when the usher ﬁnds you and takes
your arm, the usher becomes “bound” to you.
In Lisp, you might describe this situation like this:
(if (not (holding-on-to-guest))
(find-and-take-arm-of-guest))
We want to do the same thing with a buﬀer—if we do not have the buﬀer
itself, we want to get it.
Using a predicate called bufferp that tells us whether we have a buﬀer
(rather than its name), we can write the code like this:
(if (not (bufferp buffer))
; if-part
(setq buffer (get-buffer buffer)))
; then-part
Here, the true-or-false-test of the if expression is (not (bufferp buffer));
and the then-part is the expression (setq buffer (get-buffer buffer)).
In the test, the function bufferp returns true if its argument is a buﬀer—
but false if its argument is the name of the buﬀer. (The last character of
the function name bufferp is the character ‘p’; as we saw earlier, such use
of ‘p’ is a convention that indicates that the function is a predicate, which is
a term that means that the function will determine whether some property
is true or false. See Section 1.8.4, “Using the Wrong Type Object as an
Argument”, page 14.)
The function not precedes the expression (bufferp buffer), so the true-
or-false-test looks like this:
(not (bufferp buffer))
not is a function that returns true if its argument is false and false if its
argument is true. So if (bufferp buffer) returns true, the not expression
returns false and vice-versa: what is “not true” is false and what is “not
false” is true.
Using this test, the if expression works as follows: when the value of
the variable buffer is actually a buﬀer rather then its name, the true-or-
false-test returns false and the if expression does not evaluate the then-part.

The or in the Body
67
This is ﬁne, since we do not need to do anything to the variable buffer if it
really is a buﬀer.
On the other hand, when the value of buffer is not a buﬀer itself, but
the name of a buﬀer, the true-or-false-test returns true and the then-part
of the expression is evaluated. In this case, the then-part is (setq buffer
(get-buffer buffer)). This expression uses the get-buffer function to
return an actual buﬀer itself, given its name. The setq then sets the variable
buffer to the value of the buﬀer itself, replacing its previous value (which
was the name of the buﬀer).
5.2.4 The or in the Body
The purpose of the or expression in the insert-buffer function is to
ensure that the argument buffer is bound to a buﬀer and not just to the
name of a buﬀer. The previous section shows how the job could have been
done using an if expression. However, the insert-buffer function actually
uses or. To understand this, it is necessary to understand how or works.
An or function can have any number of arguments. It evaluates each
argument in turn and returns the value of the ﬁrst of its arguments that is
not nil. Also, and this is a crucial feature of or, it does not evaluate any
subsequent arguments after returning the ﬁrst non-nil value.
The or expression looks like this:
(or (bufferp buffer)
(setq buffer (get-buffer buffer)))
The ﬁrst argument to or is the expression (bufferp buffer). This expres-
sion returns true (a non-nil value) if the buﬀer is actually a buﬀer, and
not just the name of a buﬀer.
In the or expression, if this is the case,
the or expression returns this true value and does not evaluate the next
expression—and this is ﬁne with us, since we do not want to do anything to
the value of buffer if it really is a buﬀer.
On the other hand, if the value of (bufferp buffer) is nil, which it will
be if the value of buffer is the name of a buﬀer, the Lisp interpreter evaluates
the next element of the or expression. This is the expression (setq buffer
(get-buffer buffer)). This expression returns a non-nil value, which is
the value to which it sets the variable buffer—and this value is a buﬀer
itself, not the name of a buﬀer.
The result of all this is that the symbol buffer is always bound to a buﬀer
itself rather than to the name of a buﬀer. All this is necessary because the
set-buffer function in a following line only works with a buﬀer itself, not
with the name to a buﬀer.

68
Chapter 5: A Few More Complex Functions
Incidentally, using or, the situation with the usher would be written like
this:
(or (holding-on-to-guest) (find-and-take-arm-of-guest))
5.2.5 The let Expression in insert-buffer
After ensuring that the variable buffer refers to a buﬀer itself and not
just to the name of a buﬀer, the insert-buffer function continues with a
let expression. This speciﬁes three local variables, start, end, and newmark
and binds them to the initial value nil. These variables are used inside the
remainder of the let and temporarily hide any other occurrence of variables
of the same name in Emacs until the end of the let.
The body of the let contains two save-excursion expressions. First, we
will look at the inner save-excursion expression in detail. The expression
looks like this:
(save-excursion
(set-buffer buffer)
(setq start (point-min) end (point-max)))
The expression (set-buffer buffer) changes Emacs’ attention from the
current buﬀer to the one from which the text will copied. In that buﬀer,
the variables start and end are set to the beginning and end of the buﬀer,
using the commands point-min and point-max. Note that we have here an
illustration of how setq is able to set two variables in the same expression.
The ﬁrst argument of setq is set to the value of its second, and its third
argument is set to the value of its fourth.
After the body of the inner save-excursion is evaluated, the save-
excursion restores the original buﬀer, but start and end remain set to the
values of the beginning and end of the buﬀer from which the text will be
copied.
The outer save-excursion expression looks like this:
(save-excursion
(inner-save-excursion-expression
(go-to-new-buﬀer-and-set-start-and-end)
(insert-buffer-substring buffer start end)
(setq newmark (point)))
The insert-buffer-substring function copies the text into the current
buﬀer from the region indicated by start and end in buffer. Since the
whole of the second buﬀer lies between start and end, the whole of the
second buﬀer is copied into the buﬀer you are editing. Next, the value of
point, which will be at the end of the inserted text, is recorded in the variable
newmark.
After the body of the outer save-excursion is evaluated, point and mark
are relocated to their original places.

Optional Arguments
69
However, it is convenient to locate a mark at the end of the newly inserted
text and locate point at its beginning. The newmark variable records the end
of the inserted text. In the last line of the let expression, the (push-mark
newmark) expression function sets a mark to this location. (The previous
location of the mark is still accessible; it is recorded on the mark ring and
you can go back to it with C-u C-⟨SPC⟩.) Meanwhile, point is located at the
beginning of the inserted text, which is where it was before you called the
insert function.
The whole let expression looks like this:
(let (start end newmark)
(save-excursion
(save-excursion
(set-buffer buffer)
(setq start (point-min) end (point-max)))
(insert-buffer-substring buffer start end)
(setq newmark (point)))
(push-mark newmark))
Like the append-to-buffer function, the insert-buffer function uses
let, save-excursion, and set-buffer. In addition, the function illustrates
one way to use or. All these functions are building blocks that we will ﬁnd
and use again and again.
5.3 Complete Deﬁnition of beginning-of-buffer
The basic structure of the beginning-of-buffer function has already
been discussed. (See Section 4.2, “A Simpliﬁed beginning-of-buffer Def-
inition”, page 52.) This section describes the complex part of the deﬁnition.
As previously described, when invoked without an argument, beginning-
of-buffer moves the cursor to the beginning of the buﬀer, leaving the mark
at the previous position. However, when the command is invoked with a
number between one and ten, the function considers that number to be a
fraction of the length of the buﬀer, measured in tenths, and Emacs moves
the cursor that fraction of the way from the beginning of the buﬀer. Thus,
you can either call this function with the key command M-<, which will move
the cursor to the beginning of the buﬀer, or with a key command such as
C-u 7 M-< which will move the cursor to a point 70% of the way through the
buﬀer. If a number bigger than ten is used for the argument, it moves to
the end of the buﬀer.
The beginning-of-buffer function can be called with or without an
argument. The use of the argument is optional.

70
Chapter 5: A Few More Complex Functions
5.3.1 Optional Arguments
Unless told otherwise, Lisp expects that a function with an argument in
its function deﬁnition will be called with a value for that argument. If that
does not happen, you get an error and a message that says ‘Wrong number
of arguments’.
However, optional arguments are a feature of Lisp: a keyword may be
used to tell the Lisp interpreter that an argument is optional. The keyword
is &optional. (The ‘&’ in front of ‘optional’ is part of the keyword.) In a
function deﬁnition, if an argument follows the keyword &optional, a value
does not need to be passed to that argument when the function is called.
The ﬁrst line of the function deﬁnition of beginning-of-buffer therefore
looks like this:
(defun beginning-of-buffer (&optional arg)
In outline, the whole function looks like this:
(defun beginning-of-buffer (&optional arg)
"documentation..."
(interactive "P")
(push-mark)
(goto-char
(if-there-is-an-argument
ﬁgure-out-where-to-go
else-go-to
(point-min))))
The function is similar to the simplified-beginning-of-buffer func-
tion except that the interactive expression has "P" as an argument and
the goto-char function is followed by an if-then-else expression that ﬁgures
out where to put the cursor if there is an argument.
The "P" in the interactive expression tells Emacs to pass a preﬁx
argument, if there is one, to the function. A preﬁx argument is made by
typing the ⟨META⟩key followed by a number, or by typing C-u and then a
number (if you don’t type a number, C-u defaults to 4).
The true-or-false-test of the if expression is simple: it is simply the
argument arg. If arg has a value that is not nil, which will be the case if
beginning-of-buffer is called with an argument, then this true-or-false-
test will return true and the then-part of the if expression will be evaluated.
On the other hand, if beginning-of-buffer is not called with an argument,
the value of arg will be nil and the else-part of the if expression will be
evaluated. The else-part is simply point-min, and when this is the outcome,
the whole goto-char expression is (goto-char (point-min)), which is how
we saw the beginning-of-buffer function in its simpliﬁed form.

What happens in a large buﬀer
71
5.3.2 beginning-of-buffer with an Argument
When beginning-of-buffer is called with an argument, an expression is
evaluated which calculates what value to pass to goto-char. This expression
is rather complicated at ﬁrst sight. It includes an inner if expression and
much arithmetic. It looks like this:
(if (> (buffer-size) 10000)
;; Avoid overﬂow for large buﬀer sizes!
(* (prefix-numeric-value arg) (/ (buffer-size) 10))
(/
(+ 10
(*
(buffer-size) (prefix-numeric-value arg))) 10))
Like other complex-looking expressions, the conditional expression within
beginning-of-buffer can be disentangled by looking at it as parts of a
template, in this case, the template for an if-then-else expression. In skeletal
form, the expression looks like this:
(if (buﬀer-is-large
divide-buﬀer-size-by-10-and-multiply-by-arg
else-use-alternate-calculation
The true-or-false-test of this inner if expression checks the size of the
buﬀer. The reason for this is that the old Version 18 Emacs used numbers
that are no bigger than eight million or so and in the computation that
followed, the programmer feared that Emacs might try to use over-large
numbers if the buﬀer were large.
The term ‘overﬂow’, mentioned in the
comment, means numbers that are over large. Version 21 Emacs uses larger
numbers, but this code has not been touched, if only because people now
look at buﬀers that are far, far larger than ever before.
There are two cases: if the buﬀer is large and if it is not.
What happens in a large buﬀer
In beginning-of-buffer, the inner if expression tests whether the size
of the buﬀer is greater than 10,000 characters. To do this, it uses the >
function and the buffer-size function.
The line looks like this:
(if (> (buffer-size) 10000)
When the buﬀer is large, the then-part of the if expression is evaluated. It
reads like this (after formatting for easy reading):
(*
(prefix-numeric-value arg)
(/ (buffer-size) 10))
This expression is a multiplication, with two arguments to the function *.

72
Chapter 5: A Few More Complex Functions
The ﬁrst argument is (prefix-numeric-value arg). When "P" is used
as the argument for interactive, the value passed to the function as its
argument is passed a “raw preﬁx argument”, and not a number. (It is a
number in a list.) To perform the arithmetic, a conversion is necessary, and
prefix-numeric-value does the job.
The second argument is (/ (buffer-size) 10). This expression divides
the numeric value of the buﬀer by ten. This produces a number that tells
how many characters make up one tenth of the buﬀer size. (In Lisp, / is
used for division, just as * is used for multiplication.)
In the multiplication expression as a whole, this amount is multiplied by
the value of the preﬁx argument—the multiplication looks like this:
(* numeric-value-of-preﬁx-arg
number-of-characters-in-one-tenth-of-the-buﬀer)
If, for example, the preﬁx argument is ‘7’, the one-tenth value will be mul-
tiplied by 7 to give a position 70% of the way through the buﬀer.
The result of all this is that if the buﬀer is large, the goto-char expression
reads like this:
(goto-char (* (prefix-numeric-value arg)
(/ (buffer-size) 10)))
This puts the cursor where we want it.
What happens in a small buﬀer
If the buﬀer contains fewer than 10,000 characters, a slightly diﬀerent
computation is performed.
You might think this is not necessary, since
the ﬁrst computation could do the job.
However, in a small buﬀer, the
ﬁrst method may not put the cursor on exactly the desired line; the second
method does a better job.
The code looks like this:
(/ (+ 10 (* (buffer-size) (prefix-numeric-value arg))) 10))
This is code in which you ﬁgure out what happens by discovering how the
functions are embedded in parentheses. It is easier to read if you reformat
it with each expression indented more deeply than its enclosing expression:
(/
(+ 10
(*
(buffer-size)
(prefix-numeric-value arg)))
10))

The Complete beginning-of-buffer
73
Looking at parentheses, we see that the innermost operation is (prefix-
numeric-value arg), which converts the raw argument to a number. This
number is multiplied by the buﬀer size in the following expression:
(* (buffer-size) (prefix-numeric-value arg)
This multiplication creates a number that may be larger than the size of
the buﬀer—seven times larger if the argument is 7, for example.
Ten is
then added to this number and ﬁnally the large number is divided by ten to
provide a value that is one character larger than the percentage position in
the buﬀer.
The number that results from all this is passed to goto-char and the
cursor is moved to that point.
5.3.3 The Complete beginning-of-buffer
Here is the complete text of the beginning-of-buffer function:
(defun beginning-of-buffer (&optional arg)
"Move point to the beginning of the buffer;
leave mark at previous position.
With arg N, put point N/10 of the way
from the true beginning.
Don’t use this in Lisp programs!
\(goto-char (point-min)) is faster
and does not set the mark."
(interactive "P")
(push-mark)
(goto-char
(if arg
(if (> (buffer-size) 10000)
;; Avoid overﬂow for large buﬀer sizes!
(* (prefix-numeric-value arg)
(/ (buffer-size) 10))
(/ (+ 10 (* (buffer-size)
(prefix-numeric-value arg)))
10))
(point-min)))
(if arg (forward-line 1)))
Except for two small points, the previous discussion shows how this function
works. The ﬁrst point deals with a detail in the documentation string, and
the second point concerns the last line of the function.
In the documentation string, there is reference to an expression:
\(goto-char (point-min))
A ‘\’ is used before the ﬁrst parenthesis of this expression. This ‘\’ tells
the Lisp interpreter that the expression should be printed as shown in the

74
Chapter 5: A Few More Complex Functions
documentation rather than evaluated as a symbolic expression, which is what
it looks like.
Finally, the last line of the beginning-of-buffer command says to move
point to the beginning of the next line if the command is invoked with an
argument:
(if arg (forward-line 1)))
This puts the cursor at the beginning of the ﬁrst line after the appropriate
tenths position in the buﬀer. This is a ﬂourish that means that the cursor is
always located at least the requested tenths of the way through the buﬀer,
which is a nicety that is, perhaps, not necessary, but which, if it did not
occur, would be sure to draw complaints.
5.4 Review
Here is a brief summary of some of the topics covered in this chapter.
or
Evaluate each argument in sequence, and return the value of
the ﬁrst argument that is not nil; if none return a value that
is not nil, return nil. In brief, return the ﬁrst true value of
the arguments; return a true value if one or any of the other are
true.
and
Evaluate each argument in sequence, and if any are nil, return
nil; if none are nil, return the value of the last argument. In
brief, return a true value only if all the arguments are true;
return a true value if one and each of the others is true.
&optional
A keyword used to indicate that an argument to a function deﬁ-
nition is optional; this means that the function can be evaluated
without the argument, if desired.
prefix-numeric-value
Convert the ‘raw preﬁx argument’ produced by (interactive
"P") to a numeric value.
forward-line
Move point forward to the beginning of the next line, or if the
argument is greater than one, forward that many lines.
If it
can’t move as far forward as it is supposed to, forward-line
goes forward as far as it can and then returns a count of the
number of additional lines it was supposed to move but couldn’t.
erase-buffer
Delete the entire contents of the current buﬀer.
bufferp
Return t if its argument is a buﬀer; otherwise return nil.

optional Argument Exercise
75
5.5 optional Argument Exercise
Write an interactive function with an optional argument that tests
whether its argument, a number, is greater or less than the value of fill-
column, and tells you which, in a message. However, if you do not pass an
argument to the function, use 56 as a default value.

76
Chapter 5: A Few More Complex Functions

The save-restriction Special Form
77
6 Narrowing and Widening
Narrowing is a feature of Emacs that makes it possible for you to focus
on a speciﬁc part of a buﬀer, and work without accidentally changing other
parts. Narrowing is normally disabled since it can confuse novices.
With narrowing, the rest of a buﬀer is made invisible, as if it weren’t
there. This is an advantage if, for example, you want to replace a word in
one part of a buﬀer but not in another: you narrow to the part you want
and the replacement is carried out only in that section, not in the rest of
the buﬀer. Searches will only work within a narrowed region, not outside of
one, so if you are ﬁxing a part of a document, you can keep yourself from
accidentally ﬁnding parts you do not need to ﬁx by narrowing just to the
region you want. (The key binding for narrow-to-region is C-x n n.)
However, narrowing does make the rest of the buﬀer invisible, which can
scare people who inadvertently invoke narrowing and think they have deleted
a part of their ﬁle. Moreover, the undo command (which is usually bound
to C-x u) does not turn oﬀnarrowing (nor should it), so people can become
quite desperate if they do not know that they can return the rest of a buﬀer
to visibility with the widen command. (The key binding for widen is C-x n
w.)
Narrowing is just as useful to the Lisp interpreter as to a human. Often,
an Emacs Lisp function is designed to work on just part of a buﬀer; or
conversely, an Emacs Lisp function needs to work on all of a buﬀer that
has been narrowed.
The what-line function, for example, removes the
narrowing from a buﬀer, if it has any narrowing and when it has ﬁnished its
job, restores the narrowing to what it was. On the other hand, the count-
lines function, which is called by what-line, uses narrowing to restrict
itself to just that portion of the buﬀer in which it is interested and then
restores the previous situation.
6.1 The save-restriction Special Form
In Emacs Lisp, you can use the save-restriction special form to keep
track of whatever narrowing is in eﬀect, if any. When the Lisp interpreter
meets with save-restriction, it executes the code in the body of the save-
restriction expression, and then undoes any changes to narrowing that the
code caused. If, for example, the buﬀer is narrowed and the code that follows
save-restriction gets rid of the narrowing, save-restriction returns the
buﬀer to its narrowed region afterwards. In the what-line command, any
narrowing the buﬀer may have is undone by the widen command that im-
mediately follows the save-restriction command. Any original narrowing
is restored just before the completion of the function.

78
Chapter 6: Narrowing and Widening
The template for a save-restriction expression is simple:
(save-restriction
body... )
The body of the save-restriction is one or more expressions that will be
evaluated in sequence by the Lisp interpreter.
Finally, a point to note: when you use both save-excursion and save-
restriction, one right after the other, you should use save-excursion out-
ermost. If you write them in reverse order, you may fail to record narrowing
in the buﬀer to which Emacs switches after calling save-excursion. Thus,
when written together, save-excursion and save-restriction should be
written like this:
(save-excursion
(save-restriction
body...))
In other circumstances, when not written together, the save-excursion
and save-restriction special forms must be written in the order appro-
priate to the function.
For example,
(save-restriction
(widen)
(save-excursion
body...))
6.2 what-line
The what-line command tells you the number of the line in which the
cursor is located. The function illustrates the use of the save-restriction
and save-excursion commands. Here is the text of the function in full:
(defun what-line ()
"Print the current line number (in the buffer) of point."
(interactive)
(save-restriction
(widen)
(save-excursion
(beginning-of-line)
(message "Line %d"
(1+ (count-lines 1 (point)))))))
The function has a documentation line and is interactive, as you would
expect. The next two lines use the functions save-restriction and widen.
The save-restriction special form notes whatever narrowing is in ef-
fect, if any, in the current buﬀer and restores that narrowing after the code
in the body of the save-restriction has been evaluated.

Exercise with Narrowing
79
The save-restriction special form is followed by widen. This function
undoes any narrowing the current buﬀer may have had when what-line
was called.
(The narrowing that was there is the narrowing that save-
restriction remembers.)
This widening makes it possible for the line
counting commands to count from the beginning of the buﬀer. Otherwise,
they would have been limited to counting within the accessible region. Any
original narrowing is restored just before the completion of the function by
the save-restriction special form.
The call to widen is followed by save-excursion, which saves the loca-
tion of the cursor (i.e., of point) and of the mark, and restores them after
the code in the body of the save-excursion uses the beginning-of-line
function to move point.
(Note that the (widen) expression comes between the save-restriction
and save-excursion special forms.
When you write the two save- ...
expressions in sequence, write save-excursion outermost.)
The last two lines of the what-line function are functions to count the
number of lines in the buﬀer and then print the number in the echo area.
(message "Line %d"
(1+ (count-lines 1 (point)))))))
The message function prints a one-line message at the bottom of the
Emacs screen. The ﬁrst argument is inside of quotation marks and is printed
as a string of characters. However, it may contain ‘%d’, ‘%s’, or ‘%c’ to print
arguments that follow the string. ‘%d’ prints the argument as a decimal, so
the message will say something such as ‘Line 243’.
The number that is printed in place of the ‘%d’ is computed by the last
line of the function:
(1+ (count-lines 1 (point)))
What this does is count the lines from the ﬁrst position of the buﬀer, indi-
cated by the 1, up to (point), and then add one to that number. (The 1+
function adds one to its argument.) We add one to it because line 2 has only
one line before it, and count-lines counts only the lines before the current
line.
After count-lines has done its job, and the message has been printed in
the echo area, the save-excursion restores point and mark to their original
positions; and save-restriction restores the original narrowing, if any.
6.3 Exercise with Narrowing
Write a function that will display the ﬁrst 60 characters of the current
buﬀer, even if you have narrowed the buﬀer to its latter half so that the ﬁrst
line is inaccessible. Restore point, mark, and narrowing. For this exercise,
you need to use save-restriction, widen, goto-char, point-min, buffer-
substring, message, and other functions, a whole potpourri.

80
Chapter 6: Narrowing and Widening

car and cdr
81
7 car, cdr, cons: Fundamental Functions
In Lisp, car, cdr, and cons are fundamental functions. The cons function
is used to construct lists, and the car and cdr functions are used to take
them apart.
In the walk through of the copy-region-as-kill function, we will see
cons as well as two variants on cdr, namely, setcdr and nthcdr.
(See
Section 8.5, “copy-region-as-kill”, page 102.)
The name of the cons function is not unreasonable: it is an abbreviation
of the word ‘construct’. The origins of the names for car and cdr, on the
other hand, are esoteric: car is an acronym from the phrase ‘Contents of
the Address part of the Register’; and cdr (pronounced ‘could-er’) is an
acronym from the phrase ‘Contents of the Decrement part of the Register’.
These phrases refer to speciﬁc pieces of hardware on the very early computer
on which the original Lisp was developed. Besides being obsolete, the phrases
have been completely irrelevant for more than 25 years to anyone thinking
about Lisp. Nonetheless, although a few brave scholars have begun to use
more reasonable names for these functions, the old terms are still in use. In
particular, since the terms are used in the Emacs Lisp source code, we will
use them in this introduction.
7.1 car and cdr
The car of a list is, quite simply, the ﬁrst item in the list. Thus the car
of the list (rose violet daisy buttercup) is rose.
If you are reading this in Info in GNU Emacs, you can see this by evalu-
ating the following:
(car ’(rose violet daisy buttercup))
After evaluating the expression, rose will appear in the echo area.
Clearly, a more reasonable name for the car function would be first
and this is often suggested.
car does not remove the ﬁrst item from the list; it only reports what it
is. After car has been applied to a list, the list is still the same as it was. In
the jargon, car is ‘non-destructive’. This feature turns out to be important.
The cdr of a list is the rest of the list, that is, the cdr function returns
the part of the list that follows the ﬁrst item. Thus, while the car of the
list ’(rose violet daisy buttercup) is rose, the rest of the list, the value
returned by the cdr function, is (violet daisy buttercup).

82
Chapter 7: car, cdr, cons: Fundamental Functions
You can see this by evaluating the following in the usual way:
(cdr ’(rose violet daisy buttercup))
When you evaluate this, (violet daisy buttercup) will appear in the echo
area.
Like car, cdr does not remove any elements from the list—it just returns
a report of what the second and subsequent elements are.
Incidentally, in the example, the list of ﬂowers is quoted. If it were not, the
Lisp interpreter would try to evaluate the list by calling rose as a function.
In this example, we do not want to do that.
Clearly, a more reasonable name for cdr would be rest.
(There is a lesson here: when you name new functions, consider very
carefully what you are doing, since you may be stuck with the names for far
longer than you expect. The reason this document perpetuates these names
is that the Emacs Lisp source code uses them, and if I did not use them,
you would have a hard time reading the code; but do, please, try to avoid
using these terms yourself. The people who come after you will be grateful
to you.)
When car and cdr are applied to a list made up of symbols, such as the
list (pine fir oak maple), the element of the list returned by the function
car is the symbol pine without any parentheses around it. pine is the ﬁrst
element in the list. However, the cdr of the list is a list itself, (fir oak
maple), as you can see by evaluating the following expressions in the usual
way:
(car ’(pine fir oak maple))
(cdr ’(pine fir oak maple))
On the other hand, in a list of lists, the ﬁrst element is itself a list. car
returns this ﬁrst element as a list. For example, the following list contains
three sub-lists, a list of carnivores, a list of herbivores and a list of sea
mammals:
(car ’((lion tiger cheetah)
(gazelle antelope zebra)
(whale dolphin seal)))
In this example, the ﬁrst element or car of the list is the list of carnivores,
(lion tiger cheetah), and the rest of the list is ((gazelle antelope
zebra) (whale dolphin seal)).
(cdr ’((lion tiger cheetah)
(gazelle antelope zebra)
(whale dolphin seal)))
It is worth saying again that car and cdr are non-destructive—that is,
they do not modify or change lists to which they are applied. This is very
important for how they are used.

cons
83
Also, in the ﬁrst chapter, in the discussion about atoms, I said that in
Lisp, “certain kinds of atom, such as an array, can be separated into parts;
but the mechanism for doing this is diﬀerent from the mechanism for splitting
a list. As far as Lisp is concerned, the atoms of a list are unsplittable.”
(See Section 1.1.1, “Lisp Atoms”, page 1.) The car and cdr functions are
used for splitting lists and are considered fundamental to Lisp. Since they
cannot split or gain access to the parts of an array, an array is considered an
atom. Conversely, the other fundamental function, cons, can put together
or construct a list, but not an array. (Arrays are handled by array-speciﬁc
functions. See section “Arrays” in The GNU Emacs Lisp Reference Manual.)
7.2 cons
The cons function constructs lists; it is the inverse of car and cdr. For
example, cons can be used to make a four element list from the three element
list, (fir oak maple):
(cons ’pine ’(fir oak maple))
After evaluating this list, you will see
(pine fir oak maple)
appear in the echo area. cons puts a new element at the beginning of a list;
it attaches or pushes elements onto the list.
cons must have a list to attach to.1 You cannot start from absolutely
nothing. If you are building a list, you need to provide at least an empty
list at the beginning. Here is a series of cons expressions that build up a list
of ﬂowers. If you are reading this in Info in GNU Emacs, you can evaluate
each of the expressions in the usual way; the value is printed in this text
after ‘⇒’, which you may read as ‘evaluates to’.
(cons ’buttercup ())
⇒(buttercup)
(cons ’daisy ’(buttercup))
⇒(daisy buttercup)
(cons ’violet ’(daisy buttercup))
⇒(violet daisy buttercup)
(cons ’rose ’(violet daisy buttercup))
⇒(rose violet daisy buttercup)
In the ﬁrst example, the empty list is shown as () and a list made up
of buttercup followed by the empty list is constructed. As you can see,
the empty list is not shown in the list that was constructed. All that you
see is (buttercup). The empty list is not counted as an element of a list
1 Actually, you can cons an element to an atom to produce a dotted pair. Dotted pairs
are not discussed here; see section “Dotted Pair Notation” in The GNU Emacs Lisp
Reference Manual.

84
Chapter 7: car, cdr, cons: Fundamental Functions
because there is nothing in an empty list. Generally speaking, an empty list
is invisible.
The second example, (cons ’daisy ’(buttercup)) constructs a new,
two element list by putting daisy in front of buttercup; and the third
example constructs a three element list by putting violet in front of daisy
and buttercup.
7.2.1 Find the Length of a List: length
You can ﬁnd out how many elements there are in a list by using the Lisp
function length, as in the following examples:
(length ’(buttercup))
⇒1
(length ’(daisy buttercup))
⇒2
(length (cons ’violet ’(daisy buttercup)))
⇒3
In the third example, the cons function is used to construct a three element
list which is then passed to the length function as its argument.
We can also use length to count the number of elements in an empty
list:
(length ())
⇒0
As you would expect, the number of elements in an empty list is zero.
An interesting experiment is to ﬁnd out what happens if you try to ﬁnd
the length of no list at all; that is, if you try to call length without giving
it an argument, not even an empty list:
(length )
What you see, if you evaluate this, is the error message
Wrong number of arguments: #<subr length>, 0
This means that the function receives the wrong number of arguments, zero,
when it expects some other number of arguments. In this case, one argument
is expected, the argument being a list whose length the function is measuring.
(Note that one list is one argument, even if the list has many elements inside
it.)
The part of the error message that says ‘#<subr length>’ is the name of
the function. This is written with a special notation, ‘#<subr’, that indicates
that the function length is one of the primitive functions written in C rather
than in Emacs Lisp. (‘subr’ is an abbreviation for ‘subroutine’.) See section
“What Is a Function?” in The GNU Emacs Lisp Reference Manual, for more
about subroutines.

nthcdr
85
7.3 nthcdr
The nthcdr function is associated with the cdr function. What it does
is take the cdr of a list repeatedly.
If you take the cdr of the list (pine fir oak maple), you will be returned
the list (fir oak maple).
If you repeat this on what was returned, you
will be returned the list (oak maple). (Of course, repeated cdring on the
original list will just give you the original cdr since the function does not
change the list. You need to evaluate the cdr of the cdr and so on.) If you
continue this, eventually you will be returned an empty list, which in this
case, instead of being shown as () is shown as nil.
For review, here is a series of repeated cdrs, the text following the ‘⇒’
shows what is returned.
(cdr ’(pine fir oak maple))
⇒(fir oak maple)
(cdr ’(fir oak maple))
⇒(oak maple)
(cdr ’(oak maple))
⇒(maple)
(cdr ’(maple))
⇒nil
(cdr ’nil)
⇒nil
(cdr ())
⇒nil
You can also do several cdrs without printing the values in between, like
this:
(cdr (cdr ’(pine fir oak maple)))
⇒(oak maple)
In this example, the Lisp interpreter evaluates the innermost list ﬁrst. The
innermost list is quoted, so it just passes the list as it is to the innermost cdr.
This cdr passes a list made up of the second and subsequent elements of the
list to the outermost cdr, which produces a list composed of the third and
subsequent elements of the original list. In this example, the cdr function is
repeated and returns a list that consists of the original list without its ﬁrst
two elements.
The nthcdr function does the same as repeating the call to cdr. In the
following example, the argument 2 is passed to the function nthcdr, along
with the list, and the value returned is the list without its ﬁrst two items,
which is exactly the same as repeating cdr twice on the list:
(nthcdr 2 ’(pine fir oak maple))
⇒(oak maple)

86
Chapter 7: car, cdr, cons: Fundamental Functions
Using the original four element list, we can see what happens when various
numeric arguments are passed to nthcdr, including 0, 1, and 5:
;; Leave the list as it was.
(nthcdr 0 ’(pine fir oak maple))
⇒(pine fir oak maple)
;; Return a copy without the ﬁrst element.
(nthcdr 1 ’(pine fir oak maple))
⇒(fir oak maple)
;; Return a copy of the list without three elements.
(nthcdr 3 ’(pine fir oak maple))
⇒(maple)
;; Return a copy lacking all four elements.
(nthcdr 4 ’(pine fir oak maple))
⇒nil
;; Return a copy lacking all elements.
(nthcdr 5 ’(pine fir oak maple))
⇒nil
7.4 nth
The nthcdr function takes the cdr of a list repeatedly. The nth function
takes the car of the result returned by nthcdr. It returns the Nth element
of the list.
Thus, if it were not deﬁned in C for speed, the deﬁnition of nth would
be:
(defun nth (n list)
"Returns the Nth element of LIST.
N counts from zero.
If LIST is not that long, nil is returned."
(car (nthcdr n list)))
(Originally, nth was deﬁned in Emacs Lisp in ‘subr.el’, but its deﬁnition
was redone in C in the 1980s.)
The nth function returns a single element of a list. This can be very
convenient.
Note that the elements are numbered from zero, not one.
That is to
say, the ﬁrst element of a list, its car is the zeroth element. This is called
‘zero-based’ counting and often bothers people who are accustomed to the
ﬁrst element in a list being number one, which is ‘one-based’.

setcdr
87
For example:
(nth 0 ’("one" "two" "three"))
⇒"one"
(nth 1 ’("one" "two" "three"))
⇒"two"
It is worth mentioning that nth, like nthcdr and cdr, does not change
the original list—the function is non-destructive. This is in sharp contrast
to the setcar and setcdr functions.
7.5 setcar
As you might guess from their names, the setcar and setcdr functions
set the car or the cdr of a list to a new value. They actually change the
original list, unlike car and cdr which leave the original list as it was. One
way to ﬁnd out how this works is to experiment. We will start with the
setcar function.
First, we can make a list and then set the value of a variable to the list,
using the setq function. Here is a list of animals:
(setq animals ’(antelope giraffe lion tiger))
If you are reading this in Info inside of GNU Emacs, you can evaluate this
expression in the usual fashion, by positioning the cursor after the expression
and typing C-x C-e.
(I’m doing this right here as I write this.
This is
one of the advantages of having the interpreter built into the computing
environment.)
When we evaluate the variable animals, we see that it is bound to the
list (antelope giraffe lion tiger):
animals
⇒(antelope giraffe lion tiger)
Put another way, the variable animals points to the list (antelope giraffe
lion tiger).
Next, evaluate the function setcar while passing it two arguments, the
variable animals and the quoted symbol hippopotamus; this is done by
writing the three element list (setcar animals ’hippopotamus) and then
evaluating it in the usual fashion:
(setcar animals ’hippopotamus)
After evaluating this expression, evaluate the variable animals again. You
will see that the list of animals has changed:
animals
⇒(hippopotamus giraffe lion tiger)
The ﬁrst element on the list, antelope is replaced by hippopotamus.

88
Chapter 7: car, cdr, cons: Fundamental Functions
So we can see that setcar did not add a new element to the list as cons
would have; it replaced giraffe with hippopotamus; it changed the list.
7.6 setcdr
The setcdr function is similar to the setcar function, except that the
function replaces the second and subsequent elements of a list rather than
the ﬁrst element.
To see how this works, set the value of the variable to a list of domesti-
cated animals by evaluating the following expression:
(setq domesticated-animals ’(horse cow sheep goat))
If you now evaluate the list, you will be returned the list (horse cow sheep
goat):
domesticated-animals
⇒(horse cow sheep goat)
Next, evaluate setcdr with two arguments, the name of the variable
which has a list as its value, and the list to which the cdr of the ﬁrst list
will be set;
(setcdr domesticated-animals ’(cat dog))
If you evaluate this expression, the list (cat dog) will appear in the echo
area. This is the value returned by the function. The result we are inter-
ested in is the “side eﬀect”, which we can see by evaluating the variable
domesticated-animals:
domesticated-animals
⇒(horse cat dog)
Indeed, the list is changed from (horse cow sheep goat) to (horse cat
dog). The cdr of the list is changed from (cow sheep goat) to (cat dog).
7.7 Exercise
Construct a list of four birds by evaluating several expressions with cons.
Find out what happens when you cons a list onto itself. Replace the ﬁrst
element of the list of four birds with a ﬁsh. Replace the rest of that list with
a list of other ﬁsh.

zap-to-char
89
8 Cutting and Storing Text
Whenever you cut or clip text out of a buﬀer with a ‘kill’ command in
GNU Emacs, it is stored in a list and you can bring it back with a ‘yank’
command.
(The use of the word ‘kill’ in Emacs for processes which speciﬁcally do
not destroy the values of the entities is an unfortunate historical accident.
A much more appropriate word would be ‘clip’ since that is what the kill
commands do; they clip text out of a buﬀer and put it into storage from
which it can be brought back. I have often been tempted to replace globally
all occurrences of ‘kill’ in the Emacs sources with ‘clip’ and all occurrences
of ‘killed’ with ‘clipped’.)
When text is cut out of a buﬀer, it is stored on a list. Successive pieces
of text are stored on the list successively, so the list might look like this:
("a piece of text" "previous piece")
The function cons can be used to add a piece of text to the list, like this:
(cons "another piece"
’("a piece of text" "previous piece"))
If you evaluate this expression, a list of three elements will appear in the
echo area:
("another piece" "a piece of text" "previous piece")
With the car and nthcdr functions, you can retrieve whichever piece of
text you want. For example, in the following code, nthcdr 1 ... returns
the list with the ﬁrst item removed; and the car returns the ﬁrst element of
that remainder—the second element of the original list:
(car (nthcdr 1 ’("another piece"
"a piece of text"
"previous piece")))
⇒"a piece of text"
The actual functions in Emacs are more complex than this, of course.
The code for cutting and retrieving text has to be written so that Emacs
can ﬁgure out which element in the list you want—the ﬁrst, second, third,
or whatever. In addition, when you get to the end of the list, Emacs should
give you the ﬁrst element of the list, rather than nothing at all.
The list that holds the pieces of text is called the kill ring. This chapter
leads up to a description of the kill ring and how it is used by ﬁrst tracing how
the zap-to-char function works. This function uses (or ‘calls’) a function
that invokes a function that manipulates the kill ring. Thus, before reaching
the mountains, we climb the foothills.
A subsequent chapter describes how text that is cut from the buﬀer is
retrieved. See Chapter 10, “Yanking Text Back”, page 117.

90
Chapter 8: Cutting and Storing Text
8.1 zap-to-char
The zap-to-char function barely changed between GNU Emacs version
19 and GNU Emacs version 21. However, zap-to-char calls another func-
tion, kill-region, which enjoyed a major rewrite on the way to version
21.
The kill-region function in Emacs 19 is complex, but does not use code
that is important at this time. We will skip it.
The kill-region function in Emacs 21 is easier to read than the same
function in Emacs 19 and introduces a very important concept, that of error
handling. We will walk through the function.
But ﬁrst, let us look at the interactive zap-to-char function.
The GNU Emacs version 19 and version 21 implementations of the zap-
to-char function are nearly identical in form, and they work alike. The
function removes the text in the region between the location of the cursor
(i.e., of point) up to and including the next occurrence of a speciﬁed charac-
ter. The text that zap-to-char removes is put in the kill ring; and it can be
retrieved from the kill ring by typing C-y (yank). If the command is given
an argument, it removes text through that number of occurrences. Thus, if
the cursor were at the beginning of this sentence and the character were ‘s’,
‘Thus’ would be removed. If the argument were two, ‘Thus, if the curs’
would be removed, up to and including the ‘s’ in ‘cursor’.
If the speciﬁed character is not found, zap-to-char will say “Search
failed”, tell you the character you typed, and not remove any text.
In order to determine how much text to remove, zap-to-char uses a
search function. Searches are used extensively in code that manipulates text,
and we will focus attention on them as well as on the deletion command.
Here is the complete text of the version 19 implementation of the function:
(defun zap-to-char (arg char)
; version 19 implementation
"Kill up to and including ARG’th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
(interactive "*p\ncZap to char: ")
(kill-region (point)
(progn
(search-forward
(char-to-string char) nil nil arg)
(point))))
8.1.1 The interactive Expression
The interactive expression in the zap-to-char command looks like this:
(interactive "*p\ncZap to char: ")
The part within quotation marks, "*p\ncZap to char: ", speciﬁes three
diﬀerent things. First, and most simply, the asterisk, ‘*’, causes an error to

The search-forward Function
91
be signalled if the buﬀer is read-only. This means that if you try zap-to-
char in a read-only buﬀer you will not be able to remove text, and you will
receive a message that says “Buﬀer is read-only”; your terminal may beep
at you as well.
The version 21 implementation does not have the asterisk, ‘*’. The func-
tion works the same as in version 19: in both cases, it cannot remove text
from a read-only buﬀer but the function does copy the text that would have
been removed to the kill ring. Also, in both cases, you see an error message.
However, the version 19 implementation copies text from a read-only
buﬀer only because of a mistake in the implementation of interactive.
According to the documentation for interactive, the asterisk, ‘*’, should
prevent the zap-to-char function from doing anything at all when the buﬀer
is read only. The function should not copy the text to the kill ring. It is a
bug that it does.
In version 21, interactive is implemented correctly. So the asterisk, ‘*’,
had to be removed from the interactive speciﬁcation. If you insert an ‘*’ and
evaluate the function deﬁnition, then the next time you run the zap-to-char
function on a read-only buﬀer, you will not copy any text.
That change aside, and a change to the documentation, the two versions
of the zap-to-char function are identical.
Let us continue with the interactive speciﬁcation.
The second part of "*p\ncZap to char: " is the ‘p’. This part is sepa-
rated from the next part by a newline, ‘\n’. The ‘p’ means that the ﬁrst
argument to the function will be passed the value of a ‘processed preﬁx’.
The preﬁx argument is passed by typing C-u and a number, or M- and a
number. If the function is called interactively without a preﬁx, 1 is passed
to this argument.
The third part of "*p\ncZap to char: " is ‘cZap to char: ’. In this part,
the lower case ‘c’ indicates that interactive expects a prompt and that the
argument will be a character. The prompt follows the ‘c’ and is the string
‘Zap to char: ’ (with a space after the colon to make it look good).
What all this does is prepare the arguments to zap-to-char so they are
of the right type, and give the user a prompt.
8.1.2 The Body of zap-to-char
The body of the zap-to-char function contains the code that kills (that
is, removes) the text in the region from the current position of the cursor
up to and including the speciﬁed character. The ﬁrst part of the code looks
like this:
(kill-region (point) ...
(point) is the current position of the cursor.
The next part of the code is an expression using progn. The body of the
progn consists of calls to search-forward and point.

92
Chapter 8: Cutting and Storing Text
It is easier to understand how progn works after learning about search-
forward, so we will look at search-forward and then at progn.
8.1.3 The search-forward Function
The search-forward function is used to locate the zapped-for-character
in zap-to-char. If the search is successful, search-forward leaves point
immediately after the last character in the target string. (In zap-to-char,
the target string is just one character long.)
If the search is backwards,
search-forward leaves point just before the ﬁrst character in the target.
Also, search-forward returns t for true. (Moving point is therefore a ‘side
eﬀect’.)
In zap-to-char, the search-forward function looks like this:
(search-forward (char-to-string char) nil nil arg)
The search-forward function takes four arguments:
1. The ﬁrst argument is the target, what is searched for. This must be a
string, such as ‘"z"’.
As it happens, the argument passed to zap-to-char is a single charac-
ter. Because of the way computers are built, the Lisp interpreter may
treat a single character as being diﬀerent from a string of characters.
Inside the computer, a single character has a diﬀerent electronic format
than a string of one character. (A single character can often be recorded
in the computer using exactly one byte; but a string may be longer, and
the computer needs to be ready for this.) Since the search-forward
function searches for a string, the character that the zap-to-char func-
tion receives as its argument must be converted inside the computer
from one format to the other; otherwise the search-forward function
will fail. The char-to-string function is used to make this conversion.
2. The second argument bounds the search; it is speciﬁed as a position in
the buﬀer. In this case, the search can go to the end of the buﬀer, so
no bound is set and the second argument is nil.
3. The third argument tells the function what it should do if the search
fails—it can signal an error (and print a message) or it can return nil.
A nil as the third argument causes the function to signal an error when
the search fails.
4. The fourth argument to search-forward is the repeat count—how
many occurrences of the string to look for. This argument is optional
and if the function is called without a repeat count, this argument is
passed the value 1. If this argument is negative, the search goes back-
wards.

Summing up zap-to-char
93
In template form, a search-forward expression looks like this:
(search-forward "target-string"
limit-of-search
what-to-do-if-search-fails
repeat-count)
We will look at progn next.
8.1.4 The progn Special Form
progn is a special form that causes each of its arguments to be evaluated
in sequence and then returns the value of the last one. The preceding ex-
pressions are evaluated only for the side eﬀects they perform. The values
produced by them are discarded.
The template for a progn expression is very simple:
(progn
body...)
In zap-to-char, the progn expression has to do two things: put point
in exactly the right position; and return the location of point so that kill-
region will know how far to kill to.
The ﬁrst argument to the progn is search-forward.
When search-
forward ﬁnds the string, the function leaves point immediately after the
last character in the target string. (In this case the target string is just one
character long.) If the search is backwards, search-forward leaves point
just before the ﬁrst character in the target. The movement of point is a side
eﬀect.
The second and last argument to progn is the expression (point). This
expression returns the value of point, which in this case will be the location
to which it has been moved by search-forward.
This value is returned
by the progn expression and is passed to kill-region as kill-region’s
second argument.
8.1.5 Summing up zap-to-char
Now that we have seen how search-forward and progn work, we can
see how the zap-to-char function works as a whole.
The ﬁrst argument to kill-region is the position of the cursor when the
zap-to-char command is given—the value of point at that time. Within
the progn, the search function then moves point to just after the zapped-
to-character and point returns the value of this location. The kill-region
function puts together these two values of point, the ﬁrst one as the beginning
of the region and the second one as the end of the region, and removes the
region.
The progn special form is necessary because the kill-region command
takes two arguments; and it would fail if search-forward and point ex-

94
Chapter 8: Cutting and Storing Text
pressions were written in sequence as two additional arguments. The progn
expression is a single argument to kill-region and returns the one value
that kill-region needs for its second argument.
8.2 kill-region
The zap-to-char function uses the kill-region function. This function
clips text from a region and copies that text to the kill ring, from which it
may be retrieved.
The Emacs 21 version of that function uses condition-case and copy-
region-as-kill, both of which we will explain.
condition-case is an
important special form.
In essence, the kill-region function calls condition-case, which takes
three arguments. In this function, the ﬁrst argument does nothing. The
second argument contains the code that does the work when all goes well.
The third argument contains the code that is called in the event of an error.
We will go through the condition-case code in a moment. First, let us
look at the complete deﬁnition of kill-region, with comments added:
(defun kill-region (beg end)
"Kill between point and mark.
The text is deleted but saved in the kill ring."
(interactive "r")
;; 1. ‘condition-case’ takes three arguments.
;;
If the first argument is nil, as it is here,
;;
information about the error signal is not
;;
stored for use by another function.
(condition-case nil
;; 2. The second argument to ‘condition-case’
;;
tells the Lisp interpreter what to do when all goes well.
;;
The ‘delete-and-extract-region’ function usually does the
;;
work.
If the beginning and ending of the region are both
;;
the same, then the variable ‘string’ will be empty, or nil
(let ((string (delete-and-extract-region beg end)))
;; ‘when’ is an ‘if’ clause that cannot take an ‘else-part’.
;; Emacs normally sets the value of ‘last-command’ to the
;; previous command.

condition-case
95
;; ‘kill-append’ concatenates the new string and the old.
;; ‘kill-new’ inserts text into a new item in the kill ring.
(when string
(if (eq last-command ’kill-region)
;; if true, prepend string
(kill-append string (< end beg))
(kill-new string)))
(setq this-command ’kill-region))
;; 3. The third argument to ‘condition-case’ tells the interpreter
;;
what to do with an error.
;;
The third argument has a conditions part and a body part.
;;
If the conditions are met (in this case,
;;
if text or buffer is read-only)
;;
then the body is executed.
((buffer-read-only text-read-only) ;; this is the if-part
;; then...
(copy-region-as-kill beg end)
(if kill-read-only-ok
;; usually this variable is nil
(message "Read only text copied to kill ring")
;; or else, signal an error if the buffer is read-only;
(barf-if-buffer-read-only)
;; and, in any case, signal that the text is read-only.
(signal ’text-read-only (list (current-buffer)))))))
8.2.1 condition-case
As we have seen earlier (see Section 1.3, “Generate an Error Message”,
page 4), when the Emacs Lisp interpreter has trouble evaluating an expres-
sion, it provides you with help; in the jargon, this is called “signaling an
error”. Usually, the computer stops the program and shows you a message.
However, some programs undertake complicated actions. They should not
simply stop on an error. In the kill-region function, the most likely error
is that you will try to kill text that is read-only and cannot be removed. So
the kill-region function contains code to handle this circumstance. This
code, which makes up the body of the kill-region function, is inside of a
condition-case special form.
The template for condition-case looks like this:
(condition-case
var
bodyform
error-handler...)
The second argument, bodyform, is straightforward. The condition-
case special form causes the Lisp interpreter to evaluate the code in body-

96
Chapter 8: Cutting and Storing Text
form.
If no error occurs, the special form returns the code’s value and
produces the side-eﬀects, if any.
In short, the bodyform part of a condition-case expression determines
what should happen when everything works correctly.
However, if an error occurs, among its other actions, the function gener-
ating the error signal will deﬁne one or more error condition names.
An error handler is the third argument to condition case. An error
handler has two parts, a condition-name and a body. If the condition-name
part of an error handler matches a condition name generated by an error,
then the body part of the error handler is run.
As you will expect, the condition-name part of an error handler may be
either a single condition name or a list of condition names.
Also, a complete condition-case expression may contain more than one
error handler. When an error occurs, the ﬁrst applicable handler is run.
Lastly, the ﬁrst argument to the condition-case expression, the var
argument, is sometimes bound to a variable that contains information about
the error. However, if that argument is nil, as is the case in kill-region,
that information is discarded.
In brief, in the kill-region function, the code condition-case works
like this:
If no errors, run only this code
but, if errors, run this other code.
8.2.2 delete-and-extract-region
A condition-case expression has two parts, a part that is evaluated in
the expectation that all will go well, but which may generate an error; and
a part that is evaluated when there is an error.
First, let us look at the code in kill-region that is run in the expectation
that all goes well. This is the core of the function. The code looks like this:
(let ((string (delete-and-extract-region beg end)))
(when string
(if (eq last-command ’kill-region)
(kill-append string (< end beg))
(kill-new string)))
(setq this-command ’kill-region))
It looks complicated because we have the new functions delete-and-
extract-region, kill-append, and kill-new as well as the new variables,
last-command and this-command.
The delete-and-extract-region function is straightforward.
It is a
built-in function that deletes the text in a region (a side eﬀect) and also
returns that text. This is the function that actually removes the text. (And
if it cannot do that, it signals the error.)

delete-and-extract-region: Digressing into C
97
In this let expression, the text that delete-and-extract-region re-
turns is placed in the local variable called ‘string’. This is the text that is
removed from the buﬀer. (To be more precise, the variable is set to point
to the address of the extracted text; to say it is ‘placed in’ the variable is
simply a shorthand.)
If the variable ‘string’ does point to text, that text is added to the kill
ring. The variable will have a nil value if no text was removed.
The code uses when to determine whether the variable ‘string’ points
to text. A when statement is simply a programmers’ convenience. A when
statement is an if statement without the possibility of an else clause. In
your mind, you can replace when with if and understand what goes on.
That is what the Lisp interpreter does.
Technically speaking, when is a Lisp macro. A Lisp macro enables you to
deﬁne new control constructs and other language features. It tells the inter-
preter how to compute another Lisp expression which will in turn compute
the value. In this case, the ‘other expression’ is an if expression. For more
about Lisp macros, see section “Macros” in The GNU Emacs Lisp Reference
Manual. The C programming language also provides macros. These are
diﬀerent, but also useful. We will brieﬂy look at C macros in Section 8.3,
“delete-and-extract-region: Digressing into C”, page 98.
If the string has content, then another conditional expression is executed.
This is an if with both a then-part and an else-part.
(if (eq last-command ’kill-region)
(kill-append string (< end beg))
(kill-new string)))
The then-part is evaluated if the previous command was another call to
kill-region; if not, the else-part is evaluated.
last-command is a variable that comes with Emacs that we have not seen
before. Normally, whenever a function is executed, Emacs sets the value of
last-command to the previous command.
In this segment of the deﬁnition, the if expression checks whether the
previous command was kill-region. If it was,
(kill-append string (< end beg))
concatenates a copy of the newly clipped text to the just previously clipped
text in the kill ring. (If the (< end beg)) expression is true, kill-append
prepends the string to the just previously clipped text. For a detailed dis-
cussion, see “The kill-append function”, page 104.)
If you then yank back the text, i.e., ‘paste’ it, you get both pieces of
text at once. That way, if you delete two words in a row, and then yank
them back, you get both words, in their proper order, with one yank. (The
(< end beg)) expression makes sure the order is correct.)

98
Chapter 8: Cutting and Storing Text
On the other hand, if the previous command is not kill-region, then
the kill-new function is called, which adds the text to the kill ring as the
latest item, and sets the kill-ring-yank-pointer variable to point to it.
8.3 delete-and-extract-region: Digressing into C
The zap-to-char command uses the delete-and-extract-region func-
tion, which in turn uses two other functions, copy-region-as-kill and
del_range_1. The copy-region-as-kill function will be described in a
following section; it puts a copy of the region in the kill ring so it can be
yanked back. (See Section 8.5, “copy-region-as-kill”, page 102.)
The delete-and-extract-region function removes the contents of a
region and you cannot get them back.
Unlike the other code discussed here, delete-and-extract-region is
not written in Emacs Lisp; it is written in C and is one of the primitives of
the GNU Emacs system. Since it is very simple, I will digress brieﬂy from
Lisp and describe it here.
Like many of the other Emacs primitives, delete-and-extract-region
is written as an instance of a C macro, a macro being a template for code.
The complete macro looks like this:
DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
Sdelete_and_extract_region, 2, 2, 0,
"Delete the text between START and END and return it.")
(start, end)
Lisp_Object start, end;
{
validate_region (&start, &end);
return del_range_1 (XINT (start), XINT (end), 1, 1);
}
Without going into the details of the macro writing process, let me point
out that this macro starts with the word DEFUN. The word DEFUN was chosen
since the code serves the same purpose as defun does in Lisp. The word
DEFUN is followed by seven parts inside of parentheses:
• The ﬁrst part is the name given to the function in Lisp, delete-and-
extract-region.
• The second part is the name of the function in C, Fdelete_and_
extract_region. By convention, it starts with ‘F’. Since C does not
use hyphens in names, underscores are used instead.
• The third part is the name for the C constant structure that records
information on this function for internal use.
It is the name of the
function in C but begins with an ‘S’ instead of an ‘F’.
• The fourth and ﬁfth parts specify the minimum and maximum number
of arguments the function can have. This function demands exactly 2
arguments.

delete-and-extract-region: Digressing into C
99
• The sixth part is nearly like the argument that follows the interactive
declaration in a function written in Lisp: a letter followed, perhaps, by
a prompt. The only diﬀerence from the Lisp is when the macro is called
with no arguments. Then you write a 0 (which is a ‘null string’), as in
this macro.
If you were to specify arguments, you would place them between quo-
tation marks. The C macro for goto-char includes "NGoto char: " in
this position to indicate that the function expects a raw preﬁx, in this
case, a numerical location in a buﬀer, and provides a prompt.
• The seventh part is a documentation string, just like the one for a func-
tion written in Emacs Lisp, except that every newline must be written
explicitly as ‘\n’ followed by a backslash and carriage return.
Thus, the ﬁrst two lines of documentation for goto-char are written
like this:
"Set point to POSITION, a number or marker.\n\
Beginning of buffer is position (point-min), end is (point-max).
In a C macro, the formal parameters come next, with a statement of
what kind of object they are, followed by what might be called the ‘body’
of the macro. For delete-and-extract-region the ‘body’ consists of the
following two lines:
validate_region (&start, &end);
return del_range_1 (XINT (start), XINT (end), 1, 1);
The ﬁrst function, validate_region checks whether the values passed
as the beginning and end of the region are the proper type and are within
range. The second function, del_range_1, actually deletes the text.
del_range_1 is a complex function we will not look into. It updates the
buﬀer and does other things.
However, it is worth looking at the two arguments passed to del_range.
These are XINT (start) and XINT (end).
As far as the C language is concerned, start and end are two integers
that mark the beginning and end of the region to be deleted1.
In early versions of Emacs, these two numbers were thirty-two bits long,
but the code is slowly being generalized to handle other lengths. Three of
the available bits are used to specify the type of information and a fourth
bit is used for handling the computer’s memory; the remaining bits are used
as ‘content’.
‘XINT’ is a C macro that extracts the relevant number from the longer
collection of bits; the four other bits are discarded.
1 More precisely, and requiring more expert knowledge to understand, the two integers
are of type ‘Lisp Object’, which can also be a C union instead of an integer type.

100
Chapter 8: Cutting and Storing Text
The command in delete-and-extract-region looks like this:
del_range_1 (XINT (start), XINT (end), 1, 1);
It deletes the region between the beginning position, start, and the ending
position, end.
From the point of view of the person writing Lisp, Emacs is all very
simple; but hidden underneath is a great deal of complexity to make it all
work.
8.4 Initializing a Variable with defvar
Unlike the delete-and-extract-region function, the copy-region-as-
kill function is written in Emacs Lisp.
Two functions within it, kill-
append and kill-new, copy a region in a buﬀer and save it in a variable
called the kill-ring. This section describes how the kill-ring variable is
created and initialized using the defvar special form.
(Again we note that the term kill-ring is a misnomer. The text that
is clipped out of the buﬀer can be brought back; it is not a ring of corpses,
but a ring of resurrectable text.)
In Emacs Lisp, a variable such as the kill-ring is created and given an
initial value by using the defvar special form. The name comes from “deﬁne
variable”.
The defvar special form is similar to setq in that it sets the value of a
variable. It is unlike setq in two ways: ﬁrst, it only sets the value of the
variable if the variable does not already have a value. If the variable already
has a value, defvar does not override the existing value. Second, defvar
has a documentation string.
(Another special form, defcustom, is designed for variables that people
customize. It has more features than defvar. (See Section 16.2, “Setting
Variables with defcustom”, page 214.)
You can see the current value of a variable, any variable, by using the
describe-variable function, which is usually invoked by typing C-h v. If
you type C-h v and then kill-ring (followed by ⟨RET⟩) when prompted, you
will see what is in your current kill ring—this may be quite a lot! Conversely,
if you have been doing nothing this Emacs session except read this document,
you may have nothing in it. Also, you will see the documentation for kill-
ring:
Documentation:
List of killed text sequences.
Since the kill ring is supposed to interact nicely with cut-and-paste
facilities offered by window systems, use of this variable should

copy-region-as-kill
101
interact nicely with ‘interprogram-cut-function’ and
‘interprogram-paste-function’.
The functions ‘kill-new’,
‘kill-append’, and ‘current-kill’ are supposed to implement this
interaction; you may want to use them instead of manipulating the kill
ring directly.
The kill ring is deﬁned by a defvar in the following way:
(defvar kill-ring nil
"List of killed text sequences.
...")
In this variable deﬁnition, the variable is given an initial value of nil, which
makes sense, since if you have saved nothing, you want nothing back if you
give a yank command. The documentation string is written just like the
documentation string of a defun. As with the documentation string of the
defun, the ﬁrst line of the documentation should be a complete sentence,
since some commands, like apropos, print only the ﬁrst line of documenta-
tion. Succeeding lines should not be indented; otherwise they look odd when
you use C-h v (describe-variable).
8.4.1 defvar and an asterisk
In the past, Emacs used the defvar special form both for internal vari-
ables that you would not expect a user to change and for variables that you
do expect a user to change. Although you can still use defvar for user cus-
tomizable variables, please use defcustom instead, since that special form
provides a path into the Customization commands. (See Section 16.2, “Set-
ting Variables with defcustom”, page 214.)
When you speciﬁed a variable using the defvar special form, you could
distinguish a readily settable variable from others by typing an asterisk, ‘*’,
in the ﬁrst column of its documentation string. For example:
(defvar shell-command-default-error-buffer nil
"*Buffer name for ‘shell-command’ ... error output.
... ")
This means that you could (and still can) use the edit-options command
to change the value of shell-command-default-error-buffer temporarily.
However, options set using edit-options are set only for the duration
of your editing session.
The new values are not saved between sessions.
Each time Emacs starts, it reads the original value, unless you change the
value within your ‘.emacs’ ﬁle, either by setting it manually or by using
customize. See Chapter 16, “Your ‘.emacs’ File”, page 213.
For me, the major use of the edit-options command is to suggest vari-
ables that I might want to set in my ‘.emacs’ ﬁle. I urge you to look through
the list. (See section “Editing Variable Values” in The GNU Emacs Manual.)

102
Chapter 8: Cutting and Storing Text
8.5 copy-region-as-kill
The copy-region-as-kill function copies a region of text from a buﬀer
and (via either kill-append or kill-new) saves it in the kill-ring.
If you call copy-region-as-kill immediately after a kill-region com-
mand, Emacs appends the newly copied text to the previously copied text.
This means that if you yank back the text, you get it all, from both this and
the previous operation. On the other hand, if some other command precedes
the copy-region-as-kill, the function copies the text into a separate entry
in the kill ring.
Here is the complete text of the version 21 copy-region-as-kill func-
tion:
(defun copy-region-as-kill (beg end)
"Save the region as if killed, but don’t kill it.
In Transient Mark mode, deactivate the mark.
If ‘interprogram-cut-function’ is non-nil, also save
the text for a window system cut and paste."
(interactive "r")
(if (eq last-command ’kill-region)
(kill-append (buffer-substring beg end) (< end beg))
(kill-new (buffer-substring beg end)))
(if transient-mark-mode
(setq deactivate-mark t))
nil)
As usual, this function can be divided into its component parts:
(defun copy-region-as-kill (argument-list)
"documentation..."
(interactive "r")
body...)
The arguments are beg and end and the function is interactive with "r",
so the two arguments must refer to the beginning and end of the region.
If you have been reading though this document from the beginning, under-
standing these parts of a function is almost becoming routine.
The documentation is somewhat confusing unless you remember that the
word ‘kill’ has a meaning diﬀerent from its usual meaning. The ‘Transient
Mark’ and interprogram-cut-function comments explain certain side-
eﬀects.
After you once set a mark, a buﬀer always contains a region.
If you
wish, you can use Transient Mark mode to highlight the region temporarily.
(No one wants to highlight the region all the time, so Transient Mark mode
highlights it only at appropriate times. Many people turn oﬀTransient Mark
mode, so the region is never highlighted.)

The Body of copy-region-as-kill
103
Also, a windowing system allows you to copy, cut, and paste among diﬀer-
ent programs. In the X windowing system, for example, the interprogram-
cut-function function is x-select-text, which works with the windowing
system’s equivalent of the Emacs kill ring.
The body of the copy-region-as-kill function starts with an if
clause.
What this clause does is distinguish between two diﬀerent situa-
tions: whether or not this command is executed immediately after a previ-
ous kill-region command. In the ﬁrst case, the new region is appended
to the previously copied text. Otherwise, it is inserted into the beginning of
the kill ring as a separate piece of text from the previous piece.
The last two lines of the function prevent the region from lighting up if
Transient Mark mode is turned on.
The body of copy-region-as-kill merits discussion in detail.
8.5.1 The Body of copy-region-as-kill
The copy-region-as-kill function works in much the same way as the
kill-region function (see Section 8.2, “kill-region”, page 94). Both are
written so that two or more kills in a row combine their text into a single
entry. If you yank back the text from the kill ring, you get it all in one piece.
Moreover, kills that kill forward from the current position of the cursor are
added to the end of the previously copied text and commands that copy text
backwards add it to the beginning of the previously copied text. This way,
the words in the text stay in the proper order.
Like kill-region, the copy-region-as-kill function makes use of the
last-command variable that keeps track of the previous Emacs command.
Normally, whenever a function is executed, Emacs sets the value of this-
command to the function being executed (which in this case would be copy-
region-as-kill). At the same time, Emacs sets the value of last-command
to the previous value of this-command.
In the ﬁrst part of the body of the copy-region-as-kill function, an if
expression determines whether the value of last-command is kill-region.
If so, the then-part of the if expression is evaluated; it uses the kill-append
function to concatenate the text copied at this call to the function with the
text already in the ﬁrst element (the car) of the kill ring. On the other
hand, if the value of last-command is not kill-region, then the copy-
region-as-kill function attaches a new element to the kill ring using the
kill-new function.

104
Chapter 8: Cutting and Storing Text
The if expression reads as follows; it uses eq, which is a function we have
not yet seen:
(if (eq last-command ’kill-region)
;; then-part
(kill-append (buffer-substring beg end) (< end beg))
;; else-part
(kill-new (buffer-substring beg end)))
The eq function tests whether its ﬁrst argument is the same Lisp object as
its second argument. The eq function is similar to the equal function in
that it is used to test for equality, but diﬀers in that it determines whether
two representations are actually the same object inside the computer, but
with diﬀerent names. equal determines whether the structure and contents
of two expressions are the same.
If the previous command was kill-region, then the Emacs Lisp inter-
preter calls the kill-append function
The kill-append function
The kill-append function looks like this:
(defun kill-append (string before-p)
"Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill.
If ‘interprogram-cut-function’ is set, pass the resulting kill to
it."
(kill-new (if before-p
(concat string (car kill-ring))
(concat (car kill-ring) string))
t))
The kill-append function is fairly straightforward. It uses the kill-new
function, which we will discuss in more detail in a moment.
First, let us look at the conditional that is one of the two arguments to
kill-new. It uses concat to concatenate the new text to the car of the kill
ring. Whether it prepends or appends the text depends on the results of an
if expression:
(if before-p
; if-part
(concat string (car kill-ring))
; then-part
(concat (car kill-ring) string))
; else-part
If the region being killed is before the region that was killed in the last
command, then it should be prepended before the material that was saved
in the previous kill; and conversely, if the killed text follows what was just
killed, it should be appended after the previous text. The if expression
depends on the predicate before-p to decide whether the newly saved text
should be put before or after the previously saved text.

The kill-new function
105
The symbol before-p is the name of one of the arguments to kill-
append. When the kill-append function is evaluated, it is bound to the
value returned by evaluating the actual argument. In this case, this is the ex-
pression (< end beg). This expression does not directly determine whether
the killed text in this command is located before or after the kill text of the
last command; what is does is determine whether the value of the variable
end is less than the value of the variable beg. If it is, it means that the
user is most likely heading towards the beginning of the buﬀer. Also, the
result of evaluating the predicate expression, (< end beg), will be true and
the text will be prepended before the previous text. On the other hand, if
the value of the variable end is greater than the value of the variable beg,
the text will be appended after the previous text.
When the newly saved text will be prepended, then the string with the
new text will be concatenated before the old text:
(concat string (car kill-ring))
But if the text will be appended, it will be concatenated after the old text:
(concat (car kill-ring) string))
To understand how this works, we ﬁrst need to review the concat func-
tion. The concat function links together or unites two strings of text. The
result is a string. For example:
(concat "abc" "def")
⇒"abcdef"
(concat "new "
(car ’("first element" "second element")))
⇒"new first element"
(concat (car
’("first element" "second element")) " modified")
⇒"first element modified"
We can now make sense of kill-append: it modiﬁes the contents of the
kill ring. The kill ring is a list, each element of which is saved text. The
kill-append function uses the kill-new function which in turn uses the
setcar function.
The kill-new function
The kill-new function looks like this:
(defun kill-new (string &optional replace)
"Make STRING the latest kill in the kill ring.
Set the kill-ring-yank pointer to point to it.
If ‘interprogram-cut-function’ is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list."

106
Chapter 8: Cutting and Storing Text
(and (fboundp ’menu-bar-update-yank-menu)
(menu-bar-update-yank-menu string (and replace (car kill-ring))))
(if (and replace kill-ring)
(setcar kill-ring string)
(setq kill-ring (cons string kill-ring))
(if (> (length kill-ring) kill-ring-max)
(setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
(setq kill-ring-yank-pointer kill-ring)
(if interprogram-cut-function
(funcall interprogram-cut-function string (not replace))))
As usual, we can look at this function in parts.
The ﬁrst line of the documentation makes sense:
Make STRING the latest kill in the kill ring.
Let’s skip over the rest of the documentation for the moment.
Also, let’s skip over the ﬁrst two lines of code, those involving menu-bar-
update-yank-menu. We will explain them below.
The critical lines are these:
(if (and replace kill-ring)
;; then
(setcar kill-ring string)
;; else
(setq kill-ring (cons string kill-ring))
(if (> (length kill-ring) kill-ring-max)
;; avoid overly long kill ring
(setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
(setq kill-ring-yank-pointer kill-ring)
(if interprogram-cut-function
(funcall interprogram-cut-function string (not replace))))
The conditional test is (and replace kill-ring). This will be true when
two conditions are met: the kill ring has something in it, and the replace
variable is true.
The kill-append function sets replace to be true; then, when the kill
ring has at least one item in it, the setcar expression is executed:
(setcar kill-ring string)
The setcar function actually changes the ﬁrst element of the kill-ring
list to the value of string. It replaces the ﬁrst element.
On the other hand, if the kill ring is empty, or replace is false, the else-part
of the condition is executed:
(setq kill-ring (cons string kill-ring))
(if (> (length kill-ring) kill-ring-max)
(setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))

The kill-new function
107
This expression ﬁrst constructs a new version of the kill ring by prepending
string to the existing kill ring as a new element. Then it executes a second
if clause. This second if clause keeps the kill ring from growing too long.
Let’s look at these two expressions in order.
The setq line of the else-part sets the new value of the kill ring to what
results from adding the string being killed to the old kill ring.
We can see how this works with an example:
(setq example-list ’("here is a clause" "another clause"))
After evaluating this expression with C-x C-e, you can evaluate example-
list and see what it returns:
example-list
⇒("here is a clause" "another clause")
Now, we can add a new element on to this list by evaluating the following
expression:
(setq example-list (cons "a third clause" example-list))
When we evaluate example-list, we ﬁnd its value is:
example-list
⇒("a third clause" "here is a clause" "another clause")
Thus, the third clause was added to the list by cons.
This is exactly similar to what the setq and cons do in the function.
Here is the line again:
(setq kill-ring (cons string kill-ring))
Now for the second part of the if clause. This expression keeps the kill
ring from growing too long. It looks like this:
(if (> (length kill-ring) kill-ring-max)
(setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
The code checks whether the length of the kill ring is greater than the
maximum permitted length. This is the value of kill-ring-max (which is
60, by default). If the length of the kill ring is too long, then this code sets
the last element of the kill ring to nil. It does this by using two functions,
nthcdr and setcdr.
We looked at setcdr earlier (see Section 7.6, “setcdr”, page 88). It sets
the cdr of a list, just as setcar sets the car of a list. In this case, however,
setcdr will not be setting the cdr of the whole kill ring; the nthcdr function
is used to cause it to set the cdr of the next to last element of the kill ring—
this means that since the cdr of the next to last element is the last element
of the kill ring, it will set the last element of the kill ring.
The nthcdr function works by repeatedly taking the cdr of a list—it
takes the cdr of the cdr of the cdr . . . It does this N times and returns
the results.

108
Chapter 8: Cutting and Storing Text
Thus, if we had a four element list that was supposed to be three elements
long, we could set the cdr of the next to last element to nil, and thereby
shorten the list.
You can see this by evaluating the following three expressions in turn.
First set the value of trees to (maple oak pine birch), then set the cdr
of its second cdr to nil and then ﬁnd the value of trees:
(setq trees ’(maple oak pine birch))
⇒(maple oak pine birch)
(setcdr (nthcdr 2 trees) nil)
⇒nil
trees
⇒(maple oak pine)
(The value returned by the setcdr expression is nil since that is what the
cdr is set to.)
To repeat, in kill-new, the nthcdr function takes the cdr a number of
times that is one less than the maximum permitted size of the kill ring and
sets the cdr of that element (which will be the rest of the elements in the
kill ring) to nil. This prevents the kill ring from growing too long.
The next to last expression in the kill-new function is
(setq kill-ring-yank-pointer kill-ring)
The kill-ring-yank-pointer is a global variable that is set to be the
kill-ring.
Even though the kill-ring-yank-pointer is called a ‘pointer’, it is
a variable just like the kill ring. However, the name has been chosen to
help humans understand how the variable is used. The variable is used in
functions such as yank and yank-pop (see Chapter 10, “Yanking Text Back”,
page 117).
Now, to return to the ﬁrst two lines in the body of the function:
(and (fboundp ’menu-bar-update-yank-menu)
(menu-bar-update-yank-menu string (and replace (car kill-ring))))
This is an expression whose ﬁrst element is the function and.
The and special form evaluates each of its arguments until one of the
arguments returns a value of nil, in which case the and expression returns
nil; however, if none of the arguments returns a value of nil, the value
resulting from evaluating the last argument is returned. (Since such a value
is not nil, it is considered true in Emacs Lisp.) In other words, an and
expression returns a true value only if all its arguments are true.
In this case, the expression tests ﬁrst to see whether menu-bar-update-
yank-menu exists as a function, and if so, calls it. The fboundp function
returns true if the symbol it is testing has a function deﬁnition that ‘is not
void’. If the symbol’s function deﬁnition were void, we would receive an error

Review
109
message, as we did when we created errors intentionally (see Section 1.3,
“Generate an Error Message”, page 4).
Essentially, the and is an if expression that reads like this:
if the-menu-bar-function-exists
then execute-it
menu-bar-update-yank-menu is one of the functions that make it possi-
ble to use the ‘Select and Paste’ menu in the Edit item of a menu bar; using
a mouse, you can look at the various pieces of text you have saved and select
one piece to paste.
Finally, the last expression in the kill-new function adds the newly
copied string to whatever facility exists for copying and pasting among dif-
ferent programs running in a windowing system. In the X Windowing sys-
tem, for example, the x-select-text function takes the string and stores
it in memory operated by X. You can paste the string in another program,
such as an Xterm.
The expression looks like this:
(if interprogram-cut-function
(funcall interprogram-cut-function string (not replace))))
If an interprogram-cut-function exists, then Emacs executes funcall,
which in turn calls its ﬁrst argument as a function and passes the remaining
arguments to it. (Incidentally, as far as I can see, this if expression could
be replaced by an and expression similar to the one in the ﬁrst part of the
function.)
We are not going to discuss windowing systems and other programs fur-
ther, but merely note that this is a mechanism that enables GNU Emacs to
work easily and well with other programs.
This code for placing text in the kill ring, either concatenated with an
existing element or as a new element, leads us to the code for bringing back
text that has been cut out of the buﬀer—the yank commands. However,
before discussing the yank commands, it is better to learn how lists are
implemented in a computer. This will make clear such mysteries as the use
of the term ‘pointer’.
8.6 Review
Here is a brief summary of some recently introduced functions.
car
cdr
car returns the ﬁrst element of a list; cdr returns the second
and subsequent elements of a list.

110
Chapter 8: Cutting and Storing Text
For example:
(car ’(1 2 3 4 5 6 7))
⇒1
(cdr ’(1 2 3 4 5 6 7))
⇒(2 3 4 5 6 7)
cons
cons constructs a list by prepending its ﬁrst argument to its
second argument.
For example:
(cons 1 ’(2 3 4))
⇒(1 2 3 4)
nthcdr
Return the result of taking cdr ‘n’ times on a list. The nth cdr.
The ‘rest of the rest’, as it were.
For example:
(nthcdr 3 ’(1 2 3 4 5 6 7))
⇒(4 5 6 7)
setcar
setcdr
setcar changes the ﬁrst element of a list; setcdr changes the
second and subsequent elements of a list.
For example:
(setq triple ’(1 2 3))
(setcar triple ’37)
triple
⇒(37 2 3)
(setcdr triple ’("foo" "bar"))
triple
⇒(37 "foo" "bar")
progn
Evaluate each argument in sequence and then return the value
of the last.
For example:
(progn 1 2 3 4)
⇒4
save-restriction
Record whatever narrowing is in eﬀect in the current buﬀer, if
any, and restore that narrowing after evaluating the arguments.
search-forward
Search for a string, and if the string is found, move point.

Searching Exercises
111
Takes four arguments:
1. The string to search for.
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an
error message.
4. Optionally, how many times to repeat the search; if nega-
tive, the search goes backwards.
kill-region
delete-region
copy-region-as-kill
kill-region cuts the text between point and mark from the
buﬀer and stores that text in the kill ring, so you can get it back
by yanking.
delete-and-extract-region removes the text between point
and mark from the buﬀer and throws it away. You cannot get
it back.
copy-region-as-kill copies the text between point and mark
into the kill ring, from which you can get it by yanking. The
function does not cut or remove the text from the buﬀer.
8.7 Searching Exercises
• Write an interactive function that searches for a string. If the search
ﬁnds the string, leave point after it and display a message that says
“Found!”. (Do not use search-forward for the name of this function;
if you do, you will overwrite the existing version of search-forward
that comes with Emacs. Use a name such as test-search instead.)
• Write a function that prints the third element of the kill ring in the echo
area, if any; if the kill ring does not contain a third element, print an
appropriate message.

112
Chapter 8: Cutting and Storing Text

How Lists are Implemented
113
9 How Lists are Implemented
In Lisp, atoms are recorded in a straightforward fashion; if the implemen-
tation is not straightforward in practice, it is, nonetheless, straightforward
in theory. The atom ‘rose’, for example, is recorded as the four contiguous
letters ‘r’, ‘o’, ‘s’, ‘e’. A list, on the other hand, is kept diﬀerently. The
mechanism is equally simple, but it takes a moment to get used to the idea.
A list is kept using a series of pairs of pointers. In the series, the ﬁrst pointer
in each pair points to an atom or to another list, and the second pointer in
each pair points to the next pair, or to the symbol nil, which marks the end
of the list.
A pointer itself is quite simply the electronic address of what is pointed
to. Hence, a list is kept as a series of electronic addresses.
For example, the list (rose violet buttercup) has three elements,
‘rose’, ‘violet’, and ‘buttercup’. In the computer, the electronic address
of ‘rose’ is recorded in a segment of computer memory along with the ad-
dress that gives the electronic address of where the atom ‘violet’ is located;
and that address (the one that tells where ‘violet’ is located) is kept along
with an address that tells where the address for the atom ‘buttercup’ is
located.
This sounds more complicated than it is and is easier seen in a diagram:
rose
violet
buttercup
nil
In the diagram, each box represents a word of computer memory that holds
a Lisp object, usually in the form of a memory address. The boxes, i.e.
the addresses, are in pairs. Each arrow points to what the address is the
address of, either an atom or another pair of addresses. The ﬁrst box is the
electronic address of ‘rose’ and the arrow points to ‘rose’; the second box
is the address of the next pair of boxes, the ﬁrst part of which is the address
of ‘violet’ and the second part of which is the address of the next pair. The
very last box points to the symbol nil, which marks the end of the list.
When a variable is set to a list with a function such as setq, it stores the
address of the ﬁrst box in the variable. Thus, evaluation of the expression
(setq bouquet ’(rose violet buttercup))

114
Chapter 9: How Lists are Implemented
creates a situation like this:
bouquet
rose
violet
buttercup
nil
In this example, the symbol bouquet holds the address of the ﬁrst pair of
boxes.
This same list can be illustrated in a diﬀerent sort of box notation like
this:
bouquet
car
rose
cdr
car
violet
cdr
car
butter-
cup
cdr
nil
(Symbols consist of more than pairs of addresses, but the structure of
a symbol is made up of addresses. Indeed, the symbol bouquet consists of
a group of address-boxes, one of which is the address of the printed word
‘bouquet’, a second of which is the address of a function deﬁnition attached
to the symbol, if any, a third of which is the address of the ﬁrst pair of
address-boxes for the list (rose violet buttercup), and so on. Here we
are showing that the symbol’s third address-box points to the ﬁrst pair of
address-boxes for the list.)
If a symbol is set to the cdr of a list, the list itself is not changed; the
symbol simply has an address further down the list. (In the jargon, car and
cdr are ‘non-destructive’.) Thus, evaluation of the following expression
(setq flowers (cdr bouquet))
produces this:
rose
violet
buttercup
nil
flowers
bouquet

Symbols as a Chest of Drawers
115
The value of flowers is (violet buttercup), which is to say, the symbol
flowers holds the address of the pair of address-boxes, the ﬁrst of which
holds the address of violet, and the second of which holds the address of
buttercup.
A pair of address-boxes is called a cons cell or dotted pair. See section
“List Type ” in The GNU Emacs Lisp Reference Manual, and section “Dot-
ted Pair Notation” in The GNU Emacs Lisp Reference Manual, for more
information about cons cells and dotted pairs.
The function cons adds a new pair of addresses to the front of a series of
addresses like that shown above. For example, evaluating the expression
(setq bouquet (cons ’lily bouquet))
produces:
violet
flowers
nil
buttercup
rose
lily
bouquet
However, this does not change the value of the symbol flowers, as you can
see by evaluating the following,
(eq (cdr (cdr bouquet)) flowers)
which returns t for true.
Until it is reset, flowers still has the value (violet buttercup); that
is, it has the address of the cons cell whose ﬁrst address is of violet. Also,
this does not alter any of the pre-existing cons cells; they are all still there.
Thus, in Lisp, to get the cdr of a list, you just get the address of the
next cons cell in the series; to get the car of a list, you get the address of
the ﬁrst element of the list; to cons a new element on a list, you add a new
cons cell to the front of the list. That is all there is to it! The underlying
structure of Lisp is brilliantly simple!
And what does the last address in a series of cons cells refer to? It is the
address of the empty list, of nil.
In summary, when a Lisp variable is set to a value, it is provided with
the address of the list to which the variable refers.
9.1 Symbols as a Chest of Drawers
In an earlier section, I suggested that you might imagine a symbol as
being a chest of drawers. The function deﬁnition is put in one drawer, the

116
Chapter 9: How Lists are Implemented
value in another, and so on. What is put in the drawer holding the value can
be changed without aﬀecting the contents of the drawer holding the function
deﬁnition, and vice-versa.
Actually, what is put in each drawer is the address of the value or function
deﬁnition. It is as if you found an old chest in the attic, and in one of its
drawers you found a map giving you directions to where the buried treasure
lies.
(In addition to its name, symbol deﬁnition, and variable value, a symbol
has a ‘drawer’ for a property list which can be used to record other infor-
mation. Property lists are not discussed here; see section “Property Lists”
in The GNU Emacs Lisp Reference Manual.)
Here is a fanciful representation:
symbol name
Chest of Drawers
Contents of Drawers
bouquet
[none]
(rose violet buttercup)
[not described here]
directions to
map to
map to
symbol definition
directions to
variable name
directions to
property list
directions to
9.2 Exercise
Set flowers to violet and buttercup. Cons two more ﬂowers on to this
list and set this new list to more-flowers. Set the car of flowers to a ﬁsh.
What does the more-flowers list now contain?

The kill-ring-yank-pointer Variable
117
10 Yanking Text Back
Whenever you cut text out of a buﬀer with a ‘kill’ command in GNU
Emacs, you can bring it back with a ‘yank’ command. The text that is cut
out of the buﬀer is put in the kill ring and the yank commands insert the
appropriate contents of the kill ring back into a buﬀer (not necessarily the
original buﬀer).
A simple C-y (yank) command inserts the ﬁrst item from the kill ring into
the current buﬀer. If the C-y command is followed immediately by M-y, the
ﬁrst element is replaced by the second element. Successive M-y commands
replace the second element with the third, fourth, or ﬁfth element, and so
on. When the last element in the kill ring is reached, it is replaced by the
ﬁrst element and the cycle is repeated. (Thus the kill ring is called a ‘ring’
rather than just a ‘list’. However, the actual data structure that holds the
text is a list. See Appendix B, “Handling the Kill Ring”, page 243, for the
details of how the list is handled as a ring.)
10.1 Kill Ring Overview
The kill ring is a list of textual strings. This is what it looks like:
("some text" "a different piece of text" "yet more text")
If this were the contents of my kill ring and I pressed C-y, the string
of characters saying ‘some text’ would be inserted in this buﬀer where my
cursor is located.
The yank command is also used for duplicating text by copying it. The
copied text is not cut from the buﬀer, but a copy of it is put on the kill ring
and is inserted by yanking it back.
Three functions are used for bringing text back from the kill ring: yank,
which is usually bound to C-y; yank-pop, which is usually bound to M-y;
and rotate-yank-pointer, which is used by the two other functions.
These functions refer to the kill ring through a variable called the kill-
ring-yank-pointer. Indeed, the insertion code for both the yank and yank-
pop functions is:
(insert (car kill-ring-yank-pointer))
To begin to understand how yank and yank-pop work, it is ﬁrst necessary
to look at the kill-ring-yank-pointer variable and the rotate-yank-
pointer function.
10.2 The kill-ring-yank-pointer Variable
kill-ring-yank-pointer is a variable, just as kill-ring is a variable.
It points to something by being bound to the value of what it points to, like
any other Lisp variable.

118
Chapter 10: Yanking Text Back
Thus, if the value of the kill ring is:
("some text" "a different piece of text" "yet more text")
and the kill-ring-yank-pointer points to the second clause, the value of
kill-ring-yank-pointer is:
("a different piece of text" "yet more text")
As explained in the previous chapter (see Chapter 9, “List Implementa-
tion”, page 113), the computer does not keep two diﬀerent copies of the text
being pointed to by both the kill-ring and the kill-ring-yank-pointer.
The words “a diﬀerent piece of text” and “yet more text” are not duplicated.
Instead, the two Lisp variables point to the same pieces of text. Here is a
diagram:
a different piece of text
kill-ring-yank-pointer
nil
yet more text
some text
kill-ring
Both the variable kill-ring and the variable kill-ring-yank-pointer
are pointers. But the kill ring itself is usually described as if it were actually
what it is composed of. The kill-ring is spoken of as if it were the list
rather than that it points to the list.
Conversely, the kill-ring-yank-
pointer is spoken of as pointing to a list.
These two ways of talking about the same thing sound confusing at ﬁrst
but make sense on reﬂection. The kill ring is generally thought of as the
complete structure of data that holds the information of what has recently
been cut out of the Emacs buﬀers. The kill-ring-yank-pointer on the
other hand, serves to indicate—that is, to ‘point to’—that part of the kill
ring of which the ﬁrst element (the car) will be inserted.
The rotate-yank-pointer function changes the element in the kill ring
to which the kill-ring-yank-pointer points; when the pointer is set to
point to the next element beyond the end of the kill ring, it automatically
sets it to point to the ﬁrst element of the kill ring. This is how the list
is transformed into a ring. The rotate-yank-pointer function itself is not
diﬃcult, but contains many details. It and the much simpler yank and yank-
pop functions are described in an appendix. See Appendix B, “Handling the
Kill Ring”, page 243.

Exercises with yank and nthcdr
119
10.3 Exercises with yank and nthcdr
• Using C-h v (describe-variable), look at the value of your kill ring.
Add several items to your kill ring; look at its value again. Using M-y
(yank-pop), move all the way around the kill ring. How many items
were in your kill ring? Find the value of kill-ring-max. Was your kill
ring full, or could you have kept more blocks of text within it?
• Using nthcdr and car, construct a series of expressions to return the
ﬁrst, second, third, and fourth elements of a list.

120
Chapter 10: Yanking Text Back

while
121
11 Loops and Recursion
Emacs Lisp has two primary ways to cause an expression, or a series
of expressions, to be evaluated repeatedly: one uses a while loop, and the
other uses recursion.
Repetition can be very valuable.
For example, to move forward four
sentences, you need only write a program that will move forward one sentence
and then repeat the process four times. Since a computer does not get bored
or tired, such repetitive action does not have the deleterious eﬀects that
excessive or the wrong kinds of repetition can have on humans.
People mostly write Emacs Lisp functions using while loops and their
kin; but you can use recursion, which provides a very powerful way to think
about and then to solve problems1.
11.1 while
The while special form tests whether the value returned by evaluating
its ﬁrst argument is true or false. This is similar to what the Lisp interpreter
does with an if; what the interpreter does next, however, is diﬀerent.
In a while expression, if the value returned by evaluating the ﬁrst argu-
ment is false, the Lisp interpreter skips the rest of the expression (the body
of the expression) and does not evaluate it. However, if the value is true, the
Lisp interpreter evaluates the body of the expression and then again tests
whether the ﬁrst argument to while is true or false. If the value returned
by evaluating the ﬁrst argument is again true, the Lisp interpreter again
evaluates the body of the expression.
The template for a while expression looks like this:
(while true-or-false-test
body...)
So long as the true-or-false-test of the while expression returns a true
value when it is evaluated, the body is repeatedly evaluated. This process
is called a loop since the Lisp interpreter repeats the same thing again and
again, like an airplane doing a loop. When the result of evaluating the true-
or-false-test is false, the Lisp interpreter does not evaluate the rest of the
while expression and ‘exits the loop’.
Clearly, if the value returned by evaluating the ﬁrst argument to while
is always true, the body following will be evaluated again and again . . .
and again . . . forever. Conversely, if the value returned is never true, the
1 You can write recursive functions to be frugal or wasteful of mental or computer
resources; as it happens, methods that people ﬁnd easy—that are frugal of ‘mental
resources’—sometimes use considerable computer resources. Emacs was designed to
run on machines that we now consider limited and its default settings are conservative.
You may want to increase the values of max-specpdl-size and max-lisp-eval-depth.
In my ‘.emacs’ ﬁle, I set them to 15 and 30 times their default value.

122
Chapter 11: Loops and Recursion
expressions in the body will never be evaluated. The craft of writing a while
loop consists of choosing a mechanism such that the true-or-false-test returns
true just the number of times that you want the subsequent expressions to
be evaluated, and then have the test return false.
The value returned by evaluating a while is the value of the true-or-false-
test. An interesting consequence of this is that a while loop that evaluates
without error will return nil or false regardless of whether it has looped 1 or
100 times or none at all. A while expression that evaluates successfully never
returns a true value! What this means is that while is always evaluated for
its side eﬀects, which is to say, the consequences of evaluating the expressions
within the body of the while loop. This makes sense. It is not the mere act
of looping that is desired, but the consequences of what happens when the
expressions in the loop are repeatedly evaluated.
11.1.1 A while Loop and a List
A common way to control a while loop is to test whether a list has any
elements. If it does, the loop is repeated; but if it does not, the repetition is
ended. Since this is an important technique, we will create a short example
to illustrate it.
A simple way to test whether a list has elements is to evaluate the list:
if it has no elements, it is an empty list and will return the empty list, (),
which is a synonym for nil or false. On the other hand, a list with elements
will return those elements when it is evaluated. Since Emacs Lisp considers
as true any value that is not nil, a list that returns elements will test true
in a while loop.
For example, you can set the variable empty-list to nil by evaluating
the following setq expression:
(setq empty-list ())
After evaluating the setq expression, you can evaluate the variable empty-
list in the usual way, by placing the cursor after the symbol and typing
C-x C-e; nil will appear in your echo area:
empty-list
On the other hand, if you set a variable to be a list with elements, the
list will appear when you evaluate the variable, as you can see by evaluating
the following two expressions:
(setq animals ’(gazelle giraffe lion tiger))
animals
Thus, to create a while loop that tests whether there are any items in
the list animals, the ﬁrst part of the loop will be written like this:
(while animals
...

An Example: print-elements-of-list
123
When the while tests its ﬁrst argument, the variable animals is evaluated.
It returns a list. So long as the list has elements, the while considers the
results of the test to be true; but when the list is empty, it considers the
results of the test to be false.
To prevent the while loop from running forever, some mechanism needs
to be provided to empty the list eventually. An oft-used technique is to have
one of the subsequent forms in the while expression set the value of the list
to be the cdr of the list. Each time the cdr function is evaluated, the list
will be made shorter, until eventually only the empty list will be left. At
this point, the test of the while loop will return false, and the arguments to
the while will no longer be evaluated.
For example, the list of animals bound to the variable animals can be
set to be the cdr of the original list with the following expression:
(setq animals (cdr animals))
If you have evaluated the previous expressions and then evaluate this ex-
pression, you will see (giraffe lion tiger) appear in the echo area. If you
evaluate the expression again, (lion tiger) will appear in the echo area. If
you evaluate it again and yet again, (tiger) appears and then the empty
list, shown by nil.
A template for a while loop that uses the cdr function repeatedly to
cause the true-or-false-test eventually to test false looks like this:
(while test-whether-list-is-empty
body...
set-list-to-cdr-of-list)
This test and use of cdr can be put together in a function that goes
through a list and prints each element of the list on a line of its own.
11.1.2 An Example: print-elements-of-list
The print-elements-of-list function illustrates a while loop with a
list.
The function requires several lines for its output. If you are reading this
in Emacs 21 or a later version, you can evaluate the following expression
inside of Info, as usual.
If you are using an earlier version of Emacs, you need to copy the neces-
sary expressions to your ‘*scratch*’ buﬀer and evaluate them there. This
is because the echo area had only one line in the earlier versions.
You can copy the expressions by marking the beginning of the region with
C-⟨SPC⟩(set-mark-command), moving the cursor to the end of the region
and then copying the region using M-w (copy-region-as-kill).
In the
‘*scratch*’ buﬀer, you can yank the expressions back by typing C-y (yank).
After you have copied the expressions to the ‘*scratch*’ buﬀer, evaluate
each expression in turn. Be sure to evaluate the last expression, (print-
elements-of-list animals), by typing C-u C-x C-e, that is, by giving an

124
Chapter 11: Loops and Recursion
argument to eval-last-sexp.
This will cause the result of the evalua-
tion to be printed in the ‘*scratch*’ buﬀer instead of being printed in
the echo area.
(Otherwise you will see something like this in your echo
area: ^Jgiraffe^J^Jgazelle^J^Jlion^J^Jtiger^Jnil, in which each ‘^J’
stands for a ‘newline’.)
If you are using Emacs 21 or later, you can evaluate these expressions
directly in the Info buﬀer, and the echo area will grow to show the results.
(setq animals ’(gazelle giraffe lion tiger))
(defun print-elements-of-list (list)
"Print each element of LIST on a line of its own."
(while list
(print (car list))
(setq list (cdr list))))
(print-elements-of-list animals)
When you evaluate the three expressions in sequence, you will see this:
giraffe
gazelle
lion
tiger
nil
Each element of the list is printed on a line of its own (that is what the
function print does) and then the value returned by the function is printed.
Since the last expression in the function is the while loop, and since while
loops always return nil, a nil is printed after the last element of the list.
11.1.3 A Loop with an Incrementing Counter
A loop is not useful unless it stops when it ought. Besides controlling
a loop with a list, a common way of stopping a loop is to write the ﬁrst
argument as a test that returns false when the correct number of repetitions
are complete. This means that the loop must have a counter—an expression
that counts how many times the loop repeats itself.
The test can be an expression such as (< count desired-number) which
returns t for true if the value of count is less than the desired-number of
repetitions and nil for false if the value of count is equal to or is greater
than the desired-number. The expression that increments the count can
be a simple setq such as (setq count (1+ count)), where 1+ is a built-
in function in Emacs Lisp that adds 1 to its argument. (The expression

Example with incrementing counter
125
(1+ count) has the same result as (+ count 1), but is easier for a human
to read.)
The template for a while loop controlled by an incrementing counter
looks like this:
set-count-to-initial-value
(while (< count desired-number)
; true-or-false-test
body...
(setq count (1+ count)))
; incrementer
Note that you need to set the initial value of count; usually it is set to 1.
Example with incrementing counter
Suppose you are playing on the beach and decide to make a triangle of
pebbles, putting one pebble in the ﬁrst row, two in the second row, three in
the third row and so on, like this:
•
• •
• • •
• • • •
(About 2500 years ago, Pythagoras and others developed the beginnings of
number theory by considering questions such as this.)
Suppose you want to know how many pebbles you will need to make a
triangle with 7 rows?
Clearly, what you need to do is add up the numbers from 1 to 7. There
are two ways to do this; start with the smallest number, one, and add up
the list in sequence, 1, 2, 3, 4 and so on; or start with the largest number
and add the list going down: 7, 6, 5, 4 and so on. Because both mechanisms
illustrate common ways of writing while loops, we will create two examples,
one counting up and the other counting down. In this ﬁrst example, we will
start with 1 and add 2, 3, 4 and so on.
If you are just adding up a short list of numbers, the easiest way to do it
is to add up all the numbers at once. However, if you do not know ahead of
time how many numbers your list will have, or if you want to be prepared
for a very long list, then you need to design your addition so that what you
do is repeat a simple process many times instead of doing a more complex
process once.
For example, instead of adding up all the pebbles all at once, what you
can do is add the number of pebbles in the ﬁrst row, 1, to the number in the
second row, 2, and then add the total of those two rows to the third row, 3.
Then you can add the number in the fourth row, 4, to the total of the ﬁrst
three rows; and so on.

126
Chapter 11: Loops and Recursion
The critical characteristic of the process is that each repetitive action is
simple. In this case, at each step we add only two numbers, the number of
pebbles in the row and the total already found. This process of adding two
numbers is repeated again and again until the last row has been added to
the total of all the preceding rows. In a more complex loop the repetitive
action might not be so simple, but it will be simpler than doing everything
all at once.
The parts of the function deﬁnition
The preceding analysis gives us the bones of our function deﬁnition: ﬁrst,
we will need a variable that we can call total that will be the total number
of pebbles. This will be the value returned by the function.
Second, we know that the function will require an argument: this ar-
gument will be the total number of rows in the triangle. It can be called
number-of-rows.
Finally, we need a variable to use as a counter. We could call this vari-
able counter, but a better name is row-number.
That is because what
the counter does is count rows, and a program should be written to be as
understandable as possible.
When the Lisp interpreter ﬁrst starts evaluating the expressions in the
function, the value of total should be set to zero, since we have not added
anything to it. Then the function should add the number of pebbles in the
ﬁrst row to the total, and then add the number of pebbles in the second to
the total, and then add the number of pebbles in the third row to the total,
and so on, until there are no more rows left to add.
Both total and row-number are used only inside the function, so they
can be declared as local variables with let and given initial values. Clearly,
the initial value for total should be 0. The initial value of row-number
should be 1, since we start with the ﬁrst row. This means that the let
statement will look like this:
(let ((total 0)
(row-number 1))
body...)
After the internal variables are declared and bound to their initial values,
we can begin the while loop. The expression that serves as the test should
return a value of t for true so long as the row-number is less than or equal
to the number-of-rows. (If the expression tests true only so long as the
row number is less than the number of rows in the triangle, the last row will
never be added to the total; hence the row number has to be either less than
or equal to the number of rows.)

Putting the function deﬁnition together
127
Lisp provides the <= function that returns true if the value of its ﬁrst
argument is less than or equal to the value of its second argument and false
otherwise. So the expression that the while will evaluate as its test should
look like this:
(<= row-number number-of-rows)
The total number of pebbles can be found by repeatedly adding the num-
ber of pebbles in a row to the total already found. Since the number of
pebbles in the row is equal to the row number, the total can be found by
adding the row number to the total. (Clearly, in a more complex situation,
the number of pebbles in the row might be related to the row number in
a more complicated way; if this were the case, the row number would be
replaced by the appropriate expression.)
(setq total (+ total row-number))
What this does is set the new value of total to be equal to the sum of
adding the number of pebbles in the row to the previous total.
After setting the value of total, the conditions need to be established for
the next repetition of the loop, if there is one. This is done by incrementing
the value of the row-number variable, which serves as a counter.
After
the row-number variable has been incremented, the true-or-false-test at the
beginning of the while loop tests whether its value is still less than or equal
to the value of the number-of-rows and if it is, adds the new value of the
row-number variable to the total of the previous repetition of the loop.
The built-in Emacs Lisp function 1+ adds 1 to a number, so the row-
number variable can be incremented with this expression:
(setq row-number (1+ row-number))
Putting the function deﬁnition together
We have created the parts for the function deﬁnition; now we need to put
them together.
First, the contents of the while expression:
(while (<= row-number number-of-rows)
; true-or-false-test
(setq total (+ total row-number))
(setq row-number (1+ row-number)))
; incrementer
Along with the let expression varlist, this very nearly completes the body
of the function deﬁnition. However, it requires one ﬁnal element, the need
for which is somewhat subtle.
The ﬁnal touch is to place the variable total on a line by itself after the
while expression. Otherwise, the value returned by the whole function is
the value of the last expression that is evaluated in the body of the let, and
this is the value returned by the while, which is always nil.
This may not be evident at ﬁrst sight. It almost looks as if the incre-
menting expression is the last expression of the whole function. But that

128
Chapter 11: Loops and Recursion
expression is part of the body of the while; it is the last element of the list
that starts with the symbol while. Moreover, the whole of the while loop
is a list within the body of the let.
In outline, the function will look like this:
(defun name-of-function (argument-list)
"documentation..."
(let (varlist)
(while (true-or-false-test)
body-of-while... )
... )
; Need ﬁnal expression here.
The result of evaluating the let is what is going to be returned by the
defun since the let is not embedded within any containing list, except for
the defun as a whole. However, if the while is the last element of the let
expression, the function will always return nil. This is not what we want!
Instead, what we want is the value of the variable total. This is returned
by simply placing the symbol as the last element of the list starting with
let. It gets evaluated after the preceding elements of the list are evaluated,
which means it gets evaluated after it has been assigned the correct value
for the total.
It may be easier to see this by printing the list starting with let all on one
line. This format makes it evident that the varlist and while expressions are
the second and third elements of the list starting with let, and the total
is the last element:
(let (varlist) (while (true-or-false-test) body-of-while... ) total)
Putting everything together, the triangle function deﬁnition looks like
this:
(defun triangle (number-of-rows)
; Version with
;
incrementing counter.
"Add up the number of pebbles in a triangle.
The first row has one pebble, the second row two pebbles,
the third row three pebbles, and so on.
The argument is NUMBER-OF-ROWS."
(let ((total 0)
(row-number 1))
(while (<= row-number number-of-rows)
(setq total (+ total row-number))
(setq row-number (1+ row-number)))
total))

Example with decrementing counter
129
After you have installed triangle by evaluating the function, you can
try it out. Here are two examples:
(triangle 4)
(triangle 7)
The sum of the ﬁrst four numbers is 10 and the sum of the ﬁrst seven numbers
is 28.
11.1.4 Loop with a Decrementing Counter
Another common way to write a while loop is to write the test so that
it determines whether a counter is greater than zero. So long as the counter
is greater than zero, the loop is repeated. But when the counter is equal to
or less than zero, the loop is stopped. For this to work, the counter has to
start out greater than zero and then be made smaller and smaller by a form
that is evaluated repeatedly.
The test will be an expression such as (> counter 0) which returns t
for true if the value of counter is greater than zero, and nil for false if the
value of counter is equal to or less than zero. The expression that makes the
number smaller and smaller can be a simple setq such as (setq counter
(1- counter)), where 1- is a built-in function in Emacs Lisp that subtracts
1 from its argument.
The template for a decrementing while loop looks like this:
(while (> counter 0)
; true-or-false-test
body...
(setq counter (1- counter)))
; decrementer
Example with decrementing counter
To illustrate a loop with a decrementing counter, we will rewrite the
triangle function so the counter decreases to zero.
This is the reverse of the earlier version of the function. In this case, to
ﬁnd out how many pebbles are needed to make a triangle with 3 rows, add
the number of pebbles in the third row, 3, to the number in the preceding
row, 2, and then add the total of those two rows to the row that precedes
them, which is 1.
Likewise, to ﬁnd the number of pebbles in a triangle with 7 rows, add the
number of pebbles in the seventh row, 7, to the number in the preceding row,
which is 6, and then add the total of those two rows to the row that precedes
them, which is 5, and so on. As in the previous example, each addition only
involves adding two numbers, the total of the rows already added up and the
number of pebbles in the row that is being added to the total. This process
of adding two numbers is repeated again and again until there are no more
pebbles to add.

130
Chapter 11: Loops and Recursion
We know how many pebbles to start with: the number of pebbles in the
last row is equal to the number of rows. If the triangle has seven rows, the
number of pebbles in the last row is 7. Likewise, we know how many pebbles
are in the preceding row: it is one less than the number in the row.
The parts of the function deﬁnition
We start with three variables: the total number of rows in the triangle;
the number of pebbles in a row; and the total number of pebbles, which is
what we want to calculate. These variables can be named number-of-rows,
number-of-pebbles-in-row, and total, respectively.
Both total and number-of-pebbles-in-row are used only inside the
function and are declared with let. The initial value of total should, of
course, be zero. However, the initial value of number-of-pebbles-in-row
should be equal to the number of rows in the triangle, since the addition will
start with the longest row.
This means that the beginning of the let expression will look like this:
(let ((total 0)
(number-of-pebbles-in-row number-of-rows))
body...)
The total number of pebbles can be found by repeatedly adding the num-
ber of pebbles in a row to the total already found, that is, by repeatedly
evaluating the following expression:
(setq total (+ total number-of-pebbles-in-row))
After the number-of-pebbles-in-row is added to the total, the number-
of-pebbles-in-row should be decremented by one, since the next time the
loop repeats, the preceding row will be added to the total.
The number of pebbles in a preceding row is one less than the number
of pebbles in a row, so the built-in Emacs Lisp function 1- can be used to
compute the number of pebbles in the preceding row. This can be done with
the following expression:
(setq number-of-pebbles-in-row
(1- number-of-pebbles-in-row))
Finally, we know that the while loop should stop making repeated addi-
tions when there are no pebbles in a row. So the test for the while loop is
simply:
(while (> number-of-pebbles-in-row 0)
Putting the function deﬁnition together
We can put these expressions together to create a function deﬁnition that
works. However, on examination, we ﬁnd that one of the local variables is
unneeded!

Save your time: dolist and dotimes
131
The function deﬁnition looks like this:
;;; First subtractive version.
(defun triangle (number-of-rows)
"Add up the number of pebbles in a triangle."
(let ((total 0)
(number-of-pebbles-in-row number-of-rows))
(while (> number-of-pebbles-in-row 0)
(setq total (+ total number-of-pebbles-in-row))
(setq number-of-pebbles-in-row
(1- number-of-pebbles-in-row)))
total))
As written, this function works.
However, we do not need number-of-pebbles-in-row.
When the triangle function is evaluated, the symbol number-of-rows
will be bound to a number, giving it an initial value. That number can be
changed in the body of the function as if it were a local variable, without
any fear that such a change will eﬀect the value of the variable outside of
the function.
This is a very useful characteristic of Lisp; it means that
the variable number-of-rows can be used anywhere in the function where
number-of-pebbles-in-row is used.
Here is a second version of the function written a bit more cleanly:
(defun triangle (number)
; Second version.
"Return sum of numbers 1 through NUMBER inclusive."
(let ((total 0))
(while (> number 0)
(setq total (+ total number))
(setq number (1- number)))
total))
In brief, a properly written while loop will consist of three parts:
1. A test that will return false after the loop has repeated itself the correct
number of times.
2. An expression the evaluation of which will return the value desired after
being repeatedly evaluated.
3. An expression to change the value passed to the true-or-false-test so
that the test returns false after the loop has repeated itself the right
number of times.
11.2 Save your time: dolist and dotimes
In addition to while, both dolist and dotimes provide for looping.
Sometimes these are quicker to write than the equivalent while loop. Both
are Lisp macros. (See section “Macros” in The GNU Emacs Lisp Reference
Manual. )

132
Chapter 11: Loops and Recursion
dolist works like a while loop that ‘cdrs down a list’: dolist auto-
matically shortens the list each time it loops—takes the cdr of the list—and
binds the car of each shorter version of the list to the ﬁrst of its arguments.
dotimes loops a speciﬁc number of time: you specify the number.
The dolist Macro
Suppose, for example, you want to reverse a list, so that “ﬁrst” “second”
“third” becomes “third” “second” “ﬁrst”.
In practice, you would use the reverse function, like this:
(setq animals ’(gazelle giraffe lion tiger))
(reverse animals)
Here is how you could reverse the list using a while loop:
(setq animals ’(gazelle giraffe lion tiger))
(defun reverse-list-with-while (list)
"Using while, reverse the order of LIST."
(let (value)
; make sure list starts empty
(while list
(setq value (cons (car list) value))
(setq list (cdr list)))
value))
(reverse-list-with-while animals)
And here is how you could use the dolist macro:
(setq animals ’(gazelle giraffe lion tiger))
(defun reverse-list-with-dolist (list)
"Using dolist, reverse the order of LIST."
(let (value)
; make sure list starts empty
(dolist (element list value)
(setq value (cons element value)))))
(reverse-list-with-dolist animals)
In Info, you can place your cursor after the closing parenthesis of each ex-
pression and type C-x C-e; in each case, you should see
(tiger lion giraffe gazelle)
in the echo area.
For this example, the existing reverse function is obviously best. The
while loop is just like our ﬁrst example (see Section 11.1.1, “A while Loop
and a List”, page 122). The while ﬁrst checks whether the list has elements;
if so, it constructs a new list by adding the ﬁrst element of the list to the

The dotimes Macro
133
existing list (which in the ﬁrst iteration of the loop is nil). Since the second
element is prepended in front of the ﬁrst element, and the third element is
prepended in front of the second element, the list is reversed.
In the expression using a while loop, the (setq list (cdr list)) ex-
pression shortens the list, so the while loop eventually stops. In addition,
it provides the cons expression with a new ﬁrst element by creating a new
and shorter list at each repetition of the loop.
The dolist expression does very much the same as the while expression,
except that the dolist macro does some of the work you have to do when
writing a while expression.
Like a while loop, a dolist loops. What is diﬀerent is that it automat-
ically shortens the list each time it loops — it ‘cdrs down the list’ on its
own — and it automatically binds the car of each shorter version of the list
to the ﬁrst of its arguments.
In the example, the car of each shorter version of the list is referred
to using the symbol ‘element’, the list itself is called ‘list’, and the value
returned is called ‘value’. The remainder of the dolist expression is the
body.
The dolist expression binds the car of each shorter version of the list
to element and then evaluates the body of the expression; and repeats the
loop. The result is returned in value.
The dotimes Macro
The dotimes macro is similar to dolist, except that it loops a speciﬁc
number of times.
The ﬁrst argument to dotimes is assigned the numbers 0, 1, 2 and so
forth each time around the loop, and the value of the third argument is
returned. You need to provide the value of the second argument, which is
how many times the macro loops.
For example, the following binds the numbers from 0 up to, but not
including, the number 3 to the ﬁrst argument, number, and then constructs
a list of the three numbers. (The ﬁrst number is 0, the second number is
1, and the third number is 2; this makes a total of three numbers in all,
starting with zero as the ﬁrst number.)
(let (value)
; otherwise a value is a void variable
(dotimes (number 3 value)
(setq value (cons number value))))
⇒(2 1 0)
dotimes returns value, so the way to use dotimes is to operate on some
expression number number of times and then return the result, either as a
list or an atom.

134
Chapter 11: Loops and Recursion
Here is an example of a defun that uses dotimes to add up the number
of pebbles in a triangle.
(defun triangle-using-dotimes (number-of-rows)
"Using dotimes, add up the number of pebbles in a triangle."
(let ((total 0))
; otherwise a total is a void variable
(dotimes (number number-of-rows total)
(setq total (+ total (1+ number))))))
(triangle-using-dotimes 4)
11.3 Recursion
A recursive function contains code that tells the Lisp interpreter to call a
program that runs exactly like itself, but with slightly diﬀerent arguments.
The code runs exactly the same because it has the same name. However,
even though it has the same name, it is not the same thread of execution.
It is diﬀerent. In the jargon, it is a diﬀerent ‘instance’.
Eventually, if the program is written correctly, the ‘slightly diﬀerent ar-
guments’ will become suﬃciently diﬀerent from the ﬁrst arguments that the
ﬁnal instance will stop.
11.3.1 Building Robots: Extending the Metaphor
It is sometimes helpful to think of a running program as a robot that does
a job. In doing its job, a recursive function calls on a second robot to help
it. The second robot is identical to the ﬁrst in every way, except that the
second robot helps the ﬁrst and has been passed diﬀerent arguments than
the ﬁrst.
In a recursive function, the second robot may call a third; and the third
may call a fourth, and so on. Each of these is a diﬀerent entity; but all are
clones.
Since each robot has slightly diﬀerent instructions—the arguments will
diﬀer from one robot to the next—the last robot should know when to stop.
Let’s expand on the metaphor in which a computer program is a robot.
A function deﬁnition provides the blueprints for a robot. When you install
a function deﬁnition, that is, when you evaluate a defun special form, you
install the necessary equipment to build robots. It is as if you were in a
factory, setting up an assembly line. Robots with the same name are built
according to the same blueprints. So they have, as it were, the same ‘model
number’, but a diﬀerent ‘serial number’.
We often say that a recursive function ‘calls itself’. What we mean is
that the instructions in a recursive function cause the Lisp interpreter to
run a diﬀerent function that has the same name and does the same job as
the ﬁrst, but with diﬀerent arguments.

Recursion with a List
135
It is important that the arguments diﬀer from one instance to the next;
otherwise, the process will never stop.
11.3.2 The Parts of a Recursive Deﬁnition
A recursive function typically contains a conditional expression which has
three parts:
1. A true-or-false-test that determines whether the function is called again,
here called the do-again-test.
2. The name of the function. When this name is called, a new instance of
the function—a new robot, as it were—is created and told what to do.
3. An expression that returns a diﬀerent value each time the function is
called, here called the next-step-expression.
Consequently, the argu-
ment (or arguments) passed to the new instance of the function will
be diﬀerent from that passed to the previous instance. This causes the
conditional expression, the do-again-test, to test false after the correct
number of repetitions.
Recursive functions can be much simpler than any other kind of function.
Indeed, when people ﬁrst start to use them, they often look so mysteriously
simple as to be incomprehensible. Like riding a bicycle, reading a recursive
function deﬁnition takes a certain knack which is hard at ﬁrst but then seems
simple.
There are several diﬀerent common recursive patterns. A very simple
pattern looks like this:
(defun name-of-recursive-function (argument-list)
"documentation..."
(if do-again-test
body...
(name-of-recursive-function
next-step-expression)))
Each time a recursive function is evaluated, a new instance of it is created
and told what to do. The arguments tell the instance what to do.
An argument is bound to the value of the next-step-expression. Each
instance runs with a diﬀerent value of the next-step-expression.
The value in the next-step-expression is used in the do-again-test.
The value returned by the next-step-expression is passed to the new in-
stance of the function, which evaluates it (or some transmogriﬁcation of it)
to determine whether to continue or stop. The next-step-expression is de-
signed so that the do-again-test returns false when the function should no
longer be repeated.
The do-again-test is sometimes called the stop condition, since it stops
the repetitions when it tests false.

136
Chapter 11: Loops and Recursion
11.3.3 Recursion with a List
The example of a while loop that printed the elements of a list of numbers
can be written recursively. Here is the code, including an expression to set
the value of the variable animals to a list.
If you are using Emacs 20 or before, this example must be copied to the
‘*scratch*’ buﬀer and each expression must be evaluated there. Use C-u C-
x C-e to evaluate the (print-elements-recursively animals) expression
so that the results are printed in the buﬀer; otherwise the Lisp interpreter
will try to squeeze the results into the one line of the echo area.
Also, place your cursor immediately after the last closing parenthesis of
the print-elements-recursively function, before the comment. Other-
wise, the Lisp interpreter will try to evaluate the comment.
If you are using Emacs 21 or later, you can evaluate this expression
directly in Info.
(setq animals ’(gazelle giraffe lion tiger))
(defun print-elements-recursively (list)
"Print each element of LIST on a line of its own.
Uses recursion."
(if list
; do-again-test
(progn
(print (car list))
; body
(print-elements-recursively
; recursive call
(cdr list)))))
; next-step-expression
(print-elements-recursively animals)
The print-elements-recursively function ﬁrst tests whether there is
any content in the list; if there is, the function prints the ﬁrst element of the
list, the car of the list. Then the function ‘invokes itself’, but gives itself as
its argument, not the whole list, but the second and subsequent elements of
the list, the cdr of the list.
Put another way, if the list is not empty, the function invokes another
instance of code that is similar to the initial code, but is a diﬀerent thread
of execution, with diﬀerent arguments than the ﬁrst instance.
Put in yet another way, if the list is not empty, the ﬁrst robot assemblies a
second robot and tells it what to do; the second robot is a diﬀerent individual
from the ﬁrst, but is the same model.
When the second evaluation occurs, the if expression is evaluated and if
true, prints the ﬁrst element of the list it receives as its argument (which is
the second element of the original list). Then the function ‘calls itself’ with
the cdr of the list it is invoked with, which (the second time around) is the
cdr of the cdr of the original list.

Recursion in Place of a Counter
137
Note that although we say that the function ‘calls itself’, what we mean
is that the Lisp interpreter assembles and instructs a new instance of the
program. The new instance is a clone of the ﬁrst, but is a separate individual.
Each time the function ‘invokes itself’, it invokes itself on a shorter version
of the original list. It creates a new instance that works on a shorter list.
Eventually, the function invokes itself on an empty list. It creates a new
instance whose argument is nil. The conditional expression tests the value
of list. Since the value of list is nil, the if expression tests false so the
then-part is not evaluated. The function as a whole then returns nil.
When you evaluate (print-elements-recursively animals) in the
‘*scratch*’ buﬀer, you see this result:
giraffe
gazelle
lion
tiger
nil
11.3.4 Recursion in Place of a Counter
The triangle function described in a previous section can also be written
recursively. It looks like this:
(defun triangle-recursively (number)
"Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
(if (= number 1)
; do-again-test
1
; then-part
(+ number
; else-part
(triangle-recursively
; recursive call
(1- number)))))
; next-step-expression
(triangle-recursively 7)
You can install this function by evaluating it and then try it by evaluating
(triangle-recursively 7). (Remember to put your cursor immediately
after the last parenthesis of the function deﬁnition, before the comment.)
The function evaluates to 28.
To understand how this function works, let’s consider what happens in
the various cases when the function is passed 1, 2, 3, or 4 as the value of its
argument.
First, what happens if the value of the argument is 1?
The function has an if expression after the documentation string. It
tests whether the value of number is equal to 1; if so, Emacs evaluates the

138
Chapter 11: Loops and Recursion
then-part of the if expression, which returns the number 1 as the value of
the function. (A triangle with one row has one pebble in it.)
Suppose, however, that the value of the argument is 2.
In this case,
Emacs evaluates the else-part of the if expression.
The else-part consists of an addition, the recursive call to triangle-
recursively and a decrementing action; and it looks like this:
(+ number (triangle-recursively (1- number)))
When Emacs evaluates this expression, the innermost expression is eval-
uated ﬁrst; then the other parts in sequence. Here are the steps in detail:
Step 1
Evaluate the innermost expression.
The innermost expression is (1- number) so Emacs decrements
the value of number from 2 to 1.
Step 2
Evaluate the triangle-recursively function.
The Lisp interpreter creates an individual instance of triangle-
recursively. It does not matter that this function is contained
within itself. Emacs passes the result Step 1 as the argument
used by this instance of the triangle-recursively function
In this case, Emacs evaluates triangle-recursively with an
argument of 1. This means that this evaluation of triangle-
recursively returns 1.
Step 3
Evaluate the value of number.
The variable number is the second element of the list that starts
with +; its value is 2.
Step 4
Evaluate the + expression.
The + expression receives two arguments, the ﬁrst from the eval-
uation of number (Step 3) and the second from the evaluation
of triangle-recursively (Step 2).
The result of the addition is the sum of 2 plus 1, and the number
3 is returned, which is correct. A triangle with two rows has
three pebbles in it.
An argument of 3 or 4
Suppose that triangle-recursively is called with an argument of 3.
Step 1
Evaluate the do-again-test.
The if expression is evaluated ﬁrst. This is the do-again test and
returns false, so the else-part of the if expression is evaluated.
(Note that in this example, the do-again-test causes the function
to call itself when it tests false, not when it tests true.)
Step 2
Evaluate the innermost expression of the else-part.
The innermost expression of the else-part is evaluated, which
decrements 3 to 2. This is the next-step-expression.

Recursion Example Using cond
139
Step 3
Evaluate the triangle-recursively function.
The number 2 is passed to the triangle-recursively function.
We know what happens when Emacs evaluates triangle-
recursively with an argument of 2. After going through the
sequence of actions described earlier, it returns a value of 3. So
that is what will happen here.
Step 4
Evaluate the addition.
3 will be passed as an argument to the addition and will be
added to the number with which the function was called, which
is 3.
The value returned by the function as a whole will be 6.
Now that we know what will happen when triangle-recursively is
called with an argument of 3, it is evident what will happen if it is called
with an argument of 4:
In the recursive call, the evaluation of
(triangle-recursively (1- 4))
will return the value of evaluating
(triangle-recursively 3)
which is 6 and this value will be added to 4 by the addition in the
third line.
The value returned by the function as a whole will be 10.
Each time triangle-recursively is evaluated, it evaluates a version
of itself—a diﬀerent instance of itself—with a smaller argument, until the
argument is small enough so that it does not evaluate itself.
Note that this particular design for a recursive function requires that
operations be deferred.
Before (triangle-recursively 7) can calculate its answer, it must call
(triangle-recursively 6); and before (triangle-recursively 6) can
calculate its answer, it must call (triangle-recursively 5); and so on.
That is to say, the calculation that (triangle-recursively 7) makes must
be deferred until (triangle-recursively 6) makes its calculation; and
(triangle-recursively 6) must defer until (triangle-recursively 5)
completes; and so on.
If each of these instances of triangle-recursively are thought of as
diﬀerent robots, the ﬁrst robot must wait for the second to complete its job,
which must wait until the third completes, and so on.
There is a way around this kind of waiting, which we will discuss in
Section 11.3.7, “Recursion without Deferments”, page 143.
11.3.5 Recursion Example Using cond
The version of triangle-recursively described earlier is written with
the if special form. It can also be written using another special form called

140
Chapter 11: Loops and Recursion
cond. The name of the special form cond is an abbreviation of the word
‘conditional’.
Although the cond special form is not used as often in the Emacs Lisp
sources as if, it is used often enough to justify explaining it.
The template for a cond expression looks like this:
(cond
body...)
where the body is a series of lists.
Written out more fully, the template looks like this:
(cond
(ﬁrst-true-or-false-test ﬁrst-consequent)
(second-true-or-false-test second-consequent)
(third-true-or-false-test third-consequent)
...)
When the Lisp interpreter evaluates the cond expression, it evaluates the
ﬁrst element (the car or true-or-false-test) of the ﬁrst expression in a series
of expressions within the body of the cond.
If the true-or-false-test returns nil the rest of that expression, the con-
sequent, is skipped and the true-or-false-test of the next expression is eval-
uated. When an expression is found whose true-or-false-test returns a value
that is not nil, the consequent of that expression is evaluated. The conse-
quent can be one or more expressions. If the consequent consists of more
than one expression, the expressions are evaluated in sequence and the value
of the last one is returned. If the expression does not have a consequent, the
value of the true-or-false-test is returned.
If none of the true-or-false-tests test true, the cond expression returns
nil.
Written using cond, the triangle function looks like this:
(defun triangle-using-cond (number)
(cond ((<= number 0) 0)
((= number 1) 1)
((> number 1)
(+ number (triangle-using-cond (1- number))))))
In this example, the cond returns 0 if the number is less than or equal to
0, it returns 1 if the number is 1 and it evaluates (+ number (triangle-
using-cond (1- number))) if the number is greater than 1.
11.3.6 Recursive Patterns
Here are three common recursive patterns. Each involves a list. Recursion
does not need to involve lists, but Lisp is designed for lists and this provides
a sense of its primal capabilities.

Recursive Pattern: every
141
Recursive Pattern: every
In the every recursive pattern, an action is performed on every element
of a list.
The basic pattern is:
• If a list be empty, return nil.
• Else, act on the beginning of the list (the car of the list)
−through a recursive call by the function on the rest (the cdr) of
the list,
−and, optionally, combine the acted-on element, using cons, with
the results of acting on the rest.
Here is example:
(defun square-each (numbers-list)
"Square each of a NUMBERS LIST, recursively."
(if (not numbers-list)
; do-again-test
nil
(cons
(* (car numbers-list) (car numbers-list))
(square-each (cdr numbers-list))))) ; next-step-expression
(square-each ’(1 2 3))
⇒(1 4 9)
If numbers-list is empty, do nothing. But if it has content, construct a list
combining the square of the ﬁrst number in the list with the result of the
recursive call.
(The example follows the pattern exactly: nil is returned if the numbers’
list is empty. In practice, you would write the conditional so it carries out
the action when the numbers’ list is not empty.)
The print-elements-recursively function (see Section 11.3.3, “Recur-
sion with a List”, page 136) is another example of an every pattern, except
in this case, rather than bring the results together using cons, we print each
element of output.
The print-elements-recursively function looks like this:
(setq animals ’(gazelle giraffe lion tiger))

142
Chapter 11: Loops and Recursion
(defun print-elements-recursively (list)
"Print each element of LIST on a line of its own.
Uses recursion."
(if list
; do-again-test
(progn
(print (car list))
; body
(print-elements-recursively
; recursive call
(cdr list)))))
; next-step-expression
(print-elements-recursively animals)
The pattern for print-elements-recursively is:
• If the list be empty, do nothing.
• But if the list has at least one element,
−act on the beginning of the list (the car of the list),
−and make a recursive call on the rest (the cdr) of the list.
Recursive Pattern: accumulate
Another recursive pattern is called the accumulate pattern.
In the
accumulate recursive pattern, an action is performed on every element of a
list and the result of that action is accumulated with the results of perform-
ing the action on the other elements.
This is very like the ‘every’ pattern using cons, except that cons is not
used, but some other combiner.
The pattern is:
• If a list be empty, return zero or some other constant.
• Else, act on the beginning of the list (the car of the list),
−and combine that acted-on element, using + or some other combin-
ing function, with
−a recursive call by the function on the rest (the cdr) of the list.
Here is an example:
(defun add-elements (numbers-list)
"Add the elements of NUMBERS-LIST together."
(if (not numbers-list)
0
(+ (car numbers-list) (add-elements (cdr numbers-list)))))
(add-elements ’(1 2 3 4))
⇒10
See Section 14.9.2, “Making a List of Files”, page 194, for an example of
the accumulate pattern.

Recursion without Deferments
143
Recursive Pattern: keep
A third recursive pattern is called the keep pattern. In the keep recursive
pattern, each element of a list is tested; the element is acted on and the
results are kept only if the element meets a criterion.
Again, this is very like the ‘every’ pattern, except the element is skipped
unless it meets a criterion.
The pattern has three parts:
• If a list be empty, return nil.
• Else, if the beginning of the list (the car of the list) passes a test
−act on that element and combine it, using cons with
−a recursive call by the function on the rest (the cdr) of the list.
• Otherwise, if the beginning of the list (the car of the list) fails the test
−skip on that element,
−and, recursively call the function on the rest (the cdr) of the list.
Here is an example that uses cond:
(defun keep-three-letter-words (word-list)
"Keep three letter words in WORD-LIST."
(cond
;; First do-again-test: stop-condition
((not word-list) nil)
;; Second do-again-test: when to act
((eq 3 (length (symbol-name (car word-list))))
;; combine acted-on element with recursive call on shorter list
(cons (car word-list) (keep-three-letter-words (cdr word-list))))
;; Third do-again-test: when to skip element;
;;
recursively call shorter list with next-step expression
(t
(keep-three-letter-words (cdr word-list)))))
(keep-three-letter-words ’(one two three four five six))
⇒(one two six)
It goes without saying that you need not use nil as the test for when to
stop; and you can, of course, combine these patterns.
11.3.7 Recursion without Deferments
Let’s consider again what happens with the triangle-recursively func-
tion. We will ﬁnd that the intermediate calculations are deferred until all
can be done.

144
Chapter 11: Loops and Recursion
Here is the function deﬁnition:
(defun triangle-recursively (number)
"Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
(if (= number 1)
; do-again-test
1
; then-part
(+ number
; else-part
(triangle-recursively
; recursive call
(1- number)))))
; next-step-expression
What happens when we call this function with a argument of 7?
The ﬁrst instance of the triangle-recursively function adds the num-
ber 7 to the value returned by a second instance of triangle-recursively,
an instance that has been passed an argument of 6. That is to say, the ﬁrst
calculation is:
(+ 7 (triangle-recursively 6)
The ﬁrst instance of triangle-recursively—you may want to think of it
as a little robot—cannot complete its job. It must hand oﬀthe calculation
for (triangle-recursively 6) to a second instance of the program, to a
second robot. This second individual is completely diﬀerent from the ﬁrst
one; it is, in the jargon, a ‘diﬀerent instantiation’. Or, put another way, it
is a diﬀerent robot. It is the same model as the ﬁrst; it calculates triangle
numbers recursively; but it has a diﬀerent serial number.
And what does (triangle-recursively 6) return? It returns the num-
ber 6 added to the value returned by evaluating triangle-recursively
with an argument of 5. Using the robot metaphor, it asks yet another robot
to help it.
Now the total is:
(+ 7 6 (triangle-recursively 5)
And what happens next?
(+ 7 6 5 (triangle-recursively 4)
Each time triangle-recursively is called, except for the last time,
it creates another instance of the program—another robot—and asks it to
make a calculation.
Eventually, the full addition is set up and performed:
(+ 7 6 5 4 3 2 1)
This design for the function defers the calculation of the ﬁrst step until
the second can be done, and defers that until the third can be done, and
so on. Each deferment means the computer must remember what is being
waited on. This is not a problem when there are only a few steps, as in this
example. But it can be a problem when there are more steps.

No Deferment Solution
145
11.3.8 No Deferment Solution
The solution to the problem of deferred operations is to write in a manner
that does not defer operations2. This requires writing to a diﬀerent pattern,
often one that involves writing two function deﬁnitions, an ‘initialization’
function and a ‘helper’ function.
The ‘initialization’ function sets up the job; the ‘helper’ function does the
work.
Here are the two function deﬁnitions for adding up numbers. They are
so simple, I ﬁnd them hard to understand.
(defun triangle-initialization (number)
"Return the sum of the numbers 1 through NUMBER inclusive.
This is the ‘initialization’ component of a two function
duo that uses recursion."
(triangle-recursive-helper 0 0 number))
(defun triangle-recursive-helper (sum counter number)
"Return SUM, using COUNTER, through NUMBER inclusive.
This is the ‘helper’ component of a two function duo
that uses recursion."
(if (> counter number)
sum
(triangle-recursive-helper (+ sum counter)
; sum
(1+ counter)
; counter
number)))
; number
Install both function deﬁnitions by evaluating them, then call triangle-
initialization with 2 rows:
(triangle-initialization 2)
⇒3
The ‘initialization’ function calls the ﬁrst instance of the ‘helper’ function
with three arguments: zero, zero, and a number which is the number of rows
in the triangle.
The ﬁrst two arguments passed to the ‘helper’ function are initializa-
tion values. These values are changed when triangle-recursive-helper
invokes new instances.3
2 The phrase tail recursive is used to describe such a process, one that uses ‘constant
space’.
3 The jargon is mildly confusing: triangle-recursive-helper uses a process that is
iterative in a procedure that is recursive. The process is called iterative because the
computer need only record the three values, sum, counter, and number; the procedure
is recursive because the function ‘calls itself’. On the other hand, both the process
and the procedure used by triangle-recursively are called recursive.
The word
‘recursive’ has diﬀerent meanings in the two contexts.

146
Chapter 11: Loops and Recursion
Let’s see what happens when we have a triangle that has one row. (This
triangle will have one pebble in it!)
triangle-initialization will call its helper with the arguments 0 0 1.
That function will run the conditional test whether (> counter number):
(> 0 1)
and ﬁnd that the result is false, so it will invoke the then-part of the if
clause:
(triangle-recursive-helper
(+ sum counter)
; sum plus counter ⇒sum
(1+ counter)
; increment counter ⇒counter
number)
; number stays the same
which will ﬁrst compute:
(triangle-recursive-helper (+ 0 0)
; sum
(1+ 0)
; counter
1)
; number
which is:
(triangle-recursive-helper 0 1 1)
Again, (> counter number) will be false, so again, the Lisp interpreter
will evaluate triangle-recursive-helper, creating a new instance with
new arguments.
This new instance will be;
(triangle-recursive-helper
(+ sum counter)
; sum plus counter ⇒sum
(1+ counter)
; increment counter ⇒counter
number)
; number stays the same
which is:
(triangle-recursive-helper 1 2 1)
In this case, the (> counter number) test will be true! So the instance
will return the value of the sum, which will be 1, as expected.
Now, let’s pass triangle-initialization an argument of 2, to ﬁnd out
how many pebbles there are in a triangle with two rows.
That function calls (triangle-recursive-helper 0 0 2).
In stages, the instances called will be:
sum counter number
(triangle-recursive-helper 0
1
2)
(triangle-recursive-helper 1
2
2)
(triangle-recursive-helper 3
3
2)

Looping Exercise
147
When the last instance is called, the (> counter number) test will be
true, so the instance will return the value of sum, which will be 3.
This kind of pattern helps when you are writing functions that can use
many resources in a computer.
11.4 Looping Exercise
• Write a function similar to triangle in which each row has a value
which is the square of the row number. Use a while loop.
• Write a function similar to triangle that multiplies instead of adds the
values.
• Rewrite these two functions recursively. Rewrite these functions using
cond.
• Write a function for Texinfo mode that creates an index entry at the
beginning of a paragraph for every ‘@dfn’ within the paragraph. (In
a Texinfo ﬁle, ‘@dfn’ marks a deﬁnition.
For more information, see
“Indicating Deﬁnitions, Commands, etc.” in Texinfo, The GNU Docu-
mentation Format.)

148
Chapter 11: Loops and Recursion

The Regular Expression for sentence-end
149
12 Regular Expression Searches
Regular expression searches are used extensively in GNU Emacs. The
two functions, forward-sentence and forward-paragraph, illustrate these
searches well. They use regular expressions to ﬁnd where to move point.
The phrase ‘regular expression’ is often written as ‘regexp’.
Regular expression searches are described in section “Regular Expression
Search” in The GNU Emacs Manual, as well as in section “Regular Expres-
sions” in The GNU Emacs Lisp Reference Manual. In writing this chapter,
I am presuming that you have at least a mild acquaintance with them. The
major point to remember is that regular expressions permit you to search
for patterns as well as for literal strings of characters. For example, the code
in forward-sentence searches for the pattern of possible characters that
could mark the end of a sentence, and moves point to that spot.
Before looking at the code for the forward-sentence function, it is worth
considering what the pattern that marks the end of a sentence must be.
The pattern is discussed in the next section; following that is a descrip-
tion of the regular expression search function, re-search-forward.
The
forward-sentence function is described in the section following. Finally,
the forward-paragraph function is described in the last section of this chap-
ter. forward-paragraph is a complex function that introduces several new
features.
12.1 The Regular Expression for sentence-end
The symbol sentence-end is bound to the pattern that marks the end
of a sentence. What should this regular expression be?
Clearly, a sentence may be ended by a period, a question mark, or an
exclamation mark. Indeed, only clauses that end with one of those three
characters should be considered the end of a sentence. This means that the
pattern should include the character set:
[.?!]
However, we do not want forward-sentence merely to jump to a period,
a question mark, or an exclamation mark, because such a character might
be used in the middle of a sentence. A period, for example, is used after
abbreviations. So other information is needed.
According to convention, you type two spaces after every sentence, but
only one space after a period, a question mark, or an exclamation mark in the
body of a sentence. So a period, a question mark, or an exclamation mark
followed by two spaces is a good indicator of an end of sentence. However, in
a ﬁle, the two spaces may instead be a tab or the end of a line. This means
that the regular expression should include these three items as alternatives.

150
Chapter 12: Regular Expression Searches
This group of alternatives will look like this:
\\($\\| \\|
\\)
^
^^
TAB
SPC
Here, ‘$’ indicates the end of the line, and I have pointed out where the tab
and two spaces are inserted in the expression. Both are inserted by putting
the actual characters into the expression.
Two backslashes, ‘\\’, are required before the parentheses and vertical
bars: the ﬁrst backslash quotes the following backslash in Emacs; and the
second indicates that the following character, the parenthesis or the vertical
bar, is special.
Also, a sentence may be followed by one or more carriage returns, like
this:
[
]*
Like tabs and spaces, a carriage return is inserted into a regular expression
by inserting it literally. The asterisk indicates that the ⟨RET⟩is repeated zero
or more times.
But a sentence end does not consist only of a period, a question mark or an
exclamation mark followed by appropriate space: a closing quotation mark
or a closing brace of some kind may precede the space. Indeed more than
one such mark or brace may precede the space. These require a expression
that looks like this:
[]\"’)}]*
In this expression, the ﬁrst ‘]’ is the ﬁrst character in the expression; the
second character is ‘"’, which is preceded by a ‘\’ to tell Emacs the ‘"’ is not
special. The last three characters are ‘’’, ‘)’, and ‘}’.
All this suggests what the regular expression pattern for matching the
end of a sentence should be; and, indeed, if we evaluate sentence-end we
ﬁnd that it returns the following value:
sentence-end
⇒"[.?!][]\"’)}]*\\($\\|
\\|
\\)[
]*"
12.2 The re-search-forward Function
The re-search-forward function is very like the search-forward func-
tion. (See Section 8.1.3, “The search-forward Function”, page 92.)
re-search-forward searches for a regular expression. If the search is
successful, it leaves point immediately after the last character in the target.
If the search is backwards, it leaves point just before the ﬁrst character in
the target. You may tell re-search-forward to return t for true. (Moving
point is therefore a ‘side eﬀect’.)

forward-sentence
151
Like search-forward, the re-search-forward function takes four argu-
ments:
1. The ﬁrst argument is the regular expression that the function searches
for. The regular expression will be a string between quotations marks.
2. The optional second argument limits how far the function will search;
it is a bound, which is speciﬁed as a position in the buﬀer.
3. The optional third argument speciﬁes how the function responds to
failure: nil as the third argument causes the function to signal an error
(and print a message) when the search fails; any other value causes it
to return nil if the search fails and t if the search succeeds.
4. The optional fourth argument is the repeat count. A negative repeat
count causes re-search-forward to search backwards.
The template for re-search-forward looks like this:
(re-search-forward "regular-expression"
limit-of-search
what-to-do-if-search-fails
repeat-count)
The second, third, and fourth arguments are optional. However, if you
want to pass a value to either or both of the last two arguments, you must also
pass a value to all the preceding arguments. Otherwise, the Lisp interpreter
will mistake which argument you are passing the value to.
In the forward-sentence function, the regular expression will be the
value of the variable sentence-end, namely:
"[.?!][]\"’)}]*\\($\\|
\\|
\\)[
]*"
The limit of the search will be the end of the paragraph (since a sentence
cannot go beyond a paragraph). If the search fails, the function will return
nil; and the repeat count will be provided by the argument to the forward-
sentence function.
12.3 forward-sentence
The command to move the cursor forward a sentence is a straightforward
illustration of how to use regular expression searches in Emacs Lisp. Indeed,
the function looks longer and more complicated than it is; this is because the
function is designed to go backwards as well as forwards; and, optionally, over
more than one sentence. The function is usually bound to the key command
M-e.

152
Chapter 12: Regular Expression Searches
Here is the code for forward-sentence:
(defun forward-sentence (&optional arg)
"Move forward to next sentence-end.
With argument, repeat.
With negative argument, move backward repeatedly to sentence-beginning.
Sentence ends are identified by the value of sentence-end
treated as a regular expression.
Also, every paragraph boundary
terminates sentences as well."
(interactive "p")
(or arg (setq arg 1))
(while (< arg 0)
(let ((par-beg
(save-excursion (start-of-paragraph-text) (point))))
(if (re-search-backward
(concat sentence-end "[^ \t\n]") par-beg t)
(goto-char (1- (match-end 0)))
(goto-char par-beg)))
(setq arg (1+ arg)))
(while (> arg 0)
(let ((par-end
(save-excursion (end-of-paragraph-text) (point))))
(if (re-search-forward sentence-end par-end t)
(skip-chars-backward " \t\n")
(goto-char par-end)))
(setq arg (1- arg))))
The function looks long at ﬁrst sight and it is best to look at its skeleton
ﬁrst, and then its muscle. The way to see the skeleton is to look at the
expressions that start in the left-most columns:
(defun forward-sentence (&optional arg)
"documentation..."
(interactive "p")
(or arg (setq arg 1))
(while (< arg 0)
body-of-while-loop
(while (> arg 0)
body-of-while-loop
This looks much simpler! The function deﬁnition consists of documenta-
tion, an interactive expression, an or expression, and while loops.
Let’s look at each of these parts in turn.
We note that the documentation is thorough and understandable.
The function has an interactive "p" declaration. This means that the
processed preﬁx argument, if any, is passed to the function as its argument.
(This will be a number.)
If the function is not passed an argument (it
is optional) then the argument arg will be bound to 1. When forward-

The while loops
153
sentence is called non-interactively without an argument, arg is bound to
nil.
The or expression handles the preﬁx argument. What it does is either
leave the value of arg as it is, but only if arg is bound to a value; or it sets
the value of arg to 1, in the case when arg is bound to nil.
The while loops
Two while loops follow the or expression. The ﬁrst while has a true-
or-false-test that tests true if the preﬁx argument for forward-sentence is
a negative number. This is for going backwards. The body of this loop is
similar to the body of the second while clause, but it is not exactly the
same. We will skip this while loop and concentrate on the second while
loop.
The second while loop is for moving point forward. Its skeleton looks
like this:
(while (> arg 0)
; true-or-false-test
(let varlist
(if (true-or-false-test)
then-part
else-part
(setq arg (1- arg))))
; while loop decrementer
The while loop is of the decrementing kind. (See Section 11.1.4, “A Loop
with a Decrementing Counter”, page 129.) It has a true-or-false-test that
tests true so long as the counter (in this case, the variable arg) is greater
than zero; and it has a decrementer that subtracts 1 from the value of the
counter every time the loop repeats.
If no preﬁx argument is given to forward-sentence, which is the most
common way the command is used, this while loop will run once, since the
value of arg will be 1.
The body of the while loop consists of a let expression, which creates
and binds a local variable, and has, as its body, an if expression.
The body of the while loop looks like this:
(let ((par-end
(save-excursion (end-of-paragraph-text) (point))))
(if (re-search-forward sentence-end par-end t)
(skip-chars-backward " \t\n")
(goto-char par-end)))
The let expression creates and binds the local variable par-end. As we
shall see, this local variable is designed to provide a bound or limit to the
regular expression search. If the search fails to ﬁnd a proper sentence ending
in the paragraph, it will stop on reaching the end of the paragraph.

154
Chapter 12: Regular Expression Searches
But ﬁrst, let us examine how par-end is bound to the value of the end
of the paragraph. What happens is that the let sets the value of par-end
to the value returned when the Lisp interpreter evaluates the expression
(save-excursion (end-of-paragraph-text) (point))
In this expression, (end-of-paragraph-text) moves point to the end of the
paragraph, (point) returns the value of point, and then save-excursion
restores point to its original position. Thus, the let binds par-end to the
value returned by the save-excursion expression, which is the position of
the end of the paragraph. (The (end-of-paragraph-text) function uses
forward-paragraph, which we will discuss shortly.)
Emacs next evaluates the body of the let, which is an if expression that
looks like this:
(if (re-search-forward sentence-end par-end t) ; if-part
(skip-chars-backward " \t\n")
; then-part
(goto-char par-end)))
; else-part
The if tests whether its ﬁrst argument is true and if so, evaluates its
then-part; otherwise, the Emacs Lisp interpreter evaluates the else-part.
The true-or-false-test of the if expression is the regular expression search.
It may seem odd to have what looks like the ‘real work’ of the forward-
sentence function buried here, but this is a common way this kind of oper-
ation is carried out in Lisp.
The regular expression search
The re-search-forward function searches for the end of the sentence,
that is, for the pattern deﬁned by the sentence-end regular expression.
If the pattern is found—if the end of the sentence is found—then the re-
search-forward function does two things:
1. The re-search-forward function carries out a side eﬀect, which is to
move point to the end of the occurrence found.
2. The re-search-forward function returns a value of true. This is the
value received by the if, and means that the search was successful.
The side eﬀect, the movement of point, is completed before the if function
is handed the value returned by the successful conclusion of the search.
When the if function receives the value of true from a successful call to
re-search-forward, the if evaluates the then-part, which is the expression
(skip-chars-backward " \t\n"). This expression moves backwards over
any blank spaces, tabs or carriage returns until a printed character is found
and then leaves point after the character.
Since point has already been
moved to the end of the pattern that marks the end of the sentence, this
action leaves point right after the closing printed character of the sentence,
which is usually a period.
On the other hand, if the re-search-forward function fails to ﬁnd a
pattern marking the end of the sentence, the function returns false. The

forward-paragraph: a Goldmine of Functions
155
false then causes the if to evaluate its third argument, which is (goto-char
par-end): it moves point to the end of the paragraph.
Regular expression searches are exceptionally useful and the pattern il-
lustrated by re-search-forward, in which the search is the test of an if
expression, is handy. You will see or write code incorporating this pattern
often.
12.4 forward-paragraph: a Goldmine of Functions
The forward-paragraph function moves point forward to the end of the
paragraph. It is usually bound to M-} and makes use of a number of functions
that are important in themselves, including let*, match-beginning, and
looking-at.
The function deﬁnition for forward-paragraph is considerably longer
than the function deﬁnition for forward-sentence because it works with a
paragraph, each line of which may begin with a ﬁll preﬁx.
A ﬁll preﬁx consists of a string of characters that are repeated at the
beginning of each line. For example, in Lisp code, it is a convention to start
each line of a paragraph-long comment with ‘;;; ’. In Text mode, four blank
spaces make up another common ﬁll preﬁx, creating an indented paragraph.
(See section “Fill Preﬁx” in The GNU Emacs Manual, for more information
about ﬁll preﬁxes.)
The existence of a ﬁll preﬁx means that in addition to being able to
ﬁnd the end of a paragraph whose lines begin on the left-most column, the
forward-paragraph function must be able to ﬁnd the end of a paragraph
when all or many of the lines in the buﬀer begin with the ﬁll preﬁx.
Moreover, it is sometimes practical to ignore a ﬁll preﬁx that exists, espe-
cially when blank lines separate paragraphs. This is an added complication.
Rather than print all of the forward-paragraph function, we will only
print parts of it. Read without preparation, the function can be daunting!
In outline, the function looks like this:
(defun forward-paragraph (&optional arg)
"documentation..."
(interactive "p")
(or arg (setq arg 1))
(let*
varlist
(while (< arg 0)
; backward-moving-code
...
(setq arg (1+ arg)))
(while (> arg 0)
; forward-moving-code
...
(setq arg (1- arg)))))

156
Chapter 12: Regular Expression Searches
The ﬁrst parts of the function are routine: the function’s argument list
consists of one optional argument. Documentation follows.
The lower case ‘p’ in the interactive declaration means that the pro-
cessed preﬁx argument, if any, is passed to the function.
This will be a
number, and is the repeat count of how many paragraphs point will move.
The or expression in the next line handles the common case when no argu-
ment is passed to the function, which occurs if the function is called from
other code rather than interactively. This case was described earlier. (See
Section 12.3, “forward-sentence”, page 151.) Now we reach the end of the
familiar part of this function.
The let* expression
The next line of the forward-paragraph function begins a let* expres-
sion. This is a diﬀerent kind of expression than we have seen so far. The
symbol is let* not let.
The let* special form is like let except that Emacs sets each variable
in sequence, one after another, and variables in the latter part of the varlist
can make use of the values to which Emacs set variables in the earlier part
of the varlist.
In the let* expression in this function, Emacs binds two variables: fill-
prefix-regexp and paragraph-separate. The value to which paragraph-
separate is bound depends on the value of fill-prefix-regexp.
Let’s look at each in turn. The symbol fill-prefix-regexp is set to
the value returned by evaluating the following list:
(and fill-prefix
(not (equal fill-prefix ""))
(not paragraph-ignore-fill-prefix)
(regexp-quote fill-prefix))
This is an expression whose ﬁrst element is the and special form.
As we learned earlier (see “The kill-new function”, page 105), the and
special form evaluates each of its arguments until one of the arguments
returns a value of nil, in which case the and expression returns nil; however,
if none of the arguments returns a value of nil, the value resulting from
evaluating the last argument is returned. (Since such a value is not nil, it
is considered true in Lisp.) In other words, an and expression returns a true
value only if all its arguments are true.
In this case, the variable fill-prefix-regexp is bound to a non-nil
value only if the following four expressions produce a true (i.e., a non-nil)
value when they are evaluated; otherwise, fill-prefix-regexp is bound to
nil.

The let* expression
157
fill-prefix
When this variable is evaluated, the value of the ﬁll preﬁx, if
any, is returned. If there is no ﬁll preﬁx, this variable returns
nil.
(not (equal fill-prefix "")
This expression checks whether an existing ﬁll preﬁx is an empty
string, that is, a string with no characters in it. An empty string
is not a useful ﬁll preﬁx.
(not paragraph-ignore-fill-prefix)
This expression returns nil if the variable paragraph-ignore-
fill-prefix has been turned on by being set to a true value
such as t.
(regexp-quote fill-prefix)
This is the last argument to the and special form.
If all the
arguments to the and are true, the value resulting from evaluat-
ing this expression will be returned by the and expression and
bound to the variable fill-prefix-regexp,
The result of evaluating this and expression successfully is that fill-
prefix-regexp will be bound to the value of fill-prefix as modiﬁed by
the regexp-quote function. What regexp-quote does is read a string and
return a regular expression that will exactly match the string and match
nothing else. This means that fill-prefix-regexp will be set to a value
that will exactly match the ﬁll preﬁx if the ﬁll preﬁx exists. Otherwise, the
variable will be set to nil.
The second local variable in the let* expression is paragraph-separate.
It is bound to the value returned by evaluating the expression:
(if fill-prefix-regexp
(concat paragraph-separate
"\\|^" fill-prefix-regexp "[ \t]*$")
paragraph-separate)))
This expression shows why let* rather than let was used. The true-or-
false-test for the if depends on whether the variable fill-prefix-regexp
evaluates to nil or some other value.
If fill-prefix-regexp does not have a value, Emacs evaluates the else-
part of the if expression and binds paragraph-separate to its local value.
(paragraph-separate is a regular expression that matches what separates
paragraphs.)
But if fill-prefix-regexp does have a value, Emacs evaluates the then-
part of the if expression and binds paragraph-separate to a regular ex-
pression that includes the fill-prefix-regexp as part of the pattern.
Speciﬁcally, paragraph-separate is set to the original value of the para-
graph separate regular expression concatenated with an alternative expres-
sion that consists of the fill-prefix-regexp followed by a blank line. The

158
Chapter 12: Regular Expression Searches
‘^’ indicates that the fill-prefix-regexp must begin a line, and the op-
tional whitespace to the end of the line is deﬁned by "[ \t]*$".) The ‘\\|’
deﬁnes this portion of the regexp as an alternative to paragraph-separate.
Now we get into the body of the let*. The ﬁrst part of the body of the
let* deals with the case when the function is given a negative argument and
is therefore moving backwards. We will skip this section.
The forward motion while loop
The second part of the body of the let* deals with forward motion. It
is a while loop that repeats itself so long as the value of arg is greater than
zero. In the most common use of the function, the value of the argument is
1, so the body of the while loop is evaluated exactly once, and the cursor
moves forward one paragraph.
This part handles three situations: when point is between paragraphs,
when point is within a paragraph and there is a ﬁll preﬁx, and when point
is within a paragraph and there is no ﬁll preﬁx.
The while loop looks like this:
(while (> arg 0)
(beginning-of-line)
;; between paragraphs
(while (prog1 (and (not (eobp))
(looking-at paragraph-separate))
(forward-line 1)))
;; within paragraphs, with a ﬁll preﬁx
(if fill-prefix-regexp
;; There is a ﬁll preﬁx; it overrides paragraph-start.
(while (and (not (eobp))
(not (looking-at paragraph-separate))
(looking-at fill-prefix-regexp))
(forward-line 1))
;; within paragraphs, no ﬁll preﬁx
(if (re-search-forward paragraph-start nil t)
(goto-char (match-beginning 0))
(goto-char (point-max))))
(setq arg (1- arg)))
We can see immediately that this is a decrementing counter while loop,
using the expression (setq arg (1- arg)) as the decrementer.

Between paragraphs
159
The body of the loop consists of three expressions:
;; between paragraphs
(beginning-of-line)
(while
body-of-while)
;; within paragraphs, with ﬁll preﬁx
(if true-or-false-test
then-part
;; within paragraphs, no ﬁll preﬁx
else-part
When the Emacs Lisp interpreter evaluates the body of the while loop, the
ﬁrst thing it does is evaluate the (beginning-of-line) expression and move
point to the beginning of the line. Then there is an inner while loop. This
while loop is designed to move the cursor out of the blank space between
paragraphs, if it should happen to be there. Finally, there is an if expression
that actually moves point to the end of the paragraph.
Between paragraphs
First, let us look at the inner while loop. This loop handles the case
when point is between paragraphs; it uses three functions that are new to
us: prog1, eobp and looking-at.
• prog1 is similar to the progn special form, except that prog1 evaluates
its arguments in sequence and then returns the value of its ﬁrst argument
as the value of the whole expression. (progn returns the value of its last
argument as the value of the expression.) The second and subsequent
arguments to prog1 are evaluated only for their side eﬀects.
• eobp is an abbreviation of ‘End Of Buffer P’ and is a function that
returns true if point is at the end of the buﬀer.
• looking-at is a function that returns true if the text following point
matches the regular expression passed looking-at as its argument.
The while loop we are studying looks like this:
(while (prog1 (and (not (eobp))
(looking-at paragraph-separate))
(forward-line 1)))
This is a while loop with no body! The true-or-false-test of the loop is the
expression:
(prog1 (and (not (eobp))
(looking-at paragraph-separate))
(forward-line 1))
The ﬁrst argument to the prog1 is the and expression. It has within in it a
test of whether point is at the end of the buﬀer and also a test of whether

160
Chapter 12: Regular Expression Searches
the pattern following point matches the regular expression for separating
paragraphs.
If the cursor is not at the end of the buﬀer and if the characters fol-
lowing the cursor mark the separation between two paragraphs, then the
and expression is true. After evaluating the and expression, the Lisp inter-
preter evaluates the second argument to prog1, which is forward-line. This
moves point forward one line. The value returned by the prog1 however, is
the value of its ﬁrst argument, so the while loop continues so long as point
is not at the end of the buﬀer and is between paragraphs. When, ﬁnally,
point is moved to a paragraph, the and expression tests false. Note however,
that the forward-line command is carried out anyhow. This means that
when point is moved from between paragraphs to a paragraph, it is left at
the beginning of the second line of the paragraph.
Within paragraphs
The next expression in the outer while loop is an if expression. The
Lisp interpreter evaluates the then-part of the if when the fill-prefix-
regexp variable has a value other than nil, and it evaluates the else-part
when the value of if fill-prefix-regexp is nil, that is, when there is no
ﬁll preﬁx.
No ﬁll preﬁx
It is simplest to look at the code for the case when there is no ﬁll preﬁx
ﬁrst. This code consists of yet another inner if expression, and reads as
follows:
(if (re-search-forward paragraph-start nil t)
(goto-char (match-beginning 0))
(goto-char (point-max)))
This expression actually does the work that most people think of as the
primary purpose of the forward-paragraph command: it causes a regular
expression search to occur that searches forward to the start of the next
paragraph and if it is found, moves point there; but if the start of another
paragraph if not found, it moves point to the end of the accessible region of
the buﬀer.
The only unfamiliar part of this is the use of match-beginning. This is
another function that is new to us. The match-beginning function returns
a number specifying the location of the start of the text that was matched
by the last regular expression search.
The match-beginning function is used here because of a characteristic
of a forward search: a successful forward search, regardless of whether it is
a plain search or a regular expression search, will move point to the end of
the text that is found. In this case, a successful search will move point to

Summary
161
the end of the pattern for paragraph-start, which will be the beginning of
the next paragraph rather than the end of the current one.
However, we want to put point at the end of the current paragraph, not at
the beginning of the next one. The two positions may be diﬀerent, because
there may be several blank lines between paragraphs.
When given an argument of 0, match-beginning returns the position
that is the start of the text that the most recent regular expression search
matched. In this case, the most recent regular expression search is the one
looking for paragraph-start, so match-beginning returns the beginning
position of the pattern, rather than the end of the pattern. The beginning
position is the end of the paragraph.
(Incidentally, when passed a positive number as an argument, the match-
beginning function will place point at that parenthesized expression in the
last regular expression. It is a useful function.)
With a ﬁll preﬁx
The inner if expression just discussed is the else-part of an enclosing if
expression which tests whether there is a ﬁll preﬁx. If there is a ﬁll preﬁx,
the then-part of this if is evaluated. It looks like this:
(while (and (not (eobp))
(not (looking-at paragraph-separate))
(looking-at fill-prefix-regexp))
(forward-line 1))
What this expression does is move point forward line by line so long as three
conditions are true:
1. Point is not at the end of the buﬀer.
2. The text following point does not separate paragraphs.
3. The pattern following point is the ﬁll preﬁx regular expression.
The last condition may be puzzling, until you remember that point was
moved to the beginning of the line early in the forward-paragraph function.
This means that if the text has a ﬁll preﬁx, the looking-at function will
see it.
Summary
In summary, when moving forward, the forward-paragraph function
does the following:
• Move point to the beginning of the line.
• Skip over lines between paragraphs.
• Check whether there is a ﬁll preﬁx, and if there is:
— Go forward line by line so long as the line is not a paragraph sep-
arating line.

162
Chapter 12: Regular Expression Searches
• But if there is no ﬁll preﬁx,
— Search for the next paragraph start pattern.
— Go to the beginning of the paragraph start pattern, which will be
the end of the previous paragraph.
— Or else go to the end of the accessible portion of the buﬀer.
For review, here is the code we have just been discussing, formatted for
clarity:
(interactive "p")
(or arg (setq arg 1))
(let* (
(fill-prefix-regexp
(and fill-prefix (not (equal fill-prefix ""))
(not paragraph-ignore-fill-prefix)
(regexp-quote fill-prefix)))
(paragraph-separate
(if fill-prefix-regexp
(concat paragraph-separate
"\\|^"
fill-prefix-regexp
"[ \t]*$")
paragraph-separate)))
omitted-backward-moving-code ...
(while (> arg 0)
; forward-moving-code
(beginning-of-line)
(while (prog1 (and (not (eobp))
(looking-at paragraph-separate))
(forward-line 1)))
(if fill-prefix-regexp
(while (and (not (eobp))
; then-part
(not (looking-at paragraph-separate))
(looking-at fill-prefix-regexp))
(forward-line 1))
; else-part: the inner-if
(if (re-search-forward paragraph-start nil t)
(goto-char (match-beginning 0))
(goto-char (point-max))))
(setq arg (1- arg)))))
; decrementer
The full deﬁnition for the forward-paragraph function not only includes
this code for going forwards, but also code for going backwards.

Create Your Own ‘TAGS’ File
163
If you are reading this inside of GNU Emacs and you want to see the
whole function, you can type C-h f (describe-function) and the name of
the function. This gives you the function documentation and the name of
the library containing the function’s source. Place point over the name of
the library and press the RET key; you will be taken directly to the source.
(Be sure to install your sources! Without them, you are like a person who
tries to drive a car with his eyes shut!)
Or – a good habit to get into – you can type M-. (find-tag) and
the name of the function when prompted for it.
This will take you di-
rectly to the source.
If the find-tag function ﬁrst asks you for the
name of a ‘TAGS’ table, give it the name of the ‘TAGS’ ﬁle such as
‘/usr/local/share/emacs/21.0.100/lisp/TAGS’. (The exact path to your
‘TAGS’ ﬁle depends on how your copy of Emacs was installed.)
You can also create your own ‘TAGS’ ﬁle for directories that lack one.
12.5 Create Your Own ‘TAGS’ File
The M-. (find-tag) command takes you directly to the source for a
function, variable, node, or other source.
The function depends on tags
tables to tell it where to go.
You often need to build and install tags tables yourself. They are not
built automatically. A tags table is called a ‘TAGS’ ﬁle; the name is in upper
case letters.
You can create a ‘TAGS’ ﬁle by calling the etags program that comes as
a part of the Emacs distribution. Usually, etags is compiled and installed
when Emacs is built. (etags is not an Emacs Lisp function or a part of
Emacs; it is a C program.)
To create a ‘TAGS’ ﬁle, ﬁrst switch to the directory in which you want
to create the ﬁle.
In Emacs you can do this with the M-x cd command,
or by visiting a ﬁle in the directory, or by listing the directory with C-x d
(dired). Then run the compile command, with etags *.el as the command
to execute
M-x compile RET etags *.el RET
to create a ‘TAGS’ ﬁle.
For example, if you have a large number of ﬁles in your ‘~/emacs’ direc-
tory, as I do—I have 137 ‘.el’ ﬁles in it, of which I load 12—you can create
a ‘TAGS’ ﬁle for the Emacs Lisp ﬁles in that directory.
The etags program takes all the usual shell ‘wildcards’. For example,
if you have two directories for which you want a single ‘TAGS file’, type
etags *.el ../elisp/*.el, where ‘../elisp/’ is the second directory:
M-x compile RET etags *.el ../elisp/*.el RET

164
Chapter 12: Regular Expression Searches
Type
M-x compile RET etags --help RET
to see a list of the options accepted by etags as well as a list of supported
languages.
The etags program handles more than 20 languages, including Emacs
Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, Java, LaTeX, Pascal,
Perl, Python, Texinfo, makeﬁles, and most assemblers. The program has no
switches for specifying the language; it recognizes the language in an input
ﬁle according to its ﬁle name and contents.
‘etags’ is very helpful when you are writing code yourself and want to
refer back to functions you have already written. Just run etags again at
intervals as you write new functions, so they become part of the ‘TAGS’ ﬁle.
If you think an appropriate ‘TAGS’ ﬁle already exists for what you want,
but do not know where it is, you can use the locate program to attempt to
ﬁnd it.
Type M-x locate RET TAGS RET and Emacs will list for you the full path
names of all your ‘TAGS’ ﬁles. On my system, this command lists 34 ‘TAGS’
ﬁles. On the other hand, a ‘plain vanilla’ system I recently installed did not
contain any ‘TAGS’ ﬁles.
If the tags table you want has been created, you can use the M-x visit-
tags-table command to specify it. Otherwise, you will need to create the
tag table yourself and then use M-x visit-tags-table.
Building Tags in the Emacs sources
The GNU Emacs sources come with a ‘Makefile’ that contains a sophis-
ticated etags command that creates, collects, and merges tags tables from
all over the Emacs sources and puts the information into one ‘TAGS’ ﬁle in
the ‘src/’ directory below the top level of your Emacs source directory.
To build this ‘TAGS’ ﬁle, go to the top level of your Emacs source directory
and run the compile command make tags:
M-x compile RET make tags RET
(The make tags command works well with the GNU Emacs sources, as well
as with some other source packages.)
For more information, see section “Tag Tables” in The GNU Emacs Man-
ual.
12.6 Review
Here is a brief summary of some recently introduced functions.
while
Repeatedly evaluate the body of the expression so long as the
ﬁrst element of the body tests true. Then return nil. (The
expression is evaluated only for its side eﬀects.)

Review
165
For example:
(let ((foo 2))
(while (> foo 0)
(insert (format "foo is %d.\n" foo))
(setq foo (1- foo))))
⇒
foo is 2.
foo is 1.
nil
(The insert function inserts its arguments at point; the format
function returns a string formatted from its arguments the way
message formats its arguments; \n produces a new line.)
re-search-forward
Search for a pattern, and if the pattern is found, move point to
rest just after it.
Takes four arguments, like search-forward:
1. A regular expression that speciﬁes the pattern to search for.
2. Optionally, the limit of the search.
3. Optionally, what to do if the search fails, return nil or an
error message.
4. Optionally, how many times to repeat the search; if nega-
tive, the search goes backwards.
let*
Bind some variables locally to particular values, and then eval-
uate the remaining arguments, returning the value of the last
one. While binding the local variables, use the local values of
variables bound earlier, if any.
For example:
(let* ((foo 7)
(bar (* 3 foo)))
(message "‘bar’ is %d." bar))
⇒‘bar’ is 21.
match-beginning
Return the position of the start of the text found by the last
regular expression search.
looking-at
Return t for true if the text after point matches the argument,
which should be a regular expression.
eobp
Return t for true if point is at the end of the accessible part of
a buﬀer. The end of the accessible part is the end of the buﬀer
if the buﬀer is not narrowed; it is the end of the narrowed part
if the buﬀer is narrowed.

166
Chapter 12: Regular Expression Searches
prog1
Evaluate each argument in sequence and then return the value
of the ﬁrst.
For example:
(prog1 1 2 3 4)
⇒1
12.7 Exercises with re-search-forward
• Write a function to search for a regular expression that matches two or
more blank lines in sequence.
• Write a function to search for duplicated words, such as ‘the the’. See
section “Syntax of Regular Expressions” in The GNU Emacs Manual,
for information on how to write a regexp (a regular expression) to match
a string that is composed of two identical halves. You can devise several
regexps; some are better than others. The function I use is described
in an appendix, along with several regexps. See Appendix A, “the-the
Duplicated Words Function”, page 241.

The count-words-region Function
167
13 Counting: Repetition and Regexps
Repetition and regular expression searches are powerful tools that you
often use when you write code in Emacs Lisp. This chapter illustrates the
use of regular expression searches through the construction of word count
commands using while loops and recursion.
The standard Emacs distribution contains a function for counting the
number of lines within a region. However, there is no corresponding function
for counting words.
Certain types of writing ask you to count words.
Thus, if you write
an essay, you may be limited to 800 words; if you write a novel, you may
discipline yourself to write 1000 words a day.
It seems odd to me that
Emacs lacks a word count command. Perhaps people use Emacs mostly for
code or types of documentation that do not require word counts; or perhaps
they restrict themselves to the operating system word count command, wc.
Alternatively, people may follow the publishers’ convention and compute a
word count by dividing the number of characters in a document by ﬁve. In
any event, here are commands to count words.
13.1 The count-words-region Function
A word count command could count words in a line, paragraph, region,
or buﬀer. What should the command cover? You could design the command
to count the number of words in a complete buﬀer. However, the Emacs tra-
dition encourages ﬂexibility—you may want to count words in just a section,
rather than all of a buﬀer. So it makes more sense to design the command
to count the number of words in a region. Once you have a count-words-
region command, you can, if you wish, count words in a whole buﬀer by
marking it with C-x h (mark-whole-buffer).
Clearly, counting words is a repetitive act: starting from the beginning
of the region, you count the ﬁrst word, then the second word, then the third
word, and so on, until you reach the end of the region. This means that
word counting is ideally suited to recursion or to a while loop.
First, we will implement the word count command with a while loop,
then with recursion. The command will, of course, be interactive.
The template for an interactive function deﬁnition is, as always:
(defun name-of-function (argument-list)
"documentation..."
(interactive-expression...)
body...)
What we need to do is ﬁll in the slots.
The name of the function should be self-explanatory and similar to the
existing count-lines-region name. This makes the name easier to remem-
ber. count-words-region is a good choice.

168
Chapter 13: Counting: Repetition and Regexps
The function counts words within a region. This means that the argument
list must contain symbols that are bound to the two positions, the beginning
and end of the region. These two positions can be called ‘beginning’ and
‘end’ respectively. The ﬁrst line of the documentation should be a single sen-
tence, since that is all that is printed as documentation by a command such
as apropos. The interactive expression will be of the form ‘(interactive
"r")’, since that will cause Emacs to pass the beginning and end of the
region to the function’s argument list. All this is routine.
The body of the function needs to be written to do three tasks: ﬁrst, to
set up conditions under which the while loop can count words, second, to
run the while loop, and third, to send a message to the user.
When a user calls count-words-region, point may be at the beginning
or the end of the region. However, the counting process must start at the
beginning of the region.
This means we will want to put point there if
it is not already there.
Executing (goto-char beginning) ensures this.
Of course, we will want to return point to its expected position when the
function ﬁnishes its work. For this reason, the body must be enclosed in a
save-excursion expression.
The central part of the body of the function consists of a while loop
in which one expression jumps point forward word by word, and another
expression counts those jumps.
The true-or-false-test of the while loop
should test true so long as point should jump forward, and false when point
is at the end of the region.
We could use (forward-word 1) as the expression for moving point for-
ward word by word, but it is easier to see what Emacs identiﬁes as a ‘word’
if we use a regular expression search.
A regular expression search that ﬁnds the pattern for which it is searching
leaves point after the last character matched. This means that a succession
of successful word searches will move point forward word by word.
As a practical matter, we want the regular expression search to jump
over whitespace and punctuation between words as well as over the words
themselves. A regexp that refuses to jump over interword whitespace would
never jump more than one word! This means that the regexp should include
the whitespace and punctuation that follows a word, if any, as well as the
word itself. (A word may end a buﬀer and not have any following whitespace
or punctuation, so that part of the regexp must be optional.)
Thus, what we want for the regexp is a pattern deﬁning one or more word
constituent characters followed, optionally, by one or more characters that
are not word constituents. The regular expression for this is:
\w+\W*
The buﬀer’s syntax table determines which characters are and are not word
constituents. (See Section 14.2, “What Constitutes a Word or Symbol?”,
page 182, for more about syntax. Also, see section “The Syntax Table” in

The count-words-region Function
169
The GNU Emacs Manual, and section “Syntax Tables” in The GNU Emacs
Lisp Reference Manual.)
The search expression looks like this:
(re-search-forward "\\w+\\W*")
(Note that paired backslashes precede the ‘w’ and ‘W’. A single backslash
has special meaning to the Emacs Lisp interpreter. It indicates that the fol-
lowing character is interpreted diﬀerently than usual. For example, the two
characters, ‘\n’, stand for ‘newline’, rather than for a backslash followed by
‘n’. Two backslashes in a row stand for an ordinary, ‘unspecial’ backslash.)
We need a counter to count how many words there are; this variable
must ﬁrst be set to 0 and then incremented each time Emacs goes around
the while loop. The incrementing expression is simply:
(setq count (1+ count))
Finally, we want to tell the user how many words there are in the region.
The message function is intended for presenting this kind of information to
the user. The message has to be phrased so that it reads properly regardless
of how many words there are in the region: we don’t want to say that “there
are 1 words in the region”.
The conﬂict between singular and plural is
ungrammatical. We can solve this problem by using a conditional expression
that evaluates diﬀerent messages depending on the number of words in the
region. There are three possibilities: no words in the region, one word in the
region, and more than one word. This means that the cond special form is
appropriate.
All this leads to the following function deﬁnition:
;;; First version; has bugs!
(defun count-words-region (beginning end)
"Print number of words in the region.
Words are defined as at least one word-constituent
character followed by at least one character that
is not a word-constituent.
The buffer’s syntax
table determines which characters these are."
(interactive "r")
(message "Counting words in region ... ")
;;; 1. Set up appropriate conditions.
(save-excursion
(goto-char beginning)
(let ((count 0))
;;; 2. Run the while loop.
(while (< (point) end)
(re-search-forward "\\w+\\W*")
(setq count (1+ count)))

170
Chapter 13: Counting: Repetition and Regexps
;;; 3. Send a message to the user.
(cond ((zerop count)
(message
"The region does NOT have any words."))
((= 1 count)
(message
"The region has 1 word."))
(t
(message
"The region has %d words." count))))))
As written, the function works, but not in all circumstances.
13.1.1 The Whitespace Bug in count-words-region
The count-words-region command described in the preceding section
has two bugs, or rather, one bug with two manifestations.
First, if you
mark a region containing only whitespace in the middle of some text, the
count-words-region command tells you that the region contains one word!
Second, if you mark a region containing only whitespace at the end of the
buﬀer or the accessible portion of a narrowed buﬀer, the command displays
an error message that looks like this:
Search failed: "\\w+\\W*"
If you are reading this in Info in GNU Emacs, you can test for these bugs
yourself.
First, evaluate the function in the usual manner to install it.
If you wish, you can also install this keybinding by evaluating it:
(global-set-key "\C-c=" ’count-words-region)
To conduct the ﬁrst test, set mark and point to the beginning and end of
the following line and then type C-c = (or M-x count-words-region if you
have not bound C-c =):
one
two
three
Emacs will tell you, correctly, that the region has three words.
Repeat the test, but place mark at the beginning of the line and place
point just before the word ‘one’. Again type the command C-c = (or M-x
count-words-region). Emacs should tell you that the region has no words,
since it is composed only of the whitespace at the beginning of the line. But
instead Emacs tells you that the region has one word!
For the third test, copy the sample line to the end of the ‘*scratch*’
buﬀer and then type several spaces at the end of the line. Place mark right
after the word ‘three’ and point at the end of line. (The end of the line
will be the end of the buﬀer.) Type C-c = (or M-x count-words-region) as
you did before. Again, Emacs should tell you that the region has no words,

The Whitespace Bug in count-words-region
171
since it is composed only of the whitespace at the end of the line. Instead,
Emacs displays an error message saying ‘Search failed’.
The two bugs stem from the same problem.
Consider the ﬁrst manifestation of the bug, in which the command tells
you that the whitespace at the beginning of the line contains one word.
What happens is this: The M-x count-words-region command moves point
to the beginning of the region. The while tests whether the value of point
is smaller than the value of end, which it is.
Consequently, the regular
expression search looks for and ﬁnds the ﬁrst word. It leaves point after the
word. count is set to one. The while loop repeats; but this time the value
of point is larger than the value of end, the loop is exited; and the function
displays a message saying the number of words in the region is one. In brief,
the regular expression search looks for and ﬁnds the word even though it is
outside the marked region.
In the second manifestation of the bug, the region is whitespace at the
end of the buﬀer. Emacs says ‘Search failed’. What happens is that the
true-or-false-test in the while loop tests true, so the search expression is
executed. But since there are no more words in the buﬀer, the search fails.
In both manifestations of the bug, the search extends or attempts to
extend outside of the region.
The solution is to limit the search to the region—this is a fairly simple
action, but as you may have come to expect, it is not quite as simple as you
might think.
As we have seen, the re-search-forward function takes a search pattern
as its ﬁrst argument. But in addition to this ﬁrst, mandatory argument, it
accepts three optional arguments. The optional second argument bounds the
search. The optional third argument, if t, causes the function to return nil
rather than signal an error if the search fails. The optional fourth argument
is a repeat count. (In Emacs, you can see a function’s documentation by
typing C-h f, the name of the function, and then ⟨RET⟩.)
In the count-words-region deﬁnition, the value of the end of the region
is held by the variable end which is passed as an argument to the func-
tion. Thus, we can add end as an argument to the regular expression search
expression:
(re-search-forward "\\w+\\W*" end)
However, if you make only this change to the count-words-region deﬁni-
tion and then test the new version of the deﬁnition on a stretch of whitespace,
you will receive an error message saying ‘Search failed’.
What happens is this: the search is limited to the region, and fails as
you expect because there are no word-constituent characters in the region.
Since it fails, we receive an error message. But we do not want to receive an
error message in this case; we want to receive the message that "The region
does NOT have any words."

172
Chapter 13: Counting: Repetition and Regexps
The solution to this problem is to provide re-search-forward with a
third argument of t, which causes the function to return nil rather than
signal an error if the search fails.
However, if you make this change and try it, you will see the message
“Counting words in region ... ” and . . . you will keep on seeing that message
. . ., until you type C-g (keyboard-quit).
Here is what happens: the search is limited to the region, as before, and
it fails because there are no word-constituent characters in the region, as
expected. Consequently, the re-search-forward expression returns nil.
It does nothing else. In particular, it does not move point, which it does
as a side eﬀect if it ﬁnds the search target. After the re-search-forward
expression returns nil, the next expression in the while loop is evaluated.
This expression increments the count. Then the loop repeats. The true-or-
false-test tests true because the value of point is still less than the value of
end, since the re-search-forward expression did not move point. . . . and
the cycle repeats . . .
The count-words-region deﬁnition requires yet another modiﬁcation,
to cause the true-or-false-test of the while loop to test false if the search
fails. Put another way, there are two conditions that must be satisﬁed in the
true-or-false-test before the word count variable is incremented: point must
still be within the region and the search expression must have found a word
to count.
Since both the ﬁrst condition and the second condition must be true
together, the two expressions, the region test and the search expression, can
be joined with an and special form and embedded in the while loop as the
true-or-false-test, like this:
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))
(For information about and, see Section 12.4, “forward-paragraph: a Gold-
mine of Functions”, page 155.)
The re-search-forward expression returns t if the search succeeds and
as a side eﬀect moves point.
Consequently, as words are found, point is
moved through the region. When the search expression fails to ﬁnd another
word, or when point reaches the end of the region, the true-or-false-test tests
false, the while loop exists, and the count-words-region function displays
one or other of its messages.
After incorporating these ﬁnal changes, the count-words-region works
without bugs (or at least, without bugs that I have found!). Here is what it
looks like:
;;; Final version: while
(defun count-words-region (beginning end)
"Print number of words in the region."
(interactive "r")
(message "Counting words in region ... ")

Count Words Recursively
173
;;; 1. Set up appropriate conditions.
(save-excursion
(let ((count 0))
(goto-char beginning)
;;; 2. Run the while loop.
(while (and (< (point) end)
(re-search-forward "\\w+\\W*" end t))
(setq count (1+ count)))
;;; 3. Send a message to the user.
(cond ((zerop count)
(message
"The region does NOT have any words."))
((= 1 count)
(message
"The region has 1 word."))
(t
(message
"The region has %d words." count))))))
13.2 Count Words Recursively
You can write the function for counting words recursively as well as with
a while loop. Let’s see how this is done.
First, we need to recognize that the count-words-region function has
three jobs: it sets up the appropriate conditions for counting to occur; it
counts the words in the region; and it sends a message to the user telling
how many words there are.
If we write a single recursive function to do everything, we will receive
a message for every recursive call. If the region contains 13 words, we will
receive thirteen messages, one right after the other. We don’t want this!
Instead, we must write two functions to do the job, one of which (the recur-
sive function) will be used inside of the other. One function will set up the
conditions and display the message; the other will return the word count.
Let us start with the function that causes the message to be displayed.
We can continue to call this count-words-region.
This is the function that the user will call. It will be interactive. Indeed,
it will be similar to our previous versions of this function, except that it
will call recursive-count-words to determine how many words are in the
region.

174
Chapter 13: Counting: Repetition and Regexps
We can readily construct a template for this function, based on our pre-
vious versions:
;; Recursive version; uses regular expression search
(defun count-words-region (beginning end)
"documentation..."
(interactive-expression...)
;;; 1. Set up appropriate conditions.
(explanatory message)
(set-up functions...
;;; 2. Count the words.
recursive call
;;; 3. Send a message to the user.
message providing word count))
The deﬁnition looks straightforward, except that somehow the count re-
turned by the recursive call must be passed to the message displaying the
word count. A little thought suggests that this can be done by making use
of a let expression: we can bind a variable in the varlist of a let expression
to the number of words in the region, as returned by the recursive call; and
then the cond expression, using binding, can display the value to the user.
Often, one thinks of the binding within a let expression as somehow
secondary to the ‘primary’ work of a function. But in this case, what you
might consider the ‘primary’ job of the function, counting words, is done
within the let expression.
Using let, the function deﬁnition looks like this:
(defun count-words-region (beginning end)
"Print number of words in the region."
(interactive "r")
;;; 1. Set up appropriate conditions.
(message "Counting words in region ... ")
(save-excursion
(goto-char beginning)
;;; 2. Count the words.
(let ((count (recursive-count-words end)))

Count Words Recursively
175
;;; 3. Send a message to the user.
(cond ((zerop count)
(message
"The region does NOT have any words."))
((= 1 count)
(message
"The region has 1 word."))
(t
(message
"The region has %d words." count))))))
Next, we need to write the recursive counting function.
A recursive function has at least three parts: the ‘do-again-test’, the
‘next-step-expression’, and the recursive call.
The do-again-test determines whether the function will or will not be
called again. Since we are counting words in a region and can use a function
that moves point forward for every word, the do-again-test can check whether
point is still within the region. The do-again-test should ﬁnd the value of
point and determine whether point is before, at, or after the value of the
end of the region. We can use the point function to locate point. Clearly,
we must pass the value of the end of the region to the recursive counting
function as an argument.
In addition, the do-again-test should also test whether the search ﬁnds a
word. If it does not, the function should not call itself again.
The next-step-expression changes a value so that when the recursive func-
tion is supposed to stop calling itself, it stops. More precisely, the next-step-
expression changes a value so that at the right time, the do-again-test stops
the recursive function from calling itself again. In this case, the next-step-
expression can be the expression that moves point forward, word by word.
The third part of a recursive function is the recursive call.
Somewhere, also, we also need a part that does the ‘work’ of the function,
a part that does the counting. A vital part!
But already, we have an outline of the recursive counting function:
(defun recursive-count-words (region-end)
"documentation..."
do-again-test
next-step-expression
recursive call)
Now we need to ﬁll in the slots. Let’s start with the simplest cases ﬁrst:
if point is at or beyond the end of the region, there cannot be any words in
the region, so the function should return zero. Likewise, if the search fails,
there are no words to count, so the function should return zero.
On the other hand, if point is within the region and the search succeeds,
the function should call itself again.

176
Chapter 13: Counting: Repetition and Regexps
Thus, the do-again-test should look like this:
(and (< (point) region-end)
(re-search-forward "\\w+\\W*" region-end t))
Note that the search expression is part of the do-again-test—the function
returns t if its search succeeds and nil if it fails. (See Section 13.1.1, “The
Whitespace Bug in count-words-region”, page 170, for an explanation of
how re-search-forward works.)
The do-again-test is the true-or-false test of an if clause.
Clearly, if
the do-again-test succeeds, the then-part of the if clause should call the
function again; but if it fails, the else-part should return zero since either
point is outside the region or the search failed because there were no words
to ﬁnd.
But before considering the recursive call, we need to consider the next-
step-expression. What is it? Interestingly, it is the search part of the do-
again-test.
In addition to returning t or nil for the do-again-test, re-search-
forward moves point forward as a side eﬀect of a successful search. This is
the action that changes the value of point so that the recursive function stops
calling itself when point completes its movement through the region. Con-
sequently, the re-search-forward expression is the next-step-expression.
In outline, then, the body of the recursive-count-words function looks
like this:
(if do-again-test-and-next-step-combined
;; then
recursive-call-returning-count
;; else
return-zero)
How to incorporate the mechanism that counts?
If you are not used to writing recursive functions, a question like this can
be troublesome. But it can and should be approached systematically.
We know that the counting mechanism should be associated in some
way with the recursive call. Indeed, since the next-step-expression moves
point forward by one word, and since a recursive call is made for each word,
the counting mechanism must be an expression that adds one to the value
returned by a call to recursive-count-words.
Consider several cases:
• If there are two words in the region, the function should return a value
resulting from adding one to the value returned when it counts the ﬁrst
word, plus the number returned when it counts the remaining words in
the region, which in this case is one.
• If there is one word in the region, the function should return a value
resulting from adding one to the value returned when it counts that

Count Words Recursively
177
word, plus the number returned when it counts the remaining words in
the region, which in this case is zero.
• If there are no words in the region, the function should return zero.
From the sketch we can see that the else-part of the if returns zero for
the case of no words. This means that the then-part of the if must return
a value resulting from adding one to the value returned from a count of the
remaining words.
The expression will look like this, where 1+ is a function that adds one
to its argument.
(1+ (recursive-count-words region-end))
The whole recursive-count-words function will then look like this:
(defun recursive-count-words (region-end)
"documentation..."
;;; 1. do-again-test
(if (and (< (point) region-end)
(re-search-forward "\\w+\\W*" region-end t))
;;; 2. then-part: the recursive call
(1+ (recursive-count-words region-end))
;;; 3. else-part
0))
Let’s examine how this works:
If there are no words in the region, the else part of the if expression is
evaluated and consequently the function returns zero.
If there is one word in the region, the value of point is less than the value
of region-end and the search succeeds. In this case, the true-or-false-test
of the if expression tests true, and the then-part of the if expression is
evaluated. The counting expression is evaluated. This expression returns a
value (which will be the value returned by the whole function) that is the
sum of one added to the value returned by a recursive call.
Meanwhile, the next-step-expression has caused point to jump over the
ﬁrst (and in this case only) word in the region.
This means that when
(recursive-count-words region-end) is evaluated a second time, as a
result of the recursive call, the value of point will be equal to or greater
than the value of region end. So this time, recursive-count-words will
return zero. The zero will be added to one, and the original evaluation of
recursive-count-words will return one plus zero, which is one, which is
the correct amount.
Clearly, if there are two words in the region, the ﬁrst call to recursive-
count-words returns one added to the value returned by calling recursive-
count-words on a region containing the remaining word—that is, it adds
one to one, producing two, which is the correct amount.

178
Chapter 13: Counting: Repetition and Regexps
Similarly, if there are three words in the region, the ﬁrst call to
recursive-count-words returns one added to the value returned by calling
recursive-count-words on a region containing the remaining two words—
and so on and so on.
With full documentation the two functions look like this:
The recursive function:
(defun recursive-count-words (region-end)
"Number of words between point and REGION-END."
;;; 1. do-again-test
(if (and (< (point) region-end)
(re-search-forward "\\w+\\W*" region-end t))
;;; 2. then-part: the recursive call
(1+ (recursive-count-words region-end))
;;; 3. else-part
0))
The wrapper:
;;; Recursive version
(defun count-words-region (beginning end)
"Print number of words in the region.
Words are defined as at least one word-constituent
character followed by at least one character that is
not a word-constituent.
The buffer’s syntax table
determines which characters these are."
(interactive "r")
(message "Counting words in region ... ")
(save-excursion
(goto-char beginning)
(let ((count (recursive-count-words end)))
(cond ((zerop count)
(message
"The region does NOT have any words."))
((= 1 count)
(message "The region has 1 word."))
(t
(message
"The region has %d words." count))))))

Exercise: Counting Punctuation
179
13.3 Exercise: Counting Punctuation
Using a while loop, write a function to count the number of punctuation
marks in a region—period, comma, semicolon, colon, exclamation mark, and
question mark. Do the same using recursion.

180
Chapter 13: Counting: Repetition and Regexps

What to Count?
181
14 Counting Words in a defun
Our next project is to count the number of words in a function deﬁnition.
Clearly, this can be done using some variant of count-word-region. See
Chapter 13, “Counting Words: Repetition and Regexps”, page 167. If we
are just going to count the words in one deﬁnition, it is easy enough to
mark the deﬁnition with the C-M-h (mark-defun) command, and then call
count-word-region.
However, I am more ambitious: I want to count the words and symbols
in every deﬁnition in the Emacs sources and then print a graph that shows
how many functions there are of each length: how many contain 40 to 49
words or symbols, how many contain 50 to 59 words or symbols, and so on.
I have often been curious how long a typical function is, and this will tell.
Described in one phrase, the histogram project is daunting; but divided
into numerous small steps, each of which we can take one at a time, the
project becomes less fearsome. Let us consider what the steps must be:
• First, write a function to count the words in one deﬁnition. This includes
the problem of handling symbols as well as words.
• Second, write a function to list the numbers of words in each function
in a ﬁle. This function can use the count-words-in-defun function.
• Third, write a function to list the numbers of words in each function
in each of several ﬁles. This entails automatically ﬁnding the various
ﬁles, switching to them, and counting the words in the deﬁnitions within
them.
• Fourth, write a function to convert the list of numbers that we created
in step three to a form that will be suitable for printing as a graph.
• Fifth, write a function to print the results as a graph.
This is quite a project! But if we take each step slowly, it will not be
diﬃcult.
14.1 What to Count?
When we ﬁrst start thinking about how to count the words in a function
deﬁnition, the ﬁrst question is (or ought to be) what are we going to count?
When we speak of ‘words’ with respect to a Lisp function deﬁnition, we are
actually speaking, in large part, of ‘symbols’. For example, the following
multiply-by-seven function contains the ﬁve symbols defun, multiply-
by-seven, number, *, and 7. In addition, in the documentation string, it
contains the four words ‘Multiply’, ‘NUMBER’, ‘by’, and ‘seven’. The symbol
‘number’ is repeated, so the deﬁnition contains a total of ten words and
symbols.
(defun multiply-by-seven (number)
"Multiply NUMBER by seven."
(* 7 number))

182
Chapter 14: Counting Words in a defun
However, if we mark the multiply-by-seven deﬁnition with C-M-h (mark-
defun), and then call count-words-region on it, we will ﬁnd that count-
words-region claims the deﬁnition has eleven words, not ten! Something is
wrong!
The problem is twofold: count-words-region does not count the ‘*’ as
a word, and it counts the single symbol, multiply-by-seven, as containing
three words. The hyphens are treated as if they were interword spaces rather
than intraword connectors: ‘multiply-by-seven’ is counted as if it were
written ‘multiply by seven’.
The cause of this confusion is the regular expression search within the
count-words-region deﬁnition that moves point forward word by word. In
the canonical version of count-words-region, the regexp is:
"\\w+\\W*"
This regular expression is a pattern deﬁning one or more word constituent
characters possibly followed by one or more characters that are not word
constituents. What is meant by ‘word constituent characters’ brings us to
the issue of syntax, which is worth a section of its own.
14.2 What Constitutes a Word or Symbol?
Emacs treats diﬀerent characters as belonging to diﬀerent syntax cate-
gories. For example, the regular expression, ‘\\w+’, is a pattern specifying
one or more word constituent characters. Word constituent characters are
members of one syntax category. Other syntax categories include the class
of punctuation characters, such as the period and the comma, and the class
of whitespace characters, such as the blank space and the tab character.
(For more information, see section “The Syntax Table” in The GNU Emacs
Manual, and section “Syntax Tables” in The GNU Emacs Lisp Reference
Manual.)
Syntax tables specify which characters belong to which categories. Usu-
ally, a hyphen is not speciﬁed as a ‘word constituent character’. Instead,
it is speciﬁed as being in the ‘class of characters that are part of symbol
names but not words.’ This means that the count-words-region function
treats it in the same way it treats an interword white space, which is why
count-words-region counts ‘multiply-by-seven’ as three words.
There are two ways to cause Emacs to count ‘multiply-by-seven’ as
one symbol: modify the syntax table or modify the regular expression.
We could redeﬁne a hyphen as a word constituent character by modifying
the syntax table that Emacs keeps for each mode. This action would serve
our purpose, except that a hyphen is merely the most common character
within symbols that is not typically a word constituent character; there are
others, too.

The count-words-in-defun Function
183
Alternatively, we can redeﬁne the regular expression used in the count-
words deﬁnition so as to include symbols. This procedure has the merit of
clarity, but the task is a little tricky.
The ﬁrst part is simple enough: the pattern must match “at least one
character that is a word or symbol constituent”. Thus:
"\\(\\w\\|\\s_\\)+"
The ‘\\(’ is the ﬁrst part of the grouping construct that includes the ‘\\w’
and the ‘\\s_’ as alternatives, separated by the ‘\\|’. The ‘\\w’ matches any
word-constituent character and the ‘\\s_’ matches any character that is part
of a symbol name but not a word-constituent character. The ‘+’ following
the group indicates that the word or symbol constituent characters must be
matched at least once.
However, the second part of the regexp is more diﬃcult to design. What
we want is to follow the ﬁrst part with “optionally one or more characters
that are not constituents of a word or symbol”. At ﬁrst, I thought I could
deﬁne this with the following:
"\\(\\W\\|\\S_\\)*"
The upper case ‘W’ and ‘S’ match characters that are not word or symbol
constituents. Unfortunately, this expression matches any character that is
either not a word constituent or not a symbol constituent. This matches any
character!
I then noticed that every word or symbol in my test region was followed
by white space (blank space, tab, or newline). So I tried placing a pattern
to match one or more blank spaces after the pattern for one or more word
or symbol constituents.
This failed, too.
Words and symbols are often
separated by whitespace, but in actual code parentheses may follow symbols
and punctuation may follow words. So ﬁnally, I designed a pattern in which
the word or symbol constituents are followed optionally by characters that
are not white space and then followed optionally by white space.
Here is the full regular expression:
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
14.3 The count-words-in-defun Function
We have seen that there are several ways to write a count-word-region
function. To write a count-words-in-defun, we need merely adapt one of
these versions.
The version that uses a while loop is easy to understand, so I am going to
adapt that. Because count-words-in-defun will be part of a more complex
program, it need not be interactive and it need not display a message but
just return the count. These considerations simplify the deﬁnition a little.
On the other hand, count-words-in-defun will be used within a buﬀer
that contains function deﬁnitions. Consequently, it is reasonable to ask that

184
Chapter 14: Counting Words in a defun
the function determine whether it is called when point is within a function
deﬁnition, and if it is, to return the count for that deﬁnition. This adds
complexity to the deﬁnition, but saves us from needing to pass arguments
to the function.
These considerations lead us to prepare the following template:
(defun count-words-in-defun ()
"documentation..."
(set up...
(while loop...)
return count)
As usual, our job is to ﬁll in the slots.
First, the set up.
We are presuming that this function will be called within a buﬀer con-
taining function deﬁnitions. Point will either be within a function deﬁnition
or not. For count-words-in-defun to work, point must move to the begin-
ning of the deﬁnition, a counter must start at zero, and the counting loop
must stop when point reaches the end of the deﬁnition.
The beginning-of-defun function searches backwards for an opening
delimiter such as a ‘(’ at the beginning of a line, and moves point to that
position, or else to the limit of the search.
In practice, this means that
beginning-of-defun moves point to the beginning of an enclosing or pre-
ceding function deﬁnition, or else to the beginning of the buﬀer. We can use
beginning-of-defun to place point where we wish to start.
The while loop requires a counter to keep track of the words or symbols
being counted. A let expression can be used to create a local variable for
this purpose, and bind it to an initial value of zero.
The end-of-defun function works like beginning-of-defun except that
it moves point to the end of the deﬁnition. end-of-defun can be used as part
of an expression that determines the position of the end of the deﬁnition.
The set up for count-words-in-defun takes shape rapidly: ﬁrst we move
point to the beginning of the deﬁnition, then we create a local variable to
hold the count, and ﬁnally, we record the position of the end of the deﬁnition
so the while loop will know when to stop looping.
The code looks like this:
(beginning-of-defun)
(let ((count 0)
(end (save-excursion (end-of-defun) (point))))
The code is simple. The only slight complication is likely to concern end: it
is bound to the position of the end of the deﬁnition by a save-excursion
expression that returns the value of point after end-of-defun temporarily
moves it to the end of the deﬁnition.
The second part of the count-words-in-defun, after the set up, is the
while loop.

The count-words-in-defun Function
185
The loop must contain an expression that jumps point forward word by
word and symbol by symbol, and another expression that counts the jumps.
The true-or-false-test for the while loop should test true so long as point
should jump forward, and false when point is at the end of the deﬁnition.
We have already redeﬁned the regular expression for this (see Section 14.2,
“Syntax”, page 182), so the loop is straightforward:
(while (and (< (point) end)
(re-search-forward
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t)
(setq count (1+ count)))
The third part of the function deﬁnition returns the count of words and
symbols. This part is the last expression within the body of the let expres-
sion, and can be, very simply, the local variable count, which when evaluated
returns the count.
Put together, the count-words-in-defun deﬁnition looks like this:
(defun count-words-in-defun ()
"Return the number of words and symbols in a defun."
(beginning-of-defun)
(let ((count 0)
(end (save-excursion (end-of-defun) (point))))
(while
(and (< (point) end)
(re-search-forward
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
end t))
(setq count (1+ count)))
count))
How to test this? The function is not interactive, but it is easy to put a
wrapper around the function to make it interactive; we can use almost the
same code as for the recursive version of count-words-region:
;;; Interactive version.
(defun count-words-defun ()
"Number of words and symbols in a function definition."
(interactive)
(message
"Counting words and symbols in function definition ... ")
(let ((count (count-words-in-defun)))
(cond
((zerop count)
(message
"The definition does NOT have any words or symbols."))

186
Chapter 14: Counting Words in a defun
((= 1 count)
(message
"The definition has 1 word or symbol."))
(t
(message
"The definition has %d words or symbols." count)))))
Let’s re-use C-c = as a convenient keybinding:
(global-set-key "\C-c=" ’count-words-defun)
Now we can try out count-words-defun: install both count-words-in-
defun and count-words-defun, and set the keybinding, and then place the
cursor within the following deﬁnition:
(defun multiply-by-seven (number)
"Multiply NUMBER by seven."
(* 7 number))
⇒10
Success! The deﬁnition has 10 words and symbols.
The next problem is to count the numbers of words and symbols in several
deﬁnitions within a single ﬁle.
14.4 Count Several defuns Within a File
A ﬁle such as ‘simple.el’ may have 80 or more function deﬁnitions within
it. Our long term goal is to collect statistics on many ﬁles, but as a ﬁrst
step, our immediate goal is to collect statistics on one ﬁle.
The information will be a series of numbers, each number being the length
of a function deﬁnition. We can store the numbers in a list.
We know that we will want to incorporate the information regarding one
ﬁle with information about many other ﬁles; this means that the function
for counting deﬁnition lengths within one ﬁle need only return the list of
lengths. It need not and should not display any messages.
The word count commands contain one expression to jump point forward
word by word and another expression to count the jumps. The function to
return the lengths of deﬁnitions can be designed to work the same way, with
one expression to jump point forward deﬁnition by deﬁnition and another
expression to construct the lengths’ list.
This statement of the problem makes it elementary to write the function
deﬁnition. Clearly, we will start the count at the beginning of the ﬁle, so
the ﬁrst command will be (goto-char (point-min)). Next, we start the
while loop; and the true-or-false test of the loop can be a regular expression
search for the next function deﬁnition—so long as the search succeeds, point
is moved forward and then the body of the loop is evaluated. The body needs
an expression that constructs the lengths’ list. cons, the list construction
command, can be used to create the list. That is almost all there is to it.

lengths-list-file in Detail
187
Here is what this fragment of code looks like:
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
(setq lengths-list
(cons (count-words-in-defun) lengths-list)))
What we have left out is the mechanism for ﬁnding the ﬁle that contains
the function deﬁnitions.
In previous examples, we either used this, the Info ﬁle, or we switched
back and forth to some other buﬀer, such as the ‘*scratch*’ buﬀer.
Finding a ﬁle is a new process that we have not yet discussed.
14.5 Find a File
To ﬁnd a ﬁle in Emacs, you use the C-x C-f (find-file) command. This
command is almost, but not quite right for the lengths problem.
Let’s look at the source for find-file (you can use the find-tag com-
mand or C-h f (describe-function) to ﬁnd the source of a function):
(defun find-file (filename)
"Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists."
(interactive "FFind file: ")
(switch-to-buffer (find-file-noselect filename)))
The deﬁnition possesses short but complete documentation and an in-
teractive speciﬁcation that prompts you for a ﬁle name when you use the
command interactively. The body of the deﬁnition contains two functions,
find-file-noselect and switch-to-buffer.
According to its documentation as shown by C-h f (the describe-
function command), the find-file-noselect function reads the named
ﬁle into a buﬀer and returns the buﬀer. However, the buﬀer is not selected.
Emacs does not switch its attention (or yours if you are using find-file-
noselect) to the named buﬀer. That is what switch-to-buffer does: it
switches the buﬀer to which Emacs attention is directed; and it switches the
buﬀer displayed in the window to the new buﬀer. We have discussed buﬀer
switching elsewhere. (See Section 2.3, “Switching Buﬀers”, page 26.)
In this histogram project, we do not need to display each ﬁle on the
screen as the program determines the length of each deﬁnition within it.
Instead of employing switch-to-buffer, we can work with set-buffer,
which redirects the attention of the computer program to a diﬀerent buﬀer
but does not redisplay it on the screen. So instead of calling on find-file
to do the job, we must write our own expression.
The task is easy: use find-file-noselect and set-buffer.

188
Chapter 14: Counting Words in a defun
14.6 lengths-list-file in Detail
The core of the lengths-list-file function is a while loop containing
a function to move point forward ‘defun by defun’ and a function to count
the number of words and symbols in each defun. This core must be sur-
rounded by functions that do various other tasks, including ﬁnding the ﬁle,
and ensuring that point starts out at the beginning of the ﬁle. The function
deﬁnition looks like this:
(defun lengths-list-file (filename)
"Return list of definitions’ lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
(message "Working on ‘%s’ ... " filename)
(save-excursion
(let ((buffer (find-file-noselect filename))
(lengths-list))
(set-buffer buffer)
(setq buffer-read-only t)
(widen)
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
(setq lengths-list
(cons (count-words-in-defun) lengths-list)))
(kill-buffer buffer)
lengths-list)))
The function is passed one argument, the name of the ﬁle on which it will
work. It has four lines of documentation, but no interactive speciﬁcation.
Since people worry that a computer is broken if they don’t see anything
going on, the ﬁrst line of the body is a message.
The next line contains a save-excursion that returns Emacs’ attention
to the current buﬀer when the function completes. This is useful in case you
embed this function in another function that presumes point is restored to
the original buﬀer.
In the varlist of the let expression, Emacs ﬁnds the ﬁle and binds the
local variable buffer to the buﬀer containing the ﬁle. At the same time,
Emacs creates lengths-list as a local variable.
Next, Emacs switches its attention to the buﬀer.
In the following line, Emacs makes the buﬀer read-only. Ideally, this line
is not necessary. None of the functions for counting words and symbols in a
function deﬁnition should change the buﬀer. Besides, the buﬀer is not going
to be saved, even if it were changed. This line is entirely the consequence
of great, perhaps excessive, caution. The reason for the caution is that this
function and those it calls work on the sources for Emacs and it is very

lengths-list-file in Detail
189
inconvenient if they are inadvertently modiﬁed. It goes without saying that
I did not realize a need for this line until an experiment went awry and
started to modify my Emacs source ﬁles . . .
Next comes a call to widen the buﬀer if it is narrowed. This function
is usually not needed—Emacs creates a fresh buﬀer if none already exists;
but if a buﬀer visiting the ﬁle already exists Emacs returns that one. In
this case, the buﬀer may be narrowed and must be widened. If we wanted
to be fully ‘user-friendly’, we would arrange to save the restriction and the
location of point, but we won’t.
The (goto-char (point-min)) expression moves point to the beginning
of the buﬀer.
Then comes a while loop in which the ‘work’ of the function is carried out.
In the loop, Emacs determines the length of each deﬁnition and constructs
a lengths’ list containing the information.
Emacs kills the buﬀer after working through it. This is to save space
inside of Emacs. My version of Emacs 19 contained over 300 source ﬁles
of interest; Emacs 21 contains over 800 source ﬁles. Another function will
apply lengths-list-file to each of the ﬁles.
Finally, the last expression within the let expression is the lengths-list
variable; its value is returned as the value of the whole function.
You can try this function by installing it in the usual fashion. Then place
your cursor after the following expression and type C-x C-e (eval-last-
sexp).
(lengths-list-file
"/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/debug.el")
(You may need to change the pathname of the ﬁle; the one here worked
with GNU Emacs version 21.0.100. To change the expression, copy it to the
‘*scratch*’ buﬀer and edit it.
(Also, to see the full length of the list, rather than a truncated version, you
may have to evaluate the following:
(custom-set-variables ’(eval-expression-print-length nil))
(See Section 16.2, “Setting Variables with defcustom”, page 214.
Then
evaluate the lengths-list-file expression.)

190
Chapter 14: Counting Words in a defun
The lengths’ list for ‘debug.el’ takes less than a second to produce and
looks like this:
(77 95 85 87 131 89 50 25 44 44 68 35 64 45 17 34 167 457)
(Using my old machine, the version 19 lengths’ list for ‘debug.el’ took
seven seconds to produce and looked like this:
(75 41 80 62 20 45 44 68 45 12 34 235)
(The newer version of ‘debug.el’ contains more defuns than the earlier
one; and my new machine is much faster than the old one.)
Note that the length of the last deﬁnition in the ﬁle is ﬁrst in the list.
14.7 Count Words in defuns in Diﬀerent Files
In the previous section, we created a function that returns a list of the
lengths of each deﬁnition in a ﬁle. Now, we want to deﬁne a function to
return a master list of the lengths of the deﬁnitions in a list of ﬁles.
Working on each of a list of ﬁles is a repetitious act, so we can use either
a while loop or recursion.
The design using a while loop is routine. The argument passed the func-
tion is a list of ﬁles. As we saw earlier (see Section 11.1.1, “Loop Example”,
page 122), you can write a while loop so that the body of the loop is evalu-
ated if such a list contains elements, but to exit the loop if the list is empty.
For this design to work, the body of the loop must contain an expression
that shortens the list each time the body is evaluated, so that eventually the
list is empty. The usual technique is to set the value of the list to the value
of the cdr of the list each time the body is evaluated.
The template looks like this:
(while test-whether-list-is-empty
body...
set-list-to-cdr-of-list)
Also, we remember that a while loop returns nil (the result of evaluat-
ing the true-or-false-test), not the result of any evaluation within its body.
(The evaluations within the body of the loop are done for their side eﬀects.)
However, the expression that sets the lengths’ list is part of the body—and
that is the value that we want returned by the function as a whole. To do
this, we enclose the while loop within a let expression, and arrange that
the last element of the let expression contains the value of the lengths’ list.
(See “Loop Example with an Incrementing Counter”, page 125.)

The append Function
191
These considerations lead us directly to the function itself:
;;; Use while loop.
(defun lengths-list-many-files (list-of-files)
"Return list of lengths of defuns in LIST-OF-FILES."
(let (lengths-list)
;;; true-or-false-test
(while list-of-files
(setq lengths-list
(append
lengths-list
;;; Generate a lengths’ list.
(lengths-list-file
(expand-file-name (car list-of-files)))))
;;; Make ﬁles’ list shorter.
(setq list-of-files (cdr list-of-files)))
;;; Return ﬁnal value of lengths’ list.
lengths-list))
expand-file-name is a built-in function that converts a ﬁle name to the
absolute, long, path name form of the directory in which the function is
called.
Thus, if expand-file-name is called on debug.el when Emacs is visiting
the ‘/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/’ directory,
debug.el
becomes
/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/debug.el
The only other new element of this function deﬁnition is the as yet un-
studied function append, which merits a short section for itself.
14.7.1 The append Function
The append function attaches one list to another. Thus,
(append ’(1 2 3 4) ’(5 6 7 8))
produces the list
(1 2 3 4 5 6 7 8)
This is exactly how we want to attach two lengths’ lists produced by
lengths-list-file to each other. The results contrast with cons,
(cons ’(1 2 3 4) ’(5 6 7 8))

192
Chapter 14: Counting Words in a defun
which constructs a new list in which the ﬁrst argument to cons becomes the
ﬁrst element of the new list:
((1 2 3 4) 5 6 7 8)
14.8 Recursively Count Words in Diﬀerent Files
Besides a while loop, you can work on each of a list of ﬁles with recursion.
A recursive version of lengths-list-many-files is short and simple.
The recursive function has the usual parts: the ‘do-again-test’, the ‘next-
step-expression’, and the recursive call.
The ‘do-again-test’ determines
whether the function should call itself again, which it will do if the list-
of-files contains any remaining elements; the ‘next-step-expression’ resets
the list-of-files to the cdr of itself, so eventually the list will be empty;
and the recursive call calls itself on the shorter list. The complete function
is shorter than this description!
(defun recursive-lengths-list-many-files (list-of-files)
"Return list of lengths of each defun in LIST-OF-FILES."
(if list-of-files
; do-again-test
(append
(lengths-list-file
(expand-file-name (car list-of-files)))
(recursive-lengths-list-many-files
(cdr list-of-files)))))
In a sentence, the function returns the lengths’ list for the ﬁrst of the list-
of-files appended to the result of calling itself on the rest of the list-
of-files.
Here is a test of recursive-lengths-list-many-files, along with the
results of running lengths-list-file on each of the ﬁles individually.
Install recursive-lengths-list-many-files and lengths-list-file,
if necessary, and then evaluate the following expressions. You may need to
change the ﬁles’ pathnames; those here work when this Info ﬁle and the
Emacs sources are located in their customary places. To change the expres-
sions, copy them to the ‘*scratch*’ buﬀer, edit them, and then evaluate
them.
The results are shown after the ‘⇒’. (These results are for ﬁles from
Emacs Version 21.0.100; ﬁles from other versions of Emacs may produce
diﬀerent results.)
(cd "/usr/local/share/emacs/21.0.100/")
(lengths-list-file "./lisp/macros.el")
⇒(273 263 456 90)
(lengths-list-file "./lisp/mail/mailalias.el")
⇒(38 32 26 77 174 180 321 198 324)

Sorting Lists
193
(lengths-list-file "./lisp/makesum.el")
⇒(85 181)
(recursive-lengths-list-many-files
’("./lisp/macros.el"
"./lisp/mail/mailalias.el"
"./lisp/makesum.el"))
⇒(273 263 456 90 38 32 26 77 174 180 321 198 324 85 181)
The recursive-lengths-list-many-files function produces the out-
put we want.
The next step is to prepare the data in the list for display in a graph.
14.9 Prepare the Data for Display in a Graph
The recursive-lengths-list-many-files function returns a list of
numbers. Each number records the length of a function deﬁnition. What
we need to do now is transform this data into a list of numbers suitable for
generating a graph. The new list will tell how many functions deﬁnitions
contain less than 10 words and symbols, how many contain between 10 and
19 words and symbols, how many contain between 20 and 29 words and
symbols, and so on.
In brief, we need to go through the lengths’ list produced by the
recursive-lengths-list-many-files function and count the number of
defuns within each range of lengths, and produce a list of those numbers.
Based on what we have done before, we can readily foresee that it should
not be too hard to write a function that ‘cdrs’ down the lengths’ list, looks
at each element, determines which length range it is in, and increments a
counter for that range.
However, before beginning to write such a function, we should consider
the advantages of sorting the lengths’ list ﬁrst, so the numbers are ordered
from smallest to largest.
First, sorting will make it easier to count the
numbers in each range, since two adjacent numbers will either be in the
same length range or in adjacent ranges. Second, by inspecting a sorted list,
we can discover the highest and lowest number, and thereby determine the
largest and smallest length range that we will need.
14.9.1 Sorting Lists
Emacs contains a function to sort lists, called (as you might guess) sort.
The sort function takes two arguments, the list to be sorted, and a predicate
that determines whether the ﬁrst of two list elements is “less” than the
second.
As we saw earlier (see Section 1.8.4, “Using the Wrong Type Object as
an Argument”, page 14), a predicate is a function that determines whether

194
Chapter 14: Counting Words in a defun
some property is true or false. The sort function will reorder a list accord-
ing to whatever property the predicate uses; this means that sort can be
used to sort non-numeric lists by non-numeric criteria—it can, for example,
alphabetize a list.
The < function is used when sorting a numeric list. For example,
(sort ’(4 8 21 17 33 7 21 7) ’<)
produces this:
(4 7 7 8 17 21 21 33)
(Note that in this example, both the arguments are quoted so that the
symbols are not evaluated before being passed to sort as arguments.)
Sorting the list returned by the recursive-lengths-list-many-files
function is straightforward; it uses the < function:
(sort
(recursive-lengths-list-many-files
’("../lisp/macros.el"
"../lisp/mailalias.el"
"../lisp/makesum.el"))
’<
which produces:
(85 86 116 122 154 176 179 265)
(Note that in this example, the ﬁrst argument to sort is not quoted, since
the expression must be evaluated so as to produce the list that is passed to
sort.)
14.9.2 Making a List of Files
The recursive-lengths-list-many-files function requires a list of
ﬁles as its argument. For our test examples, we constructed such a list by
hand; but the Emacs Lisp source directory is too large for us to do for that.
Instead, we will write a function to do the job for us. In this function, we
will use both a while loop and a recursive call.
We did not have to write a function like this for older versions of GNU
Emacs, since they placed all the ‘.el’ ﬁles in one directory. Instead, we were
able to use the directory-files function, which lists the names of ﬁles that
match a speciﬁed pattern within a single directory.
However, recent versions of Emacs place Emacs Lisp ﬁles in sub-
directories of the top level ‘lisp’ directory.
This re-arrangement eases
navigation.
For example, all the mail related ﬁles are in a ‘lisp’
sub-directory called ‘mail’. But at the same time, this arrangement forces
us to create a ﬁle listing function that descends into the sub-directories.
We can create this function, called files-in-below-directory, using
familiar functions such as car, nthcdr, and substring in conjunction with
an existing function called directory-files-and-attributes. This latter

Making a List of Files
195
function not only lists all the ﬁlenames in a directory, including the names
of sub-directories, but also their attributes.
To restate our goal: to create a function that will enable us to feed
ﬁlenames to recursive-lengths-list-many-files as a list that looks like
this (but with more elements):
("../lisp/macros.el"
"../lisp/mail/rmail.el"
"../lisp/makesum.el")
The directory-files-and-attributes function returns a list of lists.
Each of the lists within the main list consists of 13 elements.
The ﬁrst
element is a string that contains the name of the ﬁle – which, in GNU/Linux,
may be a ‘directory ﬁle’, that is to say, a ﬁle with the special attributes of
a directory. The second element of the list is t for a directory, a string for
symbolic link (the string is the name linked to), or nil.
For example, the ﬁrst ‘.el’ ﬁle in the ‘lisp/’ directory is ‘abbrev.el’.
Its name is ‘/usr/local/share/emacs/21.0.100/lisp/abbrev.el’ and it
is not a directory or a symbolic link.
This is how directory-files-and-attributes lists that ﬁle and its
attributes:
("/usr/local/share/emacs/21.0.100/lisp/abbrev.el"
nil
1
1000
100
(15019 32380)
(14883 48041)
(15214 49336)
11583
"-rw-rw-r--"
t
341385
776)
On the other hand, ‘mail/’ is a directory within the ‘lisp/’ directory.
The beginning of its listing looks like this:
("/usr/local/share/emacs/21.0.100/lisp/mail"
t
...
)
(Look at the documentation of file-attributes to learn about the dif-
ferent attributes. Bear in mind that the file-attributes function does not
list the ﬁlename, so its ﬁrst element is directory-files-and-attributes’s
second element.)

196
Chapter 14: Counting Words in a defun
We will want our new function, files-in-below-directory, to list the
‘.el’ ﬁles in the directory it is told to check, and in any directories below
that directory.
This gives us a hint on how to construct files-in-below-directory:
within a directory, the function should add ‘.el’ ﬁlenames to a list; and if,
within a directory, the function comes upon a sub-directory, it should go
into that sub-directory and repeat its actions.
However, we should note that every directory contains a name that refers
to itself, called ‘.’, (“dot”) and a name that refers to its parent directory,
called ‘..’ (“double dot”). (In ‘/’, the root directory, ‘..’ refers to itself,
since ‘/’ has no parent.)
Clearly, we do not want our files-in-below-
directory function to enter those directories, since they always lead us,
directly or indirectly, to the current directory.
Consequently, our files-in-below-directory function must do several
tasks:
• Check to see whether it is looking at a ﬁlename that ends in ‘.el’; and
if so, add its name to a list.
• Check to see whether it is looking at a ﬁlename that is the name of a
directory; and if so,
−Check to see whether it is looking at ‘.’ or ‘..’; and if so skip it.
−Or else, go into that directory and repeat the process.
Let’s write a function deﬁnition to do these tasks. We will use a while
loop to move from one ﬁlename to another within a directory, checking what
needs to be done; and we will use a recursive call to repeat the actions on
each sub-directory. The recursive pattern is ‘accumulate’ (see “Recursive
Pattern: accumulate”, page 142), using append as the combiner.
Here is the function:
(defun files-in-below-directory (directory)
"List the .el files in DIRECTORY and in its sub-directories."
;; Although the function will be used non-interactively,
;; it will be easier to test if we make it interactive.
;; The directory will have a name such as
;;
"/usr/local/share/emacs/21.0.100/lisp/"
(interactive "DDirectory name: ")
(let (el-files-list
(current-directory-list
(directory-files-and-attributes directory t)))
;; while we are in the current directory
(while current-directory-list

Counting function deﬁnitions
197
(cond
;; check to see whether filename ends in ‘.el’
;; and if so, append its name to a list.
((equal ".el" (substring (car (car current-directory-list)) -3))
(setq el-files-list
(cons (car (car current-directory-list)) el-files-list)))
;; check whether filename is that of a directory
((eq t (car (cdr (car current-directory-list))))
;; decide whether to skip or recurse
(if
(equal (or "." "..")
(substring (car (car current-directory-list)) -1))
;; then do nothing if filename is that of
;;
current directory or parent
()
;; else descend into the directory and repeat the process
(setq el-files-list
(append
(files-in-below-directory
(car (car current-directory-list)))
el-files-list)))))
;; move to the next filename in the list; this also
;; shortens the list so the while loop eventually comes to an end
(setq current-directory-list (cdr current-directory-list)))
;; return the filenames
el-files-list))
The files-in-below-directory directory-files function takes one
argument, the name of a directory.
Thus, on my system,
(length
(files-in-below-directory "/usr/local/share/emacs/21.0.100/lisp/"))
tells me that my version 21.0.100 Lisp sources directory contains 754 ‘.el’
ﬁles.
files-in-below-directory returns a list in reverse alphabetical order.
An expression to sort the list in alphabetical order looks like this:
(sort
(files-in-below-directory "/usr/local/share/emacs/21.0.100/lisp/")
’string-lessp)
14.9.3 Counting function deﬁnitions
Our immediate goal is to generate a list that tells us how many function
deﬁnitions contain fewer than 10 words and symbols, how many contain

198
Chapter 14: Counting Words in a defun
between 10 and 19 words and symbols, how many contain between 20 and
29 words and symbols, and so on.
With a sorted list of numbers, this is easy: count how many elements
of the list are smaller than 10, then, after moving past the numbers just
counted, count how many are smaller than 20, then, after moving past the
numbers just counted, count how many are smaller than 30, and so on. Each
of the numbers, 10, 20, 30, 40, and the like, is one larger than the top of
that range. We can call the list of such numbers the top-of-ranges list.
If we wished, we could generate this list automatically, but it is simpler
to write a list manually. Here it is:
(defvar top-of-ranges
’(10
20
30
40
50
60
70
80
90 100
110 120 130 140 150
160 170 180 190 200
210 220 230 240 250
260 270 280 290 300)
"List specifying ranges for ‘defuns-per-range’.")
To change the ranges, we edit this list.
Next, we need to write the function that creates the list of the number of
deﬁnitions within each range. Clearly, this function must take the sorted-
lengths and the top-of-ranges lists as arguments.
The defuns-per-range function must do two things again and again: it
must count the number of deﬁnitions within a range speciﬁed by the current
top-of-range value; and it must shift to the next higher value in the top-
of-ranges list after counting the number of deﬁnitions in the current range.
Since each of these actions is repetitive, we can use while loops for the job.
One loop counts the number of deﬁnitions in the range deﬁned by the current
top-of-range value, and the other loop selects each of the top-of-range values
in turn.
Several entries of the sorted-lengths list are counted for each range;
this means that the loop for the sorted-lengths list will be inside the loop
for the top-of-ranges list, like a small gear inside a big gear.
The inner loop counts the number of deﬁnitions within the range. It is a
simple counting loop of the type we have seen before. (See Section 11.1.3, “A
loop with an incrementing counter”, page 124.) The true-or-false test of the
loop tests whether the value from the sorted-lengths list is smaller than
the current value of the top of the range. If it is, the function increments
the counter and tests the next value from the sorted-lengths list.

Counting function deﬁnitions
199
The inner loop looks like this:
(while length-element-smaller-than-top-of-range
(setq number-within-range (1+ number-within-range))
(setq sorted-lengths (cdr sorted-lengths)))
The outer loop must start with the lowest value of the top-of-ranges
list, and then be set to each of the succeeding higher values in turn. This
can be done with a loop like this:
(while top-of-ranges
body-of-loop...
(setq top-of-ranges (cdr top-of-ranges)))
Put together, the two loops look like this:
(while top-of-ranges
;; Count the number of elements within the current range.
(while length-element-smaller-than-top-of-range
(setq number-within-range (1+ number-within-range))
(setq sorted-lengths (cdr sorted-lengths)))
;; Move to next range.
(setq top-of-ranges (cdr top-of-ranges)))
In addition, in each circuit of the outer loop, Emacs should record the
number of deﬁnitions within that range (the value of number-within-range)
in a list.
We can use cons for this purpose.
(See Section 7.2, “cons”,
page 83.)
The cons function works ﬁne, except that the list it constructs will con-
tain the number of deﬁnitions for the highest range at its beginning and the
number of deﬁnitions for the lowest range at its end. This is because cons
attaches new elements of the list to the beginning of the list, and since the
two loops are working their way through the lengths’ list from the lower end
ﬁrst, the defuns-per-range-list will end up largest number ﬁrst. But we
will want to print our graph with smallest values ﬁrst and the larger later.
The solution is to reverse the order of the defuns-per-range-list. We can
do this using the nreverse function, which reverses the order of a list.
For example,
(nreverse ’(1 2 3 4))
produces:
(4 3 2 1)
Note that the nreverse function is “destructive”—that is, it changes
the list to which it is applied; this contrasts with the car and cdr functions,
which are non-destructive. In this case, we do not want the original defuns-
per-range-list, so it does not matter that it is destroyed. (The reverse
function provides a reversed copy of a list, leaving the original list as is.)

200
Chapter 14: Counting Words in a defun
Put all together, the defuns-per-range looks like this:
(defun defuns-per-range (sorted-lengths top-of-ranges)
"SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
(let ((top-of-range (car top-of-ranges))
(number-within-range 0)
defuns-per-range-list)
;; Outer loop.
(while top-of-ranges
;; Inner loop.
(while (and
;; Need number for numeric test.
(car sorted-lengths)
(< (car sorted-lengths) top-of-range))
;; Count number of deﬁnitions within current range.
(setq number-within-range (1+ number-within-range))
(setq sorted-lengths (cdr sorted-lengths)))
;; Exit inner loop but remain within outer loop.
(setq defuns-per-range-list
(cons number-within-range defuns-per-range-list))
(setq number-within-range 0)
; Reset count to zero.
;; Move to next range.
(setq top-of-ranges (cdr top-of-ranges))
;; Specify next top of range value.
(setq top-of-range (car top-of-ranges)))
;; Exit outer loop and count the number of defuns larger than
;;
the largest top-of-range value.
(setq defuns-per-range-list
(cons
(length sorted-lengths)
defuns-per-range-list))
;; Return a list of the number of deﬁnitions within each range,
;;
smallest to largest.
(nreverse defuns-per-range-list)))

Counting function deﬁnitions
201
The function is straightforward except for one subtle feature. The true-or-
false test of the inner loop looks like this:
(and (car sorted-lengths)
(< (car sorted-lengths) top-of-range))
instead of like this:
(< (car sorted-lengths) top-of-range)
The purpose of the test is to determine whether the ﬁrst item in the
sorted-lengths list is less than the value of the top of the range.
The simple version of the test works ﬁne unless the sorted-lengths
list has a nil value. In that case, the (car sorted-lengths) expression
function returns nil.
The < function cannot compare a number to nil,
which is an empty list, so Emacs signals an error and stops the function
from attempting to continue to execute.
The sorted-lengths list always becomes nil when the counter reaches
the end of the list. This means that any attempt to use the defuns-per-
range function with the simple version of the test will fail.
We solve the problem by using the (car sorted-lengths) expression in
conjunction with the and expression. The (car sorted-lengths) expres-
sion returns a non-nil value so long as the list has at least one number within
it, but returns nil if the list is empty. The and expression ﬁrst evaluates
the (car sorted-lengths) expression, and if it is nil, returns false without
evaluating the < expression. But if the (car sorted-lengths) expression
returns a non-nil value, the and expression evaluates the < expression, and
returns that value as the value of the and expression.
This way, we avoid an error. See Section 12.4, “forward-paragraph: a
Goldmine of Functions”, page 155, for more information about and.
Here is a short test of the defuns-per-range function. First, evaluate
the expression that binds (a shortened) top-of-ranges list to the list of
values, then evaluate the expression for binding the sorted-lengths list,
and then evaluate the defuns-per-range function.
;; (Shorter list than we will use later.)
(setq top-of-ranges
’(110 120 130 140 150
160 170 180 190 200))
(setq sorted-lengths
’(85 86 110 116 122 129 154 176 179 200 265 300 300))
(defuns-per-range sorted-lengths top-of-ranges)

202
Chapter 14: Counting Words in a defun
The list returned looks like this:
(2 2 2 0 0 1 0 2 0 0 4)
Indeed, there are two elements of the sorted-lengths list smaller than 110,
two elements between 110 and 119, two elements between 120 and 129, and
so on. There are four elements with a value of 200 or larger.

Readying a Graph
203
15 Readying a Graph
Our goal is to construct a graph showing the numbers of function deﬁni-
tions of various lengths in the Emacs lisp sources.
As a practical matter, if you were creating a graph, you would probably
use a program such as gnuplot to do the job. (gnuplot is nicely integrated
into GNU Emacs.) In this case, however, we create one from scratch, and
in the process we will re-acquaint ourselves with some of what we learned
before and learn more.
In this chapter, we will ﬁrst write a simple graph printing function. This
ﬁrst deﬁnition will be a prototype, a rapidly written function that enables
us to reconnoiter this unknown graph-making territory. We will discover
dragons, or ﬁnd that they are myth. After scouting the terrain, we will feel
more conﬁdent and enhance the function to label the axes automatically.
Since Emacs is designed to be ﬂexible and work with all kinds of terminals,
including character-only terminals, the graph will need to be made from one
of the ‘typewriter’ symbols. An asterisk will do; as we enhance the graph-
printing function, we can make the choice of symbol a user option.
We can call this function graph-body-print; it will take a numbers-list
as its only argument. At this stage, we will not label the graph, but only
print its body.
The graph-body-print function inserts a vertical column of asterisks for
each element in the numbers-list. The height of each line is determined by
the value of that element of the numbers-list.
Inserting columns is a repetitive act; that means that this function can
be written either with a while loop or recursively.
Our ﬁrst challenge is to discover how to print a column of asterisks.
Usually, in Emacs, we print characters onto a screen horizontally, line by
line, by typing. We have two routes we can follow: write our own column-
insertion function or discover whether one exists in Emacs.
To see whether there is one in Emacs, we can use the M-x apropos com-
mand. This command is like the C-h a (command-apropos) command, ex-
cept that the latter ﬁnds only those functions that are commands.
The
M-x apropos command lists all symbols that match a regular expression,
including functions that are not interactive.
What we want to look for is some command that prints or inserts columns.
Very likely, the name of the function will contain either the word ‘print’ or
the word ‘insert’ or the word ‘column’. Therefore, we can simply type M-x
apropos RET print\|insert\|column RET and look at the result. On my
system, this command takes quite some time, and then produces a list of
79 functions and variables. Scanning down the list, the only function that
looks as if it might do the job is insert-rectangle.

204
Chapter 15: Readying a Graph
Indeed, this is the function we want; its documentation says:
insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE’s first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
We can run a quick test, to make sure it does what we expect of it.
Here is the result of placing the cursor after the insert-rectangle ex-
pression and typing C-u C-x C-e (eval-last-sexp). The function inserts
the strings ‘"first"’, ‘"second"’, and ‘"third"’ at and below point. Also
the function returns nil.
(insert-rectangle ’("first" "second" "third"))first
second
third
nil
Of course, we won’t be inserting the text of the insert-rectangle expres-
sion itself into the buﬀer in which we are making the graph, but will call
the function from our program. We shall, however, have to make sure that
point is in the buﬀer at the place where the insert-rectangle function will
insert its column of strings.
If you are reading this in Info, you can see how this works by switching
to another buﬀer, such as the ‘*scratch*’ buﬀer, placing point somewhere
in the buﬀer, typing M-:, typing the insert-rectangle expression into the
minibuﬀer at the prompt, and then typing ⟨RET⟩.
This causes Emacs to
evaluate the expression in the minibuﬀer, but to use as the value of point
the position of point in the ‘*scratch*’ buﬀer. (M-: is the keybinding for
eval-expression.)
We ﬁnd when we do this that point ends up at the end of the last inserted
line—that is to say, this function moves point as a side-eﬀect. If we were to
repeat the command, with point at this position, the next insertion would
be below and to the right of the previous insertion. We don’t want this! If
we are going to make a bar graph, the columns need to be beside each other.
So we discover that each cycle of the column-inserting while loop must
reposition point to the place we want it, and that place will be at the top,
not the bottom, of the column. Moreover, we remember that when we print
a graph, we do not expect all the columns to be the same height. This means
that the top of each column may be at a diﬀerent height from the previous
one. We cannot simply reposition point to the same line each time, but
moved over to the right—or perhaps we can. . .
We are planning to make the columns of the bar graph out of asterisks.
The number of asterisks in the column is the number speciﬁed by the current
element of the numbers-list. We need to construct a list of asterisks of the
right length for each call to insert-rectangle. If this list consists solely of
the requisite number of asterisks, then we will have position point the right

Readying a Graph
205
number of lines above the base for the graph to print correctly. This could
be diﬃcult.
Alternatively, if we can ﬁgure out some way to pass insert-rectangle
a list of the same length each time, then we can place point on the same line
each time, but move it over one column to the right for each new column.
If we do this, however, some of the entries in the list passed to insert-
rectangle must be blanks rather than asterisks. For example, if the max-
imum height of the graph is 5, but the height of the column is 3, then
insert-rectangle requires an argument that looks like this:
(" " " " "*" "*" "*")
This last proposal is not so diﬃcult, so long as we can determine the
column height.
There are two ways for us to specify the column height:
we can arbitrarily state what it will be, which would work ﬁne for graphs
of that height; or we can search through the list of numbers and use the
maximum height of the list as the maximum height of the graph. If the
latter operation were diﬃcult, then the former procedure would be easiest,
but there is a function built into Emacs that determines the maximum of
its arguments. We can use that function. The function is called max and it
returns the largest of all its arguments, which must be numbers. Thus, for
example,
(max
3 4 6 5 7 3)
returns 7. (A corresponding function called min returns the smallest of all
its arguments.)
However, we cannot simply call max on the numbers-list; the max func-
tion expects numbers as its argument, not a list of numbers.
Thus, the
following expression,
(max
’(3 4 6 5 7 3))
produces the following error message;
Wrong type of argument:
number-or-marker-p, (3 4 6 5 7 3)
We need a function that passes a list of arguments to a function. This
function is apply. This function ‘applies’ its ﬁrst argument (a function) to
its remaining arguments, the last of which may be a list.
For example,
(apply ’max 3 4 7 3 ’(4 8 5))
returns 8.
(Incidentally, I don’t know how you would learn of this function without
a book such as this. It is possible to discover other functions, like search-
forward or insert-rectangle, by guessing at a part of their names and
then using apropos.
Even though its base in metaphor is clear—‘apply’
its ﬁrst argument to the rest—I doubt a novice would come up with that
particular word when using apropos or other aid. Of course, I could be
wrong; after all, the function was ﬁrst named by someone who had to invent
it.)

206
Chapter 15: Readying a Graph
The second and subsequent arguments to apply are optional, so we can
use apply to call a function and pass the elements of a list to it, like this,
which also returns 8:
(apply ’max ’(4 8 5))
This latter way is how we will use apply.
The recursive-lengths-
list-many-files function returns a numbers’ list to which we can apply
max (we could also apply max to the sorted numbers’ list; it does not matter
whether the list is sorted or not.)
Hence, the operation for ﬁnding the maximum height of the graph is this:
(setq max-graph-height (apply ’max numbers-list))
Now we can return to the question of how to create a list of strings for a
column of the graph. Told the maximum height of the graph and the number
of asterisks that should appear in the column, the function should return a
list of strings for the insert-rectangle command to insert.
Each column is made up of asterisks or blanks. Since the function is
passed the value of the height of the column and the number of asterisks in
the column, the number of blanks can be found by subtracting the number
of asterisks from the height of the column. Given the number of blanks and
the number of asterisks, two while loops can be used to construct the list:
;;; First version.
(defun column-of-graph (max-graph-height actual-height)
"Return list of strings that is one column of a graph."
(let ((insert-list nil)
(number-of-top-blanks
(- max-graph-height actual-height)))
;; Fill in asterisks.
(while (> actual-height 0)
(setq insert-list (cons "*" insert-list))
(setq actual-height (1- actual-height)))
;; Fill in blanks.
(while (> number-of-top-blanks 0)
(setq insert-list (cons " " insert-list))
(setq number-of-top-blanks
(1- number-of-top-blanks)))
;; Return whole list.
insert-list))
If you install this function and then evaluate the following expression you
will see that it returns the list as desired:
(column-of-graph 5 3)

Readying a Graph
207
returns
(" " " " "*" "*" "*")
As written, column-of-graph contains a major ﬂaw: the symbols used
for the blank and for the marked entries in the column are ‘hard-coded’ as
a space and asterisk. This is ﬁne for a prototype, but you, or another user,
may wish to use other symbols. For example, in testing the graph function,
you many want to use a period in place of the space, to make sure the point
is being repositioned properly each time the insert-rectangle function is
called; or you might want to substitute a ‘+’ sign or other symbol for the
asterisk. You might even want to make a graph-column that is more than
one display column wide. The program should be more ﬂexible. The way to
do that is to replace the blank and the asterisk with two variables that we can
call graph-blank and graph-symbol and deﬁne those variables separately.
Also, the documentation is not well written. These considerations lead
us to the second version of the function:
(defvar graph-symbol "*"
"String used as symbol in graph, usually an asterisk.")
(defvar graph-blank " "
"String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
(For an explanation of defvar, see Section 8.4, “Initializing a Variable with
defvar”, page 100.)
;;; Second version.
(defun column-of-graph (max-graph-height actual-height)
"Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
(let ((insert-list nil)
(number-of-top-blanks
(- max-graph-height actual-height)))
;; Fill in graph-symbols.
(while (> actual-height 0)
(setq insert-list (cons graph-symbol insert-list))
(setq actual-height (1- actual-height)))

208
Chapter 15: Readying a Graph
;; Fill in graph-blanks.
(while (> number-of-top-blanks 0)
(setq insert-list (cons graph-blank insert-list))
(setq number-of-top-blanks
(1- number-of-top-blanks)))
;; Return whole list.
insert-list))
If we wished, we could rewrite column-of-graph a third time to provide
optionally for a line graph as well as for a bar graph. This would not be
hard to do. One way to think of a line graph is that it is no more than a
bar graph in which the part of each bar that is below the top is blank. To
construct a column for a line graph, the function ﬁrst constructs a list of
blanks that is one shorter than the value, then it uses cons to attach a graph
symbol to the list; then it uses cons again to attach the ‘top blanks’ to the
list.
It is easy to see how to write such a function, but since we don’t need it,
we will not do it. But the job could be done, and if it were done, it would
be done with column-of-graph. Even more important, it is worth noting
that few changes would have to be made anywhere else. The enhancement,
if we ever wish to make it, is simple.
Now, ﬁnally, we come to our ﬁrst actual graph printing function. This
prints the body of a graph, not the labels for the vertical and horizontal
axes, so we can call this graph-body-print.
15.1 The graph-body-print Function
After our preparation in the preceding section, the graph-body-print
function is straightforward. The function will print column after column of
asterisks and blanks, using the elements of a numbers’ list to specify the
number of asterisks in each column. This is a repetitive act, which means
we can use a decrementing while loop or recursive function for the job. In
this section, we will write the deﬁnition using a while loop.
The column-of-graph function requires the height of the graph as an
argument, so we should determine and record that as a local variable.
This leads us to the following template for the while loop version of this
function:
(defun graph-body-print (numbers-list)
"documentation..."
(let ((height
...
...))
(while numbers-list
insert-columns-and-reposition-point
(setq numbers-list (cdr numbers-list)))))

The graph-body-print Function
209
We need to ﬁll in the slots of the template.
Clearly, we can use the (apply ’max numbers-list) expression to deter-
mine the height of the graph.
The while loop will cycle through the numbers-list one element at a
time. As it is shortened by the (setq numbers-list (cdr numbers-list))
expression, the car of each instance of the list is the value of the argument
for column-of-graph.
At each cycle of the while loop, the insert-rectangle function inserts
the list returned by column-of-graph. Since the insert-rectangle func-
tion moves point to the lower right of the inserted rectangle, we need to save
the location of point at the time the rectangle is inserted, move back to that
position after the rectangle is inserted, and then move horizontally to the
next place from which insert-rectangle is called.
If the inserted columns are one character wide, as they will be if sin-
gle blanks and asterisks are used, the repositioning command is simply
(forward-char 1); however, the width of a column may be greater than one.
This means that the repositioning command should be written (forward-
char symbol-width). The symbol-width itself is the length of a graph-
blank and can be found using the expression (length graph-blank). The
best place to bind the symbol-width variable to the value of the width of
graph column is in the varlist of the let expression.
These considerations lead to the following function deﬁnition:
(defun graph-body-print (numbers-list)
"Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
(let ((height (apply ’max numbers-list))
(symbol-width (length graph-blank))
from-position)
(while numbers-list
(setq from-position (point))
(insert-rectangle
(column-of-graph height (car numbers-list)))
(goto-char from-position)
(forward-char symbol-width)
;; Draw graph column by column.
(sit-for 0)
(setq numbers-list (cdr numbers-list)))
;; Place point for X axis labels.
(forward-line height)
(insert "\n")
))

210
Chapter 15: Readying a Graph
The one unexpected expression in this function is the (sit-for 0) expres-
sion in the while loop. This expression makes the graph printing operation
more interesting to watch than it would be otherwise. The expression causes
Emacs to ‘sit’ or do nothing for a zero length of time and then redraw the
screen. Placed here, it causes Emacs to redraw the screen column by column.
Without it, Emacs would not redraw the screen until the function exits.
We can test graph-body-print with a short list of numbers.
1. Install graph-symbol, graph-blank, column-of-graph, which are in
Chapter 15, “Readying a Graph”, page 203, and graph-body-print.
2. Copy the following expression:
(graph-body-print ’(1 2 3 4 6 4 3 5 7 6 5 2 3))
3. Switch to the ‘*scratch*’ buﬀer and place the cursor where you want
the graph to start.
4. Type M-: (eval-expression).
5. Yank the graph-body-print expression into the minibuﬀer with C-y
(yank).
6. Press ⟨RET⟩to evaluate the graph-body-print expression.
Emacs will print a graph like this:
*
*
**
*
****
*** ****
********* *
************
*************
15.2 The recursive-graph-body-print Function
The graph-body-print function may also be written recursively. The
recursive solution is divided into two parts: an outside ‘wrapper’ that uses
a let expression to determine the values of several variables that need only
be found once, such as the maximum height of the graph, and an inside
function that is called recursively to print the graph.

Need for Printed Axes
211
The ‘wrapper’ is uncomplicated:
(defun recursive-graph-body-print (numbers-list)
"Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
(let ((height (apply ’max numbers-list))
(symbol-width (length graph-blank))
from-position)
(recursive-graph-body-print-internal
numbers-list
height
symbol-width)))
The recursive function is a little more diﬃcult. It has four parts: the
‘do-again-test’, the printing code, the recursive call, and the ‘next-step-
expression’. The ‘do-again-test’ is an if expression that determines whether
the numbers-list contains any remaining elements; if it does, the func-
tion prints one column of the graph using the printing code and calls itself
again. The function calls itself again according to the value produced by the
‘next-step-expression’ which causes the call to act on a shorter version of the
numbers-list.
(defun recursive-graph-body-print-internal
(numbers-list height symbol-width)
"Print a bar graph.
Used within recursive-graph-body-print function."
(if numbers-list
(progn
(setq from-position (point))
(insert-rectangle
(column-of-graph height (car numbers-list)))
(goto-char from-position)
(forward-char symbol-width)
(sit-for 0)
; Draw graph column by column.
(recursive-graph-body-print-internal
(cdr numbers-list) height symbol-width))))
After installation, this expression can be tested; here is a sample:
(recursive-graph-body-print ’(3 2 5 6 7 5 3 4 6 4 3 2 1))
Here is what recursive-graph-body-print produces:
*
**
*
****
*
**** ***
* *********
************
*************

212
Chapter 15: Readying a Graph
Either of these two functions, graph-body-print or recursive-graph-
body-print, create the body of a graph.
15.3 Need for Printed Axes
A graph needs printed axes, so you can orient yourself. For a do-once
project, it may be reasonable to draw the axes by hand using Emacs’ Picture
mode; but a graph drawing function may be used more than once.
For this reason, I have written enhancements to the basic print-graph-
body function that automatically print labels for the horizontal and vertical
axes. Since the label printing functions do not contain much new material,
I have placed their description in an appendix. See Appendix C, “A Graph
with Labelled Axes”, page 255.
15.4 Exercise
Write a line graph version of the graph printing functions.

Site-wide Initialization Files
213
16 Your ‘.emacs’ File
“You don’t have to like Emacs to like it” – this seemingly paradoxical
statement is the secret of GNU Emacs. The plain, ‘out of the box’ Emacs is
a generic tool. Most people who use it, customize it to suit themselves.
GNU Emacs is mostly written in Emacs Lisp; this means that by writing
expressions in Emacs Lisp you can change or extend Emacs.
There are those who appreciate Emacs’ default conﬁguration. After all,
Emacs starts you in C mode when you edit a C ﬁle, starts you in Fortran
mode when you edit a Fortran ﬁle, and starts you in Fundamental mode
when you edit an unadorned ﬁle. This all makes sense, if you do not know
who is going to use Emacs. Who knows what a person hopes to do with an
unadorned ﬁle? Fundamental mode is the right default for such a ﬁle, just
as C mode is the right default for editing C code. But when you do know
who is going to use Emacs—you, yourself—then it makes sense to customize
Emacs.
For example, I seldom want Fundamental mode when I edit an otherwise
undistinguished ﬁle; I want Text mode. This is why I customize Emacs: so
it suits me.
You can customize and extend Emacs by writing or adapting a ‘~/.emacs’
ﬁle. This is your personal initialization ﬁle; its contents, written in Emacs
Lisp, tell Emacs what to do.1
A ‘~/.emacs’ ﬁle contains Emacs Lisp code. You can write this code
yourself; or you can use Emacs’ customize feature to write the code for
you. You can combine your own expressions and auto-written Customize
expressions in your ‘.emacs’ ﬁle.
(I myself prefer to write my own expressions, except for those, particularly
fonts, that I ﬁnd easier to manipulate using the customize command. I
combine the two methods.)
Most of this chapter is about writing expressions yourself. It describes
a simple ‘.emacs’ ﬁle; for more information, see section “The Init File” in
The GNU Emacs Manual, and section “The Init File” in The GNU Emacs
Lisp Reference Manual.
16.1 Site-wide Initialization Files
In addition to your personal initialization ﬁle, Emacs automatically loads
various site-wide initialization ﬁles, if they exist. These have the same form
as your ‘.emacs’ ﬁle, but are loaded by everyone.
1 You may also add ‘.el’ to ‘~/.emacs’ and call it a ‘~/.emacs.el’ ﬁle. In the past,
you were forbidden to type the extra keystrokes that the name ‘~/.emacs.el’ requires,
but now you may.
The new format is consistent with the Emacs Lisp ﬁle naming
conventions; the old format saves typing.

214
Chapter 16: Your ‘.emacs’ File
Two site-wide initialization ﬁles, ‘site-load.el’ and ‘site-init.el’,
are loaded into Emacs and then ‘dumped’ if a ‘dumped’ version of Emacs is
created, as is most common. (Dumped copies of Emacs load more quickly.
However, once a ﬁle is loaded and dumped, a change to it does not lead
to a change in Emacs unless you load it yourself or re-dump Emacs. See
section “Building Emacs” in The GNU Emacs Lisp Reference Manual, and
the ‘INSTALL’ ﬁle.)
Three other site-wide initialization ﬁles are loaded automatically each
time you start Emacs, if they exist. These are ‘site-start.el’, which is
loaded before your ‘.emacs’ ﬁle, and ‘default.el’, and the terminal type
ﬁle, which are both loaded after your ‘.emacs’ ﬁle.
Settings and deﬁnitions in your ‘.emacs’ ﬁle will overwrite conﬂicting
settings and deﬁnitions in a ‘site-start.el’ ﬁle, if it exists; but the settings
and deﬁnitions in a ‘default.el’ or terminal type ﬁle will overwrite those in
your ‘.emacs’ ﬁle. (You can prevent interference from a terminal type ﬁle by
setting term-file-prefix to nil. See Section 16.11, “A Simple Extension”,
page 224.)
The ‘INSTALL’ ﬁle that comes in the distribution contains descriptions of
the ‘site-init.el’ and ‘site-load.el’ ﬁles.
The ‘loadup.el’, ‘startup.el’, and ‘loaddefs.el’ ﬁles control loading.
These ﬁles are in the ‘lisp’ directory of the Emacs distribution and are
worth perusing.
The ‘loaddefs.el’ ﬁle contains a good many suggestions as to what to
put into your own ‘.emacs’ ﬁle, or into a site-wide initialization ﬁle.
16.2 Specifying Variables using defcustom
You can specify variables using defcustom so that you and others can
then can use Emacs’ customize feature to set their values. (You cannot use
customize to write function deﬁnitions; but you can write defuns in your
‘.emacs’ ﬁle. Indeed, you can write any Lisp expression in your ‘.emacs’
ﬁle.)
The customize feature depends on the defcustom special form.
Al-
though you can use defvar or setq for variables that users set, the
defcustom special form is designed for the job.
You can use your knowledge of defvar for writing the ﬁrst three argu-
ments for defcustom. The ﬁrst argument to defcustom is the name of the
variable. The second argument is the variable’s initial value, if any; and this
value is set only if the value has not already been set. The third argument
is the documentation.
The fourth and subsequent arguments to defcustom specify types and
options; these are not featured in defvar. (These arguments are optional.)
Each of these arguments consists of a keyword followed by a value. Each
keyword starts with the character :.

Specifying Variables using defcustom
215
For example, the customizable user option variable text-mode-hook
looks like this:
(defcustom text-mode-hook nil
"Normal hook run when entering Text mode and many related modes."
:type ’hook
:options ’(turn-on-auto-fill flyspell-mode)
:group ’data)
The name of the variable is text-mode-hook; it has no default value; and
its documentation string tells you what it does.
The :type keyword tells Emacs what kind of data text-mode-hook
should be set to and how to display the value in a Customization buﬀer.
The :options keyword speciﬁes a suggested list of values for the vari-
able. Currently, you can use :options only for a hook. The list is only a
suggestion; it is not exclusive; a person who sets the variable may set it to
other values; the list shown following the :options keyword is intended to
oﬀer convenient choices to a user.
Finally, the :group keyword tells the Emacs Customization command in
which group the variable is located. This tells where to ﬁnd it.
For more information, see section “Writing Customization Deﬁnitions”
in The GNU Emacs Lisp Reference Manual.
Consider text-mode-hook as an example.
There are two ways to customize this variable.
You can use the cus-
tomization command or write the appropriate expressions yourself.
Using the customization command, you can type:
M-x customize
and ﬁnd that the group for editing ﬁles of data is called ‘data’. Enter that
group. Text Mode Hook is the ﬁrst member. You can click on its various
options to set the values. After you click on the button to
Save for Future Sessions
Emacs will write an expression into your ‘.emacs’ ﬁle. It will look like this:
(custom-set-variables
;; custom-set-variables was added by Custom --
;;
don’t edit or cut/paste it!
;; Your init file should contain only one such instance.
’(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
(The text-mode-hook-identify function tells toggle-text-mode-auto-
fill which buﬀers are in Text mode.)
In spite of the warning, you certainly may edit, cut, and paste the ex-
pression! I do all time. The purpose of the warning is to scare those who
do not know what they are doing, so they do not inadvertently generate an
error.

216
Chapter 16: Your ‘.emacs’ File
The custom-set-variables works somewhat diﬀerently than a setq.
While I have never learned the diﬀerences, I do modify the custom-set-
variables expressions in my ‘.emacs’ ﬁle by hand: I make the changes
in what appears to me to be a reasonable manner and have not had any
problems. Others prefer to use the Customization command and let Emacs
do the work for them.
Another custom-set-... function is custom-set-faces. This function
sets the various font faces. Over time, I have set a considerable number
of faces. Some of the time, I re-set them using customize; other times, I
simply edit the custom-set-faces expression in my ‘.emacs’ ﬁle itself.
The second way to customize your text-mode-hook is to set it yourself
in your ‘.emacs’ ﬁle using code that has nothing to do with the custom-
set-... functions.
When you do this, and later use customize, you will see a message that
says
this option has been changed outside the customize buffer.
This message is only a warning. If you click on the button to
Save for Future Sessions
Emacs will write a custom-set-... expression near the end of your ‘.emacs’
ﬁle that will be evaluated after your hand-written expression. It will, there-
fore, overrule your hand-written expression. No harm will be done. When
you do this, however, be careful to remember which expression is active; if
you forget, you may confuse yourself.
So long as you remember where the values are set, you will have no
trouble. In any event, the values are always set in your initialization ﬁle,
which is usually called ‘.emacs’.
I myself use customize for hardly anything. Mostly, I write expressions
myself.
16.3 Beginning a ‘.emacs’ File
When you start Emacs, it loads your ‘.emacs’ ﬁle unless you tell it not
to by specifying ‘-q’ on the command line. (The emacs -q command gives
you a plain, out-of-the-box Emacs.)
A ‘.emacs’ ﬁle contains Lisp expressions. Often, these are no more than
expressions to set values; sometimes they are function deﬁnitions.
See section “The Init File ‘~/.emacs’” in The GNU Emacs Manual, for
a short description of initialization ﬁles.
This chapter goes over some of the same ground, but is a walk among
extracts from a complete, long-used ‘.emacs’ ﬁle—my own.
The ﬁrst part of the ﬁle consists of comments: reminders to myself. By
now, of course, I remember these things, but when I started, I did not.

Text and Auto Fill Mode
217
;;;; Bob’s .emacs file
; Robert J. Chassell
; 26 September 1985
Look at that date! I started this ﬁle a long time ago. I have been adding to
it ever since.
; Each section in this file is introduced by a
; line beginning with four semicolons; and each
; entry is introduced by a line beginning with
; three semicolons.
This describes the usual conventions for comments in Emacs Lisp. Every-
thing on a line that follows a semicolon is a comment.
Two, three, and
four semicolons are used as section and subsection markers. (See section
“Comments” in The GNU Emacs Lisp Reference Manual, for more about
comments.)
;;;; The Help Key
; Control-h is the help key;
; after typing control-h, type a letter to
; indicate the subject about which you want help.
; For an explanation of the help facility,
; type control-h two times in a row.
Just remember: type C-h two times for help.
; To find out about any mode, type control-h m
; while in that mode.
For example, to find out
; about mail mode, enter mail mode and then type
; control-h m.
‘Mode help’, as I call this, is very helpful. Usually, it tells you all you need
to know.
Of course, you don’t need to include comments like these in your ‘.emacs’
ﬁle. I included them in mine because I kept forgetting about Mode help or
the conventions for comments—but I was able to remember to look here to
remind myself.
16.4 Text and Auto Fill Mode
Now we come to the part that ‘turns on’ Text mode and Auto Fill mode.
;;; Text mode and Auto Fill mode
; The next three lines put Emacs into Text mode
; and Auto Fill mode, and are for writers who
; want to start writing prose rather than code.
(setq default-major-mode ’text-mode)
(add-hook ’text-mode-hook ’text-mode-hook-identify)
(add-hook ’text-mode-hook ’turn-on-auto-fill)

218
Chapter 16: Your ‘.emacs’ File
Here is the ﬁrst part of this ‘.emacs’ ﬁle that does something besides
remind a forgetful human!
The ﬁrst of the two lines in parentheses tells Emacs to turn on Text mode
when you ﬁnd a ﬁle, unless that ﬁle should go into some other mode, such
as C mode.
When Emacs reads a ﬁle, it looks at the extension to the ﬁle name, if
any. (The extension is the part that comes after a ‘.’.) If the ﬁle ends with
a ‘.c’ or ‘.h’ extension then Emacs turns on C mode. Also, Emacs looks at
ﬁrst nonblank line of the ﬁle; if the line says ‘-*- C -*-’, Emacs turns on
C mode. Emacs possesses a list of extensions and speciﬁcations that it uses
automatically. In addition, Emacs looks near the last page for a per-buﬀer,
“local variables list”, if any.
See sections “How Major Modes are Chosen” and “Local Variables in
Files” in The GNU Emacs Manual.
Now, back to the ‘.emacs’ ﬁle.
Here is the line again; how does it work?
(setq default-major-mode ’text-mode)
This line is a short, but complete Emacs Lisp expression.
We are already familiar with setq.
It sets the following variable,
default-major-mode, to the subsequent value, which is text-mode. The
single quote mark before text-mode tells Emacs to deal directly with the
text-mode variable, not with whatever it might stand for. See Section 1.9,
“Setting the Value of a Variable”, page 17, for a reminder of how setq works.
The main point is that there is no diﬀerence between the procedure you use
to set a value in your ‘.emacs’ ﬁle and the procedure you use anywhere else
in Emacs.
Here are the next two lines:
(add-hook ’text-mode-hook ’text-mode-hook-identify)
(add-hook ’text-mode-hook ’turn-on-auto-fill)
In these two lines, the add-hook command ﬁrst adds text-mode-hook-
identify to the variable called text-mode-hook and then adds turn-on-
auto-fill to the variable.
turn-on-auto-fill is the name of a program, that, you guessed it!,
turns on Auto Fill mode.
text-mode-hook-identify is a function that
tells toggle-text-mode-auto-fill which buﬀers are in Text mode.
Every time Emacs turns on Text mode, Emacs runs the commands
‘hooked’ onto Text mode. So every time Emacs turns on Text mode, Emacs
also turns on Auto Fill mode.
In brief, the ﬁrst line causes Emacs to enter Text mode when you edit
a ﬁle, unless the ﬁle name extension, ﬁrst non-blank line, or local variables
tell Emacs otherwise.
Text mode among other actions, sets the syntax table to work conve-
niently for writers. In Text mode, Emacs considers an apostrophe as part

Indent Tabs Mode
219
of a word like a letter; but Emacs does not consider a period or a space as
part of a word. Thus, M-f moves you over ‘it’s’. On the other hand, in C
mode, M-f stops just after the ‘t’ of ‘it’s’.
The second and third lines causes Emacs to turn on Auto Fill mode when
it turns on Text mode. In Auto Fill mode, Emacs automatically breaks a
line that is too wide and brings the excessively wide part of the line down
to the next line. Emacs breaks lines between words, not within them.
When Auto Fill mode is turned oﬀ, lines continue to the right as you
type them. Depending on how you set the value of truncate-lines, the
words you type either disappear oﬀthe right side of the screen, or else are
shown, in a rather ugly and unreadable manner, as a continuation line on
the screen.
In addition, in this part of my ‘.emacs’ ﬁle, I tell the Emacs ﬁll commands
to insert two spaces after a colon:
(setq colon-double-space t)
16.5 Mail Aliases
Here is a setq that ‘turns on’ mail aliases, along with more reminders.
;;; Mail mode
; To enter mail mode, type ‘C-x m’
; To enter RMAIL (for reading mail),
; type ‘M-x rmail’
(setq mail-aliases t)
This setq command sets the value of the variable mail-aliases to t. Since
t means true, the line says, in eﬀect, “Yes, use mail aliases.”
Mail aliases are convenient short names for long email addresses or for
lists of email addresses. The ﬁle where you keep your ‘aliases’ is ‘~/.mailrc’.
You write an alias like this:
alias geo george@foobar.wiz.edu
When you write a message to George, address it to ‘geo’; the mailer will
automatically expand ‘geo’ to the full address.
16.6 Indent Tabs Mode
By default, Emacs inserts tabs in place of multiple spaces when it formats
a region. (For example, you might indent many lines of text all at once
with the indent-region command.) Tabs look ﬁne on a terminal or with
ordinary printing, but they produce badly indented output when you use
TEX or Texinfo since TEX ignores tabs.

220
Chapter 16: Your ‘.emacs’ File
The following turns oﬀIndent Tabs mode:
;;; Prevent Extraneous Tabs
(setq-default indent-tabs-mode nil)
Note that this line uses setq-default rather than the setq command
that we have seen before. The setq-default command sets values only in
buﬀers that do not have their own local values for the variable.
See sections “Tabs vs. Spaces” and “Local Variables in Files” in The
GNU Emacs Manual.
16.7 Some Keybindings
Now for some personal keybindings:
;;; Compare windows
(global-set-key "\C-cw" ’compare-windows)
compare-windows is a nifty command that compares the text in your
current window with text in the next window. It makes the comparison by
starting at point in each window, moving over text in each window as far as
they match. I use this command all the time.
This also shows how to set a key globally, for all modes.
The command is global-set-key. It is followed by the keybinding. In a
‘.emacs’ ﬁle, the keybinding is written as shown: \C-c stands for ‘control-
c’, which means ‘press the control key and the c key at the same time’.
The w means ‘press the w key’. The keybinding is surrounded by double
quotation marks. In documentation, you would write this as C-c w. (If you
were binding a ⟨META⟩key, such as M-c, rather than a ⟨CTL⟩key, you would
write \M-c. See section “Rebinding Keys in Your Init File” in The GNU
Emacs Manual, for details.)
The command invoked by the keys is compare-windows.
Note that
compare-windows is preceded by a single quote; otherwise, Emacs would
ﬁrst try to evaluate the symbol to determine its value.
These three things, the double quotation marks, the backslash before the
‘C’, and the single quote mark are necessary parts of keybinding that I tend
to forget. Fortunately, I have come to remember that I should look at my
existing ‘.emacs’ ﬁle, and adapt what is there.
As for the keybinding itself: C-c w. This combines the preﬁx key, C-c,
with a single character, in this case, w. This set of keys, C-c followed by a
single character, is strictly reserved for individuals’ own use. (I call these
‘own’ keys, since these are for my own use.) You should always be able to
create such a keybinding for your own use without stomping on someone
else’s keybinding.
If you ever write an extension to Emacs, please avoid
taking any of these keys for public use. Create a key like C-c C-w instead.
Otherwise, we will run out of ‘own’ keys.

Keymaps
221
Here is another keybinding, with a comment:
;;; Keybinding for ‘occur’
; I use occur a lot, so let’s bind it to a key:
(global-set-key "\C-co" ’occur)
The occur command shows all the lines in the current buﬀer that contain
a match for a regular expression. Matching lines are shown in a buﬀer called
‘*Occur*’. That buﬀer serves as a menu to jump to occurrences.
Here is how to unbind a key, so it does not work:
;;; Unbind ‘C-x f’
(global-unset-key "\C-xf")
There is a reason for this unbinding: I found I inadvertently typed C-x f
when I meant to type C-x C-f. Rather than ﬁnd a ﬁle, as I intended, I
accidentally set the width for ﬁlled text, almost always to a width I did not
want. Since I hardly ever reset my default width, I simply unbound the key.
The following rebinds an existing key:
;;; Rebind ‘C-x C-b’ for ‘buffer-menu’
(global-set-key "\C-x\C-b" ’buffer-menu)
By default, C-x C-b runs the list-buffers command. This command
lists your buﬀers in another window.
Since I almost always want to do
something in that window, I prefer the buffer-menu command, which not
only lists the buﬀers, but moves point into that window.
16.8 Keymaps
Emacs uses keymaps to record which keys call which commands. When
you use global-set-key to set the keybinding for a single command in all
parts of Emacs, you are specifying the keybinding in current-global-map.
Speciﬁc modes, such as C mode or Text mode, have their own keymaps;
the mode-speciﬁc keymaps override the global map that is shared by all
buﬀers.
The global-set-key function binds, or rebinds, the global keymap. For
example, the following binds the key C-x C-b to the function buffer-menu:
(global-set-key "\C-x\C-b" ’buffer-menu)
Mode-speciﬁc keymaps are bound using the define-key function, which
takes a speciﬁc keymap as an argument, as well as the key and the command.
For example, my ‘.emacs’ ﬁle contains the following expression to bind the
texinfo-insert-@group command to C-c C-c g:
(define-key texinfo-mode-map "\C-c\C-cg" ’texinfo-insert-@group)
The texinfo-insert-@group function itself is a little extension to Texinfo
mode that inserts ‘@group’ into a Texinfo ﬁle. I use this command all the
time and prefer to type the three strokes C-c C-c g rather than the six
strokes @ g r o u p. (‘@group’ and its matching ‘@end group’ are commands

222
Chapter 16: Your ‘.emacs’ File
that keep all enclosed text together on one page; many multi-line examples
in this book are surrounded by ‘@group ... @end group’.)
Here is the texinfo-insert-@group function deﬁnition:
(defun texinfo-insert-@group ()
"Insert the string @group in a Texinfo buffer."
(interactive)
(beginning-of-line)
(insert "@group\n"))
(Of course, I could have used Abbrev mode to save typing, rather than
write a function to insert a word; but I prefer key strokes consistent with
other Texinfo mode key bindings.)
You will see numerous define-key expressions in ‘loaddefs.el’ as well
as in the various mode libraries, such as ‘cc-mode.el’ and ‘lisp-mode.el’.
See section “Customizing Key Bindings” in The GNU Emacs Manual,
and section “Keymaps” in The GNU Emacs Lisp Reference Manual, for
more information about keymaps.
16.9 Loading Files
Many people in the GNU Emacs community have written extensions to
Emacs. As time goes by, these extensions are often included in new releases.
For example, the Calendar and Diary packages are now part of the standard
GNU Emacs.
(Calc, which I consider a vital part of Emacs, would be part of the stan-
dard distribution except that it was so large it was packaged separately and
no one has changed that.)
You can use a load command to evaluate a complete ﬁle and thereby
install all the functions and variables in the ﬁle into Emacs. For example:
(load "~/emacs/slowsplit")
This evaluates, i.e. loads, the ‘slowsplit.el’ ﬁle or if it exists, the
faster, byte compiled ‘slowsplit.elc’ ﬁle from the ‘emacs’ sub-directory of
your home directory. The ﬁle contains the function split-window-quietly,
which John Robinson wrote in 1989.
The split-window-quietly function splits a window with the minimum
of redisplay. I installed it in 1989 because it worked well with the slow 1200
baud terminals I was then using. Nowadays, I only occasionally come across
such a slow connection, but I continue to use the function because I like the
way it leaves the bottom half of a buﬀer in the lower of the new windows
and the top half in the upper window.

Autoloading
223
To replace the key binding for the default split-window-vertically,
you must also unset that key and bind the keys to split-window-quietly,
like this:
(global-unset-key "\C-x2")
(global-set-key "\C-x2" ’split-window-quietly)
If you load many extensions, as I do, then instead of specifying the exact
location of the extension ﬁle, as shown above, you can specify that directory
as part of Emacs’ load-path. Then, when Emacs loads a ﬁle, it will search
that directory as well as its default list of directories. (The default list is
speciﬁed in ‘paths.h’ when Emacs is built.)
The following command adds your ‘~/emacs’ directory to the existing
load path:
;;; Emacs Load Path
(setq load-path (cons "~/emacs" load-path))
Incidentally, load-library is an interactive interface to the load func-
tion. The complete function looks like this:
(defun load-library (library)
"Load the library named LIBRARY.
This is an interface to the function ‘load’."
(interactive "sLoad library: ")
(load library))
The name of the function, load-library, comes from the use of ‘library’
as a conventional synonym for ‘ﬁle’. The source for the load-library com-
mand is in the ‘files.el’ library.
Another interactive command that does a slightly diﬀerent job is load-
file. See section “Libraries of Lisp Code for Emacs” in The GNU Emacs
Manual, for information on the distinction between load-library and this
command.
16.10 Autoloading
Instead of installing a function by loading the ﬁle that contains it, or by
evaluating the function deﬁnition, you can make the function available but
not actually install it until it is ﬁrst called. This is called autoloading.
When you execute an autoloaded function, Emacs automatically evalu-
ates the ﬁle that contains the deﬁnition, and then calls the function.
Emacs starts quicker with autoloaded functions, since their libraries are
not loaded right away; but you need to wait a moment when you ﬁrst use
such a function, while its containing ﬁle is evaluated.
Rarely used functions are frequently autoloaded. The ‘loaddefs.el’ li-
brary contains hundreds of autoloaded functions, from bookmark-set to
wordstar-mode. Of course, you may come to use a ‘rare’ function frequently.

224
Chapter 16: Your ‘.emacs’ File
When you do, you should load that function’s ﬁle with a load expression in
your ‘.emacs’ ﬁle.
In my ‘.emacs’ ﬁle for Emacs version 21, I load 12 libraries that contain
functions that would otherwise be autoloaded. (Actually, it would have been
better to include these ﬁles in my ‘dumped’ Emacs when I built it, but I
forgot. See section “Building Emacs” in The GNU Emacs Lisp Reference
Manual, and the ‘INSTALL’ ﬁle for more about dumping.)
You may also want to include autoloaded expressions in your ‘.emacs’
ﬁle. autoload is a built-in function that takes up to ﬁve arguments, the ﬁnal
three of which are optional. The ﬁrst argument is the name of the function
to be autoloaded; the second is the name of the ﬁle to be loaded. The third
argument is documentation for the function, and the fourth tells whether
the function can be called interactively. The ﬁfth argument tells what type
of object—autoload can handle a keymap or macro as well as a function
(the default is a function).
Here is a typical example:
(autoload ’html-helper-mode
"html-helper-mode" "Edit HTML documents" t)
(html-helper-mode is an alternative to html-mode, which is a standard part
of the distribution).
This expression autoloads the html-helper-mode function.
It takes
it from the ‘html-helper-mode.el’ ﬁle (or from the byte compiled
ﬁle ‘html-helper-mode.elc’, if it exists.)
The ﬁle must be located
in a directory speciﬁed by load-path.
The documentation says that
this is a mode to help you edit documents written in the HyperText
Markup Language.
You can call this mode interactively by typing
M-x html-helper-mode.
(You need to duplicate the function’s regular
documentation in the autoload expression because the regular function is
not yet loaded, so its documentation is not available.)
See section “Autoload” in The GNU Emacs Lisp Reference Manual, for
more information.
16.11 A Simple Extension: line-to-top-of-window
Here is a simple extension to Emacs that moves the line point is on to
the top of the window. I use this all the time, to make text easier to read.
You can put the following code into a separate ﬁle and then load it from
your ‘.emacs’ ﬁle, or you can include it within your ‘.emacs’ ﬁle.

A Simple Extension: line-to-top-of-window
225
Here is the deﬁnition:
;;; Line to top of window;
;;; replace three keystroke sequence
C-u 0 C-l
(defun line-to-top-of-window ()
"Move the line point is on to top of window."
(interactive)
(recenter 0))
Now for the keybinding.
Nowadays, function keys as well as mouse button events and non-ascii
characters are written within square brackets, without quotation marks. (In
Emacs version 18 and before, you had to write diﬀerent function key bindings
for each diﬀerent make of terminal.)
I bind line-to-top-of-window to my ⟨F6⟩function key like this:
(global-set-key [f6] ’line-to-top-of-window)
For more information, see section “Rebinding Keys in Your Init File” in
The GNU Emacs Manual.
If you run two versions of GNU Emacs, such as versions 20 and 21, and
use one ‘.emacs’ ﬁle, you can select which code to evaluate with the following
conditional:
(cond
((string-equal (number-to-string 20) (substring (emacs-version) 10 12))
;; evaluate version 20 code
( ... ))
((string-equal (number-to-string 21) (substring (emacs-version) 10 12))
;; evaluate version 21 code
( ... )))
For example, in contrast to version 20, version 21 blinks its cursor by
default. I hate such blinking, as well as some other features in version 21,
so I placed the following in my ‘.emacs’ ﬁle2:
(if (string-equal "21" (substring (emacs-version) 10 12))
(progn
(blink-cursor-mode 0)
;; Insert newline when you press ‘C-n’ (next-line)
;; at the end of the buffer
(setq next-line-add-newlines t)
;; Turn on image viewing
(auto-image-file-mode t)
2 When I start instances of Emacs that do not load my ‘.emacs’ ﬁle or any site ﬁle, I
also turn oﬀblinking:
emacs -q --no-site-file -eval ’(blink-cursor-mode nil)’

226
Chapter 16: Your ‘.emacs’ File
;; Turn on menu bar (this bar has text)
;; (Use numeric argument to turn on)
(menu-bar-mode 1)
;; Turn off tool bar (this bar has icons)
;; (Use numeric argument to turn on)
(tool-bar-mode nil)
;; Turn off tooltip mode for tool bar
;; (This mode causes icon explanations to pop up)
;; (Use numeric argument to turn on)
(tooltip-mode nil)
;; If tooltips turned on, make tips appear promptly
(setq tooltip-delay 0.1)
; default is one second
))
(You will note that instead of typing (number-to-string 21), I decided to
save typing and wrote ‘21’ as a string, "21", rather than convert it from
an integer to a string. In this instance, this expression is better than the
longer, but more general (number-to-string 21). However, if you do not
know ahead of time what type of information will be returned, then the
number-to-string function will be needed.)
16.12 X11 Colors
You can specify colors when you use Emacs with the MIT X Windowing
system.
I dislike the default colors and specify my own.
Here are the expressions in my ‘.emacs’ ﬁle that set values:
;; Set cursor color
(set-cursor-color "white")
;; Set mouse color
(set-mouse-color "white")
;; Set foreground and background
(set-foreground-color "white")
(set-background-color "darkblue")
;;; Set highlighting colors for isearch and drag
(set-face-foreground ’highlight "white")
(set-face-background ’highlight "blue")
(set-face-foreground ’region "cyan")
(set-face-background ’region "blue")
(set-face-foreground ’secondary-selection "skyblue")
(set-face-background ’secondary-selection "darkblue")

A Modiﬁed Mode Line
227
;; Set calendar highlighting colors
(setq calendar-load-hook
’(lambda ()
(set-face-foreground ’diary-face
"skyblue")
(set-face-background ’holiday-face "slate blue")
(set-face-foreground ’holiday-face "white")))
The various shades of blue soothe my eye and prevent me from seeing the
screen ﬂicker.
Alternatively, I could have set my speciﬁcations in various X initialization
ﬁles.
For example, I could set the foreground, background, cursor, and
pointer (i.e., mouse) colors in my ‘~/.Xresources’ ﬁle like this:
Emacs*foreground:
white
Emacs*background:
darkblue
Emacs*cursorColor:
white
Emacs*pointerColor: white
In any event, since it is not part of Emacs, I set the root color of my X
window in my ‘~/.xinitrc’ ﬁle, like this3:
# I use TWM for window manager.
xsetroot -solid Navy -fg white &
16.13 Miscellaneous Settings for a ‘.emacs’ File
Here are a few miscellaneous settings:
−Set the shape and color of the mouse cursor:
; Cursor shapes are defined in
; ‘/usr/include/X11/cursorfont.h’;
; for example, the ‘target’ cursor is number 128;
; the ‘top_left_arrow’ cursor is number 132.
(let ((mpointer (x-get-resource "*mpointer"
"*emacs*mpointer")))
;; If you have not set your mouse pointer
;;
then set it, otherwise leave as is:
(if (eq mpointer nil)
(setq mpointer "132")) ; top_left_arrow
(setq x-pointer-shape (string-to-int mpointer))
(set-mouse-color "white"))
3 I occasionally run more modern window managers, such as Sawﬁsh with GNOME,
Enlightenment, SCWM, or KDE; in those cases, I often specify an image rather than
a plain color.

228
Chapter 16: Your ‘.emacs’ File
16.14 A Modiﬁed Mode Line
Finally, a feature I really like: a modiﬁed mode line.
When I work over a network, I forget which machine I am using. Also, I
tend to I lose track of where I am, and which line point is on.
So I reset my mode line to look like this:
-:-- foo.texi
rattlesnake:/home/bob/
Line 1
(Texinfo Fill) Top
I am visiting a ﬁle called ‘foo.texi’, on my machine ‘rattlesnake’ in
my ‘/home/bob’ buﬀer. I am on line 1, in Texinfo mode, and am at the top
of the buﬀer.
My ‘.emacs’ ﬁle has a section that looks like this:
;; Set a Mode Line that tells me which machine, which directory,
;; and which line I am on, plus the other customary information.
(setq default-mode-line-format
(quote
(#("-" 0 1
(help-echo
"mouse-1: select window, mouse-2: delete others ..."))
mode-line-mule-info
mode-line-modified
mode-line-frame-identification
"
"
mode-line-buffer-identification
"
"
(:eval (substring
(system-name) 0 (string-match "\\..+" (system-name))))
":"
default-directory
#(" " 0 1
(help-echo
"mouse-1: select window, mouse-2: delete others ..."))
(line-number-mode " Line %l ")
global-mode-string

A Modiﬁed Mode Line
229
#("
%[(" 0 6
(help-echo
"mouse-1: select window, mouse-2: delete others ..."))
(:eval (mode-line-mode-name))
mode-line-process
minor-mode-alist
#("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
")%] "
(-3 . "%P")
;;
"-%-"
)))
Here, I redeﬁne the default mode line. Most of the parts are from the original;
but I make a few changes. I set the default mode line format so as to permit
various modes, such as Info, to override it.
Many elements in the list are self-explanatory: mode-line-modified is
a variable that tells whether the buﬀer has been modiﬁed, mode-name tells
the name of the mode, and so on. However, the format looks complicated
because of two features we have not discussed.
The ﬁrst string in the mode line is a dash or hyphen, ‘-’. In the old days,
it would have been speciﬁed simply as "-". But nowadays, Emacs can add
properties to a string, such as highlighting or, as in this case, a help feature.
If you place your mouse cursor over the hyphen, some help information ap-
pears (By default, you must wait one second before the information appears.
You can change that timing by changing the value of tooltip-delay.)
The new string format has a special syntax:
#("-" 0 1 (help-echo "mouse-1: select window, ..."))
The #( begins a list. The ﬁrst element of the list is the string itself, just one
‘-’. The second and third elements specify the range over which the fourth
element applies. A range starts after a character, so a zero means the range
starts just before the ﬁrst character; a 1 means that the range ends just
after the ﬁrst character. The third element is the property for the range.
It consists of a property list, a property name, in this case, ‘help-echo’,
followed by a value, in this case, a string. The second, third, and fourth
elements of this new string format can be repeated.
See section “Text Properties in String” in The GNU Emacs Lisp Refer-
ence Manual, and see section “Mode Line Format” in The GNU Emacs Lisp
Reference Manual, for more information.
mode-line-buffer-identification displays the current buﬀer name.
It is a list beginning (#("%12b" 0 4 .... The #( begins the list.
The ‘"%12b"’ displays the current buﬀer name, using the buffer-name
function with which we are familiar; the ‘12’ speciﬁes the maximum number
of characters that will be displayed. When a name has fewer characters,
whitespace is added to ﬁll out to this number. (Buﬀer names can and often

230
Chapter 16: Your ‘.emacs’ File
should be longer than 12 characters; this length works well in a typical 80
column wide window.)
:eval is a new feature in GNU Emacs version 21. It says to evaluate
the following form and use the result as a string to display. In this case, the
expression displays the ﬁrst component of the full system name. The end of
the ﬁrst component is a ‘.’ (‘period’), so I use the string-match function
to tell me the length of the ﬁrst component. The substring from the zeroth
character to that length is the name of the machine.
This is the expression:
(:eval (substring
(system-name) 0 (string-match "\\..+" (system-name))))
‘%[’ and ‘%]’ cause a pair of square brackets to appear for each recursive
editing level. ‘%n’ says ‘Narrow’ when narrowing is in eﬀect. ‘%P’ tells you
the percentage of the buﬀer that is above the bottom of the window, or
‘Top’, ‘Bottom’, or ‘All’. (A lower case ‘p’ tell you the percentage above the
top of the window.) ‘%-’ inserts enough dashes to ﬁll out the line.
Remember, “You don’t have to like Emacs to like it” — your own Emacs
can have diﬀerent colors, diﬀerent commands, and diﬀerent keys than a
default Emacs.
On the other hand, if you want to bring up a plain ‘out of the box’ Emacs,
with no customization, type:
emacs -q
This will start an Emacs that does not load your ‘~/.emacs’ initialization
ﬁle. A plain, default Emacs. Nothing more.

debug
231
17 Debugging
GNU Emacs has two debuggers, debug and edebug. The ﬁrst is built
into the internals of Emacs and is always with you; the second requires that
you instrument a function before you can use it.
Both debuggers are described extensively in section “Debugging Lisp Pro-
grams” in The GNU Emacs Lisp Reference Manual. In this chapter, I will
walk through a short example of each.
17.1 debug
Suppose you have written a function deﬁnition that is intended to return
the sum of the numbers 1 through a given number. (This is the triangle
function discussed earlier.
See “Example with Decrementing Counter”,
page 129, for a discussion.)
However, your function deﬁnition has a bug. You have mistyped ‘1=’ for
‘1-’. Here is the broken deﬁnition:
(defun triangle-bugged (number)
"Return sum of numbers 1 through NUMBER inclusive."
(let ((total 0))
(while (> number 0)
(setq total (+ total number))
(setq number (1= number)))
; Error here.
total))
If you are reading this in Info, you can evaluate this deﬁnition in the
normal fashion. You will see triangle-bugged appear in the echo area.
Now evaluate the triangle-bugged function with an argument of 4:
(triangle-bugged 4)
In GNU Emacs version 21, you will create and enter a ‘*Backtrace*’ buﬀer
that says:
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
(1= number)
(setq number (1= number))
(while (> number 0) (setq total (+ total number))
(setq number (1= number)))
(let ((total 0)) (while (> number 0) (setq total ...)
(setq number ...)) total)
triangle-bugged(4)

232
Chapter 17: Debugging
eval((triangle-bugged 4))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
(I have reformatted this example slightly; the debugger does not fold long
lines. As usual, you can quit the debugger by typing q in the ‘*Backtrace*’
buﬀer.)
In practice, for a bug as simple as this, the ‘Lisp error’ line will tell you
what you need to know to correct the deﬁnition. The function 1= is ‘void’.
In GNU Emacs 20 and before, you will see:
Symbol’s function definition is void: 1=
which has the same meaning as the ‘*Backtrace*’ buﬀer line in version 21.
However, suppose you are not quite certain what is going on? You can
read the complete backtrace.
In this case, you need to run GNU Emacs 21, which automatically starts
the debugger that puts you in the ‘*Backtrace*’ buﬀer; or else, you need to
start the debugger manually as described below.
Read the ‘*Backtrace*’ buﬀer from the bottom up; it tells you what
Emacs did that led to the error. Emacs made an interactive call to C-x C-
e (eval-last-sexp), which led to the evaluation of the triangle-bugged
expression. Each line above tells you what the Lisp interpreter evaluated
next.
The third line from the top of the buﬀer is
(setq number (1= number))
Emacs tried to evaluate this expression; in order to do so, it tried to evaluate
the inner expression shown on the second line from the top:
(1= number)
This is where the error occurred; as the top line says:
Debugger entered--Lisp error: (void-function 1=)
You can correct the mistake, re-evaluate the function deﬁnition, and then
run your test again.
17.2 debug-on-entry
GNU Emacs 21 starts the debugger automatically when your function
has an error. GNU Emacs version 20 and before did not; it simply presented
you with an error message. You had to start the debugger manually.
You can start the debugger manually for all versions of Emacs; the ad-
vantage is that the debugger runs even if you do not have a bug in your
code. Sometimes your code will be free of bugs!

debug-on-entry
233
You can enter the debugger when you call the function by calling debug-
on-entry.
Type:
M-x debug-on-entry RET triangle-bugged RET
Now, evaluate the following:
(triangle-bugged 5)
All versions of Emacs will create a ‘*Backtrace*’ buﬀer and tell you that it
is beginning to evaluate the triangle-bugged function:
---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
eval((triangle-bugged 5))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
In the ‘*Backtrace*’ buﬀer, type d. Emacs will evaluate the ﬁrst expres-
sion in triangle-bugged; the buﬀer will look like this:
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
(setq number ...)) total)
* triangle-bugged(5)
eval((triangle-bugged 5))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
Now, type d again, eight times, slowly. Each time you type d, Emacs will
evaluate another expression in the function deﬁnition.

234
Chapter 17: Debugging
Eventually, the buﬀer will look like this:
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (> number 0) (setq total (+ total number))
(setq number (1= number)))
* (let ((total 0)) (while (> number 0) (setq total ...)
(setq number ...)) total)
* triangle-bugged(5)
eval((triangle-bugged 5))
eval-last-sexp-1(nil)
eval-last-sexp(nil)
call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
Finally, after you type d two more times, Emacs will reach the error, and
the top two lines of the ‘*Backtrace*’ buﬀer will look like this:
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
...
---------- Buffer: *Backtrace* ----------
By typing d, you were able to step through the function.
You can quit a ‘*Backtrace*’ buﬀer by typing q in it; this quits the trace,
but does not cancel debug-on-entry.
To cancel the eﬀect of debug-on-entry, call cancel-debug-on-entry
and the name of the function, like this:
M-x cancel-debug-on-entry RET triangle-bugged RET
(If you are reading this in Info, cancel debug-on-entry now.)
17.3 debug-on-quit and (debug)
In addition to setting debug-on-error or calling debug-on-entry, there
are two other ways to start debug.
You can start debug whenever you type C-g (keyboard-quit) by setting
the variable debug-on-quit to t. This is useful for debugging inﬁnite loops.

The edebug Source Level Debugger
235
Or, you can insert a line that says (debug) into your code where you
want the debugger to start, like this:
(defun triangle-bugged (number)
"Return sum of numbers 1 through NUMBER inclusive."
(let ((total 0))
(while (> number 0)
(setq total (+ total number))
(debug)
; Start debugger.
(setq number (1= number)))
; Error here.
total))
The debug function is described in detail in section “The Lisp Debugger”
in The GNU Emacs Lisp Reference Manual.
17.4 The edebug Source Level Debugger
Edebug is a source level debugger. Edebug normally displays the source
of the code you are debugging, with an arrow at the left that shows which
line you are currently executing.
You can walk through the execution of a function, line by line, or run
quickly until reaching a breakpoint where execution stops.
Edebug is described in section “Edebug” in The GNU Emacs Lisp Ref-
erence Manual.
Here is a bugged function deﬁnition for triangle-recursively.
See
Section 11.3.4, “Recursion in place of a counter”, page 137, for a review of
it.
(defun triangle-recursively-bugged (number)
"Return sum of numbers 1 through NUMBER inclusive.
Uses recursion."
(if (= number 1)
1
(+ number
(triangle-recursively-bugged
(1= number)))))
; Error here.
Normally, you would install this deﬁnition by positioning your cursor after
the function’s closing parenthesis and typing C-x C-e (eval-last-sexp) or
else by positioning your cursor within the deﬁnition and typing C-M-x (eval-
defun). (By default, the eval-defun command works only in Emacs Lisp
mode or in Lisp Interactive mode.)

236
Chapter 17: Debugging
However, to prepare this function deﬁnition for Edebug, you must ﬁrst
instrument the code using a diﬀerent command. You can do this by posi-
tioning your cursor within the deﬁnition and typing
M-x edebug-defun RET
This will cause Emacs to load Edebug automatically if it is not already
loaded, and properly instrument the function.
After instrumenting the function, place your cursor after the following
expression and type C-x C-e (eval-last-sexp):
(triangle-recursively-bugged 3)
You will be jumped back to the source for triangle-recursively-bugged
and the cursor positioned at the beginning of the if line of the function.
Also, you will see an arrowhead at the left hand side of that line.
The
arrowhead marks the line where the function is executing. (In the following
examples, we show the arrowhead with ‘=>’; in a windowing system, you
may see the arrowhead as a solid triangle in the window ‘fringe’.)
=>⋆(if (= number 1)
In the example, the location of point is displayed with a star, ‘⋆’ (in Info, it
is displayed as ‘-!-’).
If you now press ⟨SPC⟩, point will move to the next expression to be
executed; the line will look like this:
=>(if ⋆(= number 1)
As you continue to press ⟨SPC⟩, point will move from expression to expression.
At the same time, whenever an expression returns a value, that value will be
displayed in the echo area. For example, after you move point past number,
you will see the following:
Result: 3 = C-c
This means the value of number is 3, which is ascii ‘control-c’ (the third
letter of the alphabet).
You can continue moving through the code until you reach the line with
the error. Before evaluation, that line looks like this:
=>
⋆(1= number)))))
; Error here.
When you press ⟨SPC⟩once again, you will produce an error message that
says:
Symbol’s function definition is void: 1=
This is the bug.
Press q to quit Edebug.
To remove instrumentation from a function deﬁnition, simply re-evaluate
it with a command that does not instrument it. For example, you could
place your cursor after the deﬁnition’s closing parenthesis and type C-x C-e.
Edebug does a great deal more than walk with you through a function.
You can set it so it races through on its own, stopping only at an error or at
speciﬁed stopping points; you can cause it to display the changing values of

Debugging Exercises
237
various expressions; you can ﬁnd out how many times a function is called,
and more.
Edebug is described in section “Edebug” in The GNU Emacs Lisp Ref-
erence Manual.
17.5 Debugging Exercises
• Install the count-words-region function and then cause it to enter
the built-in debugger when you call it. Run the command on a region
containing two words. You will need to press d a remarkable number of
times. On your system, is a ‘hook’ called after the command ﬁnishes?
(For information on hooks, see section “Command Loop Overview” in
The GNU Emacs Lisp Reference Manual.)
• Copy count-words-region into the ‘*scratch*’ buﬀer, instrument the
function for Edebug, and walk through its execution. The function does
not need to have a bug, although you can introduce one if you wish. If
the function lacks a bug, the walk-through completes without problems.
• While running Edebug, type ? to see a list of all the Edebug commands.
(The global-edebug-prefix is usually C-x X, i.e. ⟨CTL⟩-x followed by
an upper case X; use this preﬁx for commands made outside of the
Edebug debugging buﬀer.)
• In the Edebug debugging buﬀer, use the p (edebug-bounce-point)
command to see where in the region the count-words-region is work-
ing.
• Move point to some spot further down function and then type the h
(edebug-goto-here) command to jump to that location.
• Use the t (edebug-trace-mode) command to cause Edebug to walk
through the function on its own; use an upper case T for edebug-Trace-
fast-mode.
• Set a breakpoint, then run Edebug in Trace mode until it reaches the
stopping point.

238
Chapter 17: Debugging

Conclusion
239
18 Conclusion
We have now reached the end of this Introduction. You have now learned
enough about programming in Emacs Lisp to set values, to write simple
‘.emacs’ ﬁles for yourself and your friends, and write simple customizations
and extensions to Emacs.
This is a place to stop. Or, if you wish, you can now go onward, and
teach yourself.
You have learned some of the basic nuts and bolts of programming. But
only some. There are a great many more brackets and hinges that are easy
to use that we have not touched.
A path you can follow right now lies among the sources to GNU Emacs
and in The GNU Emacs Lisp Reference Manual.
The Emacs Lisp sources are an adventure. When you read the sources
and come across a function or expression that is unfamiliar, you need to
ﬁgure out or ﬁnd out what it does.
Go to the Reference Manual. It is a thorough, complete, and fairly easy-
to-read description of Emacs Lisp. It is written not only for experts, but
for people who know what you know. (The Reference Manual comes with
the standard GNU Emacs distribution. Like this introduction, it comes as
a Texinfo source ﬁle, so you can read it on-line and as a typeset, printed
book.)
Go to the other on-line help that is part of GNU Emacs: the on-line
documentation for all functions, and find-tags, the program that takes
you to sources.
Here is an example of how I explore the sources. Because of its name,
‘simple.el’ is the ﬁle I looked at ﬁrst, a long time ago. As it happens some
of the functions in ‘simple.el’ are complicated, or at least look complicated
at ﬁrst sight. The open-line function, for example, looks complicated.
You may want to walk through this function slowly, as we did with
the forward-sentence function. (See Section 12.3, “forward-sentence”,
page 151.) Or you may want to skip that function and look at another,
such as split-line. You don’t need to read all the functions. According
to count-words-in-defun, the split-line function contains 27 words and
symbols.
Even though it is short, split-line contains four expressions we have
not studied: skip-chars-forward, indent-to, current-column and ‘?\n’.
Consider the skip-chars-forward function. (It is part of the function
deﬁnition for back-to-indentation, which is shown in Section 3.11, “Re-
view”, page 46.)
In GNU Emacs, you can ﬁnd out more about skip-chars-forward by
typing C-h f (describe-function) and the name of the function. This gives
you the function documentation.

240
Chapter 18: Conclusion
You may be able to guess what is done by a well named function such as
indent-to; or you can look it up, too. Incidentally, the describe-function
function itself is in ‘help.el’; it is one of those long, but decipherable func-
tions. You can look up describe-function using the C-h f command!
In this instance, since the code is Lisp, the ‘*Help*’ buﬀer contains the
name of the library containing the function’s source. You can put point over
the name of the library and press the RET key, which in this situation is
bound to help-follow, and be taken directly to the source, in the same way
as M-. (find-tag).
The deﬁnition for describe-function illustrates how to customize the
interactive expression without using the standard character codes; and it
shows how to create a temporary buﬀer.
(The indent-to function is written in C rather than Emacs Lisp; it is a
‘built-in’ function. help-follow only provides you with the documentation
of a built-in function; it does not take you to the source. But find-tag will
take you to the source, if properly set up.)
You can look at a function’s source using find-tag, which is bound to
M-. Finally, you can ﬁnd out what the Reference Manual has to say by
visiting the manual in Info, and typing i (Info-index) and the name of the
function, or by looking up skip-chars-forward in the index to a printed
copy of the manual.
Similarly, you can ﬁnd out what is meant by ‘?\n’. You can try using
Info-index with ‘?\n’. It turns out that this action won’t help; but don’t
give up. If you search the index for ‘\n’ without the ‘?’, you will be taken
directly to the relevant section of the manual. (See section “Character Type”
in The GNU Emacs Lisp Reference Manual. ‘?\n’ stands for the newline
character.)
Other interesting source ﬁles include ‘paragraphs.el’, ‘loaddefs.el’,
and ‘loadup.el’. The ‘paragraphs.el’ ﬁle includes short, easily understood
functions as well as longer ones. The ‘loaddefs.el’ ﬁle contains the many
standard autoloads and many keymaps. I have never looked at it all; only at
parts. ‘loadup.el’ is the ﬁle that loads the standard parts of Emacs; it tells
you a great deal about how Emacs is built. (See section “Building Emacs”
in The GNU Emacs Lisp Reference Manual, for more about building.)
As I said, you have learned some nuts and bolts; however, and very
importantly, we have hardly touched major aspects of programming; I have
said nothing about how to sort information, except to use the predeﬁned
sort function; I have said nothing about how to store information, except
to use variables and lists; I have said nothing about how to write programs
that write programs.
These are topics for another, and diﬀerent kind of
book, a diﬀerent kind of learning.
What you have done is learn enough for much practical work with GNU
Emacs. What you have done is get started. This is the end of a beginning.

The the-the Function
241
Appendix A The the-the Function
Sometimes when you you write text, you duplicate words—as with “you
you” near the beginning of this sentence.
I ﬁnd that most frequently, I
duplicate “the’; hence, I call the function for detecting duplicated words,
the-the.
As a ﬁrst step, you could use the following regular expression to search
for duplicates:
\\(\\w+[ \t\n]+\\)\\1
This regexp matches one or more word-constituent characters followed by
one or more spaces, tabs, or newlines. However, it does not detect duplicated
words on diﬀerent lines, since the ending of the ﬁrst word, the end of the
line, is diﬀerent from the ending of the second word, a space. (For more
information about regular expressions, see Chapter 12, “Regular Expression
Searches”, page 149, as well as section “Syntax of Regular Expressions” in
The GNU Emacs Manual, and section “Regular Expressions” in The GNU
Emacs Lisp Reference Manual.)
You might try searching just for duplicated word-constituent characters
but that does not work since the pattern detects doubles such as the two
occurrences of ‘th’ in ‘with the’.
Another possible regexp searches for word-constituent characters followed
by non-word-constituent characters, reduplicated. Here, ‘\\w+’ matches one
or more word-constituent characters and ‘\\W*’ matches zero or more non-
word-constituent characters.
\\(\\(\\w+\\)\\W*\\)\\1
Again, not useful.
Here is the pattern that I use. It is not perfect, but good enough. ‘\\b’
matches the empty string, provided it is at the beginning or end of a word;
‘[^@ \n\t]+’ matches one or more occurrences of any characters that are
not an @-sign, space, newline, or tab.
\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b
One can write more complicated expressions, but I found that this ex-
pression is good enough, so I use it.
Here is the the-the function, as I include it in my ‘.emacs’ ﬁle, along
with a handy global key binding:
(defun the-the ()
"Search forward for for a duplicated word."
(interactive)
(message "Searching for for duplicated words ...")
(push-mark)

242
Appendix A: The the-the Function
;; This regexp is not perfect
;; but is fairly good over all:
(if (re-search-forward
"\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil ’move)
(message "Found duplicated word.")
(message "End of buffer")))
;; Bind ‘the-the’ to
C-c \
(global-set-key "\C-c\\" ’the-the)
Here is test text:
one two two three four five
five six seven
You can substitute the other regular expressions shown above in the func-
tion deﬁnition and try each of them on this list.

The rotate-yank-pointer Function
243
Appendix B Handling the Kill Ring
The kill ring is a list that is transformed into a ring by the workings of the
rotate-yank-pointer function. The yank and yank-pop commands use the
rotate-yank-pointer function. This appendix describes the rotate-yank-
pointer function as well as both the yank and the yank-pop commands.
B.1 The rotate-yank-pointer Function
The rotate-yank-pointer function changes the element in the kill ring
to which kill-ring-yank-pointer points.
For example, it can change
kill-ring-yank-pointer from pointing to the second element to point to
the third element.
Here is the code for rotate-yank-pointer:
(defun rotate-yank-pointer (arg)
"Rotate the yanking point in the kill ring."
(interactive "p")
(let ((length (length kill-ring)))
(if (zerop length)
;; then-part
(error "Kill ring is empty")
;; else-part
(setq kill-ring-yank-pointer
(nthcdr (% (+ arg
(- length
(length
kill-ring-yank-pointer)))
length)
kill-ring)))))
The rotate-yank-pointer function looks complex, but as usual, it can
be understood by taking it apart piece by piece. First look at it in skeletal
form:
(defun rotate-yank-pointer (arg)
"Rotate the yanking point in the kill ring."
(interactive "p")
(let varlist
body...)
This function takes one argument, called arg. It has a brief documen-
tation string; and it is interactive with a small ‘p’, which means that the
argument must be a processed preﬁx passed to the function as a number.
The body of the function deﬁnition is a let expression, which itself has
a body as well as a varlist.

244
Appendix B: Handling the Kill Ring
The let expression declares a variable that will be only usable within
the bounds of this function. This variable is called length and is bound to
a value that is equal to the number of items in the kill ring. This is done
by using the function called length. (Note that this function has the same
name as the variable called length; but one use of the word is to name the
function and the other is to name the variable. The two are quite distinct.
Similarly, an English speaker will distinguish between the meanings of the
word ‘ship’ when he says: "I must ship this package immediately." and "I
must get aboard the ship immediately.")
The function length tells the number of items there are in a list, so
(length kill-ring) returns the number of items there are in the kill ring.
B.1.1 The Body of rotate-yank-pointer
The body of rotate-yank-pointer is a let expression and the body of
the let expression is an if expression.
The purpose of the if expression is to ﬁnd out whether there is anything
in the kill ring. If the kill ring is empty, the error function stops evaluation
of the function and prints a message in the echo area. On the other hand, if
the kill ring has something in it, the work of the function is done.
Here is the if-part and then-part of the if expression:
(if (zerop length)
; if-part
(error "Kill ring is empty")
; then-part
...
If there is not anything in the kill ring, its length must be zero and an error
message sent to the user: ‘Kill ring is empty’. The if expression uses the
function zerop which returns true if the value it is testing is zero. When
zerop tests true, the then-part of the if is evaluated.
The then-part is
a list starting with the function error, which is a function that is similar
to the message function (see Section 1.8.5, “message”, page 16), in that it
prints a one-line message in the echo area. However, in addition to printing
a message, error also stops evaluation of the function within which it is
embedded. This means that the rest of the function will not be evaluated if
the length of the kill ring is zero.
(In my opinion, it is slightly misleading, at least to humans, to use the
term ‘error’ as the name of the error function. A better term would be
‘cancel’. Strictly speaking, of course, you cannot point to, much less rotate
a pointer to a list that has no length, so from the point of view of the
computer, the word ‘error’ is correct. But a human expects to attempt this
sort of thing, if only to ﬁnd out whether the kill ring is full or empty. This
is an act of exploration.
(From the human point of view, the act of exploration and discovery is
not necessarily an error, and therefore should not be labelled as one, even in
the bowels of a computer. As it is, the code in Emacs implies that a human
who is acting virtuously, by exploring his or her environment, is making an

The else-part of the if expression
245
error. This is bad. Even though the computer takes the same steps as it
does when there is an ‘error’, a term such as ‘cancel’ would have a clearer
connotation.)
The else-part of the if expression
The else-part of the if expression is dedicated to setting the value of
kill-ring-yank-pointer when the kill ring has something in it. The code
looks like this:
(setq kill-ring-yank-pointer
(nthcdr (% (+ arg
(- length
(length kill-ring-yank-pointer)))
length)
kill-ring)))))
This needs some examination. Clearly, kill-ring-yank-pointer is be-
ing set to be equal to some cdr of the kill ring, using the nthcdr function
that is described in an earlier section. (See Section 8.5, “copy-region-as-kill”,
page 102.) But exactly how does it do this?
Before looking at the details of the code let’s ﬁrst consider the purpose
of the rotate-yank-pointer function.
The rotate-yank-pointer function changes what kill-ring-yank-
pointer points to. If kill-ring-yank-pointer starts by pointing to the
ﬁrst element of a list, a call to rotate-yank-pointer causes it to point to
the second element; and if kill-ring-yank-pointer points to the second
element, a call to rotate-yank-pointer causes it to point to the third ele-
ment. (And if rotate-yank-pointer is given an argument greater than 1,
it jumps the pointer that many elements.)
The rotate-yank-pointer function uses setq to reset what the kill-
ring-yank-pointer points to. If kill-ring-yank-pointer points to the
ﬁrst element of the kill ring, then, in the simplest case, the rotate-yank-
pointer function must cause it to point to the second element. Put another
way, kill-ring-yank-pointer must be reset to have a value equal to the
cdr of the kill ring.
That is, under these circumstances,
(setq kill-ring-yank-pointer
("some text" "a different piece of text" "yet more text"))
(setq kill-ring
("some text" "a different piece of text" "yet more text"))

246
Appendix B: Handling the Kill Ring
the code should do this:
(setq kill-ring-yank-pointer (cdr kill-ring))
As a result, the kill-ring-yank-pointer will look like this:
kill-ring-yank-pointer
⇒("a different piece of text" "yet more text"))
The actual setq expression uses the nthcdr function to do the job.
As we have seen before (see Section 7.3, “nthcdr”, page 85), the nthcdr
function works by repeatedly taking the cdr of a list—it takes the cdr of
the cdr of the cdr . . .
The two following expressions produce the same result:
(setq kill-ring-yank-pointer (cdr kill-ring))
(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
In the rotate-yank-pointer function, however, the ﬁrst argument to
nthcdr is a rather complex looking expression with lots of arithmetic inside
of it:
(% (+ arg
(- length
(length kill-ring-yank-pointer)))
length)
As usual, we need to look at the most deeply embedded expression ﬁrst
and then work our way towards the light.
The most deeply embedded expression is (length kill-ring-yank-
pointer).
This ﬁnds the length of the current value of the kill-ring-
yank-pointer. (Remember that the kill-ring-yank-pointer is the name
of a variable whose value is a list.)
The measurement of the length is inside the expression:
(- length (length kill-ring-yank-pointer))
In this expression, the ﬁrst length is the variable that was assigned the
length of the kill ring in the let statement at the beginning of the function.
(One might think this function would be clearer if the variable length were
named length-of-kill-ring instead; but if you look at the text of the
whole function, you will see that it is so short that naming this variable
length is not a bother, unless you are pulling the function apart into very
tiny pieces as we are doing here.)
So the line (- length (length kill-ring-yank-pointer)) tells the dif-
ference between the length of the kill ring and the length of the list whose
name is kill-ring-yank-pointer.
To see how all this ﬁts into the rotate-yank-pointer function, let’s
begin by analyzing the case where kill-ring-yank-pointer points to the
ﬁrst element of the kill ring, just as kill-ring does, and see what happens
when rotate-yank-pointer is called with an argument of 1.

The % remainder function
247
The variable length and the value of the expression (length kill-ring-
yank-pointer) will be the same since the variable length is the length of
the kill ring and the kill-ring-yank-pointer is pointing to the whole kill
ring. Consequently, the value of
(- length (length kill-ring-yank-pointer))
will be zero. Since the value of arg will be 1, this will mean that the value
of the whole expression
(+ arg (- length (length kill-ring-yank-pointer)))
will be 1.
Consequently, the argument to nthcdr will be found as the result of the
expression
(% 1 length)
The % remainder function
To understand (% 1 length), we need to understand %. According to its
documentation (which I just found by typing C-h f % ⟨RET⟩), the % function
returns the remainder of its ﬁrst argument divided by its second argument.
For example, the remainder of 5 divided by 2 is 1. (2 goes into 5 twice with
a remainder of 1.)
What surprises people who don’t often do arithmetic is that a smaller
number can be divided by a larger number and have a remainder. In the
example we just used, 5 was divided by 2. We can reverse that and ask,
what is the result of dividing 2 by 5? If you can use fractions, the answer
is obviously 2/5 or .4; but if, as here, you can only use whole numbers, the
result has to be something diﬀerent. Clearly, 5 can go into 2 zero times, but
what of the remainder? To see what the answer is, consider a case that has
to be familiar from childhood:
• 5 divided by 5 is 1 with a remainder of 0;
• 6 divided by 5 is 1 with a remainder of 1;
• 7 divided by 5 is 1 with a remainder of 2.
• Similarly, 10 divided by 5 is 2 with a remainder of 0;
• 11 divided by 5 is 2 with a remainder of 1;
• 12 divided by 5 is 1 with a remainder of 2.
By considering the cases as parallel, we can see that
• zero divided by 5 must be zero with a remainder of zero;
• 1 divided by 5 must be zero with a remainder of 1;
• 2 divided by 5 must be zero with a remainder of 2;
and so on.

248
Appendix B: Handling the Kill Ring
So, in this code, if the value of length is 5, then the result of evaluating
(% 1 5)
is 1. (I just checked this by placing the cursor after the expression and typing
C-x C-e. Indeed, 1 is printed in the echo area.)
Using % in rotate-yank-pointer
When the kill-ring-yank-pointer points to the beginning of the kill
ring, and the argument passed to rotate-yank-pointer is 1, the % expres-
sion returns 1:
(- length (length kill-ring-yank-pointer))
⇒0
therefore,
(+ arg (- length (length kill-ring-yank-pointer)))
⇒1
and consequently:
(% (+ arg (- length (length kill-ring-yank-pointer)))
length)
⇒1
regardless of the value of length.
As a result of this, the setq kill-ring-yank-pointer expression simpliﬁes
to:
(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
What it does is now easy to understand. Instead of pointing as it did to the
ﬁrst element of the kill ring, the kill-ring-yank-pointer is set to point
to the second element.
Clearly, if the argument passed to rotate-yank-pointer is two, then
the kill-ring-yank-pointer is set to (nthcdr 2 kill-ring); and so on
for diﬀerent values of the argument.
Similarly, if the kill-ring-yank-pointer starts out pointing to the sec-
ond element of the kill ring, its length is shorter than the length of the kill
ring by 1, so the computation of the remainder is based on the expression
(% (+ arg 1) length). This means that the kill-ring-yank-pointer is
moved from the second element of the kill ring to the third element if the
argument passed to rotate-yank-pointer is 1.
Pointing to the last element
The ﬁnal question is, what happens if the kill-ring-yank-pointer is
set to the last element of the kill ring? Will a call to rotate-yank-pointer
mean that nothing more can be taken from the kill ring? The answer is no.
What happens is diﬀerent and useful. The kill-ring-yank-pointer is set
to point to the beginning of the kill ring instead.

yank
249
Let’s see how this works by looking at the code, assuming the length of
the kill ring is 5 and the argument passed to rotate-yank-pointer is 1.
When the kill-ring-yank-pointer points to the last element of the kill
ring, its length is 1. The code looks like this:
(% (+ arg (- length (length kill-ring-yank-pointer))) length)
When the variables are replaced by their numeric values, the expression
looks like this:
(% (+ 1 (- 5 1)) 5)
This expression can be evaluated by looking at the most embedded inner
expression ﬁrst and working outwards: The value of (- 5 1) is 4; the sum
of (+ 1 4) is 5; and the remainder of dividing 5 by 5 is zero.
So what
rotate-yank-pointer will do is
(setq kill-ring-yank-pointer (nthcdr 0 kill-ring))
which will set the kill-ring-yank-pointer to point to the beginning of
the kill ring.
So what happens with successive calls to rotate-yank-pointer is that
it moves the kill-ring-yank-pointer from element to element in the kill
ring until it reaches the end; then it jumps back to the beginning. And this
is why the kill ring is called a ring, since by jumping back to the beginning,
it is as if the list has no end! (And what is a ring, but an entity with no
end?)
B.2 yank
After learning about rotate-yank-pointer, the code for the yank func-
tion is almost easy. It has only one tricky part, which is the computation of
the argument to be passed to rotate-yank-pointer.
The code looks like this:
(defun yank (&optional arg)
"Reinsert the last stretch of killed text.
More precisely, reinsert the stretch of killed text most
recently killed OR yanked.
With just C-U as argument, same but put point in front
(and mark at end).
With argument n, reinsert the nth
most recently killed stretch of killed text.
See also the command \\[yank-pop]."

250
Appendix B: Handling the Kill Ring
(interactive "*P")
(rotate-yank-pointer (if (listp arg) 0
(if (eq arg ’-) -1
(1- arg))))
(push-mark (point))
(insert (car kill-ring-yank-pointer))
(if (consp arg)
(exchange-point-and-mark)))
Glancing over this code, we can understand the last few lines readily
enough. The mark is pushed, that is, remembered; then the ﬁrst element
(the car) of what the kill-ring-yank-pointer points to is inserted; and
then, if the argument passed the function is a cons, point and mark are
exchanged so the point is put in the front of the inserted text rather than at
the end. This option is explained in the documentation. The function itself
is interactive with "*P". This means it will not work on a read-only buﬀer,
and that the unprocessed preﬁx argument is passed to the function.
Passing the argument
The hard part of yank is understanding the computation that determines
the value of the argument passed to rotate-yank-pointer. Fortunately, it
is not so diﬃcult as it looks at ﬁrst sight.
What happens is that the result of evaluating one or both of the if
expressions will be a number and that number will be the argument passed
to rotate-yank-pointer.
Laid out with comments, the code looks like this:
(if (listp arg)
; if-part
0
; then-part
(if (eq arg ’-)
; else-part, inner if
-1
; inner if’s then-part
(1- arg))))
; inner if’s else-part
This code consists of two if expression, one the else-part of the other.
The ﬁrst or outer if expression tests whether the argument passed to
yank is a list. Oddly enough, this will be true if yank is called without an
argument—because then it will be passed the value of nil for the optional
argument and an evaluation of (listp nil) returns true! So, if no argument
is passed to yank, the argument passed to rotate-yank-pointer inside of
yank is zero. This means the pointer is not moved and the ﬁrst element to
which kill-ring-yank-pointer points is inserted, as we expect. Similarly,
if the argument for yank is C-u, this will be read as a list, so again, a zero will
be passed to rotate-yank-pointer. (C-u produces an unprocessed preﬁx
argument of (4), which is a list of one element.) At the same time, later in
the function, this argument will be read as a cons so point will be put in the

Passing a negative argument
251
front and mark at the end of the insertion. (The P argument to interactive
is designed to provide these values for the case when an optional argument
is not provided or when it is C-u.)
The then-part of the outer if expression handles the case when there is
no argument or when it is C-u. The else-part handles the other situations.
The else-part is itself another if expression.
The inner if expression tests whether the argument is a minus sign. (This
is done by pressing the ⟨META⟩and - keys at the same time, or the ⟨ESC⟩
key and then the - key). In this case, the rotate-yank-pointer function
is passed -1 as an argument.
This moves the kill-ring-yank-pointer
backwards, which is what is desired.
If the true-or-false-test of the inner if expression is false (that is, if the
argument is not a minus sign), the else-part of the expression is evaluated.
This is the expression (1- arg). Because of the two if expressions, it will
only occur when the argument is a positive number or when it is a negative
number (not just a minus sign on its own). What (1- arg) does is decrement
the number and return it. (The 1- function subtracts one from its argument.)
This means that if the argument to rotate-yank-pointer is 1, it is reduced
to zero, which means the ﬁrst element to which kill-ring-yank-pointer
points is yanked back, as you would expect.
Passing a negative argument
Finally, the question arises, what happens if either the remainder func-
tion, %, or the nthcdr function is passed a negative argument, as they quite
well may?
The answers can be found by a quick test. When (% -1 5) is evaluated, a
negative number is returned; and if nthcdr is called with a negative number,
it returns the same value as if it were called with a ﬁrst argument of zero.
This can be seen be evaluating the following code.
Here the ‘⇒’ points to the result of evaluating the code preceding it.
This was done by positioning the cursor after the code and typing C-x C-e
(eval-last-sexp) in the usual fashion. You can do this if you are reading
this in Info inside of GNU Emacs.
(% -1 5)
⇒-1
(setq animals ’(cats dogs elephants))
⇒(cats dogs elephants)
(nthcdr 1 animals)
⇒(dogs elephants)
(nthcdr 0 animals)
⇒(cats dogs elephants)

252
Appendix B: Handling the Kill Ring
(nthcdr -1 animals)
⇒(cats dogs elephants)
So, if a minus sign or a negative number is passed to yank, the kill-
ring-yank-point is rotated backwards until it reaches the beginning of the
list. Then it stays there. Unlike the other case, when it jumps from the end
of the list to the beginning of the list, making a ring, it stops. This makes
sense. You often want to get back to the most recently clipped out piece of
text, but you don’t usually want to insert text from as many as thirty kill
commands ago. So you need to work through the ring to get to the end, but
won’t cycle around it inadvertently if you are trying to come back to the
beginning.
Incidentally, any number passed to yank with a minus sign preceding
it will be treated as −1. This is evidently a simpliﬁcation for writing the
program. You don’t need to jump back towards the beginning of the kill
ring more than one place at a time and doing this is easier than writing a
function to determine the magnitude of the number that follows the minus
sign.
B.3 yank-pop
After understanding yank, the yank-pop function is easy. Leaving out
the documentation to save space, it looks like this:
(defun yank-pop (arg)
(interactive "*p")
(if (not (eq last-command ’yank))
(error "Previous command was not a yank"))
(setq this-command ’yank)
(let ((before (< (point) (mark))))
(delete-region (point) (mark))
(rotate-yank-pointer arg)
(set-mark (point))
(insert (car kill-ring-yank-pointer))
(if before (exchange-point-and-mark))))
The function is interactive with a small ‘p’ so the preﬁx argument is
processed and passed to the function. The command can only be used after
a previous yank; otherwise an error message is sent. This check uses the
variable last-command which is discussed elsewhere. (See Section 8.5, “copy-
region-as-kill”, page 102.)
The let clause sets the variable before to true or false depending whether
point is before or after mark and then the region between point and mark
is deleted. This is the region that was just inserted by the previous yank
and it is this text that will be replaced. Next the kill-ring-yank-pointer
is rotated so that the previously inserted text is not reinserted yet again.
Mark is set at the beginning of the place the new text will be inserted and

yank-pop
253
then the ﬁrst element to which kill-ring-yank-pointer points is inserted.
This leaves point after the new text. If in the previous yank, point was left
before the inserted text, point and mark are now exchanged so point is again
left in front of the newly inserted text. That is all there is to it!

254
Appendix B: Handling the Kill Ring

A Graph with Labelled Axes
255
Appendix C A Graph with Labelled Axes
Printed axes help you understand a graph. They convey scale. In an
earlier chapter (see Chapter 15, “Readying a Graph”, page 203), we wrote
the code to print the body of a graph. Here we write the code for printing
and labelling vertical and horizontal axes, along with the body itself.
Since insertions ﬁll a buﬀer to the right and below point, the new graph
printing function should ﬁrst print the Y or vertical axis, then the body of
the graph, and ﬁnally the X or horizontal axis. This sequence lays out for
us the contents of the function:
1. Set up code.
2. Print Y axis.
3. Print body of graph.
4. Print X axis.
Here is an example of how a ﬁnished graph should look:
10 -
*
*
*
*
**
*
***
5 -
*
*******
* *** *******
*************
***************
1 - ****************
|
|
|
|
1
5
10
15
In this graph, both the vertical and the horizontal axes are labelled with
numbers. However, in some graphs, the horizontal axis is time and would
be better labelled with months, like this:
5 -
*
* ** *
*******
********** **
1 - **************
|
^
|
Jan
June
Jan
Indeed, with a little thought, we can easily come up with a variety of
vertical and horizontal labelling schemes. Our task could become compli-
cated. But complications breed confusion. Rather than permit this, it is
better choose a simple labelling scheme for our ﬁrst eﬀort, and to modify or
replace it later.

256
Appendix C: A Graph with Labelled Axes
These considerations suggest the following outline for the print-graph
function:
(defun print-graph (numbers-list)
"documentation..."
(let ((height
...
...))
(print-Y-axis height ... )
(graph-body-print numbers-list)
(print-X-axis ... )))
We can work on each part of the print-graph function deﬁnition in turn.
C.1 The print-graph Varlist
In writing the print-graph function, the ﬁrst task is to write the varlist in
the let expression. (We will leave aside for the moment any thoughts about
making the function interactive or about the contents of its documentation
string.)
The varlist should set several values. Clearly, the top of the label for
the vertical axis must be at least the height of the graph, which means that
we must obtain this information here. Note that the print-graph-body
function also requires this information. There is no reason to calculate the
height of the graph in two diﬀerent places, so we should change print-
graph-body from the way we deﬁned it earlier to take advantage of the
calculation.
Similarly, both the function for printing the X axis labels and the print-
graph-body function need to learn the value of the width of each symbol.
We can perform the calculation here and change the deﬁnition for print-
graph-body from the way we deﬁned it in the previous chapter.
The length of the label for the horizontal axis must be at least as long
as the graph. However, this information is used only in the function that
prints the horizontal axis, so it does not need to be calculated here.
These thoughts lead us directly to the following form for the varlist in
the let for print-graph:
(let ((height (apply ’max numbers-list)) ; First version.
(symbol-width (length graph-blank)))
As we shall see, this expression is not quite right.
C.2 The print-Y-axis Function
The job of the print-Y-axis function is to print a label for the vertical
axis that looks like this:

Side Trip: Compute a Remainder
257
10 -
5 -
1 -
The function should be passed the height of the graph, and then should
construct and insert the appropriate numbers and marks.
It is easy enough to see in the ﬁgure what the Y axis label should look
like; but to say in words, and then to write a function deﬁnition to do the
job is another matter. It is not quite true to say that we want a number
and a tic every ﬁve lines: there are only three lines between the ‘1’ and the
‘5’ (lines 2, 3, and 4), but four lines between the ‘5’ and the ‘10’ (lines 6, 7,
8, and 9). It is better to say that we want a number and a tic mark on the
base line (number 1) and then that we want a number and a tic on the ﬁfth
line from the bottom and on every line that is a multiple of ﬁve.
The next issue is what height the label should be? Suppose the maximum
height of tallest column of the graph is seven. Should the highest label on
the Y axis be ‘5 -’, and should the graph stick up above the label? Or should
the highest label be ‘7 -’, and mark the peak of the graph? Or should the
highest label be 10 -, which is a multiple of ﬁve, and be higher than the
topmost value of the graph?
The latter form is preferred. Most graphs are drawn within rectangles
whose sides are an integral number of steps long—5, 10, 15, and so on for a
step distance of ﬁve. But as soon as we decide to use a step height for the ver-
tical axis, we discover that the simple expression in the varlist for computing
the height is wrong. The expression is (apply ’max numbers-list). This
returns the precise height, not the maximum height plus whatever is neces-
sary to round up to the nearest multiple of ﬁve. A more complex expression
is required.
As usual in cases like this, a complex problem becomes simpler if it is
divided into several smaller problems.
First, consider the case when the highest value of the graph is an integral
multiple of ﬁve—when it is 5, 10, 15 ,or some higher multiple of ﬁve. We
can use this value as the Y axis height.
A fairly simply way to determine whether a number is a multiple of ﬁve
is to divide it by ﬁve and see if the division results in a remainder. If there is
no remainder, the number is a multiple of ﬁve. Thus, seven divided by ﬁve
has a remainder of two, and seven is not an integral multiple of ﬁve. Put in
slightly diﬀerent language, more reminiscent of the classroom, ﬁve goes into

258
Appendix C: A Graph with Labelled Axes
seven once, with a remainder of two. However, ﬁve goes into ten twice, with
no remainder: ten is an integral multiple of ﬁve.
C.2.1 Side Trip: Compute a Remainder
In Lisp, the function for computing a remainder is %. The function returns
the remainder of its ﬁrst argument divided by its second argument.
As
it happens, % is a function in Emacs Lisp that you cannot discover using
apropos: you ﬁnd nothing if you type M-x apropos ⟨RET⟩remainder ⟨RET⟩.
The only way to learn of the existence of % is to read about it in a book
such as this or in the Emacs Lisp sources. The % function is used in the
code for rotate-yank-pointer, which is described in an appendix. (See
Section B.1.1, “The Body of rotate-yank-pointer”, page 244.)
You can try the % function by evaluating the following two expressions:
(% 7 5)
(% 10 5)
The ﬁrst expression returns 2 and the second expression returns 0.
To test whether the returned value is zero or some other number, we can
use the zerop function. This function returns t if its argument, which must
be a number, is zero.
(zerop (% 7 5))
⇒nil
(zerop (% 10 5))
⇒t
Thus, the following expression will return t if the height of the graph is
evenly divisible by ﬁve:
(zerop (% height 5))
(The value of height, of course, can be found from (apply ’max numbers-
list).)
On the other hand, if the value of height is not a multiple of ﬁve, we want
to reset the value to the next higher multiple of ﬁve. This is straightforward
arithmetic using functions with which we are already familiar.
First, we
divide the value of height by ﬁve to determine how many times ﬁve goes
into the number. Thus, ﬁve goes into twelve twice. If we add one to this
quotient and multiply by ﬁve, we will obtain the value of the next multiple
of ﬁve that is larger than the height. Five goes into twelve twice. Add one
to two, and multiply by ﬁve; the result is ﬁfteen, which is the next multiple
of ﬁve that is higher than twelve. The Lisp expression for this is:
(* (1+ (/ height 5)) 5)
For example, if you evaluate the following, the result is 15:
(* (1+ (/ 12 5)) 5)

Construct a Y Axis Element
259
All through this discussion, we have been using ‘ﬁve’ as the value for
spacing labels on the Y axis; but we may want to use some other value. For
generality, we should replace ‘ﬁve’ with a variable to which we can assign
a value. The best name I can think of for this variable is Y-axis-label-
spacing.
Using this term, and an if expression, we produce the following:
(if (zerop (% height Y-axis-label-spacing))
height
;; else
(* (1+ (/ height Y-axis-label-spacing))
Y-axis-label-spacing))
This expression returns the value of height itself if the height is an even
multiple of the value of the Y-axis-label-spacing or else it computes and
returns a value of height that is equal to the next higher multiple of the
value of the Y-axis-label-spacing.
We can now include this expression in the let expression of the print-
graph function (after ﬁrst setting the value of Y-axis-label-spacing):
(defvar Y-axis-label-spacing 5
"Number of lines from one Y axis label to next.")
...
(let* ((height (apply ’max numbers-list))
(height-of-top-line
(if (zerop (% height Y-axis-label-spacing))
height
;; else
(* (1+ (/ height Y-axis-label-spacing))
Y-axis-label-spacing)))
(symbol-width (length graph-blank))))
...
(Note use of the let* function: the initial value of height is computed once
by the (apply ’max numbers-list) expression and then the resulting value
of height is used to compute its ﬁnal value. See “The let* expression”,
page 156, for more about let*.)
C.2.2 Construct a Y Axis Element
When we print the vertical axis, we want to insert strings such as ‘5 -’
and ‘10 - ’ every ﬁve lines. Moreover, we want the numbers and dashes to
line up, so shorter numbers must be padded with leading spaces. If some
of the strings use two digit numbers, the strings with single digit numbers
must include a leading blank space before the number.
To ﬁgure out the length of the number, the length function is used. But
the length function works only with a string, not with a number. So the

260
Appendix C: A Graph with Labelled Axes
number has to be converted from being a number to being a string. This is
done with the number-to-string function. For example,
(length (number-to-string 35))
⇒2
(length (number-to-string 100))
⇒3
(number-to-string is also called int-to-string; you will see this alterna-
tive name in various sources.)
In addition, in each label, each number is followed by a string such as
‘ - ’, which we will call the Y-axis-tic marker. This variable is deﬁned
with defvar:
(defvar Y-axis-tic " - "
"String that follows number in a Y axis label.")
The length of the Y label is the sum of the length of the Y axis tic mark
and the length of the number of the top of the graph.
(length (concat (number-to-string height) Y-axis-tic)))
This value will be calculated by the print-graph function in its varlist as
full-Y-label-width and passed on. (Note that we did not think to include
this in the varlist when we ﬁrst proposed it.)
To make a complete vertical axis label, a tic mark is concatenated with
a number; and the two together may be preceded by one or more spaces
depending on how long the number is. The label consists of three parts:
the (optional) leading spaces, the number, and the tic mark. The function
is passed the value of the number for the speciﬁc row, and the value of the
width of the top line, which is calculated (just once) by print-graph.
(defun Y-axis-element (number full-Y-label-width)
"Construct a NUMBERed label element.
A numbered element looks like this ‘
5 - ’,
and is padded as needed so all line up with
the element for the largest number."
(let* ((leading-spaces
(- full-Y-label-width
(length
(concat (number-to-string number)
Y-axis-tic)))))
(concat
(make-string leading-spaces ? )
(number-to-string number)
Y-axis-tic)))
The Y-axis-element function concatenates together the leading spaces,
if any; the number, as a string; and the tic mark.

The Not Quite Final Version of print-Y-axis
261
To ﬁgure out how many leading spaces the label will need, the function
subtracts the actual length of the label—the length of the number plus the
length of the tic mark—from the desired label width.
Blank spaces are inserted using the make-string function. This function
takes two arguments: the ﬁrst tells it how long the string will be and the
second is a symbol for the character to insert, in a special format.
The
format is a question mark followed by a blank space, like this, ‘? ’.
See
section “Character Type” in The GNU Emacs Lisp Reference Manual, for a
description of the syntax for characters.
The number-to-string function is used in the concatenation expression,
to convert the number to a string that is concatenated with the leading
spaces and the tic mark.
C.2.3 Create a Y Axis Column
The preceding functions provide all the tools needed to construct a func-
tion that generates a list of numbered and blank strings to insert as the label
for the vertical axis:
(defun Y-axis-column (height width-of-label)
"Construct list of Y axis labels and blank strings.
For HEIGHT of line above base and WIDTH-OF-LABEL."
(let (Y-axis)
(while (> height 1)
(if (zerop (% height Y-axis-label-spacing))
;; Insert label.
(setq Y-axis
(cons
(Y-axis-element height width-of-label)
Y-axis))
;; Else, insert blanks.
(setq Y-axis
(cons
(make-string width-of-label ? )
Y-axis)))
(setq height (1- height)))
;; Insert base line.
(setq Y-axis
(cons (Y-axis-element 1 width-of-label) Y-axis))
(nreverse Y-axis)))
In this function, we start with the value of height and repetitively sub-
tract one from its value.
After each subtraction, we test to see whether
the value is an integral multiple of the Y-axis-label-spacing.
If it is,
we construct a numbered label using the Y-axis-element function; if not,

262
Appendix C: A Graph with Labelled Axes
we construct a blank label using the make-string function. The base line
consists of the number one followed by a tic mark.
C.2.4 The Not Quite Final Version of print-Y-axis
The list constructed by the Y-axis-column function is passed to the
print-Y-axis function, which inserts the list as a column.
(defun print-Y-axis (height full-Y-label-width)
"Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the maximum height of the graph.
Full width is the width of the highest label element."
;; Value of height and full-Y-label-width
;; are passed by ‘print-graph’.
(let ((start (point)))
(insert-rectangle
(Y-axis-column height full-Y-label-width))
;; Place point ready for inserting graph.
(goto-char start)
;; Move point forward by value of full-Y-label-width
(forward-char full-Y-label-width)))
The print-Y-axis uses the insert-rectangle function to insert the Y
axis labels created by the Y-axis-column function. In addition, it places
point at the correct position for printing the body of the graph.
You can test print-Y-axis:
1. Install
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
2. Copy the following expression:
(print-Y-axis 12 5)
3. Switch to the ‘*scratch*’ buﬀer and place the cursor where you want
the axis labels to start.
4. Type M-: (eval-expression).
5. Yank the graph-body-print expression into the minibuﬀer with C-y
(yank).
6. Press ⟨RET⟩to evaluate the expression.
Emacs will print labels vertically, the top one being ‘10 - ’. (The print-
graph function will pass the value of height-of-top-line, which in this
case would end up as 15.)

X Axis Tic Marks
263
C.3 The print-X-axis Function
X axis labels are much like Y axis labels, except that the tics are on a
line above the numbers. Labels should look like this:
|
|
|
|
1
5
10
15
The ﬁrst tic is under the ﬁrst column of the graph and is preceded by
several blank spaces. These spaces provide room in rows above for the Y
axis labels. The second, third, fourth, and subsequent tics are all spaced
equally, according to the value of X-axis-label-spacing.
The second row of the X axis consists of numbers, preceded by several
blank spaces and also separated according to the value of the variable X-
axis-label-spacing.
The value of the variable X-axis-label-spacing should itself be mea-
sured in units of symbol-width, since you may want to change the width
of the symbols that you are using to print the body of the graph without
changing the ways the graph is labelled.
The print-X-axis function is constructed in more or less the same fash-
ion as the print-Y-axis function except that it has two lines: the line of
tic marks and the numbers. We will write a separate function to print each
line and then combine them within the print-X-axis function.
This is a three step process:
1. Write a function to print the X axis tic marks, print-X-axis-tic-line.
2. Write a function to print the X numbers, print-X-axis-numbered-
line.
3. Write a function to print both lines, the print-X-axis function, using
print-X-axis-tic-line and print-X-axis-numbered-line.
C.3.1 X Axis Tic Marks
The ﬁrst function should print the X axis tic marks. We must specify the
tic marks themselves and their spacing:
(defvar X-axis-label-spacing
(if (boundp ’graph-blank)
(* 5 (length graph-blank)) 5)
"Number of units from one X axis label to next.")
(Note that the value of graph-blank is set by another defvar.
The
boundp predicate checks whether it has already been set; boundp returns
nil if it has not.
If graph-blank were unbound and we did not use
this conditional construction, in GNU Emacs 21, we would enter the de-
bugger and see an error message saying ‘Debugger entered--Lisp error:
(void-variable graph-blank)’.)

264
Appendix C: A Graph with Labelled Axes
Here is the defvar for X-axis-tic-symbol:
(defvar X-axis-tic-symbol "|"
"String to insert to point to a column in X axis.")
The goal is to make a line that looks like this:
|
|
|
|
The ﬁrst tic is indented so that it is under the ﬁrst column, which is
indented to provide space for the Y axis labels.
A tic element consists of the blank spaces that stretch from one tic to the
next plus a tic symbol. The number of blanks is determined by the width of
the tic symbol and the X-axis-label-spacing.
The code looks like this:
;;; X-axis-tic-element
...
(concat
(make-string
;; Make a string of blanks.
(-
(* symbol-width X-axis-label-spacing)
(length X-axis-tic-symbol))
? )
;; Concatenate blanks with tic symbol.
X-axis-tic-symbol)
...
Next, we determine how many blanks are needed to indent the ﬁrst tic
mark to the ﬁrst column of the graph. This uses the value of full-Y-label-
width passed it by the print-graph function.
The code to make X-axis-leading-spaces looks like this:
;; X-axis-leading-spaces
...
(make-string full-Y-label-width ? )
...
We also need to determine the length of the horizontal axis, which is the
length of the numbers list, and the number of tics in the horizontal axis:
;; X-length
...
(length numbers-list)
;; tic-width
...
(* symbol-width X-axis-label-spacing)

X Axis Tic Marks
265
;; number-of-X-tics
(if (zerop (% (X-length tic-width)))
(/ (X-length tic-width))
(1+ (/ (X-length tic-width))))
All this leads us directly to the function for printing the X axis tic line:
(defun print-X-axis-tic-line
(number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
"Print tics for X axis."
(insert X-axis-leading-spaces)
(insert X-axis-tic-symbol)
; Under ﬁrst column.
;; Insert second tic in the right spot.
(insert (concat
(make-string
(-
(* symbol-width X-axis-label-spacing)
;; Insert white space up to second tic symbol.
(* 2 (length X-axis-tic-symbol)))
? )
X-axis-tic-symbol))
;; Insert remaining tics.
(while (> number-of-X-tics 1)
(insert X-axis-tic-element)
(setq number-of-X-tics (1- number-of-X-tics))))
The line of numbers is equally straightforward:
First, we create a numbered element with blank spaces before each num-
ber:
(defun X-axis-element (number)
"Construct a numbered X axis element."
(let ((leading-spaces
(-
(* symbol-width X-axis-label-spacing)
(length (number-to-string number)))))
(concat (make-string leading-spaces ? )
(number-to-string number))))
Next, we create the function to print the numbered line, starting with
the number “1” under the ﬁrst column:
(defun print-X-axis-numbered-line
(number-of-X-tics X-axis-leading-spaces)
"Print line of X-axis numbers"
(let ((number X-axis-label-spacing))
(insert X-axis-leading-spaces)
(insert "1")

266
Appendix C: A Graph with Labelled Axes
(insert (concat
(make-string
;; Insert white space up to next number.
(-
(* symbol-width X-axis-label-spacing) 2)
? )
(number-to-string number)))
;; Insert remaining numbers.
(setq number (+ number X-axis-label-spacing))
(while (> number-of-X-tics 1)
(insert (X-axis-element number))
(setq number (+ number X-axis-label-spacing))
(setq number-of-X-tics (1- number-of-X-tics)))))
Finally, we need to write the print-X-axis that uses print-X-axis-
tic-line and print-X-axis-numbered-line.
The function must determine the local values of the variables used by both
print-X-axis-tic-line and print-X-axis-numbered-line, and then it
must call them. Also, it must print the carriage return that separates the
two lines.
The function consists of a varlist that speciﬁes ﬁve local variables, and
calls to each of the two line printing functions:
(defun print-X-axis (numbers-list)
"Print X axis labels to length of NUMBERS-LIST."
(let* ((leading-spaces
(make-string full-Y-label-width ? ))
;; symbol-width is provided by graph-body-print
(tic-width (* symbol-width X-axis-label-spacing))
(X-length (length numbers-list))
(X-tic
(concat
(make-string
;; Make a string of blanks.
(-
(* symbol-width X-axis-label-spacing)
(length X-axis-tic-symbol))
? )
;; Concatenate blanks with tic symbol.
X-axis-tic-symbol))
(tic-number
(if (zerop (% X-length tic-width))
(/ X-length tic-width)
(1+ (/ X-length tic-width)))))
(print-X-axis-tic-line tic-number leading-spaces X-tic)
(insert "\n")
(print-X-axis-numbered-line tic-number leading-spaces)))

Printing the Whole Graph
267
You can test print-X-axis:
1. Install X-axis-tic-symbol, X-axis-label-spacing, print-X-axis-
tic-line, as well as X-axis-element, print-X-axis-numbered-line,
and print-X-axis.
2. Copy the following expression:
(progn
(let ((full-Y-label-width 5)
(symbol-width 1))
(print-X-axis
’(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
3. Switch to the ‘*scratch*’ buﬀer and place the cursor where you want
the axis labels to start.
4. Type M-: (eval-expression).
5. Yank the test expression into the minibuﬀer with C-y (yank).
6. Press ⟨RET⟩to evaluate the expression.
Emacs will print the horizontal axis like this:
|
|
|
|
|
1
5
10
15
20
C.4 Printing the Whole Graph
Now we are nearly ready to print the whole graph.
The function to print the graph with the proper labels follows the out-
line we created earlier (see Appendix C, “A Graph with Labelled Axes”,
page 255), but with additions.
Here is the outline:
(defun print-graph (numbers-list)
"documentation..."
(let ((height
...
...))
(print-Y-axis height ... )
(graph-body-print numbers-list)
(print-X-axis ... )))
The ﬁnal version is diﬀerent from what we planned in two ways: ﬁrst, it
contains additional values calculated once in the varlist; second, it carries
an option to specify the labels’ increment per row. This latter feature turns
out to be essential; otherwise, a graph may have more rows than ﬁt on a
display or on a sheet of paper.

268
Appendix C: A Graph with Labelled Axes
This new feature requires a change to the Y-axis-column function, to
add vertical-step to it. The function looks like this:
;;; Final version.
(defun Y-axis-column
(height width-of-label &optional vertical-step)
"Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.
For example, a step of 5 means
that each line is five units of the graph."
(let (Y-axis
(number-per-line (or vertical-step 1)))
(while (> height 1)
(if (zerop (% height Y-axis-label-spacing))
;; Insert label.
(setq Y-axis
(cons
(Y-axis-element
(* height number-per-line)
width-of-label)
Y-axis))
;; Else, insert blanks.
(setq Y-axis
(cons
(make-string width-of-label ? )
Y-axis)))
(setq height (1- height)))
;; Insert base line.
(setq Y-axis (cons (Y-axis-element
(or vertical-step 1)
width-of-label)
Y-axis))
(nreverse Y-axis)))
The values for the maximum height of graph and the width of a symbol
are computed by print-graph in its let expression; so graph-body-print
must be changed to accept them.

Printing the Whole Graph
269
;;; Final version.
(defun graph-body-print (numbers-list height symbol-width)
"Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
(let (from-position)
(while numbers-list
(setq from-position (point))
(insert-rectangle
(column-of-graph height (car numbers-list)))
(goto-char from-position)
(forward-char symbol-width)
;; Draw graph column by column.
(sit-for 0)
(setq numbers-list (cdr numbers-list)))
;; Place point for X axis labels.
(forward-line height)
(insert "\n")))
Finally, the code for the print-graph function:
;;; Final version.
(defun print-graph
(numbers-list &optional vertical-step)
"Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.
For example, a step of 5 means that
each row is five units."
(let* ((symbol-width (length graph-blank))
;; height is both the largest number
;; and the number with the most digits.
(height (apply ’max numbers-list))
(height-of-top-line
(if (zerop (% height Y-axis-label-spacing))
height
;; else
(* (1+ (/ height Y-axis-label-spacing))
Y-axis-label-spacing)))
(vertical-step (or vertical-step 1))
(full-Y-label-width
(length

270
Appendix C: A Graph with Labelled Axes
(concat
(number-to-string
(* height-of-top-line vertical-step))
Y-axis-tic))))
(print-Y-axis
height-of-top-line full-Y-label-width vertical-step)
(graph-body-print
numbers-list height-of-top-line symbol-width)
(print-X-axis numbers-list)))
C.4.1 Testing print-graph
We can test the print-graph function with a short list of numbers:
1. Install the ﬁnal versions of Y-axis-column, graph-body-print, and
print-graph (in addition to the rest of the code.)
2. Copy the following expression:
(print-graph ’(3 2 5 6 7 5 3 4 6 4 3 2 1))
3. Switch to the ‘*scratch*’ buﬀer and place the cursor where you want
the axis labels to start.
4. Type M-: (eval-expression).
5. Yank the test expression into the minibuﬀer with C-y (yank).
6. Press ⟨RET⟩to evaluate the expression.
Emacs will print a graph that looks like this:
10 -
*
**
*
5 -
****
*
**** ***
* *********
************
1 - *************
|
|
|
|
1
5
10
15
On the other hand, if you pass print-graph a vertical-step value of
2, by evaluating this expression:
(print-graph ’(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)

Graphing Numbers of Words and Symbols
271
The graph looks like this:
20 -
*
**
*
10 -
****
*
**** ***
* *********
************
2 - *************
|
|
|
|
1
5
10
15
(A question: is the ‘2’ on the bottom of the vertical axis a bug or a feature?
If you think it is a bug, and should be a ‘1’ instead, (or even a ‘0’), you can
modify the sources.)
C.4.2 Graphing Numbers of Words and Symbols
Now for the graph for which all this code was written: a graph that shows
how many function deﬁnitions contain fewer than 10 words and symbols, how
many contain between 10 and 19 words and symbols, how many contain
between 20 and 29 words and symbols, and so on.
This is a multi-step process. First make sure you have loaded all the
requisite code.
It is a good idea to reset the value of top-of-ranges in case you have
set it to some diﬀerent value. You can evaluate the following:
(setq top-of-ranges
’(10
20
30
40
50
60
70
80
90 100
110 120 130 140 150
160 170 180 190 200
210 220 230 240 250
260 270 280 290 300)
Next create a list of the number of words and symbols in each range.

272
Appendix C: A Graph with Labelled Axes
Evaluate the following:
(setq list-for-graph
(defuns-per-range
(sort
(recursive-lengths-list-many-files
(directory-files "/usr/local/emacs/lisp"
t ".+el$"))
’<)
top-of-ranges))
On my machine, this takes about an hour. It looks though 303 Lisp ﬁles in
my copy of Emacs version 19.23. After all that computing, the list-for-
graph has this value:
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
This means that my copy of Emacs has 537 function deﬁnitions with fewer
than 10 words or symbols in them, 1,027 function deﬁnitions with 10 to 19
words or symbols in them, 955 function deﬁnitions with 20 to 29 words or
symbols in them, and so on.
Clearly, just by looking at this list we can see that most function deﬁni-
tions contain ten to thirty words and symbols.
Now for printing. We do not want to print a graph that is 1,030 lines
high . . . Instead, we should print a graph that is fewer than twenty-ﬁve
lines high. A graph that height can be displayed on almost any monitor,
and easily printed on a sheet of paper.
This means that each value in list-for-graph must be reduced to one-
ﬁftieth its present value.
Here is a short function to do just that, using two functions we have not
yet seen, mapcar and lambda.
(defun one-fiftieth (full-range)
"Return list, each number one-fiftieth of previous."
(mapcar ’(lambda (arg) (/ arg 50)) full-range))
C.4.3 A lambda Expression: Useful Anonymity
lambda is the symbol for an anonymous function, a function without a
name. Every time you use an anonymous function, you need to include its
whole body.

The mapcar Function
273
Thus,
(lambda (arg) (/ arg 50))
is a function deﬁnition that says ‘return the value resulting from dividing
whatever is passed to me as arg by 50’.
Earlier, for example, we had a function multiply-by-seven; it multiplied
its argument by 7. This function is similar, except it divides its argument by
50; and, it has no name. The anonymous equivalent of multiply-by-seven
is:
(lambda (number) (* 7 number))
(See Section 3.1, “The defun Special Form”, page 29.)
If we want to multiply 3 by 7, we can write:
(multiply-by-seven 3)
function
argument
This expression returns 21.
Similarly, we can write:
((lambda (number) (* 7 number)) 3)
anonymous function
argument
If we want to divide 100 by 50, we can write:
((lambda (arg) (/ arg 50)) 100)
anonymous function argument
This expression returns 2. The 100 is passed to the function, which divides
that number by 50.
See section “Lambda Expressions” in The GNU Emacs Lisp Reference
Manual, for more about lambda. Lisp and lambda expressions derive from
the Lambda Calculus.

274
Appendix C: A Graph with Labelled Axes
C.4.4 The mapcar Function
mapcar is a function that calls its ﬁrst argument with each element of its
second argument, in turn. The second argument must be a sequence.
The ‘map’ part of the name comes from the mathematical phrase, ‘map-
ping over a domain’, meaning to apply a function to each of the elements in
a domain. The mathematical phrase is based on the metaphor of a surveyor
walking, one step at a time, over an area he is mapping. And ‘car’, of course,
comes from the Lisp notion of the ﬁrst of a list.
For example,
(mapcar ’1+ ’(2 4 6))
⇒(3 5 7)
The function 1+ which adds one to its argument, is executed on each element
of the list, and a new list is returned.
Contrast this with apply, which applies its ﬁrst argument to all the re-
maining. (See Chapter 15, “Readying a Graph”, page 203, for a explanation
of apply.)
In the deﬁnition of one-fiftieth, the ﬁrst argument is the anonymous
function:
(lambda (arg) (/ arg 50))
and the second argument is full-range, which will be bound to list-for-
graph.
The whole expression looks like this:
(mapcar ’(lambda (arg) (/ arg 50)) full-range))
See section “Mapping Functions” in The GNU Emacs Lisp Reference
Manual, for more about mapcar.
Using the one-fiftieth function, we can generate a list in which each
element is one-ﬁftieth the size of the corresponding element in list-for-
graph.
(setq fiftieth-list-for-graph
(one-fiftieth list-for-graph))
The resulting list looks like this:
(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
This, we are almost ready to print! (We also notice the loss of information:
many of the higher ranges are 0, meaning that fewer than 50 defuns had
that many words or symbols—but not necessarily meaning that none had
that many words or symbols.)
C.4.5 Another Bug . . . Most Insidious
I said ‘almost ready to print’! Of course, there is a bug in the print-
graph function . . . It has a vertical-step option, but not a horizontal-

Another Bug . . . Most Insidious
275
step option. The top-of-range scale goes from 10 to 300 by tens. But the
print-graph function will print only by ones.
This is a classic example of what some consider the most insidious type
of bug, the bug of omission. This is not the kind of bug you can ﬁnd by
studying the code, for it is not in the code; it is an omitted feature. Your
best actions are to try your program early and often; and try to arrange,
as much as you can, to write code that is easy to understand and easy to
change. Try to be aware, whenever you can, that whatever you have written,
will be rewritten, if not soon, eventually. A hard maxim to follow.
It is the print-X-axis-numbered-line function that needs the work;
and then the print-X-axis and the print-graph functions need to be
adapted.
Not much needs to be done; there is one nicety: the numbers
ought to line up under the tic marks. This takes a little thought.
Here is the corrected print-X-axis-numbered-line:
(defun print-X-axis-numbered-line
(number-of-X-tics X-axis-leading-spaces
&optional horizontal-step)
"Print line of X-axis numbers"
(let ((number X-axis-label-spacing)
(horizontal-step (or horizontal-step 1)))
(insert X-axis-leading-spaces)
;; Delete extra leading spaces.
(delete-char
(- (1-
(length (number-to-string horizontal-step)))))
(insert (concat
(make-string
;; Insert white space.
(-
(* symbol-width
X-axis-label-spacing)
(1-
(length
(number-to-string horizontal-step)))
2)
? )
(number-to-string
(* number horizontal-step))))
;; Insert remaining numbers.
(setq number (+ number X-axis-label-spacing))
(while (> number-of-X-tics 1)
(insert (X-axis-element
(* number horizontal-step)))
(setq number (+ number X-axis-label-spacing))
(setq number-of-X-tics (1- number-of-X-tics)))))

276
Appendix C: A Graph with Labelled Axes
If you are reading this in Info, you can see the new versions of print-X-
axis print-graph and evaluate them. If you are reading this in a printed
book, you can see the changed lines here (the full text is too much to print).
(defun print-X-axis (numbers-list horizontal-step)
...
(print-X-axis-numbered-line
tic-number leading-spaces horizontal-step))
(defun print-graph
(numbers-list
&optional vertical-step horizontal-step)
...
(print-X-axis numbers-list horizontal-step))

The Printed Graph
277
C.4.6 The Printed Graph
When made and installed, you can call the print-graph command like
this:
(print-graph fiftieth-list-for-graph 50 10)
Here is the graph:
1000 -
*
**
**
**
**
750 -
***
***
***
***
****
500 - *****
******
******
******
*******
250 - ********
*********
*
***********
*
*************
*
50 - ***************** *
*
|
|
|
|
|
|
|
|
10
50
100
150
200
250
300
350
The largest group of functions contain 10 – 19 words and symbols each.

278
Appendix C: A Graph with Labelled Axes

GNU Free Documentation License
279
Appendix D GNU Free Documentation
License
Version 1.1, March 2000
Copyright c⃝2000 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
0. PREAMBLE
The purpose of this License is to make a manual, textbook, or other
written document free in the sense of freedom: to assure everyone the
eﬀective freedom to copy and redistribute it, with or without modifying
it, either commercially or noncommercially. Secondarily, this License
preserves for the author and publisher a way to get credit for their
work, while not being considered responsible for modiﬁcations made by
others.
This License is a kind of “copyleft”, which means that derivative works
of the document must themselves be free in the same sense. It com-
plements the GNU General Public License, which is a copyleft license
designed for free software.
We have designed this License in order to use it for manuals for free soft-
ware, because free software needs free documentation: a free program
should come with manuals providing the same freedoms that the soft-
ware does. But this License is not limited to software manuals; it can
be used for any textual work, regardless of subject matter or whether it
is published as a printed book. We recommend this License principally
for works whose purpose is instruction or reference.
1. APPLICABILITY AND DEFINITIONS
This License applies to any manual or other work that contains a notice
placed by the copyright holder saying it can be distributed under the
terms of this License. The “Document”, below, refers to any such man-
ual or work. Any member of the public is a licensee, and is addressed
as “you”.
A “Modiﬁed Version” of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with modiﬁca-
tions and/or translated into another language.
A “Secondary Section” is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the pub-
lishers or authors of the Document to the Document’s overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject. (For example, if the Document is in part
a textbook of mathematics, a Secondary Section may not explain any

280
Appendix D: GNU Free Documentation License
mathematics.) The relationship could be a matter of historical connec-
tion with the subject or with related matters, or of legal, commercial,
philosophical, ethical or political position regarding them.
The “Invariant Sections” are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says
that the Document is released under this License.
The “Cover Texts” are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the
Document is released under this License.
A “Transparent” copy of the Document means a machine-readable copy,
represented in a format whose speciﬁcation is available to the general
public, whose contents can be viewed and edited directly and straight-
forwardly with generic text editors or (for images composed of pixels)
generic paint programs or (for drawings) some widely available drawing
editor, and that is suitable for input to text formatters or for automatic
translation to a variety of formats suitable for input to text formatters.
A copy made in an otherwise Transparent ﬁle format whose markup
has been designed to thwart or discourage subsequent modiﬁcation by
readers is not Transparent. A copy that is not “Transparent” is called
“Opaque”.
Examples of suitable formats for Transparent copies include plain ascii
without markup, Texinfo input format, LaTEX input format, sgml
or xml using a publicly available dtd, and standard-conforming sim-
ple html designed for human modiﬁcation. Opaque formats include
PostScript, pdf, proprietary formats that can be read and edited only
by proprietary word processors, sgml or xml for which the dtd and/or
processing tools are not generally available, and the machine-generated
html produced by some word processors for output purposes only.
The “Title Page” means, for a printed book, the title page itself, plus
such following pages as are needed to hold, legibly, the material this
License requires to appear in the title page. For works in formats which
do not have any title page as such, “Title Page” means the text near the
most prominent appearance of the work’s title, preceding the beginning
of the body of the text.
2. VERBATIM COPYING
You may copy and distribute the Document in any medium, either com-
mercially or noncommercially, provided that this License, the copyright
notices, and the license notice saying this License applies to the Docu-
ment are reproduced in all copies, and that you add no other conditions
whatsoever to those of this License. You may not use technical mea-
sures to obstruct or control the reading or further copying of the copies
you make or distribute. However, you may accept compensation in ex-
change for copies. If you distribute a large enough number of copies you
must also follow the conditions in section 3.

GNU Free Documentation License
281
You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
3. COPYING IN QUANTITY
If you publish printed copies of the Document numbering more than
100, and the Document’s license notice requires Cover Texts, you must
enclose the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover. Both covers must also clearly and legibly identify you as
the publisher of these copies. The front cover must present the full title
with all words of the title equally prominent and visible. You may add
other material on the covers in addition. Copying with changes limited
to the covers, as long as they preserve the title of the Document and
satisfy these conditions, can be treated as verbatim copying in other
respects.
If the required texts for either cover are too voluminous to ﬁt legibly,
you should put the ﬁrst ones listed (as many as ﬁt reasonably) on the
actual cover, and continue the rest onto adjacent pages.
If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transpar-
ent copy along with each Opaque copy, or state in or with each Opaque
copy a publicly-accessible computer-network location containing a com-
plete Transparent copy of the Document, free of added material, which
the general network-using public has access to download anonymously
at no charge using public-standard network protocols. If you use the
latter option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this Transpar-
ent copy will remain thus accessible at the stated location until at least
one year after the last time you distribute an Opaque copy (directly or
through your agents or retailers) of that edition to the public.
It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
4. MODIFICATIONS
You may copy and distribute a Modiﬁed Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modiﬁed Version under precisely this License, with the Modiﬁed
Version ﬁlling the role of the Document, thus licensing distribution and
modiﬁcation of the Modiﬁed Version to whoever possesses a copy of it.
In addition, you must do these things in the Modiﬁed Version:
A. Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section of
the Document). You may use the same title as a previous version
if the original publisher of that version gives permission.

282
Appendix D: GNU Free Documentation License
B. List on the Title Page, as authors, one or more persons or enti-
ties responsible for authorship of the modiﬁcations in the Modiﬁed
Version, together with at least ﬁve of the principal authors of the
Document (all of its principal authors, if it has less than ﬁve).
C. State on the Title page the name of the publisher of the Modiﬁed
Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modiﬁcations adja-
cent to the other copyright notices.
F. Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modiﬁed Version under the
terms of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document’s license notice.
H. Include an unaltered copy of this License.
I. Preserve the section entitled “History”, and its title, and add to it
an item stating at least the title, year, new authors, and publisher
of the Modiﬁed Version as given on the Title Page. If there is no
section entitled “History” in the Document, create one stating the
title, year, authors, and publisher of the Document as given on its
Title Page, then add an item describing the Modiﬁed Version as
stated in the previous sentence.
J. Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on. These may be placed in the “History” section. You
may omit a network location for a work that was published at least
four years before the Document itself, or if the original publisher of
the version it refers to gives permission.
K. In any section entitled “Acknowledgments” or “Dedications”, pre-
serve the section’s title, and preserve in the section all the substance
and tone of each of the contributor acknowledgments and/or dedi-
cations given therein.
L. Preserve all the Invariant Sections of the Document, unaltered in
their text and in their titles. Section numbers or the equivalent are
not considered part of the section titles.
M. Delete any section entitled “Endorsements”. Such a section may
not be included in the Modiﬁed Version.
N. Do not retitle any existing section as “Endorsements” or to conﬂict
in title with any Invariant Section.
If the Modiﬁed Version includes new front-matter sections or appendices
that qualify as Secondary Sections and contain no material copied from
the Document, you may at your option designate some or all of these

GNU Free Documentation License
283
sections as invariant. To do this, add their titles to the list of Invariant
Sections in the Modiﬁed Version’s license notice. These titles must be
distinct from any other section titles.
You may add a section entitled “Endorsements”, provided it contains
nothing but endorsements of your Modiﬁed Version by various parties—
for example, statements of peer review or that the text has been ap-
proved by an organization as the authoritative deﬁnition of a standard.
You may add a passage of up to ﬁve words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list of
Cover Texts in the Modiﬁed Version. Only one passage of Front-Cover
Text and one of Back-Cover Text may be added by (or through ar-
rangements made by) any one entity. If the Document already includes
a cover text for the same cover, previously added by you or by arrange-
ment made by the same entity you are acting on behalf of, you may not
add another; but you may replace the old one, on explicit permission
from the previous publisher that added the old one.
The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or imply
endorsement of any Modiﬁed Version.
5. COMBINING DOCUMENTS
You may combine the Document with other documents released under
this License, under the terms deﬁned in section 4 above for modiﬁed
versions, provided that you include in the combination all of the Invari-
ant Sections of all of the original documents, unmodiﬁed, and list them
all as Invariant Sections of your combined work in its license notice.
The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single copy.
If there are multiple Invariant Sections with the same name but diﬀerent
contents, make the title of each such section unique by adding at the end
of it, in parentheses, the name of the original author or publisher of that
section if known, or else a unique number. Make the same adjustment
to the section titles in the list of Invariant Sections in the license notice
of the combined work.
In the combination, you must combine any sections entitled “History”
in the various original documents, forming one section entitled “His-
tory”; likewise combine any sections entitled “Acknowledgments”, and
any sections entitled “Dedications”. You must delete all sections enti-
tled “Endorsements.”
6. COLLECTIONS OF DOCUMENTS
You may make a collection consisting of the Document and other docu-
ments released under this License, and replace the individual copies of
this License in the various documents with a single copy that is included
in the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

284
Appendix D: GNU Free Documentation License
You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all other
respects regarding verbatim copying of that document.
7. AGGREGATION WITH INDEPENDENT WORKS
A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage
or distribution medium, does not as a whole count as a Modiﬁed Ver-
sion of the Document, provided no compilation copyright is claimed for
the compilation. Such a compilation is called an “aggregate”, and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they are
not themselves derivative works of the Document.
If the Cover Text requirement of section 3 is applicable to these copies
of the Document, then if the Document is less than one quarter of the
entire aggregate, the Document’s Cover Texts may be placed on covers
that surround only the Document within the aggregate. Otherwise they
must appear on covers around the whole aggregate.
8. TRANSLATION
Translation is considered a kind of modiﬁcation, so you may distribute
translations of the Document under the terms of section 4. Replacing
Invariant Sections with translations requires special permission from
their copyright holders, but you may include translations of some or all
Invariant Sections in addition to the original versions of these Invariant
Sections. You may include a translation of this License provided that
you also include the original English version of this License. In case of
a disagreement between the translation and the original English version
of this License, the original English version will prevail.
9. TERMINATION
You may not copy, modify, sublicense, or distribute the Document ex-
cept as expressly provided for under this License. Any other attempt
to copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License. However, par-
ties who have received copies, or rights, from you under this License will
not have their licenses terminated so long as such parties remain in full
compliance.
10. FUTURE REVISIONS OF THIS LICENSE
The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.
Such
new versions will be similar in spirit to the present version, but
may diﬀer in detail to address new problems or concerns.
See
http://www.gnu.org/copyleft/.
Each version of the License is given a distinguishing version number.
If the Document speciﬁes that a particular numbered version of this

GNU Free Documentation License
285
License “or any later version” applies to it, you have the option of
following the terms and conditions either of that speciﬁed version or
of any later version that has been published (not as a draft) by the
Free Software Foundation. If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.

286
Appendix D: GNU Free Documentation License

Index
287
Index
%
% (remainder function) . . . . . . . . . . . . . . 258
(
(debug) in code . . . . . . . . . . . . . . . . . . . . 235
*
* (multiplication) . . . . . . . . . . . . . . . . . . . . 31
* for read-only buﬀer. . . . . . . . . . . . . . . . . 65
‘*scratch*’ buﬀer . . . . . . . . . . . . . . . . . . 123
.
‘.emacs’ ﬁle . . . . . . . . . . . . . . . . . . . . . . . . 213
‘.emacs’ ﬁle, beginning of . . . . . . . . . . . 216
/
/ (division). . . . . . . . . . . . . . . . . . . . . . . . . . 72
>
> (greater than). . . . . . . . . . . . . . . . . . . . 40
<
<= (less than or equal) . . . . . . . . . . . . . . 127
A
Accumulate, type of recursive pattern
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
add-hook. . . . . . . . . . . . . . . . . . . . . . . . . . . 218
and. . . . . . . . . . . . . . . . . . . . . . . . . . . . 108, 156
and, introduced . . . . . . . . . . . . . . . . . . . . 108
Anonymous function . . . . . . . . . . . . . . . . 272
append-to-buffer . . . . . . . . . . . . . . . . . . . 56
apply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
apropos. . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
Argument as local variable . . . . . . . . . . 131
‘argument’ deﬁned . . . . . . . . . . . . . . . . . . . 12
‘argument list’ deﬁned . . . . . . . . . . . . . . 30
Argument, wrong type of . . . . . . . . . . . . . 14
Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . 12
Arguments’ data types . . . . . . . . . . . . . . . 13
Arguments, variable number of. . . . . . . . 14
Asterisk for read-only buﬀer . . . . . . . . . . 65
Auto Fill mode turned on . . . . . . . . . . . 218
autoload. . . . . . . . . . . . . . . . . . . . . . . . . . . 223
Automatic mode selection . . . . . . . . . . . 218
Axis, print horizontal . . . . . . . . . . . . . . . 263
Axis, print vertical. . . . . . . . . . . . . . . . . . 256
B
beginning-of-buffer. . . . . . . . . . . . . . . . 69
‘bind’ deﬁned . . . . . . . . . . . . . . . . . . . . . . . 17
‘body’ deﬁned . . . . . . . . . . . . . . . . . . . . . . . 30
Body of graph . . . . . . . . . . . . . . . . . . . . . . 203
Buﬀer size. . . . . . . . . . . . . . . . . . . . . . . . . . . 27
Buﬀer, history of word . . . . . . . . . . . . . . . 24
buffer-file-name . . . . . . . . . . . . . . . . . . . 23
buffer-menu, bound to key . . . . . . . . . 221
buffer-name . . . . . . . . . . . . . . . . . . . . . . . . 23
Bug, most insidious type . . . . . . . . . . . . 274
Building robots . . . . . . . . . . . . . . . . . . . . . 134
Building Tags in the Emacs sources . . 164
Byte compiling . . . . . . . . . . . . . . . . . . . . . . . 8
C
C language primitives . . . . . . . . . . . . . . . . 29
C, a digression into . . . . . . . . . . . . . . . . . . 98
‘call’ deﬁned . . . . . . . . . . . . . . . . . . . . . . . 27
cancel-debug-on-entry. . . . . . . . . . . . . 234
car, introduced . . . . . . . . . . . . . . . . . . . . . 81
cdr, introduced . . . . . . . . . . . . . . . . . . . . . 81
Changing a function deﬁnition . . . . . . . . 32
Chest of Drawers, metaphor for a symbol
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
Clipping text . . . . . . . . . . . . . . . . . . . . . . . . 89
Code installation . . . . . . . . . . . . . . . . . . . . 36
‘command’ deﬁned . . . . . . . . . . . . . . . . . . . . 23
Comments in Lisp code . . . . . . . . . . . . . . 32
Common Lisp. . . . . . . . . . . . . . . . . . . . . . . xiii
compare-windows . . . . . . . . . . . . . . . . . . . 220
concat . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
cond . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
condition-case . . . . . . . . . . . . . . . . . . . . . 95

288
Index
Conditional ’twixt two versions of Emacs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
Conditional with if . . . . . . . . . . . . . . . . . . 39
cons, example. . . . . . . . . . . . . . . . . . . . . . 107
cons, introduced . . . . . . . . . . . . . . . . . . . . 83
copy-region-as-kill. . . . . . . . . . . . . . . 102
copy-to-buffer . . . . . . . . . . . . . . . . . . . . . 63
Count words recursively . . . . . . . . . . . . . 173
count-words-in-defun. . . . . . . . . . . . . . 185
count-words-region . . . . . . . . . . . . . . . . 167
Counting. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
Counting words in a defun . . . . . . 181, 183
current-buffer . . . . . . . . . . . . . . . . . . . . . 25
Customizing your ‘.emacs’ ﬁle . . . . . . . 213
Cutting and storing text. . . . . . . . . . . . . . 89
D
Data types . . . . . . . . . . . . . . . . . . . . . . . . . . 13
debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
debug-on-entry . . . . . . . . . . . . . . . . . . . . 232
debug-on-quit . . . . . . . . . . . . . . . . . . . . . 234
debugging . . . . . . . . . . . . . . . . . . . . . . . . . . 231
default-mode-line-format . . . . . . . . . 228
‘default.el’ init ﬁle . . . . . . . . . . . . . . . . 213
defcustom . . . . . . . . . . . . . . . . . . . . . . . . . 214
Deferment in recursion . . . . . . . . . . . . . . 143
Defermentless solution . . . . . . . . . . . . . . 145
Deﬁnition installation . . . . . . . . . . . . . . . . 31
Deﬁnition writing . . . . . . . . . . . . . . . . . . . . 29
Deﬁnition, how to change. . . . . . . . . . . . . 32
defun . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
defvar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
defvar for a user customizable variable
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
defvar with an asterisk . . . . . . . . . . . . . 101
delete-and-extract-region . . . . . . 96, 98
Deleting text . . . . . . . . . . . . . . . . . . . . . . . . 89
describe-function . . . . . . . . . . . . . . . . . . 53
describe-function, introduced . . . . . . 51
Digression into C . . . . . . . . . . . . . . . . . . . . 98
directory-files . . . . . . . . . . . . . . . . . . . 194
Division. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
dolist. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
dotimes. . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
Drawers, Chest of, metaphor for a symbol
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
Duplicated words function . . . . . . . . . . . 241
E
edebug. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
edit-options . . . . . . . . . . . . . . . . . . . . . . 101
Else . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Emacs version, choosing . . . . . . . . . . . . . 225
‘empty list’ deﬁned . . . . . . . . . . . . . . . . . . 2
‘empty string’ deﬁned . . . . . . . . . . . . . . . 48
eobp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
eq (example of use) . . . . . . . . . . . . . . . . . 104
equal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
Erasing text . . . . . . . . . . . . . . . . . . . . . . . . . 89
error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
Error for symbol without function. . . . . 11
Error for symbol without value . . . . . . . 11
Error message generation . . . . . . . . . . . . . . 4
etags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
‘evaluate’ deﬁned . . . . . . . . . . . . . . . . . . . . 4
Evaluating inner lists. . . . . . . . . . . . . . . . . . 9
Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
Evaluation practice . . . . . . . . . . . . . . . . . . 23
Every, type of recursive pattern . . . . . . 141
Example variable, fill-column . . . . . . . 10
‘expression’ deﬁned . . . . . . . . . . . . . . . . . . 2
F
Falsehood and truth in Emacs Lisp. . . . 43
FDL, GNU Free Documentation License
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
files-in-below-directory . . . . . . . . . 194
fill-column, an example variable . . . . 10
Find a File . . . . . . . . . . . . . . . . . . . . . . . . . 187
Find function documentation . . . . . . . . . 51
Find source of function . . . . . . . . . . . . . . . 51
find-tags. . . . . . . . . . . . . . . . . . . . . . . . . . . 51
Flowers in a ﬁeld . . . . . . . . . . . . . . . . . . . . . 1
Focusing attention (narrowing) . . . . . . . 77
‘form’ deﬁned. . . . . . . . . . . . . . . . . . . . . . . . . 2
Formatting convention . . . . . . . . . . . . . . . 58
Formatting help . . . . . . . . . . . . . . . . . . . . . . 3
forward-paragraph . . . . . . . . . . . . . . . . . 155
forward-sentence . . . . . . . . . . . . . . . . . . 151
‘function’ deﬁned . . . . . . . . . . . . . . . . . . 5, 6
‘function definition’ deﬁned. . . . . . . . 29
Function deﬁnition installation. . . . . . . . 31
Function deﬁnition writing . . . . . . . . . . . 29
Function deﬁnition, how to change . . . . 32
Functions, primitive. . . . . . . . . . . . . . . . . . 29

Index
289
G
Generate an error message. . . . . . . . . . . . . 4
Getting a buﬀer . . . . . . . . . . . . . . . . . . . . . 25
Global set key . . . . . . . . . . . . . . . . . . . . . . 220
global-set-key . . . . . . . . . . . . . . . . . . . . 220
global-unset-key . . . . . . . . . . . . . . . . . . 221
Graph prototype. . . . . . . . . . . . . . . . . . . . 203
Graph, printing all. . . . . . . . . . . . . . . . . . 267
graph-body-print . . . . . . . . . . . . . . . . . . 208
graph-body-print Final version.. . . . . 268
H
Handling the kill ring . . . . . . . . . . . . . . . 243
Help typing lists . . . . . . . . . . . . . . . . . . . . . . 3
Horizontal axis printing . . . . . . . . . . . . . 263
I
if . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
‘if-part’ deﬁned . . . . . . . . . . . . . . . . . . . . 40
indent-tabs-mode . . . . . . . . . . . . . . . . . . 219
Indentation for formatting . . . . . . . . . . . . 58
Initialization ﬁle . . . . . . . . . . . . . . . . . . . . 213
Initializing a variable. . . . . . . . . . . . . . . . 100
Inner list evaluation. . . . . . . . . . . . . . . . . . . 9
insert-buffer . . . . . . . . . . . . . . . . . . . . . . 64
insert-buffer-substring . . . . . . . . . . . 56
Insidious type of bug. . . . . . . . . . . . . . . . 274
Install a Function Deﬁnition . . . . . . . . . . 31
Install code permanently . . . . . . . . . . . . . 36
interactive . . . . . . . . . . . . . . . . . . . . . . . . 33
‘interactive function’ deﬁned. . . . . . . 23
Interactive functions . . . . . . . . . . . . . . . . . 33
Interactive options . . . . . . . . . . . . . . . . . . . 35
interactive, example use of . . . . . . . . . 65
Interpreter, Lisp, explained . . . . . . . . . . . . 4
Interpreter, what it does. . . . . . . . . . . . . . . 7
K
Keep, type of recursive pattern . . . . . . 143
Key setting globally. . . . . . . . . . . . . . . . . 220
Key unbinding. . . . . . . . . . . . . . . . . . . . . . 221
Keymaps. . . . . . . . . . . . . . . . . . . . . . . . . . . 221
Keyword . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Kill ring handling. . . . . . . . . . . . . . . . . . . 243
Kill ring overview. . . . . . . . . . . . . . . . . . . 117
kill-append . . . . . . . . . . . . . . . . . . . . . . . 104
kill-new. . . . . . . . . . . . . . . . . . . . . . . . . . . 105
kill-region . . . . . . . . . . . . . . . . . . . . . . . . 94
Killing text. . . . . . . . . . . . . . . . . . . . . . . . . . 89
L
lambda. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
lengths-list-file . . . . . . . . . . . . . . . . . 188
lengths-list-many-files . . . . . . . . . . 190
let . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
let expression sample . . . . . . . . . . . . . . . . 38
let expression, parts of . . . . . . . . . . . . . . 37
let variables uninitialized . . . . . . . . . . . . 39
Library, as term for ‘ﬁle’ . . . . . . . . . . . . . 52
line-to-top-of-window. . . . . . . . . . . . . 224
Lisp Atoms. . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Lisp history . . . . . . . . . . . . . . . . . . . . . . . . xiii
Lisp interpreter, explained . . . . . . . . . . . . . 4
Lisp interpreter, what it does . . . . . . . . . . 7
Lisp Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Lisp macro . . . . . . . . . . . . . . . . . . . . . . . . . . 97
list-buffers, rebound . . . . . . . . . . . . . 221
Lists in a computer . . . . . . . . . . . . . . . . . 113
load-library . . . . . . . . . . . . . . . . . . . . . . 223
load-path . . . . . . . . . . . . . . . . . . . . . . . . . 223
Loading ﬁles. . . . . . . . . . . . . . . . . . . . . . . . 222
‘local variable’ deﬁned . . . . . . . . . . . . . 37
Local variables list, per-buﬀer, . . . . . . . 218
Location of point . . . . . . . . . . . . . . . . . . . . 27
looking-at . . . . . . . . . . . . . . . . . . . . . . . . 159
Loops. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
Loops and recursion. . . . . . . . . . . . . . . . . 121
M
Maclisp . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Macro, lisp . . . . . . . . . . . . . . . . . . . . . . . . . . 97
Mail aliases . . . . . . . . . . . . . . . . . . . . . . . . 219
make tags . . . . . . . . . . . . . . . . . . . . . . . . . . 164
make-string . . . . . . . . . . . . . . . . . . . . . . . 261
mapcar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
mark . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
mark-whole-buffer . . . . . . . . . . . . . . . . . . 54
match-beginning . . . . . . . . . . . . . . . . . . . 161
max . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
message. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
min . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
Mode line format . . . . . . . . . . . . . . . . . . . 228

290
Index
Mode selection, automatic . . . . . . . . . . . 218
Motion by sentence and paragraph . . . 149
N
Narrowing. . . . . . . . . . . . . . . . . . . . . . . . . . . 77
‘narrowing’ deﬁned . . . . . . . . . . . . . . . . . . 28
nil . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
nil, history of word. . . . . . . . . . . . . . . . . . 24
No deferment solution. . . . . . . . . . . . . . . 145
nreverse. . . . . . . . . . . . . . . . . . . . . . . . . . . 199
nth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
nthcdr . . . . . . . . . . . . . . . . . . . . . . . . . 85, 102
nthcdr, example . . . . . . . . . . . . . . . . . . . 107
number-to-string . . . . . . . . . . . . . . . . . . 259
O
occur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
optional. . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
Optional arguments . . . . . . . . . . . . . . . . . . 70
Options for interactive . . . . . . . . . . . . . 35
or . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
other-buffer . . . . . . . . . . . . . . . . . . . . . . . 25
P
Paragraphs, movement by . . . . . . . . . . . 149
Parts of a Recursive Deﬁnition. . . . . . . 135
Parts of let expression . . . . . . . . . . . . . . . 37
Passing information to functions . . . . . . 12
Pasting text . . . . . . . . . . . . . . . . . . . . . . . . 117
Patterns, searching for . . . . . . . . . . . . . . 149
Per-buﬀer, local variables list . . . . . . . . 218
Permanent code installation . . . . . . . . . . 36
point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
‘point’ deﬁned . . . . . . . . . . . . . . . . . . . . . . 27
Point location . . . . . . . . . . . . . . . . . . . . . . . 27
Point, mark, buﬀer preservation. . . . . . . 44
Practicing evaluation. . . . . . . . . . . . . . . . . 23
Preserving point, mark, and buﬀer . . . . 44
Primitive functions. . . . . . . . . . . . . . . . . . . 29
Primitives written in C. . . . . . . . . . . . . . . 29
Print horizontal axis . . . . . . . . . . . . . . . . 263
Print vertical axis. . . . . . . . . . . . . . . . . . . 256
print-elements-of-list . . . . . . . . . . . 123
print-elements-recursively . . . . . . . 136
print-graph Final version. . . . . . . . . . . 269
print-graph varlist . . . . . . . . . . . . . . . . . 256
print-X-axis . . . . . . . . . . . . . . . . . . . . . . 266
print-X-axis-numbered-line . . . . . . . 265
print-X-axis-tic-line. . . . . . . . . . . . . 265
print-Y-axis . . . . . . . . . . . . . . . . . . . . . . 262
Printing the whole graph . . . . . . . . . . . . 267
prog1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
progn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
Program, running one . . . . . . . . . . . . . . . . . 4
Prototype graph . . . . . . . . . . . . . . . . . . . . 203
R
re-search-forward . . . . . . . . . . . . . . . . . 150
Read-only buﬀer . . . . . . . . . . . . . . . . . . . . . 65
Readying a graph . . . . . . . . . . . . . . . . . . . 203
Rebinding keys . . . . . . . . . . . . . . . . . . . . . 221
Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . 134
Recursion and loops. . . . . . . . . . . . . . . . . 121
Recursion without Deferments . . . . . . . 143
Recursive Deﬁnition Parts . . . . . . . . . . . 135
Recursive pattern: accumulate . . . . . . . 142
Recursive pattern: every . . . . . . . . . . . . 141
Recursive pattern: keep . . . . . . . . . . . . . 143
Recursive Patterns . . . . . . . . . . . . . . . . . . 140
recursive-count-words. . . . . . . . . . . . . 178
recursive-graph-body-print . . . . . . . 210
recursive-lengths-list-many-files
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
Recursively counting words . . . . . . . . . . 173
regexp-quote . . . . . . . . . . . . . . . . . . . . . . 157
Region, what it is . . . . . . . . . . . . . . . . . . . . 44
Regular expression searches. . . . . . . . . . 149
Regular expressions for word counting
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
Remainder function, %. . . . . . . . . . . . . . . 258
Repetition (loops) . . . . . . . . . . . . . . . . . . 121
Repetition for word counting . . . . . . . . 167
Retrieving text . . . . . . . . . . . . . . . . . . . . . 117
reverse. . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
Ring, making a list like a . . . . . . . . . . . . 243
Robots, building . . . . . . . . . . . . . . . . . . . . 134
rotate-yank-pointer . . . . . . . . . . 117, 243
Run a program . . . . . . . . . . . . . . . . . . . . . . . 4

Index
291
S
Sample let expression . . . . . . . . . . . . . . . 38
save-excursion . . . . . . . . . . . . . . . . . . . . . 44
save-restriction . . . . . . . . . . . . . . . . . . . 77
search-forward . . . . . . . . . . . . . . . . . . . . . 92
Searches, illustrating . . . . . . . . . . . . . . . . 149
sentence-end . . . . . . . . . . . . . . . . . . . . . . 149
Sentences, movement by. . . . . . . . . . . . . 149
set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
set-buffer . . . . . . . . . . . . . . . . . . . . . . . . . 26
setcar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
setcdr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
setcdr, example . . . . . . . . . . . . . . . . . . . 107
setq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
Setting a key globally . . . . . . . . . . . . . . . 220
Setting value of variable . . . . . . . . . . . . . . 17
‘side effect’ deﬁned . . . . . . . . . . . . . . . . . 8
Simple extension in ‘.emacs’ ﬁle . . . . . 224
simplified-beginning-of-buffer . . . . 52
‘site-init.el’ init ﬁle . . . . . . . . . . . . . . 213
‘site-load.el’ init ﬁle . . . . . . . . . . . . . . 213
Size of buﬀer . . . . . . . . . . . . . . . . . . . . . . . . 27
Solution without deferment . . . . . . . . . . 145
sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Source level debugger . . . . . . . . . . . . . . . 235
Special form . . . . . . . . . . . . . . . . . . . . . . . . . . 7
Special form of defun . . . . . . . . . . . . . . . . 29
Storing and cutting text . . . . . . . . . . . . . . 89
‘string’ deﬁned . . . . . . . . . . . . . . . . . . . . . . 3
switch-to-buffer . . . . . . . . . . . . . . . . . . . 26
Switching to a buﬀer . . . . . . . . . . . . . . . . . 26
Symbol names . . . . . . . . . . . . . . . . . . . . . . . . 6
Symbol without function error . . . . . . . . 11
Symbol without value error . . . . . . . . . . . 11
Symbolic expressions, introduced. . . . . . . 2
Symbols as a Chest of Drawers. . . . . . . 115
Syntax categories and tables . . . . . . . . . 182
T
Tabs, preventing . . . . . . . . . . . . . . . . . . . . 219
‘TAGS’ ﬁle, create own . . . . . . . . . . . . . . . 163
Tags in the Emacs sources . . . . . . . . . . . 164
TAGS table, specifying . . . . . . . . . . . . . . . 51
Text between double quotation marks . . 3
Text Mode turned on . . . . . . . . . . . . . . . 218
Text retrieval. . . . . . . . . . . . . . . . . . . . . . . 117
the-the. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
‘then-part’ deﬁned . . . . . . . . . . . . . . . . . . 40
top-of-ranges . . . . . . . . . . . . . . . . . . . . . 198
triangle-bugged . . . . . . . . . . . . . . . . . . . 231
triangle-recursively. . . . . . . . . . . . . . 137
Truth and falsehood in Emacs Lisp. . . . 43
Types of data . . . . . . . . . . . . . . . . . . . . . . . 13
U
Unbinding key. . . . . . . . . . . . . . . . . . . . . . 221
Uninitialized let variables. . . . . . . . . . . . 39
V
Variable initialization . . . . . . . . . . . . . . . 100
Variable number of arguments . . . . . . . . 14
Variable, example of, fill-column . . . . 10
Variable, setting value. . . . . . . . . . . . . . . . 17
Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
‘varlist’ deﬁned . . . . . . . . . . . . . . . . . . . . 37
Version of Emacs, choosing . . . . . . . . . . 225
Vertical axis printing. . . . . . . . . . . . . . . . 256
W
what-line. . . . . . . . . . . . . . . . . . . . . . . . . . . 78
while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
Whitespace in lists . . . . . . . . . . . . . . . . . . . . 3
Whole graph printing . . . . . . . . . . . . . . . 267
Widening . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Widening, example of . . . . . . . . . . . . . . . . 78
Word counting in a defun . . . . . . . . . . . 181
Words and symbols in defun . . . . . . . . . 181
Words, counted recursively . . . . . . . . . . 173
Words, duplicated . . . . . . . . . . . . . . . . . . 241
Writing a function deﬁnition . . . . . . . . . . 29
Wrong type of argument. . . . . . . . . . . . . . 14
X
X axis printing . . . . . . . . . . . . . . . . . . . . . 263
X-axis-element . . . . . . . . . . . . . . . . . . . . 265
Y
Y axis printing . . . . . . . . . . . . . . . . . . . . . 256
Y-axis-column . . . . . . . . . . . . . . . . . . . . . 261
Y-axis-column Final version. . . . . . . . . 268
Y-axis-label-spacing. . . . . . . . . . . . . . 259
Y-axis-tic . . . . . . . . . . . . . . . . . . . . . . . . 260

292
Index
yank . . . . . . . . . . . . . . . . . . . . . . . . . . 117, 249
yank-pop. . . . . . . . . . . . . . . . . . . . . . . . . . . 252
Z
zap-to-char . . . . . . . . . . . . . . . . . . . . . . . . 90
zerop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244



About the Author
Robert J. Chassell has worked with GNU Emacs since 1985. He
writes and edits, teaches Emacs and Emacs Lisp, and speaks
throughout the world on software freedom. Chassell was a found-
ing Director and Treasurer of the Free Software Foundation, Inc.
He is co-author of the Texinfo manual, and has edited more than
a dozen other books. He graduated from Cambridge University, in
England. He has an abiding interest in social and economic history
and ﬂies his own airplane.


