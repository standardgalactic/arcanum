Querying Semantic Web Data with SPARQL:
State of the Art and Research Perspectives
Marcelo Arenas1 and Jorge P´erez2
1 Pontiﬁcia Universidad Cat´olica de Chile
2 Universidad de Chile
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
1 / 91

Semantic Web
“The Semantic Web is an extension of the current web in which
information is given well-deﬁned meaning, better enabling
computers and people to work in cooperation.”
[Tim Berners-Lee et al. 2001.]
Speciﬁc goals:
◮Build a description language with standard semantics
◮Make semantics machine-processable and understandable
◮Incorporate logical infrastructure to reason about resources
◮W3C proposals: Resource Description Framework (RDF) and
SPARQL
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
2 / 91

RDF in a nutshell
RDF is the framework proposed by the W3C to represent
information in the Web:
◮URI vocabulary
◮A URI is an atomic piece of data, and it identiﬁes an abstract
resource
◮Syntax based on directed labeled graphs
◮URIs are used as node labels and edge labels
◮Schema deﬁnition language (RDFS): Deﬁne new vocabulary
◮Typing, inheritance of classes and properties, . . .
◮Formal semantics
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
3 / 91

An example of an RDF graph: DBLP
inPods:FaginLN01
:Moni Naor
:Amnon Lotem
:Ronald Fagin
inPods:2001
"Optimal Aggregation ..."
dc:creator
dc:creator
dc:creator
dct:PartOf
dc:title
swrc:series
conf:pods
<http://purl.org/dc/terms/>
: <http://dblp.l3s.de/d2r/resource/authors/>
conf: <http://dblp.l3s.de/d2r/resource/conferences/>
inPods: <http://dblp.l3s.de/d2r/resource/publications/conf/pods/>
swrc: <http://swrc.ontoware.org/ontology#>
dc:
dct:
<http://purl.org/dc/elements/1.1/>
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
4 / 91

An example of a URI
http://dblp.l3s.de/d2r/resource/conferences/pods
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
5 / 91

URI can be used for any abstract resource
http://dblp.l3s.de/d2r/page/authors/Ronald Fagin
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
6 / 91

Querying RDF
Why is this an interesting problem? Why is it challenging?
◮RDF graphs can be interconnected
◮URIs should be dereferenceable
◮Semantics of RDF is open world
◮RDF graphs are inherently incomplete
◮The possibility of adding optional information if present is an
important feature
◮Vocabulary with predeﬁned semantics
◮Navigational capabilities are needed
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
7 / 91

Querying RDF: SPARQL
◮SPARQL is the W3C recommendation query language for
RDF (January 2008).
◮SPARQL is a recursive acronym that stands for SPARQL
Protocol and RDF Query Language
◮SPARQL is a graph-matching query language.
◮A SPARQL query consists of three parts:
◮Pattern matching: optional, union, ﬁltering, . . .
◮Solution modiﬁers: projection, distinct, order, limit, oﬀset, . . .
◮Output part: construction of new triples, . . ..
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
8 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
A SPARQL query consists of a:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
A SPARQL query consists of a:
Body: Pattern matching expression
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

SPARQL in a nutshell
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
A SPARQL query consists of a:
Body: Pattern matching expression
Head: Processing of the variables
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
9 / 91

What are the challenges in implementing SPARQL?
SPARQL has to take into account the distinctive features of RDF:
◮Should be able to extract information from interconnected
RDF graphs
◮Should be consistent with the open-world semantics of RDF
◮Should oﬀer the possibility of adding optional information if
present
◮Should be able to properly interpret RDF graphs with a
vocabulary with predeﬁned semantics
◮Should oﬀer some functionalities for navigating in an RDF
graph
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
10 / 91

What are the challenges in implementing SPARQL?
SPARQL has to take into account the distinctive features of RDF:
◮Should be able to extract information from interconnected
RDF graphs
◮Should be consistent with the open-world semantics of RDF
◮Should oﬀer the possibility of adding optional information if
present
◮Should be able to properly interpret RDF graphs with a
vocabulary with predeﬁned semantics
◮Should oﬀer some functionalities for navigating in an RDF
graph
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
10 / 91

Extracting information from interconnected RDF graphs
DBpedia
DBLP
inPods:FaginLN01
:Ronald Fagin
dbpedia:Ronald Fagin
dbpedia:Oklahoma
yago:ResearchWorker
dc:creator
owl:sameAs
dbo:birthPlace
rdf:type
rdfs:subClassOf
yago:DatabaseResearchers
<http://dbpedia.org/ontology/>
<http://www.w3.org/2000/01/rdf-schema#>
owl:
rdfs:
<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
rdf:
<http://dbpedia.org/resource/>
dbpedia:
yago: <http://dbpedia.org/class/yago>
: <http://dblp.l3s.de/d2r/resource/authors/>
dbo:
<http://www.w3.org/2002/07/owl#>
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
11 / 91

Dereferenceable URIs are the glue
http://dbpedia.org/resource/Ronald Fagin
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
12 / 91

Querying interconnected RDF graphs
Retrieve the authors that have published in PODS and were born
in Oklahoma:
SELECT ?Author
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
?Person
owl:sameAs
?Author .
?Person
dbo:birthPlace dbpedia:Oklahoma .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
13 / 91

Retrieving optional information
Retrieve the authors that have published in PODS, and their Web
pages if this information is available:
SELECT ?Author ?WebPage
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
OPTIONAL { ?Author
foaf:homePage
?WebPage . }
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
14 / 91

Taking into account vocabularies with predeﬁned semantics
Retrieve the scientists that were born in Oklahoma and that have
published in PODS:
SELECT ?Author
WHERE
{
?Author
rdf:type
yago:Scientist .
?Author
dbo:birthPlace dbpedia:Oklahoma .
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
15 / 91

Taking into account vocabularies with predeﬁned semantics
Retrieve the scientists that were born in Oklahoma and that have
published in PODS:
dbpedia:Oklahoma
yago:ResearchWorker
dbpedia:Ronald Fagin
yago:DatabaseResearchers
yago:Scientist
rdfs:subClassOf
dbo:birthPlace
rdf:type
rdfs:subClassOf
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
16 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
17 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
18 / 91

RDF formal model
Subject
Object
Predicate
L
B
U
U
U
B
U
:
set of URIs
B
:
set of blank nodes
L
:
set of literals
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
19 / 91

RDF formal model
Subject
Object
Predicate
L
B
U
U
U
B
U
:
set of URIs
B
:
set of blank nodes
L
:
set of literals
(s, p, o) ∈(U ∪B) × U × (U ∪B ∪L) is called an RDF triple
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
19 / 91

RDF formal model
Subject
Object
Predicate
L
B
U
U
U
B
U
:
set of URIs
B
:
set of blank nodes
L
:
set of literals
(s, p, o) ∈(U ∪B) × U × (U ∪B ∪L) is called an RDF triple
A set of RDF triples is called an RDF graph
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
19 / 91

RDF formal model
Proviso
In this talk, we do not consider blank nodes
◮(s, p, o) ∈U × U × (U ∪L) is called an RDF triple
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
20 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
21 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ P1
P2 }
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ { P1
P2 }
{ P3
P4 }
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ { P1
P2
OPTIONAL { P5 }
}
{ P3
P4
OPTIONAL { P7 }
}
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ { P1
P2
OPTIONAL { P5 }
}
{ P3
P4
OPTIONAL { P7
OPTIONAL { P8 }
}
}
}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ { P1
P2
OPTIONAL { P5 }
}
{ P3
P4
OPTIONAL { P7
OPTIONAL { P8 }
}
}
}
UNION
{ P9 }
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ { P1
P2
OPTIONAL { P5 }
}
{ P3
P4
OPTIONAL { P7
OPTIONAL { P8 }
}
}
}
UNION
{ P9
FILTER ( R ) }
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

SPARQL queries can be complex
Interesting features:
◮Grouping
◮Optional parts
◮Nesting
◮Union of patterns
◮Filtering
{ { P1
P2
OPTIONAL { P5 }
}
{ P3
P4
OPTIONAL { P7
OPTIONAL { P8 }
}
}
}
UNION
{ P9
FILTER ( R ) }
We focus on the body of SPARQL queries: Pattern matching
expressions
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
22 / 91

A standard algebraic syntax
◮Triple patterns: triples including variables from a set V
?X :name "john"
(?X, name, john)
◮Graph patterns: full parenthesized algebra
{
P1
P2
}
( P1 AND P2 )
{ P1 OPTIONAL { P2 }}
( P1 OPT P2 )
{
P1 } UNION { P2 }
( P1 UNION P2 )
{
P1 FILTER ( R ) }
( P1 FILTER R )
original SPARQL syntax
algebraic syntax
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
23 / 91

A standard algebraic syntax
◮Explicit precedence/association
Example
{ t1
t2
OPTIONAL { t3 }
OPTIONAL { t4 }
t5
}
( ( ( ( t1 AND t2 ) OPT t3 ) OPT t4 ) AND t5 )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
24 / 91

Mappings: building block for the semantics
Deﬁnition
A mapping is a partial function:
µ
:
V −→(U ∪L)
The evaluation of a graph pattern results in a set of mappings.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
25 / 91

Mappings: building block for the semantics
Deﬁnition
A mapping is a partial function:
µ
:
V −→(U ∪L)
The evaluation of a graph pattern results in a set of mappings.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
25 / 91

The semantics of triple patterns
Given an RDF graph G and a triple pattern t.
Deﬁnition
The evaluation of t over G is the set of mappings µ such that:
◮µ has as domain the variables in t: dom(µ) = var(t)
◮µ makes t to match the graph: µ(t) ∈G
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
26 / 91

The semantics of triple patterns
Given an RDF graph G and a triple pattern t.
Deﬁnition
The evaluation of t over G is the set of mappings µ such that:
◮µ has as domain the variables in t: dom(µ) = var(t)
◮µ makes t to match the graph: µ(t) ∈G
Example
graph
triple
evaluation
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
(?X, name, ?Y )
?X
?Y
µ1:
R1
john
µ2:
R2
paul
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
26 / 91

The semantics of triple patterns
Given an RDF graph G and a triple pattern t.
Deﬁnition
The evaluation of t over G is the set of mappings µ such that:
◮µ has as domain the variables in t: dom(µ) = var(t)
◮µ makes t to match the graph: µ(t) ∈G
Example
graph
triple
evaluation
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
(?X, name, ?Y )
?X
?Y
µ1:
R1
john
µ2:
R2
paul
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
26 / 91

The semantics of triple patterns
Given an RDF graph G and a triple pattern t.
Deﬁnition
The evaluation of t over G is the set of mappings µ such that:
◮µ has as domain the variables in t: dom(µ) = var(t)
◮µ makes t to match the graph: µ(t) ∈G
Example
graph
triple
evaluation
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
(?X, name, ?Y )
?X
?Y
µ1:
R1
john
µ2:
R2
paul
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
26 / 91

Compatible mappings
Deﬁnition
Mappings µ1 and µ2 are compatible if they agree in their common
variables:
If ?X ∈dom(µ1) ∩dom(µ2), then µ1(?X) = µ2(?X).
Example
?X
?Y
?Z
?V
µ1 :
R1
john
µ2 :
R1
J@edu.ex
µ3 :
P@edu.ex
R2
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
27 / 91

Compatible mappings
Deﬁnition
Mappings µ1 and µ2 are compatible if they agree in their common
variables:
If ?X ∈dom(µ1) ∩dom(µ2), then µ1(?X) = µ2(?X).
Example
?X
?Y
?Z
?V
µ1 :
R1
john
µ2 :
R1
J@edu.ex
µ3 :
P@edu.ex
R2
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
27 / 91

Compatible mappings
Deﬁnition
Mappings µ1 and µ2 are compatible if they agree in their common
variables:
If ?X ∈dom(µ1) ∩dom(µ2), then µ1(?X) = µ2(?X).
Example
?X
?Y
?Z
?V
µ1 :
R1
john
µ2 :
R1
J@edu.ex
µ3 :
P@edu.ex
R2
µ1 ∪µ2 :
R1
john
J@edu.ex
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
27 / 91

Compatible mappings
Deﬁnition
Mappings µ1 and µ2 are compatible if they agree in their common
variables:
If ?X ∈dom(µ1) ∩dom(µ2), then µ1(?X) = µ2(?X).
Example
?X
?Y
?Z
?V
µ1 :
R1
john
µ2 :
R1
J@edu.ex
µ3 :
P@edu.ex
R2
µ1 ∪µ2 :
R1
john
J@edu.ex
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
27 / 91

Compatible mappings
Deﬁnition
Mappings µ1 and µ2 are compatible if they agree in their common
variables:
If ?X ∈dom(µ1) ∩dom(µ2), then µ1(?X) = µ2(?X).
Example
?X
?Y
?Z
?V
µ1 :
R1
john
µ2 :
R1
J@edu.ex
µ3 :
P@edu.ex
R2
µ1 ∪µ2 :
R1
john
J@edu.ex
µ1 ∪µ3 :
R1
john
P@edu.ex
R2
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
27 / 91

Compatible mappings
Deﬁnition
Mappings µ1 and µ2 are compatible if they agree in their common
variables:
If ?X ∈dom(µ1) ∩dom(µ2), then µ1(?X) = µ2(?X).
Example
?X
?Y
?Z
?V
µ1 :
R1
john
µ2 :
R1
J@edu.ex
µ3 :
P@edu.ex
R2
µ1 ∪µ2 :
R1
john
J@edu.ex
µ1 ∪µ3 :
R1
john
P@edu.ex
R2
◮µ2 and µ3 are not compatible
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
27 / 91

Sets of mappings and operations
Let Ω1 and Ω2 be sets of mappings.
Deﬁnition
Join: extends mappings in Ω1 with compatible mappings in Ω2
◮Ω1
Ω2 = {µ1 ∪µ2 | µ1 ∈Ω1, µ2 ∈Ω2 and µ1, µ2 are
compatible}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
28 / 91

Sets of mappings and operations
Let Ω1 and Ω2 be sets of mappings.
Deﬁnition
Join: extends mappings in Ω1 with compatible mappings in Ω2
◮Ω1
Ω2 = {µ1 ∪µ2 | µ1 ∈Ω1, µ2 ∈Ω2 and µ1, µ2 are
compatible}
Diﬀerence: selects mappings in Ω1 that cannot be extended with
mappings in Ω2
◮Ω1 ∖Ω2 = {µ1 ∈Ω1 | there is no mapping in Ω2 compatible
with µ1}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
28 / 91

Sets of mappings and operations
Deﬁnition
Union: includes mappings in Ω1 and in Ω2
◮Ω1 ∪Ω2 = {µ | µ ∈Ω1 or µ ∈Ω2}
Left Outer Join: extends mappings in Ω1 with compatible
mappings in Ω2 if possible
◮Ω1
Ω2 = (Ω1
Ω2) ∪(Ω1 ∖Ω2)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
29 / 91

Semantics of SPARQL
Given an RDF graph G.
Deﬁnition
JtKG
=
JP1 AND P2KG
=
JP1 UNION P2KG
=
JP1 OPT P2KG
=
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
30 / 91

Semantics of SPARQL
Given an RDF graph G.
Deﬁnition
JtKG
=
{µ | dom(µ) = var(t) and µ(t) ∈G}
JP1 AND P2KG
=
JP1KG
JP2KG
JP1 UNION P2KG
=
JP1KG ∪JP2KG
JP1 OPT P2KG
=
JP1KG
JP2KG
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
30 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
?X
?E
R1
J@ed.ex
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
?X
?E
R1
J@ed.ex
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
?X
?Y
?E
R1
john
J@ed.ex
R2
paul
?X
?E
R1
J@ed.ex
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
?X
?Y
?E
R1
john
J@ed.ex
R2
paul
?X
?E
R1
J@ed.ex
◮from the Join
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
?X
?Y
?E
R1
john
J@ed.ex
R2
paul
?X
?E
R1
J@ed.ex
◮from the Diﬀerence
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Semantics of SPARQL: An example
Example
(R1, name, john)
(R1, email, J@ed.ex)
(R2, name, paul)
( (?X, name, ?Y ) OPT (?X, email, ?E) )
?X
?Y
R1
john
R2
paul
?X
?Y
?E
R1
john
J@ed.ex
R2
paul
?X
?E
R1
J@ed.ex
◮from the Union
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
31 / 91

Filter expressions (value constraints)
Filter expression: P FILTER R
◮P is a graph pattern
◮R is a built-in condition
We consider in R:
◮equality = among variables and RDF terms
◮unary predicate bound
◮boolean combinations (∧, ∨, ¬)
We impose a safety condition: var(R) ⊆var(P)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
32 / 91

Satisfaction of value constraints
A mapping µ satisﬁes a condition R (µ |= R) if:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
33 / 91

Satisfaction of value constraints
A mapping µ satisﬁes a condition R (µ |= R) if:
◮R is ?X = c, ?X ∈dom(µ) and µ(?X) = c
◮R is ?X =?Y , ?X, ?Y ∈dom(µ) and µ(?X) = µ(?Y )
◮R is bound(?X) and ?X ∈dom(µ)
◮. . .
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
33 / 91

Satisfaction of value constraints
A mapping µ satisﬁes a condition R (µ |= R) if:
◮R is ?X = c, ?X ∈dom(µ) and µ(?X) = c
◮R is ?X =?Y , ?X, ?Y ∈dom(µ) and µ(?X) = µ(?Y )
◮R is bound(?X) and ?X ∈dom(µ)
◮. . .
Deﬁnition
FILTER : selects mappings that satisfy a condition
JP FILTER RKG
=
{µ ∈JPKG | µ |= R}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
33 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
34 / 91

The evaluation problem
Input:
A mapping µ, a graph pattern P, and an RDF graph G
Question:
Does µ belong to the evaluation of P over G?
Does µ ∈JPKG?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
35 / 91

The evaluation problem
Input:
A mapping µ, a graph pattern P, and an RDF graph G
Question:
Does µ belong to the evaluation of P over G?
Does µ ∈JPKG?
We study the combined complexity of the evaluation problem.
◮µ, P and G are part of the input
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
35 / 91

Evaluation of simple patterns is polynomial
Theorem (P´erez, A. and Gutierrez 2006)
For patterns using only AND and FILTER operators (AND-FILTER
fragment), the evaluation problem is polynomial:
O(size of the pattern × size of the graph).
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
36 / 91

Evaluation of simple patterns is polynomial
Theorem (P´erez, A. and Gutierrez 2006)
For patterns using only AND and FILTER operators (AND-FILTER
fragment), the evaluation problem is polynomial:
O(size of the pattern × size of the graph).
Proof sketch
◮Check that the mapping makes every triple to match
◮Then check that the mapping satisﬁes the FILTERs
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
36 / 91

Evaluation including UNION is NP-complete
Theorem (P´erez, A. and Gutierrez 2006)
The evaluation problem is NP-complete for the
AND-FILTER-UNION fragment of SPARQL.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
37 / 91

Evaluation including UNION is NP-complete
Theorem (P´erez, A. and Gutierrez 2006)
The evaluation problem is NP-complete for the
AND-FILTER-UNION fragment of SPARQL.
Proof sketch of hardness
◮Reduction from 3SAT
◮¬ bound is used to verify that a satisfying truth assignment is
well deﬁned
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
37 / 91

In general: Evaluation problem is PSPACE-complete
Theorem (P´erez, A. and Gutierrez 2006, 2009)
The evaluation problem for SPARQL is PSPACE-complete.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
38 / 91

In general: Evaluation problem is PSPACE-complete
Theorem (P´erez, A. and Gutierrez 2006, 2009)
The evaluation problem for SPARQL is PSPACE-complete.
◮In fact, the evaluation problem remains PSPACE-hard for the
AND-FILTER-OPT fragment of SPARQL
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
38 / 91

In general: Evaluation problem is PSPACE-complete
Theorem (P´erez, A. and Gutierrez 2006, 2009)
The evaluation problem for SPARQL is PSPACE-complete.
◮In fact, the evaluation problem remains PSPACE-hard for the
AND-FILTER-OPT fragment of SPARQL
Theorem (Schmidt, Meier and Lausen 2010)
The evaluation problem remains PSPACE-complete for the OPT
fragment of SPARQL.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
38 / 91

What is the source of the high complexity?
The use of the OPT operator makes the evaluation problem
harder.
◮How can we deal with this operator? How can we reduce the
complexity?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
39 / 91

What is the source of the high complexity?
The use of the OPT operator makes the evaluation problem
harder.
◮How can we deal with this operator? How can we reduce the
complexity?
◮Later we will come back to this point
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
39 / 91

Research opportunities: SPARQL features under
development
A new version of SPARQL is under development: SPARQL 1.1
It includes new features like:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
40 / 91

Research opportunities: SPARQL features under
development
A new version of SPARQL is under development: SPARQL 1.1
It includes new features like:
◮Aggregates
◮Formal deﬁnition of the semantics
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
40 / 91

Research opportunities: SPARQL features under
development
A new version of SPARQL is under development: SPARQL 1.1
It includes new features like:
◮Aggregates
◮Formal deﬁnition of the semantics
◮An operator SERVICE to distribute the execution of a query
◮Safety issues: (SERVICE ?X P)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
40 / 91

Research opportunities: SPARQL features under
development
A new version of SPARQL is under development: SPARQL 1.1
It includes new features like:
◮Aggregates
◮Formal deﬁnition of the semantics
◮An operator SERVICE to distribute the execution of a query
◮Safety issues: (SERVICE ?X P)
◮Property paths based on regular expressions
◮Current semantics counts paths
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
40 / 91

SPARQL features under development
SELECT COUNT(DISTINCT ?Author)
WHERE
{
?Paper
dc:creator
?Author .
?Paper
dct:PartOf
?Conf .
?Conf
swrc:series
conf:pods .
}
This query can be executed in the DBLP SPARQL endpoint:
◮Answer: 969
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
41 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
42 / 91

Is SPARQL the right query language for RDF?
Semantics of RDF is open world.
Given an RDF graph G: We know that the triples in G hold
◮But we have no information about the triples that are not
included in G
If H is an RDF graph such that G ⊆H, then H is a possible
interpretation of G.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
43 / 91

Is the semantics of SPARQL appropriate for RDF
How can a query be answered over a graph with inﬁnitely many
interpretations?
◮Certain answer semantics is appropriate for this scenario
Certain answers of a graph pattern P over an RDF graph G:
CertainAnswers(P, G)
=
\
H : G⊆H
JPKH
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
44 / 91

Is the semantics of SPARQL appropriate for RDF
How can a query be answered over a graph with inﬁnitely many
interpretations?
◮Certain answer semantics is appropriate for this scenario
Certain answers of a graph pattern P over an RDF graph G:
CertainAnswers(P, G)
=
\
H : G⊆H
JPKH
We have two alternative semantics for SPARQL queries.
◮Is it true that JPKG = CertainAnswers(P, G)?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
44 / 91

Monotone queries are appropriate for RDF
A graph pattern P is monotone if:
For every pair G1, G2 of RDF graphs: G1 ⊆G2 ⇒JPKG1 ⊆JPKG2
Proposition
Every query in the AND-FILTER-UNION fragment of SPARQL is
monotone.
This fragment is positive.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
45 / 91

Monotone queries are appropriate for RDF
Corollary
Given a query P in the AND-FILTER-UNION fragment of
SPARQL and an RDF graph G:
JPKG
=
CertainAnswers(P, G)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
46 / 91

What about the OPT operator?
Is the OPT operator positive?
◮If this is the case, then SPARQL is appropriate for the
open-world semantics of RDF
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
47 / 91

What about the OPT operator?
Is the OPT operator positive?
◮If this is the case, then SPARQL is appropriate for the
open-world semantics of RDF
Graph patterns do not form a positive language!
◮We will see why . . .
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
47 / 91

Are graph patterns including the OPT operator monotone?
Notion of monotonicity is not appropriate for the OPT operator.
◮This operator can add information to a mapping
Given mappings µ1, µ2: µ1 is subsumed by µ2 (µ1 ⪯µ2) if
1. dom(µ1) ⊆dom(µ2)
2. µ1(?X) = µ2(?X) for every ?X ∈dom(µ1)
Given sets Ω1, Ω2 of mappings: Ω1 is subsumed by Ω2 (Ω1 ⊑Ω2)
if for every µ1 ∈Ω1, there exists µ2 ∈Ω2 such that µ1 ⪯µ2.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
48 / 91

Are graph patterns including the OPT operator monotone?
A graph pattern P is weakly monotone if:
For every pair G1, G2 of RDF graphs: G1 ⊆G2 ⇒JPKG1 ⊑JPKG2
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
49 / 91

Are graph patterns including the OPT operator monotone?
A graph pattern P is weakly monotone if:
For every pair G1, G2 of RDF graphs: G1 ⊆G2 ⇒JPKG1 ⊑JPKG2
Weakly monotone graph patterns are appropriate for the
open-world semantics of RDF:
Observation
If graph pattern P is weakly monotone, then for every RDF graph
G: JPKG is a greatest lower bound of {JPKH | G ⊆H} w.r.t. ⊑
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
49 / 91

Are graph patterns including the OPT operator weakly
monotone?
If the answer to this question is positive, then SPARQL is
appropriate for the open-world semantics of RDF.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
50 / 91

Are graph patterns including the OPT operator weakly
monotone?
If the answer to this question is positive, then SPARQL is
appropriate for the open-world semantics of RDF.
But the answer is negative.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
50 / 91

Are graph patterns including the OPT operator weakly
monotone?
If the answer to this question is positive, then SPARQL is
appropriate for the open-world semantics of RDF.
But the answer is negative.
◮In fact, we can express a minus operator
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
50 / 91

A MINUS operator in SPARQL
Let MINUS be deﬁned as:
JP1 MINUS P2KG
=
JP1KG ∖JP2KG
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
51 / 91

A MINUS operator in SPARQL
Let MINUS be deﬁned as:
JP1 MINUS P2KG
=
JP1KG ∖JP2KG
Proposition
(P1 MINUS P2) is equivalent to:

P1 OPT (P2 AND (?X1, ?X2, ?X3))

FILTER ¬ bound(?X1),
where ?X1, ?X2, ?X3 are mentioned neither in P1 nor in P2.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
51 / 91

What went wrong?
The queries used to express the MINUS operator are not natural.
◮Interestingly, there is a common syntactic pattern between
these queries and the queries used in the proofs of
PSPACE-hardness of the evaluation problem
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
52 / 91

What went wrong?
The queries used to express the MINUS operator are not natural.
◮Interestingly, there is a common syntactic pattern between
these queries and the queries used in the proofs of
PSPACE-hardness of the evaluation problem
This allows us to identify a fragment of SPARQL that:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
52 / 91

What went wrong?
The queries used to express the MINUS operator are not natural.
◮Interestingly, there is a common syntactic pattern between
these queries and the queries used in the proofs of
PSPACE-hardness of the evaluation problem
This allows us to identify a fragment of SPARQL that:
◮is appropriate for the open-world semantics of RDF
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
52 / 91

What went wrong?
The queries used to express the MINUS operator are not natural.
◮Interestingly, there is a common syntactic pattern between
these queries and the queries used in the proofs of
PSPACE-hardness of the evaluation problem
This allows us to identify a fragment of SPARQL that:
◮is appropriate for the open-world semantics of RDF
◮can be evaluated more eﬃciently
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
52 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
53 / 91

Identifying a good fragment of SPARQL
Graph patterns in the proofs of PSPACE-hardness in [P´erez, A.
and Gutierrez 2006, 2009] and [Schmidt, Meier and Lausen 2010]
are not natural:
(a, true, ?B0)
OPT
(P1
OPT
(Q1
AND
Pψ))
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
54 / 91

Identifying a good fragment of SPARQL
Graph patterns in the proofs of PSPACE-hardness in [P´erez, A.
and Gutierrez 2006, 2009] and [Schmidt, Meier and Lausen 2010]
are not natural:
(a, true, ?B0)
OPT
(P1
OPT
(Q1
AND
Pψ))
↑
?B0
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
54 / 91

Identifying a good fragment of SPARQL
Graph patterns in the proofs of PSPACE-hardness in [P´erez, A.
and Gutierrez 2006, 2009] and [Schmidt, Meier and Lausen 2010]
are not natural:
(a, true, ?B0)
OPT
(P1
OPT
(Q1
AND
Pψ))
↑
↑
?B0
?B0
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
54 / 91

Identifying a good fragment of SPARQL
Graph patterns in the proofs of PSPACE-hardness in [P´erez, A.
and Gutierrez 2006, 2009] and [Schmidt, Meier and Lausen 2010]
are not natural:
(a, true, ?B0)
OPT
(P1
OPT
(Q1
AND
Pψ))
↑
↑
↑
?B0
×
?B0
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
54 / 91

Identifying a good fragment of SPARQL
Graph patterns in the proofs of PSPACE-hardness in [P´erez, A.
and Gutierrez 2006, 2009] and [Schmidt, Meier and Lausen 2010]
are not natural:
(a, true, ?B0)
OPT
(P1
OPT
(Q1
AND
Pψ))
↑
↑
↑
?B0
×
?B0
Is ?B0 giving optional information for P1?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
54 / 91

Identifying a good fragment of SPARQL
Graph patterns in the proofs of PSPACE-hardness in [P´erez, A.
and Gutierrez 2006, 2009] and [Schmidt, Meier and Lausen 2010]
are not natural:
(a, true, ?B0)
OPT
(P1
OPT
(Q1
AND
Pψ))
↑
↑
↑
?B0
×
?B0
Is ?B0 giving optional information for P1?
◮No, ?B0 is giving optional information for (a, true, ?B0)?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
54 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
↑
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
↑
↑
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
↑
↑
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
Example

(?Y , name, paul) OPT (?X, email, ?Z)

AND
(?X, name, john)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
↑
↑
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
Example

(?Y , name, paul) OPT (?X, email, ?Z)

AND
(?X, name, john)
↑
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
↑
↑
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
Example

(?Y , name, paul) OPT (?X, email, ?Z)

AND
(?X, name, john)
↑
↑
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

Well–designed graph patterns
Deﬁnition
A query in the AND-FILTER-OPT fragment of SPARQL is
well–designed if for every OPT in the pattern:
( · · · · · · · · · · · ·
(
P
OPT
Q
)
· · · · · · · · · · · · )
↑
↑
↑
↑
if a variable occurs inside Q and anywhere outside the OPT
operator, then the variable must also occur inside P.
Example

(?Y , name, paul) OPT (?X, email, ?Z)

AND
(?X, name, john)
⧸
⧹
↑
↑
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
55 / 91

How common are well-designed patterns?
What are real SPARQL queries like? [Picalausa and Vansummeren,
2011]
◮DBpedia query log: 623,000 queries without the UNION
operator
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
56 / 91

How common are well-designed patterns?
What are real SPARQL queries like? [Picalausa and Vansummeren,
2011]
◮DBpedia query log: 623,000 queries without the UNION
operator
◮52% of these queries are well designed
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
56 / 91

How common are well-designed patterns?
What are real SPARQL queries like? [Picalausa and Vansummeren,
2011]
◮DBpedia query log: 623,000 queries without the UNION
operator
◮52% of these queries are well designed
Examples of queries from DBpedia that are not well designed are
unnatural
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
56 / 91

How common are well-designed patterns?
What are real SPARQL queries like? [Picalausa and Vansummeren,
2011]
◮DBpedia query log: 623,000 queries without the UNION
operator
◮52% of these queries are well designed
Examples of queries from DBpedia that are not well designed are
unnatural
◮In general, they are equivalent to or can be reformulated as
well-designed graph patterns
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
56 / 91

Reducing the complexity
Theorem (P´erez, A. and Gutierrez 2009)
The evaluation problem is coNP-complete for well-designed graph
patterns.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
57 / 91

Reducing the complexity
Theorem (P´erez, A. and Gutierrez 2009)
The evaluation problem is coNP-complete for well-designed graph
patterns.
Can we use this in practice?
◮Well-designed graph patterns are suitable for optimization
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
57 / 91

Classical optimization
◮Classical optimization assumes null-rejection.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
58 / 91

Classical optimization
◮Classical optimization assumes null-rejection.
◮Null-rejection: the join condition must fail in the presence of
nulls
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
58 / 91

Classical optimization
◮Classical optimization assumes null-rejection.
◮Null-rejection: the join condition must fail in the presence of
nulls
◮SPARQL operations are not null-rejecting.
◮By deﬁnition of compatible mappings
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
58 / 91

Classical optimization
◮Classical optimization assumes null-rejection.
◮Null-rejection: the join condition must fail in the presence of
nulls
◮SPARQL operations are not null-rejecting.
◮By deﬁnition of compatible mappings
◮Can we use classical optimization in the context of SPARQL?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
58 / 91

Classical optimization
◮Classical optimization assumes null-rejection.
◮Null-rejection: the join condition must fail in the presence of
nulls
◮SPARQL operations are not null-rejecting.
◮By deﬁnition of compatible mappings
◮Can we use classical optimization in the context of SPARQL?
◮Well-designed graph patterns are suitable for reordering, and
then for classical optimization
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
58 / 91

Well–designed graph patterns and optimization
Consider the following rules:
((P1 OPT P2) FILTER R)
−→
((P1 FILTER R) OPT P2)
(1)
(P1 AND (P2 OPT P3))
−→
((P1 AND P2) OPT P3)
(2)
((P1 OPT P2) AND P3)
−→
((P1 AND P3) OPT P2)
(3)
Proposition (P´erez, A. and Gutierrez 2006)
If P is well-designed and Q is obtained from P by applying either
(1) or (2) or (3), then Q is a well-designed and equivalent to P.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
59 / 91

Well-designed graph patterns are appropriate for the
open-world semantics of RDF
Theorem
Every well-designed graph pattern is weakly monotone.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
60 / 91

Well-designed graph patterns are appropriate for the
open-world semantics of RDF
Theorem
Every well-designed graph pattern is weakly monotone.
That is, if P is well designed and G1, G2 are RDF graphs such that
G1 ⊆G2, then JPKG1 ⊑JPKG2
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
60 / 91

Research opportunities: Well-designed graph patterns form
a good fragment of SPARQL
Open questions:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
61 / 91

Research opportunities: Well-designed graph patterns form
a good fragment of SPARQL
Open questions:
◮How the notion of being well-designed can be extended to
consider the UNION operator?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
61 / 91

Research opportunities: Well-designed graph patterns form
a good fragment of SPARQL
Open questions:
◮How the notion of being well-designed can be extended to
consider the UNION operator?
◮How far are well-designed graph patterns from weakly
monotone SPARQL queries?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
61 / 91

Research opportunities: Well-designed graph patterns form
a good fragment of SPARQL
Open questions:
◮How the notion of being well-designed can be extended to
consider the UNION operator?
◮How far are well-designed graph patterns from weakly
monotone SPARQL queries?
◮Are the optimization techniques useful in practice?
◮They have been used with good results [Buil-Aranda, A. and
Corcho 2011]
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
61 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
62 / 91

Syntax of RDFS
RDFS extends RDF with a schema vocabulary: subPropertyOf
(sp), subClassOf (sc), domain (dom), range (range), type (type).
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
63 / 91

Syntax of RDFS
RDFS extends RDF with a schema vocabulary: subPropertyOf
(sp), subClassOf (sc), domain (dom), range (range), type (type).
How can one query RDFS data?
◮Evaluating queries which involve this vocabulary is challenging
◮There is not yet consensus in the Semantic Web community
on how to deﬁne a query language for RDFS
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
63 / 91

A simple SPARQL query:
(dbpedia:Ronald Fagin, type, yago:Scientist)
sc
yago:ResearchWorker
dbpedia:Ronald Fagin
yago:DatabaseResearchers
yago:Scientist
dbo:birthPlace
type
sc
dbpedia:Oklahoma
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
64 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X,
, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::
)+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[
])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[(next::sp)∗/
])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[(next::sp)∗/(self::transportation service)])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[(next::sp)∗/(self::transportation service)])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[(next::sp)∗/(self::transportation service)])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[(next::sp)∗/(self::transportation service)])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

A more complex query
List the pairs a, b of cities such that there is a way to travel from a to b.
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
nSPARQL:
(?X, (next::[(next::sp)∗/(self::transportation service)])+, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
65 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
66 / 91

Concluding remarks
◮We have witnessed a constant growth in the amount of RDF
data available on the Web.
◮Two fundamental components: RDF and SPARQL
◮Some of the distinctive features of RDF have made the study
and implementation of SPARQL challenging.
◮RDF and SPARQL have attracted interest from the database
community.
◮There are many interesting research opportunities in the area
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
67 / 91

Concluding remarks
◮We have witnessed a constant growth in the amount of RDF
data available on the Web.
◮Two fundamental components: RDF and SPARQL
◮Some of the distinctive features of RDF have made the study
and implementation of SPARQL challenging.
◮RDF and SPARQL have attracted interest from the database
community.
◮There are many interesting research opportunities in the area
◮The database community has much more to say about these
technologies, and, in particular, about the fundamental
database problems that need to be solved in order to provide
solid foundations for their development.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
67 / 91

Thank you!
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
68 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Semantics of RDFS
◮Extending SPARQL with navigational capabilities
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
69 / 91

Semantics of RDFS
Checking whether a triple t is in a graph G is the basic step when
answering queries over RDF.
◮For the case of RDFS, we need to check whether t is implied by G
The notion of entailment in RDFS can be deﬁned in terms of
classical notions such as model, interpretation, etc.
◮As for the case of ﬁrst-order logic
This notion can also be characterized by a set of inference rules.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
70 / 91

An inference system for RDFS
Sub-property
:
(A,sp,B) (B,sp,C)
(A,sp,C)
(A,sp,B) (X,A,Y)
(X,B,Y)
Subclass
:
(A,sc,B) (B,sc,C)
(A,sc,C)
(A,sc,B) (X,type,A)
(X,type,B)
Typing
:
(A,dom,B) (X,A,Y)
(X,type,B)
(A,range,B) (X,A,Y)
(Y,type,B)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
71 / 91

Entailment in RDFS
Theorem (Hayes 2003, Gutierrez, Hurtado and Mendelzon
2004, Mu˜noz, P´erez and Gutierrez 2007)
The previous system of inference rules characterize the notion of
entailment in RDFS.
Thus, a triple t can be deduced from an RDF graph G (G |= t) if
there exists an RDF G ′ such that:
◮t ∈G ′
◮G ′ can be obtained from G by successively applying the rules
in the previous system
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
72 / 91

Entailment in RDFS: Closure of a graph
Deﬁnition
The closure of an RDFS graph G, denoted by cl(G), is the graph
obtained by adding to G all the triples that are implied by G.
A basic property of the closure:
◮G |= t iﬀt ∈cl(G)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
73 / 91

Outline of the talk
◮RDF formal model
◮A formal study of SPARQL
◮Syntax and semantics
◮Complexity of the evaluation problem
◮Is SPARQL the right query language for RDF?
◮Well-designed graphs patterns
◮Including RDFS vocabulary: Motivation
◮Semantics of RDFS
◮Extending SPARQL with navigational capabilities
◮Concluding remarks
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
74 / 91

Querying RDFS data
Basic step for answering queries over RDFS:
◮Checking whether a triple t is in cl(G)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
75 / 91

Querying RDFS data
Basic step for answering queries over RDFS:
◮Checking whether a triple t is in cl(G)
Deﬁnition
The RDFS-evaluation of a graph pattern P over an RDFS graph G
is deﬁned as the evaluation of P over cl(G):
JPKrdfs
G
=
JPKcl(G)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
75 / 91

Example: (dbpedia:Ronald Fagin, type, yago:Scientist)
over the closure
sc
yago:ResearchWorker
yago:DatabaseResearchers
yago:Scientist
dbo:birthPlace
type
dbpedia:Oklahoma
dbpedia:Ronald Fagin
type
sc
sc
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
76 / 91

Answering SPARQL queries over RDFS
A simple approach for answering a SPARQL query P over an
RDFS graph G:
◮Compute cl(G), and then evaluate P over cl(G) as for RDF
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
77 / 91

Answering SPARQL queries over RDFS
A simple approach for answering a SPARQL query P over an
RDFS graph G:
◮Compute cl(G), and then evaluate P over cl(G) as for RDF
This approach has some drawbacks:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
77 / 91

Answering SPARQL queries over RDFS
A simple approach for answering a SPARQL query P over an
RDFS graph G:
◮Compute cl(G), and then evaluate P over cl(G) as for RDF
This approach has some drawbacks:
◮The size of the closure of G can be quadratic in the size of G
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
77 / 91

Answering SPARQL queries over RDFS
A simple approach for answering a SPARQL query P over an
RDFS graph G:
◮Compute cl(G), and then evaluate P over cl(G) as for RDF
This approach has some drawbacks:
◮The size of the closure of G can be quadratic in the size of G
◮Once the closure has been computed, all the queries are evaluated
over a graph which can be much larger than the original graph
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
77 / 91

Answering SPARQL queries over RDFS
A simple approach for answering a SPARQL query P over an
RDFS graph G:
◮Compute cl(G), and then evaluate P over cl(G) as for RDF
This approach has some drawbacks:
◮The size of the closure of G can be quadratic in the size of G
◮Once the closure has been computed, all the queries are evaluated
over a graph which can be much larger than the original graph
◮The approach is not goal-oriented
When evaluating (a, sc, b), a goal-oriented approach should not
compute cl(G):
◮It should just verify whether there exists a path from a to b in
G where every edge has label sc
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
77 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
Possible approach: Extend SPARQL with navigational capabilities.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
Possible approach: Extend SPARQL with navigational capabilities.
◮A query P over an RDFS graph G is answered by navigating G
(cl(G) is not computed)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
Possible approach: Extend SPARQL with navigational capabilities.
◮A query P over an RDFS graph G is answered by navigating G
(cl(G) is not computed)
This approach has some advantages:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
Possible approach: Extend SPARQL with navigational capabilities.
◮A query P over an RDFS graph G is answered by navigating G
(cl(G) is not computed)
This approach has some advantages:
◮It is goal-oriented
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
Possible approach: Extend SPARQL with navigational capabilities.
◮A query P over an RDFS graph G is answered by navigating G
(cl(G) is not computed)
This approach has some advantages:
◮It is goal-oriented
◮It has been used to design query languages for XML (e.g., XPath
and XQuery). The results for these languages can be used here
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Extending SPARQL with navigational capabilities
The example (a, sc, b) suggests that a query language with
navigational capabilities could be appropriate for RDFS.
Possible approach: Extend SPARQL with navigational capabilities.
◮A query P over an RDFS graph G is answered by navigating G
(cl(G) is not computed)
This approach has some advantages:
◮It is goal-oriented
◮It has been used to design query languages for XML (e.g., XPath
and XQuery). The results for these languages can be used here
◮Navigational operators allow to express natural queries that are not
expressible in SPARQL over RDFS
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
78 / 91

Navigational axes
Forward axes for an RDF triple (a, p, b):
next
b
a
p
edge
node
Backward axes for an RDF triple (a, p, b):
p
a
b
next-1
node-1
edge-1
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
79 / 91

The basic component: Nested regular expressions
Syntax of nested regular expressions:
exp
:=
axis | axis::a |
axis::[exp] | exp/exp | exp|exp | exp∗
where a ∈U and axis ∈{self, next, next-1, edge, edge-1,
node, node-1}.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
80 / 91

Semantics of nested regular expressions
Given an RDFS graph G:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
81 / 91

Semantics of nested regular expressions
Given an RDFS graph G:
JselfKG
=
{(x, x) | x is in G}
JnextKG
=
{(x, y) | ∃z ∈U (x, z, y) ∈G}
JedgeKG
=
{(x, y) | ∃z ∈U (x, y, z) ∈G}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
81 / 91

Semantics of nested regular expressions
Given an RDFS graph G:
JselfKG
=
{(x, x) | x is in G}
JnextKG
=
{(x, y) | ∃z ∈U (x, z, y) ∈G}
JedgeKG
=
{(x, y) | ∃z ∈U (x, y, z) ∈G}
Jself::aKG
=
{(a, a)}
Jnext::aKG
=
{(x, y) | (x, a, y) ∈G}
Jedge::aKG
=
{(x, y) | (x, y, a) ∈G}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
81 / 91

Semantics of nested regular expressions
Given an RDFS graph G:
JselfKG
=
{(x, x) | x is in G}
JnextKG
=
{(x, y) | ∃z ∈U (x, z, y) ∈G}
JedgeKG
=
{(x, y) | ∃z ∈U (x, y, z) ∈G}
Jself::aKG
=
{(a, a)}
Jnext::aKG
=
{(x, y) | (x, a, y) ∈G}
Jedge::aKG
=
{(x, y) | (x, y, a) ∈G}
Jexp1/exp2KG
=
{(x, y) | ∃z (x, z) ∈Jexp1KG and
(z, y) ∈Jexp2KG}
Jexp1|exp2KG
=
Jexp1KG ∪Jexp2KG
Jexp∗KG
=
JselfKG ∪JexpKG ∪Jexp/expKG ∪
Jexp/exp/expKG ∪· · ·
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
81 / 91

Semantics of nested regular expressions (cont’d)
Given an RDFS graph G:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
82 / 91

Semantics of nested regular expressions (cont’d)
Given an RDFS graph G:
Jnext::[exp]KG
=
{(x, y) | ∃z, w ∈U (x, z, y) ∈G and
(z, w) ∈JexpKG}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
82 / 91

Semantics of nested regular expressions (cont’d)
Given an RDFS graph G:
Jnext::[exp]KG
=
{(x, y) | ∃z, w ∈U (x, z, y) ∈G and
(z, w) ∈JexpKG}
Jedge::[exp]KG
=
{(x, y) | ∃z, w ∈U (x, y, z) ∈G and
(z, w) ∈JexpKG}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
82 / 91

The query language nSPARQL
Syntax of nSPARQL:
◮Basic component: A triple of the form (x, exp, y)
◮exp is a nested regular expression
◮x (resp. y) is either an element from U or a variable
◮Operators: AND, FILTER, UNION and OPT
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
83 / 91

The query language nSPARQL
Syntax of nSPARQL:
◮Basic component: A triple of the form (x, exp, y)
◮exp is a nested regular expression
◮x (resp. y) is either an element from U or a variable
◮Operators: AND, FILTER, UNION and OPT
Triple (?X, ?Y , ?Z) is not allowed.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
83 / 91

The query language nSPARQL
Syntax of nSPARQL:
◮Basic component: A triple of the form (x, exp, y)
◮exp is a nested regular expression
◮x (resp. y) is either an element from U or a variable
◮Operators: AND, FILTER, UNION and OPT
Triple (?X, ?Y , ?Z) is not allowed.
◮It computes the closure!
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
83 / 91

nSPARQL: What can we express?
Example
◮(?X, next::a, ?Y ): Equivalent to (?X, a, ?Y )
◮(?X, edge::a, ?Y ): Equivalent to (?X, ?Y , a)
◮(?X, node::a, ?Y ): Equivalent to (a, ?X, ?Y )
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
84 / 91

nSPARQL: What can we express?
Example
◮(?X, next::a, ?Y ): Equivalent to (?X, a, ?Y )
◮(?X, edge::a, ?Y ): Equivalent to (?X, ?Y , a)
◮(?X, node::a, ?Y ): Equivalent to (a, ?X, ?Y )
◮(?X, (next::(sc))+, ?Y ): Veriﬁes whether ?X is a subclass of
?Y
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
84 / 91

Semantics of nSPARQL
Evaluation of t = (?X, exp, ?Y ) over an RDF graph G is the set of
mappings µ such that:
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
85 / 91

Semantics of nSPARQL
Evaluation of t = (?X, exp, ?Y ) over an RDF graph G is the set of
mappings µ such that:
◮The domain of µ is {?X, ?Y }
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
85 / 91

Semantics of nSPARQL
Evaluation of t = (?X, exp, ?Y ) over an RDF graph G is the set of
mappings µ such that:
◮The domain of µ is {?X, ?Y }
◮(µ(?X), µ(?Y )) ∈JexpKG
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
85 / 91

Semantics of nSPARQL
Evaluation of t = (?X, exp, ?Y ) over an RDF graph G is the set of
mappings µ such that:
◮The domain of µ is {?X, ?Y }
◮(µ(?X), µ(?Y )) ∈JexpKG
Example
What does (?X, (next::KLM | next::AirFrance)+, ?Y ) represent?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
85 / 91

Is nSPARQL a good language for RDFS?
How do we test whether a language is appropriate for RDFS?
◮Can we capture SPARQL over RDFS?
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
86 / 91

Is nSPARQL a good language for RDFS?
How do we test whether a language is appropriate for RDFS?
◮Can we capture SPARQL over RDFS?
For every RDFS graph G and SPARQL pattern P, we would like to
ﬁnd an nSPARQL pattern Q such that:
JPKrdfs
G
=
JQKG
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
86 / 91

Is nSPARQL a good language for RDFS?
How do we test whether a language is appropriate for RDFS?
◮Can we capture SPARQL over RDFS?
For every RDFS graph G and SPARQL pattern P, we would like to
ﬁnd an nSPARQL pattern Q such that:
JPKrdfs
G
=
JQKG
But we trivially fail because of triple (?X, ?Y , ?Z).
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
86 / 91

Is nSPARQL a good language for RDFS?
How do we test whether a language is appropriate for RDFS?
◮Can we capture SPARQL over RDFS?
For every RDFS graph G and SPARQL pattern P, we would like to
ﬁnd an nSPARQL pattern Q such that:
JPKrdfs
G
=
JQKG
But we trivially fail because of triple (?X, ?Y , ?Z).
◮We need to use a fragment of SPARQL
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
86 / 91

A good fragment of SPARQL for our study
T : Set of triples (x, y, z) where x ∈U or y ∈U or z ∈U.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
87 / 91

A good fragment of SPARQL for our study
T : Set of triples (x, y, z) where x ∈U or y ∈U or z ∈U.
◮(?X, a, b), (?X, a, ?Y ) and (?X, ?Y , a)
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
87 / 91

A good fragment of SPARQL for our study
T : Set of triples (x, y, z) where x ∈U or y ∈U or z ∈U.
◮(?X, a, b), (?X, a, ?Y ) and (?X, ?Y , a)
T -SPARQL: Fragment of SPARQL where triple patterns are taken
from T .
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
87 / 91

nSPARQL captures T -SPARQL over RDFS
Theorem (P´erez, A. and Gutierrez 2008)
For every T -SPARQL pattern P, there exists an nSPARQL pattern
Q such that JPKrdfs
G
= JQKG for every RDF graph G.
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
88 / 91

nSPARQL captures T -SPARQL over RDFS
Theorem (P´erez, A. and Gutierrez 2008)
For every T -SPARQL pattern P, there exists an nSPARQL pattern
Q such that JPKrdfs
G
= JQKG for every RDF graph G.
Proof sketch
Replace (?X, a, ?Y ) by (?X, trans(a), ?Y ), where:
trans(dom)
=
next::dom
trans(range)
=
next::range
trans(sc)
=
(next::sc)+
trans(sp)
=
(next::sp)+
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
88 / 91

nSPARQL: Capturing SPARQL over RDFS
trans(type) =
next::type/(next::sc)∗|
edge/(next::sp)∗/next::dom/(next::sc)∗|
node-1/(next::sp)∗/next::range/(next::sc)∗
trans(p) = next::[(next::sp)∗/self::p]
for p /∈{sc, sp, range, dom, type}
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
89 / 91

The extra expressive power of nSPARQL
sp
Calais
Paris
Dover
London
SeeFrance
TGV
NatExpress
train service
ferry service
bus service
sp
sp
sp
transportation service
sp
sp
(?X, (next::[(next::sp)∗/(self::transportation service)])+, ?Y ) cannot
be expressed in SPARQL over RDFS
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
90 / 91

Thank you!
M. Arenas and J. P´erez
–
Querying Semantic Web Data with SPARQL
91 / 91

