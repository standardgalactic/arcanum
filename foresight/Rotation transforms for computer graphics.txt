
Rotation Transforms for Computer Graphics

John Vince
Rotation
Transforms
for Computer
Graphics

Professor Emeritus, John Vince, MTech, PhD,
DSc, CEng, FBCS
Bournemouth University, Bournemouth, UK
url: www.johnvince.co.uk
ISBN 978-0-85729-153-0
e-ISBN 978-0-85729-154-7
DOI 10.1007/978-0-85729-154-7
Springer London Dordrecht Heidelberg New York
British Library Cataloguing in Publication Data
A catalogue record for this book is available from the British Library
© Springer-Verlag London Limited 2011
Apart from any fair dealing for the purposes of research or private study, or criticism or review, as per-
mitted under the Copyright, Designs and Patents Act 1988, this publication may only be reproduced,
stored or transmitted, in any form or by any means, with the prior permission in writing of the publish-
ers, or in the case of reprographic reproduction in accordance with the terms of licenses issued by the
Copyright Licensing Agency. Enquiries concerning reproduction outside those terms should be sent to
the publishers.
The use of registered names, trademarks, etc., in this publication does not imply, even in the absence of a
speciﬁc statement, that such names are exempt from the relevant laws and regulations and therefore free
for general use.
The publisher makes no representation, express or implied, with regard to the accuracy of the information
contained in this book and cannot accept any legal responsibility or liability for any errors or omissions
that may be made.
Cover design: deblik
Printed on acid-free paper
Springer is part of Springer Science+Business Media (www.springer.com)


This book is dedicated to my grandchildren,
Megan, Mia and Lucie


Preface
Every time I complete a manuscript my attention turns quickly to the title of my
next book. And after completing the latest version of Mathematics for Computer
Graphics, I began to think of what should follow. It didn’t take too long to iden-
tify the subject of this book: rotation transforms, which have always interested me
throughout my career in computer graphics.
I knew that I was not alone in ﬁnding some of the ideas difﬁcult, as every time
I searched the Internet using search keys such as ‘quaternions’, ‘Euler angles’, ‘ro-
tors’, etc., I would come across websites where groups were discussing the meaning
of gimbal lock, the matrix representation of a quaternion, eigenvectors, etc., and I
knew straight away that I had to do my bit to clarify the subject.
One of the main problems why there is so much confusion arises through the
different forms of vector and matrix notation. Some authors work with matrices that
involve row vectors, rather than column vectors, which leads to a transposed matrix.
In some cases, the direction of rotation is clockwise, rather than the normal posi-
tive, anti-clockwise direction. Quaternions are treated as a four-dimensional object
where one has to visualise a hyper-sphere before they can be mastered. Some of the
algorithms for extracting eigenvectors and their associated eigenvalue can be very
sensitive to the type of matrix in use. This is all rather disconcerting.
The experienced mathematician will take all of this in his or her stride, but to a cg
programmer trying to implement the best rotation algorithm and design some stable
code, this is not good news. So about a year ago, I started to collect my thoughts on
how to approach this subject. After a few false starts and chapter rewrites, I decided
to write an introductory book that would take the reader through the foundations of
rotation transforms from complex numbers to Clifford algebra rotors, touching on
vectors, matrices and quaternions on the journey.
Illustrations are vital to understanding rotation transforms, especially the differ-
ence between rotated points and rotated frames. I came across many websites, tech-
nical literature and books where the illustrations confused rather than clariﬁed what
was going on, and I explored various approaches before settling for a unit cube with
numbered vertices. This book contains over a hundred illustrations, which, I hope
will help the reader understand the underlying mathematics.
vii

viii
Preface
In order to create some sort of structure, I have separated transforms for rotating
points in a ﬁxed frame, from transforms that rotate frames with ﬁxed points. I have
also separated transforms in the plane from transforms in 3D space. In all, there are
thirteen chapters, including an introduction and summary chapters.
Chapter 2 provides a quick introduction to complex numbers and the rotational
qualities of imaginary i. The reader should be comfortable with these objects, as we
ﬁnd imaginary quantities in quaternions and multivectors.
Chapter 3 covers vectors and their products, whilst Chap. 4 describes matrices
and their associated algebra. It also explores other relevant topics such as matrix
inversion, symmetric and antisymmetric matrices, eigenvectors and eigenvalues.
Chapter 5 covers quaternions and their various forms, but I leave their rotational
abilities for Chap. 11. I play down their four-dimensional attributes as I don’t believe
that this characteristic is too important within this introductory book.
Chapter 6 introduces multivector rotors that are part of Clifford’s geometric al-
gebra, and again, their rotational qualities are delayed until Chap. 12.
Chapter 7 covers rotation transforms in the plane and establishes strategies used
for transforming points in space, whilst Chap. 8 addresses rotating frames of refer-
ence in the plane.
Chapter 9 is an important chapter as it introduces the classic techniques for han-
dling 3D rotations, composite rotations, gimbal lock, and provides a stable technique
for extracting eigenvectors and eigenvalues from a matrix.
Chapter 10 develops the ideas of Chap. 9 to explain how coordinates are com-
puted in rotating frames of reference.
Chapter 11 takes quaternions from Chap. 5 and shows how they provide a pow-
erful tool for rotating points and frames about an arbitrary axis.
Chapter 12 takes the multivectors from Chap. 6 and shows how they provide a
uniﬁed system for handling rotors. Finally, Chap. 13 draws the book to a conclusion.
I would like to take this opportunity to acknowledge the authors of books, tech-
nical papers and websites who have inﬂuenced my writing over recent years. From
these dedicated people I have discovered new writing techniques, how to format
equations, and how to communicate complex ideas in an easy manner. Without
them this book would not have been possible. However, there is one author that
I must acknowledge: Michael J. Crowe. His book A History of Vector Analysis [1]
is an amazing description of how vectors and quaternions evolved, and is highly
recommended.
In particular, I would like to thank Dr Tony Crilly, Reader Emeritus at Middlesex
University, who read a draft manuscript and made many important recommenda-
tions. Tony read the book through the eyes of a novice and questioned my writing
style when clarity started to sink below the surface. Forty years ago, when I was
struggling with gimbal lock and Euler transforms, Tony brought to my attention the
rotation transform developed by Olinde Rodrigues, who had invented quaternions
before Hamilton, but that’s another story. I included this transform in my animation
software system PICASO, running on a mainframe computer with a 24 KB store!
I was very nervous about using it as sines and cosines were evaluated at a software
level and extremely slow.

Preface
ix
I would also like to thank Prof. Patrick Riley for providing me with a harmono-
gram that has formed the book’s cover design, and for his feedback on early drafts
of the manuscript when I needed to know whether I was managing to communicate
my ideas effectively.
Once again, I am indebted to Beverley Ford, General Manager, Springer UK,
and Helen Desmond, Assistant Editor for Computer Science, for their support and
reminding me of the importance of deadlines. I would also like to thank Springer’s
technical support team for their help with LATEX 2ε.
John Vince
Ringwood


Contents
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Rotation Transforms . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Mathematical Techniques
. . . . . . . . . . . . . . . . . . . . .
1
1.3
The Reader . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.4
Aims and Objectives of This Book . . . . . . . . . . . . . . . . .
2
1.5
Assumptions Made in This Book
. . . . . . . . . . . . . . . . .
2
1.6
How to Use the Book . . . . . . . . . . . . . . . . . . . . . . . .
3
2
Complex Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
2.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
2.2
Complex Numbers . . . . . . . . . . . . . . . . . . . . . . . . .
5
2.2.1
Axioms . . . . . . . . . . . . . . . . . . . . . . . . . .
6
2.3
The Modulus . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
2.4
Addition and Subtraction . . . . . . . . . . . . . . . . . . . . . .
7
2.5
Multiplication by a Scalar . . . . . . . . . . . . . . . . . . . . .
7
2.6
Product of Two Complex Numbers
. . . . . . . . . . . . . . . .
7
2.7
The Complex Conjugate . . . . . . . . . . . . . . . . . . . . . .
8
2.8
Division of Two Complex Numbers . . . . . . . . . . . . . . . .
8
2.9
The Inverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
2.10
The Complex Plane
. . . . . . . . . . . . . . . . . . . . . . . .
10
2.11
Polar Representation . . . . . . . . . . . . . . . . . . . . . . . .
11
2.12
Rotors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2.13
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.13.1
Summary of Complex Operations . . . . . . . . . . . .
16
3
Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.2
Vector Notation . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.3
Graphical Representation of Vectors . . . . . . . . . . . . . . . .
18
3.4
Magnitude of a Vector . . . . . . . . . . . . . . . . . . . . . . .
18
3.5
3D Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
xi

xii
Contents
3.6
Vector Manipulation . . . . . . . . . . . . . . . . . . . . . . . .
19
3.6.1
Multiplying a Vector by a Scalar . . . . . . . . . . . . .
20
3.6.2
Vector Addition and Subtraction . . . . . . . . . . . . .
20
3.7
Position Vectors
. . . . . . . . . . . . . . . . . . . . . . . . . .
20
3.8
Unit Vectors
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.9
Cartesian Vectors . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.10
Scalar Product . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
3.11
The Vector Product . . . . . . . . . . . . . . . . . . . . . . . . .
24
3.12
The Right-Hand Rule
. . . . . . . . . . . . . . . . . . . . . . .
27
3.13
Deriving a Unit Normal Vector
. . . . . . . . . . . . . . . . . .
27
3.14
Interpolating Vectors . . . . . . . . . . . . . . . . . . . . . . . .
28
3.15
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
3.15.1
Summary of Vector Operations . . . . . . . . . . . . . .
31
4
Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
4.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
4.2
Matrices
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
4.3
The Transpose of a Matrix . . . . . . . . . . . . . . . . . . . . .
35
4.4
The Identity Matrix . . . . . . . . . . . . . . . . . . . . . . . . .
35
4.5
Adding and Subtracting Matrices
. . . . . . . . . . . . . . . . .
35
4.6
Multiplying a Matrix by a Scalar . . . . . . . . . . . . . . . . . .
36
4.7
Product of Two Matrices . . . . . . . . . . . . . . . . . . . . . .
36
4.8
The Inverse Matrix . . . . . . . . . . . . . . . . . . . . . . . . .
37
4.8.1
Calculation of Inverse
. . . . . . . . . . . . . . . . . .
37
4.9
Determinant of a Matrix . . . . . . . . . . . . . . . . . . . . . .
39
4.9.1
Sarrus’s Rule . . . . . . . . . . . . . . . . . . . . . . .
39
4.9.2
The Laplace Expansion . . . . . . . . . . . . . . . . . .
41
4.10
Cofactors and Inverse of a Matrix . . . . . . . . . . . . . . . . .
42
4.11
Orthogonal Matrix . . . . . . . . . . . . . . . . . . . . . . . . .
45
4.12
Diagonal Matrix . . . . . . . . . . . . . . . . . . . . . . . . . .
45
4.13
Trace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
4.14
Symmetric Matrix . . . . . . . . . . . . . . . . . . . . . . . . .
47
4.15
Antisymmetric Matrix . . . . . . . . . . . . . . . . . . . . . . .
48
4.16
Inverting a Pair of Matrices
. . . . . . . . . . . . . . . . . . . .
50
4.17
Eigenvectors and Eigenvalues . . . . . . . . . . . . . . . . . . .
50
4.18
Vector Products . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
4.19
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
4.19.1
Summary of Matrix Operations
. . . . . . . . . . . . .
56
5
Quaternions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
5.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
5.2
Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
5.2.1
Axioms . . . . . . . . . . . . . . . . . . . . . . . . . .
60
5.3
Adding and Subtracting Quaternions
. . . . . . . . . . . . . . .
60
5.4
Multiplying Quaternions . . . . . . . . . . . . . . . . . . . . . .
61

Contents
xiii
5.5
Pure Quaternion
. . . . . . . . . . . . . . . . . . . . . . . . . .
62
5.6
Magnitude of a Quaternion . . . . . . . . . . . . . . . . . . . . .
62
5.7
Unit Quaternion
. . . . . . . . . . . . . . . . . . . . . . . . . .
62
5.8
The Quaternion Conjugate . . . . . . . . . . . . . . . . . . . . .
63
5.9
The Inverse Quaternion
. . . . . . . . . . . . . . . . . . . . . .
64
5.10
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
5.10.1
Summary of Quaternion Operations . . . . . . . . . . .
65
6
Multivectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
6.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
6.2
Symmetric and Antisymmetric Functions . . . . . . . . . . . . .
67
6.3
Trigonometric Foundations
. . . . . . . . . . . . . . . . . . . .
68
6.4
Vectorial Foundations
. . . . . . . . . . . . . . . . . . . . . . .
68
6.5
Inner and Outer Products . . . . . . . . . . . . . . . . . . . . . .
69
6.6
The Geometric Product in 2D . . . . . . . . . . . . . . . . . . .
69
6.7
The Geometric Product in 3D . . . . . . . . . . . . . . . . . . .
71
6.8
The Outer Product of Three 3D Vectors . . . . . . . . . . . . . .
73
6.9
Axioms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
74
6.10
Notation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
6.11
Grades, Pseudoscalars and Multivectors . . . . . . . . . . . . . .
75
6.12
Redeﬁning the Inner and Outer Products
. . . . . . . . . . . . .
76
6.13
The Inverse of a Vector . . . . . . . . . . . . . . . . . . . . . . .
77
6.14
The Imaginary Properties of the Outer Product . . . . . . . . . .
78
6.15
Duality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
6.16
The Relationship Between the Vector Product and the Outer
Product . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
6.17
The Relationship Between Quaternions and Bivectors
. . . . . .
81
6.18
Reverse of a Multivector . . . . . . . . . . . . . . . . . . . . . .
82
6.19
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
83
6.19.1
Summary of Multivector Operations . . . . . . . . . . .
83
7
Rotation Transforms in the Plane . . . . . . . . . . . . . . . . . . . .
85
7.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
7.2
2D Transforms . . . . . . . . . . . . . . . . . . . . . . . . . . .
85
7.2.1
Homogeneous Coordinates . . . . . . . . . . . . . . . .
85
7.3
Matrix Transforms . . . . . . . . . . . . . . . . . . . . . . . . .
86
7.3.1
Translate a Point
. . . . . . . . . . . . . . . . . . . . .
87
7.3.2
Rotate a Point About the Origin . . . . . . . . . . . . .
87
7.3.3
Rotate a Point About an Arbitrary Point . . . . . . . . .
89
7.3.4
Rotate and Translate a Point . . . . . . . . . . . . . . .
91
7.3.5
Composite Rotations . . . . . . . . . . . . . . . . . . .
91
7.4
Inverse Transforms . . . . . . . . . . . . . . . . . . . . . . . . .
92
7.5
Multivector Transforms
. . . . . . . . . . . . . . . . . . . . . .
93
7.5.1
Translate a Point
. . . . . . . . . . . . . . . . . . . . .
93
7.5.2
Rotational Qualities of the Unit Bivector . . . . . . . . .
94

xiv
Contents
7.5.3
Rotate a Point About the Origin . . . . . . . . . . . . .
97
7.5.4
Rotate a Point About an Arbitrary Point . . . . . . . . .
99
7.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
7.6.1
Summary of Matrix Transforms . . . . . . . . . . . . . 100
7.6.2
Summary of Multivector Transforms . . . . . . . . . . . 101
8
Frames of Reference in the Plane . . . . . . . . . . . . . . . . . . . . 103
8.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
8.2
Frames of Reference . . . . . . . . . . . . . . . . . . . . . . . . 103
8.3
Matrix Transforms . . . . . . . . . . . . . . . . . . . . . . . . . 104
8.3.1
Translated Frame of Reference . . . . . . . . . . . . . . 104
8.3.2
Rotated Frame of Reference . . . . . . . . . . . . . . . 106
8.3.3
Rotated and Translated Frame of Reference . . . . . . . 107
8.4
Direction Cosines
. . . . . . . . . . . . . . . . . . . . . . . . . 109
8.5
Multivector Transforms
. . . . . . . . . . . . . . . . . . . . . . 110
8.5.1
Translated Frame of Reference . . . . . . . . . . . . . . 110
8.5.2
Rotated Frame of Reference . . . . . . . . . . . . . . . 111
8.5.3
Rotated and Translated Frame of Reference . . . . . . . 112
8.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.6.1
Summary of Matrix Transforms . . . . . . . . . . . . . 113
8.6.2
Summary of Multivector Transforms . . . . . . . . . . . 114
9
Rotation Transforms in Space . . . . . . . . . . . . . . . . . . . . . . 115
9.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
9.2
3D Transforms . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
9.2.1
Translate a Point
. . . . . . . . . . . . . . . . . . . . . 115
9.2.2
Rotate a Point About the Cartesian Axes . . . . . . . . . 116
9.2.3
Rotating About an Off-Set Axis . . . . . . . . . . . . . 117
9.3
Composite Rotations . . . . . . . . . . . . . . . . . . . . . . . . 118
9.3.1
3D Eigenvectors
. . . . . . . . . . . . . . . . . . . . . 123
9.4
Gimbal Lock . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
9.5
Yaw, Pitch and Roll
. . . . . . . . . . . . . . . . . . . . . . . . 132
9.6
Rotating a Point About an Arbitrary Axis . . . . . . . . . . . . . 134
9.6.1
Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . 134
9.6.2
Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . 137
9.7
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
9.7.1
Summary of Matrix Transforms . . . . . . . . . . . . . 141
10
Frames of Reference in Space . . . . . . . . . . . . . . . . . . . . . . 143
10.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
10.2
Frames of Reference . . . . . . . . . . . . . . . . . . . . . . . . 143
10.3
Matrix Transforms . . . . . . . . . . . . . . . . . . . . . . . . . 144
10.3.1
Translated Frames of Reference . . . . . . . . . . . . . 144
10.3.2
Rotated Frames of Reference About Cartesian Axes . . . 145
10.3.3
Rotated Frames About Off-Set Axes . . . . . . . . . . . 147
10.4
Composite Rotations . . . . . . . . . . . . . . . . . . . . . . . . 149

Contents
xv
10.5
Rotated and Translated Frames of Reference
. . . . . . . . . . . 150
10.6
Rotated Frames of Reference About Arbitrary Axes
. . . . . . . 152
10.7
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
10.7.1
Summary of Transforms . . . . . . . . . . . . . . . . . 153
11
Quaternion Transforms in Space . . . . . . . . . . . . . . . . . . . . 155
11.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
11.2
Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
11.3
Quaternions in Matrix Form . . . . . . . . . . . . . . . . . . . . 162
11.3.1
Quaternion Products and Matrices . . . . . . . . . . . . 164
11.3.2
Geometric Veriﬁcation . . . . . . . . . . . . . . . . . . 166
11.4
Multiple Rotations . . . . . . . . . . . . . . . . . . . . . . . . . 168
11.5
Eigenvalue and Eigenvector . . . . . . . . . . . . . . . . . . . . 169
11.6
Rotating About an Off-Set Axis . . . . . . . . . . . . . . . . . . 170
11.7
Frames of Reference . . . . . . . . . . . . . . . . . . . . . . . . 171
11.8
Interpolating Quaternions
. . . . . . . . . . . . . . . . . . . . . 173
11.9
Converting a Rotation Matrix to a Quaternion . . . . . . . . . . . 177
11.10 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
11.10.1 Summary of Quaternion Transforms . . . . . . . . . . . 178
12
Bivector Rotors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
12.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
12.2
The Three Reﬂections Theorem . . . . . . . . . . . . . . . . . . 181
12.3
Reﬂecting a Vector . . . . . . . . . . . . . . . . . . . . . . . . . 182
12.4
3D Rotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
12.5
Rotors as Matrices . . . . . . . . . . . . . . . . . . . . . . . . . 188
12.5.1
2D Rotor . . . . . . . . . . . . . . . . . . . . . . . . . 188
12.5.2
3D Rotor . . . . . . . . . . . . . . . . . . . . . . . . . 189
12.5.3
Extracting a Rotor
. . . . . . . . . . . . . . . . . . . . 191
12.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
12.6.1
Summary of Bivector Transforms
. . . . . . . . . . . . 195
13
Conclusion
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
Appendix A
Composite Point Rotation Sequences
. . . . . . . . . . . . 199
A.1
Euler Rotations . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
A.2
Rγ,xRβ,yRα,x
. . . . . . . . . . . . . . . . . . . . . . . . . . . 200
A.3
Rγ,xRβ,yRα,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
A.4
Rγ,xRβ,zRα,x . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
A.5
Rγ,xRβ,zRα,y . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
A.6
Rγ,yRβ,xRα,y
. . . . . . . . . . . . . . . . . . . . . . . . . . . 204
A.7
Rγ,yRβ,xRα,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
A.8
Rγ,yRβ,zRα,x . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
A.9
Rγ,yRβ,zRα,y . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
A.10
Rγ,zRβ,xRα,y . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
A.11
Rγ,zRβ,xRα,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209

xvi
Contents
A.12
Rγ,zRβ,yRα,x . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
A.13
Rγ,zRβ,yRα,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
Appendix B
Composite Frame Rotation Sequences . . . . . . . . . . . . 213
B.1
Euler Rotations . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
B.2
R−1
γ,xR−1
β,yR−1
α,x
. . . . . . . . . . . . . . . . . . . . . . . . . . . 214
B.3
R−1
γ,xR−1
β,yR−1
α,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
B.4
R−1
γ,xR−1
β,zR−1
α,x . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
B.5
R−1
γ,xR−1
β,zR−1
α,y . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
B.6
R−1
γ,yR−1
β,xR−1
α,y
. . . . . . . . . . . . . . . . . . . . . . . . . . . 217
B.7
R−1
γ,yR−1
β,xR−1
α,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
B.8
R−1
γ,yR−1
β,zR−1
α,x . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
B.9
R−1
γ,yR−1
β,zR−1
α,y . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
B.10
R−1
γ,zR−1
β,xR−1
α,y . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
B.11
R−1
γ,zR−1
β,xR−1
α,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
B.12
R−1
γ,zR−1
β,yR−1
α,x . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
B.13
R−1
γ,zR−1
β,yR−1
α,z . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
Appendix C
The Four n-Square Algebras . . . . . . . . . . . . . . . . . 227
C.1
Introduction
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
References
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
Index
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231


Chapter 1
Introduction
1.1 Rotation Transforms
In computer graphics the position of an object is expressed by two transforms:
translation and rotation. It is relatively easy to visualise a translation and express
it mathematically, however rotations do present problems. Furthermore, it is not just
objects that require rotating and translating – frames of reference have to be posi-
tioned within the world coordinate system in order to secure different views of the
virtual world. In order to do this, it is necessary to combine rotation and translation
transforms.
When rotating and translating objects, the angles and translation offsets are often
relative to a ﬁxed frame of reference. However, when rotating and translating frames
of reference, the angles and offsets are relative to a changing frame of reference,
which requires careful handling. Primarily, this book is about rotation transforms,
and how they are used for moving objects and frames of reference in the plane and
in 3D space. But in order to do this within a real computer graphics context, it is
necessary to include the translation transform, which introduces some realism to the
ﬁnal solution.
The world of mathematics offers a wide variety of rotation techniques to choose
from such as direction cosines, Euler angles, quaternions and multivectors. Each has
strengths and weaknesses, advocates and critics, therefore no attempt will be made
to identify a ‘best’ technique. However, I will attempt to draw your attention to their
qualities in order that you can draw your own conclusions.
1.2 Mathematical Techniques
Six branches of mathematics play an important role in rotations: trigonometry, com-
plex numbers, vectors, matrices, quaternions and multivectors, which are described
in the following chapters and ensure that this book is self contained. We only require
to consider certain aspects of trigonometry which will become foundations for the
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_1, © Springer-Verlag London Limited 2011
1

2
1
Introduction
other topics. Complex numbers are extremely useful from two perspectives: the ﬁrst
is that they pave the way to the idea of a rotational operator, and second, they play
an intrinsic part in quaternions and multivectors. Vectors provide a mechanism for
representing oriented lines, and together with complex numbers form the basis for
quaternions, which provide a mechanism for rotating points about an arbitrary axis.
Lastly, multivectors introduce the concept of oriented areas and volumes, and pro-
vide an algebra for undertaking a wide range of geometric operations, especially
rotations.
1.3 The Reader
This is an introductory book and is aimed at readers studying or working in com-
puter graphics who require an overview of the mathematics behind rotation trans-
forms. They are probably the same people I have encountered asking questions on
Internet forums about Euler angles, quaternions, gimbal lock and how to extract a
direction vector from a rotation matrix.
Many years ago, when writing a computer animation software, I encountered
gimbal lock and had to ﬁnd a way around the problem. Today, students and pro-
grammers are still discovering gimbal lock for the ﬁrst time, and that certain mathe-
matical techniques are not completely stable, and that special cases require detection
if their software is to remain operational.
1.4 Aims and Objectives of This Book
The aim of this book is to take the reader through the important ideas and mathemat-
ical techniques associated with rotation transforms, without becoming too pedantic
about mathematical terminology. My objective is to make the reader conﬁdent and
comfortable with the algebra associated with complex numbers, vectors, matrices,
quaternions and rotors, which seems like a daunting task. However, I believe that
this is achievable, and is why I have included a large number of worked examples,
and shown what happens when we ignore important rules.
1.5 Assumptions Made in This Book
I only expect the reader to be competent in handling algebraic expansions, and to
have a reasonable understanding of trigonometry and geometry. They will probably
be familiar with vectors but not necessarily with matrices, which is why I have
included chapters on these topics.

1.6
How to Use the Book
3
1.6 How to Use the Book
The book has a linear narrative and readers with different backgrounds can jump in
at any convenient point. Apart from explaining the mathematical techniques, I have
tried to introduce the reader to the mathematicians behind the techniques. Math-
ematicians such as Hamilton, Cayley, Gibbs, Clifford, Euler, Laplace, Sarrus and
Grassmann have all played a part in rotation transforms and associated mathemat-
ics, and are responsible for the techniques we use today. Hopefully, you will ﬁnd
this background material relevant and interesting.


Chapter 2
Complex Numbers
2.1 Introduction
Complex numbers have been described as the ‘king’ of numbers, probably because
they resolve all sorts of mathematical problems where ordinary real numbers fail.
For example, the rather innocent looking equation
1 + x2 = 0
has no real solution, which seems amazing when one considers the equation’s sim-
plicity. But one does not need a long equation to show that the algebra of real num-
bers is unable to cope with objects such as
x =
√
−1.
However, this did not prevent mathematicians from ﬁnding a way around such an
inconvenience, and fortuitously the solution turned out to be an incredible idea that
is used everywhere from electrical engineering to cosmology. The simple idea of
declaring the existence of a quantity i, such that i2 = −1, permits us to express the
solution to the above equation as
x = ±i.
All very well, you might say, but what is i? What is mathematics? One could also
ask, and spend an eternity searching for an answer! i is simply a mathematical object
whose square is −1. Let us continue with this strange object and see how it leads us
into the world of rotations.
2.2 Complex Numbers
A complex number has two parts: a real part and an imaginary part. The real part
is just an ordinary number that may be zero, positive or negative, and the imaginary
part is another real number multiplied by i. For example, 2+3i is a complex number
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_2, © Springer-Verlag London Limited 2011
5

6
2
Complex Numbers
where 2 is the real part and 3i is the imaginary part. The following are all complex
numbers:
2,
2 + 2i,
1 −3i,
−4i,
17i.
Note the convention to place the real part ﬁrst, followed by i. However, if i is as-
sociated with a trigonometric function such as sin or cos, it is usual to place i in
front of the function: i sinθ or i cosθ, to avoid any confusion that it is part of the
function’s angle.
All that we have to remember is that whenever we manipulate complex numbers,
the occurrence of i2 is replaced by −1.
2.2.1 Axioms
The axioms deﬁning the behaviour of complex numbers are identical to those asso-
ciated with real numbers. For example, given two complex numbers z1 and z2 they
obey the following rules:
Addition:
Commutative
z1 + z2 = z2 + z1
Associative
(z1 + z2) + z3 = z1 + (z2 + z3).
Multiplication:
Commutative
z1z2 = z2z1
Associative
(z1z2)z3 = z1 (z2z3)
Distributive
z1 (z2 + z3) = z1z2 + z1z3
(z1 + z2)z3 = z1z3 + z2z3.
2.3 The Modulus
The modulus of a complex number a + bi is deﬁned as
√
a2 + b2. For example, the
modulus of 3+4i is 5. In general, the modulus of a complex number z is written |z|:
z = a + bi
|z| =

a2 + b2.
We’ll see why this is so when we cover the polar representation of a complex num-
ber.

2.4
Addition and Subtraction
7
2.4 Addition and Subtraction
Given two complex numbers:
z1 = a + bi
z2 = c + di
z1 ± z2 = (a ± c) + (b ± d)i
where the real and imaginary parts are added or subtracted, respectively. For exam-
ple:
z1 = 5 + 3i
z2 = 3 + 2i
z1 + z2 = 8 + 5i
z1 −z2 = 2 + i.
2.5 Multiplication by a Scalar
A scalar is just an ordinary number, and may be used to multiply a complex number
using normal algebraic rules. For example, the complex number a +bi is multiplied
by the scalar λ as follows:
λ(a + bi) = λa + λbi
and a speciﬁc example:
2(3 + 5i) = 6 + 10i.
2.6 Product of Two Complex Numbers
The product of two complex numbers is evaluated by creating all the terms alge-
braically, and collecting up the real and imaginary terms:
z1 = a + bi
z2 = c + di
z1z2 = (a + bi)(c + di)
= ac + adi + bci + bdi2
= (ac −bd) + (ad + bc)i
which is another complex number. For example:

8
2
Complex Numbers
z1 = 3 + 4i
z2 = 5 −2i
z1z2 = (3 + 4i)(5 −2i)
= 15 −6i + 20i −8i2
= 15 + 14i + 8
= 23 + 14i.
Remember that the addition, subtraction and multiplication of complex numbers
obey the normal axioms of algebra. Also, the multiplication of two complex num-
bers, and their addition always results in a complex number, that is, the two opera-
tions are closed.
2.7 The Complex Conjugate
A special case exists when we multiply two complex numbers together where the
only difference between them is the sign of the imaginary part:
(a + bi)(a −bi) = a2 −abi + abi −b2i2
= a2 + b2.
As this real value is such an interesting result, a −bi is called the complex conjugate
of a + bi. In general, the complex conjugate of
z = a + bi
is written either with a bar ¯z symbol or an asterisk z∗as
z∗= a −bi
and implies that
zz∗= a2 + b2 = |z|2.
2.8 Division of Two Complex Numbers
The complex conjugate provides us with a mechanism to divide one complex num-
ber by another. For instance, consider the quotient
a + bi
c + di .
This can be resolved by multiplying the numerator and denominator by the complex
conjugate c −di to create a real denominator:

2.9
The Inverse
9
a + bi
c + di = (a + bi)(c −di)
(c + di)(c −di)
= ac −adi + bci −bdi2
c2 + d2
=
ac + bd
c2 + d2

+
bc −ad
c2 + d2

i.
Another special case is when a = 1 and b = 0:
1
c + di = (c + di)−1 =

c
c2 + d2

−

d
c2 + d2

i
which is the inverse of a complex number.
Let’s evaluate the quotient:
4 + 3i
3 + 4i .
Multiplying top and bottom by the complex conjugate 3 −4i we have
4 + 3i
3 + 4i = (4 + 3i)(3 −4i)
(3 + 4i)(3 −4i)
= 12 −16i + 9i −12i2
25
= 24
25 −7
25i.
2.9 The Inverse
Although we have already discovered the inverse of a complex number, let’s employ
another strategy by declaring
z1 = 1
z
where z is a complex number.
Next, we divide both sides by the complex conjugate of z to create
z1
z∗= 1
zz∗.
But we have previously shown that zz∗= |z|2, therefore,
z1
z∗=
1
|z|2
and rearranging, we have
z1 = z∗
|z|2 .
In general
1
z = z−1 = z∗
|z|2 .

10
2
Complex Numbers
As an illustration let’s ﬁnd the inverse of 3 + 4i
1
3 + 4i = (3 + 4i)−1
= 3 −4i
25
= 3
25 −4
25i.
Let’s test this result by multiplying z by its inverse:
(3 + 4i)
 3
25 −4
25i

= 9
25 −12
25i + 12
25i + 16
25 = 1
which conﬁrms the correctness of the inverse.
2.10 The Complex Plane
Leonhard Euler (1707–1783) (whose name rhymes with boiler) played a signiﬁcant
role in putting complex numbers on the map. His ideas on rotations are also used
in computer graphics to locate objects and virtual cameras in space, as we shall see
later on.
Consider the scenario depicted in Fig. 2.1. Any number on the number line is
related to the same number with the opposite sign via a rotation of 180°. For exam-
ple, when 2 is rotated 180° about zero, it becomes −2, and when −3 is rotated 180°
about zero it becomes 3.
But as we know that i2 = −1 we can write
−n = i2n.
If we now regard i2 as a rotation through 180°, then i could be a rotation through
90°!
Figure 2.2 shows how complex numbers can be interpreted as 2D coordinates
using the complex plane where the real part is the horizontal coordinate and the
Fig. 2.1 Rotating numbers
through 180° reverses their
sign

2.11
Polar Representation
11
Fig. 2.2 The graphical representation of complex numbers
imaginary part is the vertical coordinate. The ﬁgure also shows four complex num-
bers:
p = 1 + 2i,
q = −2 + i,
r = −1 −2i,
s = 2 −i
which happen to be 90° apart. For example, the complex number p in Fig. 2.2 is
rotated 90° to q by multiplying it by i:
i (1 + 2i) = i + 2i2
= −2 + i.
The point q is rotated another 90° to r by multiplying it by i:
i (−2 + i) = −2i + i2
= −1 −2i.
The point r is rotated another 90° to s by multiplying it by i:
i (−1 −2i) = −i −2i2
= 2 −i.
Finally, the point s is rotated 90° back to p by multiplying it by i:
i (2 −i) = 2i −i2
= 1 + 2i.
2.11 Polar Representation
The complex plane provides a simple mechanism to represent complex numbers
graphically. This in turn makes it possible to use a polar representation as shown

12
2
Complex Numbers
Fig. 2.3 Polar representation
of a complex number
in Fig. 2.3 where we see the complex number z = a + bi representing the oriented
line r. The length of r is obviously
√
a2 + b2, which is why the modulus of a com-
plex number has the same deﬁnition. We can see from Fig. 2.3 that the horizontal
component of z is r cosθ and the vertical component is r sinθ, which permits us to
write
z = a + bi
= r cosθ + ri sinθ
= r (cosθ + i sinθ).
Note that i has been placed in front of the sin function.
The angle θ between r and the real axis is called the argument and written arg(z),
and in this case
arg(z) = θ.
One of Euler’s discoveries concerns the relationship between the series for expo-
nential e, sin and cos:
eiθ = cosθ + i sinθ
which enables us to write
z = reiθ.
We are now in a position to revisit the product and quotient of two complex
numbers using polar representation. For example:
z = r (cosθ + i sinθ)
w = s (cosφ + i sinφ)
zw = rs (cosθ + i sinθ)(cosφ + i sinφ)
= rs

cosθ cosφ + i cosθ sinφ + i sinθ cosφ + i2 sinθ sinφ

= rs

(cosθ cosφ −sinθ sinφ) + i (sinθ cosφ + cosθ sinφ)

and as

2.12
Rotors
13
Fig. 2.4 The product of two complex numbers
cos(θ + φ) = cosθ cosφ −sinθ sinφ
sin(θ + φ) = sinθ cosφ + cosθ sinφ
zw = rs

cos(θ + φ) + i sin(θ + φ)

.
So the product of two complex numbers creates a third one with modulus
|zw| = rs
and argument
arg(zw) = arg(z) + arg(w) = θ + φ.
Let’s illustrate this with an example. Figure 2.4 shows two complex numbers
z = 1 + i,
w = 2i
therefore,
|z| =
√
2,
arg(z) = 45°
|w| = 2,
arg(w) = 90°
|zw| = 2
√
2
arg(zw) = 135°
which is another complex number −2 + 2i.
2.12 Rotors
The above observations imply that multiplying a complex number by another, whose
modulus is unity, causes no scaling. For example, multiplying 3 + 4i by 1 + 0i
creates the same complex number, unscaled and unrotated. However, multiplying
3 + 4i by 0 + i rotates it by 90° without any scaling.

14
2
Complex Numbers
Fig. 2.5 Rotating a complex
number about another
complex number
So to rotate 2 + 2i by 45° we must multiply it by
cos45° + i sin45° =
√
2
2 +
√
2
2 i
√
2
2 +
√
2
2 i

(2 + 2i) =
√
2 +
√
2i +
√
2i +
√
2i2
= 2
√
2i.
So now we have a rotor to rotate a complex number through any angle. In general,
the rotor to rotate a complex number a + bi through an angle θ is
Rθ = cosθ + i sinθ.
Now let’s consider the problem of rotating 3 + 3i, 45° about 2 + 2i as shown
in Fig. 2.5. From the ﬁgure, the result is z ≈2 + 3.414i, but let’s calculate it by
subtracting 2 + 2i from 3 + 3i to shift the operation to the origin, then multiply the
result by
√
2/2 +
√
2/2i, and then add back 2 + 2i:
z =
√
2
2 +
√
2
2 i

(3 + 3i) −(2 + 2i)

+ 2 + 2i
=
√
2
2 +
√
2
2 i

(1 + i) + 2 + 2i
=
√
2
2 +
√
2
2 i +
√
2
2 i −
√
2
2 + 2 + 2i
= 2 + (2 +
√
2)i
≈2 + 3.414i
which is correct. Therefore, to rotate any point (x,y) through an angle θ we convert
it into a complex number x + yi and multiply by the rotor cosθ + i sinθ:

2.13
Summary
15
x′ + y′i = (cosθ + i sinθ)(x + yi)
= (x cosθ −y sinθ) + (x sinθ + y cosθ)i
where (x′,y′) is the rotated point.
But as we shall see in Chap. 4, this is the transform for rotating a point (x,y)
about the origin:
x′
y′

=
cosθ
−sinθ
sinθ
cosθ
x
y

.
Before moving on let’s consider the effect the complex conjugate of a rotor has
on rotational direction, and we can do this by multiplying x +yi by the rotor cosθ −
i sinθ:
x′ + y′i = (cosθ −i sinθ)(x + yi)
= x cosθ + y sinθ −(x sinθ + y cosθ)i
which in matrix form is
x′
y′

=

cosθ
sinθ
−sinθ
cosθ
x
y

which is a rotation of −θ.
Therefore, we deﬁne a rotor Rθ and its conjugate R†
θ as
Rθ = cosθ + i sinθ
R†
θ = cosθ −i sinθ
where Rθ rotates +θ, and R†
θ rotates −θ. The dagger symbol ‘†’ is chosen as it is
used for rotors in multivectors, which are covered later.
2.13 Summary
There is no doubt that complex numbers are amazing objects and arise simply by
introducing the symbol i which squares to −1. It is unfortunate that the names
‘complex’ and ‘imaginary’ are used to describe them as they are neither complex
nor imaginary, but very simple. We will come across them again in later chapters
and see how they provide a way of rotating 3D points.
In this chapter we have seen that complex numbers can be added, subtracted,
multiplied and divided, and they can even be raised to a power. We have also come
across new terms such as: complex conjugate, modulus and argument. We have also
discovered the rotor which permits us to rotate 2D points.
In the mid-19th century, mathematicians started to look for the 3D equivalent
of complex numbers, and after many years of work, Sir William Rowan Hamilton
invented quaternions which are the subject of a later chapter.

16
2
Complex Numbers
2.13.1 Summary of Complex Operations
Complex number
z = a + bi
where i2 = −1.
Addition and subtraction
z1 = a + bi
z2 = c + di
z1 ± z2 = (a ± c) + (b ± d)i.
Scalar product
λz = λa + λbi.
Modulus
|z| =

a2 + b2.
Product
z1z2 = (ac −bd) + (ad + bc)i.
Complex conjugate
z∗= a −bi.
Division
z1
z2
=
ac + bd
c2 + d2

+
bc −ad
c2 + d2

i.
Inverse
z−1 = z∗
|z|2 .
Polar form
z = r (cosθ + i sinθ)
r = |z|
θ = arg(z)
z = reiθ.
Rotors
Rθ = cosθ + i sinθ
R†
θ = cosθ −i sinθ.

Chapter 3
Vectors
3.1 Introduction
Vectors can be used to represent all sorts of data from weather maps to magnetic
ﬁelds, and in computer graphics they are used to represent oriented lines and lo-
cate points in space. In 1853 Sir William Rowan Hamilton (1805–1865) published
his book Lectures on Quaternions [2] in which he described terms such as vector,
transvector and provector. Hamilton had been looking for a 3D equivalent to com-
plex numbers and discovered quaternions. However his work was not widely ac-
cepted until 1884, when the American mathematician Josiah Willard Gibbs (1839–
1903) published his treatise Elements of Vector Analysis, [3] describing modern
vector analysis.
3.2 Vector Notation
As a vector contains two or more numbers, its symbolic name is generally printed
using a bold font to distinguish it from a scalar variable. Examples being n, i and q.
When a vector is assigned its numeric values, the following notation is used
n =
2
3

.
The numbers 2 and 3 are the components of n and their position within the brackets
is very important.
Two types of notation are in use today: column vectors and row vectors. In this
book we use column vectors, although they can be transposed into a row vector
using this notation: n = [2
3]T. The superscript T reminds us of the column to row
transposition.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_3, © Springer-Verlag London Limited 2011
17

18
3
Vectors
Fig. 3.1 A vector is
represented by an oriented
line segment
3.3 Graphical Representation of Vectors
Cartesian coordinates provide an excellent mechanism for representing vectors and
allows them to be incorporated within the classical framework of mathematics. Fig-
ure 3.1 shows an oriented line segment used to represent a vector. The length of the
line represents the vector’s magnitude, and the line’s orientation and arrow deﬁne
its direction.
The line’s direction is determined by the vector’s head (xh,yh) and tail (xt,yt)
from which we compute its x- and y-components x and y:
x = xh −xt
y = yh −yt.
For example, in Fig. 3.1 the vector’s head is (6,4) and its tail is (1,1), which
makes its components x = 5 and y = 3 or [5
3]T. If the vector is pointing in the
opposite direction, its components become x = −5 and y = −3 or [−5
−3]T.
One can readily see from this notation that a vector does not have a unique posi-
tion in space. It does not matter where we place a vector, so long as we preserve its
length and orientation its components will not alter.
3.4 Magnitude of a Vector
The length or magnitude of a vector r is written |r| and is computed by applying the
theorem of Pythagoras to its components x and y:
|r| =

2x + 2y.
For example, the magnitude of vector [3
4]T is
√
32 + 42 = 5. Figure 3.2 shows
eight vectors, with their geometric properties listed in Table 3.1. The subscripts h
and t stand for head and tail respectively.

3.5
3D Vectors
19
Fig. 3.2 Eight vectors whose
coordinates are shown in
Table 3.1
Table 3.1 Values associated
with the eight vectors in
Fig. 3.2
xh
yh
xt
yt
x
y
|vector|
2
0
0
0
2
0
2
0
2
0
0
0
2
2
−2
0
0
0
−2
0
2
0
−2
0
0
0
−2
2
1
1
0
0
1
1
√
2
−1
1
0
0
−1
1
√
2
−1
−1
0
0
−1
−1
√
2
1
−1
0
0
1
−1
√
2
3.5 3D Vectors
A 3D vector simply requires an extra component to represent its z-component z:
r =

x
y
z
T
and its length is given by
|r| =

2x + 2y + 2z.
3.6 Vector Manipulation
Vectors are very different to scalars, and rules have been developed to control how
the two mathematical entities interact with one another. For instance, we need to
consider vector addition, subtraction and multiplication, and how a vector is modi-
ﬁed by a scalar. Let’s begin with multiplying a vector by a scalar.

20
3
Vectors
3.6.1 Multiplying a Vector by a Scalar
Given a vector n, 2n means that the vectors components are doubled. For example,
given
n = [3
4
5]T
then
2n = [6
8
10]T.
Similarly, dividing n by 2, its components are halved. Note that the vector’s direction
remains unchanged – only its magnitude changes. However, the vector’s direction is
reversed if the scalar is negative:
λ = −2
then
λn = [−6
−8
−10]T.
In general, given
n =
⎡
⎣
n1
n2
n3
⎤
⎦
then
± λn =
⎡
⎣
±λn1
±λn2
±λn3
⎤
⎦
where λ is a scalar.
3.6.2 Vector Addition and Subtraction
Given vectors r and s, r ± s is deﬁned as
r =
⎡
⎣
xr
yr
zr
⎤
⎦,
s =
⎡
⎣
xs
ys
zs
⎤
⎦
then
r ± s =
⎡
⎣
xr ± xs
yr ± ys
zr ± zs
⎤
⎦.
Vector addition is commutative:
a + b = b + a
e.g.
⎡
⎣
1
2
3
⎤
⎦+
⎡
⎣
4
5
6
⎤
⎦=
⎡
⎣
4
5
6
⎤
⎦+
⎡
⎣
1
2
3
⎤
⎦.
However, like scalar subtraction, vector subtraction is not commutative
a −b ̸= b −a
e.g.
⎡
⎣
4
5
6
⎤
⎦−
⎡
⎣
1
2
3
⎤
⎦̸=
⎡
⎣
1
2
3
⎤
⎦−
⎡
⎣
4
5
6
⎤
⎦.
3.7 Position Vectors
Given any point P(x,y,z), a position vector p is created by assuming that P is
the vector’s head and the origin is its tail. Because the tail coordinates are (0,0,0)
the vector’s components are x,y,z. Consequently, the vector’s length |p| equals

3.8
Unit Vectors
21

x2 + y2 + z2. For example, the point P(4,5,6) creates a position vector p relative
to the origin:
p = [4
5
6]T
and
|p| =

42 + 52 + 62 ≈20.88.
3.8 Unit Vectors
By deﬁnition, a unit vector has a length of 1. A simple example is i where
i = [1
0
0]T
and
|i| = 1.
Converting a vector into a unit form is called normalising and is achieved by di-
viding the vector’s components by its length. To formalise this process consider the
vector r = [x
y
z]T with length |r| =

x2 + y2 + z2. The unit form of r is given
by
ˆr = 1
|r|[x
y
z]T.
This process is conﬁrmed by showing that the length of ˆr is 1:
|ˆr| =
 x
|ˆr|
2
+
 y
|ˆr|
2
+
 z
|ˆr|
2
= 1
|ˆr|

x2 + y2 + z2
|ˆr| = 1.
To put this into context, consider the conversion of r = [1
2
3]T into a unit form:
|r| =

12 + 22 + 32 =
√
14
ˆr =
1
√
14
⎡
⎣
1
2
3
⎤
⎦≈
⎡
⎣
0.267
0.535
0.802
⎤
⎦.
3.9 Cartesian Vectors
We begin by deﬁning three Cartesian unit vectors i, j, k aligned with the x-, y- and
z-axes respectively:
i =
⎡
⎣
1
0
0
⎤
⎦,
j =
⎡
⎣
0
1
0
⎤
⎦,
k =
⎡
⎣
0
0
1
⎤
⎦.
Any vector aligned with the x-, y- or z-axes can be deﬁned by a scalar multiple of
the unit vectors i, j and k respectively. For example, a vector 10 units long aligned

22
3
Vectors
with the x-axis is 10i, and a vector 20 units long aligned with the z-axis is 20k. By
employing the rules of vector addition and subtraction we can compose a vector r
by summing three Cartesian unit vector as follows:
r = ai + bj + ck
which is equivalent to writing r as
r =
⎡
⎣
a
b
c
⎤
⎦
and means that the length of r is computed as
|r| =

a2 + b2 + c2.
Any pair of Cartesian vectors such as r and s are combined as follows
r = ai + bj + ck
s = di + ej + f k
r ± s = (a ± d)i + (b ± e)j + (c ± f )k.
For example:
r = 2i + 3j + 4k
s = 5i + 6j + 7k
r + s = 7i + 9j + 11k.
3.10 Scalar Product
The mathematicians who deﬁned the structure of vector analysis provided two ways
to multiply vectors together: one gives rise to a scalar result and the other a vector
result. For example, we could multiply two vectors r and s by using the product of
their magnitudes: |r||s|. Although this is a valid operation it ignores the orientation
of the vectors, which is one of their important features. The idea, however, is readily
developed into a useful operation by including the angle between the vectors.
Figure 3.3 shows two vectors r and s that have been drawn, for convenience,
such that their tails touch. Taking s as the reference vector – which is an arbitrary
choice – we compute the projection of r on s, which takes into account their relative
orientation. The length of r on s is |r|cosβ. We can now multiply the magnitude of
s by the projected length of r: |s||r|cosβ.
This scalar product is written
r · s = |r||s|cosβ.
(3.1)
The dot symbol ‘·’ is used to denote a scalar multiplication, which is why the product
is often referred to as the dot product. We now need to discover how to compute it.

3.10
Scalar Product
23
Fig. 3.3 Visualising the
scalar product
To begin, we deﬁne two Cartesian vectors r and s, and proceed to multiply them
together using the dot product deﬁnition:
r = ai + bj + ck
s = di + ej + f k
therefore,
r · s = (ai + bj + ck) · (di + ej + f k)
= ai · (di + ej + f k) + bj · (di + ej + f k) + ck · (di + ej + f k)
= adi · i + aei · j + af i · k + bdj · i + bej · j + bf j · k
+ cdk · i + cek · j + cf k · k.
Before we proceed any further, we can see that we have created various dot product
terms such as i · i, i · j, i · k, etc. These terms can be divided into two groups: those
that reference the same unit vector, and those that reference different unit vectors.
Using the deﬁnition of the dot product (3.1), terms such as i · i, j · j and k · k = 1,
because the angle between i and i, j and j, or k and k, is 0°, and cos0° = 1. But
because the other vector combinations are separated by 90°, and cos90° = 0, all
remaining terms collapse to zero. Bearing in mind that the magnitude of a unit vector
is 1, we can write
r · s = |r||s|cosβ = ad + be + cf.
This result conﬁrms that the dot product is indeed a scalar quantity.
Let’s use the scalar product to ﬁnd the angle between two vectors r and s:
r = [2
0
4]T
s = [5
6
10]T
|r| =

22 + 02 + 42 ≈4.472
|s| =

52 + 62 + 102 ≈12.689
|r||s|cosβ = 2 × 5 + 0 × 6 + 4 × 10 = 50
12.689 × 4.472 × cosβ = 50

24
3
Vectors
cosβ =
50
12.689 × 4.472 ≈0.8811
β = cos−1 0.8811 ≈28.22°.
The angle between the two vectors is approximately 28.22°, and β is always the
smallest angle associated with the geometry.
3.11 The Vector Product
The second way to multiply vectors is by using the vector product, which is also
called the cross product due to the ‘×’ symbol used in its notation. It is based on the
observation that two vectors r and s can be multiplied together to produce a third
vector t:
r × s = t
where
|t| = |r||s|sinβ
(3.2)
and β is the angle between r and s.
The vector t is normal (90°) to the plane containing the vectors r and s, which
makes it an ideal way of computing surface normals in computer graphics applica-
tions. Once again, let’s deﬁne two vectors and proceed to multiply them together
using the ‘×’ operator:
r = ai + bj + ck
s = di + ej + f k
r × s = (ai + bj + ck) × (di + ej + f k)
= ai × (di + ej + f k) + bj × (di + ej + f k) + ck × (di + ej + f k)
= adi × i + aei × j + af i × k + bdj × i + bej × j + bf j × k
+ cdk × i + cek × j + cf k × k.
As we found with the dot product, there are two groups of vector terms: those that
reference the same unit vector, and those that reference different unit vectors.
Using the deﬁnition for the cross product (3.2), operations such as i × i, j × j and
k × k result in a vector whose magnitude is 0. This is because the angle between the
vectors is 0°, and sin0° = 0. Consequently these terms vanish and we are left with
r × s = aei × j + af i × k + bdj × i + bf j × k + cdk × i + cek × j.
(3.3)
The mathematician Sir William Rowan Hamilton struggled for many years to gener-
alise complex numbers – and in so doing created a means of describing 3D rotations.
At the time, he was not using vectors – as they had yet to be deﬁned – but the imag-
inary terms i, j and k. Hamilton’s problem was to resolve the products ij, jk, ki
and their opposites ji, kj and ik.

3.11
The Vector Product
25
One day in 1843, when he was out walking, thinking about this problem, he
thought the impossible: ij = k, but ji = −k, jk = i, but kj = −i, and ki = j, but
ik = −j. To his surprise, this worked, but it contradicted the commutative multipli-
cation law of scalars. Although Hamilton had discovered “3D complex numbers”,
to which he gave the name quaternion, they were not popular with everyone. And as
mentioned above, Josiah Gibbs saw that converting the imaginary i, j and k terms
into the unit vectors i, j and k created a non-complex algebra for manipulating vec-
tors, and for over a century we have been using Gibbs’ vector notation.
Let’s continue with Hamilton’s rules and reduce the cross product terms of (3.3)
to
r × s = aek −af j −bdk + bf i + cdj −cei.
(3.4)
Equation (3.4) can be tidied up to bring like terms together:
r × s = (bf −ce)i + (cd −af )j + (ae −bd)k.
(3.5)
Now let’s repeat the original vector equations to see how (3.5) is computed:
r = ai + bj + ck
s = di + ej + f k
r × s = (bf −ce)i + (cd −af )j + (ae −bd)k.
(3.6)
To compute i’s scalar we consider the scalars associated with the other two unit
vectors, i.e. b, c, e, and f , and cross-multiply and subtract them to form (bf −ce).
To compute j’s scalar we consider the scalars associated with the other two unit
vectors, i.e. a, c, d, and f , and cross-multiply and subtract them to form (cd −af ).
To compute k’s scalar we consider the scalars associated with the other two unit
vectors, i.e. a, b, d, and e, and cross-multiply and subtract them to form (ae −bd).
The middle operation seems out of step with the other two, but in fact it pre-
serves a cyclic symmetry often found in mathematics. Nevertheless, some authors
reverse the sign of the j scalar term and cross-multiply and subtract the terms to
produce −(af −cd) which maintains a visual pattern for remembering the cross-
multiplication. Equation (3.6) now becomes
r × s = (bf −ce)i −(af −cd)j + (ae −bd)k.
(3.7)
Although we have not yet covered determinants, their notation allows us to write
(3.7) as
r × s =

b
c
e
f
i −

a
c
d
f
j +

a
b
d
e
k.
A 2 × 2 determinant is the difference between the product of the diagonal terms.
Therefore, to derive the cross product of two vectors we ﬁrst write the vectors
in the correct sequence. Remembering that r × s does not equal s × r. Second, we
compute the three scalar terms and form the resultant vector, which is perpendicular
to the plane containing the original vectors.
Let’s illustrate the vector product with two examples. First, we will conﬁrm that
the vector product works with the unit vectors i, j and k. We start with

26
3
Vectors
Fig. 3.4 The vector t is
normal to the vectors r and s
r = 1i + 0j + 0k
s = 0i + 1j + 0k
and then compute (3.7)
r × s = (0 × 0 −0 × 1)i −(1 × 0 −0 × 0)j + (1 × 1 −0 × 0)k.
The i scalar and j scalar terms are both zero, but the k scalar term is 1, which makes
i × j = k.
Now let’s show what happens when we reverse the vectors:
s × r = (1 × 0 −0 × 0)i −(1 × 0 −0 × 0)j + (0 × 0 −1 × 1)k.
The i scalar and j scalar terms are both zero, but the k scalar term is −1, which
makes j × i = −k. So we see that the vector product is antisymmetric, i.e. there is a
sign reversal when the vectors are reversed. Similarly, it can be shown that
j × k = i
k × i = j
k × j = −i
i × k = −j.
Now let’s consider two vectors r and s and compute the normal vector t. The vec-
tors are chosen so that we can anticipate approximately the answer. For the sake of
clarity, the vector equations include the scalar multipliers 0 and 1. Normally, these
would be omitted. Figure 3.4 shows the vectors r and s and the normal vector t, and
Table 3.2 contains the coordinates of the vertices forming the two vectors.
r =
⎡
⎣
x3 −x2
y3 −y2
z3 −z2
⎤
⎦,
s =
⎡
⎣
x1 −x2
y1 −y2
z1 −z2
⎤
⎦
then
P1 = (0,0,1),
P2 = (1,0,0),
P3 = (0,1,0)
r = −1i + 1j + 0k

3.12
The Right-Hand Rule
27
Table 3.2 Coordinates of the
vertices used in Fig. 3.4
Vertex
x
y
z
P1
0
0
1
P2
1
0
0
P3
0
1
0
s = −1i + 0j + 1k
r × s = (1 × 1 −0 × 0)i −(−1 × 1 −(−1) × 0)j + (−1 × 0 −(−1) × 1)k
t = i + j + k.
This conﬁrms what we expected from Fig. 3.4. Now let’s reverse the vectors to
illustrate the importance of vector sequence:
s × r = (0 × 0 −1 × 1)i −(−1 × 0 −(−1) × 1)j + (−1 × 1 −(−1) × 0)k
t = −i −j −k
which is in the opposite direction to r × s and conﬁrms that the vector product is
non-commutative.
3.12 The Right-Hand Rule
When we cover multivectors we will see that lines, planes and volumes are all ori-
ented and can be described mathematically. In particular, 3D space is described as
being left- or right-handed, and in this book we choose to work with a right-handed
space. Consequently, the right-hand rule is an aide mémoire for working out the
orientation of the cross product vector. Given the operation r × s, if the right-hand
thumb is aligned with r, the ﬁrst ﬁnger with s, and the middle ﬁnger points in the
direction of t.
3.13 Deriving a Unit Normal Vector
Figure 3.5 shows a triangle with vertices deﬁned in an anti-clockwise sequence from
its visible side. This is the side from which we want the surface normal to point.
Using the following information we will compute the surface normal using the cross
product and then convert it to a unit normal vector.
Create vector r between P1 and P3, and vector s between P2 and P3:
r = −1i + 1j + 0k
s = −1i + 0j + 2k
r × s = (1 × 2 −0 × 0)i −(−1 × 2 −0 × −1)j + (−1 × 0 −1 × −1)k
t = 2i + 2j + k

28
3
Vectors
Fig. 3.5 The normal vector t
is derived from the cross
product r × s
|t| =

22 + 22 + 12 = 3
ˆtu = 2
3i + 2
3j + 1
3k.
3.14 Interpolating Vectors
In computer animation we need to vary quantities such as height, width, depth, light
intensity, radius, etc., such that they change over a sequence of animation frames.
The change may be linear or non-linear, and a variety of techniques exist for chang-
ing one numeric value into another. This process is called interpolating.
To interpolate between two values v1 and v2 we often use the linear interpolant:
v = (1 −t)v1 + tv2
where the parameter t varies between 0 and 1. For example, given v1 = 2 and v2 =
10 we can compute a half-way point by making t = 0.5:
v = 0.5 × 2 + 0.5 × 10 = 6
where t is linked to the animation frame number.
However, this technique cannot be used for changing quantities such as a light
source direction, dust-cloud particle velocity, or the direction and intensity of a
ﬂame. This is because these quantities possess both magnitude and direction – they
are vector quantities.
For example, if we interpolated the x- and y-components of the vectors [2
3]T
and [4
7]T, the in-between vectors would carry the change of orientation but ignore
the change in magnitude. To preserve both, we must design a spherical interpolant
that is sensitive to a vector’s length and orientation.
Figure 3.6 shows two unit vectors v1 and v2 separated by an angle θ. The inter-
polated vector v can be deﬁned as a portion of v1 and a portion of v2:
v = av1 + bv2.
Let’s deﬁne the values of a and b such that they are a function of the separating
angle θ. Vector v is tθ from v1 and (1 −t)θ from v2, and it is evident from Fig. 3.6
that using the sine rule
a
sin(1 −t)θ =
b
sintθ .
(3.8)

3.14
Interpolating Vectors
29
Fig. 3.6 Vector v is derived
from a part of v1 and b part
of v2
Furthermore,
m = a costθ
n = b cos(1 −t)θ
where
m + n = 1.
(3.9)
From (3.8)
b =
a sintθ
sin(1 −t)θ
and from (3.9) we get
a costθ + a sintθ cos(1 −t)θ
sin(1 −t)θ
= 1.
Solving for a we ﬁnd that
a = sin(1 −t)θ
sinθ
b = sintθ
sinθ .
Therefore, the ﬁnal spherical interpolant is
v = sin(1 −t)θ
sinθ
v1 + sintθ
sinθ v2.
(3.10)
To see how this operates, let’s consider a simple exercise of interpolating be-
tween two unit vectors [1
0]T and [−1/
√
2
1/
√
2]T. The angle θ between the
vectors is 135°. Equation (3.10) is used to interpolate individually the x- and the
y-components individually:
vx = sin(1 −t)135°
sin135°
× (1) + sint135°
sin135° ×

−1
√
2

vy = sin(1 −t)135°
sin135°
× (0) + sint135°
sin135° ×
 1
√
2

.

30
3
Vectors
Fig. 3.7 Curves of the interpolated angles
Fig. 3.8 A trace of the
interpolated vectors between
[1
0]T and [−1
√
2
1
√
2]T
Figure 3.7 shows the interpolating curves and Fig. 3.8 shows the positions of the
interpolated vectors, and a trace of the interpolated vectors.
Two observations to note about (3.10):
• First, the angle θ is the angle between the two vectors, which, if not known, can
be computed using the dot product.
• Second, the range of θ is given by 0 < θ < 180°, for when θ = 0°,180° the
denominator collapses to zero. To illustrate this we will repeat (3.10) for θ =
179°.
The result is shown in Fig. 3.9, which reveals clearly that the interpolant works
normally over this range. One more degree, however, and it fails! Nevertheless, one
could still leave the range equal to 180° and test for the conditions t = 0 then v = v1
and when t = 180° then v = v2.
So far, we have only considered unit vectors. Now let’s see how the interpolant
responds to vectors of different magnitudes. As a test, we can input the following
vectors to (3.10):
v1 =
2
0

and
v2 =
0
1

.
The separating angle θ = 90°, and the result is shown in Fig. 3.10. Note how the
initial length of v1 reduces from 2 to 1 over 90°. It is left to the reader to examine
other combinations of vectors.

3.15
Summary
31
Fig. 3.9 Interpolating between two unit vectors 179° apart
Fig. 3.10 Interpolating
between the vectors [2
0]T
and [0
1]T
3.15 Summary
This chapter has covered the important features of vectors relevant to rotations. Ba-
sically, we need to know how to create a position vector, normalise a vector, and
multiply two vectors using the scalar and vector product. In Chap. 6, we explore the
ideas of multivectors, which build upon the contents of this chapter.
3.15.1 Summary of Vector Operations
Vector
v = [x
y
z]T
v = xi + yj + zk.
Addition and subtraction
v1 = x1i + y1j + z1k
v2 = x2i + y2j + z2k
v1 ± v2 = (x1 ± x2)i + (y1 ± y2)j + (z1 ± z2)k.

32
3
Vectors
Scalar product
λv = λxi + λyj + λzk.
Magnitude
|v| =

x2 + y2 + z2.
Unit vector
|v| = 1.
Scalar product
v1 · v2 = |v1||v2|cosβ
v1 · v2 = x1x2 + y1y2 + z1z2.
Vector product
v1 × v2 = t
|t| = |v1||v2|sinβ
v1 × v2 = (y1z2 −z1y2)i + (z1x2 −x1z2)j + (x1y2 −y1x2)k.
Interpolating vectors
v = sin(1 −t)θ
sinθ
v1 + sintθ
sinθ v2
[0 < t < 1].

Chapter 4
Matrices
4.1 Introduction
Matrix notation was investigated by the British mathematician, Arthur Cayley
(1821–1895), in 1858, ﬁfteen years after the invention of quaternions. Cayley and
others had realised that it was possible to express a collection of equations by sepa-
rating constants and variables. For example, the following simultaneous equations
2x + 3y = 18
(4.1)
4x −y = 8
(4.2)
have a solution x = 3 and y = 4, which can be discovered by eliminating one vari-
able, such as x, and computing y, which in turn can be substituted into one of the
equations to reveal the value of x. However, matrix notation allows us to express the
equations as follows
2
3
4
−1
x
y

=
18
8

(4.3)
where the array of four numbers is a matrix and the other two columns are vectors.
When multiplying the matrix and the vector [x
y]T together we must multiply the
respective terms of the top row of the matrix with the column vector to equal 18 and
create (4.1). Similarly, we must multiply the respective terms of the bottom row of
the matrix with the column vector to equal 8 and create (4.2).
Matrix notation also allows us to express these equations as
Av = c
(4.4)
where
A =
2
3
4
−1

,
v =
x
y

,
c =
18
8

.
There happens to be a special matrix such that when it multiplies a vector it
results in no change – this matrix is called an identity matrix and has the form
I =
1
0
0
1

.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_4, © Springer-Verlag London Limited 2011
33

34
4
Matrices
It is also possible to compute another matrix A−1, called the inverse of A, such that
A−1A = I. Therefore, if we assume that A is still
A =
2
3
4
−1

and is invertible, we can compute A−1 and use it to multiply both sides of (4.4), we
have
A−1Av = A−1c
Iv = A−1c
v = A−1c
which reveals the components of the vector v, and the solution to the equations.
Without showing its derivation, the inverse of A is
A−1 = 1
14
1
3
4
−2

(4.5)
and when we multiply c by A−1 we get
A−1c = 1
14
1
3
4
−2
18
8

=
3
4

which is the desired result.
Matrices can also be regarded as rectangular arrays of numbers, which may pos-
sess various properties. For instance, we can imagine a matrix where all the elements
have the same value. We could also create a matrix where all the elements are zero,
apart from the diagonal elements. There are many more such conﬁgurations, which
are explored in this chapter.
If this is the ﬁrst time you have met matrices, then the author’s book Mathematics
for Computer Graphics [4] will provide you with the necessary background. So for
the moment, let’s continue and discover more about matrices.
4.2 Matrices
Let’s begin by deﬁning a matrix as a rectangular array of numbers with row rows and
col columns, where any element in the matrix is addressed by arow,col. The matrix
of numbers can be represented in shorthand as
A = [arow,col]
where row and col are natural numbers. However, matrices representing 2D and 3D
rotations are all square, where the number of rows equals the number of columns.
The following are all examples of square matrices:
1
2
3
4

,
⎡
⎣
1
2
3
4
5
6
7
8
9
⎤
⎦,
⎡
⎢⎢⎣
1
2
3
4
5
6
7
8
9
8
7
6
5
4
3
2
⎤
⎥⎥⎦.

4.3
The Transpose of a Matrix
35
We will discover in later chapters that a 4 × 4 matrix is the largest matrix we will
require to represent a 3D rotation. Now let’s look at some of the ways we manipulate
matrices.
4.3 The Transpose of a Matrix
One useful matrix operation is the transpose where every element arow,col is ex-
changed with its transpose acol,row, and is written
AT = [arow,col]T = [acol,row].
For example, here is a matrix A and its transpose AT
A =
1
2
3
4

,
AT =
1
3
2
4

.
It is possible that the elements of A are such that A = AT. Such a matrix is called a
symmetric matrix, and we will examine this later.
4.4 The Identity Matrix
As mentioned above, the identity matrix I is a matrix such that
IA = AI = A.
The three identity matrices we will encounter in later chapters are
1
0
0
1

,
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦,
⎡
⎢⎢⎣
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
and it should be obvious that IT = I.
4.5 Adding and Subtracting Matrices
It is possible to add and subtract matrices so long as they have the same number of
rows and columns. For example, in matrix notation
A ± B = [arow,col ± brow,col].
For example:
A =
5
6
7
8

,
B =
1
2
3
4

then
A + B =
 6
8
10
12

,
A −B =
4
4
4
4

.

36
4
Matrices
4.6 Multiplying a Matrix by a Scalar
Multiplying a matrix by a scalar λ is the same as multiplying an equation by the
same scalar. Therefore,
±λA = [±λarow,col].
For example, if λ = 2
A =
1
2
3
4

,
λA =
2
4
6
8

.
4.7 Product of Two Matrices
As already mentioned, every element in a matrix has a unique address speciﬁed
by its row and column: arow,col where a comma separates the values of row and
col. However, these commas can make the notation very fussy and are not always
employed. For example, a11 represents the element for row = 1 and col = 1, and
a23 represents the element for row = 2 and col = 3. In this book, we never need
to manipulate matrices with more that 4 rows or columns, therefore, there is no
confusion.
Matrices have their origins in algebra, therefore matrix algebra must agree with
its algebraic counterpart. Bearing this in mind, let’s investigate the product of two
matrices:
A =
a11
a12
a21
a22

,
B =
b11
b12
b21
b22

then their product is given by
AB =
a11b11 + a12b21
a11b12 + a12b22
a21b11 + a22b21
a21b12 + a22b22

.
For example, given
A =
5
6
7
8

,
B =
1
2
3
4

then
AB =
5 × 1 + 6 × 3
5 × 2 + 6 × 4
7 × 1 + 8 × 3
7 × 2 + 8 × 4

=
5 + 18
10 + 24
7 + 24
14 + 32

=
23
34
31
46

.

4.8
The Inverse Matrix
37
Now let’s compute BA
BA =
1 × 5 + 2 × 7
1 × 6 + 2 × 8
3 × 5 + 4 × 7
3 × 6 + 4 × 8

=
19
22
43
50

which conﬁrms that, in general, matrix multiplication is non-commutative.
It can also be shown that
[AB]T = BTAT
and
[A + B]T = AT + BT.
4.8 The Inverse Matrix
Most mathematics software systems include a matrix inversion package, but for
completeness, let’s demonstrate how we arrived at the inverse matrix A−1 (4.5):
A−1 = 1
14
1
3
4
−2

.
Initially, we started with the simultaneous equations
2x + 3y = 18
(4.6)
4x −y = 8.
(4.7)
Solving these algebraically we multiply (4.7) by 3 and add it to (4.6) to eliminate y:
2x + 3y = 18
12x −3y = 24
14x = 42
x = 3.
Substituting x = 3 in (4.6) gives
6 + 3y = 18
which makes y = 4.
4.8.1 Calculation of Inverse
Now let’s solve (4.6) and (4.7) using matrix notation. We begin with
Av = c

38
4
Matrices
where
A =
2
3
4
−1

,
v =
x
y

,
c =
18
8

.
Next we introduce an identity matrix, which does not disturb anything:
Av = Ic
(4.8)
2
3
4
−1
x
y

=
1
0
0
1
18
8

.
(4.9)
The objective is to multiply both sides of (4.8) by A−1 and turn the LHS matrix A
into an identity matrix, and at the same time turn the RHS matrix I into A−1. But
as we don’t know A−1 we will have to do this in a number of steps. Like the above
simultaneous equations, we can scale, add, subtract or divide matrix rows, so long
as we manipulate the entire matrix equation.
We start by subtracting 2 × row(1) from row(2) in (4.9):
2
3
0
−7
x
y

=

1
0
−2
1
18
8

.
(4.10)
Next, multiply row(1) × 7
3 in (4.10):
 14
3
7
0
−7
x
y

=

7
3
0
−2
1
18
8

.
(4.11)
Next, add row(2) to row(1) in (4.11):
 14
3
0
0
−7
x
y

=

1
3
1
−2
1
18
8

.
(4.12)
Next, multiply row(1) × 3
14 in (4.12):
1
0
0
−7
x
y

=

1
14
3
14
−2
1
18
8

.
(4.13)
Finally, divide row(2) by −7 in (4.13):
1
0
0
1
x
y

=

 1
14
3
14
2
7
−1
7
18
8

.
(4.14)
As the LHS matrix is an identity matrix, the RHS matrix in (4.14) must be A−1 and
is tidied up to become
A−1 = 1
14
1
3
4
−2

.
Later on, we will explore another technique that does not involve any overt algebraic
skills.

4.9
Determinant of a Matrix
39
4.9 Determinant of a Matrix
When solving a pair of simultaneous equations such as
ax + by = r
cx + dy = s
the expression ad −bc arises in the solution. For example, in the simultaneous
equations (4.6) and (4.7) the corresponding expression has a value 2 × (−1) −3 ×
4 = −14 whose magnitude appears in the solution of A−1. Because this expression
is so useful, it is identiﬁed by the name determinant and is written
detA = |A| = ad −bc
where
A =
a
b
c
d

.
Determinants are formed from square arrays, in that they have the same number
of rows and columns, which permits us to classify them in terms of their order.
Some texts classify a scalar quantity as a ﬁrst-order determinant – for example a.
A second-order determinant has two rows and columns – for example

a
b
c
d
.
When dealing with three simultaneous equations
ax + by + cz = r
dx + ey + f z = s
gx + hy + iz = t
the corresponding matrix is
A =
⎡
⎣
a
b
c
d
e
f
g
h
i
⎤
⎦
and the equivalent determinant is
aei + bfg + cdh −ceg −af h −bdi.
4.9.1 Sarrus’s Rule
The French mathematician, J.P. Sarrus (1789–1861), noted that a third-order de-
terminant is easily computed by exploiting a pattern which is very obvious if the
determinant’s columns are extended as follows:

a
b
c
a
b
d
e
f
d
e
g
h
i
g
h

.

40
4
Matrices
aei, bfg and cdh are strings of elements sloping downwards to the right, whereas,
ceg, af h and bdi are strings of elements sloping downwards to the left. For exam-
ple, the determinant
detA =

2
0
4
3
1
0
4
2
2

has a value of
|A| = (2 × 1 × 2) + (0 × 0 × 4) + (4 × 3 × 2)
−(4 × 1 × 4) −(2 × 0 × 2) −(0 × 3 × 2)
= 4 + 0 + 24 −16 −0 −0
|A| = 12.
In general
detA = |A| = aei + bfg + cdh −ceg −af h −bdi
(4.15)
and the expansion is known as Sarrus’s rule.
Equation (4.15) can be rearranged to reveal another pattern:
|A| = a(ei −f h) + b(fg −di) + c(dh −eg)
where the expressions
(ei −f h),
(fg −di),
(dh −eg)
are regarded as minor determinants. Let’s pause at this juncture and examine |A|’s
minor determinants:

a
b
c
d
e
f
g
h
i

=

a
e
f
h
i

−

b
d
f
g
i

+

c
d
e
g
h

.
(4.16)
Equation (4.16) shows how a third-order determinant can be represented as the sum
of three minor determinants:

a
b
c
d
e
f
g
h
i

= a

e
f
h
i
 −b

d
f
g
i
 + c

d
e
g
h
.
Note that the middle minor determinant is preﬁxed with a negative sign. This ensures
that the equation’s value is the same as (4.15). The reason for this is that mathematics
is not interested in forming convenient visual patterns on the page – its patterns are
created from cycles of elements or subscripts. Consequently, if we prefer a visual
pattern as an aide-mémoire, we must make the necessary algebraic adjustments to
maintain the equation’s integrity. For example, by repeating the ﬁrst column of |A|
as follows

a
b
c
a
d
e
f
d
g
h
i
g


4.9
Determinant of a Matrix
41
the pattern (fg −di) is now very obvious. However, it is widely agreed that it is
best to ignore this and embrace a simple visual pattern. The price to be paid for this
is a negative sign as follows:
|A| = a(ei −f h) −b(di −fg) + c(dh −eg).
4.9.2 The Laplace Expansion
The French mathematician, Pierre Simon de Laplace (1749–1827), developed a
method of expanding a determinant in terms of its minors, which, with the associ-
ated change of sign, is called a cofactor. The cofactor crow,col of an element arow,col
is the minor that remains after removing from the original determinant the row row
and the col column.
For example, in (4.17) the minor of a11 is identiﬁed by removing the ﬁrst row
and the ﬁrst column; the minor of a12 is identiﬁed by removing the ﬁrst row and the
second column; and the minor of a13 is identiﬁed by removing the ﬁrst row and the
third column:
detA =

a11
a12
a13
a21
a22
a23
a31
a32
a33

.
(4.17)
The three minor determinants for a11, a12 and a13 are respectively:
A11 =

a22
a23
a32
a33
,
A12 =

a21
a23
a31
a33
,
A13 =

a21
a22
a31
a32

whereas, the three cofactors are
c11 = +a11A11
c12 = −a12A12
c13 = +a13A13.
In general, the minor of arow,col is denoted Arow,col.
Laplace proposed the following formulae for selecting the cofactor sign:
(−1)row+col
which generates the pattern

+
−
+
...
−
+
−
...
+
−
+
...
...
...
...
...

.
Although we have chosen the ﬁrst row to expand the above determinants, any row,
or column may be used.

42
4
Matrices
The above Laplace expansion can be used for any order determinant, and for
the purposes of this book, the highest order we will encounter is a fourth-order
determinant. So let’s expand the following determinant
detA =

0
4
−1
0
1
0
1
4
0
6
3
3
3
5
2
2

.
The ﬁrst column and the ﬁrst row both contain two zeros, which helps our expansion,
so let’s expand |A| using the ﬁrst row. The two relevant minor determinants are
A12 =

1
1
4
0
3
3
3
2
2

,
A13 =

1
0
4
0
6
3
3
5
2

.
Next, we expand A12 and A13 with their cofactors as follows
c12 = −4

1(−1)1+1

3
3
2
2
 + 1(−1)1+2

0
3
3
2
 + 4(−1)1+3

0
3
3
2


= −4[0 + 9 −36]
= 108
c13 = −1

1(−1)1+1

6
3
5
2
 + 4(−1)1+3

0
6
3
5


= −1[−3 −72]
= 75.
Therefore,
detA = c12 + c13 = 108 + 75 = 183.
4.10 Cofactors and Inverse of a Matrix
Although the idea of cofactors has been described in the context of determinants,
they can also be applied to matrices. For example, let’s start with the following
matrix and its cofactor matrix
A =
⎡
⎣
0
1
3
2
1
4
4
2
6
⎤
⎦
cofactor matrix of A =
⎡
⎣
A11
A12
A13
A21
A22
A23
A31
A32
A33
⎤
⎦

4.10
Cofactors and Inverse of a Matrix
43
where
A11 = +

a22
a23
a32
a33
 = +

1
4
2
6
 = −2
A12 = −

a21
a23
a31
a33
 = −

2
4
4
6
 = 4
A13 = +

a21
a23
a31
a33
 = +

2
1
4
2
 = 0
A21 = −

a22
a23
a32
a33
 = −

1
3
2
6
 = 0
A22 = +

a11
a13
a31
a33
 = +

0
3
4
6
 = −12
A23 = −

a11
a12
a31
a32
 = −

0
1
4
2
 = 4
A31 = +

a12
a13
a22
a23
 = +

1
3
1
4
 = 1
A32 = −

a11
a13
a21
a23
 = −

0
3
2
4
 = 6
A33 = +

a11
a12
a21
a22
 = +

0
1
2
1
 = −2
therefore, the cofactor matrix of A is
cofactor matrix of A =
⎡
⎣
−2
4
0
0
−12
4
1
6
−2
⎤
⎦.
It can be shown that the product of a matrix with the transpose of its cofactor matrix
has the following form:
A(cofactor matrix of A)T =
⎡
⎢⎢⎣
detA
0
...
0
0
detA
...
0
...
...
...
...
0
0
0
detA
⎤
⎥⎥⎦
and multiplying throughout by 1/detA we have
(1/detA)A(cofactor matrix of A)T = I
which implies that
A−1 = (cofactor matrix of A)T
detA
.
Naturally, this assumes that the inverse actually exists, and it will if detA ̸= 0.

44
4
Matrices
Let’s ﬁnd the inverse of the above matrix
A =
⎡
⎣
0
1
3
2
1
4
4
2
6
⎤
⎦
(cofactor matrix of A) =
⎡
⎣
−2
4
0
0
−12
4
1
6
−2
⎤
⎦
(cofactor matrix of A)T =
⎡
⎣
−2
0
1
4
−12
6
0
4
−2
⎤
⎦
detA = 1 × 4 × 4 + 3 × 2 × 2 −1 × 2 × 6 −3 × 1 × 4 = 4
A−1 = 1
4
⎡
⎣
−2
0
1
4
−12
6
0
4
−2
⎤
⎦.
Let’s check this result by multiplying A by A−1 which must equal I:
AA−1 =
⎡
⎣
0
1
3
2
1
4
4
2
6
⎤
⎦1
4
⎡
⎣
−2
0
1
4
−12
6
0
4
−2
⎤
⎦
= 1
4
⎡
⎣
4
0
0
0
4
0
0
0
4
⎤
⎦
=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦.
Finally, let’s compute the inverse matrix for (4.6) and (4.7) using cofactors:
A =
2
3
4
−1

(cofactor matrix of A) =
−1
−4
−3
2

(cofactor matrix of A)T =
−1
−3
−4
2

detA = 2 × (−1) −3 × 4 = −14
A−1 = 1
14
1
3
4
−2

which conﬁrms the original result.
In general, the inverse of a 2 × 2 matrix is given by
A =
a11
a12
a21
a22


4.11
Orthogonal Matrix
45
A−1 =
1
a11a22 −a12a21

a22
−a12
−a21
a11

which, for the above matrix is
A−1 = −1
14
−1
−3
−4
2

= 1
14
1
3
4
−2

.
4.11 Orthogonal Matrix
Although many matrices have to be inverted using the transpose of their cofactor
matrix, an orthogonal matrix implies that its transpose is also its inverse. For exam-
ple:
A =
cosβ
−sinβ
sinβ
cosβ

is orthogonal because
AT =

cosβ
sinβ
−sinβ
cosβ

and
AAT =
cosβ
−sinβ
sinβ
cosβ

cosβ
sinβ
−sinβ
cosβ

=
1
0
0
1

.
Orthogonal matrices play an important role in rotations because they leave the origin
ﬁxed and preserve all angles and distances. Consequently, an object’s geometric
integrity is maintained after a rotation, which is why an orthogonal transform is
known as a rigid motion transform.
A rotation transform also preserves orientations, which means that left-handed
and right-handed axial systems (frames) remain unaltered after a rotation. Such
changes in orientation will occur with a reﬂection transform.
4.12 Diagonal Matrix
A diagonal matrix is a square matrix whose elements are zero, apart from its diag-
onal:
A =
⎡
⎢⎢⎢⎣
a11
0
...
0
0
a22
...
0
...
...
...
...
0
0
...
ann
⎤
⎥⎥⎥⎦.
The determinant of a diagonal matrix must be
detA = a11 × a22 × ··· × ann.

46
4
Matrices
Here is a diagonal matrix with its determinant
A =
⎡
⎣
2
0
0
0
3
0
0
0
4
⎤
⎦
|A| = 2 × 3 × 4 = 24.
The identity matrix I is a diagonal matrix with a determinant of 1.
4.13 Trace
The trace of a square matrix A is the sum of its diagonal elements and written as
Tr(A). For example:
A =
⎡
⎢⎢⎣
1
2
3
4
2
3
4
5
3
4
5
6
4
5
6
7
⎤
⎥⎥⎦
Tr(A) = 1 + 3 + 5 + 7 = 16.
In Chap. 9 we use the trace of a square matrix to reveal the angle of rotation
associated with a rotation matrix. And as we will be using the product of two or
more rotation transforms we require to establish that
Tr(AB) = Tr(BA)
to reassure ourselves that the trace operation is not sensitive to transform order, and
is readily proved as follows.
Given two square matrices A and B:
A =
⎡
⎢⎢⎣
a11
···
···
a1n
···
a22
···
a2n
···
···
···
···
an1
···
···
ann
⎤
⎥⎥⎦,
B =
⎡
⎢⎢⎣
b11
···
···
b1n
···
b22
···
b2n
···
···
···
···
bn1
···
···
bnn
⎤
⎥⎥⎦
then,
AB =
⎡
⎢⎢⎣
a11
···
···
a1n
···
a22
···
a2n
···
···
···
···
an1
···
···
ann
⎤
⎥⎥⎦
⎡
⎢⎢⎣
b11
···
···
b1n
···
b22
···
b2n
···
···
···
···
bn1
···
···
bnn
⎤
⎥⎥⎦
AB =
⎡
⎢⎢⎣
a11b11
···
···
a1n
···
a22b22
···
a2n
···
···
···
···
an1
···
···
annbnn
⎤
⎥⎥⎦
and Tr(AB) = a11b11 + a22b22 + ··· + annbnn.

4.14
Symmetric Matrix
47
Hopefully, it is obvious that reversing the matrix sequence to BA only reverses
the a and b scalar elements on the diagonal, and therefore does not affect the trace
operation.
4.14 Symmetric Matrix
It is worth exploring two types of matrices called symmetric and antisymmetric ma-
trices, as we refer to them in later chapters. A symmetric matrix is a matrix which
equals its own transpose:
A = AT.
For example, the following matrix is symmetric:
A =
⎡
⎣
1
3
4
3
2
4
4
4
3
⎤
⎦.
The symmetric part of any square matrix can be isolated as follows. Given a matrix
A and its transpose AT
A =
⎡
⎢⎢⎢⎣
a11
a12
...
a1n
a21
a22
...
a2n
...
...
...
...
an1
an2
...
ann
⎤
⎥⎥⎥⎦,
AT =
⎡
⎢⎢⎢⎣
a11
a21
...
an1
a12
a22
...
an2
...
...
...
...
a1n
a2n
...
ann
⎤
⎥⎥⎥⎦
their sum is
A + AT =
⎡
⎢⎢⎢⎣
2a11
a12 + a21
...
a1n + an1
a12 + a21
2a22
...
a2n + an2
...
...
...
...
a1n + an1
a2n + an2
...
2ann
⎤
⎥⎥⎥⎦.
By inspection, A + AT is symmetric, and if we divide throughout by 2 we have
S = 1
2

A + AT
which is deﬁned as the symmetric part of A. For example, given
A =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦,
AT =
⎡
⎣
a11
a21
a31
a12
a22
a32
a13
a23
a33
⎤
⎦
then
S = 1
2

A + AT
=
⎡
⎣
a11
(a12 + a21)/2
(a13 + a31)/2
(a12 + a21)/2
a22
a23 + a32
(a13 + a31)/2
(a23 + a32)/2
a33
⎤
⎦

48
4
Matrices
=
⎡
⎣
a11
s3/2
s2/2
s3/2
a22
s1/2
s2/2
s1/2
a33
⎤
⎦
where
s1 = a23 + a32
s2 = a13 + a31
s3 = a12 + a21.
Using a real example:
A =
⎡
⎣
0
1
4
3
1
4
4
2
6
⎤
⎦,
AT =
⎡
⎣
0
3
4
1
1
2
4
4
6
⎤
⎦
S =
⎡
⎣
0
2
4
2
1
3
4
3
6
⎤
⎦
which equals its own transpose.
4.15 Antisymmetric Matrix
An antisymmetric matrix is a matrix whose transpose is its own negative:
AT = −A
and is also known as a skew symmetric matrix.
As the elements of A and AT are related by
arow,col = −acol,row.
When k = row = col:
ak,k = −ak,k
which implies that the diagonal elements must be zero. For example, this is an anti-
symmetric matrix
⎡
⎣
0
6
2
−6
0
−4
−2
4
0
⎤
⎦.
In general, we have
A =
⎡
⎢⎢⎢⎣
a11
a12
...
a1n
a21
a22
...
a2n
...
...
...
...
an1
an2
...
ann
⎤
⎥⎥⎥⎦,
AT =
⎡
⎢⎢⎢⎣
a11
a21
...
an1
a12
a22
...
an2
...
...
...
...
a1n
a2n
...
ann
⎤
⎥⎥⎥⎦

4.15
Antisymmetric Matrix
49
and their difference is
A −AT =
⎡
⎢⎢⎢⎣
0
a12 −a21
...
a1n −an1
−(a12 −a21)
0
...
a2n −an2
...
...
...
...
−(a1n −an1)
−(a2n −an2)
...
0
⎤
⎥⎥⎥⎦.
It is clear that A −AT is antisymmetric, and if we divide throughout by 2 we have
Q = 1
2

A −AT
.
For example:
A =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦,
AT =
⎡
⎣
a11
a21
a31
a12
a22
a32
a13
a23
a33
⎤
⎦
Q =
⎡
⎣
0
(a12 −a21)/2
(a13 −a31)/2
(a21 −a12)/2
0
(a23 −a32)/2
(a31 −a13)/2
(a32 −a23)/2
0
⎤
⎦
and if we maintain some symmetry with the subscripts, we have
Q =
⎡
⎣
0
(a12 −a21)/2
−(a31 −a13)/2
−(a12 −a21)/2
0
(a23 −a32)/2
(a31 −a13)/2
−(a23 −a32)/2
0
⎤
⎦
=
⎡
⎣
0
q3/2
−q2/2
−q3/2
0
q1/2
q2/2
−q1/2
0
⎤
⎦
where
q1 = a23 −a32
q2 = a31 −a13
q3 = a12 −a21.
Using a real example:
A =
⎡
⎣
0
1
4
3
1
4
4
2
6
⎤
⎦,
AT =
⎡
⎣
0
3
4
1
1
2
4
4
6
⎤
⎦
Q =
⎡
⎣
0
−1
0
1
0
1
0
−1
0
⎤
⎦.
Furthermore, we have already computed
S =
⎡
⎣
0
2
4
2
1
3
4
3
6
⎤
⎦

50
4
Matrices
and
S + Q =
⎡
⎣
0
1
4
3
1
4
4
2
6
⎤
⎦= A.
4.16 Inverting a Pair of Matrices
In later chapters we form the products of two or more matrices, and in some cases
require to ﬁnd their inverse. In anticipation of this requirement, let’s compute the
inverse of a pair of matrices.
Given two transforms T and R, the product TR and its inverse (TR)−1 must
equal the identity matrix I:
(TR)(TR)−1 = I
and multiplying throughout by T−1 we have
T−1TR(TR)−1 = T−1
R(TR)−1 = T−1.
Multiplying throughout by R−1 we have
R−1R(TR)−1 = R−1T−1
(TR)−1 = R−1T−1.
Therefore, if T and R are invertible, then
(TR)−1 = R−1T−1.
Generalising this result to a triple product such as STR we can reason that
(STR)−1 = R−1T−1S−1.
4.17 Eigenvectors and Eigenvalues
Matrices represent linear transforms that scale, translate, shear, reﬂect or rotate
points, whilst leaving the origin untouched. For example, the following 2D trans-
form
4
1
1
4
x
y

=
x′
y′

transforms the points on four unit squares as shown in Fig. 4.1 where we see a
pronounced stretching in the ﬁrst and third quadrants, and reduced stretching in the
second and fourth quadrants.
It should be clear from Fig. 4.1 that any point (k,k) is transformed to another
point (5k,5k), and that its mirror point (−k,−k) is transformed to (−5k,−5k).

4.17
Eigenvectors and Eigenvalues
51
Fig. 4.1 Transforming points
on four unit squares
Fig. 4.2 How a transform
reacts to different points
Similarly, any point (−k,k) is transformed to another point (−3k,3k), and its mirror
point (k,−k) is transformed to (3k,−3k). Thus the transform shows a particular
bias towards points lying on vectors [k
k]T and [−k
k]T, where k ̸= 0.
These vectors are called eigenvectors and the scaling factor is its eigenvalue.
Figure 4.2 shows a scenario where a transform t moves point R to S, whilst the
same transform moves P – which lies on one of t’s eigenvectors, to Q – which also
lies on the same eigenvector.
We can deﬁne an eigenvector and its eigenvalue as follows. Given a square ma-
trix A, a non-zero vector v is an eigenvector, and λ is the corresponding eigenvalue
if
Av = λv
where λ is a scalar.
The German word eigen means characteristic, own, latent or special, and eigen-
vector means a special vector associated with a transform. The equation that deter-
mines the existence of any eigenvectors is called the characteristic equation of a
square matrix, and is given by
det(A −λI) = 0.
(4.18)

52
4
Matrices
Let’s derive the characteristic equation (4.18).
Consider the 2D transform t that maps the point (x,y) to another point (ax +
by,cx + dy):
t (x,y) →(ax + by,cx + dy).
This is expressed in matrix form as
t : v →Av
or
x′
y′

=
a
b
c
d
x
y

where
A =
a
b
c
d

,
v =
x
y

.
Therefore, if v is an eigenvector of t, and λ its associated eigenvalue, then
Av = λv
a
b
c
d
x
y

= λ
x
y

or in equation terms:
ax + by = λx
cx + dy = λy.
Rearranging, we have
(a −λ)x + by = 0
cx + (d −λ)y = 0
or back in matrix form:
a −λ
b
c
d −λ
x
y

=
0
0

.
For a non-zero [x
y]T to exist, we must have
det
a −λ
b
c
d −λ

= 0
which is called the characteristic equation. Let’s use this on the transform
4
1
1
4
x
y

=
x′
y′

.

4.17
Eigenvectors and Eigenvalues
53
Then

4 −λ
1
1
4 −λ
 = 0
(4 −λ)2 −1 = 0
λ2 −8λ + 16 −1 = 0
λ2 −8λ + 15 = 0
(λ −5)(λ −3) = 0.
Thus λ = 5 and λ = 3, are the two eigenvalues we observed in Fig. 4.1. Next, we
substitute the two values of λ in
4 −λ
1
1
4 −λ
x
y

=
0
0

to extract the eigenvectors. Let’s start with λ = 5:
−1
1
1
−1
x
y

=
0
0

which represents the equation y = x or the vector [k
k]T. Next, we substitute
λ = 3:
1
1
1
1
x
y

=
0
0

which represents the equation y = −x or the vector [−k
k]T.
Thus we have discovered that the transform possesses two eigenvectors [k
k]T
and [−k
k]T and their respective eigenvalues λ = 5 and λ = 3, as predicted.
The characteristic equation may have real or complex solutions, and if they are
complex, there are no real eigenvectors. For example, we have already come across
the 2D transform for rotating points about the origin:
A =
cosβ
−sinβ
sinβ
cosβ

and we would not expect this to have any real eigenvectors, as this would imply that
it shows a rotational preference to certain points. Let’s explore this transform to see
how the characteristic equation behaves.
The characteristic equation is

cosβ −λ
−sinβ
sinβ
cosβ −λ
 = 0
where β is the angle of rotation. Therefore,
(cosβ −λ)2 + sin2 β = 0
λ2 −2λcosβ + cos2 β + sin2 β = 0
λ2 −2λcosβ + 1 = 0.

54
4
Matrices
This quadratic in λ is solved using
λ = −b ±
√
b2 −4ac
2a
where a = 1, b = −2cosβ, c = 1:
λ = 2cosβ ±

4cos2 β −4
2
= cosβ ±

cos2 β −1
= cosβ ±

−sin2 β
λ1 = cosβ + i sinβ
λ2 = cosβ −i sinβ
which are complex numbers.
The corresponding complex eigenvectors are
v1 =
1
i

v2 =
 1
−i

.
Now let’s investigate the eigenvectors associated with a 3D transform. We start
with the arbitrary transform
A =
⎡
⎣
3
0
1
−1
3
3
1
0
3
⎤
⎦
and its characteristic equation is

3 −λ
0
1
−1
3 −λ
3
1
0
3 −λ

= 0.
Expanding the determinant using the top row we have
(3 −λ)

3 −λ
3
0
3 −λ
 −0 +

−1
3 −λ
1
0
 = 0
(3 −λ)(3 −λ)2 −(3 −λ) = 0
(3 −λ)

(3 −λ)2 −1

= 0
(3 −λ)

λ2 −6λ + 8

= 0
(3 −λ)(λ −4)(λ −2) = 0
which has solutions λ = 2, 3, 4. Let’s substitute these values of λ in the original
equations to reveal the eigenvectors:
⎧
⎨
⎩
(3 −λ)x
+
z = 0
−x + (3 −λ)y +
3z = 0
x
+ (3 −λ)z = 0.

4.18
Vector Products
55
With λ = 2 we have z = −x from the 1st equation. Substituting this in the 2nd
equation we have y = 4x, which permits us to state that the associated eigenvector
is of the form [k
4k
−k]T.
With λ = 3 we have z = 0 from the 1st equation, and x = 0 from the 3rd equation,
which permits us to state that the associated eigenvector is of the form [0
k
0]T.
With λ = 4 we have z = x from the 1st equation. Substituting this in the 2nd
equation we have y = 2x, which permits us to state that the associated eigenvector
is of the form [k
2k
k]T.
Therefore, the eigenvectors and eigenvalues are
[k
4k
−k]T
λ = 2
[0
k
0]T
λ = 3
[k
2k
k]T
λ = 4
where k ̸= 0.
The major problem with the above technique is that it requires careful analysis to
untangle the eigenvector, and ideally, we require a deterministic algorithm to reveal
the result. We will discover that such a technique is available in Chap. 9.
4.18 Vector Products
Vectors are regarded as single column or single row matrices, which permits us to
express their products neatly. For example, given two vectors
v =
⎡
⎣
a
b
c
⎤
⎦,
w =
⎡
⎣
x
y
z
⎤
⎦
then
v · w = vTw
=
a
b
c
⎡
⎣
x
y
z
⎤
⎦= ax + by + cz.
Similarly, the vector cross product is written
v × w =
⎡
⎣
a
b
c
⎤
⎦×
⎡
⎣
x
y
z
⎤
⎦=
⎡
⎣
i
j
k
a
b
c
x
y
z
⎤
⎦
= (bz −cy)i −(az −xc)j + (ay −bx)k
=
⎡
⎣
bz −cy
−az + xc
ay −bx
⎤
⎦.

56
4
Matrices
4.19 Summary
Matrices play an important role in representing rotations, especially orthogonal ma-
trices, which is why they have been reviewed in this chapter. The inverse matrix is
also an important concept to grasp as this provides the mechanism for reversing a
rotation or change of frame. We will also come across eigenvectors in later chapters,
which is why they were explained in some detail.
4.19.1 Summary of Matrix Operations
Matrix (2 × 2)
A =
a
b
c
d

.
Matrix (3 × 3)
B =
⎡
⎣
a
b
c
d
e
f
g
h
i
⎤
⎦.
Transpose
AT =
a
c
b
d

,
BT =
⎡
⎣
a
d
g
b
e
h
c
f
i
⎤
⎦.
Identity
I =
1
0
0
1

,
I =
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦.
Adding and subtracting
M ± N = [mrow,col ± nrow,col].
Multiplying by a scalar
±λM = [±λmrow,col].
Product transpose
[MN]T = NTMT.
Sum/difference transpose
[M ± N]T = MT ± NT.
Determinant
detA = |A| = ad −bc
detB = |B| = aei + bfg + cdh −ceg −af h −bdi.

4.19
Summary
57
Inverse
M−1 = (cofactor matrix of M)T
detM
[MN]−1 = N−1M−1.
Orthogonal
M is orthogonal if MT = M−1.
Trace
Tr(A) = a + d
Tr(B) = a + e + i
Tr(MN) = Tr(NM).
Symmetric
M is symmetric if M = MT.
Symmetric part S
S = 1
2

M + MT
.
Antisymmetric
M is antisymmetric if M = −MT.
Antisymmetric part Q
Q = 1
2

M −MT
.
Eigenvector
v is the eigenvector of M if Mv = λv.
Eigenvalue
λ is the eigenvalue of M if Mv = λv.


Chapter 5
Quaternions
5.1 Introduction
As mentioned earlier, quaternions were invented by Sir William Rowan Hamilton in
1843. Sir William was looking to generalise complex numbers in higher dimensions,
and it took 14 years of toil before he stumbled upon the idea of using a 4D notation
– hence the name ‘quaternion’.
5.2 Deﬁnition
The deﬁnition and associated rules for a quaternion are:
q = a + bi + cj + dk
where a, b, c and d are scalars, and i, j and k are imaginary and obey the following
rules:
i2 = −1,
j2 = −1,
k2 = −1,
ijk = −1
ij = k,
jk = i,
ki = j
ji = −k,
kj = −i,
ik = −j.
Although quaternions had some enthusiastic supporters, there were many mathe-
maticians and scientists who were suspicious of the need to involve so many imag-
inary terms. Towards the end of the nineteenth century Josiah Gibbs resolved the
problem by declaring that the three imaginary quantities could be viewed as a 3D
vector and changed the original bi + cj + dk into bi + cj + dk, where i, j and k
are unit Cartesian vectors. Today, it is convenient in computer graphics to write a
quaternion in two ways:
q = s,v
(5.1)
q = s + v
(5.2)
where s is a scalar, and v is a 3D vector.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_5, © Springer-Verlag London Limited 2011
59

60
5
Quaternions
The difference is rather subtle: in (5.1) the scalar and vector are separated by a
comma, whereas in (5.2) a ‘+’ sign is used as in complex numbers. Although the
idea of adding a scalar to a vector seems strange, this notation is used in this book
as it helps us understand the ideas behind multivectors, which are covered in the
next chapter. Since Hamilton’s invention, mathematicians have successfully applied
quaternions to rotate points about an arbitrary axis, which is why we are interested
in them.
A quaternion then, is the combination of a scalar and a vector:
q = s + v
where s is a scalar and v is a 3D vector. If we express the vector v in terms of its
components, we have
q = s + xi + yj + zk
where s,x,y,z are all scalars.
Later on we will discover that in the context of a rotation transform, v is used to
represent the axis of rotation, and the scalar s encodes the angle of rotation.
5.2.1 Axioms
Quaternions share the same axioms as complex numbers apart from multiplication,
where they do not commute.
Addition:
Commutative
q1 + q2 = q2 + q1
Associative
(q1 + q2) + q3 = q1 + (q2 + q3).
Multiplication:
Associative
(q1q2)q3 = q1(q2q3)
Non-commutative
q1q2 ̸= q2q1.
5.3 Adding and Subtracting Quaternions
Two quaternions q1 and q2
q1 = s1 + x1i + y1j + z1k
q2 = s2 + x2i + y2j + z2k
are equal if, and only if, their corresponding terms are equal. Furthermore, like vec-
tors, they can be added and subtracted as follows:
q1 ± q2 = (s1 ± s2) + (x1 ± x2)i + (y1 ± y2)j + (z1 ± z2)k.

5.4
Multiplying Quaternions
61
For example:
q1 = 0.6 + 2i + 4j −3k
q2 = 0.2 + 3i + 5j + 7k
q1 + q2 = 0.8 + 5i + 9j + 4k
q1 −q2 = 0.4 −i −j −10k.
5.4 Multiplying Quaternions
When multiplying quaternions we must employ the following rules:
i2 = −1,
j2 = −1,
k2 = −1,
ijk = −1
ij = k,
jk = i,
ki = j
ji = −k,
kj = −i,
ik = −j.
Note that quaternion addition is commutative, however, the rules make quaternion
products non-commutative. For example:
q1 = s1 + v1 = s1 + x1i + y1j + z1k
q2 = s2 + v2 = s2 + x2i + y2j + z2k
q1q2 = (s1s2 −x1x2 −y1y2 −z1z2) + (s1x2 + s2x1 + y1z2 −y2z1)i
+ (s1y2 + s2y1 + z1x2 −z2x1)j + (s1z2 + s2z1 + x1y2 −x2y1)k
= s1s2 −(x1x2 + y1y2 + z1z2) + s1(x2i + y2j + z2k) + s2(x1i + y1j + z1k)
+ (y1z2 −y2z1)i + (z1x2 −z2x1)j + (x1y2 −x2y1)k
which can be rewritten using the dot and cross product notation as
q1q2 = s1s2 −v1 · v2 + s1v2 + s2v1 + v1 × v2
where
s1s2 −v1 · v2
is a scalar, and
s1v2 + s2v1 + v1 × v2
is a vector.
For example:
q1 = 1 + 2i + 3j + 4k
q2 = 2 −i + 5j −2k
q1q2 = (1 + 2i + 3j + 4k)(2 −i + 5j −2k)
q1q2 =

1 × 2 −2 × (−1) + 3 × 5 + 4 × (−2)

+ 1(−i + 5j −2k) + 2(2i + 3j + 4k)
+

3 × (−2) −4 × 5

i −

2 × (−2) −4 × (−1)

j +

2 × 5 −3 × (−1)

k
= −3 + 3i + 11j + 6k −26i + 13k
= −3 −23i + 11j + 19k

62
5
Quaternions
which is another quaternion. You may wish to evaluate q2q1 and show that q1q2 ̸=
q2q1.
5.5 Pure Quaternion
A pure quaternion has a zero scalar term:
q = 0 + v
which is a vector. Therefore,
q1 = 0 + v1
q2 = 0 + v2
q1q2 = −v1 · v2 + v1 × v2
which leads to a rather strange result for the square of a pure quaternion:
qq = −v · v + v × v
= −v · v
= −|v|2
a negative real number! In Hamilton’s day, physicists found this result difﬁcult to
accept, and on top of all the imaginary terms refused to adopt quaternions and em-
braced the vector analysis proposed by Gibbs et al.
5.6 Magnitude of a Quaternion
The magnitude, norm or modulus of a quaternion is written |q| and equals
q = s + xi + yj + zk
|q| =

s2 + x2 + y2 + z2.
For example:
q = 1 + 2i + 4j −3k
|q| =

12 + 22 + 42 + (−3)2 =
√
30.
5.7 Unit Quaternion
A unit quaternion has a magnitude equal to 1:
|q| =

s2 + x2 + y2 + z2 = 1.

5.8
The Quaternion Conjugate
63
Any quaternion q can be normalised to a unit quaternion ˆq by dividing by its mag-
nitude:
ˆq = q
|q|.
5.8 The Quaternion Conjugate
We have already discovered that the complex conjugate of a complex number z =
a + bi is given by
z∗= a −bi
and is very useful in computing the inverse of z. The quaternion conjugate plays a
similar role in computing the inverse of a quaternion. Therefore, given
q = s + v
= s + xi + yj + zk
its conjugate is deﬁned as
q∗= s −v
= s −xi −yj −zk.
If we compute the product qq∗we obtain
qq∗= (s + v)(s −v)
= s2 + v · v + sv −sv + v × (−v) = s2 + v · v
= s2 + x2 + y2 + z2
which is a scalar and implies that
qq∗= |q|2
or
|q| =

qq∗.
Similarly, we can show that qq∗= q∗q.
Now let’s show that (q1q2)∗= q∗
2q∗
1. We start with quaternions q1 and q2:
q1 = s1 + v1
q2 = s2 + v2
q1q2 = (s1 + v1)(s2 + v2)
= s1s2 −v1 · v2 + s1v2 + s2v1 + v1 × v2
(q1q2)∗= s1s2 −v1 · v2 −s1v2 −s2v1 −v1 × v2.
(5.3)

64
5
Quaternions
Next, we compute q∗
2q∗
1
q∗
1 = s1 −v1
q∗
2 = s2 −v2
q∗
2q∗
1 = (s2 −v2)(s1 −v1)
= s1s2 −v1 · v2 + s2(−v1) + s1(−v2) + (−v2) × (−v1)
= s1s2 −v1 · v2 −s1v2 −s2v1 −v1 × v2
(5.4)
and as (5.3) equals (5.4), (q1q2)∗= q∗
2q∗
1.
5.9 The Inverse Quaternion
Given a quaternion q we can compute its inverse q−1 as follows.
By deﬁnition, we require that
qq−1 = q−1q = 1.
(5.5)
First, we multiply (5.5) by q∗
q∗qq−1 = q∗q−1q = q∗
(5.6)
and from (5.6) we can write
q−1 = q∗
q∗q = q∗
|q|2 .
If q is a unit quaternion, then q−1 = q∗, which is useful when reversing a rotational
sequence. Therefore, as
(q1q2)∗= q∗
2q∗
1
then
(q1q2)−1 = q−1
2 q−1
1 .
For completeness let’s evaluate the inverse of q where
q = 1 + 1
√
3
i + 1
√
3
j + 1
√
3
k
q∗= 1 −1
√
3
i −1
√
3
j −1
√
3
k
|q|2 = 1 + 1
3 + 1
3 + 1
3 = 2
q−1 = 1
2

1 −1
√
3
i −1
√
3
j −1
√
3
k

= 1
2 −
1
√
12
i −
1
√
12
j −
1
√
12
k.

5.10
Summary
65
5.10 Summary
Quaternions offer a powerful algebra for rotating points about an arbitrary axis and
it is important that they are fully understood before proceeding. We have yet to see
how quaternions actually perform this rotational task, which is covered in Chap. 11.
5.10.1 Summary of Quaternion Operations
q = s + v
= s + xi + yj + zk
where s, x, y, z are scalars, and
i2 = −1,
j2 = −1,
k2 = −1,
ijk = −1
ij = k,
jk = i,
ki = j
ji = −k,
kj = −i,
ik = −j.
Addition and subtraction
q1 ± q2 = (s1 ± s2) + (x1 ± x2)i + (y1 ± y2)j + (z1 ± z2)k.
Product
q1q2 = (s1s2 −x1x2 −y1y2 −z1z2) + (s1x2 + s2x1 + y1z2 −y2z1)i
+ (s1y2 + s2y1 + z1x2 −z2x1)j + (s1z2 + s2z1 + x1y2 −x2y1)k
q1q2 = (s1s2 −v1 · v2) + s1v2 + s2v1 + v1 × v2.
Pure
q = 0 + v.
Magnitude
|q| =

s2 + x2 + y2 + z2.
Unit
|q| =

s2 + x2 + y2 + z2 = 1.
Quaternion conjugate
q∗= s −v = s −xi −yj −zk
(q1q2)∗= q∗
2q∗
1.
Inverse
q−1 = q∗
q∗q = q∗
|q|2
(q1q2)−1 = q−1
2 q−1
1 .


Chapter 6
Multivectors
6.1 Introduction
This is a brief introduction to multivectors of geometric algebra and we only ex-
plore those elements associated with rotations. Those readers who wish to pursue
the subject further may wish to consult the author’s books: Geometric Algebra for
Computer Graphics [5] or Geometric Algebra: An Algebraic System for Computer
Games and Animation [6].
We regard vectors as directed lines or oriented lines, but if they exist, why
shouldn’t oriented planes and oriented volumes exist? Well they do, which is what
geometric algebra is about. Unfortunately when vectors were invented, the work of
the German mathematician, Hermann Grassmann (1809–1877), was not understood
and consequently ignored. In retrospect this was unfortunate, as Grassmann had
invented an exceedingly powerful algebra for geometry, and it has taken a further
century for it to emerge through the work of William Kingdon Clifford (1845–1879)
and David Hestenes. So let’s explore an exciting algebra that offers new ways of
handling rotations.
6.2 Symmetric and Antisymmetric Functions
Symmetric (even) and antisymmetric (odd) functions play an important role in un-
derstanding multivectors. For example, f (β) is a symmetric function if
f (−β) = f (β)
an example being cosβ where cos(−β) = cosβ. Whereas, f (β) is an antisymmetric
function if
f (−β) = −f (β)
an example being sinβ where sin(−β) = −sinβ.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_6, © Springer-Verlag London Limited 2011
67

68
6
Multivectors
Fig. 6.1 Two line segments a
and b separated by +β
6.3 Trigonometric Foundations
Figure 6.1 shows two line segments a and b with coordinates (a1,a2) and (b1,b2)
respectively. The lines are separated by an angle β, and it is a trivial exercise to
show that
ab sinβ = a1b2 −a2b1
which equals the area of the parallelogram formed by a and b. What is interesting is
that reversing the relative orientation of the lines such that b is rotated −β relative
to a makes
ab sinβ = −(a1b2 −a2b1)
which means that this is antisymmetric due to the sine function.
We know from the deﬁnition of the scalar product of vectors that
ab cosβ = a1b1 + a2b2
which remains unaltered if the relative orientation of the lines is reversed, which
means that this is symmetric due to the cosine function.
6.4 Vectorial Foundations
If we form the algebraic product of two 2D vectors a and b we have:
a = a1i + a2j
b = b1i + b2j
ab = a1b1i2 + a2b2j2 + a1b2ij + a2b1ji.
(6.1)
It is clear from (6.1) that a1b1i2 + a2b2j2 has something to do with ab cosβ, and
a1b2ij + a2b1ji has something to do with ab sinβ. The product ab creates the terms
i2, j2, ij and ji, which are resolved as follows.

6.5
Inner and Outer Products
69
6.5 Inner and Outer Products
Let’s assume that the products ij and ji in (6.1) anticommute: ji = −ij. Therefore,
ab = a1b1i2 + a2b2j2 + (a1b2 −a2b1)ij
(6.2)
and if we reverse the product to ba we obtain
ba = a1b1i2 + a2b2j2 −(a1b2 −a2b1)ij.
(6.3)
From (6.2) and (6.3) we see that the product of two vectors contains a symmetric
component
a1b1i2 + a2b2j2
and an antisymmetric component
(a1b2 −a2b1)ij.
Geometric algebra deﬁnes the product ab as the sum of two other products called
the inner and outer products. The inner product has the form
a · b = |a||b|cosβ
(6.4)
where
a · b = (a1i + a2j) · (b1i + b2j)
= a1b1i · i + a1b2i · j + a2b1j · i + a2b2j · j
= a1b1 + a2b2
which is the familiar scalar product. The outer product uses the wedge ‘∧’ symbol,
which is why it is also called the wedge product and has the form
a ∧b = |a||b|sinβi ∧j
(6.5)
where
a ∧b = (a1i + a2j) ∧(b1i + b2j)
= a1b1i ∧i + a1b2i ∧j + a2b1j ∧i + a2b2j ∧j
= (a1b2 −a2b1)i ∧j
which enables us to write
ab = a · b + a ∧b
(6.6)
ab = |a||b|cosβ + |a||b|sinβi ∧j.
(6.7)
6.6 The Geometric Product in 2D
Clifford named the sum of the two products the geometric product, which means
that (6.6) reads: The geometric product ab is the sum of the inner product “a dot b”
and the outer product “a wedge b”.

70
6
Multivectors
Given the deﬁnition of the geometric product, let’s evaluate i2:
ii = i · i + i ∧i.
Using the deﬁnition for the inner product (6.4) we have
i · i = 1 × 1 × cos0° = 1
whereas using the deﬁnition of the outer product (6.5) we have
i ∧i = 1 × 1 × sin0°i ∧i = 0.
Thus i2 = 1 and j2 = 1, and aa = |a|2:
aa = a · a + a ∧a
= |a||a|cos0° + |a||a|sin0°i ∧j
aa = |a|2.
This result is much more satisfying than the square of a pure quaternion q:
qq = −|q|2.
Now let’s evaluate ij:
ij = i · j + i ∧j.
Using the deﬁnition for the inner product (6.4) we have
i · j = 1 × 1 × cos90° = 0
whereas using the deﬁnition of the outer product (6.5) we have
i ∧j = 1 × 1 × sin90°i ∧j = i ∧j.
Thus ij = i∧j. But what is i∧j? Well, it is a new object called a bivector and deﬁnes
the orientation of the plane containing i and j. As the order of the vectors is from i
to j, the angle is +90° and sin(+90)° = 1. Whereas, if the order is from j to i the
angle is −90° and sin(−90°) = −1. Consequently,
ji = j · i + j ∧i
= 0 + 1 × 1 × sin(−90°)i ∧j
= −i ∧j.
A useful way of visualising the bivector i ∧j is to imagine moving along the
vector i and then along the vector j, which creates an anticlockwise rotation. Con-
versely, for the bivector j∧i, imagine moving along the vector j followed by vector i,
which creates a clockwise rotation. Another useful picture is to sweep vector j along
vector i to create an anticlockwise rotation, and vice versa for j ∧i. These ideas are
shown in Fig. 6.2.
The following equation
ab = 9 + 12i ∧j

6.7
The Geometric Product in 3D
71
Fig. 6.2 An anticlockwise
and clockwise bivector
means that the geometric product of two vectors a and b creates a scalar, inner
product of 9, and an outer product of 12 on the i–j plane. For example, given
a = 3i
b = 3i + 4j
ab = (3i) · (3i + 4j) + (3i) ∧(3i + 4j)
= 9 + 9i ∧i + 12i ∧j
= 9 + 12i ∧j.
The 9 represents |a||b|cosβ, whereas the 12 represents an area |a||b|sinβ on the
i–j plane. The angle between the two vectors β is given by
β = cos−1(3/5).
However, reversing the product, we obtain
ba = (3i + 4j) · (3i) + (3i + 4j) ∧(3i)
= 9 + 9i ∧i + 12j ∧i
= 9 −12i ∧j
where the sign of the outer (wedge) product has ﬂipped to reﬂect the new orientation
of the vectors relative to the accepted orientation of the basis bivector.
So the geometric product combines the scalar and wedge products into a single
product, where the scalar product is the symmetric component and the wedge prod-
uct is the antisymmetric component. Now let’s see how these products behave in
3D.
6.7 The Geometric Product in 3D
Before we begin let’s introduce some new notation to simplify future algebraic ex-
pressions. Rather than use i, j and k to represent the unit basis vectors let’s employ
e1, e2 and e3 respectively. This implies that (6.7) can be written
ab = |a||b|cosβ + |a||b|sinβe1 ∧e2.
We also remind ourselves that we are working with a right-handed axial system,
where, using our right-hand, the thumb aligns with e1, the x-axis, the ﬁrst ﬁnger

72
6
Multivectors
Fig. 6.3 The 3D bivectors
aligns with e2, the y-axis, and the middle ﬁnger aligns with e3, the z-axis. We begin
with two 3D vectors:
a = a1e1 + a2e2 + a3e3
b = b1e1 + b2e2 + b3e3
and their inner product is
a · b = (a1e1 + a2e2 + a3e3) · (b1e1 + b2e2 + b3e3)
= a1b1 + a2b2 + a3b3
and their outer product is
a ∧b = (a1e1 + a2e2 + a3e3) ∧(b1e1 + b2e2 + b3e3)
= a1b2e1 ∧e2 + a1b3e1 ∧e3 + a2b1e2 ∧e1
+ a2b3e2 ∧e3 + a3b1e3 ∧e1 + a3b2e3 ∧e2
= (a1b2 −a2b1)e1 ∧e2 + (a2b3 −a3b2)e2 ∧e3 + (a3b1 −a1b3)e3 ∧e1.
(6.8)
This time we have three unit basis bivectors: e1 ∧e2, e2 ∧e3, e3 ∧e1, and three asso-
ciated scalar multipliers: (a1b2 −a2b1), (a2b3 −a3b2), (a3b1 −a1b3) respectively.
These bivectors are the basis for a right-handed oriented axial system.
Continuing with the idea described in the previous section, the three bivectors
represent the three planes containing the respective vectors as shown in Fig. 6.3, and
the scalar multipliers are projections of the area of the vector parallelogram onto the
three bivectors as shown in Fig. 6.4. Note that this is the accepted deﬁnition for a
right-handed space. The orientation of the vectors a and b determine whether the
projected areas are positive or negative.
Equation (6.8) should look familiar as it looks similar to the cross product a × b:
a × b = (a1b2 −a2b1)e3 + (a2b3 −a3b2)e1 + (a3b1 −a1b3)e2.
(6.9)
This similarity is no accident, for when Hamilton invented quaternions he did not
recognise the possibility of bivectors, and invented some rules which eventually

6.8
The Outer Product of Three 3D Vectors
73
Fig. 6.4 The projections on
the three bivectors
became the vector product. In fact, we show later that quaternions are bivectors in
disguise. We can see that a simple relationship exists between (6.8) and (6.9):
e1 ∧e2 and e3
e2 ∧e3 and e1
e3 ∧e1 and e2.
The wedge product bivectors are perpendicular to the vector components of the cross
product. So the wedge product is just another way of representing the cross product.
However, the wedge product introduces a very important bonus – it works in space
of any dimension; whereas, the cross product is only comfortable in 3D. Not only
that, the wedge (outer) product is a product that creates volumes, hypervolumes, and
can also be applied to vectors, bivectors, trivectors, etc.
6.8 The Outer Product of Three 3D Vectors
Having seen that the outer product of two 3D vectors is represented by areal pro-
jections onto the three basis bivectors, let’s compute the outer product of three 3D
vectors:
a = a1e1 + a2e2 + a3e3
b = b1e1 + b2e2 + b3e3
c = c1e1 + c2e2 + c3e3
a ∧b ∧c = (a1e1 + a2e2 + a3e3) ∧(b1e1 + b2e2 + b3e3) ∧(c1e1 + c2e2 + c3e3)
= ((a1b2 −a2b1)e1 ∧e2 + (a2b3 −a3b2)e2 ∧e3 + (a3b1 −a1b3)e3 ∧e1)
∧(c1e1 + c2e2 + c3e3).
At this stage we introduce another axiom: the outer product is associative. This
means that a ∧(b ∧c) = (a ∧b) ∧c. Therefore, knowing that a ∧a = 0:

74
6
Multivectors
a ∧b ∧c = c3(a1b2 −a2b1)e1 ∧e2 ∧e3 + c1(a2b3 −a3b2)e2 ∧e3 ∧e1
+ c2(a3b1 −a1b3)e3 ∧e1 ∧e2
= (c3(a1b2 −a2b1) + c1(a2b3 −a3b2) + c2(a3b1 −a1b3))e1 ∧e2 ∧e3
or using a determinant:
a ∧b ∧c =

a1
b1
c1
a2
b2
c2
a3
b3
c3

e1 ∧e2 ∧e3
which is the well-known expression for the volume of a parallelpiped formed by
three vectors.
The term e1 ∧e2 ∧e3 is a trivector and implies that the volume is oriented. If
the sign of the determinant is positive, the original three vectors possess the same
orientation of the three basis vectors. If the sign of the determinant is negative, the
three vectors oppose the orientation of the basis trivector.
6.9 Axioms
One of the features of geometric algebra is that it behaves very similar to the every-
day algebra of reals:
Axiom 6.1 The associative rule:
a(bc) = (ab)c.
Axiom 6.2 The left and right distributive rules:
a(b + c) = ab + ac
(b + c)a = ba + ca.
The next four axioms describe how vectors interact with a scalar λ:
Axiom 6.3
(λa)b = λ(ab) = λab.
Axiom 6.4
λ(φa) = (λφ)a.
Axiom 6.5
λ(a + b) = λa + λb.
Axiom 6.6
(λ + φ)a = λa + φa.

6.10
Notation
75
Axiom 6.7
a2 = |a|2.
6.10 Notation
Having abandoned i, j, k for e1, e2, e3, it is convenient to convert geometric products
e1e2 ···en to e12···n. For example, e1e2e3 ≡e123. Furthermore, we must get used to
the following substitutions:
eieiej = ej
e21 = −e12
e312 = e123
e112 = e2
e121 = −e2.
6.11 Grades, Pseudoscalars and Multivectors
As geometric algebra embraces such a wide range of objects, it is convenient to
grade them as follows: scalars are grade 0, vectors are grade 1, bivectors are grade 2,
and trivectors are grade 3, and so on for higher dimensions. In such a graded algebra
it is traditional to call the highest grade element a pseudoscalar. Thus in 2D the
pseudoscalar is e12 and in 3D the pseudoscalar is e123.
One very powerful feature of geometric algebra is the idea of a multivector,
which is a linear combination of a scalar, vector, bivector, trivector, or any other
higher dimensional object. For example the following are multivectors:
A = 3 + (2e1 + 3e2 + 4e3) + (5e12 + 6e23 + 7e31) + 8e123
B = 2 + (2e1 + 2e2 + 3e3) + (4e12 + 5e23 + 6e31) + 7e123
and we can form their sum:
A + B = 5 + (4e1 + 5e2 + 7e3) + (9e12 + 11e23 + 13e31) + 15e123
or their difference:
A −B = 1 + (e2 + e3) + (e12 + e23 + e31) + e123.
We can even form their product AB.
We can isolate any grade of a multivector using the following notation:
⟨multivector⟩g
where g identiﬁes a particular grade. For example, say we have the following mul-
tivector:
2 + 3e1 + 2e2 −5e12 + 6e123

76
6
Multivectors
we extract the scalar term using:
⟨2 + 3e1 + 2e2 −5e12 + 6e123⟩0 = 2
the vector term using
⟨2 + 3e1 + 2e2 −5e12 + 6e123⟩1 = 3e1 + 2e2
the bivector term using:
⟨2 + 3e1 + 2e2 −5e12 + 6e123⟩2 = −5e12
and the trivector term using:
⟨2 + 3e1 + 2e2 −5e12 + 6e123⟩3 = 6e123.
It is also worth pointing out that the inner vector product converts two grade 1
elements, i.e. vectors, into a grade 0 element, i.e. a scalar, whereas the outer vector
product converts two grade 1 elements into a grade 2 element, i.e. a bivector. Thus
the inner product is a grade lowering operation, while the outer product is a grade
raising operation. These qualities of the inner and outer products are associated
with higher grade elements in the algebra. This is why the scalar product is renamed
as the inner product, because the scalar product is synonymous with transforming
vectors into scalars. Whereas, the inner product transforms two elements of grade n
into a grade n −1 element.
6.12 Redeﬁning the Inner and Outer Products
As the geometric product is deﬁned in terms of the inner and outer products, it
seems only natural to expect that similar functions exist relating the inner and outer
products in terms of the geometric product. Such functions do exist and emerge
when we combine the following two equations:
ab = a · b + a ∧b
(6.10)
ba = a · b −a ∧b.
(6.11)
Adding and subtracting (6.10) and (6.11) we have
a · b = 1
2(ab + ba)
(6.12)
a ∧b = 1
2(ab −ba).
(6.13)
Equations (6.12) and (6.13) are used frequently to deﬁne the products between dif-
ferent grade elements.

6.13
The Inverse of a Vector
77
6.13 The Inverse of a Vector
In traditional vector analysis we accept that it is impossible to divide by a vector, but
that is not so in geometric algebra. In fact, we don’t actually divide a multivector by
another vector but ﬁnd a way of representing the inverse of a vector. For example,
we know that a unit vector ˆa is deﬁned as
ˆa = a
|a|
and using the geometric product
ˆa2 = a2
|a|2 = 1
therefore,
b = a2b
|a|2
and exploiting the associative nature of the geometric product we have
b = a(ab)
|a|2 .
(6.14)
Equation (6.14) is effectively stating that, given the geometric product ab we can
recover the vector b by pre-multiplying by a−1:
a−1 =
a
|a|2 .
Similarly, we can recover the vector a as follows by post-multiplying by b−1:
a = (ab)b
|b|2 .
For example:
a = e1 + 2e2
b = 3e1 + 2e2
their geometric product is
ab = 7 −4e12.
Therefore, given ab and a, we can recover b as follows:
b =
e1 + 2e2
5

(7 −4e12)
= 1
5(7e1 −4e112 + 14e2 −8e212)
= 1
5(7e1 −4e2 + 14e2 + 8e1)
= 3e1 + 2e2.

78
6
Multivectors
Similarly, given ab and b, a is recovered as follows:
a = (7 −4e12)
3e1 + 2e2
13

= 1
13(21e1 + 14e2 −12e121 −8e122)
= 1
13(21e1 + 14e2 + 12e2 −8e1)
= e1 + 2e2.
Note that the inverse of a unit vector is the original vector:
ˆa−1 =
ˆa
|ˆa|2 = ˆa.
6.14 The Imaginary Properties of the Outer Product
So far we know that the outer product of two vectors is represented by one or more
unit basis vectors, such as
a ∧b = λ1e12 + λ2e23 + λ3e31
where, in this case, the λ terms represent areas projected onto their respective unit
basis bivectors. But what has not emerged is that the outer product is an imaginary
quantity, which is revealed by expanding e2
12:
e2
12 = e1212
but as
e21 = −e12
then
e1(21)2 = −e1(12)2
= −e2
1e2
2
e2
12 = −1.
Consequently, the geometric product effectively creates a complex number! Thus in
a 2D scenario, given:
a = a1e1 + a2e2
b = b1e1 + b2e2
their geometric product is
ab = (a1b1 + a2b2) + (a1b2 −a2b1)e12
and knowing that e12 = i, then we can write ab as
ab = (a1b1 + a2b2) + (a1b2 −a2b1)i.
(6.15)

6.14
The Imaginary Properties of the Outer Product
79
However, this notation is not generally adopted by the geometric algebra commu-
nity. The reason being that i is normally only associated with a scalar, with which it
commutes. Whereas in 2D, e12 is associated with scalars and vectors, and although
scalars present no problem, under some conditions, it anticommutes with vectors.
Consequently, an upper-case I is used so that there is no confusion between the two
elements. Thus (6.15) is written as
ab = (a1b1 + a2b2) + (a1b2 −a2b1)I
where
I 2 = −1.
It goes without saying that the 3D unit basis bivectors are also imaginary quantities,
so too, is e123.
Multiplying a complex number by i rotates it 90° on the complex plane. There-
fore, it should be no surprise that multiplying a 2D vector by e12 rotates it by 90°.
However, because vectors are sensitive to their product partners, we must remember
that pre-multiplying a vector by e12 rotates a vector clockwise and post-multiplying
rotates a vector anticlockwise. For instance, post-multiplying e1 by e12 creates e2,
which is an anticlockwise rotation, whereas, pre-multiplying e1 by e12 creates −e2,
which is a clockwise rotation.
Whilst on the subject of rotations, let’s consider what happens in 3D. We begin
with a 3D vector
a = a1e1 + a2e2 + a3e3
and the unit basis bivector e12 as shown in Fig. 6.5. Next we construct their geomet-
ric product
e12a = a1e12e1 + a2e12e2 + a3e12e3
= a1e121 + a2e122 + a3e123
= −a1e2 + a2e1 + a3e123
= a2e1 −a1e2 + a3e123
which contains two parts: a vector (a2e1 −a1e2) and a volume a3e123.
Figure 6.5 shows how the projection of vector a is rotated anticlockwise on the
bivector e12. A volume is also created perpendicular to the bivector. This enables us
to predict that if the vector is coplanar with the bivector, the entire vector is rotated
90° and the volume component is zero.
Post-multiplying a by e12 creates
ae12 = −a2e1 + a1e2 + a3e123
which shows that while the volumetric element has remained the same, the projected
vector is rotated anticlockwise. You may wish to show that the same happens with
the other two bivectors.

80
6
Multivectors
Fig. 6.5 The effect of
multiplying a vector by a
bivector
6.15 Duality
The ability to exchange pairs of geometric elements such as lines and planes in-
volves a dual operation, which in geometric algebra is relatively easy to deﬁne. For
example, given a multivector A its dual A∗is deﬁned as
A∗= IA
where I is the local pseudoscalar. For 2D this is e12 and for 3D it is e123. Therefore,
given:
a = a1e1 + a2e2
its dual is
a∗= e12(a1e1 + a2e2)
= a1e121 + a2e122
= a2e1 −a1e2
which is another vector rotated 90° anticlockwise.
It is easy to show that (a∗)∗= −a, and two further dual operations return the
vector back to a.
In 3D the dual of a vector e1 is
e123e1 = e1231 = e23
which is the perpendicular bivector. Similarly, the dual of e2 is e31 and the dual of
e3 is e12.
For a general vector a1e1 + a2e2 + a3e3 its dual is
e123(a1e1 + a2e2 + a3e3) = a1e1231 + a2e1232 + a3e1233
= a3e12 + a1e23 + a2e31.
The duals of the 3D basis bivectors are:
e123e12 = e12312 = −e3
e123e23 = e12323 = −e1
e123e31 = e12331 = −e2.

6.16
The Relationship Between the Vector Product and the Outer Product
81
Table 6.1 Hamilton’s
quaternion product rules
i
j
k
i
−1
k
−j
j
−k
−1
i
k
j
−i
−1
6.16 The Relationship Between the Vector Product and the
Outer Product
We have already discovered that there is a very close relationship between the vector
product and the outer product, and we will see what happens when we form the cross
and wedge product of two 3D vectors:
a = a1e1 + a2e2 + a3e3
b = b1e1 + b2e2 + b3e3
a × b = (a2b3 −a3b2)e1 + (a3b1 −a1b3)e2 + (a1b2 −a2b1)e3
(6.16)
a ∧b = (a2b3 −a3b2)e2 ∧e3 + (a3b1 −a1b3)e3 ∧e1 + (a1b2 −a2b1)e1 ∧e2
= (a2b3 −a3b2)e23 + (a3b1 −a1b3)e31 + (a1b2 −a2b1)e12.
(6.17)
Multiplying (6.17) by I123 we obtain
I123(a ∧b) = (a2b3 −a3b2)e123e23 + (a3b1 −a1b3)e123e31
+ (a1b2 −a2b1)e123e12
= −((a2b3 −a3b2)e1 + (a3b1 −a1b3)e2 + (a1b2 −a2b1)e3)
which is identical to the cross product (6.9) apart from its sign. Therefore, we can
state:
a × b = −I123(a ∧b).
6.17 The Relationship Between Quaternions and Bivectors
Hamilton’s rules for the imaginaries i, j and k are shown in Table 6.1, whilst Ta-
ble 6.2 shows the rules for 3D bivector products. Although there is some agreement
between the table entries, there is a sign reversal in some of them. However, if we
switch to a left-handed axial system the bivectors become e32, e13, e21 and their
products are as shown in Table 6.3. If we now create a one-to-one correspondence
(isomorphism) between the two systems:
i ↔e32,
j ↔e13,
k ↔e21
there is a true correspondence between quaternions and a left-handed set of bivec-
tors.

82
6
Multivectors
Table 6.2 3D bivector
product rules
e23
e31
e12
e23
−1
−e12
e31
e31
e12
−1
−e23
e12
−e31
e23
−1
Table 6.3 Left-handed 3D
bivector product rules
e32
e13
e21
e32
−1
e21
−e13
e13
−e21
−1
e32
e21
e13
−e32
−1
6.18 Reverse of a Multivector
You will have noticed how sensitive geometric algebra is to the sequence of vectors,
and it should not be too much of a surprise to learn that a special function exists to
reverse sequences of elements. For example, given
A = ab
the reverse of A is denoted using the dagger symbol A†
A† = ba
or the tilde symbol ˜A
˜A = ba.
The dagger symbol is used in this book.
Obviously, scalars are unaffected by reversion, neither are vectors. However,
bivectors and trivectors ﬂip their signs:
(e1e2)† = e2e1 = −e1e2
and
(e1e2e3)† = e3e2e1 = −e1e2e3.
When reversing a multivector containing terms up to a trivector, it’s only the bivector
and trivector terms that are reversed. For example, given a multivector A
A = λ + v + B + T
where
λ is a scalar
v is a vector
B is a bivector, and
T is a trivector

6.19
Summary
83
then
A† = λ + v −B −T.
Let’s illustrate this reversion process with an example.
Given three vectors
a = 2e1 + 3e2
b = 4e1 −2e2
c = e1 + e2
the products ab and ba are
ab = (2e1 + 3e2)(4e1 −2e2) = 2 −16e12
ba = (4e1 −2e2)(2e1 + 3e2) = 2 + 16e12.
Thus
(ab)† = ba.
Furthermore, the products abc and cba are
abc = (2e1 + 3e2)(4e1 −2e2)(e1 + e2) = −14e1 + 18e2
cba = (e1 + e2)(4e1 −2e2)(2e1 + 3e2) = −14e1 + 18e2.
And as there are only vectors terms there are no sign changes.
Reversion plays an important role in rotors and we will meet them again in the
next chapter.
6.19 Summary
This chapter has covered the basic ideas behind geometric algebra which offers
an algebraic framework for oriented lines (vectors), oriented planes (bivectors) and
oriented volumes (trivectors), not to mention higher dimensional objects. We have
yet to discover how they offer an alternative way of rotating points in the plane and
in 3D space.
6.19.1 Summary of Multivector Operations
Inner product: 2D vectors
a = a1e1 + a2e2
b = b1e1 + b2e2
a · b = |a||b|cosβ = a1b1 + a2b2.

84
6
Multivectors
Inner product: 3D vectors
a = a1e1 + a2e2 + a3e3
b = b1e1 + b2e2 + b3e3
a · b = |a||b|cosβ = a1b1 + a2b2 + a3b3.
Outer product: 2D vectors
a = a1e1 + a2e2
b = b1e1 + b2e2
a ∧b =

a1
a2
b1
b2
e1 ∧e2.
Outer product: 3D vectors
a = a1e1 + a2e2 + a3e3
b = b1e1 + b2e2 + b3e3
c = c1e1 + c2e2 + c3e3
a ∧b =

a1
a2
b1
b2
e1 ∧e2 +

a2
a3
b2
b3
e2 ∧e3 +

a3
a1
b3
b1
e3 ∧e1
a ∧b ∧c =

a1
a2
a3
b1
b2
b3
c1
c2
c3

e1 ∧e2 ∧e3
|a ∧b| = |a||b|sinβ.
Geometric product
ab = a · b + a ∧b
ba = a · b −a ∧b
a · b = 1
2(ab + ba)
a ∧b = 1
2(ab −ba).
Inverse of a vector
a−1 =
a
|a|2 .
Duality
A⋆= IA
I = the local pseudoscalar.
Reverse of a multivector
A = ab
A† = ba.

Chapter 7
Rotation Transforms in the Plane
7.1 Introduction
In this chapter we investigate the techniques for rotating points in the plane using
geometry, matrices and multivectors. These ideas will be developed further in the
next chapter where we consider rotating frames of reference in the plane.
7.2 2D Transforms
2D transforms are used to scale, translate, rotate, reﬂect and shear shapes. For ex-
ample, a point P(x,y) is transformed into P ′(x′,y′) by modifying x and y using
x′ = ax + by
y′ = cx + dy.
By using different values for a,b,c and d we can scale, shear, reﬂect or rotate a
point about the origin. However, this transform cannot effect a translation as we
need to increment both x and y by values which are spatial offsets. To achieve this
we employ homogeneous coordinates.
7.2.1 Homogeneous Coordinates
Homogeneous coordinates are used to deﬁne a point in the plane using three coordi-
nates instead of two. This means that for a point (x,y) there exists a homogeneous
point (xt,yt,t) where t is an arbitrary number. The values of x and y are found by
dividing xt and yt by t. For example, the point (2,3) has homogeneous coordinates
(4,6,2), because (4/2,6/2,2/2) = (2,3,1). But the homogeneous point (4,6,2)
is not unique to (2,3) – (8,12,4), (10,15,5) and (200,300,100) are all possible
homogeneous coordinates for (2,3).
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_7, © Springer-Verlag London Limited 2011
85

86
7
Rotation Transforms in the Plane
Fig. 7.1 2D homogeneous
coordinates can be visualised
as a plane in 3D space where
t = 1, for convenience
For our purposes we can imagine that a collection of homogeneous points of
the form (xt,yt,t) exist on an xy-plane where t is the z-coordinate as illustrated
in Fig. 7.1. The ﬁgure shows a triangle on the t = 1 plane, and a similar, larger
triangle on a more distant plane. Thus, instead of working in two dimensions, we
can work on an arbitrary xy-plane in three dimensions. The t-coordinate of the plane
is immaterial because the x- and y-coordinates are eventually scaled by t. To keep
things simple it is convenient to choose t = 1, which means that the point (x,y) has
homogeneous coordinates (x,y,1) making scaling unnecessary.
If we substitute 3D homogeneous coordinates for traditional 2D Cartesian coor-
dinates we must attach 1 to every (x,y) pair. When a point (x,y,1) is transformed,
it emerges as (x′,y′,1), and we discard the 1. This may seem a futile exercise, but
it resolves the problem of creating a translation transform.
Consider the following transform on the homogeneous point (x,y,1):
x′ = ax + by + e
y′ = cx + dy + f
this is represented in matrix form as
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
a
b
e
c
d
f
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
and resolves the problem of translation by adding e and f to x′ and y′ respectively.
However, this has to be paid for in terms of extra memory required to store the larger
matrix.
7.3 Matrix Transforms
In this section we investigate strategies for designing matrix transforms to translate
and rotate points about the origin and an arbitrary point. We will also see how the
inverse transform is used to establish new frames of reference.

7.3
Matrix Transforms
87
Fig. 7.2 The point P (x,y) is
rotated through an angle β to
P ′(x′,y′)
7.3.1 Translate a Point
Perhaps the simplest transform is that of point translation. For example, to translate
a point P(x,y) by (tx,ty), we only require
x′ = x + tx
y′ = y + ty
which is represented by this homogeneous matrix
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
We will refer to this translate matrix as Ttx,ty.
As an example, let’s translate the point P(2,3) by (4,5), which moves it to
P ′(6,8):
⎡
⎣
6
8
1
⎤
⎦=
⎡
⎣
1
0
4
0
1
5
0
0
1
⎤
⎦
⎡
⎣
2
3
1
⎤
⎦.
7.3.2 Rotate a Point About the Origin
Figure 7.2 shows a point P(x,y) which is rotated an angle β about the origin to
P ′(x′,y′), and as we are dealing with a pure rotation, both P ′ and P are distance R
from the origin.
From Fig. 7.2 it can be seen that
cosθ = x/R
sinθ = y/R
x′ = R cos(θ + β)
y′ = R sin(θ + β)

88
7
Rotation Transforms in the Plane
and substituting the identities for cos(θ + β) and sin(θ + β) we have
x′ = R (cosθ cosβ −sinθ sinβ)
= R
 x
R cosβ −y
R sinβ

= x cosβ −y sinβ
y′ = R (sinθ cosβ + cosθ sinβ)
= R
 y
R cosβ + x
R sinβ

= x sinβ + y cosβ
or in matrix form
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
and is the homogeneous transform for rotating points about the origin. For example,
to rotate a point 90° about the origin the transform becomes
⎡
⎣
0
1
1
⎤
⎦=
⎡
⎣
0
−1
0
1
0
0
0
0
1
⎤
⎦
⎡
⎣
1
0
1
⎤
⎦
where we see the point (1,0,1) becomes (0,1,1) and we ignore the homogeneous
scaling factor of 1.
Rotating a point 360° about the origin the transform becomes the identity matrix:
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
The following observations can be made about the rotation matrix Rβ:
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦.
Its determinant equals 1:
detRβ = cos2 β + sin2 β = 1.
Its transpose is
RT
β =
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦.
The product RβRT
β = I:
RβRT
β =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦

7.3
Matrix Transforms
89
and because RβRT
β equals the identity matrix, R−1
β
= RT
β:
R−1
β
=
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦
conﬁrms that Rβ is orthogonal.
7.3.3 Rotate a Point About an Arbitrary Point
Now let’s see how to rotate a point (x,y) about an arbitrary point (tx,ty). The
strategy involves making the point of rotation a temporary origin, which is achieved
by subtracting (tx,ty) from the coordinates (x,y) respectively. Next, we perform a
rotation about the temporary origin, and ﬁnally, we add (tx,ty) back to the rotated
point to compensate for the original subtraction. Here are the steps:
1. Subtract (tx,ty) to create a new temporary origin:
x1 = x −tx
y1 = y −ty.
2. Rotate (x1,y1) about the temporary origin by β:
x2 = (x −tx)cosβ −(y −ty)sinβ
y2 = (x −tx)sinβ + (y −ty)cosβ.
3. Add (tx,ty) to the rotated point (x2,y2) to return to the original origin:
x′ = x2 + tx
y′ = y2 + ty
x′ = (x −tx)cosβ −(y −ty)sinβ + tx
y′ = (x −tx)sinβ + (y −ty)cosβ + ty.
Simplifying, we obtain
x′ = x cosβ −y sinβ + tx(1 −cosβ) + ty sinβ
y′ = x sinβ + y cosβ + ty(1 −cosβ) −tx sinβ
and in matrix form we have
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
−sinβ
tx (1 −cosβ) + ty sinβ
sinβ
cosβ
ty (1 −cosβ) −tx sinβ
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
(7.1)
For example, if we rotate the point (2,1), 90° about the point (1,1) the transform
(7.1) becomes
⎡
⎣
1
2
1
⎤
⎦=
⎡
⎣
0
−1
2
1
0
0
0
0
1
⎤
⎦
⎡
⎣
2
1
1
⎤
⎦.

90
7
Rotation Transforms in the Plane
The above algebraic approach to derive the rotation transform is relatively easy.
However, it is also possible to use matrices to derive composite transforms, such as
a reﬂection relative to an arbitrary line or scaling and rotation relative to an arbitrary
point. All of these linear transforms are called afﬁne transforms, as parallel lines
remain parallel after being transformed. Furthermore, the word ‘afﬁne’ is used to
imply that there is a strong geometric afﬁnity between the original and transformed
shape. One cannot always guarantee that angles and lengths are preserved, as these
can change when different scaling factors are used. For completeness, let’s derive
the above transform using matrices.
A transform for rotating a point β about the origin is given by
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
and a transform for translating a point (tx,ty) relative to the origin is given by
Ttx,ty =
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦.
We can use Rβ and Ttx,ty to develop a composite transform for rotating a point about
an arbitrary point (tx,ty) as follows:
⎡
⎣
x′
y′
1
⎤
⎦= Ttx,tyRβT−tx,−ty
⎡
⎣
x
y
1
⎤
⎦
(7.2)
where
T−tx,−ty
creates a temporary origin
Rβ
rotates β about the origin
Ttx,ty
returns to the original position.
Note that the transform sequence starts on the right next to the original coordinates,
working leftwards.
Equation (7.2) expands to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
Next, we multiply these matrices together to form a single matrix. Let’s begin by
multiplying the Rβ and T−tx,−ty matrices, which produces
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
⎡
⎣
cosβ
−sinβ
−tx cosβ + ty sinβ
sinβ
cosβ
−tx sinβ −ty cosβ
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
and ﬁnally we obtain
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
−sinβ
tx (1 −cosβ) + ty sinβ
sinβ
cosβ
ty (1 −cosβ) −tx sinβ
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
which is the same as the previous transform (7.1).

7.3
Matrix Transforms
91
7.3.4 Rotate and Translate a Point
There are two ways we can combine the rotate and translate transforms into a single
transform. The ﬁrst method starts by translating a point P(x,y) using T(tx,ty) to an
intermediate point, which is then rotated using Rβ. The problem with this strategy
is that the radius of rotation becomes large and subjects the point to a large circular
motion. The normal way is to ﬁrst subject the point to a rotation about the origin
and then translate it:
P ′ = Ttx,tyRβP
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
−sinβ
tx
sinβ
cosβ
ty
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
For example, consider rotating the point P(1,0), 90° and then translating it by
(1,0). The rotation moves P to (0,1) and the translation moves it to (1,1). This is
conﬁrmed by the above transform:
⎡
⎣
1
1
1
⎤
⎦=
⎡
⎣
0
−1
1
1
0
0
0
0
1
⎤
⎦
⎡
⎣
1
0
1
⎤
⎦.
7.3.5 Composite Rotations
It is worth conﬁrming that if we rotate a point β about the origin, and follow this
by a rotation of θ, this is equivalent to a single rotation of θ + β, so RθRβ = Rθ+β.
Let’s start with the transforms Rβ and Rθ:
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
Rθ =
⎡
⎣
cosθ
−sinθ
0
sinθ
cosθ
0
0
0
1
⎤
⎦.
We can represent the double rotation by the product RθRβ:
RθRβ =
⎡
⎣
cosθ
−sinθ
0
sinθ
cosθ
0
0
0
1
⎤
⎦
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦

92
7
Rotation Transforms in the Plane
=
⎡
⎣
cosθ cosβ −sinθ sinβ
−cosθ sinβ −sinθ cosβ
0
sinθ cosβ + cosθ sinβ
−sinθ sinβ + cosθ cosβ
0
0
0
1
⎤
⎦
=
⎡
⎣
cos(θ + β)
−sin(θ + β)
0
sin(θ + β)
cos(θ + β)
0
0
0
1
⎤
⎦
which conﬁrms that the composite rotation is equivalent to a single rotation of θ +β.
7.4 Inverse Transforms
Given a transform A, its inverse A−1 is deﬁned as such that
AA−1 = A−1A = I
where I is the identity matrix. So let’s identify the inverse translation and rotation
transforms.
We know that the translation matrix is given by
Ttx,ty =
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
and we could reason that the inverse of Ttx,ty must be a translation in the opposite
direction:
T−1
tx,ty =
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦.
We can conﬁrm this by computing T−1
tx,ty from the cofactor matrix of Ttx,ty, trans-
posing it and dividing by its determinant:
cofactor matrix of Ttx,ty =
⎡
⎣
1
0
0
0
1
0
−tx
−ty
1
⎤
⎦
TT
tx,ty =
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦
and as detTtx,ty = 1, we can write
T−1
tx,ty =
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦.
So our reasoning is correct. Furthermore, Ttx,tyT−1
tx,ty = I:
Ttx,tyT−1
tx,ty =
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦.

7.5
Multivector Transforms
93
Similarly, we know that the rotation transform is given by
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
and we can reason that the inverse of Rβ must be a rotation in the opposite direction,
i.e. a rotation of −β:
R−1
β =
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦.
We can also compute R−1
β
by forming the cofactor matrix of Rβ, transposing it and
dividing by its determinant:
cofactor matrix of Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
RT
β =
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦
and as detRβ = 1, we can write
R−1
β =
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦.
So our reasoning is correct. Furthermore, RβR−1
β = I:
RβR−1
β
=
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦.
7.5 Multivector Transforms
Multivectors are linear combinations of vectors, bivectors, trivectors, etc., plus a
scalar. They possess imaginary qualities and consequently have the ability to rotate
vectors. Although it is unusual to employ multivectors in 2D computer graphics,
they have been included to introduce their rotational qualities.
7.5.1 Translate a Point
Figure 7.3 shows a point P(x,y) with position vector p, and is translated by (tx,ty)
using
p′ = p + t

94
7
Rotation Transforms in the Plane
Fig. 7.3 Translate a point by
(tx,ty)
where t = [tx
ty]T. The position vector p′ points to the translated point P ′ with
components:
p′ = (x + tx)e1 +

y + ty
	
e2
and agrees with the translation matrix
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
7.5.2 Rotational Qualities of the Unit Bivector
We know from Chap. 2 that multiplying a complex number by imaginary i rotates
that complex number by 90°. In geometric algebra the 2D pseudoscalar e12 is also
imaginary in that e2
12 = −1, and has similar rotational properties, but has the extra
feature of controlling the direction of rotation. For example, Fig. 7.4 shows pe12
which rotates p, 90°:
p = p1e1 + p2e2
pe12 = (p1e1 + p2e2)e12
= p1e2 −p2e1
= −p2e1 + p1e2.
Fig. 7.4 pe12 rotates p, 90°

7.5
Multivector Transforms
95
Fig. 7.5 e12p rotates p, −90°
However, the reverse product e12p rotates p, −90°:
p = p1e1 + p2e2
pe12 = e12 (p1e1 + p2e2)
= −p1e2 + p2e1
= p2e1 −p1e2
as shown in Fig. 7.5.
We also discovered in Chap. 2 that a complex number z = a + bi can be repre-
sented in exponential form as
z = |z|eiβ = |z|(cosβ + i sinβ)
which, if used to multiply another complex number, scales it by |z| and rotates it β.
Figure 7.6 shows a plane deﬁned by m ∧n and the vectors n and m such that n
is rotated β further than m:
n = n1e1 + n2e2
m = m1e1 + m2e2
nm = n · m −m ∧n
= |n||m|cosβ −|m||n|sinβe12
= |n||m|(cosβ −sinβe12).
Fig. 7.6 The bivector m ∧n

96
7
Rotation Transforms in the Plane
Pre-multiplying a vector p by the product nm creates p′ such that given:
p = p1e1 + p2e2
nmp = |n||m|(cosβ −sinβe12)(p1e1 + p2e2)
= |n||m|(cosβp1e1 + cosβp2e2 + sinβp1e2 −sinβp2e1)
p′ = |n||m|

(cosβp1 −sinβp2)e1 + (sinβp1 + cosβp2)e2


p′
1
p′
2

= |n||m|
cosβ
−sinβ
sinβ
cosβ
p1
p2

and conﬁrms that the vector p is rotated β and scaled by |n||m|.
Post-multiplying a vector p by the product nm creates p′ such that given:
p = p1e1 + p2e2
pnm = (p1e1 + p2e2)|n||m|(cosβ −sinβe12)
= |n||m|(p1e1 cosβ −p1e2 sinβ + p2e2 cosβ + p2e1 sinβ)
p′ = |n||m|

(p1 cosβ + p2 sinβ)e1 + (−p1 sinβ + p2 cosβ)e2
	

p′
1
p′
2

= |n||m|

cosβ
sinβ
−sinβ
cosβ
p1
p2

and conﬁrms that the vector p is rotated −β and scaled by |n||m|. By making n
and m unit vectors, the product nm rotates a vector without scaling, which is an
essential quality for a rotation transform.
Before proceeding, we should clarify the effect of reversing the product nm to
mn. Therefore, assuming that vectors n and m remain unchanged, the product mn
is given by:
n = n1e1 + n2e2
m = m1e1 + m2e2
mn = m · n + m ∧n
= |n||m|cosβ + |m||n|sinβe12
= |n||m|(cosβ + sinβe12).
Pre-multiplying a vector p by the product mn creates p′ such that given:
p = p1e1 + p2e2
mnp = |n||m|(cosβ + sinβe12)(p1e1 + p2e2)
= |n||m|(cosβp1e1 + cosβp2e2 −sinβp1e2 + sinβp2e1)
p′ = |n||m|

(cosβp1 + sinβp2)e1 + (−sinβp1 + cosβp2)e2
	

p′
1
p′
2

= |n||m|

cosβ
sinβ
−sinβ
cosβ
p1
p2

and conﬁrms that the vector p is rotated −β and scaled by |n||m|.

7.5
Multivector Transforms
97
It should be no surprise that post-multiplying a vector p by the product mn rotates
it β.
The above results are summarised as follows:
nmp = pmn
rotates p,
β
pnm = mnp
rotates p, −β.
7.5.3 Rotate a Point About the Origin
In Chap. 9 on 3D rotations we show the origins of rotors in geometric algebra using
double reﬂections. The plane containing the vectors n and m is deﬁned by the wedge
product m ∧n, which means we can write the product mn as
mn = m · n + m ∧n
and the product nm in the same plane as
nm = m · n −m ∧n
which accounts for the negative sign in the following bivector term
nm = |n||m|(cosβ −sinβe12).
Furthermore, if we make n and m unit vectors we can replace them by a rotor Rβ
whose magnitude is 1 because
|Rβ| =

cos2 β + sin2 β = 1
therefore no scaling occurs, which means that
Rβp
rotates p,β
i.e. anticlockwise, and
pRβ
rotates p,−β
i.e. clockwise.
The effect of this rotor is illustrated as follows:
p = e1 + e2
R45° = cos45° −sin45°e12
=
√
2
2 −
√
2
2 e12
p′ = R45°p =
√
2
2 −
√
2
2 e12

(e1 + e2)
=
√
2
2 e1 +
√
2
2 e2 +
√
2
2 e2 −
√
2
2 e1
=
√
2e2
as shown in Fig. 7.7.

98
7
Rotation Transforms in the Plane
Fig. 7.7 The effect of rotor
R45° on vector p
Similarly, reversing the product to pR45° we obtain
p′ = pR45° = (e1 + e2)
√
2
2 −
√
2
2 e12

=
√
2
2 e1 −
√
2
2 e2 +
√
2
2 e2 +
√
2
2 e1
=
√
2e1
as shown in Fig. 7.7.
Geometric algebra also employs a reversion function which reverses the sequence
of elements in a multivector by switching the signs of bivector and trivector ele-
ments. Instead of reversing the sequence of p and Rβ, we can reverse Rβ using R†
β:
Rβ = cosβ −sinβe12
R†
β = cosβ + sinβe12
therefore,
p′ = R†
45°p =
√
2
2 +
√
2
2 e12

(e1 + e2)
=
√
2
2 e1 +
√
2
2 e2 −
√
2
2 e2 +
√
2
2 e1
=
√
2e1
and
p′ = pR†
45° = (e1 + e2)
√
2
2 +
√
2
2 e12

=
√
2
2 e1 +
√
2
2 e2 +
√
2
2 e2 −
√
2
2 e1
=
√
2e2
which means that

7.5
Multivector Transforms
99
R†
βp
rotates p,−β
i.e. clockwise
pR†
β
rotates p,β
i.e. anticlockwise
and
Rβp = pR†
β
pRβ = R†
βp.
Using the rotor Rβ in a single-sided transformation only works for vectors in the
plane of rotation, which satisﬁes everything we do in 2D. However, in 3D we have
to employ a double-sided, half-angle formula of the form RβpR†
β, which is covered
in Chap. 11.
7.5.4 Rotate a Point About an Arbitrary Point
Earlier in this chapter we developed a transform for rotating a point about an ar-
bitrary point. Let’s show how we can approach the same problem using geometric
algebra. Figure 7.8 shows the geometry describing how the point P is rotated β
about T to P ′, and by inspection we can write
p′ = t + Rβ (p −t).
Using the previous example, where T = (1,1),P = (2,1) and β = 90° we have
R90° = cos90° −sin90°e12 = −e12
t = e1 + e2
p = 2e1 + e2
p′ = e1 + e2 −e12 (2e1 + e2 −e1 −e2)
= e1 + e2 −e12e1
= e1 + e2 + e2
= e1 + 2e2
which is correct.
Fig. 7.8 Using a rotor Rβ to
rotate P about T

100
7
Rotation Transforms in the Plane
If we expand the deﬁnition of p′ we obtain:
p′ = t + Rβ (p −t)
= txe1 + tye2 + (cosβ −sinβe12)

(x −tx)e1 + (y −ty)e2
	
= txe1 + tye2 +

x cosβ −y sinβ −tx cosβ + ty sinβ
	
e1
+ (x sinβ + y cosβ −tx sinβ −ty cosβ)e2
=

x cosβ −y sinβ + tx (1 −cosβ) + ty sinβ
	
e1
+

x sinβ + y cosβ + ty (1 −cosβ) −tx sinβ
	
e2
which in matrix form is
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
−sinβ
tx (1 −cosβ) + ty sinβ
sinβ
cosβ
ty (1 −cosβ) −tx sinβ
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
and agrees with the original transform (7.1).
7.6 Summary
In this chapter we have seen how the translation and rotation transforms are used
to rotate points about the origin and arbitrary points. We have also seen how the
inverse transforms translate and rotate in the opposite directions which will be used
in the next chapter to relate points in different frames of reference.
We have also seen how multivectors provide an alternative approach based upon
vectors, bivectors and rotors, and can undertake the same tasks. However, we have
discovered that fundamentally they are matrix transforms in disguise, albeit, an ef-
fective one.
In order to show the patterns that exist between these two mathematical ap-
proaches, all the commands are summarised.
7.6.1 Summary of Matrix Transforms
Translate a point
Ttx,ty =
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦.
Rotate a point
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦.

7.6
Summary
101
Rotate a point about (tx,ty)
Ttx,tyRβT−tx,−ty =
⎡
⎣
cosβ
−sinβ
tx (1 −cosβ) + ty sinβ
sinβ
cosβ
ty (1 −cosβ) −tx sinβ
0
0
1
⎤
⎦.
7.6.2 Summary of Multivector Transforms
Rotor deﬁnition
Rβ = cosβ −sinβe12
R†
β = cosβ + sinβe12.
Translate a point
p′ = p + t = (x + tx)e1 + (y + ty)e2.
Rotate a point
p′ = Rβp = (cosβ −sinβe12)(xe1 + ye2)
p′ = pR†
β = (xe1 + ye2)(cosβ + sinβe12).
Rotate a point about (tx,ty)
p′ = t + Rβ (p −t) = txe1 + tye2 + (cosβ −sinβe12)

(x −tx)e1 + (y −ty)e2
	
p′ = t + (p −t)R†
β = txe1 + tye2 +

(x −tx)e1 + (y −ty)e2
	
(cosβ + sinβe12).


Chapter 8
Frames of Reference in the Plane
8.1 Introduction
In the previous chapter we covered the transforms for rotating points in the plane
with respect to a ﬁxed frame of reference. In this chapter we investigate the trans-
forms for computing the coordinates of points in rotated frames of reference using
geometry, matrices and multivectors. We will employ many of the concepts previ-
ously described in order to develop inverse transforms and rotors.
8.2 Frames of Reference
You have probably been on a train waiting to depart from a railway station, and
through the window see another stationary train. Then suddenly you notice move-
ment. To begin with, it is difﬁcult to decide which train is moving, and the problem
is often resolved when the entire scenario is seen with reference to some ﬁxed object
such as a tree or a building. This phenomena reminds us that motion is relative, and
plays an important role in understanding transforms and frames of reference.
When a frame of reference moves – such as a train – the relationship between
the seated passengers and the train remains ﬁxed. The only thing that does change
is the relationship between the train and other frames of references such as a tree or
a building.
One can describe the relative motion between the train and a tree by assuming
that the train remains stationary and the tree moves in an equal and opposite direc-
tion. So if the train’s translation is described by T, the tree’s translation relative to
the train is described by the inverse transform T−1.
Similarly, the rotation of a swivel chair can be described in two ways. The usual
way is to assume that the swivel chair rotates relative to the desk where it’s lo-
cated. The relative motion interpretation proposes that the chair is stationary, whilst
the desk rotates in an equal and opposite direction. So if the chair’s rotation is de-
scribed by R, the desk’s rotation relative to the chair is described by the inverse
transform R−1.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_8, © Springer-Verlag London Limited 2011
103

104
8
Frames of Reference in the Plane
Let’s assume that a tree is located in a 3D frame of reference labelled XYZ and
the train’s frame of reference is labelled X′Y ′Z′. When the two frames are coinci-
dent, the tree has identical coordinates in both frames. However, if the train’s frame
X′Y ′Z′ is translated by the transform T relative to XYZ, the tree’s coordinates rel-
ative to the train have effectively moved in the opposite direction given by T−1.
Similarly, let’s assume that a desk is located in a frame of reference labelled
XYZ and a chair’s frame of reference is labelled X′Y ′Z′. When the two frames are
coincident, the desk has identical coordinates in both frames. However, if the chair’s
frame X′Y ′Z′ is rotated by the transform R relative to XYZ, the desk’s coordinates
relative to the chair have effectively rotated in the opposite direction given by R−1.
8.3 Matrix Transforms
Having established the equivalence between transforms for moving points in a ﬁxed
frame, and the inverse transforms for ﬁxed points in a moving frame, let’s explore
how we construct the transforms for translated and rotated frames of reference in
the plane. As in the previous chapter, we will show how matrices and multivectors
offer two approaches to this problem.
In computer graphics most frame of reference transforms are expressed by a
translation or a rotation, or a combination of both. We will explore these different
scenarios and develop transforms for converting coordinates in the original frame of
reference to coordinates in the second frame.
8.3.1 Translated Frame of Reference
Figure 8.1 shows two coincident 2D frames of reference X′Y ′ and XY, where a
point in one frame has identical coordinates in the other. Therefore, the two frames
of reference are related as follows
⎡
⎣
x′
y′
1
⎤
⎦= I
⎡
⎣
x
y
1
⎤
⎦
where I is the identity transform
I =
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦
which ensures that P ′ = P .

8.3
Matrix Transforms
105
Fig. 8.1 The X′Y ′ axial
system is coincident with XY
Fig. 8.2 The X′Y ′ axial
system is translated (tx,ty)
Figure 8.2 shows the frame X′Y ′ translated by (tx,ty) which is equivalent to
translating P by T−tx,−ty which is also the inverse transform T−1
tx,ty. Therefore,
a point P(x,y) in XY has coordinates P ′(x′,y′) in X′Y ′ given by
⎡
⎣
x′
y′
1
⎤
⎦= T−1
tx,ty
⎡
⎣
x
y
1
⎤
⎦
where
T−1
tx,ty =
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦.
For example, the point (tx,ty) in XY should have coordinates (0,0) in X′Y ′:
⎡
⎣
0
0
1
⎤
⎦=
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦
⎡
⎣
tx
ty
1
⎤
⎦
which is conﬁrmed.

106
8
Frames of Reference in the Plane
Fig. 8.3 The X′Y ′ axial
system is rotated β
8.3.2 Rotated Frame of Reference
Figure 8.3 shows the frame X′Y ′ rotated β which is equivalent to rotating P by
−β and is effected by the transform R−1
β . Therefore, a point P(x,y) in XY has
coordinates P ′(x′,y′) in X′Y ′ given by
⎡
⎣
x′
y′
1
⎤
⎦= R−1
β
⎡
⎣
x
y
1
⎤
⎦
where
R−1
β =
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦.
We can also conﬁrm this using the geometry shown in Fig. 8.3,
x = R cosθ
y = R sinθ
x′ = R cos(θ −β)
y′ = R sin(θ −β)
x′ = R cosθ cosβ + R sinθ sinβ
= x cosβ + y sinβ
y′ = R sinθ cosβ −R cosθ sinβ
= −x sinβ + y cosβ
which as a homogeneous matrix is
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦

8.3
Matrix Transforms
107
which is the inverse rotation transform R−1
β
or R−β. For example, the point (1,1)
in XY, will have coordinates (
√
2,0) in the frame of reference rotated 45°:
⎡
⎣
√
2
0
1
⎤
⎦=
⎡
⎣
√
2/2
√
2/2
0
−
√
2/2
√
2/2
0
0
0
1
⎤
⎦
⎡
⎣
1
1
1
⎤
⎦
which is conﬁrmed.
We have previously shown that two separate rotations of a point is equivalent
to a single composite rotation of a point. Similarly, it is a trivial exercise to prove
that two separate rotations of a frame is equivalent to single composite rotation of a
frame.
8.3.3 Rotated and Translated Frame of Reference
Having looked at translated and rotated frames of reference, let’s combine the two
operations and develop a single transform. This is not too difﬁcult to follow, so long
as we are careful with our deﬁnitions and diagrams.
When a point is rotated and translated we use the operation
P ′ = Ttx,tyRβP.
We know that the transform for moving a frame of reference – whilst keeping a point
ﬁxed – is the inverse of that used for moving points – whilst keeping the frame ﬁxed.
Which suggests that the transform for a rotated and translated frame of reference is
the inverse of Ttx,tyRβ which is
(Ttx,tyRβ)−1 = R−1
β T−1
tx,ty
and makes
P ′ = R−1
β T−1
tx,tyP
or
P ′ = R−βT−tx,−tyP.
Substituting the matrices for R−β and T−tx,−ty we have
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
which simpliﬁes to
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
sinβ
−tx cosβ −ty sinβ
−sinβ
cosβ
tx sinβ −ty cosβ
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
(8.1)
Equation (8.1) is the homogeneous matrix for converting points in the XY coordi-
nate system to the translated and rotated X′Y ′ coordinate system.

108
8
Frames of Reference in the Plane
Fig. 8.4 The X′Y ′ axial
system translated (tx,ty) and
rotated β
A quick test conﬁrms that Ttx,tyRβR−1
β T−1
tx,ty = I, i.e.
Ttx,tyRβR−1
β T−1
tx,ty = Ttx,tyT−1
tx,ty = I
or⎡
⎣
cosβ
−sinβ
tx
sinβ
cosβ
ty
0
0
1
⎤
⎦
⎡
⎣
cosβ
sinβ
−tx cosβ −ty sinβ
−sinβ
cosβ
tx sinβ −ty cosβ
0
0
1
⎤
⎦=
⎡
⎣
1
0
0
0
1
0
0
0
1
⎤
⎦.
Figure 8.4 shows how the frame of reference XT YT is created for the intermedi-
ate translated frame, followed by a rotation of β about the new origin, ending with
the ﬁnal frame of reference X′Y ′.
Let’s test (8.1) with the example shown in Fig. 8.5 where
β = 90°
(tx,ty) = (10,5)
(x,y) = (9,6)
⎡
⎣
1
1
1
⎤
⎦=
⎡
⎣
0
1
−5
−1
0
10
0
0
1
⎤
⎦
⎡
⎣
9
6
1
⎤
⎦
(8.2)
and we see that (9,6) in XY becomes (1,1) in X′Y ′.
Fig. 8.5 The X′Y ′ axial
system is translated (10,5)
and rotated 90°

8.4
Direction Cosines
109
Fig. 8.6 If the X′- and
Y ′-axes are assumed to be
unit vectors, their direction
cosines form the elements of
the rotation matrix
8.4 Direction Cosines
Direction cosines are the cosines of the angles between a vector and the Cartesian
axes, and for a unit vector they are its components.
Figure 8.6 shows the rotated frame X′Y ′, and by inspection the direction cosines
for a vector lying on X′ are cosβ and cos(90° −β), which can be rewritten as cosβ
and sinβ. The direction cosines for a vector lying on Y ′ are cos(90° + β) and cosβ,
which can be rewritten as −sinβ and cosβ. But these direction cosines cosβ, sinβ,
−sinβ and cosβ are the four elements of the inverse rotation matrix R−1
β :
R−1
β =

cosβ
sinβ
−sinβ
cosβ

.
The top row contains the direction cosines for the X′-axis and the bottom row con-
tains the direction cosines for the Y ′-axis. This relationship also holds in 3D. Conse-
quently, if we have access to these cosines we can construct a transform that relates
rotated frames of reference.
Figure 8.7 shows an axial system X′Y ′ rotated 45°, and the associated transform
is
⎡
⎣
x′
y′
1
⎤
⎦≈
⎡
⎣
0.707
0.707
0
−0.707
0.707
0
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦.
Fig. 8.7 The four vertices of
the unit square shown in both
frames

110
8
Frames of Reference in the Plane
The four vertices on a unit square become
(0,0) →(0,0)
(1,0) →(0.707,−0.707)
(1,1) →(1.1414,0)
(0,1) →(0.707,0.707)
which by inspection of Fig. 8.7 are correct.
8.5 Multivector Transforms
Geometric algebra is relatively new compared to other branches of mathematics and
has still not found its way into mainstream computer graphics software. Neverthe-
less, it has been included in this chapter to demonstrate that it can be used alongside
matrix transforms and quaternions.
8.5.1 Translated Frame of Reference
Figure 8.8 shows a frame of reference X′Y ′ translated (tx,ty) relative to the original
frame of reference XY. Therefore, if p points to a point P(x,y) in XY, and t points
to the origin of X′Y ′, then p′ = p −t points to the point P ′(x′,y′) relative to the
X′Y ′ frame of reference, and means that p′ is given by
p′ = (x −tx)e1 + (y −ty)e2.
Fig. 8.8 The X′Y ′ axial
system translated (tx,ty)

8.5
Multivector Transforms
111
Fig. 8.9 Using a rotor R to
rotate XY to X′Y ′
8.5.2 Rotated Frame of Reference
We have already shown that in order to compute the coordinates of a point P in
a rotated frame of reference X′Y ′, we rotate the point by an angle in the opposite
direction as shown in Fig. 8.9 to P ′. Thus if the new frame of reference is rotated β,
and p is P ’s position vector, then p′ points to the new point P ′ and is computed as
follows:
p′ = R†
βp
where
R†
β = cosβ + sinβe12.
Let’s test this with the same example used above by rotating the frame of reference
45° and computing the coordinates of the point (1,1)
p = e1 + e2
R†
45° = cos45° + sin45°e12
=
√
2
2 +
√
2
2 e12
p′ =
√
2
2 +
√
2
2 e12
	
(e1 + e2)
=
√
2
2 e1 +
√
2
2 e2 −
√
2
2 e2 +
√
2
2 e1
=
√
2e1
and P ′ = (
√
2,0), which is correct.

112
8
Frames of Reference in the Plane
Fig. 8.10 The X′Y ′ axial
system is rotated 90° and
translated (10,5)
8.5.3 Rotated and Translated Frame of Reference
Earlier, we saw how two inverse transforms are used to compute the coordinates of a
point in a rotated and translated frame of reference. We can achieve the same result
using multivectors as follows.
We begin with point P and its frame of reference XY. The ﬁrst step is to establish
a translated frame of reference XT YT with position vector t. Which means that
pT = p −t.
(8.3)
Next, as shown in Fig. 8.10, we rotate pT by −β to effectively rotate the frame of
reference XT YT to X′Y ′. Which means that
p′ = R†
βpT .
(8.4)
Substituting (8.3) in (8.4) we have
p′ = R†
β(p −t)
or
p′ = (cosβ + sinβe12)

(x −tx)e1 + (y −ty)e2

.
(8.5)
Let’s test (8.5) using the same values in the previous example where
β = 90°
(tx,ty) = (10,5)
(x,y) = (9,6)
p′ =

cos90° + sin90°e12

(9 −10)e1 + (6 −5)e2

= e12(−e1 + e2)
= e1 + e2
which makes P ′ = (1,1) the same as (8.2).
Although multivectors provide an alternative way of solving vector-based prob-
lems, they still have a matrix background. For example, expanding (8.5) we have

8.6
Summary
113
p′ = (cosβ + sinβe12)

(x −tx)e1 + (y −ty)e2

= (x cosβ−tx cosβ)e1 + (y cosβ−ty cosβ)e2
−(x sinβ−tx sinβ)e2 + (y sinβ−ty sinβ)e1
= (x cosβ + y sinβ −tx cosβ −ty sinβ)e1
+ (−x sinβ + y cosβ + tx sinβ −ty cosβ)e2
or in matrix form
⎡
⎣
x′
y′
1
⎤
⎦=
⎡
⎣
cosβ
sinβ
−tx cosβ −ty sinβ
−sinβ
cosβ
tx sinβ −ty cosβ
0
0
1
⎤
⎦
⎡
⎣
x
y
1
⎤
⎦
which is identical to (8.1).
8.6 Summary
In this chapter we have discovered that if a transform such as Ttx,ty or Rβ is used
for moving points, whilst keeping the frame ﬁxed, their inverses T−1
tx,ty and R−1
β
can
be used for moving the frame, whilst keeping the point ﬁxed. It goes without saying
that the converse also holds, in that we could have declared a transform for moving
a frame, and its inverse could be used for moving a point.
We have also seen how geometric algebra provides an alternative approach to
transforms based upon vectors, bivectors and rotors, and can undertake the same
tasks.
In order to show the patterns that exist between these two mathematical ap-
proaches, all the commands are summarised.
8.6.1 Summary of Matrix Transforms
Given
Ttx,ty =
⎡
⎣
1
0
tx
0
1
ty
0
0
1
⎤
⎦
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦.
Translate frame
T−1
tx,ty =
⎡
⎣
1
0
−tx
0
1
−ty
0
0
1
⎤
⎦.

114
8
Frames of Reference in the Plane
Rotate frame
R−1
β =
⎡
⎣
cosβ
sinβ
0
−sinβ
cosβ
0
0
0
1
⎤
⎦.
Translate and rotate frame
R−1
β T−1
tx,ty =
⎡
⎣
cosβ
sinβ
−tx cosβ −ty sinβ
−sinβ
cosβ
tx sinβ −ty cosβ
0
0
1
⎤
⎦.
8.6.2 Summary of Multivector Transforms
Frame rotor
R†
β = cosβ + sinβe12.
Translate frame
p′ = p −t = (x −tx)e1 + (y −ty)e2.
Rotate frame
p′ = R†
βp = (cosβ + sinβe12)(xe1 + ye2).
Translate and rotate frame
p′ = R†
β(p −t) = (cosβ + sinβe12)

(x −tx)e1 + (y −ty)e2

.

Chapter 9
Rotation Transforms in Space
9.1 Introduction
In this chapter we generalise the 2D transforms covered in Chap. 7 to three dimen-
sions. In particular, we examine rotating points about the ﬁxed three Cartesian axes
and off-set, parallel axes, and about an arbitrary axis. We also explore Euler an-
gles, and their Achilles’ heel – gimbal lock. Matrices will be used to describe these
geometric scenarios.
9.2 3D Transforms
3D transforms include the scale, translate, reﬂect, shear and rotate transforms, and
in this chapter we need only consider the translate and rotate operations, which we
will explore individually and in combination. Let’s start with the translate transform.
9.2.1 Translate a Point
The matrix for a 3D point translation is basically the same as previously described
but with one extra dimension Ttx,ty,tz. It requires the homogeneous form and is
written
Ttx,ty,tz =
⎡
⎢⎢⎣
1
0
0
tx
0
1
0
ty
0
0
1
tz
0
0
0
1
⎤
⎥⎥⎦
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_9, © Springer-Verlag London Limited 2011
115

116
9
Rotation Transforms in Space
where tx, ty, tz are the x-, y-, z-offsets respectively. It goes without further explana-
tion that the inverse transform T−1
tx,ty,tz is
T−1
tx,ty,tz =
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦.
9.2.2 Rotate a Point About the Cartesian Axes
Although we talk about rotating points about another point in space, we require
more precise information to describe this mathematically. We could, for example,
associate a plane with the point of rotation and conﬁne the rotated point to this plane,
but it’s much easier to visualise an axis perpendicular to this plane, about which the
rotation occurs. Unfortunately, the matrix algebra for such an operation starts to be-
come fussy, and ultimately we have seek the help of quaternions or multivectors.
So let us begin this investigation by rotating a point about the three ﬁxed Carte-
sian axes. Such rotations are called Euler rotations after the Swiss mathematician
Leonhard Euler.
Recall that the transform for rotating a point about the origin in the plane is given
by
Rβ =
⎡
⎣
cosβ
−sinβ
0
sinβ
cosβ
0
0
0
1
⎤
⎦.
This can be generalised into a 3D rotation Rβ,z about the z-axis by adding a z-
coordinate as follows
Rβ,z =
⎡
⎢⎢⎣
cosβ
−sinβ
0
0
sinβ
cosβ
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
which is illustrated in Fig. 9.1
To rotate a point about the x-axis, the x-coordinate remains constant whilst the
y- and z-coordinates are changed according to the 2D rotation transform. This is
expressed algebraically as
x′ = x
y′ = y cosβ −zsinβ
z′ = y sinβ + zcosβ

9.2
3D Transforms
117
Fig. 9.1 Rotating the point
P about the z-axis
or in matrix form as Rβ,x
Rβ,x =
⎡
⎢⎢⎣
1
0
0
0
0
cosβ
−sinβ
0
0
sinβ
cosβ
0
0
0
0
1
⎤
⎥⎥⎦.
To rotate about the y-axis, the y-coordinate remains constant whilst the x- and z-
coordinates are changed. This is expressed algebraically as
x′ = zsinβ + x cosβ
y′ = y
z′ = zcosβ −x sinβ
or in matrix form as Rβ,y
Rβ,y =
⎡
⎢⎢⎣
cosβ
0
sinβ
0
0
1
0
0
−sinβ
0
cosβ
0
0
0
0
1
⎤
⎥⎥⎦.
Note that the matrix terms don’t appear to share the symmetry enjoyed by the pre-
vious two matrices. Nothing really has gone wrong, it’s just the way the axes are
paired together to rotate the coordinates. Now let’s consider similar rotations about
off-set axes parallel to the Cartesian axes.
9.2.3 Rotating About an Off-Set Axis
To begin, let’s develop a transform to rotate a point about a ﬁxed axis parallel with
the z-axis, as shown in Fig. 9.2. The scenario is very reminiscent of the 2D case for
rotating a point about an arbitrary point, and the general transform is given by
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= Ttx,ty,0Rβ,zT−tx,−ty,0
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦

118
9
Rotation Transforms in Space
Fig. 9.2 Rotating a point
about an axis parallel with the
z-axis
where
T−tx,−ty,0
creates a temporary origin
Rβ,z
rotates β about the temporary z-axis
Ttx,ty,0
returns to the original position
and the matrix transform is
Ttx,ty,0Rβ,zT−tx,−ty,0 =
⎡
⎢⎢⎣
cosβ
−sinβ
0
tx(1 −cosβ) + ty sinβ
sinβ
cosβ
0
ty(1 −cosβ) −tx sinβ
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
I hope you can see the similarity between rotating in 3D and 2D – the x- and
y-coordinates are updated while the z-coordinate is held constant. We can now state
the other two matrices for rotating about an off-set axis parallel with the x-axis and
parallel with the y-axis:
T0,ty,tzRβ,xT0,−ty,−tz =
⎡
⎢⎢⎣
1
0
0
0
0
cosβ
−sinβ
ty(1 −cosβ) + tz sinβ
0
sinβ
cosβ
tz(1 −cosβ) −ty sinβ
0
0
0
1
⎤
⎥⎥⎦
Ttx,0,tzRβ,yT−tx,0,−tz =
⎡
⎢⎢⎣
cosβ
0
sinβ
tx(1 −cosβ) −tz sinβ
0
1
0
0
−sinβ
0
cosβ
tz(1 −cosβ) + tx sinβ
0
0
0
1
⎤
⎥⎥⎦.
9.3 Composite Rotations
So far we have only considered single rotations about a Cartesian axis or a parallel
off-set axis, but there is nothing to stop us constructing a sequence of rotations
to create a composite rotation. For example, we could begin by rotating a point α
about the x-axis followed by a rotation β about the y-axis, which in turn could be

9.3
Composite Rotations
119
Fig. 9.3 A unit cube with
vertices coded as shown in
Table 9.1
Table 9.1 Vertex coordinates
for the cube in Fig. 9.3
vertex
0
1
2
3
4
5
6
7
x
0
0
0
0
1
1
1
1
y
0
0
1
1
0
0
1
1
z
0
1
0
1
0
1
0
1
followed by a rotation γ about the z-axis. As mentioned above, these rotations are
called Euler rotations.
One of the problems with Euler rotations is visualising exactly what is happening
at each step, and predicting the orientation of an object after a composite rotation. To
simplify the problem we will employ a unit cube whose vertices are numbered 0 to
7 as shown in Fig. 9.3. We will also employ the following binary coded expression
that uses the Cartesian coordinates of the vertex in the vertex number:
vertex = 4x + 2y + z.
For example, vertex 0 has coordinates (0,0,0), and vertex 7 has coordinates
(1,1,1). All the codes are shown in Table 9.1.
Let’s repeat the three rotation transforms for rotating points about the x-, y- and
z-axes respectively, in their non-homogeneous form and substitute c for cos and s
for sin to save space:
rotate α about the x-axis
Rα,x =
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
rotate β about the y-axis
Rβ,y =
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
rotate γ about the z-axis
Rγ,z =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦.

120
9
Rotation Transforms in Space
We can create a composite, moving-point, ﬁxed-frame rotation by placing
Rα,x, Rβ,y and Rγ,z in any sequence. As an example, let’s choose the sequence
Rγ,zRβ,yRα,x
Rγ,zRβ,yRα,x =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦. (9.1)
Multiplying the three matrices in (9.1) together we obtain
⎡
⎣
cγ cβ
cγ sβsα −sγ cα
cγ sβcα + sγ sα
sγ cβ
sγ sβsα + cγ cα
sγ sβcα −cγ sα
−sβ
cβsα
cβcα
⎤
⎦
(9.2)
or using the more familiar notation:
⎡
⎣
cosγ cosβ
cosγ sinβ sinα −sinγ cosα
cosγ sinβ cosα + sinγ sinα
sinγ cosβ
sinγ sinβ sinα + cosγ cosα
sinγ sinβ cosα −cosγ sinα
−sinβ
cosβ sinα
cosβ cosα
⎤
⎦.
Let’s evaluate (9.2) by making α = β = γ = 90°:
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦.
(9.3)
The matrix (9.3) is equivalent to rotating a point 90° about the ﬁxed x-axis, followed
by a rotation of 90° about the ﬁxed y-axis, followed by a rotation of 90° about the
ﬁxed z-axis. This rotation sequence is illustrated in Fig. 9.4 (a)–(d).
Figure 9.4 (a) shows the starting position of the cube; (b) shows its orientation
after a 90° rotation about the x-axis; (c) shows its orientation after a further rotation
of 90° about the y-axis; and (d) the cube’s resting position after a rotation of 90°
about the z-axis.
From Fig. 9.4 (d) we see that the cube’s coordinates are as shown in Table 9.2. We
can conﬁrm that these coordinates are correct by multiplying the cube’s original co-
ordinates shown in Table 9.1 by the matrix (9.3). Although it is not mathematically
correct, we will show the matrix multiplying an array of coordinates as follows
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
0
0
0
0
−1
−1
−1
−1
⎤
⎦
which agree with the coordinates in Table 9.2.
Naturally, any three angles can be chosen to rotate a point about the ﬁxed axes,
but it does become difﬁcult to visualise without an interactive cgi system.
Note that the determinant of (9.3) is 1, which is as expected.

9.3
Composite Rotations
121
Fig. 9.4 Four views of the unit cube before and during the three rotations
Table 9.2 Vertex coordinates
for the cube in Fig. 9.4 (d)
vertex
0
1
2
3
4
5
6
7
x
0
1
0
1
0
1
0
1
y
0
0
1
1
0
0
1
1
z
0
0
0
0
−1
−1
−1
−1
An observation we made with 2D rotations is that they are additive: i.e. Rα fol-
lowed by Rβ is equivalent to Rα+β. But something equally important is that rota-
tions in 2D commute:
RαRβ = RβRα = Rα+β = Rβ+α
whereas, in general, 3D rotations are non-commutative. This is seen by considering
a composite rotation formed by a rotation α about the x-axis Rα,x, followed by a
rotation β about the z-axis Rβ,z, and
Rα,xRβ,z ̸= Rβ,zRα,x.
As an illustration, let’s reverse the composite rotation computed above to
Rα,xRβ,yRγ,z:
Rα,xRβ,yRγ,z =
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦. (9.4)

122
9
Rotation Transforms in Space
Fig. 9.5 Four views of the unit cube using the rotation sequence Rα,xRβ,yRγ,z
Multiplying the three matrices in (9.4) together we obtain
⎡
⎣
cβcγ
−cβsγ
sβ
sαsβcγ + cαsγ
−sαsβsγ + cαcγ
−sαcβ
−cαsβcγ + sαsγ
cαsβsγ + sαcγ
cαcβ
⎤
⎦
(9.5)
or using the more familiar notation:
⎡
⎣
cosβ cosγ
−cosβ sinγ
sinβ
sinα sinβ cosγ + cosα sinγ −sinα sinβ sinγ + cosα cosγ −sinα cosβ
−cosα sinβ cosγ + sinα sinγ
cosα sinβ sinγ + sinα cosγ
cosα cosβ
⎤
⎦.
Comparing (9.3) and (9.5) it can be seen that they are completely different.
Let’s evaluate (9.5) by making α = β = γ = 90°:
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦.
(9.6)
The matrix (9.6) is equivalent to rotating a point 90° about the ﬁxed z-axis, fol-
lowed by a rotation of 90° about the ﬁxed y-axis, followed by a rotation of 90° about
the ﬁxed x-axis. This rotation sequence is illustrated in Fig. 9.5 (a)–(d).
From Fig. 9.5 (d) we see that the cube’s coordinates are as shown in Table 9.3.
We can conﬁrm that these coordinates are correct by multiplying the cube’s original

9.3
Composite Rotations
123
Table 9.3 Vertex coordinates
for the cube in Fig. 9.5 (d)
vertex
0
1
2
3
4
5
6
7
x
0
1
0
1
0
1
0
1
y
0
0
−1
−1
0
0
−1
−1
z
0
0
0
0
1
1
1
1
coordinates shown in Table 9.1 by the matrix (9.6). We show the matrix multiplying
an array of coordinates as before:
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦
which agree with the coordinates in Table 9.3, and we can safely conclude that, in
general, 3D rotation transforms do not commute. Inspection of Fig. 9.5 (d) shows
that the unit cube has been rotated 180° about a vector [1
0
1]T.
Now let’s explore the role eigenvectors and eigenvalues play in 3D rotations.
9.3.1 3D Eigenvectors
In Chap. 4 we examined the characteristic equation used to identify any eigenvectors
associated with a matrix. The eigenvector v satisﬁes the relationship
Av = λv
where λ is a scaling factor.
In the context of a 3D rotation matrix, an eigenvector is a vector scaled by λ
but not rotated, which implies that it is the axis of rotation. To illustrate this, let’s
identify the eigenvector for the composite rotation (9.3) above:
R90°,zR90°,yR90°,x =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦.
Figure 9.4 (a)–(d) shows the effect of this composite rotation, which is nothing
more than a rotation of 90° about the y-axis. Therefore, we should be able to extract
this information from the above matrix.
We begin by writing the characteristic equation for the matrix:

0 −λ
0
1
0
1 −λ
0
−1
0
0 −λ

= 0.
(9.7)

124
9
Rotation Transforms in Space
Expanding (9.7) using the top row we have
−λ

1 −λ 0
0
−λ
 + 1

0 1 −λ
−1
0
 = 0
−λ
	
−λ + λ2
+ 1 −λ = 0
λ2 −λ3 + 1 −λ = 0
−λ3 + λ2 −λ + 1 = 0
λ3 −λ2 + λ = 1.
When working with 3 × 3 matrices we always end up with a cubic in λ, for which
there can be three types of solution:
1. One real and two complex conjugate solutions.
2. Three real solutions including the possibility of a double solution.
3. Three distinct real solutions.
It is clear that λ = 1 is one such real root, which satisﬁes our requirement for an
eigenvalue. We could also show that the other two roots are complex conjugates.
Substituting λ = 1 in the original equations associated with (9.7) to reveal the
eigenvector, we have
⎧
⎨
⎩
−x + 0y + z = 0
0x + 0y + 0z = 0
−x + 0y −z = 0.
It is obvious from the 1st and 3rd equations that x = z = 0. However, all three
equations multiply the y term by zero, which implies that the associated eigenvector
is of the form [0
k
0]T, which is the y-axis, as anticipated. Now let’s ﬁnd the
angle of rotation.
Using one of the above rotation matrices Rβ,y and the trace operation:
Rβ,y =
⎡
⎣
cosβ
0
sinβ
0
1
0
−sinβ
0
cosβ
⎤
⎦
Tr(Rβ,y) = 1 + 2cosβ
therefore,
β = arccos((Tr(Rβ,y) −1)/2).
To illustrate this, let β = 90°:
R90°,y =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
Tr(R90°,y) = 1
therefore,
β = arccos((1 −1)/2) = 90°.

9.3
Composite Rotations
125
Let’s choose another matrix and repeat the above:
Rα,x =
⎡
⎣
1
0
0
0
cosα
−sinα
0
sinα
cosα
⎤
⎦.
This time, let α = 45°:
R45°,x =
⎡
⎣
1
0
0
0
√
2/2
−
√
2/2
0
√
2/2
√
2/2
⎤
⎦
Tr(R45°,x) = 1 +
√
2
therefore,
α = arccos((1 +
√
2 −1)/2) = 45°.
So we now have a mechanism to extract the axis and angle of rotation from a
rotation matrix. However, the algorithm for identifying the axis is far from satisfac-
tory, and later on we will discover that there is a similar technique which is readily
programable.
For completeness, let’s identify the axis and angle of rotation for the matrix (9.6):
R90°,xR90°,yR90°,z =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦.
Once more, we begin by writing the characteristic equation for the matrix:

0 −λ
0
1
0
−1 −λ
0
1
0
0 −λ

= 0.
(9.8)
Expanding (9.8) using the top row we have
−λ

−1 −λ
0
0
−λ
 + 1

0
−1 −λ
1
0
 = 0
−λ
	
−λ + λ2
+ 1 −λ = 0
λ2 −λ3 + 1 −λ = 0
−λ3 + λ2 −λ + 1 = 0
λ3 −λ2 + λ = 1.
Again, there is a single real root: λ = 1, and substituting this in the original equations
associated with (9.8) to reveal the eigenvector, we have
⎧
⎨
⎩
−x + 0y + z = 0
0x −2y + 0z = 0
x + 0y −z = 0.
It is obvious from the 1st and 3rd equations that x = z, and from the 2nd equation
that y = 0, which implies that the associated eigenvector is of the form [k
0
k],
which is correct.

126
9
Rotation Transforms in Space
Using the trace operation, we can write
Tr(R90°,xR90°,yR90°,z) = −1
therefore,
β = arccos((−1 −1)/2) = 180°.
As promised, let’s explore another way of identifying the ﬁxed axis of rotation,
which is an eigenvector. Consider the following argument where A is a simple rota-
tion transform:
If v is a ﬁxed axis of rotation and A a rotation transform, then v suffers no rota-
tion:
Av = v
(9.9)
similarly,
ATv = v.
(9.10)
Subtracting (9.10) from (9.9), we have
Av −ATv = 0
(9.11)
	
A −AT
v = 0
(9.12)
where 0 is a null vector.
In Chap. 4 we deﬁned an antisymmetric matrix Q as
Q = 1
2
	
A −AT
(9.13)
therefore,
	
A −AT
= 2Q.
(9.14)
Substituting (9.14) in (9.12) we have
2Qv = 0
Qv = 0
which permits us to write
⎡
⎣
0
q3
−q2
−q3
0
q1
q2
−q1
0
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦=
⎡
⎣
0
0
0
⎤
⎦
(9.15)
where
q1 = a23 −a32
q2 = a31 −a13
q3 = a12 −a21.
Expanding (9.15) we have

9.3
Composite Rotations
127
0v1 + q3v2 −q2v3 = 0
−q3v1 + 0v2 + q1v3 = 0
q2v1 −q1v2 + 0v3 = 0.
Obviously, one possible solution is v1 = v2 = v3 = 0, but we seek a solution for v
in terms of q1,q2 and q3. A standard technique is to relax one of the v terms, such
as making v1 = 1. Then
q3v2 −q2v3 = 0
(9.16)
−q3 + q1v3 = 0
(9.17)
q2 −q1v2 = 0.
(9.18)
From (9.18) we have
v2 = q2
q1
.
From (9.17) we have
v3 = q3
q1
therefore, a solution is
v =
q1
q1
q2
q1
q3
q1
T
which in a non-homogeneous form is
v =

q1
q2
q3
T
or in terms of the original matrix:
v =

(a23 −a32)
(a31 −a13)
(a12 −a21)
T
(9.19)
which appears to be a rather elegant solution for ﬁnding the ﬁxed axis of revolution.
Now let’s put (9.19) to the test by recomputing the axis of rotation for the pure
rotations Rα,x,Rβ,y and Rγ,z where α = β = γ = 90°:
R90°,x =
⎡
⎣
1
0
0
0
0
−1
0
1
0
⎤
⎦
using (9.19) we have
v =

(−1 −1)
(0 −0)
(0 −0)

= [−2
0
0]T
which is the x-axis.
R90°,y =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦

128
9
Rotation Transforms in Space
using (9.19) we have
v =

(0 −0)
(−1 −1)
(0 −0)

= [0
−2
0]T
which is the y-axis.
R90°,z =
⎡
⎣
0
−1
0
1
0
0
0
0
1
⎤
⎦
using (9.19) we have
v =

(0 −0)
(0 −0)
(−1 −1)

= [0
0
−2]T
which is the z-axis.
However, if we attempt to extract the axis of rotation from
R90°,xR90°,yR90°,z =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
we have a problem, because q1 = q2 = q3 = 0. This is because A = AT and the
technique relies upon A ̸= AT.
So let’s consider another approach based upon the fact that a rotation matrix
always has a real eigenvalue λ = 1, which permits us to write
Av = λv
Av = λIv = Iv
(A −I)v = 0
therefore,
⎡
⎣
(a11 −1)
a12
a13
a21
(a22 −1)
a23
a31
a32
(a33 −1)
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦=
⎡
⎣
0
0
0
⎤
⎦.
(9.20)
Expanding (9.20) we have
(a11 −1)v1 + a12v2 + a13v3 = 0
a21v1 + (a22 −1)v2 + a23v3 = 0
a31v1 + a32v2 + (a33 −1)v3 = 0.
Once more, there exists a trivial solution where v1 = v2 = v3 = 0, but to discover
something more useful we can relax any one of the v terms which gives us three
equations in two unknowns. Let’s make v1 = 0:
a12v2 + a13v3 = −(a11 −1)
(9.21)
(a22 −1)v2 + a23v3 = −a21
(9.22)
a32v2 + (a33 −1)v3 = −a31.
(9.23)
We are now faced with choosing a pair of equations to isolate v2 and v3. In fact, we
have to consider all three pairings because it is possible that a future rotation matrix

9.3
Composite Rotations
129
will contain a column with two zero elements, which could conﬂict with any pairing
we make at this stage.
Let’s begin by choosing (9.21) and (9.22). The solution employs the following
strategy: Given the following matrix equation
a1
b1
a2
b2
x
y

=
c1
c2

then
x

c1
b1
c2
b2

=
y

a1
c1
a2
c2

=
1

a1
b1
a2
b2
.
Therefore, using the 1st and 2nd (9.21) and (9.22) we have
v2

−(a11 −1)
a13
−a21
a23

=
v3

a12
−(a11 −1)
(a22 −1)
−a21

=
1

a12
a13
(a22 −1)
a23

v1 = a12a23 −a13(a22 −1)
v2 = a13a21 −a23(a11 −1)
v3 = (a11 −1)(a22 −1) −a12a21.
Similarly, using the 1st and 3rd (9.21) and (9.23) we have
v1 = a12(a33 −1) −a13a32
v2 = a13a31 −(a11 −1)(a33 −1)
v3 = a32(a11 −1) −a12a31
and using the 2nd and 3rd (9.22) and (9.23) we have
v1 = (a22 −1)(a33 −1) −a23a32
v2 = a23a31 −a21(a33 −1)
v3 = a21a32 −a31(a22 −1).
Now we have nine equations to cope with any eventuality. In fact, there is nothing
to stop us from choosing any three that take our fancy, for example these three
equations look interesting and sound:
v1 = (a22 −1)(a33 −1) −a23a32
(9.24)
v2 = (a33 −1)(a11 −1) −a31a13
(9.25)
v3 = (a11 −1)(a22 −1) −a12a21.
(9.26)
Therefore, the solution for the eigenvector is [v1
v2
v3]T. Note that the sign of
v2 has been reversed to maintain symmetry.
Let’s test (9.24), (9.25) and (9.26) with the transforms used above:

130
9
Rotation Transforms in Space
R90°,x =
⎡
⎣
1
0
0
0
0
−1
0
1
0
⎤
⎦
⎧
⎨
⎩
v1 = (−1)(−1) −(−1) × 1 = 2
v2 = (−1)(0) −
0 × 0
= 0
v3 = (0)(−1) −
0 × 0
= 0
R90°,y =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎧
⎨
⎩
v1 = (0)(−1) −
0 × 0
= 0
v2 = (−1)(−1) −(−1) × 1 = 2
v3 = (−1)(0) −
0 × 0
= 0
R90°,z =
⎡
⎣
0
−1
0
1
0
0
0
0
1
⎤
⎦
⎧
⎨
⎩
v1 = (−1)(0) −
0 × 0
= 0
v2 = (0)(−1) −
0 × 0
= 0
v3 = (−1)(−1) −(−1) × 1 = 2
R90°,xR90°,yR90°,z =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎧
⎨
⎩
v1 = (−2)(−1) −
0 × 0
= 2
v2 = (−1)(−1) −
1 × 1
= 0
v3 = (−1)(−2) −0 × (−1) = 2
R90°,zR90°,yR90°,x =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎧
⎨
⎩
v1 = (0)(−1) −
0 × 0
= 0
v2 = (−1)(−1) −(−1) × 1 = 2
v3 = (−1)(0) −
0 × 0
= 0.
We can see why the resulting vectors have components of 2 by evaluating a normal
rotation transform:
Rα,x =
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
⎧
⎨
⎩
v1 = (cα −1)(cα −1) −(−sα) × (sα) = 2(1 −cα)
v2 =
(cα −1)(0)
−
0 × 0
=
0
v3 =
(0)(cα −1)
−
0 × 0
=
0.
We can see that when α = 90°, v1 = 2.
So far we have created three composite rotations comprising individual rota-
tions about the x-, y- and z-axes: Rα,xRβ,yRγ,z and Rγ,zRβ,yRα,x. But there is
nothing stopping us from creating other combinations such as Rα,xRβ,yRγ,x or
Rα,zRβ,yRγ,z that include two rotations about the same axis. In fact, there are twelve
possible combinations:
Rα,xRβ,yRγ,x,
Rα,xRβ,yRγ,z,
Rα,xRβ,zRγ,x,
Rα,xRβ,zRγ,y
Rα,yRβ,xRγ,y,
Rα,yRβ,xRγ,z,
Rα,yRβ,zRγ,x,
Rα,yRβ,zRγ,y
Rα,zRβ,xRγ,y,
Rα,zRβ,xRγ,z,
Rα,zRβ,yRγ,x,
Rα,zRβ,yRγ,z
which are covered in detail in Appendix A.
9.4 Gimbal Lock
There are two potential problems with all of the above composite transforms. The
ﬁrst is the difﬁculty visualising the orientation of an object subjected to several
rotations; the second is that they all suffer from what is called gimbal lock. From
a visualisation point of view, if we use the transform Rγ,zRβ,yRα,x to animate an
object and change γ , β and α over a period of frames, it can be very difﬁcult to
predict the ﬁnal movement and adjust the angles to achieve a desired effect. Gimbal

9.4
Gimbal Lock
131
Fig. 9.6 Three types of gimbal joints
lock, on the other hand, is a weakness associated with Euler rotations when certain
combinations of angles are used.
To understand this phenomenon, consider a simple gimbal which is a pivoted
support that permits rotation about an axis, as shown in Fig. 9.6 (a). If two gimbals
are combined, as shown in Fig. 9.6 (b), the inner cradle remains level with some ref-
erence plane as the assembly rolls and pitches. Such a combination has two degrees
of rotational freedom. By adding a third gimbal so that the entire structure is free to
rotate about a vertical axis, an extra degree of rotational freedom is introduced and
is often used for mounting a camera on a tripod, as shown in Fig. 9.6 (c).
A mechanical gimbal joint with three degrees of freedom is represented math-
ematically by a composite Euler rotation transform. For example, say we choose
R90°,yR90°,xR90°,z to rotate our unit cube as shown in Fig. 9.7 (a). The cube’s
faces containing vertices 1, 5, 7, 3 and 0, 2, 6, 4 are ﬁrst rotated about the perpen-
dicular z-axis, as shown in Fig. 9.7 (b). The second transform rotates the cube’s
faces containing vertices 0, 4, 5, 1 and 2, 3, 7, 6 about the perpendicular x-axis,
as shown in Fig. 9.7 (c). If we now attempt to rotate the cube about the y-axis,
as shown in Fig. 9.7 (d), the cube’s faces containing 0, 2, 6, 4 and 1, 5, 7, 3 are
rotated again. Effectively we have lost the ability to rotate a cube about one of its
axes, and such a condition is called gimbal lock. There is little we can do about this,
apart from use another composite transform, but it, too, will have a similar restric-
tion. For example, Appendix A shows that R90°,xR90°,zR90°,y, R90°,yR90°,zR90°,x,
R90°,zR90°,xR90°,y and R90°,zR90°,yR90°,x all possess a similar afﬂiction. Fortu-
nately, there are other ways of rotating an object, which we will explore later.

132
9
Rotation Transforms in Space
Fig. 9.7 An example of gimbal lock
9.5 Yaw, Pitch and Roll
The above Euler rotations are also known as yaw, pitch and roll, and great care
should be taken with these angles when referring to other books and technical pa-
pers. Sometimes a left-handed system of axes is used rather than a right-handed set,
and the vertical axis may be the y-axis or the z-axis, and might even point down-
wards. Consequently, the matrices representing the rotations can vary greatly. In
this text all Cartesian coordinate systems are right-handed, and the vertical axis is
always the y-axis.
The terms yaw, pitch and roll are often used in aviation and to describe the mo-
tion of ships. For example, if a ship or aeroplane is heading in a particular direction,
the axis aligned with the heading is the roll axis, as shown in Fig. 9.8 (a). A perpen-
dicular axis in the horizontal plane containing the heading axis is the pitch axis, as
shown in Fig. 9.8 (b). The axis perpendicular to both these axes is the yaw axis, as
shown in Fig. 9.8 (c).
Clearly, there are many ways of aligning a set of Cartesian axes with the yaw,
pitch and roll axes, and consequently, it is impossible to deﬁne an absolute set of
yaw, pitch and roll transforms. However, if we choose the following alignment:
• the roll axis is the z-axis
• the pitch axis is the x-axis
• the yaw axis is the y-axis
we have the situation as shown in Fig. 9.9, and the transforms representing these
rotations are as follows:

9.5
Yaw, Pitch and Roll
133
Fig. 9.8 Deﬁnitions of yaw, pitch and roll
Fig. 9.9 A convention for
roll, pitch and yaw angles
Rroll,z =
⎡
⎣
cosroll
−sinroll
0
sinroll
cosroll
0
0
0
1
⎤
⎦
Rpitch,x =
⎡
⎣
1
0
0
0
cospitch
−sinpitch
0
sinpitch
cospitch
⎤
⎦
Ryaw,y =
⎡
⎣
cosyaw
0
sinyaw
0
1
0
−sinyaw
0
cosyaw
⎤
⎦.

134
9
Rotation Transforms in Space
A common sequence for applying these rotations is roll, pitch, yaw, as seen in the
following transform:
⎡
⎣
x′
y′
z′
⎤
⎦= Ryaw,yRpitch,xRroll,z
⎡
⎣
x
y
z
⎤
⎦
and if a translation is involved,
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= Ttx,ty,tzRyaw,yRpitch,xRroll,z
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦.
9.6 Rotating a Point About an Arbitrary Axis
Now let’s examine two ways of rotating a point about an arbitrary axis. The ﬁrst
technique uses matrices and trigonometry and is rather laborious. The second ap-
proach employs vector analysis and is quite succinct. Fortunately, they both arrive
at the same result!
9.6.1 Matrices
We begin by deﬁning an axis using a unit vector ˆn about which a point P is rotated
α to P ′ as shown in Fig. 9.10. And as we only have access to matrices that rotate
points about the Cartesian axes, this unit vector has to be temporarily aligned with a
Cartesian axis. In the following example we choose the x-axis. During the alignment
process, the point P is subjected to the transforms necessary to align the unit vector
with the x-axis. We then rotate P , α about the x-axis. To complete the operation, the
rotated point is subjected to the transforms that return the unit vector to its original
position. Although matrices provide a powerful tool for undertaking this sort of
Fig. 9.10 The geometry
associated with rotating a
point about an arbitrary axis

9.6
Rotating a Point About an Arbitrary Axis
135
work, it is nevertheless extremely tedious, but is a good exercise for improving one’s
algebraic skills!
Figure 9.10 shows a point P(x,y,z) to be rotated through an angle α to
P ′(x′,y′,z′) about an axis deﬁned by
ˆn = ai + bj + ck.
The transforms to achieve this operation can be expressed as follows:
⎡
⎣
x′
y′
z′
⎤
⎦= R−φ,yRθ,zRα,xR−θ,zRφ,y
⎡
⎣
x
y
z
⎤
⎦
which aligns the axis of rotation with the x-axis, performs the rotation of P through
an angle α about the x-axis, and returns the axis of rotation back to its original
position. Therefore,
Rφ,y =
⎡
⎣
cosφ
0
sinφ
0
1
0
−sinφ
0
cosφ
⎤
⎦,
R−θ,z =
⎡
⎣
cosθ
sinθ
0
−sinθ
cosθ
0
0
0
1
⎤
⎦
Rα,x =
⎡
⎣
1
0
0
0
cosα
−sinα
0
sinα
cosα
⎤
⎦,
Rθ,z =
⎡
⎣
cosθ
−sinθ
0
sinθ
cosθ
0
0
0
1
⎤
⎦
R−φ,y =
⎡
⎣
cosφ
0
−sinφ
0
1
0
sinφ
0
cosφ
⎤
⎦.
Let
R−φ,yRθ,zRα,xR−θ,zRφ,y =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦
where by multiplying the matrices together we ﬁnd that:
a11 = cos2 φ cos2 θ + cos2 φ sin2 θ cosα + sin2 φ cosα
a12 = cosφ cosθ sinθ −cosφ sinθ cosθ cosα −sinφ cosθ sinα
a13 = cosφ sinφ cos2 θ + cosφ sinφ sin2 θ cosα + sin2 φ sinθ sinα
+ cos2 φ sinθ sinα −cosφ sinφ cosα
a21 = sinθ cosθ cosφ −cosθ sinθ cosφ cosα + cosθ sinφ sinα
a22 = sin2 θ + cos2 θ cosα
a23 = sinθ cosθ sinφ −cosθ sinθ sinφ cosα −cosθ cosφ sinα
a31 = cosφ sinφ cos2 θ + cosφ sinφ sin2 θ cosα −cos2 φ sinθ sinα
−cosφ sinφ cosα
a32 = sinφ cosθ sinθ −sinφ sinθ cosθ cosα + cosφ cosθ sinα
a33 = sin2 φ cos2 θ + sin2 φ sin2 θ cosα −cosφ sinφ sinθ sinα
+ cosφ sinφ sinθ sinα + cos2 φ cosα.

136
9
Rotation Transforms in Space
From Fig. 9.10 we compute the sin and cos of θ and φ in terms of a, b and c, and
then compute their equivalent sin2 and cos2 values:
cosθ =

1 −b2
⇒
cos2 θ = 1 −b2
sinθ = b
⇒
sin2 θ = b2
cosφ = a/

1 −b2
⇒
cos2 φ = a2/
	
1 −b2
sinφ = c/

1 −b2
⇒
sin2 φ = c2/
	
1 −b2
.
To ﬁnd a11:
a11 = cos2 φ cos2 θ + cos2 φ sin2 θ cosα + sin2 φ cosα
= a2 + a2b2
1 −b2 cosα +
c2
1 −b2 cosα
= a2 +
c2 + a2b2
1 −b2

cosα
but
a2 + b2 + c2 = 1
⇒
c2 = 1 −a2 −b2
a11 = a2 +
1 −a2 −b2 + a2b2
1 −b2

cosα
= a2 +
(1 −a2)(1 −b2)
1 −b2

cosα
= a2(1 −cosα) + cosα.
Let
K = 1 −cosα
then
a11 = a2K + cosα.
To ﬁnd a12:
a12 = cosφ cosθ sinθ −cosφ sinθ cosθ cosα −sinφ cosθ sinα
=
a
√
1 −b2

1 −b2b −
a
√
1 −b2 b

1 −b2 cosα −
c
√
1 −b2

1 −b2 sinα
= ab −ab cosα −c sinα
= ab(1 −cosα) −c sinα
a12 = abK −c sinα.

9.6
Rotating a Point About an Arbitrary Axis
137
To ﬁnd a13:
a13 = cosφ sinφ cos2 θ + cosφ sinφ sin2 θ cosα + sin2 φ sinθ sinα
+ cos2 φ sinθ sinα −cosφ sinφ cosα
= cosφ sinφ cos2 θ + cosφ sinφ sin2 θ cosα + sinθ sinα −cosφ sinφ cosα
=
a
√
1 −b2
c
√
1 −b2
	
1 −b2
+
a
√
1 −b2
c
√
1 −b2 b2 cosα + b sinα
−
a
√
1 −b2
c
√
1 −b2 cosα
= ac + ac
b2
(1 −b2) cosα + b sinα −
ac
(1 −b2) cosα
= ac + ac(b2 −1)
(1 −b2) cosα + b sinα
= ac(1 −cosα) + b sinα
a13 = acK + b sinα.
Using similar algebraic methods, we discover that:
a21 = abK + c sinα
a22 = b2K + cosα
a23 = bcK −a sinα
a31 = acK −b sinα
a32 = bcK + a sinα
a33 = c2K + cosα
and our original matrix transform becomes:
⎡
⎢⎣
x′
p
y′
p
z′
p
⎤
⎥⎦=
⎡
⎣
a2K + cosα
abK −c sinα
acK + b sinα
abK + c sinα
b2K + cosα
bcK −a sinα
acK −b sinα
bcK + a sinα
c2K + cosα
⎤
⎦
⎡
⎣
xp
yp
zp
⎤
⎦
where
K = 1 −cosα.
9.6.2 Vectors
Now let’s solve the same problem using vectors. Figure 9.11 shows a view of the
geometry associated with the task at hand. For clariﬁcation, Fig. 9.12 shows a cross-
section and a plan view of the geometry.
The axis of rotation is given by the unit vector:
ˆn = ai + bj + ck.

138
9
Rotation Transforms in Space
Fig. 9.11 A view of the
geometry associated with
rotating a point about an
arbitrary axis
Fig. 9.12 A cross-section
and plan view of the
geometry associated with
rotating a point about an
arbitrary axis
• P(xp,ypzp) is the point to be rotated by angle α to P ′(x′
p,y′
p, z′
p).
• O is the origin, whilst p and p′ are position vectors for P and P ′ respectively.
From Fig. 9.11 and Fig. 9.12:
p′ = −−→
ON + −−→
NQ + −−→
QP ′.
To ﬁnd −−→
ON:
|n| = |p|cosθ = ˆn · p
therefore,
−−→
ON = n = ˆn(ˆn · p).
To ﬁnd −−→
NQ:
−−→
NQ = NQ
NP r = NQ
NP ′ r = cosα r
but
p = n + r = ˆn(ˆn · p) + r
therefore,
r = p −ˆn(ˆn · p)

9.6
Rotating a Point About an Arbitrary Axis
139
and
−−→
NQ =
	
p −ˆn(ˆn · p)

cosα.
To ﬁnd −−→
QP ′:
Let
ˆn × p = w
where
|w| = |ˆn| · |p|sinθ = |p|sinθ
but
|r| = |p|sinθ
therefore,
|w| = |r|.
Now
QP ′
NP ′ = QP ′
|r| = QP ′
|w| = sinα
therefore,
−−→
QP ′ = wsinα = ˆn × psinα
then
p′ = ˆn(ˆn · p) +
	
p −ˆn(ˆn · p)

cosα + ˆn × psinα
and
p′ = pcosα + ˆn(ˆn · p)(1 −cosα) + ˆn × psinα.
This is known as the Rodrigues rotation formula, as it was developed by the French
mathematician, Olinde Rodrigues (1795–1851), who had also invented the ideas be-
hind quaternions before Hamilton. This has been documented by Simon Altmann in
the Mathematics Magazine under the title “Hamilton, Rodrigues and the quaternion
scandal” [7].
If we let
K = 1 −cosα
then
p′ = pcosα + ˆn(ˆn · p)K + ˆn × psinα
= (xpi + ypj + zpk)cosα + (ai + bj + ck)(axp + byp + czp)K
+
	
(bzp −cyp)i + (cxp −azp)j + (ayp −bxp)k

sinα
=
	
xp cosα + a(axp + byp + czp)K + (bzp −cyp)sinα

i
+
	
yp cosα + b(axp + byp + czp)K + (cxp −azp)sinα

j

140
9
Rotation Transforms in Space
+
	
zp cosα + c(axp + byp + czp)K + (ayp −bxp)sinα

k
=
	
xp(a2K + cosα) + yp(abK −c sinα) + zp(acK + b sinα)

i
+
	
xp(abK + c sinα) + yp
	
b2K + cosα

+ zp(bcK −a sinα)

j
+
	
xp(acK −b sinα) + yp(bcK + a sinα) + zp
	
c2K + cosα


k
and the transform is:
⎡
⎣
x′
p
y′
p
z′
p
⎤
⎦=
⎡
⎣
a2K + cosα
abK −c sinα
acK + b sinα
abK + c sinα
b2K + cosα
bcK −a sinα
acK −b sinα
bcK + a sinα
c2K + cosα
⎤
⎦
⎡
⎣
xp
yp
zp
⎤
⎦
which is identical to the transform derived using matrices.
Now let’s test the transform with a simple example that can be easily veriﬁed. If
we rotate the point P(10,0,0), 180° about an axis deﬁned by n = i + j, it should
end up at P ′(0,10,0).
Therefore
α = 180°,
cosα = −1,
sinα = 0,
K = 2
a =
√
2
2 ,
b =
√
2
2 ,
c = 0
and
⎡
⎣
0
10
0
⎤
⎦=
⎡
⎣
0
1
0
1
0
0
0
0
0
⎤
⎦
⎡
⎣
10
0
0
⎤
⎦
which is correct.
9.7 Summary
In this chapter we have seen how the 2 × 2 matrix for rotating a point in the plane
is developed for rotating points in space. In its simplest form, the rotations are re-
stricted to one of the three Cartesian axes, but by employing homogeneous coor-
dinates, the translation transform can be used to rotate points about an off-set axis
parallel with one of the Cartesian axes.
Composite Euler rotations are created by combining the matrices representing the
individual rotations about three successive axes, for which there are twelve combi-
nations. Unfortunately, one of the problems with such transforms is that they suffer
from gimbal lock, where one degree of freedom is lost under certain angle com-
binations. Another problem, is that it is difﬁcult to predict how a point moves in
space when animated by a composite transform, although they are widely used for
positioning objects in world space.
We have also seen how to compute the eigenvector associated with a rotation
transform, and how it represents the axis about which rotation occurs, and the eigen-
value represents the angle of rotation.
Finally, matrices and vectors were used to develop a transform for rotating a point
about an arbitrary axis.

9.7
Summary
141
9.7.1 Summary of Matrix Transforms
Translate a point
Ttx,ty,tz =
⎡
⎢⎢⎣
1
0
0
tx
0
1
0
ty
0
0
1
tz
0
0
0
1
⎤
⎥⎥⎦.
Rotate a point about the x-, y-, z-axes
Rβ,x =
⎡
⎢⎢⎣
1
0
0
0
0
cosβ
−sinβ
0
0
sinβ
cosβ
0
0
0
0
1
⎤
⎥⎥⎦
Rβ,y =
⎡
⎢⎢⎣
cosβ
0
sinβ
0
0
1
0
0
−sinβ
0
cosβ
0
0
0
0
1
⎤
⎥⎥⎦
Rβ,z =
⎡
⎢⎢⎣
cosβ
−sinβ
0
0
sinβ
cosβ
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Rotate a point about off-set x-, y-, z-axes
T0,ty,tzRβ,xT0,−ty,−tz =
⎡
⎢⎢⎣
1
0
0
0
0
cosβ
−sinβ
ty(1 −cosβ) + tz sinβ
0
sinβ
cosβ
tz(1 −cosβ) −ty sinβ
0
0
0
1
⎤
⎥⎥⎦
Ttx,0,tzRβ,yT−tx,0,−tz =
⎡
⎢⎢⎣
cosβ
0
sinβ
tx(1 −cosβ) −tz sinβ
0
1
0
0
−sinβ
0
cosβ
tz(1 −cosβ) + tx sinβ
0
0
0
1
⎤
⎥⎥⎦
Ttx,ty,0Rβ,zT−tx,−ty,0 =
⎡
⎢⎢⎣
cosβ
−sinβ
0
tx(1 −cosβ) + ty sinβ
sinβ
cosβ
0
ty(1 −cosβ) −tx sinβ
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Rotate a point about an arbitrary axis
p′ = pcosα + ˆn(ˆn · p)(1 −cosα) + ˆn × psinα
Rα,ˆn =
⎡
⎣
a2K + cosα
abK −c sinα
acK + b sinα
abK + c sinα
b2K + cosα
bcK −a sinα
acK −b sinα
bcK + a sinα
c2K + cosα
⎤
⎦
K = 1 −cosα
ˆn = ai + bj + ck.

142
9
Rotation Transforms in Space
Extracting the angle and axis of rotation from a transform
Rα,v =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦
α = arccos((Tr(Rα,v) −1)/2)
v = v1i + v2j + v3k
v1 = (a22 −1)(a33 −1) −a23a32
v2 = (a33 −1)(a11 −1) −a31a13
v3 = (a11 −1)(a22 −1) −a12a21.

Chapter 10
Frames of Reference in Space
10.1 Introduction
In Chap. 8 we discovered how to compute the coordinates of a point in a frame of
reference in the plane. In this chapter we study the same problem but in 3D space.
Again, we employ many of the concepts previously described in order to develop
the transforms for translating and rotating frames in space.
The relativity of motion, previously discussed, implies that we cannot absolutely
claim that one frame of reference is stationary whilst another is in motion – it is sim-
ply a question of interpretation and convenience. Fortunately, a matrix transform can
be used to support moving points and moving frames, which means that the trans-
form used for rotating a point in a ﬁxed frame of reference, can be used for rotating
the frame of reference in the opposite direction, whilst keeping the point ﬁxed.
In a 3D space context, this implies that the rotation transform Rα,x, which rotates
a point α about the ﬁxed x-axis, can be used to rotate the frame of reference −α
about the x-axis, whilst the point remains ﬁxed. Similarly, the rotation transform
R−α,x, which rotates a point −α about the ﬁxed x-axis, can also be used to rotate
the frame of reference α about the x-axis, whilst the point remains ﬁxed.
We employ a simple notation to distinguish transforms that rotate points from
those that rotate frames. For example, Rα,x rotates a point α about the x-axis,
whilst R−1
α,x rotates a frame α about the x-axis. Similarly, R−α,x rotates a point −α
about the x-axis, whilst R−1
−α,x rotates a frame −α about the x-axis. Also, Ttx,ty,tz
translates a point (tx,ty,tz), whilst T−1
tx,ty,tz translates a frame (tx,ty,tz). Similarly,
T−tx,−ty,−tz translates a point (−tx,−ty,−tz), whilst T−1
−tx,−ty,−tz translates a frame
(−tx,−ty,−tz).
10.2 Frames of Reference
We have already discussed frames of reference in Chap. 8, and even though the
frames were 2D, the same ideas can be generalised to 3D space without having to
introduce any new concepts – we simply add an extra z-coordinate.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_10, © Springer-Verlag London Limited 2011
143

144
10
Frames of Reference in Space
Fig. 10.1 The point P is
translated by (tx,ty,tz) with a
ﬁxed frame
10.3 Matrix Transforms
In general, if points in the frame X′Y ′Z′ are related to points in the frame XYZ by
the transform A using
P = AP ′,
then a point P in XYZ has coordinates in X′Y ′Z′ using
P ′ = A−1P.
In computer graphics most frame of reference transforms involve a translation or
a rotation, or a combination of both. We now explore these different scenarios and
develop transforms for converting coordinates in the original frame of reference to
another frame.
10.3.1 Translated Frames of Reference
Figure 10.1 shows a point P translated by (tx,ty,tz) to P ′ using the transform
Ttx,ty,tz
Ttx,ty,tz =
⎡
⎢⎢⎣
1
0
0
tx
0
1
0
ty
0
0
1
tz
0
0
0
1
⎤
⎥⎥⎦
where the translated point P ′ is given by
P ′ = Ttx,ty,tzP.
Thus the coordinates of P are updated relative to the ﬁxed frame of reference XYZ.
However, there is a second interpretation for Ttx,ty,tz, where P remains ﬁxed and
the frame of reference XYZ is translated by (−tx,−ty,−tz), as shown in Fig. 10.2.
Consequently, the point P(x,y,z) in XYZ has coordinates P ′(x′,y′,z′) in X′Y ′Z′
given by
P ′ = T−1
−tx,−ty,−tzP.

10.3
Matrix Transforms
145
Fig. 10.2 The point P
remains ﬁxed whilst the
frame XYZ is translated
(−tx,−ty,−tz)
For example, the origin of XYZ becomes (tx,ty,tz) in X′Y ′Z′:
⎡
⎢⎢⎣
tx
ty
tz
1
⎤
⎥⎥⎦=
⎡
⎢⎢⎣
1
0
0
tx
0
1
0
ty
0
0
1
tz
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
0
0
0
1
⎤
⎥⎥⎦.
Therefore, the transform for translating a frame by (tx,ty,tz) is
T−1
tx,ty,tz =
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦.
Now we consider rotated frames of reference in space.
10.3.2 Rotated Frames of Reference About Cartesian Axes
A 2D frame of reference can only be rotated within its plane, whereas a 3D frame
can be rotated about any axis, whether it be a Cartesian axis or some arbitrary axis.
Let’s look at how Rα,x behaves when rotating frames about the x-axis, and apply
the results to the other axes.
We know that we can rotate a point, α about the x-axis using
Rα,x =
⎡
⎣
1
0
0
0
cosα
−sinα
0
sinα
cosα
⎤
⎦.
However, Rα,x can also be used to rotate a frame −α about the x-axis. Similarly,
R−1
α,x rotates a frame α about the same axis. Therefore, in general, we can use the
same technique for all three Cartesian axes.
Figure 10.3 (a) and (b) show our unit cube rotated by −90° about the x-axis,
whilst (c) and (d) show the frame rotated 90° about the same axis, with the cube
ﬁxed.

146
10
Frames of Reference in Space
Fig. 10.3 (a) and (b) The cube is rotated −90°. (c) and (d) The XYZ frame is rotated 90°
The transform for R−1
90°,x is
R−1
90°,x = R−90°,x =
⎡
⎣
1
0
0
0
0
1
0
−1
0
⎤
⎦
which when used on the cube’s coordinates create
⎡
⎣
1
0
0
0
0
1
0
−1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
1
1
1
1
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
⎤
⎦
which are conﬁrmed by Fig. 10.3 (d).
In summary, the transforms for rotating frames α about the x-, y- and z-axes are:
R−1
α,x =
⎡
⎣
1
0
0
0
cosα
sinα
0
−sinα
cosα
⎤
⎦
R−1
α,y =
⎡
⎣
cosα
0
−sinα
0
1
0
sinα
0
cosα
⎤
⎦

10.3
Matrix Transforms
147
Fig. 10.4 (a) and (b) The off-set axis and rotated frame. (c) and (d) The unit cube and rotated
frame
R−1
α,z =
⎡
⎣
cosα
sinα
0
−sinα
cosα
0
0
0
1
⎤
⎦.
10.3.3 Rotated Frames About Off-Set Axes
In Chap. 9 we developed three transforms for rotating a point about an off-set axis
parallel with one of the three Cartesian axes. Let’s develop three complementary
transforms for rotating a frame about the same off-set axes.
To ensure that we compute the correct transform, we must be very clear in our
own minds what we are attempting to do. The objective is to identify an off-set axis
parallel with the z-axis, for example, in the current XYZ frame of reference, about
which a frame is rotated. The ﬁrst step, then, is to translate the frame, and then
rotate it.
Let’s assume that the axis passes through the point (tx,ty,0), as shown in
Fig. 10.4 (a). Therefore, given the following deﬁnitions for T−1
tx,ty,0 and R−1
α,z
T−1
tx,ty,0 =
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦

148
10
Frames of Reference in Space
R−1
α,z =
⎡
⎢⎢⎣
cosα
sinα
0
0
−sinα
cosα
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
R−1
α,zT−1
tx,ty,0 =
⎡
⎢⎢⎣
cosα
sinα
0
−tx cosα −ty sinα
−sinα
cosα
0
−ty cosα + tx sinα
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Let’s test this transform by making α = 90°, and tx = ty = 1, as shown in
Fig. 10.4 (b):
R−1
90°,zT−1
1,1,0 =
⎡
⎢⎢⎣
0
1
0
−1
−1
0
0
1
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
which, if used on the unit cube shown in Fig. 10.4 (c), produces
⎡
⎢⎢⎣
0
1
0
−1
−1
0
0
1
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦
=
⎡
⎢⎢⎣
−1
−1
0
0
−1
−1
0
0
1
1
1
1
0
0
0
0
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦
as conﬁrmed by Fig. 10.4 (d).
Let’s explore what happens if we swap the rotation and translation transforms to
T−1
tx,ty,0R−1
α,z. This now implies that the frame of reference is rotated α about the z-
axis, and then translated (tx,ty,0) in the rotated frame’s space, which is not what we
had planned. Here are the three transforms for rotating a frame of reference about
an off-set axis:
R−1
α,xT−1
0,ty,tz =
⎡
⎢⎢⎣
1
0
0
0
0
cosα
sinα
−ty cosα −tz sinα
0
−sinα
cosα
−tz cosα + ty sinα
0
0
0
1
⎤
⎥⎥⎦
R−1
α,yT−1
tx,0,tz =
⎡
⎢⎢⎣
cosα
0
−sinα
−tx cosα + tz sinα
0
1
0
0
sinα
0
cosα
−tz cosα −tx sinα
0
0
0
1
⎤
⎥⎥⎦
R−1
α,zT−1
tx,ty,0 =
⎡
⎢⎢⎣
cosα
sinα
0
−tx cosα −ty sinα
−sinα
cosα
0
−ty cosα + tx sinα
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.

10.4
Composite Rotations
149
10.4 Composite Rotations
In Chap. 9 we went into some detail describing how point rotation transforms can be
combined into composite rotations about the three Cartesian axes. There are twelve
possible combinations that are listed in Appendix A. As any rotation transform can
be used to rotate a point in one direction, or a frame of reference in the opposite
direction, the previously computed composite transforms for rotating points, can be
used for rotating frames in the opposite direction.
For example, we previously computed Rγ,zRβ,yRα,x:
Rγ,zRβ,yRα,x =
⎡
⎣
cγ cβ
cγ sβsα −sγ cα
cγ sβcα + sγ sα
sγ cβ
sγ sβsα + cγ cα
sγ sβcα −cγ sα
−sβ
cβsα
cβcα
⎤
⎦
which rotates a point about a ﬁxed frame of reference. But it can also be used to
rotate a frame of reference in the opposite directions:
R−1
−γ,zR−1
−β,yR−1
−α,x =
⎡
⎣
cγ cβ
cγ sβsα −sγ cα
cγ sβcα + sγ sα
sγ cβ
sγ sβsα + cγ cα
sγ sβcα −cγ sα
−sβ
cβsα
cβcα
⎤
⎦.
In order to compute R−1
γ,zR−1
β,yR−1
α,x we only have to reverse the sign of the sine terms
in the transform for Rγ,zRβ,yRα,x:
R−1
γ,zR−1
β,yR−1
α,x =
⎡
⎣
cγ cβ
cγ sβsα + sγ cα
−cγ sβcα + sγ sα
−sγ cβ
−sγ sβsα + cγ cα
sγ sβcα + cγ sα
sβ
−cβsα
cβcα
⎤
⎦. (10.1)
Let’s test (10.1) by making α = β = γ = 90°:
R−1
90°,zR−1
90°,yR−1
90°,x =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦.
Figure 10.5 (a) shows the initial scenario, Fig. 10.5 (b) shows the frame rotated 90°
about the local x-axis, Fig. 10.5 (c) shows the frame rotated 90° about the local
y-axis, and Fig. 10.5 (d) shows the frame rotated 90° about the local z-axis. If we
subject the coordinates of the unit cube to this composite transform we have
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦
which are conﬁrmed by Fig. 10.5 (d).

150
10
Frames of Reference in Space
Fig. 10.5 (a) The original frame. (b) Rotated frame about the x-axis. (c) Rotated frame about the
y-axis. (d) Rotated frame about the z-axis
Note that this speciﬁc transform also suffers from gimbal lock, where it is impos-
sible to rotate the cube through an axis passing through vertices 0 and 2. Whereas,
the cube is rotated twice about the axis passing through vertices 0 and 4. Effec-
tively, the axial system has been rotated 180° about the vector [1 0 1]T, which could
be conﬁrmed by calculating the eigenvalue and eigenvector.
10.5 Rotated and Translated Frames of Reference
One of the most important frame changing transforms in cgi enables us to view an
object from any location in space. The transform uses a rotation, which is often a
composite transform, for example R−1
γ,zR−1
β,yR−1
α,x, and a translation T−1
tx,ty,tz. And as
the position of the translated frame is normally speciﬁed in the original frame, we
begin by translating the frame followed by the rotation:
⎡
⎢⎢⎣
cγ cβ
cγ sβsα + sγ cα
−cγ sβcα + sγ sα
0
−sγ cβ
−sγ sβsα + cγ cα
sγ sβcα + cγ sα
0
sβ
−cβsα
cβcα
0
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦. (10.2)
It is not worth multiplying these matrices together as it creates too many terms.
However, we can test it with a simple example.

10.5
Rotated and Translated Frames of Reference
151
Fig. 10.6 (a) The translated frame. (b) The rotated frame about the y-axis
Using the unit cube, let’s position the new frame 2 units along the initial x-axis,
and then rotate the frame 270° about its local y-axis so that its z-axis is looking
back towards the original origin. Figure 10.6 (a) shows the translated frame, and
Fig. 10.6 (b) shows the rotated frame. Thus tx = 2, ty = tz = 0, α = 0°, β = 270°
and γ = 0°. Substituting these values in (10.2) we have
R−1
0°,zR−1
270°,yR−1
0°,xT−1
2,0,0 =
⎡
⎢⎢⎣
0
0
1
0
0
1
0
0
−1
0
0
0
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
1
0
0
−2
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
(10.3)
=
⎡
⎢⎢⎣
0
0
1
0
0
1
0
0
−1
0
0
2
0
0
0
1
⎤
⎥⎥⎦.
(10.4)
Using (10.4) to process the coordinates of the unit cube we have
⎡
⎢⎢⎣
0
0
1
0
0
1
0
0
−1
0
0
2
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦
=
⎡
⎢⎢⎣
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
2
2
2
2
1
1
1
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦
which are conﬁrmed by Fig. 10.6 (b).
To obtain a perspective view of the cube we simply divide its transformed x- and
y-coordinates by the associated z-coordinate:
⎡
⎢⎢⎣
0
0.5
0
0.5
0
1
0
1
0
0
0.5
0.5
0
0
1
1
2
2
2
2
1
1
1
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦

152
10
Frames of Reference in Space
Fig. 10.7 Perspective view
of the unit cube
and as the x-axis of the display screen is in the opposite direction to that of the
frame, we have to switch the sign of the x-coordinates:
⎡
⎢⎢⎣
0
−0.5
0
−0.5
0
−1
0
−1
0
0
0.5
0.5
0
0
1
1
2
2
2
2
1
1
1
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦.
The x- and y-coordinates are used in Fig. 10.7 to show the perspective view seen
from this translated, rotated frame.
10.6 Rotated Frames of Reference About Arbitrary Axes
In Chap. 9 we developed the following transform to rotate a point α about an arbi-
trary axis ˆn:
Rα,ˆn =
⎡
⎣
a2K + cosα
abK −c sinα
acK + b sinα
abK + c sinα
b2K + cosα
bcK −a sinα
acK −b sinα
bcK + a sinα
c2K + cosα
⎤
⎦
K = 1 −cosα
ˆn = ai + bj + ck.
Therefore, there is nothing to stop us using the same transform to rotate a frame −α
about ˆn, or its inverse R−1
α,ˆn to rotate a frame α about ˆn. To compute the latter, we
simply transpose the matrix, or change the sign of α which implies reversing the
sign of the sine terms:
R−1
α,ˆn =
⎡
⎣
a2K + cosα
abK + c sinα
acK −b sinα
abK −c sinα
b2K + cosα
bcK + a sinα
acK + b sinα
bcK −a sinα
c2K + cosα
⎤
⎦.
(10.5)
Let’s test (10.5) using the previous example where we rotated a frame 270° about
the y-axis, which makes α = 270°, ˆn = j and K = 1:
R−1
270°,j =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦

10.7
Summary
153
which agrees perfectly. Naturally, this can be combined with a translation transform
using
R−1
α,ˆnT−1
tx,ty,tz =
⎡
⎢⎢⎣
a2K + cosα
abK + c sinα
acK −b sinα
0
abK −c sinα
b2K + cosα
bcK + a sinα
0
acK + b sinα
bcK −a sinα
c2K + cosα
0
0
0
0
1
⎤
⎥⎥⎦
×
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦.
10.7 Summary
Hopefully, this chapter has covered most of the scenarios involving rotated and
translated frames of reference in 3D space. Although composite rotation transforms
offer a powerful mechanism for creating complex rotations, they are difﬁcult to
visualise and suffer from gimbal lock. Perhaps, the most useful transform is for ro-
tating a frame about an arbitrary axis. For completeness, the important transforms
are summarised below.
10.7.1 Summary of Transforms
Translating a frame
T−1
tx,ty,tz =
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦.
Rotating a frame about a Cartesian axis
R−1
α,x =
⎡
⎣
1
0
0
0
cosα
sinα
0
−sinα
cosα
⎤
⎦
R−1
α,y =
⎡
⎣
cosα
0
−sinα
0
1
0
sinα
0
cosα
⎤
⎦
R−1
α,z =
⎡
⎣
cosα
sinα
0
−sinα
cosα
0
0
0
1
⎤
⎦.

154
10
Frames of Reference in Space
Rotating a frame about an off-set axis
R−1
α,xT−1
0,ty,tz =
⎡
⎢⎢⎣
1
0
0
0
0
cosα
sinα
−ty cosα −tz sinα
0
−sinα
cosα
−tz cosα + ty sinα
0
0
0
1
⎤
⎥⎥⎦
R−1
α,yT−1
tx,0,tz =
⎡
⎢⎢⎣
cosα
0
−sinα
−tx cosα + tz sinα
0
1
0
0
sinα
0
cosα
−tz cosα −tx sinα
0
0
0
1
⎤
⎥⎥⎦
R−1
α,zT−1
tx,ty,0 =
⎡
⎢⎢⎣
cosα
sinα
0
−tx cosα −ty sinα
−sinα
cosα
0
−ty cosα + tx sinα
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Rotating a frame using a composite transform
R−1
γ,zR−1
β,yR−1
α,x =
⎡
⎣
cγ cβ
cγ sβsα + sγ cα
−cγ sβcα + sγ sα
−sγ cβ
−sγ sβsα + cγ cα
sγ sβcα + cγ sα
sβ
−cβsα
cβcα
⎤
⎦.
Rotating and translating a frame
R−1
γ,zR−1
β,yR−1
α,xT−1
tx,ty,tz =
⎡
⎢⎢⎣
cγ cβ
cγ sβsα + sγ cα
−cγ sβcα + sγ sα
0
−sγ cβ
−sγ sβsα + cγ cα
sγ sβcα + cγ sα
0
sβ
−cβsα
cβcα
0
0
0
0
1
⎤
⎥⎥⎦
×
⎡
⎢⎢⎣
1
0
0
−tx
0
1
0
−ty
0
0
1
−tz
0
0
0
1
⎤
⎥⎥⎦.
Rotating a frame about an arbitrary axis
R−1
α,ˆn =
⎡
⎣
a2K + cosα
abK + c sinα
acK −b sinα
abK −c sinα
b2K + cosα
bcK + a sinα
acK + b sinα
bcK −a sinα
c2K + cosα
⎤
⎦
K = 1 −cosα
ˆn = ai + bj + ck.

Chapter 11
Quaternion Transforms in Space
11.1 Introduction
Quaternions were introduced in Chap. 5 as a mathematical object that combines a
scalar with a vector, in the same way a complex number combines a scalar with an
imaginary quantity. Quaternions, like complex numbers, possess rotational qualities,
but work in four dimensions rather than on the complex plane.
Hamilton invented quaternions in October 1843, and by December of the same
year his friend, John T. Graves, had invented octonions. Arthur Cayley had also
been intrigued by Hamilton’s quaternions, and independently discovered octonions
in 1845.
There are four such composition algebras: real R, complex C, quaternion H,
and octonion O that obey an n-square identity used to compute their magnitudes.
Adolf Hurwitz (1859–1919) proved that the product of the sum of n squares by
the sum of n squares is the sum of n squares only when n is equal to 1, 2, 4 and
8, which are represented by reals, complex, quaternions and octonions. No other
system is possible, which shows how important quaternions are within the realm of
mathematics. Appendix C provides further information on this topic.
In this chapter we investigate how quaternions are used to rotate 3D vectors about
an arbitrary axis.
11.2 Deﬁnition
A quaternion q is the union of a scalar and a vector:
q = s + v
where s is a scalar and v is a 3D vector. If we express the vector v in terms of its
components, we have
q = s + xi + yj + zk
where s,x,y and z are all real numbers.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_11, © Springer-Verlag London Limited 2011
155

156
11
Quaternion Transforms in Space
Fig. 11.1 Three orthogonal
vectors u, ˆv and ˆv × u
Hamilton had hoped that a quaternion could be used like a complex rotor, where
we saw in Chap. 2 that
Rθ = cosθ + i sinθ
rotates a complex number by θ. Could the product of a quaternion q and a vector u
rotate u about the quaternion’s vector? Well yes, but only in a restricted sense. To
understand this, consider the scenario where we form the product of a unit quater-
nion q and a pure quaternion p. The unit quaternion q is deﬁned as
q = s + λˆv
where
s2 + λ2 = 1
and the pure quaternion p encodes the vector u with a zero scalar term
p = 0 + u.
In Chap. 5 we computed product qp, which in this context is
qp = (s + λˆv)(0 + u)
= −λˆv · u + su + λˆv × u.
However, if ˆv is orthogonal to u, the dot product term −λˆv · u vanishes, and we are
left with
qp = su + λˆv × u.
Figure 11.1 illustrates this scenario, where u is perpendicular to ˆv, and ˆv × u is
perpendicular to the plane containing u and ˆv.
Now because ˆv is a unit vector, the length of ˆv × u is |u|, which means that we
have two orthogonal vectors, i.e. u and ˆv × u, with the same length. Therefore, to
rotate u about ˆv, all that we have to do is to substitute cosθ for s and sinθ for λ:
qp = cosθu + sinθ ˆv × u.
For example, if we create a quaternion whose vector is aligned with the z-axis as
shown in Fig. 11.2 with
q = cosθ + sinθk

11.2
Deﬁnition
157
Fig. 11.2 The vector 2i is
rotated 45° by the quaternion
q = cosθ + sinθk
and a pure quaternion to represent the vector 2i
p = 0 + 2i
then
qp = 2cosθi + sinθk × 2i.
With θ = 45° then
qp = 2
√
2
2 i +
√
2
2 k × 2i
=
√
2i +
√
2j
which is a pure quaternion, i.e. a vector, and p has been rotated 45°.
Let’s see what happens when θ = 180°:
qp = 2cos180°i + sin180°k × 2i = −2i
which is also a pure quaternion, and p has been rotated 180°. Note that the vector has
not been scaled during the rotation. This is because we are using a unit quaternion.
Now let’s see what happens when we reduce the angle between ˆv and p. Let’s
reduce the angle to 45° and retain the quaternion’s magnitude at unity, as shown in
Fig. 11.3. Therefore,
ˆv = 1
√
2
i + 1
√
2
k
q = cosθ + sinθ
 1
√
2
i + 1
√
2
k

p = 0 + 2i.
This time we must include the dot product term:
qp = −sinθ ˆv · u + cosθu + sinθ ˆv × u.
We let θ = 45°
qp = −
√
2
2
 1
√
2
i + 1
√
2
k

· (2i) +
√
2
2 2i +
√
2
2
 1
√
2
i + 1
√
2
k

× 2i
= −1 +
√
2i + j

158
11
Quaternion Transforms in Space
Fig. 11.3 Rotating the vector
2i by the quaternion
q = cosθ + sinθ( 1
√
2i +
1
√
2k)
which, unfortunately, is not a pure quaternion. It has not been rotated 45° and the
vector’s magnitude is reduced to
√
3! Multiplying the vector by a non-orthogonal
quaternion seems to have converted some of the vector information into the quater-
nion’s scalar component.
Not to worry. Could it be that an inverse quaternion reverses the operation? Let’s
see what happens if we multiply this result, i.e. qp, by q−1.
Given
q = cosθ + sinθ
 1
√
2
i + 1
√
2
k

then
q−1 = cosθ −sinθ
 1
√
2
i + 1
√
2
k

=
√
2
2 −
√
2
2
 1
√
2
i + 1
√
2
k

= 1
2(
√
2 −i −k).
Therefore,
qpq−1 = 1
2(−1 +
√
2i + j)(
√
2 −i −k)
= 1
2

−
√
2 −(
√
2i + j) · (−i −k) + (i + k) +
√
2(
√
2i + j) −i +
√
2j + k

= 1
2(−
√
2 +
√
2 + i + k + 2i +
√
2j −i +
√
2j + k)
= i +
√
2j + k
which is a pure quaternion. Furthermore, its magnitude is 2, but what is strange, the
vector has been rotated 90° rather than 45° as shown in Fig. 11.4.
If this ‘sandwiching’ of the vector by q and q−1 is correct, it implies that increas-
ing θ to 90° should rotate p = 2i by 180° to 2k. Let’s try this.

11.2
Deﬁnition
159
Fig. 11.4 The vector 2i is
rotated 90° to i +
√
2j + k
Let θ = 90°, therefore,
qp =

0 + 1
 1
√
2
i + 1
√
2
k

(0 + 2i)
= 2
√
2
(−1 + j).
Next, we post-multiply by q−1
qpq−1 = 2
√
2
(−1 + j)

0 −1
√
2
i −1
√
2
k

= 2
√
2
 1
√
2
i + 1
√
2
k −1
√
2
i + 1
√
2
k

= i + k −i + k
= 2k
which conﬁrms our prediction. Now let’s show how this double angle arises.
We begin by deﬁning a unit quaternion q:
q = s + λˆv
and we will eventually assign values to s and λ. The vector u to be rotated is a pure
quaternion:
p = 0 + u.
The inverse quaternion q−1 is
q−1 = s −λˆv
therefore, the triple qpq−1 is
qpq−1 = (s + λˆv)(0 + u)(s −λˆv)
= (−λˆv · u + su + λˆv × u)(s −λˆv)
= −λsˆv · u + λsu · ˆv + λ2(ˆv × u) · ˆv
+ λ2(ˆv · u)ˆv + s2u + λsˆv × u
−λsu × ˆv −λ2(ˆv × u) × ˆv
= λ2(ˆv × u) · ˆv + λ2(ˆv · u)ˆv + s2u + 2λsˆv × u −λ2(ˆv × u) × ˆv.

160
11
Quaternion Transforms in Space
Note that
(ˆv × u) · ˆv = 0
and
(ˆv × u) × ˆv = (ˆv · ˆv)u −(u · ˆv)ˆv = u −(u · ˆv)ˆv.
Therefore,
qpq−1 = λ2(ˆv · u)ˆv + s2u + 2λsˆv × u −λ2u + λ2(u · ˆv)ˆv
= 2λ2(ˆv · u)ˆv +

s2 −λ2
u + 2λsˆv × u.
Obviously, this is a pure quaternion as there is no scalar component. However, it is
not obvious where the angle doubling comes from. But, look what happens when
we make s = cosθ and λ = sinθ:
qpq−1 = 2sin2 θ(ˆv · u)ˆv +

cos2 θ −sin2 θ

u + 2sinθ cosθ ˆv × u
= (1 −cos2θ)(ˆv · u)ˆv + cos2θu + sin2θ ˆv × u.
The double angle trigonometric terms emerge! Now, if we want this triple to actually
rotate the vector by θ, then we must build this in from the outset by halving θ in q:
q = cos(θ/2) + sin(θ/2)ˆv
which makes
qpq−1 = (1 −cosθ)(ˆv · u)ˆv + cosθu + sinθ ˆv × u.
(11.1)
Equation (11.1) is the same equation we came across in Chap. 9 discovered by
Rodrigues a few years before Hamilton, hence the scandal!
Let’s test (11.1) using the previous example where we rotated a vector u = 2i,
90° about the quaternion’s vector ˆv =
1
√
2i +
1
√
2k:
qpq−1 = 2
√
2
 1
√
2
i + 1
√
2
k

+
√
2j
= i +
√
2j + k
which agrees with the previous result.
Thus, when a quaternion takes on the form
q = cos(θ/2) + sin(θ/2)ˆv
it rotates a vector p, anticlockwise θ using the triple
qpq−1.
It can be shown that this triple always preserves the magnitude of the rotated vector.
You may be wondering what happens if the triple is reversed to q−1pq? A guess
would suggest that the rotation sequence is reversed, but let’s see what an algebraic
solution predicts:

11.2
Deﬁnition
161
q−1pq = (s −λˆv)(0 + u)(s + λˆv)
= (λˆv · u + su −λˆv × u)(s + λˆv)
= λsˆv · u −λsu · ˆv + λ2ˆv × u · ˆv + λ2ˆv · uˆv
+ s2u −λsˆv × u + λsu × ˆv −λ2ˆv × u × ˆv
= λ2(ˆv × u) · ˆv + λ2(ˆv · u)ˆv + s2u −2λsˆv × u −λ2(ˆv × u) × ˆv.
Once again
(ˆv × u) · ˆv = 0
and
(ˆv × u) × ˆv = u −(u · ˆv)ˆv.
Therefore,
q−1pq = λ2(ˆv · u)ˆv + s2u −2λsˆv × u −λ2u + λ2(u · ˆv)ˆv
= 2λ2(ˆv · u)ˆv +

s2 −λ2
u −2λsˆv × u.
Again, let’s make s = cosθ and λ = sinθ:
q−1pq = (1 −2cosθ)(ˆv · u)ˆv + cos2θu −sin2θ ˆv × u
and the only thing that has changed is the sign of the cross-product term, which
reverses the direction of its vector. However, we must remember to compensate for
the angle-doubling by halving θ:
q−1pq = (1 −cosθ)(ˆv · u)ˆv + cosθu −sinθ ˆv × u.
(11.2)
Let’s see what happens when we employ (11.2) to rotate u = 2i, 90° about the
quaternion’s vector ˆv =
1
√
2i +
1
√
2k:
q−1pq = 2
√
2
 1
√
2
i + 1
√
2
k

−
√
2j
= i −
√
2j + k
which has rotated u clockwise 90° about the quaternion’s vector. Therefore, the
rotor qpq−1 rotates a vector anticlockwise, and q−1pq rotates a vector clockwise:
qpq−1 = (1 −cosθ)(ˆv · u)ˆv + cosθu + sinθ ˆv × u
q−1pq = (1 −cosθ)(ˆv · u)ˆv + cosθu −sinθ ˆv × u.
However, we must remember that the rotor interprets θ as 2θ.
Let’s compute another example. Consider the point P(0,1,1) in Fig. 11.5 which
is to be rotated 90° about the y-axis. We can see that the rotated point P ′ has the
coordinates (1,1,0) which we will conﬁrm algebraically. The point P is represented
by the pure quaternion
p = 0 + u.
The axis of rotation is ˆv = j, and the vector to be rotated is u = j + k. Therefore,

162
11
Quaternion Transforms in Space
Fig. 11.5 The point
P (0,1,1) is rotated 90° to
P ′(1,1,0) about the y-axis
qpq−1 = (1 −cosθ)(ˆv · u)ˆv + cosθu + sinθ ˆv × u
= j · (j + k)j + j × (j + k)
= i + j
and conﬁrms that P is indeed rotated to (1,1,0).
Before moving onto the next section it is worth clarifying the interpretation of the
two triples described above. As with the rotation transforms previously covered, we
have used Rθ,v to describe a point rotation, θ about the vector v, and R−1
θ,v to describe
a frame rotation θ about the vector v. Therefore, in keeping with this convention, we
will use qpq−1 to describe a point rotation of the point represented by p about the
quaternion’s vector. And q−1pq to describe a frame rotation about the same vector.
11.3 Quaternions in Matrix Form
Having discovered a vector equation to represent the triple qpq−1, let’s continue
and convert it into a matrix. We will explore two methods: the ﬁrst is a simple vec-
torial method which translates the vector equation representing qpq−1 directly into
a matrix form; the second method uses matrix algebra to develop a rather cunning
solution. Let’s start with the vectorial approach, for which it is convenient to de-
scribe the unit quaternion as
q = s + v
= s + xi + yj + zk
and the pure quaternion as
p = 0 + u
which means that the triple becomes
qpq−1 = 2(v · u)v +

s2 −|v|2
u + 2sv × u.
And as we are working with unit quaternions to prevent scaling
s2 + |v|2 = 1

11.3
Quaternions in Matrix Form
163
therefore,
s2 −|v|2 = 2s2 −1
and
qpq−1 = 2(v · u)v +

2s2 −1

u + 2sv × u.
We can now represent the three terms 2(v · u)v, (2s2 −1)u and 2sv × u as three
individual matrices, which can be summed together:
2(v · u)v = 2(xxu + yyu + zzu)(xi + yj + zk)
=
⎡
⎣
2x2
2xy
2xz
2xy
2y2
2yz
2xz
2yz
2z2
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦

2s2 −1

u =

2s2 −1

xui +

2s2 −1

yuj +

2s2 −1

zuk
=
⎡
⎣
2s2 −1
0
0
0
2s2 −1
0
0
0
2s2 −1
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
2sv × u = 2s

(yzu −zyu)i + (zxu −xzu)j + (xyu −yxu)k

=
⎡
⎣
0
−2sz
2sy
2sz
0
−2sx
−2sy
2sx
0
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Adding these matrices together produces
qpq−1 =
⎡
⎣
2(s2 + x2) −1
2(xy −sz)
2(xz + sy)
2(xy + sz)
2(s2 + y2) −1
2(yz −sx)
2(xz −sy)
2(yz + sx)
2(s2 + z2) −1
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
(11.3)
or
qpq−1 =
⎡
⎣
1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
(11.4)
To compute the equivalent matrix for q−1pq all that we have to do is reverse the
sign of 2sv × u:
q−1pq =
⎡
⎣
2(s2 + x2) −1
2(xy + sz)
2(xz −sy)
2(xy −sz)
2(s2 + y2) −1
2(yz + sx)
2(xz + sy)
2(yz −sx)
2(s2 + z2) −1
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
(11.5)
or

164
11
Quaternion Transforms in Space
q−1pq =
⎡
⎣
1 −2(y2 + z2)
2(xy + sz)
2(xz −sy)
2(xy −sz)
1 −2(x2 + z2)
2(yz + sx)
2(xz + sy)
2(yz −sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
(11.6)
which is the transpose of (11.3) for qpq−1.
11.3.1 Quaternion Products and Matrices
The second way to derive (11.3) depends upon representing a quaternion product in
matrix form. For example, given
q1 = s1 + x1i + y1j + z1k
q2 = s2 + x2i + y2j + z2k
their product is
q1q2 = (s1 + x1i + y1j + z1k)(s2 + x2i + y2j + z2k)
= s1s2 −x1x2 −y1y2 −z1z2
+ s1(x2i + y2j + z2k)
+ s2(x1i + y1j + z1k)
+ (y1z2 −y2z1)i + (x2z1 −x1z2)j + (x1y2 −x2y1)k
= s1s2 −x1x2 −y1y2 −z1z2
+ (s1x2 + s2x1 + y1z2 −y2z1)i
+ (s1y2 + s2y1 + x2z1 −x1z2)j
+ (s1z2 + s2z1 + x1y2 −x2y1)k
q1q2 =
⎡
⎢⎢⎣
s1
−x1
−y1
−z1
x1
s1
−z1
y1
y1
z1
s1
−x1
z1
−y1
x1
s1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s2
x2
y2
z2
⎤
⎥⎥⎦.
At this stage we have quaternion q1 represented by a matrix, and q2 represented by a
column vector. Now let’s reverse the scenario without altering the result by making
q2 the matrix and q1 the column vector:
q1q2 =
⎡
⎢⎢⎣
s2
−x2
−y2
−z2
x2
s2
z2
−y2
y2
−z2
s2
x2
z2
y2
−x2
s2
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s1
x1
y1
z1
⎤
⎥⎥⎦.
So now we have two ways of computing q1q2 and we need a way of distinguish-
ing between the two matrices. Let’s call the matrix that preserves the left-to-right
quaternion sequence L and the matrix that reverses the sequence to right-to-left, R:

11.3
Quaternions in Matrix Form
165
q1q2 = L(q1)q2 =
⎡
⎢⎢⎣
s1
−x1
−y1
−z1
x1
s1
−z1
y1
y1
z1
s1
−x1
z1
−y1
x1
s1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s2
x2
y2
z2
⎤
⎥⎥⎦
q1q2 = R(q2)q1 =
⎡
⎢⎢⎣
s2
−x2
−y2
−z2
x2
s2
z2
−y2
y2
−z2
s2
x2
z2
y2
−x2
s2
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s1
x1
y1
z1
⎤
⎥⎥⎦.
Remember that L(q1)q2 = R(q2)q1, as this is central to understanding the next
stage. Furthermore, don’t be surprised if you don’t understand the logic of the argu-
ment in the ﬁrst reading. It took the author many hours of anguish trying to decipher
the original algorithm, and the explanation has been expanded to ensure that you do
not suffer the same experience!
First, let’s employ the matrices L and R to rearrange the quaternion triple product
acb to abc: i.e. move c from the middle to the right-hand side.
We start with the quaternion triple product acb and divide it into two parts, ac
and b. We can do this because quaternion algebra is associative:
acb = (ac)b.
We have already demonstrated above that the product ac can be replaced by L(a)c:
acb = L(a)cb.
We now have another two parts: L(a)c and b which can be reversed using R without
disturbing the result:
acb = L(a)cb = R(b)L(a)c
which has achieved our objective to move c to the right-hand side.
Now let’s repeat the same process to rearrange the triple product qpq−1. The
objective is to remove p from the middle of q and q−1 and move it to the right-hand
side. The reason for doing this is to bring together q and q−1 in the form of two
matrices, which can be multiplied together into a single matrix.
We start with the quaternion triple product qpq−1 and divide it into two parts,
qp and q−1:
qpq−1 = (qp)q−1.
The product qp can be replaced by L(q)p:
qpq−1 = L(q)pq−1.
We now have another two parts: L(q)p and q−1 which can be reversed using R
without disturbing the result:
qpq−1 = L(q)pq−1 = R

q−1
L(q)p
which has achieved our objective to move p to the right-hand side.
The next step is to compute L(q) and R(q−1) using q = s + xi + yj + zk. L(q)
is easy as it is the same as L(q1) without any subscripts:

166
11
Quaternion Transforms in Space
L(q) =
⎡
⎢⎢⎣
s
−x
−y
−z
x
s
−z
y
y
z
s
−x
z
−y
x
s
⎤
⎥⎥⎦.
R(q−1) is also easy, but requires converting q2 in the original deﬁnition into q−1
2
which is effected by reversing the signs of the vector components:
R

q−1
=
⎡
⎢⎢⎣
s
x
y
z
−x
s
−z
y
−y
z
s
−x
−z
−y
x
s
⎤
⎥⎥⎦.
So now we can write
qpq−1 = R

q−1
L(q)p
=
⎡
⎢⎢⎣
s
x
y
z
−x
s
−z
y
−y
z
s
−x
−z
−y
x
s
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s
−x
−y
−z
x
s
−z
y
y
z
s
−x
z
−y
x
s
⎤
⎥⎥⎦
⎡
⎢⎢⎣
0
xu
yu
zu
⎤
⎥⎥⎦
=
⎡
⎢⎢⎣
1
0
0
0
0 1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
0
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
0
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎥⎥⎦
⎡
⎢⎢⎣
0
xu
yu
zu
⎤
⎥⎥⎦.
If we remove the ﬁrst row and column and treat p as a vector, rather than a quater-
nion, we have
=
⎡
⎣
1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
which is identical to (11.4)!
11.3.2 Geometric Veriﬁcation
Let’s illustrate the action of (11.3) by rotating the point (0,1,1), 90° about the y-
axis, as shown in Fig. 11.6. The quaternion must take the form
q = cos(θ/2) + sin(θ/2)ˆv
which means that θ = 90° and ˆv = j, therefore,
q = cos45° + sin45°ˆj.
Consequently,
s =
√
2
2 ,
x = 0,
y =
√
2
2 ,
z = 0.

11.3
Quaternions in Matrix Form
167
Fig. 11.6 The point
P (0,1,1) is rotated 90° to
P ′(1,1,0) about the y-axis
Substituting these values in (11.3) gives
⎡
⎣
1
1
0
⎤
⎦=
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎡
⎣
0
1
1
⎤
⎦
where (0,1,1) is rotated to (1,1,0), which is correct.
So now we have a transform that rotates a point about an arbitrary axis intersect-
ing the origin without the problems of gimbal lock associated with Euler transforms.
Before moving on, let’s evaluate one more example. Let’s perform a 180° ro-
tation about a vector v = i + k passing through the origin. To begin with, we will
deliberately forget to convert the vector into a unit vector, just to see what happens
to the ﬁnal matrix. The quaternion should take the form
q = cos(θ/2) + sin(θ/2)ˆv
but we will use v as speciﬁed. Therefore, with θ = 180°
s = 0,
x = 1,
y = 0,
z = 1.
Substituting these values in (11.3) gives
⎡
⎣
1
0
2
0
−1
0
2
0
1
⎤
⎦
which looks nothing like a rotation matrix, and reminds us how important it is to
have a unit vector to represent the axis. Let’s repeat these calculations normalising
the vector to ˆv = i/
√
2 + k/
√
2:
s = 0,
x = 1
√
2
,
y = 0,
z = 1
√
2
.
Substituting these values in (11.3) gives
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦

168
11
Quaternion Transforms in Space
Fig. 11.7 The point (1,0,0)
is rotated 180° about the
vector v to (0,0,1)
which not only looks like a rotation matrix, but has a determinant of 1 and rotates
the point (1,0,0) to (0,0,1) as shown in Fig. 11.7,
⎡
⎣
0
0
1
⎤
⎦=
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
1
0
0
⎤
⎦.
11.4 Multiple Rotations
Say a vector or frame of reference is subjected to two rotations speciﬁed by q1
followed by q2. There is a temptation to convert both quaternions to their respective
matrix and multiply the matrices together. However, this not the most efﬁcient way
of combining the rotations. It is best to accumulate the rotations as quaternions and
then convert to matrix notation, if required.
To illustrate this, consider the vector p subjected to the ﬁrst quaternion q1:
q1pq−1
1
followed by a second quaternion q2
q2

q1pq−1
1

q−1
2
which can be expressed as
(q2q1)p(q2q1)−1.
Extra quaternions can be added accordingly. Let’s illustrate this with an example.
To keep things simple, the ﬁrst quaternion q1 rotates 30° about the y-axis:
q1 = cos15° + sin15°j.
The second quaternion q2 rotates 60° also about the y-axis:
q1 = cos30° + sin30°j.
Together, the two quaternions rotate 90° about the y-axis. To accumulate these ro-
tations, we must multiply them together:

11.5
Eigenvalue and Eigenvector
169
q1q2 =

cos15° + sin15°j

cos30° + sin30°j

= cos15°cos30° −sin15°sin30° + cos15°sin30°j + cos30°sin15°j
=
√
2
2 +
√
2
2 j
which is a quaternion that rotates 90° about the y-axis. Using the matrix (11.4) we
have
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
which rotates points about the y-axis by 90°.
11.5 Eigenvalue and Eigenvector
Although there is no doubt that (11.3) is a rotation matrix, we can secure further
evidence by calculating its eigenvalue and eigenvector. The eigenvalue should be θ,
where
Tr

qpq−1
= 1 + 2cosθ.
The trace of (11.3) is
Tr

qpq−1
= 2

s2 + x2
−1 + 2

s2 + y2
−1 + 2

s2 + z2
−1
= 4s2 + 2

s2 + x2 + y2 + z2
−3
= 4s2 −1
= 4cos2(θ/2) −1
= 4cosθ + 4sin2(θ/2) −1
= 4cosθ + 2 −2cosθ −1
= 1 + 2cosθ
and
cosθ = 1
2

Tr

qpq−1
−1

.
To compute the eigenvector of (11.3) we use the three equations derived in Chap. 9:
v1 = (a22 −1)(a33 −1) −a23a32
v2 = (a33 −1)(a11 −1) −a31a13
v3 = (a11 −1)(a22 −1) −a12a21.

170
11
Quaternion Transforms in Space
Therefore,
v1 =

2

s2 + y2
−2

2

s2 + z2
−2

−2(yz −sx)2(yz + sx)
= 4

s2 + y2 −1

s2 + z2 −1

−4

y2z2 −s2x2
= 4

x2 + z2
x2 + y2
−y2z2 + s2x2
= 4

x4 + x2y2 + x2z2 + z2y2 −y2z2 + s2x2
= 4x2
s2 + x2 + y2 + z2
= 4x2.
Similarly, v2 = 4y2 and v3 = 4z2, which conﬁrms that the eigenvector has compo-
nents associated with the quaternion’s vector. The square terms should be no sur-
prise, as the triple qpq−1 includes the product of two quaternions.
11.6 Rotating About an Off-Set Axis
Now that we have a matrix to represent a quaternion rotor, we can employ it to
resolve problems such as rotating a point about an off-set axis using the same tech-
niques associated with normal rotation transforms. For example, in Chap. 9 we used
the following notation
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= Ttx,0,tzRβ,yT−tx,0,−tz
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦
to rotate a point about a ﬁxed axis parallel with the y-axis. Therefore, by substituting
qpq−1 for Rβ,y we have
⎡
⎢⎢⎣
x′
y′
z′
1
⎤
⎥⎥⎦= Ttx,0,tzqpq−1T−tx,0,−tz
⎡
⎢⎢⎣
x
y
z
1
⎤
⎥⎥⎦.
Let’s test this by rotating our unit cube 90° about the vertical axis intersecting ver-
tices 4 and 6 as shown in Fig. 11.8 (a) and (b).
The quaternion to achieve this is
q = cos45° + sin45°j
with the pure quaternion
p = 0 + u
and using (11.3) this creates the homogeneous matrix
qpq−1 =
⎡
⎢⎢⎣
0
0
1
0
0
1
0
0
−1
0
0
0
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
xu
yu
zu
1
⎤
⎥⎥⎦.

11.7
Frames of Reference
171
Fig. 11.8 The cube is rotated 90° about the axis intersecting vertices 4 and 6
The other two matrices are
T−tx,0,0 =
⎡
⎢⎢⎣
1
0
0
−1
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦
Ttx,0,0 =
⎡
⎢⎢⎣
1
0
0
1
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Multiplying these matrices together creates
⎡
⎢⎢⎣
0
0
1
1
0
1
0
0
−1
0
0
1
0
0
0
1
⎤
⎥⎥⎦
which when applied to the cube’s coordinates produces
⎡
⎢⎢⎣
0
0
1
1
0
1
0
0
−1
0
0
1
0
0
0
1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦
=
⎡
⎢⎢⎣
1
2
1
2
1
2
1
2
0
0
1
1
0
0
1
1
1
1
1
1
0
0
0
0
1
1
1
1
1
1
1
1
⎤
⎥⎥⎦.
These coordinates are conﬁrmed by Fig. 11.8 (a) and (b).
11.7 Frames of Reference
Chapter 10 explored various techniques for changing the coordinates of objects in
different frames of reference. Now that we have covered quaternions, and especially

172
11
Quaternion Transforms in Space
Fig. 11.9 The frame is rotated 180° about the vector [i + k]
the matrix representing the triple q−1pq, (11.5) we can show how quaternions can
be added to these techniques.
The triple qpq−1 is used for rotating points about the vector associated with
the quaternion q, whereas the triple q−1pq is used for rotating points about the
same vector, but in the opposite direction. But we have already reasoned that this
reverse rotation is equivalent to a change of frame of reference. To demonstrate this,
consider the problem of rotating the frame of reference 180° about i + k as shown
in Fig. 11.9 (a) and (b). The unit quaternion for such a rotation is
q = cos90° + sin90°
 1
√
2
i + 1
√
2
k

= 0 +
√
2
2 i +
√
2
2 k.
Consequently,
s = 0,
x =
√
2
2 ,
y = 0,
z =
√
2
2 .
Substituting these values in (11.5) we obtain
q−1pq =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
which if used to process the coordinates of our unit cube produces
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This scenario is shown in Fig. 11.9 (a) and (b).

11.8
Interpolating Quaternions
173
Fig. 11.10 The point
(0,1,1) is rotated 90° about
the vector v to (1,1,0)
11.8 Interpolating Quaternions
Like vectors, quaternions can also be interpolated to compute an in-between quater-
nion. However, whereas two interpolated vectors results in a third vector that is
readily visualised, two interpolated quaternions results in a third quaternion that
acts as a rotor, and is not immediately visualised.
We have already seen that the spherical interpolant for vectors is
v = sin(1 −t)θ
sinθ
v1 + sintθ
sinθ v2
and requires no modiﬁcation for quaternions:
q = sin(1 −t)θ
sinθ
q1 + sintθ
sinθ q2.
(11.7)
So, given
q1 = s1 + x1i + y1j + z1k
q2 = s2 + x2i + y2j + z2k
θ is obtained by taking the 4D dot product of q1 and q2:
cosθ = q1 · q2
|q1||q2|
cosθ = s1s2 + x1x2 + y1y2 + z1z2
|q1||q2|
and if we are working with unit quaternions, then
cosθ = s1s2 + x1x2 + y1y2 + z1z2.
(11.8)
Let’s use (11.7) in a scenario with two simple quaternions.
Figure 11.10 shows one such scenario where the point (0,1,1) is rotated 90°
about v, the axis of q1. Figure 11.11 shows another scenario where the same point
(0,1,1) is rotated 90° about v, the axis of q2. The quaternions are
q1 = cos45° + sin45°j =
√
2
2 +
√
2
2 j
q2 = cos45° + sin45°i =
√
2
2 +
√
2
2 i.

174
11
Quaternion Transforms in Space
Fig. 11.11 The point
(0,1,1) is rotated 90° about
the vector v to (0,−1,1)
Therefore, using (11.8)
cosθ =
√
2
2
√
2
2 = 0.5
θ = 60°.
Before proceeding, let’s compute the two matrices for the two quaternion triples.
For q1
s =
√
2
2 ,
x = 0,
y =
√
2
2 ,
z = 0
which when substituted in (11.3) gives
q1pq−1
1
=
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Substituting the coordinates (0,1,1) gives
⎡
⎣
1
1
0
⎤
⎦=
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎡
⎣
0
1
1
⎤
⎦
which is correct.
For q2
s =
√
2
2 ,
x =
√
2
2 ,
y = 0,
z = 0
which when substituted in (11.3) gives
q2pq−1
2
=
⎡
⎣
1
0
0
0
0
−1
0
1
0
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Substituting the coordinates (0,1,1) gives
⎡
⎣
0
−1
1
⎤
⎦=
⎡
⎣
1
0
0
0
0
−1
0
1
0
⎤
⎦
⎡
⎣
0
1
1
⎤
⎦
which is also correct.

11.8
Interpolating Quaternions
175
Fig. 11.12 The point
(0,1,1) is rotated 90° about
the vector v to (1,0,1)
Using (11.7) with t = 0.5 should compute a mid-way position for an interpolated
quaternion, with its vector at 45° between the x- and y-axes, as shown in Fig. 11.12.
We already know that θ = 60°, therefore sinθ =
√
3/2, and using (11.7)
q = sin 1
260°
sin60°
√
2
2 +
√
2
2 j

+ sin 1
260°
sin60°
√
2
2 +
√
2
2 i

= 1
√
3
√
2
2 +
√
2
2 j

+ 1
√
3
√
2
2 +
√
2
2 i

=
√
2
2
√
3
+
√
2
2
√
3
j +
√
2
2
√
3
+
√
2
2
√
3
i
=
√
2
√
3
+ 1
√
6
i + 1
√
6
j
therefore,
s =
√
2
√
3
,
x = 1
√
6
,
y = 1
√
6
,
z = 0
which when substituted in (11.3) gives
qpq−1 =
⎡
⎢⎣
1 −( 2
6)
2( 1
6)
2( 1
3)
2( 1
6)
1 −2( 1
6)
2(−1
3)
2(−1
3)
2( 1
3)
1 −2( 1
6 + 1
6)
⎤
⎥⎦
⎡
⎣
xu
yu
zu
⎤
⎦
and
qpq−1 =
⎡
⎢⎣
2
3
1
3
2
3
1
3
2
3
−2
3
−2
3
2
3
1
3
⎤
⎥⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Substituting the coordinates (0,1,1) gives
⎡
⎣
1
0
1
⎤
⎦=
⎡
⎢⎣
2
3
1
3
2
3
1
3
2
3
−2
3
−2
3
2
3
1
3
⎤
⎥⎦
⎡
⎣
0
1
1
⎤
⎦
(11.9)
which gives the point (1,0,1).

176
11
Quaternion Transforms in Space
Fig. 11.13 Spherical
interpolation between q1
and q2
One of the reasons for using this spherical interpolant is that it linearly inter-
polates the angle between the two quaternions, which creates a constant-angular
velocity between the quaternions. However, one of the problems with visualising
quaternions is that they reside in a four-dimensional space and create a hyper-sphere
with a radius equal to the quaternion’s magnitude. With our 3D brains, this is difﬁ-
cult to visualise. Nevertheless, we can convince ourselves into thinking we see what
is going on with a simple sketch, as shown in Fig. 11.13, where we see part of the
hyper-sphere and two quaternions q1 and q2. In this example, the angle φ is a con-
stant angle between two values of the interpolant t. The spherical interpolant also
ensures that the magnitude of the interpolated quaternion remains constant at unity
and prevents any unwanted scaling.
Figure 11.14 provides another sketch to help visualise what is going on. For ex-
ample, when t = 0, the interpolated quaternion is q1 which rotates the point (0,1,1)
to (1,1,0), and when t = 1, the interpolated quaternion is q2 which rotates the point
(0,1,1) to (0,−1,1). When t = 0.5, the interpolated quaternion rotates the point
(0,1,1) to (1,0,1) as computed above. Two other curves show what happens for
t = 0.25 and t = 0.75.
A natural consequence of the interpolant is that the angle of rotation is 90° for
t = 0 and t = 1, but for t = 0.5 the angle of rotation (eigenvalue) is approximately
70.5°. Corresponding angles arise for other values of t.
Fig. 11.14 Sketch showing
the actions of the interpolated
quaternions

11.9
Converting a Rotation Matrix to a Quaternion
177
11.9 Converting a Rotation Matrix to a Quaternion
The matrix transform equivalent to qpq−1 is
qpq−1 =
⎡
⎣
2(s2 + x2) −1
2(xy −sz)
2(xz + sy)
2(xy + sz)
2(s2 + y2) −1
2(yz −sx)
2(xz −sy)
2(yz + sx)
2(s2 + z2) −1
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦
=
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Inspection of the matrix shows that by combining various elements we can isolate
the terms of a quaternion s,x,y,z. For example, by adding the terms a11 +a22 +a33
we obtain:
a11 + a22 + a33 =

2

s2 + x2
−1

+

2

s2 + y2
−1

+

2

s2 + z2
−1

= 6s2 + 2

x2 + y2 + z2
−3
= 4s2 −1
therefore,
s = ±1
2

1 + a11 + a22 + a33.
To isolate x, y and z we use
x = 1
4s (a32 −a23)
y = 1
4s (a13 −a31)
z = 1
4s (a21 −a12).
We can conﬁrm their accuracy using the matrix (11.9):
s = ±1
2

1 + 2
3 + 2
3 + 1
3 =
√
2
√
3
x =
√
3
4
√
2
2
3 + 2
3

= 1
√
6
y =
√
3
4
√
2
2
3 + 2
3

= 1
√
6
z =
√
3
4
√
2
1
3 −1
3

= 0
which agree with the original values.
Say, for example, the value of s had been close to zero, this could have made the
values of x, y, z unreliable. Consequently, other combinations are available:

178
11
Quaternion Transforms in Space
x = ±1
2

1 + a11 −a22 −a33
y = 1
4x (a12 + a21)
z = 1
4x (a13 + a31)
s = 1
4x (a32 −a23)
y = ±1
2

1 −a11 + a22 −a33
x = 1
4y (a12 + a21)
z = 1
4y (a23 + a32)
s = 1
4y (a13 −a31)
z = ±1
2

1 −a11 −a22 + a33
x = 1
4z(a13 + a31)
y = 1
4z(a23 + a32)
s = 1
4z(a21 −a12).
11.10 Summary
Quaternion algebra offers a simple and efﬁcient way for computing rotations, but
can also be evaluated in matrix form. We have also shown that it is possible to move
between both forms of notation. It is left to the reader to code up some of these ideas
and explore issues of accuracy and efﬁciency.
11.10.1 Summary of Quaternion Transforms
Given
q = s + ˆv = cos(θ/2) + sin(θ/2)(xi + yj + zk)
p = 0 + u.

11.10
Summary
179
Rotating a point about a vector
qpq−1 = (1 −cosθ)(ˆv · u)ˆv + cosθu + sinθ ˆv × u.
Rotating a frame about a vector
q−1pq = (1 −cosθ)(ˆv · u)ˆv + cosθu −sinθ ˆv × u.
Matrix for rotating a point about a vector
qpq−1 =
⎡
⎣
1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Matrix for rotating a frame about a vector
q−1pq =
⎡
⎣
1 −2(y2 + z2)
2(xy + sz)
2(xz −sy)
2(xy −sz)
1 −2(x2 + z2)
2(yz + sx)
2(xz + sy)
2(yz −sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
xu
yu
zu
⎤
⎦.
Matrix for a quaternion product
q1q2 = L(q1)q2 =
⎡
⎢⎢⎣
s1
−x1
−y1
−z1
x1
s1
−z1
y1
y1
z1
s1
−x1
z1
−y1
x1
s1
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s2
x2
y2
z2
⎤
⎥⎥⎦
q1q2 = R(q2)q1 =
⎡
⎢⎢⎣
s2
−x2
−y2
−z2
x2
s2
z2
−y2
y2
−z2
s2
x2
z2
y2
−x2
s2
⎤
⎥⎥⎦
⎡
⎢⎢⎣
s1
x1
y1
z1
⎤
⎥⎥⎦.
Interpolating two quaternions
q = sin(1 −t)θ
sinθ
q1 + sintθ
sinθ q2
where
cosθ = q1 · q2
|q1||q2|
cosθ = s1s2 + x1x2 + y1y2 + z1z2
|q1||q2|
.
Quaternion from a rotation matrix
s = ±1
2

1 + a11 + a22 + a33
x = 1
4s (a32 −a23)
y = 1
4s (a13 −a31)
z = 1
4s (a21 −a12)

180
11
Quaternion Transforms in Space
x = ±1
2

1 + a11 −a22 −a33
y = 1
4x (a12 + a21)
z = 1
4x (a13 + a31)
s = 1
4x (a32 −a23)
y = ±1
2

1 −a11 + a22 −a33
x = 1
4y (a12 + a21)
z = 1
4y (a23 + a32)
s = 1
4y (a13 −a31)
z = ±1
2

1 −a11 −a22 + a33
x = 1
4z(a13 + a31)
y = 1
4z(a23 + a32)
s = 1
4z(a21 −a12).

Chapter 12
Bivector Rotors
12.1 Introduction
In Chap. 6 we explored multivectors, and in Chap. 11 we saw how quaternions are
used to rotate points and frames of reference about an arbitrary vector. In this chapter
we will see how these two ideas merge into one to form bivector rotors. In order to
show how such rotors operate, we begin with reﬂections and show how these can
effect a rotation.
12.2 The Three Reﬂections Theorem
The three reﬂections theorem states that ‘each isometry of the Euclidean plane is
the composite of one, two, or three reﬂections.’ To begin with, an isometry of the
Euclidean plane is a way of transforming the plane that preserves length. Such
isometries include rotation, translation, reﬂection and glide reﬂections. The latter is
a combination of a reﬂection in a line and a translation along that line. John Stillwell
provides an elegant proof for this theorem in his book Numbers and Geometry [8].
The isometry we are particularly interested in is reﬂection, where the distance
between two points is preserved in their reﬂection. Consider, for example, the 2D
scenario shown in Fig. 12.1 where two lines M and N are imaginary mirrors sepa-
rated by an angle θ. The real point P subtends an angle α to mirror M and creates
a virtual image PR which subtends an equal but opposite angle.
Although it is not physically possible, we can imagine that the virtual image PR
is reﬂected in the second mirror N. To begin with, PR subtends an angle θ −α to
mirror N and creates another virtual image P ′ which subtends an equal and opposite
angle. What is interesting about this conﬁguration is that although the mirrors are
separated by θ, the angle between P and P ′ is 2θ. In order to take advantage of this
effect we need to know how vectors are reﬂected using multivectors, which is the
subject of the next section.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_12, © Springer-Verlag London Limited 2011
181

182
12
Bivector Rotors
Fig. 12.1 Rotating a point by
a double reﬂection
12.3 Reﬂecting a Vector
Figure 12.2 shows a mirror with a unit normal vector ˆn and a vector a with its
reﬂection a′. Vector a has a perpendicular component a⊥and a parallel component
a∥with ˆn, and our objective is to derive a deﬁnition of the reﬂection a′ in terms of
vector a and any other essential vectors.
From our knowledge of multivectors, we know that ˆn2 = 1 which permits us to
write
a = ˆn2a = ˆn(ˆna).
This has created the geometric product ˆna which equals
ˆna = ˆn · a + ˆn ∧a
(12.1)
therefore,
a = ˆn(ˆn · a + ˆn ∧a).
(12.2)
We can see that (12.2) has two parts: ˆn(ˆn · a) and ˆn(ˆn ∧a). The ﬁrst part is another
way of expressing a∥:
a∥= (ˆn · a)ˆn
and as
a = a⊥+ a∥
Fig. 12.2 Reﬂecting a vector
in a mirror

12.3
Reﬂecting a Vector
183
the second part must be
a⊥= ˆn(ˆn ∧a).
From Fig. 12.2 we see that
a′ = a⊥−a∥
(12.3)
= ˆn(ˆn ∧a) −(ˆn · a)ˆn.
(12.4)
Equation (12.4) contains the product of a vector ˆn and a bivector ˆn ∧ˆa which anti-
commute:
ˆn(ˆn ∧a) = ˆn
2(ˆna −aˆn)
= 1
2(a −ˆnaˆn)
whereas,
(ˆn ∧a)ˆn = 1
2(ˆna −aˆn)ˆn
= 1
2(ˆnaˆn −a)
therefore, we can write (12.4) as
a′ = −(ˆn · a)ˆn −(ˆn ∧a)ˆn
which simpliﬁes to
a′ = −(ˆn · a + ˆn ∧a)ˆn.
(12.5)
By substituting (12.1) in (12.5) we have
a′ = −ˆnaˆn
(12.6)
which is rather elegant!
To illustrate (12.6), consider the scenario shown in Fig. 12.3 where we see a
mirror placed on the zx-plane with normal vector j or e2. The vector to be reﬂected
is
a = i + j −k
which can also be expressed as
a = e1 + e2 −e3.
Using (12.6) we have
a′ = −e2(e1 + e2 −e3)e2
which, using the rules of multivectors simpliﬁes to
a′ = −e2e1e2 −e2e2e2 + e2e3e2
= e1 −e2 −e3
= i −j −k
and is conﬁrmed by Fig. 12.3. Now let’s see how these ideas can be generalised into
3D rotations.

184
12
Bivector Rotors
Fig. 12.3 Reﬂecting a vector
in a mirror
12.4 3D Rotations
Figure 12.4 shows a plan view of two mirrors M and N with their respective unit
normal vectors ˆm and ˆn separated by an angle θ. The plane containing ˆm and ˆn is
readily deﬁned by their wedge product ˆm ∧ˆn. Using (12.6) we can compute vector
a’s reﬂection by
b = −ˆma ˆm
(12.7)
and b’s reﬂection by
a′ = −ˆnbˆn.
(12.8)
Substituting (12.7) in (12.8) we obtain
a′ = ˆn ˆma ˆmˆn,
(12.9)
which is extremely compact. However, we must remember that a is rotated twice
the angle separating the mirrors, i.e. 2θ. Within geometric algebra ˆn ˆm is called a
rotor, and is represented by R, which means that using the reverse operation † we
can write (12.9) as
a′ = RaR†
(12.10)
which reminds us of the way quaternions work.
To illustrate the action of (12.10) consider the 2D scenario shown in Fig. 12.5
with two mirrors M and N and their unit normal vectors ˆm, ˆn and position vector p:
Fig. 12.4 Rotating a point by
a double reﬂection

12.4
3D Rotations
185
Fig. 12.5 Rotating a point by
180°
ˆm = e2
ˆn = −e1
p = e1 −e2.
As the mirrors are separated by 90° the point P is rotated 180°:
p′ = ˆn ˆmp ˆmˆn
= −e1e2(e1 −e2)e2(−e1)
= e12121 −e12221
p′ = −e1 + e2.
Let’s now deﬁne a rotor in terms of its bivector and the actual angle a vector is
rotated as follows. The bivector deﬁning the plane is ˆm ∧ˆn and θ is the rotor angle,
which means that the bivector angle is θ/2. Let
Rθ = ˆn ˆm
R†
θ = ˆmˆn
where
ˆn ˆm = ˆn · ˆm −ˆm ∧ˆn
ˆmˆn = ˆn · ˆm + ˆm ∧ˆn
ˆn · ˆm = cos(θ/2)
ˆm ∧ˆn = sin(θ/2) ˆB.
Therefore,
Rθ = cos(θ/2) −sin(θ/2) ˆB
R†
θ = cos(θ/2) + sin(θ/2) ˆB.
We now have an equation that rotates a vector p through an angle θ about an axis
deﬁned by ˆB:
p′ = RθpR†
θ

186
12
Bivector Rotors
or
p′ =

cos(θ/2) −sin(θ/2) ˆB

p

cos(θ/2) + sin(θ/2) ˆB

.
(12.11)
Let’s demonstrate how (12.11) works with two examples.
Example 1 Figure 12.6 shows a scenario where vector p is to be rotated 90° about
e2 which is perpendicular to ˆB, where
θ = 90°,
a = e2,
p = e1 + e2,
ˆB = e31.
Therefore,
p′ =

cos45° −sin45°e31

(e1 + e2)

cos45° + sin45°e31

=
√
2
2 −
√
2
2 e31

(e1 + e2)
√
2
2 +
√
2
2 e31

=
√
2
2 e1 +
√
2
2 e2 −
√
2
2 e3 −
√
2
2 e312
√
2
2 +
√
2
2 e31

= 1
2(e1 −e3 + e2 + e231 −e3 −e1 −e312 −e31231)
= e2 −e3
which is correct.
Observe what happens when the bivector’s sign is reversed to −e31:
p′ =

cos45° + sin45°e31

(e1 + e2)

cos45° −sin45°e31

= 1
2(1 + e31)(e1 + e2)(1 −e31)
= 1
2(e1 + e2 + e3 + e312)(1 −e31)
Fig. 12.6 Rotating a vector
by 90°

12.4
3D Rotations
187
Fig. 12.7 Rotating a vector
by 120°
= 1
2(e1 + e3 + e2 + e231 + e3 −e1 + e312 −e31231)
p′ = e2 + e3
the rotation is clockwise about e2.
Example 2 Figure 12.7 shows a scenario where vector p is to be rotated 120° about
the bivector B, where
m = e1 −e3,
n = e2 −e3,
θ = 120°,
p = e2 + e3.
First, we compute the bivector:
B = m ∧n
= (e1 −e3) ∧(e2 −e3)
= e12 + e23 + e31.
Next, we normalise B to ˆB:
ˆB = 1
√
3
(e12 + e23 + e31)
and
p′ =

cos60° −sin60° ˆB

p

cos60° + sin60° ˆB

=
1
2 −
√
3
2
1
√
3

e12 + e23 + e31

(e2 + e3)
1
2 +
√
3
2
1
√
3
(e12 + e23 + e31)

=
1
2 −e12
2 −e23
2 −e31
2

(e2 + e3)
1
2 + e12
2 + e23
2 + e31
2

= 1
4(e2 + e3 −e1 −e123 + e3 −e2 −e312 + e1)(1 + e12 + e23 + e31)
= 1
2(e3 −e123)(1 + e12 + e23 + e31)
= 1
2(e3 −e2 + e1 + e3 + e1 + e2)
= e1 + e3.

188
12
Bivector Rotors
These examples show that rotors behave just like quaternions. Rotors not only
rotate vectors, but they can be used to rotate any multivector, irrespective of their
dimension.
12.5 Rotors as Matrices
Although rotors can be computed using geometric algebra, there is a one-to-one
correspondence with matrix algebra, which we will now demonstrate.
12.5.1 2D Rotor
To begin with we will show that a 2D rotor is nothing more that a 2 × 2 matrix in
disguise for rotating a point 2θ about the origin.
Given
ˆm = m1e1 + m2e2
ˆn = n1e1 + n2e2
p = p1e1 + p2e2
and θ is the angle between ˆm and ˆn. Therefore, we can write
ˆn ˆm = ˆn · ˆm −ˆm ∧ˆn
ˆmˆn = ˆn · ˆm + ˆm ∧ˆn
where
ˆn · ˆm = cosθ
ˆm ∧ˆn = sinθe12.
Therefore, using the deﬁnition of a rotor
p′ = ˆn ˆmp ˆmˆn
= (cosθ −sinθe12)(p1e1 + p2e2)(cosθ + sinθe12)
= (p1 cosθe1 + p2 cosθe2 + p1 sinθe2 −p2 sinθe1)(cosθ + sinθe12)
=

(p1 cosθ −p2 sinθ)e1 + (p1 sinθ + p2 cosθ)e2

(cosθ + sinθe12)
=

cos2 θ −sin2 θ

p1 −2cosθ sinθp2

e1
+

2cosθ sinθp1 +

cos2 θ −sin2 θ

p2

e2
= (p1 cos2θ −p2 sin2θ)e1 + (p1 sin2θ + p2 cos2θ)e2
or in matrix form

p′
1
p′
2

=
cos2θ
−sin2θ
sin2θ
cos2θ
	p1
p2
	

12.5
Rotors as Matrices
189
which is the matrix for rotating a point 2θ about the origin. Now let’s do the same
for a 3D rotor.
12.5.2 3D Rotor
We begin with a unit bivector deﬁning the plane ˆm ∧ˆn, about which the rotation is
effected, where
ˆm = m1e1 + m2e2 + m3e3
ˆn = n1e1 + n2e2 + n3e3
and we deliberately deﬁne
Rθ = ˆn ˆm
where θ is half the angle between ˆm and ˆn.
The rotor will take the form
Rθ = s −xe23 −ye31 −ze12
which permits us to deﬁne
R†
θ = ˆmˆn
which is
R†
θ = s + xe23 + ye31 + ze12.
Therefore, given an arbitrary vector
v = v1e1 + v2e2 + v3e3
the rotated vector is given by
v′ = RθvR†
θ.
To keep the algebra simple it is best to compute the individual components of v′
using Rθv1e1R†
θ, Rθv2e2R†
θ and Rθv3e3R†
θ:
Rθv1e1R†
θ = (s −xe23 −ye31 −ze12)v1e1(s + xe23 + ye31 + ze12)
= v1(se1 −xe123 −ye3 + ze2)(s + xe23 + ye31 + ze12)
= v1

s2 + x2 −y2 −z2
e1 + 2(xy + sz)e2 + 2(xz −sy)e3

but
s2 + x2 = 1 −y2 −z2
therefore,
Rθv1e1R†
θ = v1

1 −2

y2 + z2
e1 + 2(xy + sz)e2 + 2(xz −sy)e3

.

190
12
Bivector Rotors
Next,
Rθv2e2R†
θ = (s −xe23 −ye31 −ze12)v2e2(s + xe23 + ye31 + ze12)
= v2(se2 + xe3 −ye123 + ze1)(s + xe23 + ye31 + ze12)
= v2

2(xy −sz)e1 +

s2 −x2 + y2 −z2
e2 + 2(yz + sx)e3

.
Substituting
s2 + y2 = 1 −x2 −z2
we have
Rθv2e2R†
θ = v2

2(xy −sz)e1 +

1 −2

x2 + z2
e2 + 2(yz + sx)e3

.
Next,
Rθv3e3R†
θ = (s −xe23 −ye31 −ze12)v3e3(s + xe23 + ye31 + ze12)
= v3(se3 −xe2 + ye1 −ze123)(s + xe23 + ye31 + ze12)
= v3

2(xz + sy)e1 + 2(yz −sx)e2 +

s2 −x2 −y2 + z2
e3

.
Substituting
s2 + z2 = 1 −x2 −y2
we have
Rθv3e3R†
θ = v3

2(xz −sy)e1 + 2(yz −sx)e2 +

1 −2

x2 + y2
e3

.
Therefore,
RθvR†
θ = Rv1e1R† + Rv2e2R† + Rv3e3R†
or as a matrix
⎡
⎢⎣
v′
1
v′
2
v′
3
⎤
⎥⎦=
⎡
⎣
1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦
which is the same matrix representing the quaternion triple qpq−1.
The reader should not be put off by the above algebraic proof. It has been in-
cluded to demonstrate that bivector rotors behave just like quaternions and are rep-
resented by identical matrices.
You may wish to investigate the matrix for the reverse rotor triple R†
θpRθ, which
you will discover is
⎡
⎢⎣
v′
1
v′
2
v′
3
⎤
⎥⎦=
⎡
⎣
1 −2(y2 + z2)
2(xy + sz)
2(xz −sy)
2(xy −sz)
1 −2(x2 + z2)
2(yz + sx)
2(xz + sy)
2(yz −sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦
and is the transpose of the above matrix for RθvR†
θ. Thus the matrices conﬁrm that

12.5
Rotors as Matrices
191
RθvR†
θ
rotates a vector anticlockwise by θ
R†
θvRθ
rotates a vector clockwise by θ.
Furthermore, maintaining our convention about rotating points and frames:
RθvR†
θ
rotates a frame clockwise by θ
R†
θvRθ
rotates a frame anticlockwise by θ.
12.5.3 Extracting a Rotor
Say we are presented with
ˆb = Rθ ˆaR†
θ
where we know ˆa and ˆb and have to discover Rθ. Here is one way we can undertake
the task, which is cunning, rather than obvious!
Figure 12.8 shows vectors ˆa and ˆb and a third vector ˆn, mid-way between the
two vectors. Vector ˆn bisects the angle θ separating ˆa and ˆb, therefore, the product
ˆbˆn must be a rotor capable of rotating any vector in the plane ˆn ∧ˆb by θ, which
permits us to write
ˆb = ˆbˆnˆaˆnˆb
or
ˆb = Rθ ˆaR†
θ
where
Rθ = ˆbˆn
(12.12)
R†
θ = ˆnˆb.
(12.13)
Next, to eliminate ˆn we compute
ˆn = ˆa + ˆb
|ˆa + ˆb|
Fig. 12.8 Vector ˆn bisects θ

192
12
Bivector Rotors
and substitute it in (12.12):
Rθ = ˆbˆn
= ˆb
 ˆa + ˆb
|ˆa + ˆb|

= 1 + ˆbˆa
|ˆa + ˆb|
.
Similarly,
R†
θ = ˆnˆb
=
 ˆa + ˆb
|ˆa + ˆb|

ˆb
= 1 + ˆaˆb
|ˆa + ˆb|
.
It is possible to show that
|ˆa + ˆb| =

2(1 + ˆa · ˆb)
which permits us to propose an alternative solution
Rθ =
1 + ˆbˆa

2(1 + ˆa · ˆb)
(12.14)
R†
θ =
1 + ˆaˆb

2(1 + ˆa · ˆb)
.
(12.15)
Now let’s put these deﬁnitions to the test.
Figure 12.9 shows vector ˆa aligned with the e1 axis and ˆb aligned with the e2
axis. Therefore, the rotor is acting in the e12 plane with an angle of 45° to effect a
rotation of 90°. Using our knowledge of rotors, it is obvious that
Fig. 12.9 Vector ˆa rotates
to ˆb

12.5
Rotors as Matrices
193
R90° = cos45° −sin45°e12
= 1 −e12
√
2
R†
90° = cos45° + sin45°e12
= 1 + e12
√
2
.
So let’s conﬁrm these using (12.14) and (12.15):
R90° =
1 + e2e1
√2(1 + e1 · e2)
= 1 −e12
√
2
R†
90° =
1 + e1e2
√2(1 + e1 · e2)
= 1 + e12
√
2
which conﬁrm our predictions.
In a previous example above, we used
R120° = cos60° −sin60° ˆB
R†
120° = cos60° + sin60° ˆB
ˆB = 1
√
3
(e12 + e23 + e31)
to rotate e2 + e3 to e1 + e3.
Let’s use (12.14) and (12.15) to invert the process, but remember that we are
dealing with unit vectors, which means that we have to normalise a and b:
ˆa = 1
√
2
(e2 + e3)
ˆb = 1
√
2
(e1 + e3).
Furthermore, although the bivector ˆB formed the plane of rotation in the previous
example, this time, the plane of rotation is ˆa ∧ˆb. Therefore,
R120° =
1 + ˆbˆa

2(1 + ˆa · ˆb)
=
1 +
1
√
2(e1 + e3) 1
√
2(e2 + e3)

2(1 +
1
√
2(e2 + e3) ·
1
√
2(e1 + e3))

194
12
Bivector Rotors
= 1 + 1
2(e12 −e31 −e23 + 1)

2(1 + 1
2)
= 1 + 1
2e12 −1
2e23 −1
2e31 + 1
2
√
3
=
√
3
2 +
√
3
6 e12 −
√
3
6 e23 −
√
3
6 e31
which makes
R†
120° =
√
3
2 −
√
3
6 e12 +
√
3
6 e23 +
√
3
6 e31.
But does it work? Well, let’s ﬁnd out by forming the product
R120°
1
√
2
(e2 + e3)R†
120° =
1
12
√
2
(3 + e12 + e32 + e13)
× (e2 + e3)(3 −e12 −e32 −e13)
=
1
6
√
2
(e1 + e2 + 2e3)(3 −e12 −e32 −e13)
=
1
6
√
2
(6e1 + 6e3)
= 1
√
2
(e1 + e3)
which is correct.
Finally, let’s employ the rotor matrix. But remember that its deﬁnition of Rθ has
a negative bivector term, which means that we have to switch the bivector terms in
R120° or use the bivector terms from R†
120°:
R†
120° =
√
3
2 −
√
3
6 e12 +
√
3
6 e23 +
√
3
6 e31
where
s =
√
3
2 ,
x =
√
3
6 ,
y =
√
3
6 ,
z = −
√
3
6
R120°vR†
120° =
⎡
⎣
1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦
=
⎡
⎢⎣
1 −2( 1
12 + 1
12)
2( 1
12 + 3
12)
2(−1
12 + 3
12)
2( 1
12 −3
12)
1 −2( 1
12 + 1
12)
2(−1
12 −3
12)
2(−1
12 −3
12)
2(−1
12 + 3
12)
1 −2( 1
12 + 1
12)
⎤
⎥⎦
⎡
⎣
v1
v2
v3
⎤
⎦
=
⎡
⎢⎣
2
3
2
3
1
3
−1
3
2
3
−2
3
−2
3
1
3
2
3
⎤
⎥⎦
⎡
⎣
v1
v2
v3
⎤
⎦.

12.6
Summary
195
Substituting a = [e2 + e3] we obtain
⎡
⎣
1
0
1
⎤
⎦=
⎡
⎢⎣
2
3
2
3
1
3
−1
3
2
3
−2
3
−2
3
1
3
2
3
⎤
⎥⎦
⎡
⎣
0
1
1
⎤
⎦
which is correct.
You may also like to verify that the determinant of the matrix is 1.
12.6 Summary
It is very interesting to see the close relationship between quaternions and geomet-
ric algebra. It demonstrates that although it is possible to describe the low-level
arithmetic that actually does the work behind the scenes, such as a matrix, it is also
possible to invent objects such as quaternions or bivectors, trivectors, etc., that pro-
vide a conceptual high-level framework that allow mathematicians to work more
productively and creatively. In the end, Hamilton, Grassman and Clifford have pro-
vided us with some extraordinary mathematical inventions that have found their way
into computer graphics, and I hope that this chapter has shown you another way of
handling rotations.
12.6.1 Summary of Bivector Transforms
Reﬂecting a vector in a plane
v′ = −ˆnvˆn.
Rotating a vector using rotors
v′ = RθvR†
θ
where
Rθ = cos(θ/2) −sin(θ/2) ˆB
R†
θ = cos(θ/2) + sin(θ/2) ˆB.
Rotor as a matrix
RθvR†
θ =
⎡
⎣
1 −2(y2 + z2)
2(xy −sz)
2(xz + sy)
2(xy + sz)
1 −2(x2 + z2)
2(yz −sx)
2(xz −sy)
2(yz + sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦
R†
θvRθ =
⎡
⎣
1 −2(y2 + z2)
2(xy + sz)
2(xz −sy)
2(xy −sz)
1 −2(x2 + z2)
2(yz + sx)
2(xz + sy)
2(yz −sx)
1 −2(x2 + y2)
⎤
⎦
⎡
⎣
v1
v2
v3
⎤
⎦

196
12
Bivector Rotors
where
Rθ = s −xe23 −ye31 −ze12
R†
θ = s + xe23 + ye31 + ze12.
Extracting a rotor
If
ˆb = Rθ ˆaR†
θ
then
Rθ = 1 + ˆbˆa
|ˆa + ˆb|
=
1 + ˆbˆa

2(1 + ˆa · ˆb)
R†
θ = 1 + ˆaˆb
|ˆa + ˆb|
=
1 + ˆaˆb

2(1 + ˆa · ˆb)
.

Chapter 13
Conclusion
The aim of this book was to take the reader through the important ideas and mathe-
matical techniques associated with rotation transforms. I mentioned that I would not
be too pedantic about mathematical terminology and would not swamp the reader
with high-level concepts and axioms that pervade the real world of mathematics.
My prime objective was to make the reader conﬁdent and comfortable with com-
plex numbers, vectors, matrices, quaternions and bivector rotors. I knew that this
was a challenge, but as they all share rotation as a common thread, hopefully, this
has not been too onerous for the reader.
The worked examples will provide the reader with real problems to explore. As
far as I know, they all produce correct results. But that was not always the case, as it
is so easy to switch a sign during an algebraic expansion that creates a false result.
However, repeated examination eventually leads one to the mistake, and the correct
answer emerges so naturally.
The real challenge for the reader is the next level. There are some excellent books,
technical papers and websites that introduce more advanced topics such as the B-
spline interpolation of quaternions, the kinematics of moving frames, exponential
rotors and conformal geometry. Hopefully, the contents of this book has prepared
the reader for such journeys.
What I have tried to show throughout the previous dozen chapters is that rotations
are about sines and cosines, which are ratios associated with a line sweeping the unit
circle. These, in turn, can be expressed in various identities, especially half-angle
identities.
Imaginary quantities also seem to play an important role in rotations, and it is just
as well that they exist otherwise life would be extremely difﬁcult! We have seen that
complex numbers, quaternions and bivector rotors all include imaginary quantities,
and at the end of the day, they just seem to be different ways of controlling sines and
cosines. I am certain that you now appreciate that quaternions are just one of four
possible algebras that require an n-square identity, and that they are closely related
to Clifford algebra. Which one is best for computer graphics? I don’t know. But I am
certain that if you attempt to implement these ideas, you will discover the answer.
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7_13, © Springer-Verlag London Limited 2011
197


Appendix A
Composite Point Rotation Sequences
A.1 Euler Rotations
In Chap. 9 we considered composite Euler rotations comprising individual rotations
about the x, y and z-axes such as Rγ,xRβ,yRα,z and Rγ,zRβ,yRα,x. However, there
is nothing preventing us from creating other combinations such as Rγ,xRβ,yRα,x or
Rγ,zRβ,yRα,z that do not include two consecutive rotations about the same axis. In
all, there are twelve possible combinations:
Rγ,xRβ,yRα,x,
Rγ,xRβ,yRα,z,
Rγ,xRβ,zRα,x,
Rγ,xRβ,zRα,y
Rγ,yRβ,xRα,y,
Rγ,yRβ,xRα,z,
Rγ,yRβ,zRα,x,
Rγ,yRβ,zRα,y
Rγ,zRβ,xRα,y,
Rγ,zRβ,xRα,z,
Rγ,zRβ,yRα,x,
Rγ,zRβ,yRα,z
which we now cover in detail.
For each combination there are three Euler rotation matrices, the resulting com-
posite matrix, a matrix where the three angles equal 90°, the coordinates of the
rotated unit cube, the axis and angle of rotation and a ﬁgure illustrating the stages
of rotation. To compute the axis of rotation [v1
v2
v3]T we use
v1 = (a22 −1)(a33 −1) −a23a32
v2 = (a33 −1)(a11 −1) −a31a13
v3 = (a11 −1)(a22 −1) −a12a21
where
R =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦
and for the angle of rotation δ we use
cosδ = 1
2

Tr(R) −1

.
We begin by deﬁning the three principal Euler rotations:
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7, © Springer-Verlag London Limited 2011
199

200
A
Composite Point Rotation Sequences
rotate α about the x-axis
Rα,x =
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
rotate β about the y-axis
Rβ,y =
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
rotate γ about the z-axis
Rγ,z =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦
where cα = cosα and sα = sinα, etc.
Remember that the right-most transform is applied ﬁrst and the left-most trans-
form last. In terms of angles, the sequence is always α, β, γ .
For each composite transform you can verify that when α = β = γ = 0 the result
is the identity transform I.
We now examine the twelve combinations in turn.

A.2
Rγ,xRβ,yRα,x
201
A.2 Rγ,xRβ,yRα,x
Rγ,xRβ,yRα,x =
⎡
⎣
1
0
0
0
cγ
−sγ
0
sγ
cγ
⎤
⎦
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
=
⎡
⎣
cβ
sβsα
sβcα
sγ sβ
(cγ cα −sγ cβsα)
(−cγ sα −sγ cβcα)
−cγ sβ
(sγ cα + cγ cβsα)
(−sγ sα + cγ cβcα)
⎤
⎦
R90°,xR90°,yR90°,x =
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.1 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. A.1 Four views of the unit cube before and during the three rotations R90°,xR90°,yR90°,x

202
A
Composite Point Rotation Sequences
A.3 Rγ,xRβ,yRα,z
Rγ,xRβ,yRα,z =
⎡
⎣
1
0
0
0
cγ
−sγ
0
sγ
cγ
⎤
⎦
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
⎡
⎣
cα
−sα
0
sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
cβcα
−cβsα
sβ
(cγ sα + sγ sβcα)
(cγ cα −sγ sβsα)
−sγ cβ
(sγ sα −cγ sβcα)
(sγ cα + cγ sβsα)
cγ cβ
⎤
⎦
R90°,xR90°,yR90°,z =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.2 (a)–(d), where the axis of rotation
is [2
0
2]T and the angle of rotation 180°.
Fig. A.2 Four views of the unit cube before and during the three rotations R90°,xR90°,yR90°,z

A.4
Rγ,xRβ,zRα,x
203
A.4 Rγ,xRβ,zRα,x
Rγ,xRβ,zRα,x =
⎡
⎣
1
0
0
0
cγ
−sγ
0
sγ
cγ
⎤
⎦
⎡
⎣
cβ
−sβ
0
sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
=
⎡
⎣
cβ
−sβcα
sβsα
cγ sβ
(−sγ sα + cγ cβcα)
(−sγ cα −cγ cβsα)
sγ sβ
(cγ sα + sγ cβcα)
(cγ cα −sγ cβsα)
⎤
⎦
R90°,xR90°,zR90°,x =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.3 (a)–(d), where the axis of rotation
is [2
0
2]T and the angle of rotation 180°.
Fig. A.3 Four views of the unit cube before and during the three rotations R90°,xR90°,zR90°,x

204
A
Composite Point Rotation Sequences
A.5 Rγ,xRβ,zRα,y
Rγ,xRβ,zRα,y =
⎡
⎣
1
0
0
0
cγ
−sγ
0
sγ
cγ
⎤
⎦
⎡
⎣
cβ
−sβ
0
sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
cα
0
sα
0
1
0
−sα
0
cα
⎤
⎦
=
⎡
⎣
cβcα
−sβ
cβsα
(sγ sα + cγ sβcα)
cγ cβ
(−sγ cα + cγ sβsα)
(−cγ sα + sγ sβcα)
sγ cβ
(cγ cα + sγ sβsα)
⎤
⎦
R90°,xR90°,zR90°,y =
⎡
⎣
0
−1
0
1
0
0
0
0
1
⎤
⎦
⎡
⎣
0
−1
0
1
0
0
0
0
1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
0
1
0
1
0
1
0
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.4 (a)–(d), where the axis of rotation
is [0
0
2]T and the angle of rotation 90°.
Fig. A.4 Four views of the unit cube before and during the three rotations R90°,xR90°,zR90°,y

A.6
Rγ,yRβ,xRα,y
205
A.6 Rγ,yRβ,xRα,y
Rγ,yRβ,xRα,y =
⎡
⎣
cγ
0
sγ
0
1
0
−sγ
0
cγ
⎤
⎦
⎡
⎣
1
0
0
0
cβ
−sβ
0
sβ
cβ
⎤
⎦
⎡
⎣
cα
0
sα
0
1
0
−sα
0
cα
⎤
⎦
=
⎡
⎣
(cγ cα −sγ cβsα)
sγ sβ
(cγ sα + sγ cβcα)
sβsα
cβ
−sβcα
(−sγ cα −cγ cβsα)
cγ sβ
(−sγ sα + cγ cβcα)
⎤
⎦
R90°,yR90°,xR90°,y =
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.5 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. A.5 Four views of the unit cube before and during the three rotations R90°,yR90°,xR90°,y

206
A
Composite Point Rotation Sequences
A.7 Rγ,yRβ,xRα,z
Rγ,yRβ,xRα,z =
⎡
⎣
cγ
0
sγ
0
1
0
−sγ
0
cγ
⎤
⎦
⎡
⎣
1
0
0
0
cβ
−sβ
0
sβ
cβ
⎤
⎦
⎡
⎣
cα
−sα
0
sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
(cγ cα + sγ sβsα)
(−cγ sα + sγ sβcα)
sγ cβ
cβsα
cβcα
−sβ
(−sγ cα + cγ sβsα)
(sγ sα + cγ sβcα)
cγ cβ
⎤
⎦
R90°,yR90°,xR90°,z =
⎡
⎣
1
0
0
0
0
−1
0
1
0
⎤
⎦
⎡
⎣
1
0
0
0
0
−1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.6 (a)–(d), where the axis of rotation
is [2
0
0]T and the angle of rotation 90°.
Fig. A.6 Four views of the unit cube before and during the three rotations R90°,yR90°,xR90°,z

A.8
Rγ,yRβ,zRα,x
207
A.8 Rγ,yRβ,zRα,x
Rγ,yRβ,zRα,x =
⎡
⎣
cγ
0
sγ
0
1
0
−sγ
0
cγ
⎤
⎦
⎡
⎣
cβ
−sβ
0
sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
=
⎡
⎣
cγ cβ
(sγ sα −cγ sβcα)
(sγ cα + cγ sβsα)
sβ
cβcα
−cβsα
−sγ cβ
(cγ sα + sγ sβcα)
(cγ cα −sγ sβsα)
⎤
⎦
R90°,yR90°,zR90°,x =
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.7 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. A.7 Four views of the unit cube before and during the three rotations R90°,yR90°,zR90°,x

208
A
Composite Point Rotation Sequences
A.9 Rγ,yRβ,zRα,y
Rγ,yRβ,zRα,y =
⎡
⎣
cγ
0
sγ
0
1
0
−sγ
0
cγ
⎤
⎦
⎡
⎣
cβ
−sβ
0
sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
cα
0
sα
0
1
0
−sα
0
cα
⎤
⎦
=
⎡
⎣
(−sγ sα + cγ cβcα)
−cγ sβ
(sγ cα + cγ cβsα)
sβcα
cβ
sβsα
(−cγ sα −sγ cβcα)
sγ sβ
(cγ cα −sγ cβsα)
⎤
⎦
R90°,yR90°,zR90°,y =
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.8 (a)–(d), where the axis of rotation
is [0
2
2]T and the angle of rotation 180°.
Fig. A.8 Four views of the unit cube before and during the three rotations R90°,yR90°,zR90°,y

A.10
Rγ,zRβ,xRα,y
209
A.10 Rγ,zRβ,xRα,y
Rγ,zRβ,xRα,y =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cβ
−sβ
0
sβ
cβ
⎤
⎦
⎡
⎣
cα
0
sα
0
1
0
−sα
0
cα
⎤
⎦
=
⎡
⎣
(cγ cα −sγ sβsα)
−sγ cβ
(cγ sα + sγ sβcα)
(sγ cα + cγ sβsα)
cγ cβ
(sγ sα −cγ sβcα)
−cβsα
sβ
cβcα
⎤
⎦
R90°,zR90°,xR90°,y =
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.9 (a)–(d), where the axis of rotation
is [0
2
2]T and the angle of rotation 180°.
Fig. A.9 Four views of the unit cube before and during the three rotations R90°,zR90°,xR90°,y

210
A
Composite Point Rotation Sequences
A.11 Rγ,zRβ,xRα,z
Rγ,zRβ,xRα,z =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cβ
−sβ
0
sβ
cβ
⎤
⎦
⎡
⎣
cα
−sα
0
sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
(cγ cα −sγ cβsα)
(−cγ sα −sγ cβcα)
sγ sβ
(sγ cα + cγ cβsα)
(−sγ sα + cγ cβcα)
−cγ sβ
sβsα
sβcα
cβ
⎤
⎦
R90°,zR90°,xR90°,z =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.10 (a)–(d), where the axis of rota-
tion is [2
0
2]T and the angle of rotation 180°.
Fig. A.10 Four views of the unit cube before and during the three rotations R90°,zR90°,xR90°,z

A.12
Rγ,zRβ,yRα,x
211
A.12 Rγ,zRβ,yRα,x
Rγ,zRβ,yRα,x =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
⎡
⎣
1
0
0
0
cα
−sα
0
sα
cα
⎤
⎦
=
⎡
⎣
cγ cβ
(−sγ cα + cγ sβsα)
(sγ sα + cγ sβcα)
sγ cβ
(cγ cα + sγ sβsα)
(−cγ sα + sγ sβcα)
−sβ
cβsα
cβcα
⎤
⎦
R90°,zR90°,yR90°,x =
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
1
0
−1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
0
0
0
0
−1
−1
−1
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.11 (a)–(d), where the axis of rota-
tion is [0
2
0]T and the angle of rotation 90°.
Fig. A.11 Four views of the unit cube before and during the three rotations R90°,zR90°,yR90°,x

212
A
Composite Point Rotation Sequences
A.13 Rγ,zRβ,yRα,z
Rγ,zRβ,yRα,z =
⎡
⎣
cγ
−sγ
0
sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
cβ
0
sβ
0
1
0
−sβ
0
cβ
⎤
⎦
⎡
⎣
cα
−sα
0
sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
(−sγ sα + cγ cβcα)
(−sγ cα −cγ cβsα)
cγ sβ
(cγ sα + sγ cβcα)
(cγ cα −sγ cβsα)
sγ sβ
−sβcα
sβsα
cβ
⎤
⎦
R90°,zR90°,yR90°,z =
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. A.12 (a)–(d), where the axis of rota-
tion is [0
2
2]T and the angle of rotation 180°.
Fig. A.12 Four views of the unit cube before and during the three rotations R90°,zR90°,yR90°,z

Appendix B
Composite Frame Rotation Sequences
B.1 Euler Rotations
This appendix lists the twelve combinations of creating a composite frame rotation
sequence from R−1
α,x,R−1
β,y and R−1
γ,z, which are
R−1
γ,xR−1
β,yR−1
α,x,
R−1
γ,xR−1
β,yR−1
α,z,
R−1
γ,xR−1
β,zR−1
α,x,
R−1
γ,xR−1
β,zR−1
α,y
R−1
γ,yR−1
β,xR−1
α,y,
R−1
γ,yR−1
β,xR−1
α,z,
R−1
γ,yR−1
β,zR−1
α,x,
R−1
γ,yR−1
β,zR−1
α,y
R−1
γ,zR−1
β,xR−1
α,y,
R−1
γ,zR−1
β,xR−1
α,z,
R−1
γ,zR−1
β,yR−1
α,x,
R−1
γ,zR−1
β,yR−1
α,z.
For each combination there are three Euler frame rotation matrices, the resulting
composite matrix, a matrix where the three angles equal 90°, the coordinates of the
unit cube in the rotated frame, the axis and angle of rotation and a ﬁgure illustrating
the stages of rotation. To compute the axis of rotation [v1
v2
v3]T we use
v1 = (a22 −1)(a33 −1) −a23a32
v2 = (a33 −1)(a11 −1) −a31a13
v3 = (a11 −1)(a22 −1) −a12a21
where
R =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦
and for the angle of rotation δ we use
cosδ = 1
2

Tr(R) −1

.
We begin by deﬁning the three principal inverse Euler frame rotations:
rotate the frame α about the x-axis
R−1
α,x =
⎡
⎣
1
0
0
0
cα
sα
0
−sα
cα
⎤
⎦
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7, © Springer-Verlag London Limited 2011
213

214
B
Composite Frame Rotation Sequences
rotate the frame β about the y-axis
R−1
β,y =
⎡
⎣
cβ
0
−sβ
0
1
0
sβ
0
cβ
⎤
⎦
rotate the frame γ about the z-axis
R−1
γ,z =
⎡
⎣
cγ
sγ
0
−sγ
cγ
0
0
0
1
⎤
⎦
where cα = cosα and sα = sinα, etc.
Remember that the right-most transform is applied ﬁrst and the left-most trans-
form last. In terms of angles, the sequence is always α, β, γ .
For each composite transform you can verify that when α = β = γ = 0 the result
is the identity transform I.
We now examine the twelve combinations in turn.

B.2
R−1
γ,xR−1
β,yR−1
α,x
215
B.2 R−1
γ,xR−1
β,yR−1
α,x
R−1
γ,xR−1
β,yR−1
α,x =
⎡
⎣
1
0
0
0
cγ
sγ
0
−sγ
cγ
⎤
⎦
⎡
⎣
cβ
0
−sβ
0
1
0
sβ
0
cβ
⎤
⎦
⎡
⎣
1
0
0
0
cα
sα
0
−sα
cα
⎤
⎦
=
⎡
⎣
cβ
sβsα
−sβcα
sγ sβ
(cγ cα −sγ cβsα)
(cγ sα + sγ cβcα)
cγ sβ
(−sγ cα −cγ cβsα)
(−sγ sα + cγ cβcα)
⎤
⎦
R−1
90°,xR−1
90°,yR−1
90°,x =
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.1 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. B.1 Four views of the frame before and during the three rotations R−1
90°,xR−1
90°,yR−1
90°,x

216
B
Composite Frame Rotation Sequences
B.3 R−1
γ,xR−1
β,yR−1
α,z
R−1
γ,xR−1
β,yR−1
α,z =
⎡
⎣
1
0
0
0
cγ
sγ
0
−sγ
cγ
⎤
⎦
⎡
⎣
cβ
0
−sβ
0
1
0
sβ
0
cβ
⎤
⎦
⎡
⎣
cα
sα
0
−sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
cβcα
cβsα
−sβ
(−cγ sα + sγ sβcα)
(cγ cα + sγ sβsα)
+sγ cβ
(sγ sα + cγ sβcα)
(−sγ cα + cγ sβsα)
cγ cβ
⎤
⎦
R−1
90°,xR−1
90°,yR−1
90°,z =
⎡
⎣
0
0
−1
0
1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
−1
0
1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
−1
0
−1
0
−1
0
−1
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.2 (a)–(d), where the axis of rotation
is [0
2
0]T and the angle of rotation 90°.
Fig. B.2 Four views of the frame before and during the three rotations R−1
90°,xR−1
90°,yR−1
90°,z

B.4
R−1
γ,xR−1
β,zR−1
α,x
217
B.4 R−1
γ,xR−1
β,zR−1
α,x
R−1
γ,xR−1
β,zR−1
α,x =
⎡
⎣
1
0
0
0
cγ
sγ
0
−sγ
cγ
⎤
⎦
⎡
⎣
cβ
sβ
0
−sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cα
sα
0
−sα
cα
⎤
⎦
=
⎡
⎣
cβ
sβcα
sβsα
−cγ sβ
(−sγ sα + cγ cβcα)
(−sγ cα + cγ cβsα)
sγ sβ
(−cγ sα −sγ cβcα)
(cγ cα −sγ cβsα)
⎤
⎦
R−1
90°,xR−1
90°,zR−1
90°,x =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.3 (a)–(d), where the axis of rotation
is [2
0
2]T and the angle of rotation 180°.
Fig. B.3 Four views of the frame before and during the three rotations R−1
90°,xR−1
90°,zR−1
90°,x

218
B
Composite Frame Rotation Sequences
B.5 R−1
γ,xR−1
β,zR−1
α,y
R−1
γ,xR−1
β,zR−1
α,y =
⎡
⎣
1
0
0
0
cγ
sγ
0
−sγ
cγ
⎤
⎦
⎡
⎣
cβ
sβ
0
−sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
cα
0
−sα
0
1
0
sα
0
cα
⎤
⎦
=
⎡
⎣
cβcα
sβ
−cβsα
(sγ sα −cγ sβcα)
cγ cβ
(sγ cα + cγ sβsα)
(cγ sα + sγ sβcα)
−sγ cβ
(cγ cα −sγ sβsα)
⎤
⎦
R−1
90°,xR−1
90°,zR−1
90°,y =
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.4 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. B.4 Four views of the frame before and during the three rotations R−1
90°,xR−1
90°,zR−1
90°,y

B.6
R−1
γ,yR−1
β,xR−1
α,y
219
B.6 R−1
γ,yR−1
β,xR−1
α,y
R−1
γ,yR−1
β,xR−1
α,y =
⎡
⎣
cγ
0
−sγ
0
1
0
sγ
0
cγ
⎤
⎦
⎡
⎣
1
0
0
0
cβ
sβ
0
−sβ
cβ
⎤
⎦
⎡
⎣
cα
0
−sα
0
1
0
sα
0
cα
⎤
⎦
=
⎡
⎣
(cγ cα −sγ cβsα)
sγ sβ
(−cγ sα −sγ cβcα)
sβsα
cβ
sβcα
(sγ cα + cγ cβsα)
−cγ sβ
(−sγ sα + cγ cβcα)
⎤
⎦
R−1
90°,yR−1
90°,xR−1
90°,y =
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
1
0
1
0
0
0
0
−1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
1
1
1
1
0
−1
0
−1
0
−1
0
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.5 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. B.5 Four views of the frame before and during the three rotations R−1
90°,yR−1
90°,xR−1
90°,y

220
B
Composite Frame Rotation Sequences
B.7 R−1
γ,yR−1
β,xR−1
α,z
R−1
γ,yR−1
β,xR−1
α,z =
⎡
⎣
cγ
0
−sγ
0
1
0
sγ
0
cγ
⎤
⎦
⎡
⎣
1
0
0
0
cβ
sβ
0
−sβ
cβ
⎤
⎦
⎡
⎣
cα
sα
0
−sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
(cγ cα −sγ sβsα)
(cγ sα + sγ sβcα)
−sγ cβ
−cβsα
cβcα
sβ
(sγ cα + cγ sβsα)
(sγ sα −cγ sβcα)
cγ cβ
⎤
⎦
R−1
90°,yR−1
90°,xR−1
90°,z =
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.6 (a)–(d), where the axis of rotation
is [0
2
2]T and the angle of rotation 180°.
Fig. B.6 Four views of the frame before and during the three rotations R−1
90°,yR−1
90°,xR−1
90°,z

B.8
R−1
γ,yR−1
β,zR−1
α,x
221
B.8 R−1
γ,yR−1
β,zR−1
α,x
R−1
γ,yR−1
β,zR−1
α,x =
⎡
⎣
cγ
0
−sγ
0
1
0
sγ
0
cγ
⎤
⎦
⎡
⎣
cβ
sβ
0
−sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cα
sα
0
−sα
cα
⎤
⎦
=
⎡
⎣
cγ cβ
(sγ sα + cγ sβcα)
(−sγ cα + cγ sβsα)
−sβ
cβcα
cβsα
sγ cβ
(−cγ sα + sγ sβcα)
(cγ cα + sγ sβsα)
⎤
⎦
R−1
90°,yR−1
90°,zR−1
90°,x =
⎡
⎣
0
1
0
−1
0
0
0
0
1
⎤
⎦
⎡
⎣
0
1
0
−1
0
0
0
0
1
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
1
1
0
0
1
1
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.7 (a)–(d), where the axis of rotation
is [2
2
0]T and the angle of rotation 180°.
Fig. B.7 Four views of the frame before and during the three rotations R−1
90°,yR−1
90°,zR−1
90°,x

222
B
Composite Frame Rotation Sequences
B.9 R−1
γ,yR−1
β,zR−1
α,y
R−1
γ,yR−1
β,zR−1
α,y =
⎡
⎣
cγ
0
−sγ
0
1
0
sγ
0
cγ
⎤
⎦
⎡
⎣
cβ
sβ
0
−sβ
cβ
0
0
0
1
⎤
⎦
⎡
⎣
cα
0
−sα
0
1
0
sα
0
cα
⎤
⎦
=
⎡
⎣
(−sγ sα + cγ cβcα)
cγ sβ
(−sγ cα −cγ cβsα)
−sβcα
cβ
sβsα
(cγ sα + sγ cβcα)
sγ sβ
(cγ cα −sγ cβsα)
⎤
⎦
R−1
90°,yR−1
90°,zR−1
90°,y =
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.8 (a)–(d), where the axis of rotation
is [0
2
2]T and the angle of rotation 180°.
Fig. B.8 Four views of the frame before and during the three rotations R−1
90°,yR−1
90°,zR−1
90°,y

B.10
R−1
γ,zR−1
β,xR−1
α,y
223
B.10 R−1
γ,zR−1
β,xR−1
α,y
R−1
γ,zR−1
β,xR−1
α,y =
⎡
⎣
cγ
sγ
0
−sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cβ
sβ
0
−sβ
cβ
⎤
⎦
⎡
⎣
cα
0
−sα
0
1
0
sα
0
cα
⎤
⎦
=
⎡
⎣
(cγ cα + sγ sβsα)
sγ cβ
(−cγ sα + sγ sβcα)
(−sγ cα + cγ sβsα)
cγ cβ
(sγ sα + cγ sβcα)
cβsα
−sβ
cβcα
⎤
⎦
R−1
90°,zR−1
90°,xR−1
90°,y =
⎡
⎣
1
0
0
0
0
1
0
−1
0
⎤
⎦
⎡
⎣
1
0
0
0
0
1
0
−1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
1
1
1
1
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.9 (a)–(d), where the axis of rotation
is [2
0
0]T and the angle of rotation 90°.
Fig. B.9 Four views of the frame before and during the three rotations R−1
90°,zR−1
90°,xR−1
90°,y

224
B
Composite Frame Rotation Sequences
B.11 R−1
γ,zR−1
β,xR−1
α,z
R−1
γ,zR−1
β,xR−1
α,z =
⎡
⎣
cγ
sγ
0
−sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
1
0
0
0
cβ
sβ
0
−sβ
cβ
⎤
⎦
⎡
⎣
cα
sα
0
−sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
(cγ cα −sγ cβsα)
(cγ sα + sγ cβcα)
sγ sβ
(−sγ cα −cγ cβsα)
(−sγ sα + cγ cβcα)
+cγ sβ
sβsα
−sβcα
cβ
⎤
⎦
R−1
90°,zR−1
90°,xR−1
90°,z =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.10 (a)–(d), where the axis of rota-
tion is [2
0
2]T and the angle of rotation 180°.
Fig. B.10 Four views of the frame before and during the three rotations R−1
90°,zR−1
90°,xR−1
90°,z

B.12
R−1
γ,zR−1
β,yR−1
α,x
225
B.12 R−1
γ,zR−1
β,yR−1
α,x
R−1
γ,zR−1
β,yR−1
α,x =
⎡
⎣
cγ
sγ
0
−sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
cβ
0
−sβ
0
1
0
sβ
0
cβ
⎤
⎦
⎡
⎣
1
0
0
0
cα
sα
0
−sα
cα
⎤
⎦
=
⎡
⎣
cγ cβ
(sγ cα + cγ sβsα)
(sγ sα −cγ sβcα)
−sγ cβ
(cγ cα −sγ sβsα)
(cγ sα + sγ sβcα)
sβ
−cβsα
cβcα
⎤
⎦
R−1
90°,zR−1
90°,yR−1
90°,x =
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
1
0
−1
0
1
0
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
1
0
1
0
1
0
1
0
0
−1
−1
0
0
−1
−1
0
0
0
0
1
1
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.11 (a)–(d), where the axis of rota-
tion is [2
0
2]T and the angle of rotation 180°.
Fig. B.11 Four views of the frame before and during the three rotations R−1
90°,zR−1
90°,yR−1
90°,x

226
B
Composite Frame Rotation Sequences
B.13 R−1
γ,zR−1
β,yR−1
α,z
R−1
γ,zR−1
β,yR−1
α,z =
⎡
⎣
cγ
sγ
0
−sγ
cγ
0
0
0
1
⎤
⎦
⎡
⎣
cβ
0
−sβ
0
1
0
sβ
0
cβ
⎤
⎦
⎡
⎣
cα
sα
0
−sα
cα
0
0
0
1
⎤
⎦
=
⎡
⎣
(−sγ sα + cγ cβcα)
(sγ cα + cγ cβsα)
−cγ sβ
(−cγ sα −sγ cβcα)
(cγ cα −sγ cβsα)
sγ sβ
sβcα
sβsα
cβ
⎤
⎦
R−1
90°,zR−1
90°,yR−1
90°,z =
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
−1
0
0
0
0
1
0
1
0
⎤
⎦
⎡
⎣
0
0
0
0
1
1
1
1
0
0
1
1
0
0
1
1
0
1
0
1
0
1
0
1
⎤
⎦
=
⎡
⎣
0
0
0
0
−1
−1
−1
−1
0
1
0
1
0
1
0
1
0
0
1
1
0
0
1
1
⎤
⎦.
This rotation sequence is illustrated in Fig. B.12 (a)–(d), where the axis of rota-
tion is [0
2
2]T and the angle of rotation 180°.
Fig. B.12 Four views of the frame before and during the three rotations R−1
90°,zR−1
90°,yR−1
90°,z

Appendix C
The Four n-Square Algebras
C.1 Introduction
The magnitude of a real quantity is its positive value. However, when dealing with
objects such as complex numbers, quaternions and octonions, their magnitude is
expressed using the Pythagorean formula which takes the square root of the sums of
the terms squared.
For example, the magnitude of a complex number z1 = a + bi is
|z1| =

a2 + b2
and the magnitude of a quaternion q = s + xi + yj + zk is
|q| =
	
s2 + x2 + y2 + z2
and something similar for an octonion, which has 8 terms.
In their book On Quaternions and Octonions [9], John Conway and Derek Smith
use the Euclidean norm N to represent the sums of the squares, although other au-
thors deﬁne the Euclidean norm as
√
N. However, for the purpose of this description
I will employ Conway and Smith’s deﬁnition. Thus
N(a + bi) = a2 + b2
and
N(q) = s2 + x2 + y2 + z2.
We know from the algebra of complex numbers that
|z1||z2| = |z1z2|
or
N(z1)N(z2) = N(z1z2)
and from the algebra of quaternions that
|q1||q2| = |q1q2|
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7, © Springer-Verlag London Limited 2011
227

228
C
The Four n-Square Algebras
or
N(q1)N(q2) = N(q1q2).
The algebra of octonions also includes this composition law.
In the algebra of reals R, we have
x2
1y2
1 = (x1y1)2.
In the algebra of complex numbers C, we have
z1 = x1 + x2i
z2 = y1 + y2i

x2
1 + x2
2

y2
1 + y2
2

= (x1y1 −x2y2)2 + (x1y2 + x2y1)2.
In the algebra of quaternions H, we have
q1 = x1 + x2i + x3j + x4k
q2 = y1 + y2i + y3j + y4k

x2
1 + x2
2 + x2
3 + x2
4

y2
1 + y2
2 + y2
3 + y2
4

= (x1y1 −x2y2 −x3y3 −x4y4)2
+ (x1y2 + x2y1 + x3y4 −x4y3)2
+ (x1y3 −x2y4 + x3y1 + x4y2)2
+ (x1y4 + x2y3 −x3y2 + x4y1)2.
And in the algebra of octonions O, we have something similar, but with many more
terms.
The above algebras are called composition algebras because of their inherent
composition law, and Adolf Hurwitz proved that such algebras can only exist in 1,
2, 4 and 8 dimensions.

References
1. Crowe, M.J.: A History of Vector Analysis. Dover, New York (1994)
2. Hamilton, W.R.: Lectures on Quaternions. Hodges and Smith, Dublin (1853)
3. Gibbs, J.W.: Elements of Vector Analysis. Tuttle, Moorehouse & Taylor, New Haven (1884)
4. Vince, J.A.: Mathematics for Computer Graphics. Springer, London (2010)
5. Vince, J.A.: Geometric Algebra for Computer Graphics. Springer, London (2008)
6. Vince, J.A.: Geometric Algebra: An Algebraic System for Computer Games and Animation.
Springer, London (2009)
7. Altmann, S.: Hamilton, Rodrigues and the quaternion scandal. Math. Mag. 62(5), 291–308
(1989)
8. Stillwell, J.: Numbers and Geometry. Springer, New York (1998)
9. Conway, J., Smith, D.: On Quaternions and Octonions. AK Peters, Natick (2003)
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7, © Springer-Verlag London Limited 2011
229


Index
2D frames of reference, 103
2D rotation transform, 87
2D rotor, 188
2D transforms, 85
3D frames of reference, 143
3D rotations, 184
3D rotor, 189
3D transforms, 115
3D vectors, 19
A
Adding quaternions, 60
Afﬁne transform, 90
Antisymmetric functions, 67
Antisymmetric matrix, 48
B
Bivector, 70, 93
Bivector rotors, 181
C
Cartesian vector, 21
Cayley, Arthur, 33, 155
Characteristic equation, 52, 123
Clifford, William Kingdon, 67
Cofactors of a matrix, 41
Column vector, 17
Commutative, 20
Complex addition, 7
Complex argument, 12
Complex conjugate, 8
Complex division, 8
Complex inverse, 9
Complex number axioms, 6
Complex numbers, 5
Complex plane, 10
Complex product, 7
Complex rotor, 13
Composite rotations, 91, 118, 149
Composition algebras, 155
Cross product, 24
D
Determinant of a matrix, 39
Diagonal matrix, 45
Direction cosines, 2D, 109
Dot product, 22
Duality, 80
E
Eigenvalue, 50, 169
Eigenvector, 50, 123, 169
Euler, Leonhard, 10
Euler rotations, 116
Extracting a rotor, 191
F
Frames of reference, 103, 143, 171
G
Geometric product, 69, 71
Gibbs, Josiah, 25, 59
Gimbal lock, 130
Grades, 75
H
Hamilton, William Rowan, 17, 24, 59, 155
Hamilton’s rules, 25, 59, 81
Hestenes, David, 67
Homogeneous coordinates, 85
Hurwitz, Adolph, 155
I
Identity matrix, 35
Imaginary, 5
J. Vince, Rotation Transforms for Computer Graphics,
DOI 10.1007/978-0-85729-154-7, © Springer-Verlag London Limited 2011
231

232
Index
Inner product, 69
Interpolating quaternions, 173
Interpolating vectors, 28
Inverse matrix, 37
Inverse of a vector, 77
Inverse quaternion, 64
Inverse transforms, 92
L
Laplace, Pierre Simon, 41
Laplace expansion, 42
M
Magnitude of a quaternion, 62
Magnitude of a vector, 18
Matrices, 33
Matrix addition, 35
Matrix inverse, 42
Matrix notation, 33
Matrix product, 36
Matrix transforms, 86
Matrix transpose, 35
Minor determinant, 40
Modulus of a complex number, 6
Multiplying quaternions, 61
Multivector axioms, 74
Multivector rotor, 97
Multivector transforms, 93
Multivectors, 67, 75
N
Non-commutative, 37, 60
O
Octonions, 155
Orthogonal matrix, 45
Outer product, 69
Outer product of three vectors, 73
P
Pitch, 132
Polar representation, 11
Position vector, 20
Pseudoscalars, 75
Pure quaternion, 62
Q
Quaternion addition, 60
Quaternion axioms, 60
Quaternion conjugate, 63
Quaternion matrix, 162
Quaternion multiplication, 61
Quaternions, 59, 81, 155
R
Reﬂecting a vector, 182
Reverse of a multivector, 82
Right-hand rule, 27
Rodrigues, Olinde, 139
Roll, 132
Rotate a point, 116
Rotated frames, 106
Rotating about an axis, 117, 134
Rotation in the plane, 85
Rotation transform, 45
Rotation transforms in space, 115
Rotor matrices, 188
Row vector, 17
S
Sarrus, J.P., 39
Scalar product, 22
Skew symmetric matrix, 48
Spherical interpolant, 176
Square matrix, 39, 46
Subtracting quaternions, 60
Symmetric functions, 67
Symmetric matrix, 47
T
Three reﬂections theorem, 181
Trace of a matrix, 46
Translate a point, 115
Translated frames, 104
Translation transform, 87
Trivector, 74, 75, 93
U
Unit bivector, 94
Unit normal vector, 27
Unit quaternion, 62
Unit vector, 21
V
Vector addition, 20
Vector interpolation, 28
Vector inverse, 77
Vector magnitude, 18
Vector notation, 17
Vector product, 24, 55
Vector subtraction, 20
W
Wedge product, 73
Y
Yaw, 132

